{"code": "static void evtchn_fifo_handle_events(unsigned cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, false);\n}", "target": 1}
{"code": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\nexit:\n    return error;\n}", "target": 1}
{"code": "static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)\n{\n\tUINT32 left = originalSize;\n\twhile (left > 4)\n\t{\n\t\tconst BYTE value = *in++;\n\t\tUINT32 len = 0;\n\t\tif (left == 5)\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32)*in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = ((UINT32)(*in++));\n\t\t\t\tlen |= ((UINT32)(*in++)) << 8U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 16U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 24U;\n\t\t\t}\n\t\t\tif (outSize < len)\n\t\t\t\treturn FALSE;\n\t\t\toutSize -= len;\n\t\t\tFillMemory(out, len, value);\n\t\t\tout += len;\n\t\t\tleft -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t}\n\tif ((outSize < 4) || (left < 4))\n\t\treturn FALSE;\n\tmemcpy(out, in, 4);\n\treturn TRUE;\n}", "target": 1}
{"code": "struct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new(const ut8* buf, ut64 size) {\n\tstruct r_bin_dyldcache_obj_t *bin;\n\tif (!(bin = malloc (sizeof (struct r_bin_dyldcache_obj_t)))) {\n\t\treturn NULL;\n\t}\n\tmemset (bin, 0, sizeof (struct r_bin_dyldcache_obj_t));\n\tif (!buf) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->b = r_buf_new();\n\tif (!r_buf_set_bytes (bin->b, buf, size)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->size = size;\n\treturn bin;\n}", "target": 1}
{"code": "int main()\n{\n   initialize_environment();\n   test_format_wrong_size();\n   test_blit_info_format_check();\n   test_blit_info_format_check_null_format();\n   test_format_is_plain_nullptr_deref_trigger();\n   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();\n   test_format_util_format_is_rgb_nullptr_deref_trigger();\n   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();\n   test_double_free_in_vrend_renderer_blit_int_trigger();\n   test_format_is_has_alpha_nullptr_deref_trigger_original();\n   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();\n   test_heap_overflow_vrend_renderer_transfer_write_iov();\n   virgl_renderer_context_destroy(ctx_id);\n   virgl_renderer_cleanup(&cookie);\n   virgl_egl_destroy(test_egl);\n   return 0;\n}", "target": 1}
{"code": "static void nalm_dump(FILE * trace, char *data, u32 data_size)\n{\n\tGF_BitStream *bs;\n\tBool rle, large_size;\n\tu32 entry_count;\n\tif (!data) {\n\t\tfprintf(trace, \"<NALUMap rle=\\\"\\\" large_size=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<NALUMapEntry NALU_startNumber=\\\"\\\" groupID=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</NALUMap>\\n\");\n\t\treturn;\n\t}\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tgf_bs_read_int(bs, 6);\n\tlarge_size = gf_bs_read_int(bs, 1);\n\trle = gf_bs_read_int(bs, 1);\n\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\tfprintf(trace, \"<NALUMap rle=\\\"%d\\\" large_size=\\\"%d\\\">\\n\", rle, large_size);\n\twhile (entry_count) {\n\t\tu32 ID;\n\t\tfprintf(trace, \"<NALUMapEntry \");\n\t\tif (rle) {\n\t\t\tu32 start_num = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tfprintf(trace, \"NALU_startNumber=\\\"%d\\\" \", start_num);\n\t\t}\n\t\tID = gf_bs_read_u16(bs);\n\t\tfprintf(trace, \"groupID=\\\"%d\\\"/>\\n\", ID);\n\t\tentry_count--;\n\t}\n\tgf_bs_del(bs);\n\tfprintf(trace, \"</NALUMap>\\n\");\n\treturn;\n}", "target": 1}
{"code": "void RenderThreadImpl::Shutdown() {\n  FOR_EACH_OBSERVER(\n      RenderProcessObserver, observers_, OnRenderProcessShutdown());\n  ChildThread::Shutdown();\n  if (memory_observer_) {\n    message_loop()->RemoveTaskObserver(memory_observer_.get());\n    memory_observer_.reset();\n  }\n   if (webkit_platform_support_) {\n     webkit_platform_support_->web_database_observer_impl()->\n         WaitForAllDatabasesToClose();\n   }\n  if (devtools_agent_message_filter_.get()) {\n    RemoveFilter(devtools_agent_message_filter_.get());\n    devtools_agent_message_filter_ = NULL;\n  }\n  RemoveFilter(audio_input_message_filter_.get());\n  audio_input_message_filter_ = NULL;\n  RemoveFilter(audio_message_filter_.get());\n  audio_message_filter_ = NULL;\n#if defined(ENABLE_WEBRTC)\n  RTCPeerConnectionHandler::DestructAllHandlers();\n  peer_connection_factory_.reset();\n#endif\n  RemoveFilter(vc_manager_->video_capture_message_filter());\n  vc_manager_.reset();\n  RemoveFilter(db_message_filter_.get());\n  db_message_filter_ = NULL;\n  if (file_thread_)\n    file_thread_->Stop();\n  if (compositor_output_surface_filter_.get()) {\n    RemoveFilter(compositor_output_surface_filter_.get());\n    compositor_output_surface_filter_ = NULL;\n  }\n  media_thread_.reset();\n  compositor_thread_.reset();\n  input_handler_manager_.reset();\n  if (input_event_filter_.get()) {\n    RemoveFilter(input_event_filter_.get());\n    input_event_filter_ = NULL;\n  }\n  embedded_worker_dispatcher_.reset();\n  main_thread_indexed_db_dispatcher_.reset();\n  if (webkit_platform_support_)\n    blink::shutdown();\n  lazy_tls.Pointer()->Set(NULL);\n#if defined(OS_WIN)\n  NPChannelBase::CleanupChannels();\n#endif\n}", "target": 1}
{"code": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}", "target": 1}
{"code": "    bool CFontFileType1::RemovePfbMarkers()\n    {\n        bool bSuccess = true;\n        int nBlockType = 0;\n        int nBlockLen  = 0;\n        int nChar = 0;\n        unsigned char *sBuffer = NULL;\n        int nBufLen = 0;\n        while ( nBlockType != PFB_DONE )\n        {\n            while ( 0 == nBlockLen )\n            {\n                nChar = ReadU8( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n                nBlockType = ReadU8( &bSuccess );\n                if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType && PFB_BINARY != nBlockType && PFB_DONE != nBlockType ) )\n                    return false;\n                if ( PFB_DONE == nBlockType )\n                    break;\n                nBlockLen = ReadU32LE( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n            }\n            if ( nBlockLen > 0 )\n            {\n                if ( !sBuffer )\n                {\n                    sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );\n                    if ( !sBuffer )\n                        return false;\n                }\n                else\n                    sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );\n                Read( sBuffer + nBufLen, nBlockLen );\n                nBufLen += nBlockLen;\n            }\n            nBlockLen = 0;\n        }\n        if ( m_bFreeFileData )\n            MemUtilsFree( m_sFile );\n        m_bFreeFileData = true;\n        m_sFile         = (unsigned char*)sBuffer;\n        m_sFileData     = m_sFile;\n        m_nLen          = nBufLen;\n        m_nPos          = 0;\n        return true;\n    }", "target": 1}
{"code": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\tif (!mm)\n\t\treturn 0;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\t\tthis_len = env_end - (env_start + src);\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\t\tretval = access_remote_vm(mm, (env_start + src),\n\t\t\tpage, this_len, 0);\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}", "target": 1}
{"code": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\treturn &tpg->se_tpg;\n}", "target": 1}
{"code": "void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\tif (!handle)\n\t\treturn NULL;\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\treturn pointer;\n}", "target": 1}
{"code": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n \t\treturn NULL;\n \t}\n \tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n \t\tr_asn1_free_object (object);\n \t\tfree (container);\n \t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}", "target": 1}
{"code": "folly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes,\n    std::unique_ptr<HTTPMessage>& msg) {\n  Cursor headerCursor(curHeaderBlock_.front());\n  bool isReq = false;\n  if (promisedStream) {\n    isReq = true;\n  } else if (exAttributes) {\n    isReq = isRequest(curHeader_.stream);\n  } else {\n    isReq = transportDirection_ == TransportDirection::DOWNSTREAM;\n  }\n  decodeInfo_.init(isReq, parsingDownstreamTrailers_);\n  if (priority) {\n    if (curHeader_.stream == priority->streamDependency) {\n      streamError(folly::to<string>(\"Circular dependency for txn=\",\n                                    curHeader_.stream),\n                  ErrorCode::PROTOCOL_ERROR,\n                  curHeader_.type == http2::FrameType::HEADERS);\n      return ErrorCode::NO_ERROR;\n    }\n    decodeInfo_.msg->setHTTP2Priority(\n        std::make_tuple(priority->streamDependency,\n                        priority->exclusive,\n                        priority->weight));\n  }\n  headerCodec_.decodeStreaming(\n      headerCursor, curHeaderBlock_.chainLength(), this);\n  msg = std::move(decodeInfo_.msg);\n  auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });\n  if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {\n    static const std::string decodeErrorMessage =\n        \"Failed decoding header block for stream=\";\n    if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream\n                 << \" header block=\";\n      VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    } else {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream;\n    }\n    if (msg) {\n      msg->dumpMessage(3);\n    }\n    return ErrorCode::COMPRESSION_ERROR;\n  }\n  if (decodeInfo_.parsingError != \"\") {\n    LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream\n               << \", error=\" << decodeInfo_.parsingError << \", header block=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    HTTPException err(HTTPException::Direction::INGRESS,\n                      folly::to<std::string>(\"HTTP2Codec stream error: \",\n                                             \"stream=\",\n                                             curHeader_.stream,\n                                             \" status=\",\n                                             400,\n                                             \" error: \",\n                                             decodeInfo_.parsingError));\n    err.setHttpStatusCode(400);\n    callback_->onError(curHeader_.stream, err, true);\n    return ErrorCode::NO_ERROR;\n  }\n  return folly::Optional<ErrorCode>();\n}", "target": 1}
{"code": "void Utf8DecoderBase::WriteUtf16Slow(const uint8_t* stream,\n                                     uint16_t* data,\n                                     unsigned data_length) {\n  while (data_length != 0) {\n    unsigned cursor = 0;\n    uint32_t character = Utf8::ValueOf(stream, Utf8::kMaxEncodedSize, &cursor);\n    stream += cursor;\n    if (character > unibrow::Utf16::kMaxNonSurrogateCharCode) {\n      *data++ = Utf16::LeadSurrogate(character);\n      *data++ = Utf16::TrailSurrogate(character);\n      DCHECK(data_length > 1);\n      data_length -= 2;\n    } else {\n      *data++ = character;\n      data_length -= 1;\n    }\n  }\n}", "target": 1}
{"code": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\tif (info.si_code >= 0)\n\t\treturn -EPERM;\n\tinfo.si_signo = sig;\n\treturn kill_proc_info(sig, &info, pid);\n}", "target": 1}
{"code": "static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest, int *setmeta,\n\t\t     int * firsthardlink)\n{\n    int rc = 0;\n    int numHardlinks = rpmfiFNlink(fi);\n    if (numHardlinks > 1) {\n\tif (*firsthardlink < 0) {\n\t    *firsthardlink = rpmfiFX(fi);\n\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n\t} else {\n\t    char *fn = rpmfilesFN(files, *firsthardlink);\n\t    rc = link(fn, dest);\n\t    if (rc < 0) {\n\t\trc = RPMERR_LINK_FAILED;\n\t    }\n\t    free(fn);\n\t}\n    }\n    if (numHardlinks<=1) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n    } else if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n\t*firsthardlink = -1;\n    } else {\n\t*setmeta = 0;\n    }\n    return rc;\n}", "target": 1}
{"code": "void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext)\n{\n    std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x)\n    {\n        if(ext.remove_emoji)\n            x.Remark = trim(removeEmoji(x.Remark));\n        nodeRename(x, ext.rename_array, ext);\n        if(ext.add_emoji)\n            x.Remark = addEmoji(x, ext.emoji_array, ext);\n    });\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size())\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                try\n                {\n                    ctx.eval(script);\n                    auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(\"compare\");\n                    auto comparer = [&](const Proxy &a, const Proxy &b)\n                    {\n                        if(a.Type == ProxyType::Unknow)\n                            return 1;\n                        if(b.Type == ProxyType::Unknow)\n                            return 0;\n                        return compare(a, b);\n                    };\n                    std::stable_sort(nodes.begin(), nodes.end(), comparer);\n                    failed = false;\n                }\n                catch(qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n        }\n        if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b)\n        {\n            return a.Remark < b.Remark;\n        });\n    }\n}", "target": 1}
{"code": "static int i2c_ddc_rx(I2CSlave *i2c)\n{\n    I2CDDCState *s = I2CDDC(i2c);\n    int value;\n    value = s->edid_blob[s->reg];\n    s->reg++;\n    return value;\n}", "target": 1}
{"code": "void CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n  order = 0x4949;\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, strip_offset+row*4, SEEK_SET);\n    fseek (ifp, data_offset+get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7:4;\n    for (col=0; col < raw_width; col+=16) {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c]) {\n\tcase 3: len[c] = ph1_bits(4);\tbreak;\n\tcase 2: len[c]--;\t\tbreak;\n\tcase 1: len[c]++;\n      }\n      for (c=0; c < 16; c+=2) {\n\ti = len[((c & 1) << 1) | (c >> 3)];\n        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n\tif (c == 14) c = -1;\n      }\n    }\n  }\n  for (row=0; row < raw_height-1; row+=2)\n    for (col=0; col < raw_width-1; col+=2)\n      SWAP (RAW(row,col+1), RAW(row+1,col));\n}", "target": 1}
{"code": "char *ReadInput(char *filename)\n{\n    FILE *finput;\n    long filesize, num;\n    char *buffer;\n    if ( ( finput = fopen(filename,\"r\") ) == 0 ) {\n        fprintf(stderr,\"%s: Cannot open file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    if ( ( fseek(finput,0,SEEK_END) != 0 )\n      || ( ( filesize = ftell(finput) ) < 0 )\n      || ( fseek(finput,0,SEEK_SET) != 0 ) ) {\n        fprintf(stderr,\"%s: File error in file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    if ( ( buffer = malloc((filesize+1)*sizeof(char)) ) == 0 ) {\n        fprintf(stderr,\"%s: Error allocating %ld bytes of memory\",axohelp,filesize+1);\n        exit(-1);\n    }\n    num = fread( buffer, 1, filesize, finput );\n    if ( ferror(finput) ) {\n        fprintf(stderr,\"%s: Error reading file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    buffer[num] = 0;\n    fclose(finput);\n    return(buffer);\n}", "target": 1}
{"code": "static Jsi_RC StringSearchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *source_str;\n    ChkString(_this, funcPtr, source_str, &sLen, &bLen);\n    char *v = _this->d.obj->d.s.str;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n    if (Jsi_ValueIsString(interp, seq)) {\n        char *ce, *cp = Jsi_ValueString(interp, seq, NULL);\n        int n = -1;\n        if ((ce = Jsi_Strstr(source_str, cp))) {\n            n = (ce-source_str);\n        }\n        Jsi_ValueMakeNumber(interp, ret, n);\n        return JSI_OK;\n    }\n    if (!seq || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNumber(interp, ret, -1);\n        return JSI_OK;\n    }\n    regex_t *reg = &seq->d.obj->d.robj->reg;\n    regmatch_t pos[MAX_SUBREGEX] = {};\n    int r;\n    if ((r = regexec(reg, v, MAX_SUBREGEX, pos, 0)) != 0) {\n        if (r == REG_NOMATCH) {\n            Jsi_ValueMakeNumber(interp, ret, -1.0);\n            return JSI_OK;\n        }\n        if (r >= REG_BADPAT) {\n            char buf[100];\n            regerror(r, reg, buf, sizeof(buf));\n            Jsi_LogError(\"error while matching pattern: %s\", buf);\n            return JSI_ERROR;\n        }\n    }\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos[0].rm_so);\n    return JSI_OK;\n}", "target": 1}
{"code": "static int hns_gmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_gmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "bool OutOfProcessInstance::Init(uint32_t argc,\n                                 const char* argn[],\n                                 const char* argv[]) {\n   pp::Var document_url_var = pp::URLUtil_Dev::Get()->GetDocumentURL(this);\n  std::string document_url = document_url_var.is_string() ?\n      document_url_var.AsString() : std::string();\n   std::string extension_url = std::string(kChromeExtension);\n  bool in_extension =\n      !document_url.compare(0, extension_url.size(), extension_url);\n  if (in_extension) {\n    for (uint32_t i = 0; i < argc; ++i) {\n      if (strcmp(argn[i], \"full-frame\") == 0) {\n        full_ = true;\n        break;\n      }\n     }\n   }\n  if (full_)\n    SetPluginToHandleFindRequests();\n  pp::VarDictionary translated_strings;\n  translated_strings.Set(kType, kJSSetTranslatedStringsType);\n  translated_strings.Set(kJSGetPasswordString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFGETPASSWORD));\n  translated_strings.Set(kJSLoadingString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFLOADING));\n  translated_strings.Set(kJSLoadFailedString,\n      GetLocalizedString(PP_RESOURCESTRING_PDFLOAD_FAILED));\n  PostMessage(translated_strings);\n  text_input_.reset(new pp::TextInput_Dev(this));\n  const char* stream_url = nullptr;\n  const char* original_url = nullptr;\n  const char* headers = nullptr;\n  bool is_material = false;\n  for (uint32_t i = 0; i < argc; ++i) {\n    if (strcmp(argn[i], \"src\") == 0)\n      original_url = argv[i];\n    else if (strcmp(argn[i], \"stream-url\") == 0)\n      stream_url = argv[i];\n    else if (strcmp(argn[i], \"headers\") == 0)\n      headers = argv[i];\n    else if (strcmp(argn[i], \"is-material\") == 0)\n      is_material = true;\n    else if (strcmp(argn[i], \"top-toolbar-height\") == 0)\n      base::StringToInt(argv[i], &top_toolbar_height_);\n  }\n  if (is_material)\n    background_color_ = kBackgroundColorMaterial;\n  else\n    background_color_ = kBackgroundColor;\n  if (!original_url)\n    return false;\n  if (!stream_url)\n    stream_url = original_url;\n  if (IsPrintPreviewUrl(original_url))\n    return true;\n  LoadUrl(stream_url);\n  url_ = original_url;\n  return engine_->New(original_url, headers);\n}", "target": 1}
{"code": "static static void adpt_delay(int millisec)\n{\n\tint i;\n\tfor (i = 0; i < millisec; i++) {\n\t\tudelay(1000);\t\n\t}\n}", "target": 1}
{"code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint           i, j, ret;\n\tunsigned char count;\n\tif (flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\tif ( (scd->curbit + code_size) >= scd->lastbit) {\n\t\tif (scd->done) {\n\t\t\tif (scd->curbit >= scd->lastbit) {\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tscd->buf[0] = scd->buf[scd->last_byte-2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte-1];\n               if ((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0)\n\t\t\tscd->done = TRUE;\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2+count)*8 ;\n\t}\n\tret = 0;\n\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j)\n\t\tif (i < CSD_BUF_SIZE * 8) {\n\t\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t\t} else {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\tscd->curbit += code_size;\n\treturn ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const float in_min = context->input(2).flat<float>()(0);\n    const float in_max = context->input(3).flat<float>()(0);\n    ImageResizerState st(align_corners_, false);\n    st.ValidateAndCreateOutput(context);\n    if (!context->status().ok()) return;\n    if (st.output->NumElements() == 0) return;\n    typename TTypes<T, 4>::ConstTensor image_data(\n        context->input(0).tensor<T, 4>());\n    typename TTypes<T, 4>::Tensor output_data(st.output->tensor<T, 4>());\n    ResizeBilinear<T>(image_data, st.height_scale, st.width_scale, in_min,\n                      in_max, half_pixel_centers_, &output_data);\n    Tensor* out_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &out_min));\n    out_min->flat<float>()(0) = in_min;\n    Tensor* out_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &out_max));\n    out_max->flat<float>()(0) = in_max;\n  }", "target": 1}
{"code": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 1}
{"code": "static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n{\n\tM_fs_info_t  *info = NULL;\n\tchar         *pold = NULL;\n\tchar         *pnew = NULL;\n\tM_fs_type_t   type;\n\tM_bool        ret  = M_TRUE;\n\tif (mode & M_FS_FILE_MODE_OVERWRITE)\n\t\treturn M_TRUE;\n\tif (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)\n\t\treturn M_FALSE;\n\ttype = M_fs_info_get_type(info);\n\tM_fs_info_destroy(info);\n\tif (type != M_FS_TYPE_DIR) {\n\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n\t\t{\n\t\t\tret = M_FALSE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tpold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);\n\tpnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);\n\tif (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\tret = M_FALSE;\n\t\tgoto done;\n\t}\ndone:\n\tM_free(pnew);\n\tM_free(pold);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong datalen;\n\tdatalen = parse_iv2((*p) + 2, p);\n        (*p) += 2;\n       if (datalen < 0 || (*p) + datalen >= max) {\n                zend_error(E_WARNING, \"Insufficient data for unserializing - %ld required, %ld present\", datalen, (long)(max - (*p)));\n                return 0;\n        }\n\tif (ce->unserialize == NULL) {\n\t\tzend_error(E_WARNING, \"Class %s has no unserializer\", ce->name);\n\t\tobject_init_ex(*rval, ce);\n\t} else if (ce->unserialize(rval, ce, (const unsigned char*)*p, datalen, (zend_unserialize_data *)var_hash TSRMLS_CC) != SUCCESS) {\n\t\treturn 0;\n\t}\n\t(*p) += datalen;\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}", "target": 1}
{"code": "spnego_gss_get_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_qop_t  qop_req,\n\t\tconst gss_buffer_t message_buffer,\n\t\tgss_buffer_t message_token)\n{\n\tOM_uint32 ret;\n\tret = gss_get_mic(minor_status,\n\t\t    context_handle,\n\t\t    qop_req,\n\t\t    message_buffer,\n\t\t    message_token);\n\treturn (ret);\n}", "target": 1}
{"code": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n   rtadv_event (zvrf, RTADV_READ, sock);\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n   if (len < 0) \n     {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n  return 0;\n}", "target": 1}
{"code": "gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n{\n        if (client->priv->watch_id > 0) {\n                g_source_remove (client->priv->watch_id);\n        }\n        if (client->priv->conn != NULL) {\n                SmsCleanUp (client->priv->conn);\n        }\n        if (client->priv->ice_connection != NULL) {\n                IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                IceCloseConnection (client->priv->ice_connection);\n        }\n        if (client->priv->protocol_timeout > 0) {\n                g_source_remove (client->priv->protocol_timeout);\n        }\n}", "target": 1}
{"code": "static void hidp_process_report(struct hidp_session *session,\n\t\t\t\tint type, const u8 *data, int len, int intr)\n{\n\tif (len > HID_MAX_BUFFER_SIZE)\n\t\tlen = HID_MAX_BUFFER_SIZE;\n\tmemcpy(session->input_buf, data, len);\n\thid_input_report(session->hid, type, session->input_buf, len, intr);\n}", "target": 1}
{"code": "bool DL_Dxf::handleLWPolylineData(DL_CreationInterface* ) {\n    if (groupCode==90) {\n        maxVertices = toInt(groupValue);\n        if (maxVertices>0) {\n            if (vertices!=NULL) {\n                delete[] vertices;\n            }\n            vertices = new double[4*maxVertices];\n            for (int i=0; i<maxVertices; ++i) {\n                vertices[i*4] = 0.0;\n                vertices[i*4+1] = 0.0;\n                vertices[i*4+2] = 0.0;\n                vertices[i*4+3] = 0.0;\n            }\n        }\n        vertexIndex=-1;\n        return true;\n    }\n    else if (groupCode==10 || groupCode==20 ||\n             groupCode==30 || groupCode==42) {\n        if (vertexIndex<maxVertices-1 && groupCode==10) {\n            vertexIndex++;\n        }\n        if (groupCode<=30) {\n            if (vertexIndex>=0 && vertexIndex<maxVertices) {\n                vertices[4*vertexIndex + (groupCode/10-1)] = toReal(groupValue);\n            }\n        } else if (groupCode==42 && vertexIndex<maxVertices) {\n            vertices[4*vertexIndex + 3] = toReal(groupValue);\n        }\n        return true;\n    }\n    return false;\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_get_block_size, const String& cipher,\n                                    const Variant& module ) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.asCStrRef().data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_block_size\");\n    return false;\n  }\n  int64_t ret = mcrypt_enc_get_block_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}", "target": 1}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 1}
{"code": "static void do_proc_open(FILE *fin, FILE *fout, int afdt_fd) {\n  char cmd[BUFFER_SIZE];\n  read_buf(fin, cmd);\n  if (strlen(cmd) == 0) {\n    fprintf(fout, \"error\\n%d\\n\", ENOENT);\n    fflush(fout);\n    return;\n  }\n  char cwd[BUFFER_SIZE];\n  read_buf(fin, cwd);\n  char buf[BUFFER_SIZE];\n  int env_size = 0;\n  std::vector<std::string> env;\n  read_buf(fin, buf);\n  sscanf(buf, \"%d\", &env_size);\n  for (int i = 0; i < env_size; i++) {\n    read_buf(fin, buf);\n    env.push_back(buf);\n  }\n  int pipe_size = 0;\n  read_buf(fin, buf);\n  sscanf(buf, \"%d\", &pipe_size);\n  std::vector<int> pvals;\n  for (int i = 0; i < pipe_size; i++) {\n    int fd_value;\n    read_buf(fin, buf);\n    sscanf(buf, \"%d\", &fd_value);\n    pvals.push_back(fd_value);\n  }\n  std::vector<int> pkeys;\n  for (int i = 0; i < pipe_size; i++) {\n    int fd = recv_fd(afdt_fd);\n    if (fd < 0) {\n      fprintf(fout, \"error\\n%d\\n\", EPROTO);\n      fflush(fout);\n      close_fds(pkeys);\n      return;\n    }\n    pkeys.push_back(fd);\n  }\n  pid_t child = fork();\n  if (child == 0) {\n    for (int i = 0; i < pipe_size; i++) {\n      dup2(pkeys[i], pvals[i]);\n    }\n    if (strlen(cwd) > 0 && chdir(cwd)) {\n    }\n    if (!env.empty()) {\n      char **envp = build_envp(env);\n      execle(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr, envp);\n      free(envp);\n    } else {\n      execl(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr);\n    }\n    _exit(127);\n  } else if (child > 0) {\n    fprintf(fout, \"%\" PRId64 \"\\n\", (int64_t)child);\n    fflush(fout);\n  } else {\n    fprintf(fout, \"error\\n%d\\n\", errno);\n    fflush(fout);\n  }\n  close_fds(pkeys);\n}", "target": 1}
{"code": "void* ipc_alloc(int size)\n{\n\tvoid* out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}", "target": 1}
{"code": "static int adpt_slave_configure(struct scsi_device * device)\n{\n\tstruct Scsi_Host *host = device->host;\n\tif (host->can_queue && device->tagged_supported) {\n\t\tscsi_change_queue_depth(device,\n\t\t\t\thost->can_queue - 1);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": " mm_answer_pam_free_ctx(int sock, Buffer *m)\n {\n \tdebug3(\"%s\", __func__);\n \t(sshpam_device.free_ctx)(sshpam_ctxt);\n \tbuffer_clear(m);\n \tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n \tauth_method = \"keyboard-interactive\";\n \tauth_submethod = \"pam\";\n\treturn (sshpam_authok == sshpam_ctxt);\n }", "target": 1}
{"code": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\thid_set_drvdata(hdev, priv);\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\treturn 0;\nerr_free:\n\tkfree(priv);\n\treturn ret;\n}", "target": 1}
{"code": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(up, &ktv);\n\treturn err;\n}", "target": 1}
{"code": "PatternMatch(char *pat, int patdashes, char *string, int stringdashes)\n{\n    char        c,\n                t;\n    if (stringdashes < patdashes)\n\treturn 0;\n    for (;;) {\n\tswitch (c = *pat++) {\n\tcase '*':\n\t    if (!(c = *pat++))\n\t\treturn 1;\n\t    if (c == XK_minus) {\n\t\tpatdashes--;\n\t\tfor (;;) {\n\t\t    while ((t = *string++) != XK_minus)\n\t\t\tif (!t)\n\t\t\t    return 0;\n\t\t    stringdashes--;\n\t\t    if (PatternMatch(pat, patdashes, string, stringdashes))\n\t\t\treturn 1;\n\t\t    if (stringdashes == patdashes)\n\t\t\treturn 0;\n\t\t}\n\t    } else {\n\t\tfor (;;) {\n\t\t    while ((t = *string++) != c) {\n\t\t\tif (!t)\n\t\t\t    return 0;\n\t\t\tif (t == XK_minus) {\n\t\t\t    if (stringdashes-- < patdashes)\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t    }\n\t\t    if (PatternMatch(pat, patdashes, string, stringdashes))\n\t\t\treturn 1;\n \t\t}\n \t    }\n \tcase '?':\n\t    if (*string++ == XK_minus)\n \t\tstringdashes--;\n \t    break;\n \tcase '\\0':\n \t    return (*string == '\\0');\n\t\tpatdashes--;\n\t\tstringdashes--;\n\t\tbreak;\n\t    }\n\t    return 0;\n\tdefault:\n\t    if (c == *string++)\n\t\tbreak;\n\t    return 0;\n\t}\n    }", "target": 1}
{"code": "static pj_status_t pjsip_auth_verify( const pjsip_authorization_hdr *hdr,\n\t\t\t\t      const pj_str_t *method,\n\t\t\t\t      const pjsip_cred_info *cred_info )\n{\n    if (pj_stricmp(&hdr->scheme, &pjsip_DIGEST_STR) == 0) {\n\tchar digest_buf[PJSIP_MD5STRLEN];\n\tpj_str_t digest;\n\tconst pjsip_digest_credential *dig = &hdr->credential.digest;\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->username, &cred_info->username) == 0,\n\t\t\t PJ_EINVALIDOP);\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->realm, &cred_info->realm) == 0,\n\t\t\t PJ_EINVALIDOP);\n\tdigest.ptr = digest_buf;\n\tdigest.slen = PJSIP_MD5STRLEN;\n\tpjsip_auth_create_digest(&digest, \n\t\t\t\t &hdr->credential.digest.nonce,\n\t\t\t\t &hdr->credential.digest.nc, \n\t\t\t\t &hdr->credential.digest.cnonce,\n\t\t\t\t &hdr->credential.digest.qop,\n\t\t\t\t &hdr->credential.digest.uri,\n\t\t\t\t &cred_info->realm,\n\t\t\t\t cred_info, \n\t\t\t\t method );\n\treturn (pj_stricmp(&digest, &hdr->credential.digest.response) == 0) ?\n\t       PJ_SUCCESS : PJSIP_EAUTHINVALIDDIGEST;\n    } else {\n\tpj_assert(!\"Unsupported authentication scheme\");\n\treturn PJSIP_EINVALIDAUTHSCHEME;\n    }\n}", "target": 1}
{"code": "rdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n \tstatic char *rest = NULL;\n \tchar *buf;\n \tpkglen = s->end - s->p;\n \tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\txfree(buf);\n}", "target": 1}
{"code": "static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n{\n\tint i;\n\tint nr = pagevec_count(pvec);\n\tint delta_munlocked;\n\tstruct pagevec pvec_putback;\n\tint pgrescued = 0;\n\tpagevec_init(&pvec_putback, 0);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\t__munlock_isolation_failed(page);\n\t\t}\n\t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n\t\tpvec->pages[i] = NULL;\n\t}\n\tdelta_munlocked = -nr + pagevec_count(&pvec_putback);\n\t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n\tspin_unlock_irq(zone_lru_lock(zone));\n\tpagevec_release(&pvec_putback);\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\tget_page(page); \n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); \n\t\t\t}\n\t\t}\n\t}\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayReduceSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, i;\n    Jsi_Obj *obj;\n    Jsi_Value *func, *vpargs, *ini = Jsi_ValueArrayIndex(interp, args, 1);\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0)\n        Jsi_ObjSetLength(interp, obj, 0);\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_Value *vobjs[4];\n    int n, rev = (op==2);\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>4)\n        maa = 4;\n    for (n = 0, i = (rev?obj->arrCnt-1:0); (rev?i>=0:i < (int)obj->arrCnt) && rc == JSI_OK; n++, i = (rev?i-1:i+1)) {\n        if (!obj->arr[i]) continue;\n        if (n==0 && !ini) {\n            ini = obj->arr[i];\n            continue;\n        }\n        vobjs[0] = ini;\n        vobjs[1] = obj->arr[i];\n        vobjs[2] = (maa>2?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[3] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, NULL);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        ini = nrPtr;\n    }\n    if (rc == JSI_OK && ini)\n        Jsi_ValueCopy(interp, *ret, ini); \n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n}", "target": 1}
{"code": "PHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n \t\treturn;\n \t}\n \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n \tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "juniper_mlfr_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_MLFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLC_UI):\n        case (LLC_UI<<8):\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)\n{\n\tu64 runtime = 0, slice = sched_cfs_bandwidth_slice();\n\tunsigned long flags;\n\tu64 expires;\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tcfs_b->slack_started = false;\n\tif (cfs_b->distribute_running) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\treturn;\n\t}\n\tif (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\treturn;\n\t}\n\tif (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)\n\t\truntime = cfs_b->runtime;\n\texpires = cfs_b->runtime_expires;\n\tif (runtime)\n\t\tcfs_b->distribute_running = 1;\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\tif (!runtime)\n\t\treturn;\n\truntime = distribute_cfs_runtime(cfs_b, runtime, expires);\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tif (expires == cfs_b->runtime_expires)\n\t\tlsub_positive(&cfs_b->runtime, runtime);\n\tcfs_b->distribute_running = 0;\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n}", "target": 1}
{"code": "static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)\n{\n\tchar fnam[PROCLEN];\n\tFILE *f;\n\tbool answer = false;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\tret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);\n\tif (ret < 0 || ret >= PROCLEN)\n\t\treturn false;\n\tif (!(f = fopen(fnam, \"r\")))\n\t\treturn false;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *c1, *c2, *linecmp;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\t\tc1 = strchr(line, ':');\n\t\tif (!c1)\n\t\t\tgoto out;\n\t\tc1++;\n\t\tc2 = strchr(c1, ':');\n\t\tif (!c2)\n\t\t\tgoto out;\n\t\t*c2 = '\\0';\n\t\tif (strcmp(c1, contrl) != 0)\n\t\t\tcontinue;\n\t\tc2++;\n\t\tstripnewline(c2);\n\t\tprune_init_slice(c2);\n\t\tlinecmp = *cg == '/' ? c2 : c2+1;\n\t\tif (strncmp(linecmp, cg, strlen(linecmp)) != 0) {\n\t\t\tif (nextcg)\n\t\t\t\t*nextcg = get_next_cgroup_dir(linecmp, cg);\n\t\t\tgoto out;\n\t\t}\n\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfclose(f);\n\tfree(line);\n\treturn answer;\n}", "target": 1}
{"code": " bool SVGElement::HasSVGParent() const {\n  return ParentOrShadowHostElement() &&\n         ParentOrShadowHostElement()->IsSVGElement();\n }", "target": 1}
{"code": "*/\nstatic void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  LIST *pruned_list= 0;\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n    }\n    else\n    {\n      pruned_list= list_add(pruned_list, element);\n    }\n  }\n  mysql->stmts= pruned_list;", "target": 1}
{"code": "static int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}", "target": 1}
{"code": "__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tu32 id;\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\n\treturn htonl(id);\n}", "target": 1}
{"code": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\t*bounce_buf_ret = bounce_buf;\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}", "target": 1}
{"code": "static uint32_t color_string_to_rgba(const char *p, int len)\n{\n    uint32_t ret = 0xFF000000;\n     const ColorEntry *entry;\n     char color_name[100];\n     if (*p == '#') {\n         p++;\n         len--;\n        if (len == 3) {\n            ret |= (hex_char_to_number(p[2]) <<  4) |\n                   (hex_char_to_number(p[1]) << 12) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 4) {\n            ret  = (hex_char_to_number(p[3]) <<  4) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 20) |\n                   (hex_char_to_number(p[0]) << 28);\n        } else if (len == 6) {\n            ret |=  hex_char_to_number(p[5])        |\n                   (hex_char_to_number(p[4]) <<  4) |\n                   (hex_char_to_number(p[3]) <<  8) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 16) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 8) {\n            ret  =  hex_char_to_number(p[7])        |\n                   (hex_char_to_number(p[6]) <<  4) |\n                   (hex_char_to_number(p[5]) <<  8) |\n                   (hex_char_to_number(p[4]) << 12) |\n                   (hex_char_to_number(p[3]) << 16) |\n                   (hex_char_to_number(p[2]) << 20) |\n                   (hex_char_to_number(p[1]) << 24) |\n                   (hex_char_to_number(p[0]) << 28);\n        }\n    } else {\n        strncpy(color_name, p, len);\n        color_name[len] = '\\0';\n        entry = bsearch(color_name,\n                        color_table,\n                        FF_ARRAY_ELEMS(color_table),\n                        sizeof(ColorEntry),\n                        color_table_compare);\n        if (!entry)\n            return ret;\n        ret = entry->rgb_color;\n    }\n    return ret;\n}", "target": 1}
{"code": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n    FREE(&token.data);\n  }\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}", "target": 1}
{"code": "static int is_git_directory(const char *suspect)\n{\n\tchar path[PATH_MAX];\n\tsize_t len = strlen(suspect);\n\tstrcpy(path, suspect);\n\tif (getenv(DB_ENVIRONMENT)) {\n\t\tif (access(getenv(DB_ENVIRONMENT), X_OK))\n\t\t\treturn 0;\n\t}\n\telse {\n\t\tstrcpy(path + len, \"/objects\");\n\t\tif (access(path, X_OK))\n\t\t\treturn 0;\n\t}\n\tstrcpy(path + len, \"/refs\");\n\tif (access(path, X_OK))\n\t\treturn 0;\n\tstrcpy(path + len, \"/HEAD\");\n\tif (validate_headref(path))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "bool ZipCommon::isValidPath(const std::string& path)\n{\n\tif (path == \"..\")\n\t\treturn false;\n\tif (path.compare(0, 3, \"../\") == 0)\n\t\treturn false;\n\tif (path.compare(0, 3, \"..\\\\\") == 0)\n\t\treturn false;\n\tif (path.find(\"/..\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\..\") != std::string::npos)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n    std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =\n        GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,\n                                               shapes_list_in, dense_list_in);\n    const tstring k_feature_separator = \"_X_\";\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Crosser crosser(\n        columns, num_buckets_, hash_key_, k_feature_separator);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Updater updater(\n        output_start_indices, indices_out, values_out);\n    auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<InternalType> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }", "target": 1}
{"code": "int bind_ports(void) {\n    SERVICE_OPTIONS *opt;\n    int listening_section;\n#ifdef USE_LIBWRAP\n    libwrap_init();\n#endif \n    s_poll_init(fds, 1);\n    for(opt=service_options.next; opt; opt=opt->next) {\n        unsigned i;\n        for(i=0; i<opt->local_addr.num; ++i)\n            opt->local_fd[i]=INVALID_SOCKET;\n    }\n    listening_section=0;\n    for(opt=service_options.next; opt; opt=opt->next) {\n        opt->bound_ports=0;\n        if(opt->local_addr.num) { \n            unsigned i;\n            s_log(LOG_DEBUG, \"Binding service [%s]\", opt->servname);\n            for(i=0; i<opt->local_addr.num; ++i) {\n                SOCKET fd;\n                fd=bind_port(opt, listening_section, i);\n                opt->local_fd[i]=fd;\n                if(fd!=INVALID_SOCKET) {\n                    s_poll_add(fds, fd, 1, 0);\n                    ++opt->bound_ports;\n                }\n            }\n            if(!opt->bound_ports) {\n                s_log(LOG_ERR, \"Binding service [%s] failed\", opt->servname);\n                return 1;\n            }\n            ++listening_section;\n        } else if(opt->exec_name && opt->connect_addr.names) {\n            s_log(LOG_DEBUG, \"Skipped exec+connect service [%s]\", opt->servname);\n#ifndef OPENSSL_NO_TLSEXT\n        } else if(!opt->option.client && opt->sni) {\n            s_log(LOG_DEBUG, \"Skipped SNI slave service [%s]\", opt->servname);\n#endif\n        } else { \n            s_log(LOG_ERR, \"Invalid service [%s]\", opt->servname);\n            return 1;\n        }\n    }\n    if(listening_section<systemd_fds) {\n        s_log(LOG_ERR,\n            \"Too many listening file descriptors received from systemd, got %d\",\n            systemd_fds);\n        return 1;\n    }\n    return 0; \n}", "target": 1}
{"code": "static int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int rc = 0;\n    int i;\n    size_t ldnlen = 0;\n    const char * ldn = NULL;\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\tif (dnlen <= 1)\n\t    continue;\n\tif (dnlen == ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\t(void) stpcpy(dn, dpath);\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t\tcontinue;\n\t    *te = '\\0';\n\t    rc = fsmStat(dn, 1, &sb); \n\t    *te = '/';\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\tcontinue;\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(dn, mode);\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\tldn = dpath;\n\tldnlen = dnlen;\n    }\n    dnlFreeIterator(dnli);\n    return rc;\n}", "target": 1}
{"code": "switchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n\tif (userInfo != NULL) {\n\t\tbool setgroupsCalled = false;\n\t\t#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n\t\t\t#ifdef __APPLE__\n\t\t\t\tint groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(int);\n\t\t\t#else\n\t\t\t\tgid_t groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(gid_t);\n\t\t\t#endif\n\t\t\tboost::scoped_array<gid_t> gidset;\n\t\t\tint ret = getgrouplist(userInfo->pw_name, gid,\n\t\t\t\tgroups, &ngroups);\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (ngroups <= NGROUPS_MAX) {\n\t\t\t\tsetgroupsCalled = true;\n\t\t\t\tgidset.reset(new gid_t[ngroups]);\n\t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\tngroups, strerror(e), e);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\t\tif (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr, \"ERROR: initgroups(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (setgid(gid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"ERROR: setgid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) gid, strerror(e), e);\n\t\texit(1);\n\t}\n}", "target": 1}
{"code": "int Dispatcher::getparam( size_t N, int defaultval )\n{\n  int ret = defaultval;\n  if ( !parsed ) {\n    parse_params();\n  }\n  if ( parsed_params.size() > N ) {\n    ret = parsed_params[ N ];\n  }\n  if ( ret < 1 ) ret = defaultval;\n  return ret;\n}", "target": 1}
{"code": "XLookupColor (\n\tregister Display *dpy,\n        Colormap cmap,\n\t_Xconst char *spec,\n\tXColor *def,\n\tXColor *scr)\n{\n\tregister int n;\n\txLookupColorReply reply;\n\tregister xLookupColorReq *req;\n\tXcmsCCC ccc;\n\tXcmsColor cmsColor_exact;\n#ifdef XCMS\n\tif ((ccc = XcmsCCCOfColormap(dpy, cmap)) != (XcmsCCC)NULL) {\n\t    const char *tmpName = spec;\n\t    switch (_XcmsResolveColorString(ccc, &tmpName, &cmsColor_exact,\n\t\t\t\t\t    XcmsRGBFormat)) {\n\t    case XcmsSuccess:\n\t    case XcmsSuccessWithCompression:\n\t\t_XcmsRGB_to_XColor(&cmsColor_exact, def, 1);\n\t\tmemcpy((char *)scr, (char *)def, sizeof(XColor));\n\t\t_XUnresolveColor(ccc, scr);\n\t\treturn(1);\n\t    case XcmsFailure:\n\t    case _XCMS_NEWNAME:\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tn = (int) strlen (spec);\n\tLockDisplay(dpy);\n\tGetReq (LookupColor, req);\n\treq->cmap = cmap;\n\treq->nbytes = n;\n\treq->length += (n + 3) >> 2;\n\tData (dpy, spec, (long)n);\n\tif (!_XReply (dpy, (xReply *) &reply, 0, xTrue)) {\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (0);\n\t    }\n\tdef->red   = reply.exactRed;\n\tdef->green = reply.exactGreen;\n\tdef->blue  = reply.exactBlue;\n\tscr->red   = reply.screenRed;\n\tscr->green = reply.screenGreen;\n\tscr->blue  = reply.screenBlue;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (1);\n}", "target": 1}
{"code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n \t}\n \tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n \t\tswitch (mode) {\n \t\tcase PSR_AA32_MODE_USR:\n \t\tcase PSR_AA32_MODE_FIQ:\n \t\tcase PSR_AA32_MODE_IRQ:\n \t\tcase PSR_AA32_MODE_SVC:\n \t\tcase PSR_AA32_MODE_ABT:\n \t\tcase PSR_AA32_MODE_UND:\n \t\tcase PSR_MODE_EL0t:\n \t\tcase PSR_MODE_EL1t:\n \t\tcase PSR_MODE_EL1h:\n \t\t\tbreak;\n \t\tdefault:\n \t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}", "target": 1}
{"code": "static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct mcryptd_queue *queue)\n{\n\tstruct hashd_instance_ctx *ctx;\n\tstruct ahash_instance *inst;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *alg;\n\tu32 type = 0;\n\tu32 mask = 0;\n\tint err;\n\tmcryptd_check_internal(tb, &type, &mask);\n\thalg = ahash_attr_alg(tb[1], type, mask);\n\tif (IS_ERR(halg))\n\t\treturn PTR_ERR(halg);\n\talg = &halg->base;\n\tpr_debug(\"crypto: mcryptd hash alg: %s\\n\", alg->cra_name);\n\tinst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),\n\t\t\t\t\tsizeof(*ctx));\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\tctx = ahash_instance_ctx(inst);\n\tctx->queue = queue;\n\terr = crypto_init_ahash_spawn(&ctx->spawn, halg,\n\t\t\t\t      ahash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\ttype = CRYPTO_ALG_ASYNC;\n\tif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\n\t\ttype |= CRYPTO_ALG_INTERNAL;\n\tinst->alg.halg.base.cra_flags = type;\n\tinst->alg.halg.digestsize = halg->digestsize;\n\tinst->alg.halg.statesize = halg->statesize;\n\tinst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);\n\tinst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;\n\tinst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;\n\tinst->alg.init   = mcryptd_hash_init_enqueue;\n\tinst->alg.update = mcryptd_hash_update_enqueue;\n\tinst->alg.final  = mcryptd_hash_final_enqueue;\n\tinst->alg.finup  = mcryptd_hash_finup_enqueue;\n\tinst->alg.export = mcryptd_hash_export;\n\tinst->alg.import = mcryptd_hash_import;\n\tinst->alg.setkey = mcryptd_hash_setkey;\n\tinst->alg.digest = mcryptd_hash_digest_enqueue;\n\terr = ahash_register_instance(tmpl, inst);\n\tif (err) {\n\t\tcrypto_drop_ahash(&ctx->spawn);\nout_free_inst:\n\t\tkfree(inst);\n\t}\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}", "target": 1}
{"code": "htmlParsePubidLiteral(htmlParserCtxtPtr ctxt) {\n    const xmlChar *q;\n    xmlChar *ret = NULL;\n    if (CUR == '\"') {\n        NEXT;\n\tq = CUR_PTR;\n\twhile (IS_PUBIDCHAR_CH(CUR)) NEXT;\n\tif (CUR != '\"') {\n\t    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n\t                 \"Unfinished PubidLiteral\\n\", NULL, NULL);\n\t} else {\n\t    ret = xmlStrndup(q, CUR_PTR - q);\n\t    NEXT;\n\t}\n    } else if (CUR == '\\'') {\n        NEXT;\n\tq = CUR_PTR;\n\twhile ((IS_PUBIDCHAR_CH(CUR)) && (CUR != '\\''))\n\t    NEXT;\n\tif (CUR != '\\'') {\n\t    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n\t                 \"Unfinished PubidLiteral\\n\", NULL, NULL);\n\t} else {\n\t    ret = xmlStrndup(q, CUR_PTR - q);\n\t    NEXT;\n\t}\n    } else {\n\thtmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,\n\t             \"PubidLiteral \\\" or ' expected\\n\", NULL, NULL);\n    }\n    return(ret);\n}", "target": 1}
{"code": "int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ip_options *opt;\n\topt = inet_sk(sk)->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn -ENOMSG;\n\treturn cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),\n\t\t\t\tsecattr);\n}", "target": 1}
{"code": "smix(uint8_t * B, size_t r, uint64_t N, void * V, void * XY)\n{\n  __m128i * X = (__m128i *) XY;\n  __m128i * Y = (__m128i *) ((uintptr_t)(XY) + 128 * r);\n  __m128i * Z = (__m128i *) ((uintptr_t)(XY) + 256 * r);\n  uint32_t * X32 = (uint32_t *)X;\n  uint64_t i, j;\n  size_t k;\n  for (k = 0; k < 2 * r; k++) {\n    for (i = 0; i < 16; i++) {\n      X32[k * 16 + i] = folly::Endian::little32(\n                          *((uint32_t *) &B[(k * 16 + (i * 5 % 16)) * 4]));\n    }\n  }\n  for (i = 0; i < N; i += 2) {\n    blkcpy((void *)((uintptr_t)(V) + i * 128 * r), X, 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    blkcpy((void *)((uintptr_t)(V) + (i + 1) * 128 * r),\n        Y, 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (i = 0; i < N; i += 2) {\n    j = integerify(X, r) & (N - 1);\n    blkxor(X, (void *)((uintptr_t)(V) + j * 128 * r), 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    j = integerify(Y, r) & (N - 1);\n    blkxor(Y, (void *)((uintptr_t)(V) + j * 128 * r), 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (k = 0; k < 2 * r; k++) {\n    for (i = 0; i < 16; i++) {\n      *((uint32_t *) &B[(k * 16 + (i * 5 % 16)) * 4]) =\n          folly::Endian::little32(X32[k * 16 + i]);\n    }\n  }\n}", "target": 1}
{"code": "static int ldb_kv_index_dn_attr(struct ldb_module *module,\n\t\t\t\tstruct ldb_kv_private *ldb_kv,\n\t\t\t\tconst char *attr,\n\t\t\t\tstruct ldb_dn *dn,\n\t\t\t\tstruct dn_list *list,\n\t\t\t\tenum key_truncation *truncation)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *key;\n\tstruct ldb_val val;\n\tint ret;\n\tldb = ldb_module_get_ctx(module);\n\tval.data = (uint8_t *)((uintptr_t)ldb_dn_get_casefold(dn));\n\tval.length = strlen((char *)val.data);\n\tkey = ldb_kv_index_key(ldb, ldb_kv, attr, &val, NULL, truncation);\n\tif (!key) {\n\t\tldb_oom(ldb);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tret = ldb_kv_dn_list_load(module, ldb_kv, key, list);\n\ttalloc_free(key);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (list->count == 0) {\n\t\treturn LDB_ERR_NO_SUCH_OBJECT;\n\t}\n\treturn LDB_SUCCESS;\n}", "target": 1}
{"code": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n}", "target": 1}
{"code": "static int adpt_i2o_enable_hba(adpt_hba* pHba)\n{\n\tu32 msg[4];\n\tint ret;\n\tadpt_i2o_status_get(pHba);\n\tif(!pHba->status_block){\n\t\treturn -ENOMEM;\n\t}\n\tif(pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL)\n\t\treturn 0;\n\tif(pHba->status_block->iop_state != ADAPTER_STATE_READY)\n\t\treturn -EINVAL;\n\tmsg[0]=FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1]=I2O_CMD_SYS_ENABLE<<24|HOST_TID<<12|ADAPTER_TID;\n\tmsg[2]= 0;\n\tmsg[3]= 0;\n\tif ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {\n\t\tprintk(KERN_WARNING\"%s: Could not enable (status=%#10x).\\n\", \n\t\t\tpHba->name, ret);\n\t} else {\n\t\tPDEBUG(\"%s: Enabled.\\n\", pHba->name);\n\t}\n\tadpt_i2o_status_get(pHba);\n\treturn ret;\n}", "target": 1}
{"code": "int sub__remove(struct mosquitto *context, const char *sub, uint8_t *reason)\n{\n\tint rc = 0;\n\tstruct mosquitto__subhier *subhier;\n\tconst char *sharename = NULL;\n\tchar *local_sub = NULL;\n\tchar **topics = NULL;\n\tassert(sub);\n\trc = sub__topic_tokenise(sub, &local_sub, &topics, &sharename);\n\tif(rc) return rc;\n\tHASH_FIND(hh, db.subs, topics[0], strlen(topics[0]), subhier);\n\tif(subhier){\n\t\t*reason = MQTT_RC_NO_SUBSCRIPTION_EXISTED;\n\t\trc = sub__remove_recurse(context, subhier, topics, reason, sharename);\n\t}\n\tmosquitto__free(local_sub);\n\tmosquitto__free(topics);\n\treturn rc;\n}", "target": 1}
{"code": "FramebufferModel::FramebufferModel(QObject* parent)\n  : QObject(parent)\n  , m_pixelBuffer(nullptr)\n  , m_width(0)\n  , m_height(0)\n  , m_isImageLoaded(false)\n  , m_exposure(0)\n  , m_imageLoadingWatcher(new QFutureWatcher<void>(this))\n  , m_imageEditingWatcher(new QFutureWatcher<void>(this))\n  , m_pixelAspectRatio(1.f)\n{}", "target": 1}
{"code": "void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,\n\t\t\t\tunsigned long end, unsigned long vmflag)\n{\n\tunsigned long addr;\n\tunsigned long base_pages_to_flush = TLB_FLUSH_ALL;\n\tpreempt_disable();\n\tif (current->active_mm != mm)\n\t\tgoto out;\n\tif (!current->mm) {\n\t\tleave_mm(smp_processor_id());\n\t\tgoto out;\n\t}\n\tif ((end != TLB_FLUSH_ALL) && !(vmflag & VM_HUGETLB))\n\t\tbase_pages_to_flush = (end - start) >> PAGE_SHIFT;\n\tif (base_pages_to_flush > tlb_single_page_flush_ceiling) {\n\t\tbase_pages_to_flush = TLB_FLUSH_ALL;\n\t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\t\tlocal_flush_tlb();\n\t} else {\n\t\tfor (addr = start; addr < end;\taddr += PAGE_SIZE) {\n\t\t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);\n\t\t\t__flush_tlb_single(addr);\n\t\t}\n\t}\n\ttrace_tlb_flush(TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush);\nout:\n\tif (base_pages_to_flush == TLB_FLUSH_ALL) {\n\t\tstart = 0UL;\n\t\tend = TLB_FLUSH_ALL;\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, end);\n\tpreempt_enable();\n}", "target": 1}
{"code": "processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif \n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE);\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}", "target": 1}
{"code": "R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n#if __UNIX__\n\tint msecs = (usecs / 1000);\n\tstruct pollfd fds[1];\n\tfds[0].fd = s->fd;\n\tfds[0].events = POLLIN | POLLPRI;\n\tfds[0].revents = POLLNVAL | POLLHUP | POLLERR;\n\treturn poll ((struct pollfd *)&fds, 1, msecs);\n#elif __WINDOWS__\n\tfd_set rfds;\n\tstruct timeval tv;\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\ttv.tv_sec = secs;\n\ttv.tv_usec = usecs;\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n#else\n\treturn true; \n#endif\n}", "target": 1}
{"code": "static unsigned int ipv6_defrag(void *priv,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tconst struct nf_hook_state *state)\n{\n\tint err;\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\n\t\treturn NF_ACCEPT;\n#endif\n\terr = nf_ct_frag6_gather(state->net, skb,\n\t\t\t\t nf_ct6_defrag_user(state->hook, skb));\n\tif (err == -EINPROGRESS)\n\t\treturn NF_STOLEN;\n\treturn NF_ACCEPT;\n}", "target": 1}
{"code": "xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,\n                     xmlEntityPtr ent, size_t replacement)\n{\n    size_t consumed = 0;\n    if ((ctxt == NULL) || (ctxt->options & XML_PARSE_HUGE))\n        return (0);\n    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n        return (1);\n    if ((ent != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n\t(ent->content != NULL) && (ent->checked == 0)) {\n\tunsigned long oldnbent = ctxt->nbentities;\n\txmlChar *rep;\n\tent->checked = 1;\n\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n\tent->checked = (ctxt->nbentities - oldnbent + 1) * 2;\n\tif (rep != NULL) {\n\t    if (xmlStrchr(rep, '<'))\n\t\tent->checked |= 1;\n\t    xmlFree(rep);\n\t    rep = NULL;\n\t}\n    }\n    if (replacement != 0) {\n\tif (replacement < XML_MAX_TEXT_LENGTH)\n\t    return(0);\n        if (ctxt->input != NULL) {\n\t    consumed = ctxt->input->consumed +\n\t               (ctxt->input->cur - ctxt->input->base);\n\t}\n        consumed += ctxt->sizeentities;\n        if (replacement < XML_PARSER_NON_LINEAR * consumed)\n\t    return(0);\n    } else if (size != 0) {\n        if (size < XML_PARSER_BIG_ENTITY)\n\t    return(0);\n        if (ctxt->input != NULL) {\n            consumed = ctxt->input->consumed +\n                (ctxt->input->cur - ctxt->input->base);\n        }\n        consumed += ctxt->sizeentities;\n        if ((size < XML_PARSER_NON_LINEAR * consumed) &&\n\t    (ctxt->nbentities * 3 < XML_PARSER_NON_LINEAR * consumed))\n            return (0);\n    } else if (ent != NULL) {\n        size = ent->checked / 2;\n        if (ctxt->input != NULL) {\n            consumed = ctxt->input->consumed +\n                (ctxt->input->cur - ctxt->input->base);\n        }\n        consumed += ctxt->sizeentities;\n        if (size * 3 < consumed * XML_PARSER_NON_LINEAR)\n            return (0);\n    } else {\n\tif (((ctxt->lastError.code != XML_ERR_UNDECLARED_ENTITY) &&\n\t     (ctxt->lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||\n\t    (ctxt->nbentities <= 10000))\n\t    return (0);\n    }\n    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n    return (1);\n}", "target": 1}
{"code": " gs_nulldevice(gs_gstate * pgs)\n {\n     int code = 0;\n     if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {\n         gx_device *ndev;\n         code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,\n                                 pgs->memory);\n         if (code < 0)\n             return code;\n        rc_init(ndev, pgs->memory, 0);\n        if (pgs->device != NULL) {\n            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,\n                                               &(ndev->icc_struct))) < 0)\n                return code;\n            rc_increment(ndev->icc_struct);\n            set_dev_proc(ndev, get_profile, gx_default_get_profile);\n        }\n        if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)\n         if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)\n             gs_free_object(pgs->memory, ndev, \"gs_copydevice(device)\");\n     }\n     return code;\n }", "target": 1}
{"code": "static char *utf2char(utf16_t *str, char *buffer)\n{\n  char *b = buffer;\n  while (*str != 0x00) {\n    char *chr = (char *)str;\n    *b++ = *chr;\n    str++;\n  }\n  *b = 0;\n  return buffer;\n}", "target": 1}
{"code": "std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type) {\n  std::vector<std::string> subject_alt_names;\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(&cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return subject_alt_names;\n  }\n  for (const GENERAL_NAME* san : san_names.get()) {\n    if (san->type == type) {\n      subject_alt_names.push_back(generalNameAsString(san));\n    }\n  }\n  return subject_alt_names;\n}", "target": 1}
{"code": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, \"w.ufdio\");\n\tumask(old_umask);\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}", "target": 1}
{"code": "static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    cmd_parse_list(idata, s);\n    return;\n  }\n  if (!ImapCheckSubscribed)\n    return;\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  if (!list.name || list.noselect)\n    return;\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}", "target": 1}
{"code": "static int binder_thread_release(struct binder_proc *proc,\n\t\t\t\t struct binder_thread *thread)\n{\n\tstruct binder_transaction *t;\n\tstruct binder_transaction *send_reply = NULL;\n\tint active_transactions = 0;\n\tstruct binder_transaction *last_t = NULL;\n\tbinder_inner_proc_lock(thread->proc);\n\tproc->tmp_ref++;\n\tatomic_inc(&thread->tmp_ref);\n\trb_erase(&thread->rb_node, &proc->threads);\n\tt = thread->transaction_stack;\n\tif (t) {\n\t\tspin_lock(&t->lock);\n\t\tif (t->to_thread == thread)\n\t\t\tsend_reply = t;\n\t}\n\tthread->is_dead = true;\n\twhile (t) {\n\t\tlast_t = t;\n\t\tactive_transactions++;\n\t\tbinder_debug(BINDER_DEBUG_DEAD_TRANSACTION,\n\t\t\t     \"release %d:%d transaction %d %s, still active\\n\",\n\t\t\t      proc->pid, thread->pid,\n\t\t\t     t->debug_id,\n\t\t\t     (t->to_thread == thread) ? \"in\" : \"out\");\n\t\tif (t->to_thread == thread) {\n\t\t\tt->to_proc = NULL;\n\t\t\tt->to_thread = NULL;\n\t\t\tif (t->buffer) {\n\t\t\t\tt->buffer->transaction = NULL;\n\t\t\t\tt->buffer = NULL;\n\t\t\t}\n\t\t\tt = t->to_parent;\n\t\t} else if (t->from == thread) {\n\t\t\tt->from = NULL;\n\t\t\tt = t->from_parent;\n\t\t} else\n\t\t\tBUG();\n\t\tspin_unlock(&last_t->lock);\n\t\tif (t)\n\t\t\tspin_lock(&t->lock);\n\t}\n\tif ((thread->looper & BINDER_LOOPER_STATE_POLL) &&\n\t    waitqueue_active(&thread->wait)) {\n\t\twake_up_poll(&thread->wait, EPOLLHUP | POLLFREE);\n\t}\n\tbinder_inner_proc_unlock(thread->proc);\n\tif (send_reply)\n\t\tbinder_send_failed_reply(send_reply, BR_DEAD_REPLY);\n\tbinder_release_work(proc, &thread->todo);\n\tbinder_thread_dec_tmpref(thread);\n\treturn active_transactions;\n}", "target": 1}
{"code": "static inline void *host_from_stream_offset(QEMUFile *f,\n                                            ram_addr_t offset,\n                                            int flags)\n{\n    static RAMBlock *block = NULL;\n    char id[256];\n    uint8_t len;\n    if (flags & RAM_SAVE_FLAG_CONTINUE) {\n        if (!block) {\n            error_report(\"Ack, bad migration stream!\");\n            return NULL;\n        }\n        return memory_region_get_ram_ptr(block->mr) + offset;\n    }\n    len = qemu_get_byte(f);\n    qemu_get_buffer(f, (uint8_t *)id, len);\n    id[len] = 0;\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n        if (!strncmp(id, block->idstr, sizeof(id)))\n            return memory_region_get_ram_ptr(block->mr) + offset;\n    }\n    error_report(\"Can't find block %s!\", id);\n    return NULL;\n}", "target": 1}
{"code": "  QUInt16() {}", "target": 1}
{"code": "__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "static int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\tpr_debug(\"\\n\");\n#endif\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; \n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\tparams->resp_avail(params->v);\n\treturn 0;\n}", "target": 1}
{"code": "String preg_quote(const String& str,\n                  const String& delimiter ) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n  if (in_str == in_str_end) {\n    return str;\n  }\n  char delim_char = 0;      \n  bool quote_delim = false; \n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n  return ret.setSize(q - out_str);\n}", "target": 1}
{"code": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n {\n     OPJ_UINT32 l_data_size;\n    l_data_size = 1 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                    (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n     if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}", "target": 1}
{"code": "srs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}", "target": 1}
{"code": "static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint rc;\n\tpr_debug(\"sock=%p sk=%p len=%zu flags=%d\\n\", sock, sk, len, flags);\n\tskb = skb_recv_datagram(sk, flags, noblock, &rc);\n\tif (!skb)\n\t\treturn rc;\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tskb_free_datagram(sk, skb);\n\treturn rc ? : copied;\n}", "target": 1}
{"code": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tchar *options;\n\tif (flags & MS_KERNMOUNT) {\n\t\tns = (struct pid_namespace *)data;\n\t\toptions = NULL;\n\t} else {\n\t\tns = task_active_pid_ns(current);\n\t\toptions = data;\n\t\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))\n\t\t\treturn ERR_PTR(-EPERM);\n\t}\n\tsb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);\n \tif (IS_ERR(sb))\n \t\treturn ERR_CAST(sb);\n \tif (!proc_parse_options(options, ns)) {\n \t\tdeactivate_locked_super(sb);\n \t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (!sb->s_root) {\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tsb->s_flags |= MS_ACTIVE;\n\t\tsb->s_iflags |= SB_I_NOEXEC;\n\t}\n\treturn dget(sb->s_root);\n}", "target": 1}
{"code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}", "target": 1}
{"code": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n \tif (url_len < 1)\n \t\treturn false;\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n \tif (port_len) {\n \t\tchar *slash;\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\treturn true;\n}", "target": 1}
{"code": "decode_definite_bytestring(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL;\n    ret = PyBytes_FromStringAndSize(NULL, length);\n    if (!ret)\n        return NULL;\n    if (fp_read(self, PyBytes_AS_STRING(ret), length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 1}
{"code": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_int n;\n  mrb_value val;\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  };\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}", "target": 1}
{"code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  uint pos = 0;\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n  for(uint i = 0; i < commentFields; i++) {\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n    addField(key, value, false);\n  }\n}", "target": 1}
{"code": "int PackLinuxElf64::canUnpack()\n{\n    if (super::canUnpack()) {\n        return true;\n    }\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf64help1(fi);\n        Elf64_Phdr const *phdr = phdri, *last_LOAD = nullptr;\n        for (unsigned j = 0; j < e_phnum; ++phdr, ++j)\n            if (Elf64_Phdr::PT_LOAD==get_te32(&phdr->p_type)) {\n                last_LOAD = phdr;\n            }\n        if (!last_LOAD)\n            return false;\n        off_t offset = get_te64(&last_LOAD->p_offset);\n        unsigned filesz = get_te64(&last_LOAD->p_filesz);\n        fi->seek(filesz+offset, SEEK_SET);\n        MemBuffer buf(32 + sizeof(overlay_offset));\n        fi->readx(buf, buf.getSize());\n        return PackUnix::find_overlay_offset(buf);\n    }\n    return false;\n}", "target": 1}
{"code": "  tt_cmap8_validate( FT_Byte*      table,\n                     FT_Validator  valid )\n  {\n    FT_Byte*   p = table + 4;\n    FT_Byte*   is32;\n    FT_UInt32  length;\n    FT_UInt32  num_groups;\n    if ( table + 16 + 8192 > valid->limit )\n      FT_INVALID_TOO_SHORT;\n    length = TT_NEXT_ULONG( p );\n    if ( length > (FT_UInt32)( valid->limit - table ) || length < 8192 + 16 )\n      FT_INVALID_TOO_SHORT;\n    is32       = table + 12;\n     p          = is32  + 8192;          \n     num_groups = TT_NEXT_ULONG( p );\n    if ( p + num_groups * 12 > valid->limit )\n       FT_INVALID_TOO_SHORT;\n      FT_UInt32  n, start, end, start_id, count, last = 0;\n      for ( n = 0; n < num_groups; n++ )\n      {\n        FT_UInt   hi, lo;\n        start    = TT_NEXT_ULONG( p );\n        end      = TT_NEXT_ULONG( p );\n        start_id = TT_NEXT_ULONG( p );\n        if ( start > end )\n          FT_INVALID_DATA;\n        if ( n > 0 && start <= last )\n          FT_INVALID_DATA;\n         if ( valid->level >= FT_VALIDATE_TIGHT )\n         {\n          if ( start_id + end - start >= TT_VALID_GLYPH_COUNT( valid ) )\n             FT_INVALID_GLYPH_ID;\n           count = (FT_UInt32)( end - start + 1 );\n            {\n              hi = (FT_UInt)( start >> 16 );\n              lo = (FT_UInt)( start & 0xFFFFU );\n              if ( (is32[hi >> 3] & ( 0x80 >> ( hi & 7 ) ) ) == 0 )\n                FT_INVALID_DATA;\n              if ( (is32[lo >> 3] & ( 0x80 >> ( lo & 7 ) ) ) == 0 )\n                FT_INVALID_DATA;\n            }\n          }\n          else\n          {\n            if ( end & ~0xFFFFU )\n              FT_INVALID_DATA;\n            for ( ; count > 0; count--, start++ )\n            {\n              lo = (FT_UInt)( start & 0xFFFFU );\n              if ( (is32[lo >> 3] & ( 0x80 >> ( lo & 7 ) ) ) != 0 )\n                FT_INVALID_DATA;\n            }\n          }\n        }\n        last = end;\n      }", "target": 1}
{"code": "CURLcode Curl_ntlm_core_mk_ntlmv2_hash(const char *user, size_t userlen,\n                                       const char *domain, size_t domlen,\n                                       unsigned char *ntlmhash,\n                                       unsigned char *ntlmv2hash)\n{\n  size_t identity_len = (userlen + domlen) * 2;\n  unsigned char *identity = malloc(identity_len);\n  CURLcode result = CURLE_OK;\n  if(!identity)\n    return CURLE_OUT_OF_MEMORY;\n  ascii_uppercase_to_unicode_le(identity, user, userlen);\n  ascii_to_unicode_le(identity + (userlen << 1), domain, domlen);\n  result = Curl_hmac_md5(ntlmhash, 16, identity, curlx_uztoui(identity_len),\n                         ntlmv2hash);\n  free(identity);\n  return result;\n}", "target": 1}
{"code": "static int inotify_update_existing_watch(struct fsnotify_group *group,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t u32 arg)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\t__u32 old_mask, new_mask;\n\t__u32 mask;\n\tint add = (arg & IN_MASK_ADD);\n\tint create = (arg & IN_MASK_CREATE);\n\tint ret;\n\tmask = inotify_arg_to_mask(arg);\n\tfsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tif (!fsn_mark)\n\t\treturn -ENOENT;\n\telse if (create)\n\t\treturn -EEXIST;\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\tspin_lock(&fsn_mark->lock);\n\told_mask = fsn_mark->mask;\n\tif (add)\n\t\tfsn_mark->mask |= mask;\n\telse\n\t\tfsn_mark->mask = mask;\n\tnew_mask = fsn_mark->mask;\n\tspin_unlock(&fsn_mark->lock);\n\tif (old_mask != new_mask) {\n\t\tint dropped = (old_mask & ~new_mask);\n\t\tint do_inode = (new_mask & ~inode->i_fsnotify_mask);\n\t\tif (dropped || do_inode)\n\t\t\tfsnotify_recalc_mask(inode->i_fsnotify_marks);\n\t}\n\tret = i_mark->wd;\n\tfsnotify_put_mark(fsn_mark);\n\treturn ret;\n}", "target": 1}
{"code": "spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "local void init_block(s)\n    deflate_state *s;\n{\n    int n; \n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n    s->dyn_ltree[END_BLOCK].Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->last_lit = s->matches = 0;\n}", "target": 1}
{"code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n \t\terr = 0;\n\t\tif (!mp->ports && !mp->mglist &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n \t\tbreak;\n\t}\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "ConnectClientToUnixSock(const char *sockFile)\n{\n#ifdef WIN32\n  rfbClientErr(\"Windows doesn't support UNIX sockets\\n\");\n  return -1;\n#else\n  int sock;\n  struct sockaddr_un addr;\n  addr.sun_family = AF_UNIX;\n  strcpy(addr.sun_path, sockFile);\n  sock = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\"ConnectToUnixSock: socket (%s)\\n\",strerror(errno));\n    return -1;\n  }\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0) {\n    rfbClientErr(\"ConnectToUnixSock: connect\\n\");\n    close(sock);\n    return -1;\n  }\n  return sock;\n#endif\n}", "target": 1}
{"code": "  bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) override {\n    isvalid = true;\n    return true;\n  };", "target": 1}
{"code": "php_stream *php_stream_zip_opener(php_stream_wrapper *wrapper,\n\t\t\t\t\t\t\t\t\t\t\tchar *path,\n\t\t\t\t\t\t\t\t\t\t\tchar *mode,\n\t\t\t\t\t\t\t\t\t\t\tint options,\n                                                                                        char **opened_path,\n                                                                                        php_stream_context *context STREAMS_DC TSRMLS_DC)\n {\n       int path_len;\n        char *file_basename;\n        size_t file_basename_len;\n\tchar file_dirname[MAXPATHLEN];\n        struct zip *za;\n        struct zip_file *zf = NULL;\n        char *fragment;\n       int fragment_len;\n        int err;\n        php_stream *stream = NULL;\n\tstruct php_zip_stream_data_t *self;\n\tfragment = strchr(path, '#');\n\tif (!fragment) {\n\t\treturn NULL;\n\t}\n\tif (strncasecmp(\"zip:\n\t\tpath += 6;\n\t}\n\tfragment_len = strlen(fragment);\n\tif (fragment_len < 1) {\n\t\treturn NULL;\n\t}\n\tpath_len = strlen(path);\n\tif (path_len >= MAXPATHLEN || mode[0] != 'r') {\n\t\treturn NULL;\n\t}\n\tmemcpy(file_dirname, path, path_len - fragment_len);\n\tfile_dirname[path_len - fragment_len] = '\\0';\n\tphp_basename(path, path_len - fragment_len, NULL, 0, &file_basename, &file_basename_len TSRMLS_CC);\n\tfragment++;\n\tif (ZIP_OPENBASEDIR_CHECKPATH(file_dirname)) {\n\t\tefree(file_basename);\n\t\treturn NULL;\n\t}\n\tza = zip_open(file_dirname, ZIP_CREATE, &err);\n\tif (za) {\n\t\tzf = zip_fopen(za, fragment, 0);\n\t\tif (zf) {\n                        self = emalloc(sizeof(*self));\n                        self->za = za;\n                       self->zf = zf; \n                        self->stream = NULL;\n                        self->cursor = 0;\n                        stream = php_stream_alloc(&php_stream_zipio_ops, self, NULL, mode);\n\t\t\tif (opened_path) {\n\t\t\t\t*opened_path = estrdup(path);\n\t\t\t}\n\t\t} else {\n\t\t\tzip_close(za);\n\t\t}\n\t}\n\tefree(file_basename);\n\tif (!stream) {\n\t\treturn NULL;\n\t} else {\n\t\treturn stream;\n\t}\n}", "target": 1}
{"code": "CallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n  ComputedPropertyDescriptor desc;\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}", "target": 1}
{"code": "static void skcipher_release(void *private)\n{\n\tcrypto_free_skcipher(private);\n}", "target": 1}
{"code": " static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n \tunsigned char max_level = 0;\n \tint unix_sock_count = 0;\n \tfor (i = scm->fp->count - 1; i >= 0; i--) {\n \t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n \tif (!UNIXCB(skb).fp)\n \t\treturn -ENOMEM;\n\tif (unix_sock_count) {\n\t\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\t\tunix_inflight(scm->fp->fp[i]);\n\t}\n \treturn max_level;\n }", "target": 1}
{"code": "  void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                        const Tensor& in, Tensor* out) {\n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx->eigen_device<CPUDevice>();\n    auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();\n    const auto input_dims = input.dimensions();\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape temp_shape{input_dims[0]};\n    for (int i = 1; i <= FFTRank; ++i) {\n      input_slice_sizes[i] = fft_shape[i - 1];\n      temp_shape.AddDim(fft_shape[i - 1]);\n    }\n    auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();\n    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;\n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                           temp_shape, &temp));\n    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n    full_fft.device(device) =\n        input.slice(zero_start_indices, input_slice_sizes)\n            .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);\n    output.device(device) =\n        full_fft.slice(zero_start_indices, output.dimensions());\n  }", "target": 1}
{"code": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if (size < 2 || o > size-2) throw Error(kerNotACrwImage);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        for (uint16_t i = 0; i < count; ++i) {\n            if (o + 10 > size) throw Error(kerNotACrwImage);\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::AutoPtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;\n            default: m = CiffComponent::AutoPtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(m);\n            o += 10;\n        }\n    }  ", "target": 1}
{"code": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}", "target": 1}
{"code": "void PDFDoc::markObject (Object* obj, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict*> *alreadyMarkedDicts)\n{\n  Array *array;\n  switch (obj->getType()) {\n    case objArray:\n      array = obj->getArray();\n      for (int i=0; i<array->getLength(); i++) {\n        Object obj1 = array->getNF(i).copy();\n        markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum);\n      }\n      break;\n    case objDict:\n      markDictionnary (obj->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);\n      break;\n    case objStream: \n      {\n        Stream *stream = obj->getStream();\n        markDictionnary (stream->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);\n      }\n      break;\n    case objRef:\n      {\n        if (obj->getRef().num + (int) numOffset >= xRef->getNumObjects() || xRef->getEntry(obj->getRef().num + numOffset)->type == xrefEntryFree) {\n          if (getXRef()->getEntry(obj->getRef().num)->type == xrefEntryFree) {\n            return;  \n          }\n          xRef->add(obj->getRef().num + numOffset, obj->getRef().gen, 0, true);\n          if (getXRef()->getEntry(obj->getRef().num)->type == xrefEntryCompressed) {\n            xRef->getEntry(obj->getRef().num + numOffset)->type = xrefEntryCompressed;\n          }\n        }\n        if (obj->getRef().num + (int) numOffset >= countRef->getNumObjects() || \n            countRef->getEntry(obj->getRef().num + numOffset)->type == xrefEntryFree)\n        {\n          countRef->add(obj->getRef().num + numOffset, 1, 0, true);\n        } else {\n          XRefEntry *entry = countRef->getEntry(obj->getRef().num + numOffset);\n          entry->gen++;\n          if (entry->gen > 9)\n            break;\n        } \n        Object obj1 = getXRef()->fetch(obj->getRef());\n        markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum);\n      }\n      break;\n    default:\n      break;\n  }\n}", "target": 1}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[1]) << 32) + X[0]);\n}", "target": 1}
{"code": "void php_filter_validate_url(PHP_INPUT_FILTER_PARAM_DECL) \n{\n\tphp_url *url;\n\tsize_t old_len = Z_STRLEN_P(value);\n\tif (flags & (FILTER_FLAG_SCHEME_REQUIRED | FILTER_FLAG_HOST_REQUIRED)) {\n\t\tphp_error_docref(NULL, E_DEPRECATED,\n\t\t\t\"explicit use of FILTER_FLAG_SCHEME_REQUIRED and FILTER_FLAG_HOST_REQUIRED is deprecated\");\n\t}\n\tphp_filter_url(value, flags, option_array, charset);\n\tif (Z_TYPE_P(value) != IS_STRING || old_len != Z_STRLEN_P(value)) {\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\turl = php_url_parse_ex(Z_STRVAL_P(value), Z_STRLEN_P(value));\n\tif (url == NULL) {\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\tif (url->scheme != NULL &&\n\t\t(zend_string_equals_literal_ci(url->scheme, \"http\") || zend_string_equals_literal_ci(url->scheme, \"https\"))) {\n\t\tchar *e, *s, *t;\n\t\tsize_t l;\n\t\tif (url->host == NULL) {\n\t\t\tgoto bad_url;\n\t\t}\n\t\ts = ZSTR_VAL(url->host);\n\t\tl = ZSTR_LEN(url->host);\n\t\te = s + l;\n\t\tt = e - 1;\n\t\tif (*s == '[' && *t == ']' && _php_filter_validate_ipv6((s + 1), l - 2)) {\n\t\t\tphp_url_free(url);\n\t\t\treturn;\n\t\t}\n\t\tif (!_php_filter_validate_domain(ZSTR_VAL(url->host), l, FILTER_FLAG_HOSTNAME)) {\n\t\t\tphp_url_free(url);\n\t\t\tRETURN_VALIDATION_FAILED\n\t\t}\n\t}\n\tif (\n\t\turl->scheme == NULL ||\n\t\t(url->host == NULL && (strcmp(ZSTR_VAL(url->scheme), \"mailto\") && strcmp(ZSTR_VAL(url->scheme), \"news\") && strcmp(ZSTR_VAL(url->scheme), \"file\"))) ||\n\t\t((flags & FILTER_FLAG_PATH_REQUIRED) && url->path == NULL) || ((flags & FILTER_FLAG_QUERY_REQUIRED) && url->query == NULL)\n\t) {\nbad_url:\n\t\tphp_url_free(url);\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\tif (url->user != NULL && !is_userinfo_valid(url->user)) {\n\t\tphp_url_free(url);\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\tphp_url_free(url);\n}", "target": 1}
{"code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n {\n \tunsigned int u = 0;\n \tLineContribType *res;\n\tint overflow_error = 0;\n \tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n \tif (!res) {\n \t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n \t\treturn NULL;\n \t}\n \tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n \t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n \t\t\t\tgdFree(res->ContribRow[i].Weights);\n \t\t\t}\n \t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)\n{\n  DTD * const dtd = parser->m_dtd;  \n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (!poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (!poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (!prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n       else\n         poolDiscard(&dtd->pool);\n       elementType->prefix = prefix;\n     }\n   }\n   return 1;\n}", "target": 1}
{"code": "print_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n   ND_TCHECK2(data[0],length);\n   switch(attr_code)\n   {\n      case TUNNEL_PASS:\n           if (length < 3)\n           {\n              ND_PRINT((ndo, \"%s\", tstr));\n              return;\n           }\n           if (*data && (*data <=0x1F) )\n              ND_PRINT((ndo, \"Tag[%u] \", *data));\n           else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n           if (*data <= 0x1F)\n           {\n              if (length < 1)\n              {\n                 ND_PRINT((ndo, \"%s\", tstr));\n                 return;\n              }\n              if (*data)\n                ND_PRINT((ndo, \"Tag[%u] \", *data));\n              else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n           }\n        break;\n      case EGRESS_VLAN_NAME:\n           ND_PRINT((ndo, \"%s (0x%02x) \",\n                  tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                  *data));\n           data++;\n           length--;\n        break;\n   }\n   for (i=0; *data && i < length ; i++, data++)\n       ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n   return;\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}", "target": 1}
{"code": "static int perf_swevent_init(struct perf_event *event)\n{\n\tint event_id = event->attr.config;\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\tif (!event->parent) {\n\t\tint err;\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void EventPluginsManager::loadPlugin(const QString &pluginId)\n{\n    QPluginLoader loader(\"plasmacalendarplugins/\" + pluginId);\n    if (!loader.load()) {\n        qWarning() << \"Could not create Plasma Calendar Plugin: \" << pluginId;\n        qWarning() << loader.errorString();\n        return;\n    }\n    QObject *obj = loader.instance();\n    if (obj) {\n        CalendarEvents::CalendarEventsPlugin *eventsPlugin = qobject_cast<CalendarEvents::CalendarEventsPlugin *>(obj);\n        if (eventsPlugin) {\n            qDebug() << \"Loading Calendar plugin\" << eventsPlugin;\n            eventsPlugin->setProperty(\"pluginId\", pluginId);\n            d->plugins << eventsPlugin;\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::dataReady, this, &EventPluginsManager::dataReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventModified, this, &EventPluginsManager::eventModified);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventRemoved, this, &EventPluginsManager::eventRemoved);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::alternateCalendarDateReady, this, &EventPluginsManager::alternateCalendarDateReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::subLabelReady, this, &EventPluginsManager::subLabelReady);\n        } else {\n            loader.unload();\n        }\n    } else {\n        loader.unload();\n    }\n}", "target": 1}
{"code": "size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address)\n {\n     return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"s256\");\n }", "target": 1}
{"code": "check(str, sub, should)\nchar *str;\nmy_regmatch_t sub;\nchar *should;\n{\n\tregister int len;\n\tregister int shlen;\n\tregister char *p;\n\tstatic char grump[500];\n\tregister char *at = NULL;\n\tif (should != NULL && strcmp(should, \"-\") == 0)\n\t\tshould = NULL;\n\tif (should != NULL && should[0] == '@') {\n\t\tat = should + 1;\n\t\tshould = (char*) \"\";\n\t}\n\tif (sub.rm_so > sub.rm_eo || (sub.rm_so == -1 && sub.rm_eo != -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_eo == -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_so < 0) ||\n\t\t\t\t(sub.rm_eo != -1 && sub.rm_eo < 0) ) {\n\t\tsprintf(grump, \"start %ld end %ld\", (long)sub.rm_so,\n\t\t\t\t\t\t\t(long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\tif (sub.rm_so == -1 && should == NULL)\n\t\treturn(NULL);\n\tif (sub.rm_so == -1)\n\t\treturn((char*) \"did not match\");\n\tif ((int) sub.rm_eo > (int) strlen(str)) {\n\t\tsprintf(grump, \"start %ld end %ld, past end of string\",\n\t\t\t\t\t(long)sub.rm_so, (long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\tlen = (int)(sub.rm_eo - sub.rm_so);\n\tshlen = (int)strlen(should);\n\tp = str + sub.rm_so;\n\tif (should == NULL) {\n\t\tsprintf(grump, \"matched `%.*s'\", len, p);\n\t\treturn(grump);\n\t}\n\tif (len != shlen || strncmp(p, should, (size_t)shlen) != 0) {\n\t\tsprintf(grump, \"matched `%.*s' instead\", len, p);\n\t\treturn(grump);\n\t}\n\tif (shlen > 0)\n\t\treturn(NULL);\n\tif (at == NULL)\n\t\treturn(NULL);\n\tshlen = strlen(at);\n\tif (shlen == 0)\n\t\tshlen = 1;\t\n\tif (strncmp(p, at, shlen) != 0) {\n\t\tsprintf(grump, \"matched null at `%.20s'\", p);\n\t\treturn(grump);\n\t}\n\treturn(NULL);\n}", "target": 1}
{"code": "int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_sock *sk_inet;\n\tstruct inet_connection_sock *sk_conn;\n\tif (sk == NULL)\n\t\treturn 0;\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto socket_setattr_failure;\n\tbuf_len = ret_val;\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\tsk_inet = inet_sk(sk);\n\tif (sk_inet->is_icsk) {\n\t\tsk_conn = inet_csk(sk);\n\t\tif (sk_inet->opt)\n\t\t\tsk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;\n\t\tsk_conn->icsk_ext_hdr_len += opt->optlen;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n\topt = xchg(&sk_inet->opt, opt);\n\tkfree(opt);\n\treturn 0;\nsocket_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1}
{"code": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {\n\t\tuint8_t desc[20];\n\t\tconst char *btype;\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "WebContents* DevToolsWindow::OpenURLFromTab(\n    WebContents* source,\n    const content::OpenURLParams& params) {\n   DCHECK(source == main_web_contents_);\n   if (!params.url.SchemeIs(content::kChromeDevToolsScheme)) {\n     WebContents* inspected_web_contents = GetInspectedWebContents();\n    return inspected_web_contents ?\n        inspected_web_contents->OpenURL(params) : NULL;\n   }\n   bindings_->Reload();\n   return main_web_contents_;\n}", "target": 1}
{"code": "int gg_change_status_descr(struct gg_session *sess, int status, const char *descr)\n{\n\tstruct gg_new_status80 p;\n\tchar *gen_descr = NULL;\n\tint descr_len = 0;\n\tint res;\n\tgg_debug_session(sess, GG_DEBUG_FUNCTION, \"** gg_change_status_descr(%p, %d, \\\"%s\\\");\\n\", sess, status, descr);\n\tif (!sess) {\n\t\terrno = EFAULT;\n\t\treturn -1;\n\t}\n\tif (sess->state != GG_STATE_CONNECTED) {\n\t\terrno = ENOTCONN;\n\t\treturn -1;\n\t}\n\tsess->status = status;\n\tif (descr != NULL && sess->encoding != GG_ENCODING_UTF8) {\n\t\tdescr = gen_descr = gg_encoding_convert(descr, GG_ENCODING_CP1250, GG_ENCODING_UTF8, -1, -1);\n\t\tif (!gen_descr)\n\t\t\treturn -1;\n\t}\n\tif (descr) {\n\t\tdescr_len = strlen(descr);\n\t\tif (descr_len > GG_STATUS_DESCR_MAXSIZE)\n\t\t\tdescr_len = GG_STATUS_DESCR_MAXSIZE;\n\t} else {\n\t\tdescr = \"\";\n\t}\n\tp.status\t\t= gg_fix32(status);\n\tp.flags\t\t\t= gg_fix32(sess->status_flags);\n\tp.description_size\t= gg_fix32(descr_len);\n\tif (sess->protocol_version >= GG_PROTOCOL_110) {\n\t\tp.flags = gg_fix32(0x00000014);\n\t\tdescr_len++; \n\t}\n\tres = gg_send_packet(sess, GG_NEW_STATUS80, \n\t\t\t&p, sizeof(p), \n\t\t\tdescr, descr_len,\n\t\t\tNULL);\n\tfree(gen_descr);\n\tif (GG_S_NA(status)) {\n\t\tsess->state = GG_STATE_DISCONNECTING;\n\t\tsess->timeout = GG_TIMEOUT_DISCONNECT;\n\t}\n\treturn res;\n}", "target": 1}
{"code": "find_entry2modify_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "static void listdir(unsigned int depth, int f, void * const tls_fd,\n                    const char *name)\n{\n    PureFileInfo *dir;\n    char *names;\n    PureFileInfo *s;\n    PureFileInfo *r;\n    int d;\n    if (depth >= max_ls_depth || matches >= max_ls_files) {\n        return;\n    }\n    if ((dir = sreaddir(&names)) == NULL) {\n        addreply(226, MSG_CANT_READ_FILE, name);\n        return;\n    }\n    s = dir;\n    while (s->name_offset != (size_t) -1) {\n        d = 0;\n        if (FI_NAME(s)[0] != '.') {\n            d = listfile(s, NULL);\n        } else if (opt_a) {\n            if (FI_NAME(s)[1] == 0 ||\n                (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {\n                listfile(s, NULL);\n            } else {\n                d = listfile(s, NULL);\n            }\n        }\n        if (!d) {\n            s->name_offset = (size_t) -1;\n        }\n        s++;\n    }\n    outputfiles(f, tls_fd);\n    r = dir;\n    while (opt_R && r != s) {\n        if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {\n            char *alloca_subdir;\n            const size_t sizeof_subdir = PATH_MAX + 1U;\n            if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {\n                goto toomany;\n            }\n            if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",\n                                 name, FI_NAME(r)), sizeof_subdir)) {\n                goto nolist;\n            }\n            wrstr(f, tls_fd, \"\\r\\n\\r\\n\");\n            wrstr(f, tls_fd, alloca_subdir);\n            wrstr(f, tls_fd, \":\\r\\n\\r\\n\");\n            listdir(depth + 1U, f, tls_fd, alloca_subdir);\n            nolist:\n            ALLOCA_FREE(alloca_subdir);\n            if (matches >= max_ls_files) {\n                goto toomany;\n            }\n            if (chdir(\"..\")) {    \n                if (chdir(wd) || chdir(name)) {    \n                    die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                }\n            }\n        }\n        r++;\n    }\n    toomany:\n    free(names);\n    free(dir);\n    names = NULL;\n}", "target": 1}
{"code": "static int vt_kdsetmode(struct vc_data *vc, unsigned long mode)\n{\n\tswitch (mode) {\n\tcase KD_GRAPHICS:\n\t\tbreak;\n\tcase KD_TEXT0:\n\tcase KD_TEXT1:\n\t\tmode = KD_TEXT;\n\t\tfallthrough;\n\tcase KD_TEXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (vc->vc_mode == mode)\n\t\treturn 0;\n\tvc->vc_mode = mode;\n\tif (vc->vc_num != fg_console)\n\t\treturn 0;\n\tconsole_lock();\n\tif (mode == KD_TEXT)\n\t\tdo_unblank_screen(1);\n\telse\n\t\tdo_blank_screen(1);\n\tconsole_unlock();\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "int dhcp6_option_append_ia(uint8_t **buf, size_t *buflen, const DHCP6IA *ia) {\n        uint16_t len;\n        uint8_t *ia_hdr;\n        size_t iaid_offset, ia_buflen, ia_addrlen = 0;\n        DHCP6Address *addr;\n        int r;\n        assert_return(buf, -EINVAL);\n        assert_return(*buf, -EINVAL);\n        assert_return(buflen, -EINVAL);\n        assert_return(ia, -EINVAL);\n        switch (ia->type) {\n        case SD_DHCP6_OPTION_IA_NA:\n                len = DHCP6_OPTION_IA_NA_LEN;\n                iaid_offset = offsetof(DHCP6IA, ia_na);\n                break;\n        case SD_DHCP6_OPTION_IA_TA:\n                len = DHCP6_OPTION_IA_TA_LEN;\n                iaid_offset = offsetof(DHCP6IA, ia_ta);\n                break;\n        default:\n                return -EINVAL;\n        }\n        if (*buflen < len)\n                return -ENOBUFS;\n        ia_hdr = *buf;\n        ia_buflen = *buflen;\n        *buf += sizeof(DHCP6Option);\n        *buflen -= sizeof(DHCP6Option);\n        memcpy(*buf, (char*) ia + iaid_offset, len);\n        *buf += len;\n        *buflen -= len;\n        LIST_FOREACH(addresses, addr, ia->addresses) {\n                r = option_append_hdr(buf, buflen, SD_DHCP6_OPTION_IAADDR,\n                                      sizeof(addr->iaaddr));\n                if (r < 0)\n                        return r;\n                memcpy(*buf, &addr->iaaddr, sizeof(addr->iaaddr));\n                *buf += sizeof(addr->iaaddr);\n                *buflen -= sizeof(addr->iaaddr);\n                ia_addrlen += sizeof(DHCP6Option) + sizeof(addr->iaaddr);\n        }\n        r = option_append_hdr(&ia_hdr, &ia_buflen, ia->type, len + ia_addrlen);\n        if (r < 0)\n                return r;\n        return 0;\n}", "target": 1}
{"code": "rfbReleaseClientIterator(rfbClientIteratorPtr iterator)\n{\n  if(iterator->next) rfbDecrClientRef(iterator->next);\n  free(iterator);\n}", "target": 1}
{"code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n        ctx->cid = cid;\n    }\n    return 0;\n}", "target": 1}
{"code": "SProcXkbSelectEvents(ClientPtr client)\n{\n    REQUEST(xkbSelectEventsReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);\n    swaps(&stuff->deviceSpec);\n    swaps(&stuff->affectWhich);\n    swaps(&stuff->clear);\n    swaps(&stuff->selectAll);\n    swaps(&stuff->affectMap);\n    swaps(&stuff->map);\n    if ((stuff->affectWhich & (~XkbMapNotifyMask)) != 0) {\n        union {\n            BOOL *b;\n            CARD8 *c8;\n            CARD16 *c16;\n            CARD32 *c32;\n        } from;\n        register unsigned bit, ndx, maskLeft, dataLeft, size;\n        from.c8 = (CARD8 *) &stuff[1];\n        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);\n        maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));\n        for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {\n            if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))\n                continue;\n            maskLeft &= ~bit;\n            if ((stuff->selectAll & bit) || (stuff->clear & bit))\n                continue;\n            switch (ndx) {\n            case XkbNewKeyboardNotify:\n            case XkbStateNotify:\n            case XkbNamesNotify:\n            case XkbAccessXNotify:\n            case XkbExtensionDeviceNotify:\n                size = 2;\n                break;\n            case XkbControlsNotify:\n            case XkbIndicatorStateNotify:\n            case XkbIndicatorMapNotify:\n                size = 4;\n                break;\n            case XkbBellNotify:\n            case XkbActionMessage:\n            case XkbCompatMapNotify:\n                size = 1;\n                break;\n            default:\n                client->errorValue = _XkbErrCode2(0x1, bit);\n                return BadValue;\n            }\n            if (dataLeft < (size * 2))\n                return BadLength;\n            if (size == 2) {\n                swaps(&from.c16[0]);\n                swaps(&from.c16[1]);\n            }\n            else if (size == 4) {\n                swapl(&from.c32[0]);\n                swapl(&from.c32[1]);\n            }\n            else {\n                size = 2;\n            }\n            from.c8 += (size * 2);\n            dataLeft -= (size * 2);\n        }\n        if (dataLeft > 2) {\n            ErrorF(\"[xkb] Extra data (%d bytes) after SelectEvents\\n\",\n                   dataLeft);\n            return BadLength;\n        }\n    }\n    return ProcXkbSelectEvents(client);\n}", "target": 1}
{"code": "delete_principal_2_svc(dprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_DELETE,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_DELETE;\n        log_unauth(\"kadm5_delete_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_delete_principal((void *)handle, arg->princ);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_delete_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_buffer_size( const bson *b ) {\n    return (b->cur - b->data + 1);\n}", "target": 1}
{"code": "int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {\n    keyReference *keys;\n    UNUSED(cmd);\n    UNUSED(argv);\n    UNUSED(argc);\n    keys = getKeysPrepareResult(result, 1);\n    keys[0].pos = 1; \n    keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;\n    return 1;\n}", "target": 1}
{"code": "static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size)\n{\n\tunsigned long cons_pos, prod_pos, new_prod_pos, flags;\n\tu32 len, pg_off;\n\tstruct bpf_ringbuf_hdr *hdr;\n\tif (unlikely(size > RINGBUF_MAX_RECORD_SZ))\n\t\treturn NULL;\n\tlen = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\tif (in_nmi()) {\n\t\tif (!spin_trylock_irqsave(&rb->spinlock, flags))\n\t\t\treturn NULL;\n\t} else {\n\t\tspin_lock_irqsave(&rb->spinlock, flags);\n\t}\n\tprod_pos = rb->producer_pos;\n\tnew_prod_pos = prod_pos + len;\n\tif (new_prod_pos - cons_pos > rb->mask) {\n\t\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\t\treturn NULL;\n\t}\n\thdr = (void *)rb->data + (prod_pos & rb->mask);\n\tpg_off = bpf_ringbuf_rec_pg_off(rb, hdr);\n\thdr->len = size | BPF_RINGBUF_BUSY_BIT;\n\thdr->pg_off = pg_off;\n\tsmp_store_release(&rb->producer_pos, new_prod_pos);\n\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\treturn (void *)hdr + BPF_RINGBUF_HDR_SZ;\n}", "target": 1}
{"code": "cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n                               cherokee_connection_t     *conn)\n{\n\tint                              re;\n\tret_t                            ret;\n\tsize_t                           size;\n\tchar                            *dn;\n\tLDAPMessage                     *message;\n\tLDAPMessage                     *first;\n\tchar                            *attrs[] = { LDAP_NO_ATTRS, NULL };\n\tcherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);\n\tif ((conn->validator == NULL) ||\n\t    cherokee_buffer_is_empty (&conn->validator->user))\n\t\treturn ret_error;\n\tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \"*()\");\n\tif (size != conn->validator->user.len)\n\t\treturn ret_error;\n\tret = init_filter (ldap, props, conn);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);\n\tif (re != LDAP_SUCCESS) {\n\t\tLOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,\n\t\t           props->filter.buf ? props->filter.buf : \"\");\n\t\treturn ret_error;\n\t}\n\tTRACE (ENTRIES, \"subtree search (%s): done\\n\", ldap->filter.buf ? ldap->filter.buf : \"\");\n\tre = ldap_count_entries (ldap->conn, message);\n\tif (re != 1) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tfirst = ldap_first_entry (ldap->conn, message);\n\tif (first == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tdn = ldap_get_dn (ldap->conn, first);\n\tif (dn == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_error;\n\t}\n\tldap_msgfree (message);\n\tret = validate_dn (props, dn, conn->validator->passwd.buf);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_unbind_s (ldap->conn);\n\tif (re != LDAP_SUCCESS)\n\t\treturn ret_error;\n\tTRACE (ENTRIES, \"Access to use %s has been granted\\n\", conn->validator->user.buf);\n\treturn ret_ok;\n}", "target": 1}
{"code": "static void addECSOption(char* packet, const size_t& packetSize, uint16_t* len, const ComboAddress& remote, int stamp)\n{\n  string EDNSRR;\n  struct dnsheader* dh = (struct dnsheader*) packet;\n  EDNSSubnetOpts eso;\n  if(stamp < 0)\n    eso.source = Netmask(remote);\n  else {\n    ComboAddress stamped(remote);\n    *((char*)&stamped.sin4.sin_addr.s_addr)=stamp;\n    eso.source = Netmask(stamped);\n  }\n  string optRData=makeEDNSSubnetOptsString(eso);\n  string record;\n  generateEDNSOption(EDNSOptionCode::ECS, optRData, record);\n  generateOptRR(record, EDNSRR);\n  uint16_t arcount = ntohs(dh->arcount);\n  if (packetSize - *len > EDNSRR.size()) {\n    arcount++;\n    dh->arcount = htons(arcount);\n    memcpy(packet + *len, EDNSRR.c_str(), EDNSRR.size());\n    *len += EDNSRR.size();\n  }\n}", "target": 1}
{"code": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n \t++vcpu->stat.insn_emulation_fail;\n \ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu)) {\n \t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n \t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n \t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn r;\n}", "target": 1}
{"code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(nullptr);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}", "target": 1}
{"code": "static int axff_init(struct hid_device *hid)\n{\n\tstruct axff_device *axff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_first_entry(&hid->inputs, struct hid_input, list);\n\tstruct list_head *report_list =&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint field_count = 0;\n\tint i, j;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tfor (i = 0; i < report->maxfield; i++) {\n\t\tfor (j = 0; j < report->field[i]->report_count; j++) {\n\t\t\treport->field[i]->value[j] = 0x00;\n\t\t\tfield_count++;\n\t\t}\n\t}\n\tif (field_count < 4 && hid->product != 0xf705) {\n\t\thid_err(hid, \"not enough fields in the report: %d\\n\",\n\t\t\tfield_count);\n\t\treturn -ENODEV;\n\t}\n\taxff = kzalloc(sizeof(struct axff_device), GFP_KERNEL);\n\tif (!axff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, axff, axff_play);\n\tif (error)\n\t\tgoto err_free_mem;\n\taxff->report = report;\n\thid_hw_request(hid, axff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force Feedback for ACRUX game controllers by Sergei Kolzun <x0r@dv-life.ru>\\n\");\n\treturn 0;\nerr_free_mem:\n\tkfree(axff);\n\treturn error;\n}", "target": 1}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        DCHECK(attr != nullptr);\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 1}
{"code": "find_entry(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, 0 ) );\n}", "target": 1}
{"code": "vhost_backend_cleanup(struct virtio_net *dev)\n{\n\tif (dev->mem) {\n\t\tfree_mem_region(dev);\n\t\trte_free(dev->mem);\n\t\tdev->mem = NULL;\n\t}\n\tfree(dev->guest_pages);\n\tdev->guest_pages = NULL;\n\tif (dev->log_addr) {\n\t\tmunmap((void *)(uintptr_t)dev->log_addr, dev->log_size);\n\t\tdev->log_addr = 0;\n\t}\n\tif (dev->slave_req_fd >= 0) {\n\t\tclose(dev->slave_req_fd);\n\t\tdev->slave_req_fd = -1;\n\t}\n\tif (dev->postcopy_ufd >= 0) {\n\t\tclose(dev->postcopy_ufd);\n\t\tdev->postcopy_ufd = -1;\n\t}\n\tdev->postcopy_listening = 0;\n}", "target": 1}
{"code": "static int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\tclear_inode_flag(inode, FI_ACL_MODE);\n\treturn error;\n}", "target": 1}
{"code": "void ext4_es_insert_delayed_block(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t  bool allocated)\n{\n\tstruct extent_status newes;\n\tint err1 = 0;\n\tint err2 = 0;\n\tstruct extent_status *es1 = NULL;\n\tstruct extent_status *es2 = NULL;\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\tes_debug(\"add [%u/1) delayed to extent status tree of inode %lu\\n\",\n\t\t lblk, inode->i_ino);\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = 1;\n\text4_es_store_pblock_status(&newes, ~0, EXTENT_STATUS_DELAYED);\n\ttrace_ext4_es_insert_delayed_block(inode, &newes, allocated);\n\text4_es_insert_extent_check(inode, &newes);\nretry:\n\tif (err1 && !es1)\n\t\tes1 = __es_alloc_extent(true);\n\tif ((err1 || err2) && !es2)\n\t\tes2 = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr1 = __es_remove_extent(inode, lblk, lblk, NULL, es1);\n\tif (err1 != 0)\n\t\tgoto error;\n\terr2 = __es_insert_extent(inode, &newes, es2);\n\tif (err2 != 0)\n\t\tgoto error;\n\tif (allocated)\n\t\t__insert_pending(inode, lblk);\n\tif (es1 && !es1->es_len)\n\t\t__es_free_extent(es1);\n\tif (es2 && !es2->es_len)\n\t\t__es_free_extent(es2);\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err1 || err2)\n\t\tgoto retry;\n\text4_es_print_tree(inode);\n\text4_print_pending_tree(inode);\n\treturn;\n}", "target": 1}
{"code": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n        assert(path);\n         if (parents)\n                 mkdir_parents(path, 0755);\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n         if (fd < 0)\n                 return -errno;\n        if (mode != MODE_INVALID) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n {\n \tstruct fb_info *info = file_fb_info(file);\n \tstruct fb_ops *fb;\n\tunsigned long off;\n \tunsigned long start;\n \tu32 len;\n \tif (!info)\n \t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n \tfb = info->fbops;\n \tif (!fb)\n \t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n \t\treturn res;\n \t}\n \tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n \t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n \t}\n \tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n }", "target": 1}
{"code": "static long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n \t\tgoto out;\n \t}\n \tret = vfs_dedupe_file_range(file, same);\n \tif (ret)\n \t\tgoto out;\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\nout:\n\tkfree(same);\n\treturn ret;\n}", "target": 1}
{"code": " bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {\n   SetState(STATE_NORMAL);\n   ui::MouseEvent synthetic_event(\n      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),\n      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);\n  NotifyClick(synthetic_event);\n  return true;\n}", "target": 1}
{"code": "int gru_set_context_option(unsigned long arg)\n{\n\tstruct gru_thread_state *gts;\n\tstruct gru_set_context_option_req req;\n\tint ret = 0;\n\tSTAT(set_context_option);\n\tif (copy_from_user(&req, (void __user *)arg, sizeof(req)))\n\t\treturn -EFAULT;\n\tgru_dbg(grudev, \"op %d, gseg 0x%lx, value1 0x%lx\\n\", req.op, req.gseg, req.val1);\n\tgts = gru_find_lock_gts(req.gseg);\n\tif (!gts) {\n\t\tgts = gru_alloc_locked_gts(req.gseg);\n\t\tif (IS_ERR(gts))\n\t\t\treturn PTR_ERR(gts);\n\t}\n\tswitch (req.op) {\n\tcase sco_blade_chiplet:\n\t\tif (req.val0 < -1 || req.val0 >= GRU_CHIPLETS_PER_HUB ||\n\t\t    req.val1 < -1 || req.val1 >= GRU_MAX_BLADES ||\n\t\t    (req.val1 >= 0 && !gru_base[req.val1])) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tgts->ts_user_blade_id = req.val1;\n\t\t\tgts->ts_user_chiplet_id = req.val0;\n\t\t\tgru_check_context_placement(gts);\n\t\t}\n\t\tbreak;\n\tcase sco_gseg_owner:\n\t\tgts->ts_tgid_owner = current->tgid;\n\t\tbreak;\n\tcase sco_cch_req_slice:\n\t\tgts->ts_cch_req_slice = req.val1 & 3;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tgru_unlock_gts(gts);\n\treturn ret;\n}", "target": 1}
{"code": "static void __net_exit sctp_net_exit(struct net *net)\n{\n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}", "target": 1}
{"code": "int hci_conn_check_link_mode(struct hci_conn *conn)\n{\n\tBT_DBG(\"hcon %p\", conn);\n\tif (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) {\n\t\tif (!hci_conn_sc_enabled(conn) ||\n\t\t    !test_bit(HCI_CONN_AES_CCM, &conn->flags) ||\n\t\t    conn->key_type != HCI_LK_AUTH_COMBINATION_P256)\n\t\t\treturn 0;\n\t}\n\tif (hci_conn_ssp_enabled(conn) &&\n\t    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "gimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n   GimpImage           *image;\n   GimpImage           *loaded_image;\n   GimpPlugInProcedure *proc;\n  gchar               *filename;\n   GFile               *file;\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                          use_gimp_2_8_features);\n  filename = g_build_filename (g_get_tmp_dir (), \"gimp-test.xcf\", NULL);\n   file = g_file_new_for_path (filename);\n   g_free (filename);\n  proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL );\n  file_save (gimp,\n             image,\n             NULL ,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE ,\n             FALSE ,\n             FALSE ,\n             NULL );\n  loaded_image = gimp_test_load_image (image->gimp, file);\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}", "target": 1}
{"code": "hb_set_clear (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->clear ();\n}", "target": 1}
{"code": "DECLAREwriteFunc(writeBufferToContigTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\tuint32 tilew  = TIFFTileRowSize(out);\n\tint iskew = imagew - tilew;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\t(void) spp;\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,\n\t\t\t\t    0, iskew);\n\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\t_TIFFfree(obuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += nrow * imagew;\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}", "target": 1}
{"code": "deltas_head_set_size(struct deltas_head *deltas, size_t capacity)\n{\n\tsize_t i;\n\tif (deltas->array != NULL)\n\t\tpr_crit(\"Size of this list can't be modified\");\n\tdeltas->capacity = capacity;\n\tif (capacity == 0)\n\t\treturn 0; \n\tdeltas->array = malloc(deltas->capacity\n\t    * sizeof(struct delta_head *));\n\tif (deltas->array == NULL)\n\t\treturn pr_enomem();\n\tfor (i = 0; i < deltas->capacity; i++)\n\t\tdeltas->array[i] = NULL;\n\treturn 0;\n}", "target": 1}
{"code": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n\tstruct ieee80211_radiotap_header *radiotap_header,\n\tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n{\n\tif (radiotap_header->it_version)\n\t\treturn -EINVAL;\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader >\n\t\t\t    (unsigned long)iterator->_max_length)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\titerator->_arg += sizeof(uint32_t);\n\t}\n\titerator->this_arg = iterator->_arg;\n\treturn 0;\n}", "target": 1}
{"code": "static int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tstruct ati_remote2 *ar2;\n\tint r;\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn -ENODEV;\n\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n\tar2->udev = udev;\n\tar2->intf[0] = interface;\n\tar2->ep[0] = &alt->endpoint[0].desc;\n\tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n\tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n\tif (r)\n\t\tgoto fail1;\n\talt = ar2->intf[1]->cur_altsetting;\n\tar2->ep[1] = &alt->endpoint[0].desc;\n\tr = ati_remote2_urb_init(ar2);\n\tif (r)\n\t\tgoto fail2;\n\tar2->channel_mask = channel_mask;\n\tar2->mode_mask = mode_mask;\n\tr = ati_remote2_setup(ar2, ar2->channel_mask);\n\tif (r)\n\t\tgoto fail2;\n\tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n\tstrlcat(ar2->phys, \"/input0\", sizeof(ar2->phys));\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n\tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n\tif (r)\n\t\tgoto fail2;\n\tr = ati_remote2_input_init(ar2);\n\tif (r)\n\t\tgoto fail3;\n\tusb_set_intfdata(interface, ar2);\n\tinterface->needs_remote_wakeup = 1;\n\treturn 0;\n fail3:\n\tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail2:\n\tati_remote2_urb_cleanup(ar2);\n\tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n fail1:\n\tkfree(ar2);\n\treturn r;\n}", "target": 1}
{"code": "static int tsc210x_load(QEMUFile *f, void *opaque, int version_id)\n{\n    TSC210xState *s = (TSC210xState *) opaque;\n    int64_t now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    int i;\n    s->x = qemu_get_be16(f);\n    s->y = qemu_get_be16(f);\n    s->pressure = qemu_get_byte(f);\n    s->state = qemu_get_byte(f);\n    s->page = qemu_get_byte(f);\n    s->offset = qemu_get_byte(f);\n    s->command = qemu_get_byte(f);\n    s->irq = qemu_get_byte(f);\n    qemu_get_be16s(f, &s->dav);\n    timer_get(f, s->timer);\n    s->enabled = qemu_get_byte(f);\n    s->host_mode = qemu_get_byte(f);\n    s->function = qemu_get_byte(f);\n    s->nextfunction = qemu_get_byte(f);\n    s->precision = qemu_get_byte(f);\n    s->nextprecision = qemu_get_byte(f);\n    s->filter = qemu_get_byte(f);\n    s->pin_func = qemu_get_byte(f);\n    s->ref = qemu_get_byte(f);\n    s->timing = qemu_get_byte(f);\n    s->noise = qemu_get_be32(f);\n    qemu_get_be16s(f, &s->audio_ctrl1);\n    qemu_get_be16s(f, &s->audio_ctrl2);\n    qemu_get_be16s(f, &s->audio_ctrl3);\n    qemu_get_be16s(f, &s->pll[0]);\n    qemu_get_be16s(f, &s->pll[1]);\n    qemu_get_be16s(f, &s->volume);\n    s->volume_change = qemu_get_sbe64(f) + now;\n    s->powerdown = qemu_get_sbe64(f) + now;\n    s->softstep = qemu_get_byte(f);\n    qemu_get_be16s(f, &s->dac_power);\n    for (i = 0; i < 0x14; i ++)\n        qemu_get_be16s(f, &s->filter_data[i]);\n    s->busy = timer_pending(s->timer);\n    qemu_set_irq(s->pint, !s->irq);\n    qemu_set_irq(s->davint, !s->dav);\n    return 0;\n}", "target": 1}
{"code": "static int sd_compat_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct scsi_device *sdev = scsi_disk(bdev->bd_disk)->device;\n\tif (!scsi_block_when_processing_errors(sdev))\n\t\treturn -ENODEV;\n\tif (sdev->host->hostt->compat_ioctl) {\n\t\tint ret;\n\t\tret = sdev->host->hostt->compat_ioctl(sdev, cmd, (void __user *)arg);\n\t\treturn ret;\n\t}\n\treturn -ENOIOCTLCMD; \n}", "target": 1}
{"code": "TEST_F(TestSPIFFEValidator, TestGetTrustBundleStore) {\n  initialize();\n  auto cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/non_spiffe_san_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/spiffe_san_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  validator().trustBundleStores().emplace(\"example.com\", X509StorePtr(X509_STORE_new()));\n  EXPECT_TRUE(validator().getTrustBundleStore(cert.get()));\n}", "target": 1}
{"code": "static int virtio_gpu_object_shmem_init(struct virtio_gpu_device *vgdev,\n\t\t\t\t\tstruct virtio_gpu_object *bo,\n\t\t\t\t\tstruct virtio_gpu_mem_entry **ents,\n\t\t\t\t\tunsigned int *nents)\n{\n\tbool use_dma_api = !virtio_has_dma_quirk(vgdev->vdev);\n\tstruct virtio_gpu_object_shmem *shmem = to_virtio_gpu_shmem(bo);\n\tstruct scatterlist *sg;\n\tint si, ret;\n\tret = drm_gem_shmem_pin(&bo->base);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tshmem->pages = drm_gem_shmem_get_sg_table(&bo->base);\n\tif (!shmem->pages) {\n\t\tdrm_gem_shmem_unpin(&bo->base);\n\t\treturn -EINVAL;\n\t}\n\tif (use_dma_api) {\n\t\tret = dma_map_sgtable(vgdev->vdev->dev.parent,\n\t\t\t\t      shmem->pages, DMA_TO_DEVICE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*nents = shmem->mapped = shmem->pages->nents;\n\t} else {\n\t\t*nents = shmem->pages->orig_nents;\n\t}\n\t*ents = kvmalloc_array(*nents,\n\t\t\t       sizeof(struct virtio_gpu_mem_entry),\n\t\t\t       GFP_KERNEL);\n\tif (!(*ents)) {\n\t\tDRM_ERROR(\"failed to allocate ent list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (use_dma_api) {\n\t\tfor_each_sgtable_dma_sg(shmem->pages, sg, si) {\n\t\t\t(*ents)[si].addr = cpu_to_le64(sg_dma_address(sg));\n\t\t\t(*ents)[si].length = cpu_to_le32(sg_dma_len(sg));\n\t\t\t(*ents)[si].padding = 0;\n\t\t}\n\t} else {\n\t\tfor_each_sgtable_sg(shmem->pages, sg, si) {\n\t\t\t(*ents)[si].addr = cpu_to_le64(sg_phys(sg));\n\t\t\t(*ents)[si].length = cpu_to_le32(sg->length);\n\t\t\t(*ents)[si].padding = 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int huft_build(const unsigned *b, const unsigned n,\n\t\t\tconst unsigned s, const unsigned short *d,\n\t\t\tconst unsigned char *e, huft_t **t, unsigned *m)\n{\n\tunsigned a;             \n\tunsigned c[BMAX + 1];   \n\tunsigned eob_len;       \n\tunsigned f;             \n\tint g;                  \n\tint htl;                \n \tunsigned i;             \n \tunsigned j;             \n \tint k;                  \n\tunsigned *p;            \n \thuft_t *q;              \n \thuft_t r;               \n \thuft_t *u[BMAX];        \n \tunsigned v[N_MAX];      \n \tint ws[BMAX + 1];       \n \tint w;                  \n \tunsigned x[BMAX + 1];   \n\tint y;                  \n\tunsigned z;             \n\teob_len = n > 256 ? b[256] : BMAX;\n\t*t = NULL;\n \tmemset(c, 0, sizeof(c));\n\tp = (unsigned *) b; \n \ti = n;\n \tdo {\n \t\tc[*p]++; \n\t} while (--i);\n\tif (c[0] == n) {  \n\t\t*m = 0;\n\t\treturn 2;\n\t}\n\tfor (j = 1; (j <= BMAX) && (c[j] == 0); j++)\n\t\tcontinue;\n\tk = j; \n\tfor (i = BMAX; (c[i] == 0) && i; i--)\n\t\tcontinue;\n\tg = i; \n\t*m = (*m < j) ? j : ((*m > i) ? i : *m);\n\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\ty -= c[j];\n\t\tif (y < 0)\n\t\t\treturn 2; \n\t}\n\ty -= c[i];\n\tif (y < 0)\n\t\treturn 2;\n\tc[i] += y;\n\tx[1] = j = 0;\n\tp = c + 1;\n\txp = x + 2;\n\twhile (--i) { \n\t\tj += *p++;\n\t\t*xp++ = j;\n\t}\n \t}", "target": 1}
{"code": "xcf_load_stream (Gimp          *gimp,\n                 GInputStream  *input,\n                 GFile         *input_file,\n                 GimpProgress  *progress,\n                 GError       **error)\n{\n  XcfInfo      info  = { 0, };\n  const gchar *filename;\n  GimpImage   *image = NULL;\n  gchar        id[14];\n  gboolean     success;\n  g_return_val_if_fail (GIMP_IS_GIMP (gimp), NULL);\n  g_return_val_if_fail (G_IS_INPUT_STREAM (input), NULL);\n  g_return_val_if_fail (input_file == NULL || G_IS_FILE (input_file), NULL);\n  g_return_val_if_fail (progress == NULL || GIMP_IS_PROGRESS (progress), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n  if (input_file)\n    filename = gimp_file_get_utf8_name (input_file);\n  else\n    filename = _(\"Memory Stream\");\n  info.gimp             = gimp;\n  info.input            = input;\n  info.seekable         = G_SEEKABLE (input);\n  info.bytes_per_offset = 4;\n  info.progress         = progress;\n  info.file             = input_file;\n  info.compression      = COMPRESS_NONE;\n  if (progress)\n    gimp_progress_start (progress, FALSE, _(\"Opening '%s'\"), filename);\n  success = TRUE;\n  xcf_read_int8 (&info, (guint8 *) id, 14);\n  if (! g_str_has_prefix (id, \"gimp xcf \"))\n    {\n      success = FALSE;\n    }\n  else if (strcmp (id + 9, \"file\") == 0)\n    {\n      info.file_version = 0;\n    }\n  else if (id[9] == 'v')\n    {\n      info.file_version = atoi (id + 10);\n    }\n  else\n    {\n      success = FALSE;\n    }\n  if (info.file_version >= 11)\n    info.bytes_per_offset = 8;\n  if (success)\n    {\n      if (info.file_version >= 0 &&\n          info.file_version < G_N_ELEMENTS (xcf_loaders))\n        {\n          image = (*(xcf_loaders[info.file_version])) (gimp, &info, error);\n          if (! image)\n            success = FALSE;\n          g_input_stream_close (info.input, NULL, NULL);\n        }\n      else\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"XCF error: unsupported XCF file version %d \"\n                         \"encountered\"), info.file_version);\n          success = FALSE;\n        }\n    }\n  if (progress)\n    gimp_progress_end (progress);\n  return image;\n}", "target": 1}
{"code": "int X509_cmp_time(ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n    ASN1_TIME atm;\n    long offset;\n    char buff1[24], buff2[24], *p;\n    int i, j;\n    p = buff1;\n    i = ctm->length;\n    str = (char *)ctm->data;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n            return 0;\n        memcpy(p, str, 10);\n        p += 10;\n        str += 10;\n    } else {\n        if (i < 13)\n            return 0;\n        memcpy(p, str, 12);\n        p += 12;\n        str += 12;\n    }\n    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n        *(p++) = '0';\n        *(p++) = '0';\n    } else {\n        *(p++) = *(str++);\n        *(p++) = *(str++);\n        if (*str == '.') {\n            str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n        }\n    }\n    *(p++) = 'Z';\n    *(p++) = '\\0';\n    if (*str == 'Z')\n        offset = 0;\n    else {\n        if ((*str != '+') && (*str != '-'))\n            return 0;\n        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n        offset += (str[3] - '0') * 10 + (str[4] - '0');\n        if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           \n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 \n        return -1;\n    else\n        return i;\n}", "target": 1}
{"code": "BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, bitmapUpdate->number); \n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT16 count;\n\t\tBITMAP_DATA* newdata;\n\t\tcount = bitmapUpdate->number * 2;\n\t\tnewdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                                 sizeof(BITMAP_DATA) * count);\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}", "target": 1}
{"code": "static INLINE SIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvLen;\n\tData_Read_UINT16(&pAvPair->AvLen, AvLen);\n\treturn AvLen;\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageWBMPPtr(gdImagePtr im, int *size, int fg)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageWBMPCtx(im, fg, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg = NULL;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          ch->n_end_lineno, ch->n_end_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    goto error;\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "void ResourceHandle::FromProto(const ResourceHandleProto& proto) {\n  set_device(proto.device());\n  set_container(proto.container());\n  set_name(proto.name());\n  set_hash_code(proto.hash_code());\n  set_maybe_type_name(proto.maybe_type_name());\n  std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes;\n  for (const auto& dtype_and_shape : proto.dtypes_and_shapes()) {\n    DataType dtype = dtype_and_shape.dtype();\n    PartialTensorShape shape(dtype_and_shape.shape());\n    dtypes_and_shapes.push_back(DtypeAndPartialTensorShape{dtype, shape});\n  }\n  dtypes_and_shapes_ = std::move(dtypes_and_shapes);\n}", "target": 1}
{"code": "void DoImageProjectiveTransformOp(OpKernelContext* ctx,\n                                  const Interpolation& interpolation,\n                                  const Mode& fill_mode) {\n  const Tensor& images_t = ctx->input(0);\n  const Tensor& transform_t = ctx->input(1);\n  OP_REQUIRES(ctx, images_t.shape().dims() == 4,\n              errors::InvalidArgument(\"Input images must have rank 4\"));\n  OP_REQUIRES(ctx,\n              (TensorShapeUtils::IsMatrix(transform_t.shape()) &&\n               (transform_t.dim_size(0) == images_t.dim_size(0) ||\n                transform_t.dim_size(0) == 1) &&\n               transform_t.dim_size(1) == 8),\n              errors::InvalidArgument(\n                  \"Input transform should be num_images x 8 or 1 x 8\"));\n  int32_t out_height, out_width;\n  if (ctx->num_inputs() >= 3) {\n    const Tensor& shape_t = ctx->input(2);\n    OP_REQUIRES(ctx, shape_t.dims() == 1,\n                errors::InvalidArgument(\"output shape must be 1-dimensional\",\n                                        shape_t.shape().DebugString()));\n    OP_REQUIRES(ctx, shape_t.NumElements() == 2,\n                errors::InvalidArgument(\"output shape must have two elements\",\n                                        shape_t.shape().DebugString()));\n    auto shape_vec = shape_t.vec<int32>();\n    out_height = shape_vec(0);\n    out_width = shape_vec(1);\n    OP_REQUIRES(ctx, out_height > 0 && out_width > 0,\n                errors::InvalidArgument(\"output dimensions must be positive\"));\n  } else {\n    out_height = images_t.shape().dim_size(1);\n    out_width = images_t.shape().dim_size(2);\n  }\n  T fill_value(0);\n  if (ctx->num_inputs() >= 4) {\n    const Tensor& fill_value_t = ctx->input(3);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(fill_value_t.shape()),\n                errors::InvalidArgument(\"fill_value must be a scalar\",\n                                        fill_value_t.shape().DebugString()));\n    fill_value = static_cast<T>(*(fill_value_t.scalar<float>().data()));\n  }\n  Tensor* output_t;\n  OP_REQUIRES_OK(\n      ctx, ctx->allocate_output(0,\n                                TensorShape({images_t.dim_size(0), out_height,\n                                             out_width, images_t.dim_size(3)}),\n                                &output_t));\n  auto output = output_t->tensor<T, 4>();\n  auto images = images_t.tensor<T, 4>();\n  auto transform = transform_t.matrix<float>();\n  (FillProjectiveTransform<Device, T>(interpolation))(\n      ctx->eigen_device<Device>(), &output, images, transform, fill_mode,\n      fill_value);\n}", "target": 1}
{"code": "void CConfig::Write(CFile& File, unsigned int iIndentation) {\n    CString sIndentation = CString(iIndentation, '\\t');\n    for (const auto& it : m_ConfigEntries) {\n        for (const CString& sValue : it.second) {\n            File.Write(sIndentation + it.first + \" = \" + sValue + \"\\n\");\n        }\n    }\n    for (const auto& it : m_SubConfigs) {\n        for (const auto& it2 : it.second) {\n            File.Write(\"\\n\");\n            File.Write(sIndentation + \"<\" + it.first + \" \" + it2.first + \">\\n\");\n            it2.second.m_pSubConfig->Write(File, iIndentation + 1);\n            File.Write(sIndentation + \"</\" + it.first + \">\\n\");\n        }\n    }\n}", "target": 1}
{"code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_reset_classperms_list(cp->classperms);\n}", "target": 1}
{"code": "static ssize_t exitcode_proc_write(struct file *file,\n \t\tconst char __user *buffer, size_t count, loff_t *pos)\n {\n \tchar *end, buf[sizeof(\"nnnnn\\0\")];\n \tint tmp;\n\tif (copy_from_user(buf, buffer, count))\n \t\treturn -EFAULT;\n \ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\tuml_exitcode = tmp;\n\treturn count;\n}", "target": 1}
{"code": "void MediaStreamDispatcherHost::DoOpenDevice(\n    int32_t page_request_id,\n    const std::string& device_id,\n    blink::MediaStreamType type,\n    OpenDeviceCallback callback,\n    MediaDeviceSaltAndOrigin salt_and_origin) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,\n                                           salt_and_origin.origin)) {\n    std::move(callback).Run(false , std::string(),\n                            blink::MediaStreamDevice());\n    return;\n   }\n   media_stream_manager_->OpenDevice(\n      render_process_id_, render_frame_id_, page_request_id, requester_id_,\n       device_id, type, std::move(salt_and_origin), std::move(callback),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,\n                           weak_factory_.GetWeakPtr()));\n}", "target": 1}
{"code": "Status CompressElement(const std::vector<Tensor>& element,\n                       CompressedElement* out) {\n  std::vector<TensorProto> non_memcpy_components;\n  int64 total_size = 0;\n  for (auto& component : element) {\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      total_size += DMAHelper::buffer(&component)->size();\n    } else {\n      non_memcpy_components.emplace_back();\n      component.AsProtoTensorContent(&non_memcpy_components.back());\n      total_size += non_memcpy_components.back().ByteSizeLong();\n    }\n  }\n  tstring uncompressed;\n  uncompressed.resize_uninitialized(total_size);\n  char* position = uncompressed.mdata();\n  int non_memcpy_component_index = 0;\n  for (auto& component : element) {\n    CompressedComponentMetadata* metadata =\n        out->mutable_component_metadata()->Add();\n    metadata->set_dtype(component.dtype());\n    component.shape().AsProto(metadata->mutable_tensor_shape());\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      const TensorBuffer* buffer = DMAHelper::buffer(&component);\n      memcpy(position, buffer->data(), buffer->size());\n      metadata->set_tensor_size_bytes(buffer->size());\n    } else {\n      TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];\n      proto.SerializeToArray(position, proto.ByteSizeLong());\n      metadata->set_tensor_size_bytes(proto.ByteSizeLong());\n    }\n    position += metadata->tensor_size_bytes();\n  }\n  DCHECK_EQ(position, uncompressed.mdata() + total_size);\n  if (!port::Snappy_Compress(uncompressed.mdata(), total_size,\n                             out->mutable_data())) {\n    return errors::Internal(\"Failed to compress using snappy.\");\n  }\n  VLOG(3) << \"Compressed element from \" << total_size << \" bytes to \"\n          << out->data().size() << \" bytes\";\n  return Status::OK();\n}", "target": 1}
{"code": "static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    if (get_bits_left(gb) <= 32)\n         return 0;\n     s->partitioned_frame = 0;\n     s->decode_mb = mpeg4_decode_studio_mb;\n     decode_smpte_tc(ctx, gb);\n    skip_bits(gb, 10); \n    skip_bits(gb, 2); \n    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I; \n    if (get_bits1(gb)) { \n        skip_bits1(gb); \n        skip_bits1(gb); \n        s->progressive_frame = get_bits1(gb) ^ 1; \n    }\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        if (get_bits1(gb))\n            reset_studio_dc_predictors(s);\n    }\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        s->alternate_scan = get_bits1(gb);\n        s->frame_pred_frame_dct = get_bits1(gb);\n        s->dct_precision = get_bits(gb, 2);\n        s->intra_dc_precision = get_bits(gb, 2);\n        s->q_scale_type = get_bits1(gb);\n    }\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    }\n    mpeg4_load_default_matrices(s);\n    next_start_code_studio(gb);\n    extension_and_user_data(s, gb, 4);\n    return 0;\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(CentralDirectoryRecord) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), central_directory_record_signature, sizeof(central_directory_record_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&made_by_version), buffer.data() + sizeof(central_directory_record_signature), fields_size);\n        name = buffer.data() + sizeof(central_directory_record_signature) + fields_size;\n        extra_data = name + name_length;\n        comment = extra_data + extra_data_length;\n        return true;\n    }", "target": 1}
{"code": "void Node::RunForwardTypeInference() {\n  VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n  if (props_->fwd_type_fn == nullptr) {\n    return;\n  }\n  std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n  std::vector<int> input_idx(props_->input_types.size(), 0);\n  for (const auto& edge : in_edges_) {\n    if (edge->IsControlEdge()) {\n      continue;\n    }\n    DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n    int i = edge->dst_input();\n    input_nodes.at(i) = edge->src();\n    input_idx.at(i) = edge->src_output();\n  }\n  for (const auto* node : input_nodes) {\n    if (node == nullptr) {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  static FullTypeDef* no_type = new FullTypeDef();\n  std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n  for (int i = 0; i < input_nodes.size(); i++) {\n    const auto* node = input_nodes[i];\n    if (node->def().has_experimental_type()) {\n      const auto& node_t = node->def().experimental_type();\n      if (node_t.type_id() != TFT_UNSET) {\n        int ix = input_idx[i];\n        DCHECK(ix < node_t.args_size())\n            << \"input \" << i << \" should have an output \" << ix\n            << \" but instead only has \" << node_t.args_size()\n            << \" outputs: \" << node_t.DebugString();\n        input_types.emplace_back(node_t.args(ix));\n      } else {\n        input_types.emplace_back(*no_type);\n      }\n    } else {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  const auto infer_type = props_->fwd_type_fn(input_types);\n  const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n  if (infer_typedef.type_id() != TFT_UNSET) {\n    MaybeCopyOnWrite();\n    *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n  }\n}", "target": 1}
{"code": "GF_Err load_svg_run(GF_SceneLoader *load)\n{\n\tu32 in_time;\n\tGF_Err e;\n\tGF_SVG_Parser *parser = (GF_SVG_Parser *)load->loader_priv;\n\tif (!parser) {\n\t\te = gf_sm_load_initialize_svg(load, NULL, GF_FALSE);\n\t\tif (e) return e;\n\t\tparser = (GF_SVG_Parser *)load->loader_priv;\n\t}\n\tin_time = gf_sys_clock();\n\te = gf_xml_sax_parse_file(parser->sax_parser, (const char *)load->fileName, svg_progress);\n\tif (parser->last_error<0) e = parser->last_error;\n\tif (e<0) return svg_report(parser, e, \"Unable to parse file %s: %s\", load->fileName, gf_xml_sax_get_error(parser->sax_parser) );\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[Parser] Scene parsed and Scene Graph built in %d ms\\n\", gf_sys_clock() - in_time));\n\tsvg_flush_animations(parser);\n\tgf_sm_svg_flush_state(parser);\n\treturn e;\n}", "target": 1}
{"code": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n        assert(p);\n        assert(key);\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n        r = dns_packet_extract(p);\n         if (r < 0)\n                 return r;\n         if (p->question->n_keys != 1)\n                 return 0;\n        return dns_resource_key_equal(p->question->keys[0], key);\n}", "target": 1}
{"code": "static void parse_content_range(URLContext *h, const char *p)\n{\n    HTTPContext *s = h->priv_data;\n    const char *slash;\n    if (!strncmp(p, \"bytes \", 6)) {\n        p     += 6;\n        s->off = strtoll(p, NULL, 10);\n        if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n            s->filesize = strtoll(slash + 1, NULL, 10);\n    }\n    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n        h->is_streamed = 0; \n}", "target": 1}
{"code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}", "target": 1}
{"code": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n                        void *value, size_t vsize)\n{\n    ssize_t size = 0;\n    void *ovalue = value;\n    XattrOperations *xops;\n    char *orig_value, *orig_value_start;\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n    char *dirpath, *name;\n    int dirfd;\n    dirpath = g_path_get_dirname(path);\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    g_free(dirpath);\n    if (dirfd == -1) {\n        return -1;\n    }\n    name = g_path_get_basename(path);\n    xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);\n    if (xattr_len <= 0) {\n        g_free(name);\n        close_preserve_errno(dirfd);\n        return xattr_len;\n    }\n    orig_value = g_malloc(xattr_len);\n    xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);\n    g_free(name);\n    close_preserve_errno(dirfd);\n    if (xattr_len < 0) {\n        return -1;\n    }\n    orig_value_start = orig_value;\n    while (xattr_len > parsed_len) {\n        xops = get_xattr_operations(ctx->xops, orig_value);\n        if (!xops) {\n            goto next_entry;\n        }\n        if (!value) {\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n        } else {\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n            if (size < 0) {\n                goto err_out;\n            }\n            value += size;\n            vsize -= size;\n        }\nnext_entry:\n        attr_len = strlen(orig_value) + 1;\n        parsed_len += attr_len;\n        orig_value += attr_len;\n    }\n    if (value) {\n        size = value - ovalue;\n    }\nerr_out:\n    g_free(orig_value_start);\n    return size;\n}", "target": 1}
{"code": "bool PPB_ImageData_Impl::Init(PP_ImageDataFormat format,\n                              int width, int height,\n                              bool init_to_zero) {\n  if (!IsImageDataFormatSupported(format))\n     return false;  \n   if (width <= 0 || height <= 0)\n     return false;\n  if (static_cast<int64>(width) * static_cast<int64>(height) * 4 >=\n      std::numeric_limits<int32>::max())\n     return false;  \n   format_ = format;\n  width_ = width;\n  height_ = height;\n  return backend_->Init(this, format, width, height, init_to_zero);\n}", "target": 1}
{"code": "yy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)\n{\n  int res = 0;\n  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;\n  if (0 <= yylocp->first_line)\n    {\n      res += YYFPRINTF (yyo, \"%d\", yylocp->first_line);\n      if (0 <= yylocp->first_column)\n        res += YYFPRINTF (yyo, \".%d\", yylocp->first_column);\n    }\n  if (0 <= yylocp->last_line)\n    {\n      if (yylocp->first_line < yylocp->last_line)\n        {\n          res += YYFPRINTF (yyo, \"-%d\", yylocp->last_line);\n          if (0 <= end_col)\n            res += YYFPRINTF (yyo, \".%d\", end_col);\n        }\n      else if (0 <= end_col && yylocp->first_column < end_col)\n        res += YYFPRINTF (yyo, \"-%d\", end_col);\n    }\n  return res;\n }", "target": 1}
{"code": "Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,\n                 string* init_op_name) {\n  const auto& sig_def_map = meta_graph_def.signature_def();\n  const auto& init_op_sig_it =\n      meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);\n  if (init_op_sig_it != sig_def_map.end()) {\n    *init_op_name = init_op_sig_it->second.outputs()\n                        .find(kSavedModelInitOpSignatureKey)\n                        ->second.name();\n    return Status::OK();\n  }\n  const auto& collection_def_map = meta_graph_def.collection_def();\n  string init_op_collection_key;\n  if (collection_def_map.find(kSavedModelMainOpKey) !=\n      collection_def_map.end()) {\n    init_op_collection_key = kSavedModelMainOpKey;\n  } else {\n    init_op_collection_key = kSavedModelLegacyInitOpKey;\n  }\n  const auto init_op_it = collection_def_map.find(init_op_collection_key);\n  if (init_op_it != collection_def_map.end()) {\n    if (init_op_it->second.node_list().value_size() != 1) {\n      return errors::FailedPrecondition(\n          strings::StrCat(\"Expected exactly one main op in : \", export_dir));\n    }\n    *init_op_name = init_op_it->second.node_list().value(0);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\tif (old_len > vma->vm_end - addr)\n\t\tgoto Efault;\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n\t\tif (new_len > old_len)\n\t\t\tgoto Efault;\n\t}\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\treturn vma;\nEfault:\t\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}", "target": 1}
{"code": "static int ext4_destroy_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = 0, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t};\n\tint error;\n\tif (!ei->i_inline_off)\n\t\treturn 0;\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\tif (ext4_has_feature_extents(inode->i_sb)) {\n\t\tif (S_ISDIR(inode->i_mode) ||\n\t\t    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\text4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\tEXT4_I(inode)->i_inline_off = 0;\n\tEXT4_I(inode)->i_inline_size = 0;\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\nout:\n\tbrelse(is.iloc.bh);\n\tif (error == -ENODATA)\n\t\terror = 0;\n\treturn error;\n}", "target": 1}
{"code": "static int logi_dj_ll_raw_request(struct hid_device *hid,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t count, unsigned char report_type,\n\t\t\t\t  int reqtype)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\tu8 *out_buf;\n\tint ret;\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n \tif (!out_buf)\n \t\treturn -ENOMEM;\n\tif (count < DJREPORT_SHORT_LENGTH - 2)\n \t\tcount = DJREPORT_SHORT_LENGTH - 2;\n \tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\tkfree(out_buf);\n\treturn ret;\n}", "target": 1}
{"code": "STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {\n    struct pollfd *free_slot = NULL;\n    if (poll_set->used == poll_set->max_used) {\n        if (poll_set->max_used >= poll_set->alloc) {\n            poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);\n            poll_set->alloc += 4;\n        }\n        free_slot = &poll_set->pollfds[poll_set->max_used++];\n    } else {\n        for (unsigned int i = 0; i < poll_set->max_used; ++i) {\n            struct pollfd *slot = &poll_set->pollfds[i];\n            if (slot->fd == -1) {\n                free_slot = slot;\n                break;\n            }\n        }\n        assert(free_slot != NULL);\n    }\n    free_slot->fd = fd;\n    ++poll_set->used;\n    return free_slot;\n}", "target": 1}
{"code": "  inline void init (hb_face_t *face,\n\t\t    hb_tag_t _hea_tag, hb_tag_t _mtx_tag,\n\t\t    unsigned int default_advance_)\n  {\n    this->default_advance = default_advance_;\n    this->num_metrics = face->get_num_glyphs ();\n    hb_blob_t *_hea_blob = OT::Sanitizer<OT::_hea>::sanitize (face->reference_table (_hea_tag));\n    const OT::_hea *_hea = OT::Sanitizer<OT::_hea>::lock_instance (_hea_blob);\n    this->num_advances = _hea->numberOfLongMetrics;\n    hb_blob_destroy (_hea_blob);\n    this->blob = OT::Sanitizer<OT::_mtx>::sanitize (face->reference_table (_mtx_tag));\n    if (unlikely (!this->num_advances ||\n\t\t  2 * (this->num_advances + this->num_metrics) < hb_blob_get_length (this->blob)))\n    {\n      this->num_metrics = this->num_advances = 0;\n      hb_blob_destroy (this->blob);\n      this->blob = hb_blob_get_empty ();\n    }\n    this->table = OT::Sanitizer<OT::_mtx>::lock_instance (this->blob);\n  }", "target": 1}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb)\n{\n\tkiocb->ki_iovec = &kiocb->ki_inline_vec;\n\tkiocb->ki_iovec->iov_base = kiocb->ki_buf;\n\tkiocb->ki_iovec->iov_len = kiocb->ki_left;\n\tkiocb->ki_nr_segs = 1;\n\tkiocb->ki_cur_seg = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static void bond_setup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\trwlock_init(&bond->lock);\n\trwlock_init(&bond->curr_slave_lock);\n\tbond->params = bonding_defaults;\n\tbond->dev = bond_dev;\n\tINIT_LIST_HEAD(&bond->vlan_list);\n\tether_setup(bond_dev);\n\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\tbond_dev->destructor = bond_destructor;\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\tbond_dev->features |= NETIF_F_LLTX;\n\tbond_dev->hw_features = BOND_VLAN_FEATURES |\n\t\t\t\tNETIF_F_HW_VLAN_TX |\n\t\t\t\tNETIF_F_HW_VLAN_RX |\n\t\t\t\tNETIF_F_HW_VLAN_FILTER;\n\tbond_dev->hw_features &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_NO_CSUM);\n\tbond_dev->features |= bond_dev->hw_features;\n}", "target": 1}
{"code": "cib_recv_tls(gnutls_session * session)\n{\n    char *buf = NULL;\n    int rc = 0;\n    int len = 0;\n    int chunk_size = 1024;\n    if (session == NULL) {\n        return NULL;\n    }\n    buf = calloc(1, chunk_size);\n    while (TRUE) {\n        errno = 0;\n        rc = gnutls_record_recv(*session, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", rc, errno);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"Retry\");\n        } else if (rc == GNUTLS_E_UNEXPECTED_PACKET_LENGTH) {\n            crm_trace(\"Session disconnected\");\n            goto bail;\n        } else if (rc < 0) {\n            crm_err(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            goto bail;\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else {\n            crm_trace(\"Got %d more bytes\", (int)rc);\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n}", "target": 1}
{"code": "ext2_xattr_put_super(struct super_block *sb)\n{\n}", "target": 1}
{"code": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n \t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n \t\t\tstruct mount *parent = ACCESS_ONCE(mnt->mnt_parent);\n \t\t\tif (mnt != parent) {\n \t\t\t\tdentry = ACCESS_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}", "target": 1}
{"code": "SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n                     const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                     Ssl::HandshakerFactoryCb handshaker_factory_cb)\n    : transport_socket_options_(transport_socket_options),\n      ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),\n      info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n          ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {\n  if (state == InitialState::Client) {\n    SSL_set_connect_state(rawSsl());\n  } else {\n    ASSERT(state == InitialState::Server);\n    SSL_set_accept_state(rawSsl());\n  }\n}", "target": 1}
{"code": "        unsigned int GetUVarBE(int nPos, int nSize, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + nSize > m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = 0;\n            for ( int nIndex = 0; nIndex < nSize; ++nIndex )\n                nRes = (nRes << 8) + m_sFile[nPos + nIndex];\n            return nRes;\n        }", "target": 1}
{"code": "ParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}", "target": 1}
{"code": "void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Write(s, fields->Buffer, fields->Len);\n\t}\n}", "target": 1}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context,\n                          const TfLiteEvalTensor* params,\n                          const TfLiteEvalTensor* indices,\n                          TfLiteEvalTensor* output) {\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n      break;\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Params type '%s' are not supported by gather_nd.\",\n                         TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MaxTextExtent];\n  const char\n    *option;\n  graph_t\n    *graph;\n  Image\n    *image;\n  ImageInfo\n    *read_info;\n  MagickBooleanType\n    status;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MaxTextExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}", "target": 1}
{"code": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}", "target": 1}
{"code": "pci_populate_msixcap(struct msixcap *msixcap, int msgnum, int barnum,\n\t\t     uint32_t msix_tab_size)\n{\n\tassert(msix_tab_size % 4096 == 0);\n\tbzero(msixcap, sizeof(struct msixcap));\n\tmsixcap->capid = PCIY_MSIX;\n\tmsixcap->msgctrl = msgnum - 1;\n\tmsixcap->table_info = barnum & PCIM_MSIX_BIR_MASK;\n\tmsixcap->pba_info = msix_tab_size | (barnum & PCIM_MSIX_BIR_MASK);\n}", "target": 1}
{"code": "void CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n  }\n}", "target": 1}
{"code": "IceGenerateMagicCookie (\n \tint len\n )\n {\n    char    *auth;\n#ifndef HAVE_ARC4RANDOM_BUF\n     long    ldata[2];\n     int\t    seed;\n     int\t    value;\n     int\t    i;\n#endif\n    if ((auth = malloc (len + 1)) == NULL)\n\treturn (NULL);\n#ifdef HAVE_ARC4RANDOM_BUF\n    arc4random_buf(auth, len);\n#else\n #ifdef ITIMER_REAL\n     {\n \tstruct timeval  now;\n    int\t    i;\n \tldata[0] = now.tv_sec;\n \tldata[1] = now.tv_usec;\n     }\n#else\n     {\n \tlong    time ();\n \tldata[0] = time ((long *) 0);\n \tldata[1] = getpid ();\n     }\n#endif\n     seed = (ldata[0]) + (ldata[1] << 16);\n     srand (seed);\n     for (i = 0; i < len; i++)\n\tldata[1] = now.tv_usec;\n \tvalue = rand ();\n \tauth[i] = value & 0xff;\n     }", "target": 1}
{"code": "testBackingParse(const void *args)\n{\n    const struct testBackingParseData *data = args;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *xml = NULL;\n    g_autoptr(virStorageSource) src = NULL;\n    int rc;\n    int erc = data->rv;\n    if (!data->expect)\n        erc = -1;\n    if ((rc = virStorageSourceNewFromBackingAbsolute(data->backing, &src)) != erc) {\n        fprintf(stderr, \"expected return value '%d' actual '%d'\\n\", erc, rc);\n        return -1;\n    }\n    if (!src)\n        return 0;\n    if (src && !data->expect) {\n        fprintf(stderr, \"parsing of backing store string '%s' should \"\n                        \"have failed\\n\", data->backing);\n        return -1;\n    }\n    if (virDomainDiskSourceFormat(&buf, src, \"source\", 0, false, 0, true, NULL) < 0 ||\n        !(xml = virBufferContentAndReset(&buf))) {\n        fprintf(stderr, \"failed to format disk source xml\\n\");\n        return -1;\n    }\n    if (STRNEQ(xml, data->expect)) {\n        fprintf(stderr, \"\\n backing store string '%s'\\n\"\n                        \"expected storage source xml:\\n%s\\n\"\n                        \"actual storage source xml:\\n%s\\n\",\n                        data->backing, data->expect, xml);\n        return -1;\n    }\n    return 0;\n}", "target": 1}
{"code": "Java_org_tensorflow_lite_InterpreterTest_getNativeHandleForDelegate(\n    JNIEnv* env, jclass clazz) {\n  static TfLiteRegistration registration = {\n      .init = nullptr,\n      .free = nullptr,\n      .prepare =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n            output->type = kTfLiteFloat32;\n            return context->ResizeTensor(context, output, output_dims);\n          },\n      .invoke =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            std::fill(output->data.f,\n                      output->data.f + tflite::NumElements(output), 7.0f);\n            return kTfLiteOk;\n          },\n      .profiling_string = nullptr,\n      .builtin_code = 0,\n      .custom_name = \"\",\n      .version = 1,\n  };\n  static TfLiteDelegate delegate = {\n      .data_ = nullptr,\n      .Prepare = [](TfLiteContext* context,\n                    TfLiteDelegate* delegate) -> TfLiteStatus {\n        TfLiteIntArray* execution_plan;\n        TF_LITE_ENSURE_STATUS(\n            context->GetExecutionPlan(context, &execution_plan));\n        context->ReplaceNodeSubsetsWithDelegateKernels(\n            context, registration, execution_plan, delegate);\n        for (size_t i = 0; i < context->tensors_size; ++i) {\n          context->tensors[i].delegate = delegate;\n          context->tensors[i].buffer_handle = static_cast<int>(i);\n        }\n        return kTfLiteOk;\n      },\n      .CopyFromBufferHandle = nullptr,\n      .CopyToBufferHandle = nullptr,\n      .FreeBufferHandle = nullptr,\n      .flags = kTfLiteDelegateFlagsAllowDynamicTensors,\n  };\n  return reinterpret_cast<jlong>(&delegate);\n}", "target": 1}
{"code": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tret = mount_entry_create_dir_file(mntent, path);\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\tcull_mntent_opt(mntent);\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n\t\t\t  mntflags, mntdata, optional);\n\tfree(mntdata);\n\treturn ret;\n}", "target": 1}
{"code": "TfLiteStatus ScatterNd(const TfLiteTensor* indices, const TfLiteTensor* updates,\n                       TfLiteTensor* output) {\n  reference_ops::ScatterNd(\n      GetTensorShape(indices), GetTensorData<IndicesT>(indices),\n      GetTensorShape(updates), GetTensorData<UpdatesT>(updates),\n      GetTensorShape(output), GetTensorData<UpdatesT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "CallResult<PseudoHandle<>> GeneratorInnerFunction::callInnerFunction(\n    Handle<GeneratorInnerFunction> selfHandle,\n    Runtime &runtime,\n    Handle<> arg,\n    Action action) {\n  auto self = Handle<GeneratorInnerFunction>::vmcast(selfHandle);\n  SmallHermesValue shv =\n      SmallHermesValue::encodeHermesValue(arg.getHermesValue(), runtime);\n  self->result_.set(shv, runtime.getHeap());\n  self->action_ = action;\n  auto ctx = runtime.makeMutableHandle(selfHandle->savedContext_);\n  const uint32_t argCount = self->argCount_;\n  HermesValue newTarget = HermesValue::encodeUndefinedValue();\n  ScopedNativeCallFrame frame{\n      runtime,\n      argCount, \n      selfHandle.getHermesValue(),\n      newTarget,\n      ctx->at(0)};\n  if (LLVM_UNLIKELY(frame.overflowed()))\n    return runtime.raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  for (ArrayStorage::size_type i = 0, e = argCount; i < e; ++i) {\n    frame->getArgRef(i) = ctx->at(i + 1);\n  }\n  if (LLVM_UNLIKELY(selfHandle->getCodeBlock(runtime)->isLazy())) {\n    selfHandle->getCodeBlock(runtime)->lazyCompile(runtime);\n    if (LLVM_UNLIKELY(\n            ArrayStorage::resize(\n                ctx,\n                runtime,\n                getContextSize(\n                    selfHandle->getCodeBlock(runtime),\n                    selfHandle->argCount_)) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    selfHandle->savedContext_.set(runtime, ctx.get(), runtime.getHeap());\n  }\n  return JSFunction::_callImpl(selfHandle, runtime);\n}", "target": 1}
{"code": "static void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tint clear_rd, clear_wr, clear_rdwr;\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\tclear_rd = clear_wr = clear_rdwr = 0;\n\tspin_lock(&state->owner->so_lock);\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tclear_rd |= test_and_clear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tclear_wr |= test_and_clear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t}\n\tspin_unlock(&state->owner->so_lock);\n\tif (!clear_rd && !clear_wr && !clear_rdwr) {\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tnfs_fattr_init(calldata->res.fattr);\n\tif (test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_READ;\n\t} else if (test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_WRITE;\n\t}\n\tcalldata->timestamp = jiffies;\n\trpc_call_start(task);\n}", "target": 1}
{"code": "void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n#else\n    (void)secret;\n#endif\n    UNUSED(info);\n    UNUSED(sig);\n    serverLogFromHandler(LL_WARNING,\"\\n--- WATCHDOG TIMER EXPIRED ---\");\n#ifdef HAVE_BACKTRACE\n    logStackTrace(getMcontextEip(uc), 1);\n#else\n    serverLogFromHandler(LL_WARNING,\"Sorry: no support for backtrace().\");\n#endif\n    serverLogFromHandler(LL_WARNING,\"--------\\n\");\n}", "target": 1}
{"code": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + \n                         1 + \n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}", "target": 1}
{"code": "static void validate_dex_header(const dex_header* dh,\n                                size_t dexsize,\n                                int support_dex_version) {\n  bool supported = false;\n  switch (support_dex_version) {\n  case 38:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; \n  case 37:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V37, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; \n  case 35:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V35, sizeof(dh->magic));\n    break;\n  default:\n    not_reached_log(\"Unrecognized support_dex_version %d\\n\",\n                    support_dex_version);\n  }\n  always_assert_log(supported, \"Bad dex magic %s for support_dex_version %d\\n\",\n                    dh->magic, support_dex_version);\n  always_assert_log(\n      dh->file_size == dexsize,\n      \"Reported size in header (%zu) does not match file size (%u)\\n\",\n      dexsize,\n      dh->file_size);\n  auto off = (uint64_t)dh->class_defs_off;\n  auto limit = off + dh->class_defs_size * sizeof(dex_class_def);\n  always_assert_log(off < dexsize, \"class_defs_off out of range\");\n  always_assert_log(limit <= dexsize, \"invalid class_defs_size\");\n}", "target": 1}
{"code": "int setup_conds(THD *thd, TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                COND **conds)\n{\n  SELECT_LEX *select_lex= thd->lex->current_select;\n  TABLE_LIST *table= NULL;\t\n  bool it_is_update= (select_lex == thd->lex->first_select_lex()) &&\n    thd->lex->which_check_option_applicable();\n  bool save_is_item_list_lookup= select_lex->is_item_list_lookup;\n  TABLE_LIST *derived= select_lex->master_unit()->derived;\n  DBUG_ENTER(\"setup_conds\");\n  select_lex->is_item_list_lookup= 0;\n  thd->column_usage= MARK_COLUMNS_READ;\n  DBUG_PRINT(\"info\", (\"thd->column_usage: %d\", thd->column_usage));\n  select_lex->cond_count= 0;\n  select_lex->between_count= 0;\n  select_lex->max_equal_elems= 0;\n  for (table= tables; table; table= table->next_local)\n  {\n    if (select_lex == thd->lex->first_select_lex() &&\n        select_lex->first_cond_optimization &&\n        table->merged_for_insert &&\n        table->prepare_where(thd, conds, FALSE))\n      goto err_no_arena;\n  }\n  if (*conds)\n  {\n    thd->where=\"where clause\";\n    DBUG_EXECUTE(\"where\",\n                 print_where(*conds,\n                             \"WHERE in setup_conds\",\n                             QT_ORDINARY););\n    if ((*conds)->type() == Item::FIELD_ITEM && !derived)\n      wrap_ident(thd, conds);\n    (*conds)->mark_as_condition_AND_part(NO_JOIN_NEST);\n    if ((*conds)->fix_fields_if_needed_for_bool(thd, conds))\n      goto err_no_arena;\n  }\n  if (setup_on_expr(thd, tables, it_is_update))\n    goto err_no_arena;\n  if (!thd->stmt_arena->is_conventional())\n  {\n    select_lex->where= *conds;\n  }\n  thd->lex->current_select->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(thd->is_error());\nerr_no_arena:\n  select_lex->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(1);\n}", "target": 1}
{"code": "static void ext4_clamp_want_extra_isize(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    sbi->s_want_extra_isize == 0) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO,\n\t\t\t \"required extra inode space not available\");\n\t}\n}", "target": 1}
{"code": "deltas_head_create(struct deltas_head **deltas)\n{\n\tstruct deltas_head *tmp;\n\ttmp = malloc(sizeof(struct deltas_head));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tdeltas_head_init(tmp);\n\t*deltas = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(gcmR, sizeof(gcmR));\n}", "target": 1}
{"code": "static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t   int fromlen, unsigned char *to)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tunsigned char *p = to;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\tcase 2:\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n\t\t\t\t\t      pc->lengthComponentIdent);\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n}", "target": 1}
{"code": "flush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n \t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n \t\t\tka->sa.sa_handler = SIG_DFL;\n \t\tka->sa.sa_flags = 0;\n \t\tsigemptyset(&ka->sa.sa_mask);\n \t\tka++;\n \t}\n}", "target": 1}
{"code": "SHA256_Pad(struct SHA256_CTX * ctx)\n{\n  unsigned char len[8];\n  uint32_t r, plen;\n  be32enc_vect(len, ctx->count, 8);\n  r = (ctx->count[1] >> 3) & 0x3f;\n  plen = (r < 56) ? (56 - r) : (120 - r);\n  scrypt_SHA256_Update(ctx, PAD, (size_t)plen);\n  scrypt_SHA256_Update(ctx, len, 8);\n}", "target": 1}
{"code": "gen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n    if (is_splat || n > limit || cursp() >= slimit) { \n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  \n  }\n  return n;\n}", "target": 1}
{"code": "static void rose_loopback_timer(unsigned long param)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci_i, lci_o;\n\twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\t\tframetype = skb->data[2];\n\t\tdest      = (rose_address *)(skb->data + 4);\n\t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n\t\tskb_reset_transport_header(skb);\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif ((dev = rose_dev_get(dest)) != NULL) {\n\t\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0)\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECT2 &&\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\thci_conn_accept(pi->conn->hcon, 0);\n \t\tsk->sk_state = BT_CONFIG;\n \t\trelease_sock(sk);\n \t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}", "target": 1}
{"code": "mptctl_readtest (unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_readtest() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;\n#else\n\tkarg.chip_type = ioc->pcidev->device;\n#endif\n\tstrncpy (karg.name, ioc->name, MPT_MAX_NAME);\n\tkarg.name[MPT_MAX_NAME-1]='\\0';\n\tstrncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);\n\tkarg.product[MPT_PRODUCT_LENGTH-1]='\\0';\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to write out mpt_ioctl_test struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int mutt_seqset_iterator_next (SEQSET_ITERATOR *iter, unsigned int *next)\n{\n  char *range_sep;\n  if (!iter || !next)\n    return -1;\n  if (iter->in_range)\n  {\n    if ((iter->down && iter->range_cur == (iter->range_end - 1)) ||\n        (!iter->down && iter->range_cur == (iter->range_end + 1)))\n      iter->in_range = 0;\n  }\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr (iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n    range_sep = strchr (iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n    if (mutt_atoui (iter->substr_cur, &iter->range_cur))\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_atoui (range_sep, &iter->range_end))\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n  return 0;\n}", "target": 1}
{"code": "void flash_option_bytes_init(int boot_from_dfu)\n{\n    uint32_t val = 0xfffff8aa;\n    if (boot_from_dfu){\n        val &= ~(1<<27); \n    }\n    else {\n        if (solo_is_locked())\n        {\n            val = 0xfffff8cc;\n        }\n    }\n    val &= ~(1<<26); \n    val &= ~(1<<25); \n    val &= ~(1<<24); \n    if (FLASH->OPTR == val)\n    {\n        return;\n    }\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n    if (FLASH->CR & (1<<30))\n    {\n        FLASH->OPTKEYR = 0x08192A3B;\n        FLASH->OPTKEYR = 0x4C5D6E7F;\n    }\n    FLASH->OPTR =val;\n    FLASH->CR |= (1<<17);\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_lock();\n    __enable_irq();\n}", "target": 1}
{"code": "void NuPlayer::GenericSource::notifyPreparedAndCleanup(status_t err) {\n if (err != OK) {\n        mMetaDataSize = -1ll;\n        mContentType = \"\";\n        mSniffedMIME = \"\";\n {\n            sp<DataSource> dataSource = mDataSource;\n            sp<NuCachedSource2> cachedSource = mCachedSource;\n            sp<DataSource> httpSource = mHttpSource;\n             {\n                 Mutex::Autolock _l(mDisconnectLock);\n                 mDataSource.clear();\n                 mCachedSource.clear();\n                 mHttpSource.clear();\n             }\n }\n        cancelPollBuffering();\n }\n    notifyPrepared(err);\n}", "target": 1}
{"code": "static pfunc check_literal(struct jv_parser* p) {\n  if (p->tokenpos == 0) return 0;\n  const char* pattern = 0;\n  int plen;\n  jv v;\n  switch (p->tokenbuf[0]) {\n  case 't': pattern = \"true\"; plen = 4; v = jv_true(); break;\n  case 'f': pattern = \"false\"; plen = 5; v = jv_false(); break;\n  case 'n': pattern = \"null\"; plen = 4; v = jv_null(); break;\n  }\n  if (pattern) {\n    if (p->tokenpos != plen) return \"Invalid literal\";\n    for (int i=0; i<plen; i++)\n      if (p->tokenbuf[i] != pattern[i])\n        return \"Invalid literal\";\n    TRY(value(p, v));\n  } else {\n    p->tokenbuf[p->tokenpos] = 0; \n    char* end = 0;\n    double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);\n    if (end == 0 || *end != 0)\n      return \"Invalid numeric literal\";\n    TRY(value(p, jv_number(d)));\n  }\n  p->tokenpos = 0;\n  return 0;\n}", "target": 1}
{"code": "encodeJsonStructure(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    status ret = writeJsonObjStart(ctx);\n    uintptr_t ptr = (uintptr_t) src;\n    u8 membersSize = type->membersSize;\n    const UA_DataType * typelists[2] = {UA_TYPES, &type[-type->typeIndex]};\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(m->memberName != NULL && *m->memberName != 0)\n            ret |= writeJsonKey(ctx, m->memberName);\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t memSize = mt->memSize;\n            ret |= encodeJsonJumpTable[mt->typeKind]((const void*) ptr, mt, ctx);\n            ptr += memSize;\n        } else {\n            ptr += m->padding;\n            const size_t length = *((const size_t*) ptr);\n            ptr += sizeof (size_t);\n            ret |= encodeJsonArray(ctx, *(void * const *)ptr, length, mt);\n            ptr += sizeof (void*);\n        }\n    }\n    ret |= writeJsonObjEnd(ctx);\n    ctx->depth--;\n    return ret;\n}", "target": 1}
{"code": " void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)\n {\n     ASSERT(m_form);\n    if (toHTMLElement(this)->highestAncestor() != formRoot)\n        setForm(0);\n }", "target": 1}
{"code": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n{\n\tva_list va;\n\tchar *message = NULL;\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\tefree(message);\n\tva_end(va);\n}", "target": 1}
{"code": "int32_t PepperFlashRendererHost::OnNavigate(\n    ppapi::host::HostMessageContext* host_context,\n    const ppapi::URLRequestInfoData& data,\n    const std::string& target,\n    bool from_user_action) {\n  content::PepperPluginInstance* plugin_instance =\n      host_->GetPluginInstance(pp_instance());\n   if (!plugin_instance)\n     return PP_ERROR_FAILED;\n  ppapi::proxy::HostDispatcher* host_dispatcher =\n      ppapi::proxy::HostDispatcher::GetForInstance(pp_instance());\n  host_dispatcher->set_allow_plugin_reentrancy();\n  base::WeakPtr<PepperFlashRendererHost> weak_ptr = weak_factory_.GetWeakPtr();\n  navigate_replies_.push_back(host_context->MakeReplyMessageContext());\n  plugin_instance->Navigate(data, target.c_str(), from_user_action);\n  if (weak_ptr.get()) {\n    SendReply(navigate_replies_.back(), IPC::Message());\n    navigate_replies_.pop_back();\n  }\n  return PP_OK_COMPLETIONPENDING;\n}", "target": 1}
{"code": "static inline void write_s3row_data(\n\tconst entity_stage3_row *r,\n\tunsigned orig_cp,\n\tenum entity_charset charset,\n\tzval *arr)\n{\n\tchar key[9] = \"\"; \n\tchar entity[LONGEST_ENTITY_LENGTH + 2] = {'&'};\n\tsize_t written_k1;\n\twritten_k1 = write_octet_sequence(key, charset, orig_cp);\n\tif (!r->ambiguous) {\n\t\tsize_t l = r->data.ent.entity_len;\n\t\tmemcpy(&entity[1], r->data.ent.entity, l);\n\t\tentity[l + 1] = ';';\n\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t} else {\n\t\tunsigned i,\n\t\t\t     num_entries;\n\t\tconst entity_multicodepoint_row *mcpr = r->data.multicodepoint_table;\n\t\tif (mcpr[0].leading_entry.default_entity != NULL) {\n\t\t\tsize_t l = mcpr[0].leading_entry.default_entity_len;\n\t\t\tmemcpy(&entity[1], mcpr[0].leading_entry.default_entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t\t}\n\t\tnum_entries = mcpr[0].leading_entry.size;\n\t\tfor (i = 1; i <= num_entries; i++) {\n\t\t\tsize_t   l,\n\t\t\t\t     written_k2;\n\t\t\tunsigned uni_cp,\n\t\t\t\t\t spe_cp;\n\t\t\tuni_cp = mcpr[i].normal_entry.second_cp;\n\t\t\tl = mcpr[i].normal_entry.entity_len;\n\t\t\tif (!CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\tif (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE)\n\t\t\t\t\tcontinue; \n\t\t\t} else {\n\t\t\t\tspe_cp = uni_cp;\n\t\t\t}\n\t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n\t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tentity[l + 1] = '\\0';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + written_k2 + 1, entity, l + 1, 1);\n\t\t}\n\t}\n}", "target": 1}
{"code": "int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,\n                BIO *dcont, BIO *out, unsigned int flags)\n{\n    int r;\n    BIO *cont;\n    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {\n        CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);\n        return 0;\n    }\n    if (!dcont && !check_content(cms))\n        return 0;\n    if (flags & CMS_DEBUG_DECRYPT)\n         cms->d.envelopedData->encryptedContentInfo->debug = 1;\n     else\n         cms->d.envelopedData->encryptedContentInfo->debug = 0;\n     if (!pk && !cert && !dcont && !out)\n         return 1;\n     if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))\n    r = cms_copy_content(out, cont, flags);\n    do_free_upto(cont, dcont);\n    return r;\n}", "target": 1}
{"code": "static int clone_submodule(const char *path, const char *gitdir, const char *url,\n\t\t\t   const char *depth, struct string_list *reference,\n\t\t\t   int quiet, int progress)\n{\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\targv_array_push(&cp.args, \"clone\");\n\targv_array_push(&cp.args, \"--no-checkout\");\n\tif (quiet)\n\t\targv_array_push(&cp.args, \"--quiet\");\n\tif (progress)\n\t\targv_array_push(&cp.args, \"--progress\");\n\tif (depth && *depth)\n\t\targv_array_pushl(&cp.args, \"--depth\", depth, NULL);\n\tif (reference->nr) {\n\t\tstruct string_list_item *item;\n\t\tfor_each_string_list_item(item, reference)\n\t\t\targv_array_pushl(&cp.args, \"--reference\",\n\t\t\t\t\t item->string, NULL);\n\t}\n\tif (gitdir && *gitdir)\n\t\targv_array_pushl(&cp.args, \"--separate-git-dir\", gitdir, NULL);\n\targv_array_push(&cp.args, url);\n\targv_array_push(&cp.args, path);\n\tcp.git_cmd = 1;\n\tprepare_submodule_repo_env(&cp.env_array);\n\tcp.no_stdin = 1;\n\treturn run_command(&cp);\n}", "target": 1}
{"code": "static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl)\n{\n  const size_t so_ext_len= sizeof(SO_EXT) - 1;\n  if (my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n                    SO_EXT))\n  {\n    char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);\n    memcpy(s, dl->str, dl->length);\n    strcpy(s + dl->length, SO_EXT);\n    dl->str= s;\n    dl->length+= so_ext_len;\n  }\n}", "target": 1}
{"code": "static void check_pointer_type_change(Notifier *notifier, void *data)\n{\n    VncState *vs = container_of(notifier, VncState, mouse_mode_notifier);\n    int absolute = qemu_input_is_absolute();\n    if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) {\n         vnc_write_u8(vs, 0);\n         vnc_write_u16(vs, 1);\n         vnc_framebuffer_update(vs, absolute, 0,\n                               surface_width(vs->vd->ds),\n                               surface_height(vs->vd->ds),\n                                VNC_ENCODING_POINTER_TYPE_CHANGE);\n         vnc_unlock_output(vs);\n         vnc_flush(vs);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    }\n    vs->absolute = absolute;\n}", "target": 1}
{"code": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n {\n \tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n \tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n \treturn false;\n }", "target": 1}
{"code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  TfLiteIntArray* ret =\n      (TfLiteIntArray*)malloc(TfLiteIntArrayGetSizeInBytes(size));\n  ret->size = size;\n  return ret;\n}", "target": 1}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *last,\n\t\t\tvoid *data)\n{\n\tchar *name = path_name(path, last);\n\tadd_preferred_base_object(name);\n\tadd_object_entry(obj->oid.hash, obj->type, name, 0);\n\tobj->flags |= OBJECT_ADDED;\n\tfree((char *)name);\n}", "target": 1}
{"code": " static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n {\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n }", "target": 1}
{"code": "int sanity_check_ckpt(struct f2fs_sb_info *sbi)\n{\n\tunsigned int total, fsmeta;\n \tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n \tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n \tunsigned int ovp_segments, reserved_segments;\n \ttotal = le32_to_cpu(raw_super->segment_count);\n \tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_sit);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_nat);\n\tfsmeta += le32_to_cpu(ckpt->rsvd_segment_count);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_ssa);\n\tif (unlikely(fsmeta >= total))\n\t\treturn 1;\n\tovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\treserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tif (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||\n\t\t\tovp_segments == 0 || reserved_segments == 0)) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR,\n\t\t\t\"Wrong layout: check mkfs.f2fs version\");\n \t\treturn 1;\n \t}\n \tif (unlikely(f2fs_cp_error(sbi))) {\n \t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n \t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "hstore_recv(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tint32\t\ti;\n\tint32\t\tpcount;\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tpcount = pq_getmsgint(buf, 4);\n\tif (pcount == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n \t\tPG_RETURN_POINTER(out);\n \t}\n \tpairs = palloc(pcount * sizeof(Pairs));\n \tfor (i = 0; i < pcount; ++i)\n\t{\n\t\tint\t\t\trawlen = pq_getmsgint(buf, 4);\n\t\tint\t\t\tlen;\n\t\tif (rawlen < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\t\tpairs[i].key = pq_getmsgtext(buf, rawlen, &len);\n\t\tpairs[i].keylen = hstoreCheckKeyLen(len);\n\t\tpairs[i].needfree = true;\n\t\trawlen = pq_getmsgint(buf, 4);\n\t\tif (rawlen < 0)\n\t\t{\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].vallen = 0;\n\t\t\tpairs[i].isnull = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].val = pq_getmsgtext(buf, rawlen, &len);\n\t\t\tpairs[i].vallen = hstoreCheckValLen(len);\n\t\t\tpairs[i].isnull = false;\n\t\t}\n\t}\n\tpcount = hstoreUniquePairs(pairs, pcount, &buflen);\n\tout = hstorePairs(pairs, pcount, buflen);\n\tPG_RETURN_POINTER(out);\n}", "target": 1}
{"code": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n \tstruct nft_chain *chain, *nc;\n \tstruct nft_set *set, *ns;\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n \t\tctx->chain = chain;\n \t\terr = nft_delrule_by_chain(ctx);\n \t\tif (err < 0)\n \t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n \t}\n \tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n \t\t\tgoto out;\n \t}\n \terr = nft_deltable(ctx);\n out:\n \treturn err;\n}", "target": 1}
{"code": " static void mpeg4_encode_gop_header(MpegEncContext *s)\n {\n    int hours, minutes, seconds;\n     int64_t time;\n     put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, GOP_STARTCODE);\n    time = s->current_picture_ptr->f->pts;\n    if (s->reordered_input_picture[1])\n        time = FFMIN(time, s->reordered_input_picture[1]->f->pts);\n    time = time * s->avctx->time_base.num;\n    s->last_time_base = FFUDIV(time, s->avctx->time_base.den);\n    seconds = FFUDIV(time, s->avctx->time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n    put_bits(&s->pb, 5, hours);\n    put_bits(&s->pb, 6, minutes);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 6, seconds);\n    put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&s->pb, 1, 0);  \n    ff_mpeg4_stuffing(&s->pb);\n}", "target": 1}
{"code": " smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n {\n\tint rc;\n \tunsigned char key2[8];\n\tstruct crypto_skcipher *tfm_des;\n\tstruct scatterlist sgin, sgout;\n\tstruct skcipher_request *req;\n \tstr_to_key(key, key2);\n\ttfm_des = crypto_alloc_skcipher(\"ecb(des)\", 0, CRYPTO_ALG_ASYNC);\n \tif (IS_ERR(tfm_des)) {\n\t\trc = PTR_ERR(tfm_des);\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_err;\n\t}\n\treq = skcipher_request_alloc(tfm_des, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n \t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_free_skcipher;\n \t}\n\tcrypto_skcipher_setkey(tfm_des, key2, 8);\n\tsg_init_one(&sgin, in, 8);\n\tsg_init_one(&sgout, out, 8);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);\n\trc = crypto_skcipher_encrypt(req);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"could not encrypt crypt key rc: %d\\n\", rc);\n\tskcipher_request_free(req);\nsmbhash_free_skcipher:\n\tcrypto_free_skcipher(tfm_des);\nsmbhash_err:\n\treturn rc;\n }", "target": 1}
{"code": "gostdsa_vko (const struct ecc_scalar *priv,\n\t\tconst struct ecc_point *pub,\n\t\tsize_t ukm_length, const uint8_t *ukm,\n\t\tuint8_t *out)\n{\n  const struct ecc_curve *ecc = priv->ecc;\n  unsigned bsize = (ecc_bit_size (ecc) + 7) / 8;\n  mp_size_t size = ecc->p.size;\n  mp_size_t itch = 4*size + ecc->mul_itch;\n  mp_limb_t *scratch;\n  if (itch < 5*size + ecc->h_to_a_itch)\n      itch = 5*size + ecc->h_to_a_itch;\n  assert (pub->ecc == ecc);\n  assert (priv->ecc == ecc);\n  assert (ukm_length <= bsize);\n  scratch = gmp_alloc_limbs (itch);\n#define UKM scratch\n#define TEMP (scratch + 3*size)\n#define XYZ scratch\n#define TEMP_Y (scratch + 4*size)\n  mpn_set_base256_le (UKM, size, ukm, ukm_length);\n  if (mpn_zero_p (UKM, size))\n    UKM[0] = 1;\n  ecc_mod_mul (&ecc->q, TEMP, priv->p, UKM, TEMP); \n  ecc->mul (ecc, XYZ, TEMP, pub->p, scratch + 4*size); \n  ecc->h_to_a (ecc, 0, TEMP, XYZ, scratch + 5*size); \n  mpn_get_base256_le (out, bsize, TEMP, size);\n  mpn_get_base256_le (out+bsize, bsize, TEMP_Y, size);\n  gmp_free_limbs (scratch, itch);\n}", "target": 1}
{"code": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n\tchar *p2;\n\tstruct debug_data *d = f->private_data;\n\tpdata = kmalloc(cnt, GFP_KERNEL);\n\tif (pdata == NULL)\n\t\treturn 0;\n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n\t\tkfree(pdata);\n\t\treturn 0;\n\t}\n\tp0 = pdata;\n\tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\treturn (ssize_t)cnt;\n}", "target": 1}
{"code": "print_perm_line (int        idx,\n                 GPtrArray *items,\n                 int        cols)\n{\n  g_autoptr(GString) res = g_string_new (NULL);\n  int i;\n  g_string_append_printf (res, \"    [%d] %s\", idx, (char *) items->pdata[0]);\n  for (i = 1; i < items->len; i++)\n    {\n      char *p;\n      int len;\n      p = strrchr (res->str, '\\n');\n      if (!p)\n        p = res->str;\n      len = (res->str + strlen (res->str)) - p;\n      if (len + strlen ((char *) items->pdata[i]) + 2 >= cols)\n        g_string_append_printf (res, \",\\n        %s\", (char *) items->pdata[i]);\n      else\n        g_string_append_printf (res, \", %s\", (char *) items->pdata[i]);\n    }\n  g_print (\"%s\\n\", res->str);\n}", "target": 1}
{"code": "static inline bool unconditional(const struct arpt_arp *arp)\n{\n\tstatic const struct arpt_arp uncond;\n\treturn memcmp(arp, &uncond, sizeof(uncond)) == 0;\n}", "target": 1}
{"code": "decode_definite_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL;\n    char *buf;\n    buf = PyMem_Malloc(length);\n    if (!buf)\n        return PyErr_NoMemory();\n    if (fp_read(self, buf, length) == 0)\n        ret = PyUnicode_DecodeUTF8(\n                buf, length, PyBytes_AS_STRING(self->str_errors));\n    PyMem_Free(buf);\n    if (!ret)\n        return NULL;\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 1}
{"code": "OperationID FileSystemOperationRunner::BeginOperation(\n     std::unique_ptr<FileSystemOperation> operation) {\n   OperationID id = next_operation_id_++;\n  operations_.emplace(id, std::move(operation));\n   return id;\n }", "target": 1}
{"code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n    trail = 0;\n    length = info->name.length;\n    if (dir != NULL) {\n        length = dir->length;\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n        trail = (dir->start[dir->length - 1] != '/');\n        if (trail) {\n            length++;\n        }\n    }\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n    p = &src[0];\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n    return NJS_OK;\n}", "target": 1}
{"code": " int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n {\n \tstruct au1100fb_device *fbdev;\n\tunsigned int len;\n\tunsigned long start=0, off;\n \tfbdev = to_au1100fb_device(fbi);\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= (6 << 9); \n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\tvma->vm_end - vma->vm_start,\n\t\t\t\tvma->vm_page_prot)) {\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n }", "target": 1}
{"code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\t\treturn (int)len;\n\t}\n \tif (bufflen > 0 && bufflen < (size_t)len)\n \t\treturn GIT_EBUFS;\n \tline += PKT_LEN_SIZE;\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\tif (len == 0) { \n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\tlen -= PKT_LEN_SIZE; \n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\t*out = line + len;\n\treturn ret;\n}", "target": 1}
{"code": "static int ssd0323_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssd0323_state *s = (ssd0323_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->cmd_len = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 8; i++)\n        s->cmd_data[i] = qemu_get_be32(f);\n    s->row = qemu_get_be32(f);\n    s->row_start = qemu_get_be32(f);\n    s->row_end = qemu_get_be32(f);\n    s->col = qemu_get_be32(f);\n    s->col_start = qemu_get_be32(f);\n    s->col_end = qemu_get_be32(f);\n    s->redraw = qemu_get_be32(f);\n    s->remap = qemu_get_be32(f);\n    s->mode = qemu_get_be32(f);\n    qemu_get_buffer(f, s->framebuffer, sizeof(s->framebuffer));\n    ss->cs = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": "static int ax88179_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct sk_buff *ax_skb;\n\tint pkt_cnt;\n\tu32 rx_hdr;\n\tu16 hdr_off;\n\tu32 *pkt_hdr;\n\tif (skb->len < dev->net->hard_header_len)\n\t\treturn 0;\n\tskb_trim(skb, skb->len - 4);\n\trx_hdr = get_unaligned_le32(skb_tail_pointer(skb));\n\tpkt_cnt = (u16)rx_hdr;\n\thdr_off = (u16)(rx_hdr >> 16);\n\tpkt_hdr = (u32 *)(skb->data + hdr_off);\n\twhile (pkt_cnt--) {\n\t\tu16 pkt_len;\n\t\tle32_to_cpus(pkt_hdr);\n\t\tpkt_len = (*pkt_hdr >> 16) & 0x1fff;\n\t\tif ((*pkt_hdr & AX_RXHDR_CRC_ERR) ||\n\t\t    (*pkt_hdr & AX_RXHDR_DROP_ERR)) {\n\t\t\tskb_pull(skb, (pkt_len + 7) & 0xFFF8);\n\t\t\tpkt_hdr++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pkt_cnt == 0) {\n\t\t\tskb->len = pkt_len;\n\t\t\tskb_pull(skb, 2);\n\t\t\tskb_set_tail_pointer(skb, skb->len);\n\t\t\tskb->truesize = pkt_len + sizeof(struct sk_buff);\n\t\t\tax88179_rx_checksum(skb, pkt_hdr);\n\t\t\treturn 1;\n\t\t}\n\t\tax_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (ax_skb) {\n\t\t\tax_skb->len = pkt_len;\n\t\t\tskb_pull(ax_skb, 2);\n\t\t\tskb_set_tail_pointer(ax_skb, ax_skb->len);\n\t\t\tax_skb->truesize = pkt_len + sizeof(struct sk_buff);\n\t\t\tax88179_rx_checksum(ax_skb, pkt_hdr);\n\t\t\tusbnet_skb_return(dev, ax_skb);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tskb_pull(skb, (pkt_len + 7) & 0xFFF8);\n\t\tpkt_hdr++;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "pixBlockconvGrayUnnormalized(PIX     *pixs,\n                             l_int32  wc,\n                             l_int32  hc)\n{\nl_int32    i, j, w, h, d, wpla, wpld, jmax;\nl_uint32  *linemina, *linemaxa, *lined, *dataa, *datad;\nPIX       *pixsb, *pixacc, *pixd;\n    PROCNAME(\"pixBlockconvGrayUnnormalized\");\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pixs);\n    if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixsb not made\", procName, NULL);\n    pixacc = pixBlockconvAccum(pixsb);\n    pixDestroy(&pixsb);\n    if (!pixacc)\n        return (PIX *)ERROR_PTR(\"pixacc not made\", procName, NULL);\n    if ((pixd = pixCreate(w, h, 32)) == NULL) {\n        pixDestroy(&pixacc);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    wpla = pixGetWpl(pixacc);\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixacc);\n    for (i = 0; i < h; i++) {\n        lined = datad + i * wpld;\n        linemina = dataa + i * wpla;\n        linemaxa = dataa + (i + 2 * hc + 1) * wpla;\n        for (j = 0; j < w; j++) {\n            jmax = j + 2 * wc + 1;\n            lined[j] = linemaxa[jmax] - linemaxa[j] -\n                       linemina[jmax] + linemina[j];\n        }\n    }\n    pixDestroy(&pixacc);\n    return pixd;\n}", "target": 1}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 1}
{"code": "static struct kmem_cache *ccid_kmem_cache_create(int obj_size, char *slab_name_fmt, const char *fmt,...)\n{\n\tstruct kmem_cache *slab;\n\tva_list args;\n\tva_start(args, fmt);\n\tvsnprintf(slab_name_fmt, sizeof(slab_name_fmt), fmt, args);\n\tva_end(args);\n\tslab = kmem_cache_create(slab_name_fmt, sizeof(struct ccid) + obj_size, 0,\n\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\treturn slab;\n}", "target": 1}
{"code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}", "target": 1}
{"code": "int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state;\n\t\tint predictor = (encoded[0] << 8) | (encoded[1] & 0x80);\n\t\tif (predictor & 0x8000)\n\t\t\tpredictor -= 0x10000;\n\t\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\t\tstate.index = encoded[1] & 0x7f;\n\t\tencoded += 2;\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t e = *encoded;\n\t\t\tdecoded[n*channelCount + c] = decodeSample(state, e & 0xf);\n\t\t\tdecoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);\n\t\t\tencoded++;\n\t\t}\n\t}\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}", "target": 1}
{"code": "header_put_be_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "spnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n\t\t\tint\t\t*opened)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tret = gss_inquire_context(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tsrc_name,\n\t\t\t\ttarg_name,\n\t\t\t\tlifetime_rec,\n\t\t\t\tmech_type,\n\t\t\t\tctx_flags,\n\t\t\t\tlocally_initiated,\n\t\t\t\topened);\n\treturn (ret);\n}", "target": 1}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tgf_bs_write_u8(bs, ptr->layout.definedLayout);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.layouts[i].position);\n\t\t\t\tif (ptr->layout.layouts[i].position==126) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16);\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tgf_bs_write_u8(bs, ptr->layout.object_count);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}", "target": 1}
{"code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n \t\t\tstruct oz_multiple_fixed *body =\n \t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n \t\t\tu8 *data = body->data;\n\t\t\tint n;\n\t\t\tif (!body->unit_size)\n \t\t\t\tbreak;\n\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)\n \t\t\t\t/ body->unit_size;\n \t\t\twhile (n--) {\n \t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "int is_ntfs_dotgit(const char *name)\n{\n\tsize_t len;\n\tfor (len = 0; ; len++)\n\t\tif (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) {\n\t\t\tif (only_spaces_and_periods(name, len, 4) &&\n\t\t\t\t\t!strncasecmp(name, \".git\", 4))\n\t\t\t\treturn 1;\n\t\t\tif (only_spaces_and_periods(name, len, 5) &&\n\t\t\t\t\t!strncasecmp(name, \"git~1\", 5))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n}", "target": 1}
{"code": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tbool strict = env->strict_alignment;\n\tconst char *pointer_desc = \"\";\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n \t\tbreak;\n \tcase PTR_TO_STACK:\n \t\tpointer_desc = \"stack \";\n \t\tbreak;\n \tdefault:\n \t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}", "target": 1}
{"code": "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n\tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n\tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n\tif (p->mm) {\n\t\tstats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE / KB;\n\t}\n\tstats->read_char\t= p->rchar;\n\tstats->write_char\t= p->wchar;\n\tstats->read_syscalls\t= p->syscr;\n\tstats->write_syscalls\t= p->syscw;\n}", "target": 1}
{"code": "static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.time_page)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}", "target": 1}
{"code": " next_line(struct archive_read *a,\n     const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n \t\t*b += diff;\n \t\t*avail -= diff;\n \t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n \t\tif (len >= 0)\n \t\t\tlen += tested;\n \t}\n\treturn (len);\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* params;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kParams, &params));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kIndices, &indices));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  switch (indices->type) {\n    case kTfLiteInt32:\n      return EvalGatherNd<int32_t>(context, params, indices, output);\n    case kTfLiteInt64:\n      return EvalGatherNd<int64_t>(context, params, indices, output);\n    default:\n      context->ReportError(\n          context, \"Indices of type '%s' are not supported by gather_nd.\",\n          TfLiteTypeGetName(indices->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "xsltStylesheetPtr XSLStyleSheet::compileStyleSheet()\n{\n     if (m_embedded)\n         return xsltLoadStylesheetPI(document());\n     ASSERT(!m_stylesheetDocTaken);\n     xsltStylesheetPtr result = xsltParseStylesheetDoc(m_stylesheetDoc);\n     if (result)\n         m_stylesheetDocTaken = true;\n     return result;\n }", "target": 1}
{"code": "int main(int argc, char **argv, char **envp)\n{\n#ifdef DYNLOAD\n    if (!uc_dyn_load(NULL, 0)) {\n        printf(\"Error dynamically loading shared library.\\n\");\n        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    return 0;\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 4>::ConstTensor input,\n                  typename TTypes<T, 3>::ConstTensor filter,\n                  typename TTypes<T, 4>::ConstTensor out_backprop,\n                  int stride_rows, int stride_cols, int rate_rows,\n                  int rate_cols, int pad_top, int pad_left,\n                  typename TTypes<T, 3>::Tensor filter_backprop) {\n    const int batch = input.dimension(0);\n    const int input_rows = input.dimension(1);\n    const int input_cols = input.dimension(2);\n    const int depth = input.dimension(3);\n    const int filter_rows = filter.dimension(0);\n    const int filter_cols = filter.dimension(1);\n    const int output_rows = out_backprop.dimension(1);\n    const int output_cols = out_backprop.dimension(2);\n    filter_backprop.setZero();\n    for (int b = 0; b < batch; ++b) {\n      for (int h_out = 0; h_out < output_rows; ++h_out) {\n        int h_beg = h_out * stride_rows - pad_top;\n        for (int w_out = 0; w_out < output_cols; ++w_out) {\n          int w_beg = w_out * stride_cols - pad_left;\n          for (int d = 0; d < depth; ++d) {\n            T cur_val = Eigen::NumTraits<T>::lowest();\n            int h_max = 0;\n            int w_max = 0;\n            for (int h = 0; h < filter_rows; ++h) {\n              const int h_in = h_beg + h * rate_rows;\n              if (h_in >= 0 && h_in < input_rows) {\n                for (int w = 0; w < filter_cols; ++w) {\n                  const int w_in = w_beg + w * rate_cols;\n                  if (w_in >= 0 && w_in < input_cols) {\n                    const T val = input(b, h_in, w_in, d) + filter(h, w, d);\n                    if (val > cur_val) {\n                      cur_val = val;\n                      h_max = h;\n                      w_max = w;\n                    }\n                  }\n                }\n              }\n            }\n            filter_backprop(h_max, w_max, d) +=\n                out_backprop(b, h_out, w_out, d);\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "inline PointerReader ListReader::getPointerElement(ElementCount index) const {\n  return PointerReader(segment, capTable, reinterpret_cast<const WirePointer*>(\n      ptr + upgradeBound<uint64_t>(index) * step / BITS_PER_BYTE), nestingLimit);\n}", "target": 1}
{"code": "void jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval, jas_seqent_t maxval)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t v;\n\tjas_seqent_t *rowstart;\n\tjas_seqent_t *data;\n\tint rowstep;\n\trowstep = jas_matrix_rowstep(matrix);\n\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t  rowstart += rowstep) {\n\t\tdata = rowstart;\n\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t  ++data) {\n\t\t\tv = *data;\n\t\t\tif (v < minval) {\n\t\t\t\t*data = minval;\n\t\t\t} else if (v > maxval) {\n\t\t\t\t*data = maxval;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\tstruct msghdr *msg, size_t len, int noblock,\n\t\t\tint flags, int *addr_len)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct sockaddr_pn sa;\n\tint rval = -EOPNOTSUPP;\n\tint copylen;\n\tif (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n\tif (addr_len)\n\t\t*addr_len = sizeof(sa);\n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n\tpn_skb_get_src_sockaddr(skb, &sa);\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\trval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);\n\tif (rval) {\n\t\trval = -EFAULT;\n\t\tgoto out;\n\t}\n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n\tif (msg->msg_name != NULL)\n\t\tmemcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));\n out:\n \tskb_free_datagram(sk, skb);\nout_nofree:\n\treturn rval;\n}", "target": 1}
{"code": "static void sas_unregister_devs_sas_addr(struct domain_device *parent,\n\t\t\t\t\t int phy_id, bool last)\n{\n\tstruct expander_device *ex_dev = &parent->ex_dev;\n\tstruct ex_phy *phy = &ex_dev->ex_phy[phy_id];\n\tstruct domain_device *child, *n, *found = NULL;\n\tif (last) {\n\t\tlist_for_each_entry_safe(child, n,\n\t\t\t&ex_dev->children, siblings) {\n\t\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t\t    SAS_ADDR(phy->attached_sas_addr)) {\n\t\t\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\t\tsas_unregister_ex_tree(parent->port, child);\n\t\t\t\telse\n\t\t\t\t\tsas_unregister_dev(parent->port, child);\n\t\t\t\tfound = child;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsas_disable_routing(parent, phy->attached_sas_addr);\n\t}\n\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\tif (phy->port) {\n\t\tsas_port_delete_phy(phy->port, phy->phy);\n\t\tsas_device_set_phy(found, phy->port);\n\t\tif (phy->port->num_phys == 0)\n\t\t\tsas_port_delete(phy->port);\n\t\tphy->port = NULL;\n\t}\n}", "target": 1}
{"code": "quant::UniformQuantizedPerAxisType ResetAxisAndBroadcast(\n    ArrayRef<int64_t> shape, quant::UniformQuantizedPerAxisType qtype,\n    Type target, int quant_dim) {\n  auto shaped = target.dyn_cast<RankedTensorType>();\n  if (!shaped) return {};\n  ArrayRef<int64_t> new_shape = shaped.getShape();\n  SmallVector<double, 4> scales(qtype.getScales().begin(),\n                                qtype.getScales().end());\n  SmallVector<int64_t, 4> zero_points(qtype.getZeroPoints().begin(),\n                                      qtype.getZeroPoints().end());\n  if (new_shape.size() == shape.size()) {  \n    if (BroadcastVector<double>(shaped.getDimSize(quant_dim), scales) ||\n        BroadcastVector<int64_t>(shaped.getDimSize(quant_dim), zero_points)) {\n      return {};\n    }\n  } else if ((new_shape.size() == shape.size() + 1) && new_shape.back() == 1) {\n    if (std::equal(shape.begin(), shape.end(), new_shape.begin()) &&\n        quant_dim == -1) {\n      quant_dim = shape.size() + quant_dim;\n    } else {\n      return {};\n    }\n  } else {\n    return {};\n  }\n  return quant::UniformQuantizedPerAxisType::get(\n      qtype.getFlags(), qtype.getStorageType(), qtype.getExpressedType(),\n      scales, zero_points, quant_dim, qtype.getStorageTypeMin(),\n      qtype.getStorageTypeMax());\n}", "target": 1}
{"code": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n    qemu_put_be32(f, s->ris);\n    qemu_put_be32(f, s->im);\n    qemu_put_be32(f, s->rctl);\n    qemu_put_be32(f, s->tctl);\n    qemu_put_be32(f, s->thr);\n    qemu_put_be32(f, s->mctl);\n    qemu_put_be32(f, s->mdv);\n    qemu_put_be32(f, s->mtxd);\n    qemu_put_be32(f, s->mrxd);\n    qemu_put_be32(f, s->np);\n    qemu_put_be32(f, s->tx_fifo_len);\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        qemu_put_be32(f, s->rx[i].len);\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n    }\n    qemu_put_be32(f, s->next_packet);\n    qemu_put_be32(f, s->rx_fifo_offset);\n}", "target": 1}
{"code": "EXPORTED const char *dlist_reserve_path(const char *part, int isarchive,\n                                        const struct message_guid *guid)\n{\n    static char buf[MAX_MAILBOX_PATH];\n    const char *base;\n    if (strchr(part, '/')) {\n        base = part;\n    }\n    else {\n        base = isarchive ? config_archivepartitiondir(part)\n                         : config_partitiondir(part);\n    }\n    assert(base != NULL);\n    snprintf(buf, MAX_MAILBOX_PATH, \"%s/sync./%lu/%s\",\n                  base, (unsigned long)getpid(),\n                  message_guid_encode(guid));\n    if (cyrus_mkdir(buf, 0755)) {\n        syslog(LOG_ERR, \"IOERROR: failed to create %s/sync./%lu/ for reserve: %m\",\n                        base, (unsigned long)getpid());\n    }\n    return buf;\n}", "target": 1}
{"code": "static rfbBool MallocFrameBuffer(rfbClient* client) {\n  if(client->frameBuffer)\n    free(client->frameBuffer);\n  client->frameBuffer=malloc(client->width*client->height*client->format.bitsPerPixel/8);\n  return client->frameBuffer?TRUE:FALSE;\n}", "target": 1}
{"code": "int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \"Count: \" << count << \" DataTypeSize: \" << size;\n  return count * size;\n}", "target": 1}
{"code": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  \n\tvmcs_writel(HOST_CR4, read_cr4());  \n\tvmcs_writel(HOST_CR3, read_cr3());  \n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  \n#ifdef CONFIG_X86_64\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  \n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  \n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   \n\tvmx->host_idt_base = dt.address;\n\tvmcs_writel(HOST_RIP, vmx_return); \n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   \n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}", "target": 1}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n \thdr->sadb_msg_pid = c->portid;\n \thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n \tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n \treturn 0;\n}", "target": 1}
{"code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n \t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n \t\tuint32 row = 0;\n \t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns; s++) {\n \t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n \t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n \t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}", "target": 1}
{"code": "static void process_constructors (RBinFile *bf, RList *ret, int bits) {\n\tRList *secs = sections (bf);\n\tRListIter *iter;\n\tRBinSection *sec;\n\tint i, type;\n\tr_list_foreach (secs, iter, sec) {\n\t\ttype = -1;\n\t\tif (!strcmp (sec->name, \".fini_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (!strcmp (sec->name, \".init_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_INIT;\n\t\t} else if (!strcmp (sec->name, \".preinit_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_PREINIT;\n\t\t}\n\t\tif (type != -1) {\n\t\t\tut8 *buf = calloc (sec->size, 1);\n\t\t\tif (!buf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);\n\t\t\tif (bits == 32) {\n\t\t\t\tfor (i = 0; i < sec->size; i += 4) {\n\t\t\t\t\tut32 addr32 = r_read_le32 (buf + i);\n\t\t\t\t\tif (addr32) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < sec->size; i += 8) {\n\t\t\t\t\tut64 addr64 = r_read_le64 (buf + i);\n\t\t\t\t\tif (addr64) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t}\n\tr_list_free (secs);\n}", "target": 1}
{"code": "static int get_query(struct MHD_Connection *connection, char **query, const char *separator)\n{\n\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j;\n\tint length = 0;\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\tif (element_counter < 0) {\n\t\t*query = safe_strdup(\"\");\n\t\treturn MHD_NO;\n\t}\n\telements = calloc(element_counter, sizeof(char *));\n\tif (elements == NULL) {\n\t\treturn MHD_NO;\n\t}\n\tcollect_query.i = 0;\n\tcollect_query.elements = elements;\n\tMHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, collect_query_string, &collect_query);\n\tfor (i = 0; i < element_counter; i++) {\n\t\tif (!elements[i])\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\t\tif (i > 0) \n\t\t\tlength++;\n\t}\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tfree(elements[i]);\n\t\t}\n\t\tfree(elements);\n\t\treturn 0;\n\t}\n\tquery_str = safe_calloc(QUERYMAXLEN);\n\tfor (i = 0, j = 0; i < element_counter; i++) {\n\t\tif (!elements[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\t\tstrncpy(*query + j, elements[i], length - j);\n\t\tif (i == 0) {\n\t\t\tstrcpy(query_str, \"?\");\n\t\t} else {\n\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t}\n\t\t}\n\t\tif (QUERYMAXLEN - strlen(query_str) > length - j) {\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string exceeds the maximum of %d bytes so has been truncated.\", QUERYMAXLEN/2);\n\t\t}\n\t\tfree(elements[i]);\n\t}\n\tdebug(LOG_DEBUG, \" query is [%s]\", query_str);\n\tstrncpy(*query, query_str, QUERYMAXLEN);\n\tfree(query_str);\n\tfree(elements);\n\treturn 0;\n}", "target": 1}
{"code": "dvi_document_file_exporter_end (EvFileExporter *exporter)\n{\n\tgchar *command_line;\n\tgint exit_stat;\n\tGError *err = NULL;\n\tgboolean success;\n\tDviDocument *dvi_document = DVI_DOCUMENT(exporter);\n\tcommand_line = g_strdup_printf (\"dvipdfm %s -o %s \\\"%s\\\"\", \n\t\t\t\t\tdvi_document->exporter_opts->str,\n\t\t\t\t\tdvi_document->exporter_filename,\n\t\t\t\t\tdvi_document->context->filename);\n\tsuccess = g_spawn_command_line_sync (command_line,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &exit_stat,\n\t\t\t\t\t     &err);\n\tg_free (command_line);\n\tif (success == FALSE) {\n\t\tg_warning (\"Error: %s\", err->message);\n\t} else if (!WIFEXITED(exit_stat) || WEXITSTATUS(exit_stat) != EXIT_SUCCESS){\n\t\tg_warning (\"Error: dvipdfm does not end normally or exit with a failure status.\");\n\t}\n\tif (err)\n\t\tg_error_free (err);\n}", "target": 1}
{"code": "build_config(char *prefix, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server->port) + 20;\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, \"{\\n\");\n    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n    fprintf(f, \"\\n}\\n\");\n    fclose(f);\n    ss_free(path);\n}", "target": 1}
{"code": "int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\terr = ovl_want_write(dentry);\n \tif (err)\n \t\tgoto out;\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n \t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n \t\terr = notify_change(upperdentry, attr, NULL);\n \t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t} else {\n\t\terr = ovl_copy_up_last(dentry, attr, false);\n \t}\n \tovl_drop_write(dentry);\n out:\n\treturn err;\n}", "target": 1}
{"code": "static void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}", "target": 1}
{"code": "new_msg_register_event (u_int32_t seqnum, struct lsa_filter_type *filter)\n{\n  u_char buf[OSPF_API_MAX_MSG_SIZE];\n  struct msg_register_event *emsg;\n  int len;\n  emsg = (struct msg_register_event *) buf;\n  len = sizeof (struct msg_register_event) +\n    filter->num_areas * sizeof (struct in_addr);\n   emsg->filter.typemask = htons (filter->typemask);\n   emsg->filter.origin = filter->origin;\n   emsg->filter.num_areas = filter->num_areas;\n   return msg_new (MSG_REGISTER_EVENT, emsg, seqnum, len);\n }", "target": 1}
{"code": "void TileManager::crop( RawTile *ttt ){\n  int tw = image->getTileWidth();\n  int th = image->getTileHeight();\n  if( loglevel >= 5 ){\n    *logfile << \"TileManager :: Edge tile: Base size: \" << tw << \"x\" << th\n\t     << \": This tile: \" << ttt->width << \"x\" << ttt->height\n\t     << endl;\n  }\n  int len = tw * th * ttt->channels * (ttt->bpc/8);\n  unsigned char* buffer = (unsigned char*) malloc( len );\n  unsigned char* src_ptr = (unsigned char*) memcpy( buffer, ttt->data, len );\n  unsigned char* dst_ptr = (unsigned char*) ttt->data;\n  len =  ttt->width * ttt->channels * (ttt->bpc/8);\n  for( unsigned int i=0; i<ttt->height; i++ ){\n    memcpy( dst_ptr, src_ptr, len );\n    dst_ptr += len;\n    src_ptr += tw * ttt->channels * (ttt->bpc/8);\n  }\n  free( buffer );\n  len = ttt->width * ttt->height * ttt->channels * (ttt->bpc/8);\n  ttt->dataLength = len;\n  ttt->padded = false;\n}", "target": 1}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    OP_REQUIRES_OK_ASYNC(c,\n                         FillCollectiveParams(col_params, REDUCTION_COLLECTIVE,\n                                               c->input(1),\n                                               c->input(2),\n                                               c->input(3)),\n                         done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();\n    col_params->final_op = final_op_.get();\n    VLOG(1) << \"CollectiveReduceV2 group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "resolve_iffeature(struct lys_iffeature *expr)\n{\n    int index_e = 0, index_f = 0;\n    if (expr->expr) {\n        return resolve_iffeature_recursive(expr, &index_e, &index_f);\n    }\n    return 0;\n}", "target": 1}
{"code": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n \tdo {\n \t\tnext = hugetlb_entry_end(h, addr, end);\n \t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\t\tif (pte && walk->hugetlb_entry)\n \t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n \t\tif (err)\n \t\t\tbreak;\n \t} while (addr = next, addr != end);\n\treturn err;\n}", "target": 1}
{"code": "void Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };\n    m_messages.push_back(temp);\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n    emit newLogMessage(temp);\n}", "target": 1}
{"code": "size_t _process_request_next_key(mcp_parser_t *pr) {\n    const char *cur = pr->request + pr->parsed;\n    int remain = pr->reqlen - pr->parsed - 2;\n    while (remain) {\n        if (*cur == ' ') {\n            remain--;\n            cur++;\n            pr->parsed++;\n        } else {\n            break;\n        }\n    }\n    const char *s = memchr(cur, ' ', remain);\n    if (s != NULL) {\n        pr->klen = s - cur;\n        pr->parsed += s - cur;\n    } else {\n        pr->klen = remain;\n        pr->parsed += remain;\n    }\n    return cur - pr->request;\n}", "target": 1}
{"code": "static void set_own_dir(const char *argv0) {\n\tsize_t l = strlen(argv0);\n \twhile(l && argv0[l - 1] != '/')\n \t\tl--;\n \tif(l == 0)\n \t\tmemcpy(own_dir, \".\", 2);\n \telse {\n \t\tmemcpy(own_dir, argv0, l - 1);\n \t\town_dir[l] = 0;\n\t}\n}", "target": 1}
{"code": "PHPAPI char *php_escape_shell_arg(char *str)\n{\n\tint x, y = 0, l = strlen(str);\n\tchar *cmd;\n\tsize_t estimate = (4 * l) + 3;\n\tTSRMLS_FETCH();\n\tcmd = safe_emalloc(4, l, 3); \n#ifdef PHP_WIN32\n\tcmd[y++] = '\"';\n#else\n\tcmd[y++] = '\\'';\n#endif\n\tfor (x = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(cmd + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (str[x]) {\n#ifdef PHP_WIN32\n\t\tcase '\"':\n\t\tcase '%':\n\t\t\tcmd[y++] = ' ';\n\t\t\tbreak;\n#else\n\t\tcase '\\'':\n\t\t\tcmd[y++] = '\\'';\n\t\t\tcmd[y++] = '\\\\';\n\t\t\tcmd[y++] = '\\'';\n#endif\n\t\tdefault:\n\t\t\tcmd[y++] = str[x];\n                }\n        }\n #ifdef PHP_WIN32\n        cmd[y++] = '\"';\n #else\n        cmd[y++] = '\\'';\n\treturn cmd;\n}", "target": 1}
{"code": "  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }", "target": 1}
{"code": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, \n                                ecma_value_t key_arg, \n                                ecma_value_t value_arg, \n                                lit_magic_string_id_t lit_id) \n{\n  JERRY_ASSERT (container_p != NULL);\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} ", "target": 1}
{"code": "escapes(cp, tp)\nconst char\t*cp;\nchar *tp;\n{\n    while (*cp) {\n\tint\tcval = 0, meta = 0;\n\tif (*cp == '\\\\' && cp[1] && index(\"mM\", cp[1]) && cp[2]) {\n\t\tmeta = 1;\n\t\tcp += 2;\n\t}\n\tif (*cp == '\\\\' && cp[1] && index(\"0123456789xXoO\", cp[1]) && cp[2]) {\n\t    NEARDATA const char hex[] = \"00112233445566778899aAbBcCdDeEfF\";\n\t    const char *dp;\n\t    int dcount = 0;\n\t    cp++;\n\t    if (*cp == 'x' || *cp == 'X')\n\t\tfor (++cp; *cp && (dp = index(hex, *cp)) && (dcount++ < 2); cp++)\n\t\t    cval = (cval * 16) + ((int)(dp - hex) / 2);\n\t    else if (*cp == 'o' || *cp == 'O')\n\t\tfor (++cp; *cp && (index(\"01234567\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 8) + (*cp - '0');\n\t    else\n\t\tfor (; *cp && (index(\"0123456789\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 10) + (*cp - '0');\n\t} else if (*cp == '\\\\' && cp[1]) {\t\n\t    switch (*++cp) {\n\t    case '\\\\': cval = '\\\\'; break;\n\t    case 'n': cval = '\\n'; break;\n\t    case 't': cval = '\\t'; break;\n\t    case 'b': cval = '\\b'; break;\n\t    case 'r': cval = '\\r'; break;\n\t    default: cval = *cp;\n\t    }\n\t    cp++;\n\t} else if (*cp == '^' && cp[1]) { \n\t    cval = (*++cp & 0x1f);\n\t    cp++;\n\t} else\n\t    cval = *cp++;\n\tif (meta)\n\t    cval |= 0x80;\n\t*tp++ = cval;\n    }\n    *tp = '\\0';\n}", "target": 1}
{"code": "sysContact_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG, https:\n}", "target": 1}
{"code": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}", "target": 1}
{"code": "static int HistogramCompare(const void *x,const void *y)\n{\n  const PixelInfo\n    *color_1,\n    *color_2;\n  color_1=(const PixelInfo *) x;\n  color_2=(const PixelInfo *) y;\n  if (color_2->red != color_1->red)\n    return((int) color_1->red-(int) color_2->red);\n  if (color_2->green != color_1->green)\n    return((int) color_1->green-(int) color_2->green);\n  if (color_2->blue != color_1->blue)\n    return((int) color_1->blue-(int) color_2->blue);\n  return((int) color_2->count-(int) color_1->count);\n}", "target": 1}
{"code": "static int ttusb_dec_send_command(struct ttusb_dec *dec, const u8 command,\n\t\t\t\t  int param_length, const u8 params[],\n\t\t\t\t  int *result_length, u8 cmd_result[])\n{\n\tint result, actual_len;\n\tu8 *b;\n\tdprintk(\"%s\\n\", __func__);\n\tb = kmalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\tif ((result = mutex_lock_interruptible(&dec->usb_mutex))) {\n\t\tkfree(b);\n\t\tprintk(\"%s: Failed to lock usb mutex.\\n\", __func__);\n\t\treturn result;\n\t}\n\tb[0] = 0xaa;\n\tb[1] = ++dec->trans_count;\n\tb[2] = command;\n\tb[3] = param_length;\n\tif (params)\n\t\tmemcpy(&b[4], params, param_length);\n\tif (debug) {\n\t\tprintk(KERN_DEBUG \"%s: command: %*ph\\n\",\n\t\t       __func__, param_length, b);\n\t}\n\tresult = usb_bulk_msg(dec->udev, dec->command_pipe, b,\n\t\t\t      COMMAND_PACKET_SIZE + 4, &actual_len, 1000);\n\tif (result) {\n\t\tprintk(\"%s: command bulk message failed: error %d\\n\",\n\t\t       __func__, result);\n\t\tmutex_unlock(&dec->usb_mutex);\n\t\tkfree(b);\n\t\treturn result;\n\t}\n\tresult = usb_bulk_msg(dec->udev, dec->result_pipe, b,\n\t\t\t      COMMAND_PACKET_SIZE + 4, &actual_len, 1000);\n\tif (result) {\n\t\tprintk(\"%s: result bulk message failed: error %d\\n\",\n\t\t       __func__, result);\n\t\tmutex_unlock(&dec->usb_mutex);\n\t\tkfree(b);\n\t\treturn result;\n\t} else {\n\t\tif (debug) {\n\t\t\tprintk(KERN_DEBUG \"%s: result: %*ph\\n\",\n\t\t\t       __func__, actual_len, b);\n\t\t}\n\t\tif (result_length)\n\t\t\t*result_length = b[3];\n\t\tif (cmd_result && b[3] > 0)\n\t\t\tmemcpy(cmd_result, &b[4], b[3]);\n\t\tmutex_unlock(&dec->usb_mutex);\n\t\tkfree(b);\n\t\treturn 0;\n\t}\n}", "target": 1}
{"code": "isofs_export_encode_fh(struct inode *inode,\n\t\t       __u32 *fh32,\n\t\t       int *max_len,\n\t\t       struct inode *parent)\n{\n\tstruct iso_inode_info * ei = ISOFS_I(inode);\n\tint len = *max_len;\n\tint type = 1;\n\t__u16 *fh16 = (__u16*)fh32;\n\tif (parent && (len < 5)) {\n\t\t*max_len = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\treturn 255;\n\t}\n \tlen = 3;\n \tfh32[0] = ei->i_iget5_block;\n  \tfh16[2] = (__u16)ei->i_iget5_offset;  \n \tfh32[2] = inode->i_generation;\n \tif (parent) {\n \t\tstruct iso_inode_info *eparent;\n\t\teparent = ISOFS_I(parent);\n\t\tfh32[3] = eparent->i_iget5_block;\n\t\tfh16[3] = (__u16)eparent->i_iget5_offset;  \n\t\tfh32[4] = parent->i_generation;\n\t\tlen = 5;\n\t\ttype = 2;\n\t}\n\t*max_len = len;\n\treturn type;\n}", "target": 1}
{"code": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n    if (BLTUNSAFE(s))\n        return 0;\n\t(*s->cirrus_rop) (s, s->vram_ptr +\n                (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\t\t\t  s->vram_ptr +\n                (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n    return 1;\n}", "target": 1}
{"code": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n \tint r;\n \tstruct kvm_vcpu *vcpu, *v;\n \tvcpu = kvm_arch_vcpu_create(kvm, id);\n \tif (IS_ERR(vcpu))\n \t\treturn PTR_ERR(vcpu);\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}", "target": 1}
{"code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n\tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tstrcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n\t\t\t    &link_info, sizeof(link_info));\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n     int aligned_height;\n     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n         av_free(c->framebuf);\n         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n         if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "void CleanWriters(GF_List *writers)\n{\n\twhile (gf_list_count(writers)) {\n\t\tTrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);\n\t\tgf_isom_box_del(writer->stco);\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\tgf_free(writer);\n\t\tgf_list_rem(writers, 0);\n\t}\n}", "target": 1}
{"code": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}", "target": 1}
{"code": "void bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\tstruct bpf_binary_header *header = NULL;\n\tint proglen, oldproglen = 0;\n\tstruct jit_context ctx = {};\n\tu8 *image = NULL;\n\tint *addrs;\n\tint pass;\n\tint i;\n\tif (!bpf_jit_enable)\n\t\treturn;\n\tif (!prog || !prog->len)\n\t\treturn;\n\taddrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);\n\tif (!addrs)\n\t\treturn;\n\tfor (proglen = 0, i = 0; i < prog->len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tctx.cleanup_addr = proglen;\n\tfor (pass = 0; pass < 10; pass++) {\n\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n\t\tif (proglen <= 0) {\n\t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",\n\t\t\t\t       proglen, oldproglen);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\theader = bpf_jit_binary_alloc(proglen, &image,\n\t\t\t\t\t\t      1, jit_fill_hole);\n\t\t\tif (!header)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\tif (bpf_jit_enable > 1)\n\t\tbpf_jit_dump(prog->len, proglen, 0, image);\n\tif (image) {\n\t\tbpf_flush_icache(header, image + proglen);\n\t\tset_memory_ro((unsigned long)header, header->pages);\n\t\tprog->bpf_func = (void *)image;\n\t\tprog->jited = true;\n\t}\nout:\n\tkfree(addrs);\n}", "target": 1}
{"code": "int ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n \telf_xtregs_t *xtregs = uregs;\n \tint ret = 0;\n #if XTENSA_HAVE_COPROCESSORS\n \tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\treturn ret ? -EFAULT : 0;\n}", "target": 1}
{"code": "void SSecurityTLS::initGlobal()\n{\n  static bool globalInitDone = false;\n  if (!globalInitDone) {\n    if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_global_init failed\");\n    globalInitDone = true;\n  }\n}", "target": 1}
{"code": "static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,\n                               int size)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n    if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {\n        nc->info->receive(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n}", "target": 1}
{"code": "Envoy::Ssl::ClientValidationStatus DefaultCertValidator::verifyCertificate(\n    X509* cert, const std::vector<std::string>& verify_san_list,\n    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n        subject_alt_name_matchers) {\n  Envoy::Ssl::ClientValidationStatus validated = Envoy::Ssl::ClientValidationStatus::NotValidated;\n  if (!verify_san_list.empty()) {\n    if (!verifySubjectAltName(cert, verify_san_list)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  if (!subject_alt_name_matchers.empty()) {\n    if (!matchSubjectAltName(cert, subject_alt_name_matchers)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  if (!verify_certificate_hash_list_.empty() || !verify_certificate_spki_list_.empty()) {\n    const bool valid_certificate_hash =\n        !verify_certificate_hash_list_.empty() &&\n        verifyCertificateHashList(cert, verify_certificate_hash_list_);\n    const bool valid_certificate_spki =\n        !verify_certificate_spki_list_.empty() &&\n        verifyCertificateSpkiList(cert, verify_certificate_spki_list_);\n    if (!valid_certificate_hash && !valid_certificate_spki) {\n      stats_.fail_verify_cert_hash_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  return validated;\n}", "target": 1}
{"code": "static inline void exit_io_context(void)\n{\n}", "target": 1}
{"code": "bool Server::MatchViewOrStatic(const std::string& method,\n                               const std::string& url, bool* stream) {\n  if (Router::MatchView(method, url, stream)) {\n    return true;\n  }\n  if (method == methods::kGet && !doc_root_.empty()) {\n    fs::path path = doc_root_ / url;\n    fs::error_code ec;\n    if (!fs::is_directory(path, ec) && fs::exists(path, ec)) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "void AsfVideo::streamProperties() {\n  DataBuf streamTypedBuf = io_->read(GUID);\n  enum class streamTypeInfo { Audio = 1, Video = 2 };\n  auto stream = static_cast<streamTypeInfo>(0);\n  auto tag_stream_type = GUIDReferenceTags.find(GUIDTag(streamTypedBuf.data()));\n  if (tag_stream_type != GUIDReferenceTags.end()) {\n    if (tag_stream_type->second == \"Audio_Media\")\n      stream = streamTypeInfo::Audio;\n    else if (tag_stream_type->second == \"Video_Media\")\n      stream = streamTypeInfo::Video;\n    io_->seek(io_->tell() + GUID, BasicIo::beg);  \n    uint64_t time_offset = readQWORDTag(io_);\n    if (stream == streamTypeInfo::Video)\n      xmpData()[\"Xmp.video.TimeOffset\"] = time_offset;\n    else if (stream == streamTypeInfo::Audio)\n      xmpData()[\"Xmp.audio.TimeOffset\"] = time_offset;\n    auto specific_data_length = readDWORDTag(io_);\n    auto correction_data_length = readDWORDTag(io_);\n    io_->seek(io_->tell() + WORD  + DWORD  + specific_data_length + correction_data_length,\n              BasicIo::beg);\n  }\n}  ", "target": 1}
{"code": "   PowerPopupView() {\n     SetHorizontalAlignment(ALIGN_RIGHT);\n     UpdateText();\n   }", "target": 1}
{"code": "bool Archive::ReadSubData(Array<byte> *UnpData,File *DestFile,bool TestMode)\n{\n  if (BrokenHeader)\n  {\n    uiMsg(UIERROR_SUBHEADERBROKEN,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return false;\n  }\n  if (SubHead.Method>5 || SubHead.UnpVer>(Format==RARFMT50 ? VER_UNPACK5:VER_UNPACK))\n  {\n    uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n    return false;\n  }\n  if (SubHead.PackSize==0 && !SubHead.SplitAfter)\n    return true;\n  SubDataIO.Init();\n  Unpack Unpack(&SubDataIO);\n  Unpack.Init(SubHead.WinSize,false);\n  if (DestFile==NULL)\n  {\n    if (SubHead.UnpSize>0x1000000)\n    {\n      uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n      return false;\n    }\n    if (UnpData==NULL)\n      SubDataIO.SetTestMode(true);\n    else\n    {\n      UnpData->Alloc((size_t)SubHead.UnpSize);\n      SubDataIO.SetUnpackToMemory(&(*UnpData)[0],(uint)SubHead.UnpSize);\n    }\n  }\n  if (SubHead.Encrypted)\n    if (Cmd->Password.IsSet())\n      SubDataIO.SetEncryption(false,SubHead.CryptMethod,&Cmd->Password,\n                SubHead.SaltSet ? SubHead.Salt:NULL,SubHead.InitV,\n                SubHead.Lg2Count,SubHead.HashKey,SubHead.PswCheck);\n    else\n      return false;\n  SubDataIO.UnpHash.Init(SubHead.FileHash.Type,1);\n  SubDataIO.SetPackedSizeToRead(SubHead.PackSize);\n  SubDataIO.EnableShowProgress(false);\n  SubDataIO.SetFiles(this,DestFile);\n  SubDataIO.SetTestMode(TestMode);\n  SubDataIO.UnpVolume=SubHead.SplitAfter;\n  SubDataIO.SetSubHeader(&SubHead,NULL);\n  Unpack.SetDestSize(SubHead.UnpSize);\n  if (SubHead.Method==0)\n    CmdExtract::UnstoreFile(SubDataIO,SubHead.UnpSize);\n  else\n    Unpack.DoUnpack(SubHead.UnpVer,false);\n  if (!SubDataIO.UnpHash.Cmp(&SubHead.FileHash,SubHead.UseHashKey ? SubHead.HashKey:NULL))\n  {\n    uiMsg(UIERROR_SUBHEADERDATABROKEN,FileName,SubHead.FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    if (UnpData!=NULL)\n      UnpData->Reset();\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static x3f_huffnode_t *new_node(x3f_hufftree_t *tree)\n{\n  x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];\n  t->branch[0] = NULL;\n  t->branch[1] = NULL;\n  t->leaf = UNDEFINED_LEAF;\n  tree->free_node_index++;\n  return t;\n}", "target": 1}
{"code": "GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}", "target": 1}
{"code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    krb5_clear_error_message(context);\n    if (pol_dn == NULL)\n        return EINVAL;\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n    ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n    }\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}", "target": 1}
{"code": "fgetwln(FILE *stream, size_t *lenp)\n{\n\tstruct filewbuf *fb;\n\twint_t wc;\n\tsize_t wused = 0;\n\tfb = &fb_pool[fb_pool_cur];\n\tif (fb->fp != stream && fb->fp != NULL) {\n\t\tfb_pool_cur++;\n\t\tfb_pool_cur %= FILEWBUF_POOL_ITEMS;\n\t\tfb = &fb_pool[fb_pool_cur];\n\t}\n \tfb->fp = stream;\n \twhile ((wc = fgetwc(stream)) != WEOF) {\n\t\tif (!fb->len || wused > fb->len) {\n \t\t\twchar_t *wp;\n \t\t\tif (fb->len)\n\t\t\t\tfb->len *= 2;\n\t\t\telse\n\t\t\t\tfb->len = FILEWBUF_INIT_LEN;\n\t\t\twp = reallocarray(fb->wbuf, fb->len, sizeof(wchar_t));\n\t\t\tif (wp == NULL) {\n\t\t\t\twused = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfb->wbuf = wp;\n\t\t}\n\t\tfb->wbuf[wused++] = wc;\n\t\tif (wc == L'\\n')\n\t\t\tbreak;\n\t}\n\t*lenp = wused;\n\treturn wused ? fb->wbuf : NULL;\n}", "target": 1}
{"code": "print_bacp_config_options(netdissect_options *ndo,\n                          const u_char *p, int length)\n{\n\tint len, opt;\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t\t          opt,\n\t\t          len));\n\t\treturn 0;\n\t}\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t          opt,\n\t          len));\n\tswitch (opt) {\n\tcase BACPOPT_FPEER:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK2(*(p + 2), 4);\n\t\tND_PRINT((ndo, \": Magic-Num 0x%08x\", EXTRACT_32BITS(p + 2)));\n\t\tbreak;\n\tdefault:\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); \n\treturn len;\ntrunc:\n\tND_PRINT((ndo, \"[|bacp]\"));\n\treturn 0;\n}", "target": 1}
{"code": "  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecgsiGMAPLDAP.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }", "target": 1}
{"code": "static inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n    return close(sr->fd_file);\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayPopCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Value *v;\n    Jsi_Obj *obj;\n    obj = _this->d.obj;\n    int i = Jsi_ObjGetLength(interp, obj) - 1;\n    if (i < 0) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    if (obj->arr) {\n        if ((v = obj->arr[i])) {\n            obj->arr[i] = NULL;\n            obj->arrCnt--;\n        }\n    } else {\n        v = Jsi_ValueArrayIndex(interp, _this, i);\n    }\n    if (v) {\n        Jsi_DecrRefCount(interp, *ret);\n        *ret = v;\n    }\n    Jsi_ObjSetLength(interp, obj, i);\n    return JSI_OK;\n}", "target": 1}
{"code": "void rose_stop_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "char *gf_bt_get_next(GF_BTParser *parser, Bool point_break)\n{\n\tu32 has_quote;\n\tBool go = 1;\n\ts32 i;\n\tgf_bt_check_line(parser);\n\ti=0;\n\thas_quote = 0;\n\twhile (go) {\n\t\tif (parser->line_buffer[parser->line_pos + i] == '\\\"') {\n\t\t\tif (!has_quote) has_quote = 1;\n\t\t\telse has_quote = 0;\n\t\t\tparser->line_pos += 1;\n\t\t\tif (parser->line_pos+i==parser->line_size) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!has_quote) {\n\t\t\tswitch (parser->line_buffer[parser->line_pos + i]) {\n\t\t\tcase 0:\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase ']':\n\t\t\tcase '[':\n\t\t\tcase ',':\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tif (point_break) go = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!go) break;\n\t\t}\n\t\tparser->cur_buffer[i] = parser->line_buffer[parser->line_pos + i];\n\t\ti++;\n\t\tif (parser->line_pos+i==parser->line_size) break;\n\t}\n\tparser->cur_buffer[i] = 0;\n\tparser->line_pos += i;\n\treturn parser->cur_buffer;\n}", "target": 1}
{"code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  \n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  \n  va_end(argp);\n  if (isLua(ci))  \n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}", "target": 1}
{"code": "void DoCanonicalizeRef(const CHAR* spec,\n                       const Component& ref,\n                       CanonOutput* output,\n                       Component* out_ref) {\n  if (ref.len < 0) {\n    *out_ref = Component();\n    return;\n  }\n  output->push_back('#');\n  out_ref->begin = output->length();\n  int end = ref.end();\n  for (int i = ref.begin; i < end; i++) {\n    if (spec[i] == 0) {\n      continue;\n    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {\n      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);\n    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {\n       output->push_back(static_cast<char>(spec[i]));\n     } else {\n      unsigned code_point;\n      ReadUTFChar(spec, &i, end, &code_point);\n      AppendUTF8Value(code_point, output);\n     }\n   }\n  out_ref->len = output->length() - out_ref->begin;\n}", "target": 1}
{"code": "SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n    return TPM_SUCCESS;\n}", "target": 1}
{"code": "AMediaCodecCryptoInfo *AMediaCodecCryptoInfo_new(\n int numsubsamples,\n uint8_t key[16],\n uint8_t iv[16],\n cryptoinfo_mode_t mode,\n size_t *clearbytes,\n         size_t *encryptedbytes) {\n    size_t cryptosize = sizeof(AMediaCodecCryptoInfo) + sizeof(size_t) * numsubsamples * 2;\n     AMediaCodecCryptoInfo *ret = (AMediaCodecCryptoInfo*) malloc(cryptosize);\n     if (!ret) {\n         ALOGE(\"couldn't allocate %zu bytes\", cryptosize);\n return NULL;\n }\n    ret->numsubsamples = numsubsamples;\n    memcpy(ret->key, key, 16);\n    memcpy(ret->iv, iv, 16);\n    ret->mode = mode;\n    ret->pattern.encryptBlocks = 0;\n    ret->pattern.skipBlocks = 0;\n    ret->clearbytes = (size_t*) (ret + 1); \n    ret->encryptedbytes = ret->clearbytes + numsubsamples; \n    memcpy(ret->clearbytes, clearbytes, numsubsamples * sizeof(size_t));\n    memcpy(ret->encryptedbytes, encryptedbytes, numsubsamples * sizeof(size_t));\n return ret;\n}", "target": 1}
{"code": "llvm::Optional<Value> simplifyBroadcast(ShapeComponentAnalysis& analysis,\n                                        ValueRange shapes, Location loc,\n                                        OpBuilder* builder) {\n  SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;\n  size_t maxRank = 0;\n  for (const auto &shape : llvm::enumerate(shapes)) {\n    auto found_shape = analysis.GetValueInfo(shape.value());\n    if (!found_shape) return {};\n    shapes_found.push_back(*found_shape);\n    maxRank = std::max(maxRank, found_shape->size());\n  }\n  SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions(\n      maxRank);\n  SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);\n  for (const auto &shape : llvm::enumerate(shapes_found)) {\n    for (const auto &dim : llvm::enumerate(llvm::reverse(shape.value()))) {\n      if (dim.value().isConstant(1)) continue;\n      auto index = maxRank - dim.index() - 1;\n      if (!joined_dimensions[index]) {\n        joined_dimensions[index] = &dim.value();\n        shape_and_rank_for_dim[index] =\n            std::make_pair(shapes[shape.index()], shape.value().size());\n        continue;\n      }\n      if (*joined_dimensions[index] != dim.value()) return {};\n    }\n  }\n  if (llvm::is_splat(shape_and_rank_for_dim) &&\n      shape_and_rank_for_dim[0].first) {\n    return shape_and_rank_for_dim[0].first;\n  }\n  SmallVector<Value> elements;\n  for (int i = 0; i != maxRank; ++i) {\n    if (!shape_and_rank_for_dim[i].first) {\n      auto one = builder->getIntegerAttr(\n          shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);\n      elements.push_back(builder->create<ConstantOp>(loc, one));\n      continue;\n    }\n    Value index = builder->create<ConstantIndexOp>(\n        loc, i - maxRank + shape_and_rank_for_dim[i].second);\n    elements.push_back(builder->create<tensor::ExtractOp>(\n        loc, shape_and_rank_for_dim[i].first, index));\n  }\n  return Value(builder->create<tensor::FromElementsOp>(loc, elements));\n}", "target": 1}
{"code": "static void put_prev_task(struct rq *rq, struct task_struct *prev)\n{\n\tif (prev->se.on_rq)\n\t\tupdate_rq_clock(rq);\n\trq->skip_clock_update = 0;\n\tprev->sched_class->put_prev_task(rq, prev);\n}", "target": 1}
{"code": "sraSpanRemove(sraSpan *span) {\n  span->_prev->_next = span->_next;\n  span->_next->_prev = span->_prev;\n}", "target": 1}
{"code": "int ip_check_mc_rcu(struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u8 proto)\n{\n\tstruct ip_mc_list *im;\n\tstruct ip_mc_list __rcu **mc_hash;\n\tstruct ip_sf_list *psf;\n\tint rv = 0;\n\tmc_hash = rcu_dereference(in_dev->mc_hash);\n\tif (mc_hash) {\n\t\tu32 hash = hash_32((__force u32)mc_addr, MC_HASH_SZ_LOG);\n\t\tfor (im = rcu_dereference(mc_hash[hash]);\n\t\t     im != NULL;\n\t\t     im = rcu_dereference(im->next_hash)) {\n\t\t\tif (im->multiaddr == mc_addr)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tfor_each_pmc_rcu(in_dev, im) {\n\t\t\tif (im->multiaddr == mc_addr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (im && proto == IPPROTO_IGMP) {\n\t\trv = 1;\n\t} else if (im) {\n\t\tif (src_addr) {\n\t\t\tfor (psf = im->sources; psf; psf = psf->sf_next) {\n\t\t\t\tif (psf->sf_inaddr == src_addr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (psf)\n\t\t\t\trv = psf->sf_count[MCAST_INCLUDE] ||\n\t\t\t\t\tpsf->sf_count[MCAST_EXCLUDE] !=\n\t\t\t\t\tim->sfcount[MCAST_EXCLUDE];\n\t\t\telse\n\t\t\t\trv = im->sfcount[MCAST_EXCLUDE] != 0;\n\t\t} else\n\t\t\trv = 1; \n\t}\n\treturn rv;\n}", "target": 1}
{"code": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n \t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n {\n \tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n \tif (1 + wlen > MAX_XFER_SIZE) {\n \t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n \t\treturn -EOPNOTSUPP;\n \t}\n\two = (rbuf == NULL || rlen == 0); \n \tmutex_lock(&d->data_mutex);\n \tst->data[0] = cmd;\n \tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n \tmutex_unlock(&d->data_mutex);\n \treturn ret;\n}", "target": 1}
{"code": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n\tfor (tidno = 0, tid = &an->tid[tidno];\n\t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n\t\tif (!tid->sched)\n\t\t\tcontinue;\n\t\tac = tid->ac;\n\t\ttxq = ac->txq;\n\t\tath_txq_lock(sc, txq);\n\t\tbuffered = ath_tid_has_buffered(tid);\n\t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\t\tath_txq_unlock(sc, txq);\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}", "target": 1}
{"code": "void dhcps_deinit(void)\n{\n\tif (dhcps_pcb != NULL) {\n\t\tudp_remove(dhcps_pcb);\n\t\tdhcps_pcb = NULL;\t\n\t}\n\tif (dhcps_ip_table_semaphore != NULL) {\t\n\t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n\t\tdhcps_ip_table_semaphore = NULL;\n\t}\t\t\n}", "target": 1}
{"code": "RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRBinAddr *entry;\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tentry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tRBinSection *s = r_list_get_n (segments, bin->ne_header->csEntryPoint - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tentry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { \n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xFF) { \n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);\n\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t} else { \n\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off);\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}", "target": 1}
{"code": "static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pmd_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pmd_devmap(orig))\n\t\treturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pmd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "Status TensorSliceReader::GetTensor(\n    const string& name, std::unique_ptr<tensorflow::Tensor>* out_tensor) const {\n  DataType type;\n  TensorShape shape;\n  TensorSlice slice;\n  {\n    mutex_lock l(mu_);\n    const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n    if (tss == nullptr) {\n      return errors::NotFound(name, \" not found in checkpoint file\");\n    }\n    if (tss->Slices().size() > 1) {\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));\n  bool success = false;\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n  switch (type) {\n    READER_COPY(DT_FLOAT);\n    READER_COPY(DT_DOUBLE);\n    READER_COPY(DT_INT32);\n    READER_COPY(DT_UINT8);\n    READER_COPY(DT_INT16);\n    READER_COPY(DT_INT8);\n    READER_COPY(DT_INT64);\n    READER_COPY(DT_STRING);\n    default:\n      return errors::Unimplemented(\"Data type not supported\");\n  }\n#undef READER_COPY\n  if (!success) {\n    return errors::NotFound(name, \" not found in checkpoint file\");\n  }\n  std::swap(*out_tensor, t);\n  return Status::OK();\n}", "target": 1}
{"code": "INST_HANDLER (cpse) {\t\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "PJ_DEF(int) pj_scan_get_char( pj_scanner *scanner )\n{\n    int chr = *scanner->curptr;\n    if (!chr) {\n\tpj_scan_syntax_err(scanner);\n\treturn 0;\n    }\n    ++scanner->curptr;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n    return chr;\n}", "target": 1}
{"code": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n     int off_cur;\n     int off_cur_end;\n     for (y = 0; y < lines; y++) {\n        off_cur = off_begin;\n        off_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;\n         memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);\n        off_begin += off_pitch;\n     }\n    uint8_t *dst;\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n    if (blit_is_unsafe(s, false))\n        return 0;\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}", "target": 1}
{"code": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n    if (SMALL_OBJ(lb))\n         return(GC_generic_malloc((word)lb, k));\n     lg = ROUNDED_UP_GRANULES(lb);\n     lb_rounded = GRANULES_TO_BYTES(lg);\n     n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n     init = GC_obj_kinds[k].ok_init;\n     if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}", "target": 1}
{"code": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n {\n \tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 1}
{"code": "void options_defaults() {\n    SERVICE_OPTIONS *service;\n    memset(&new_global_options, 0, sizeof(GLOBAL_OPTIONS));\n    memset(&new_service_options, 0, sizeof(SERVICE_OPTIONS));\n    new_service_options.next=NULL;\n    parse_global_option(CMD_SET_DEFAULTS, NULL, NULL);\n    service=&new_service_options;\n    parse_service_option(CMD_SET_DEFAULTS, &service, NULL, NULL);\n}", "target": 1}
{"code": "void cipso_v4_sock_delattr(struct sock *sk)\n{\n\tint hdr_delta;\n\tstruct ip_options *opt;\n\tstruct inet_sock *sk_inet;\n\tsk_inet = inet_sk(sk);\n\topt = sk_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\thdr_delta = cipso_v4_delopt(&sk_inet->opt);\n\tif (sk_inet->is_icsk && hdr_delta > 0) {\n\t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n\t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}", "target": 1}
{"code": "void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n\t\t    gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n\tvoid *memory;\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\treturn __dma_alloc(dev, size, handle, gfp, prot, false,\n\t\t\t   __builtin_return_address(0));\n}", "target": 1}
{"code": "    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        if(len < 1)\n        {\n            return alloc;\n        }\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n        if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n        alloc = std::string(attr_vals);\n        return alloc;\n    }", "target": 1}
{"code": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\nexit:\n    return error;\n}", "target": 1}
{"code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    auto* resource = node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      outer_context->set_output_handle_shapes_and_types(index, *resource);\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "pullf_read_max(PullFilter *pf, int len, uint8 **data_p, uint8 *tmpbuf)\n{\n\tint\t\t\tres,\n\t\t\t\ttotal;\n\tuint8\t   *tmp;\n\tres = pullf_read(pf, len, data_p);\n\tif (res <= 0 || res == len)\n\t\treturn res;\n\tmemcpy(tmpbuf, *data_p, res);\n\t*data_p = tmpbuf;\n\tlen -= res;\n\ttotal = res;\n\twhile (len > 0)\n\t{\n\t\tres = pullf_read(pf, len, &tmp);\n\t\tif (res < 0)\n\t\t{\n\t\t\tpx_memset(tmpbuf, 0, total);\n\t\t\treturn res;\n\t\t}\n\t\tif (res == 0)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuf + total, tmp, res);\n\t\ttotal += res;\n\t}\n\treturn total;\n}", "target": 1}
{"code": "nft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64(dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\t*dest = nft_meta_hour(ktime_get_real_seconds());\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "static void vgacon_scrollback_startup(void)\n{\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[0];\n\tvgacon_scrollback_init(0);\n}", "target": 1}
{"code": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\tmutex_lock(&ctx->ring_lock);\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n \tif (head == tail)\n \t\tgoto out;\n \twhile (ret < nr) {\n \t\tlong avail;\n \t\tstruct io_event *ev;\n\t\tstruct page *page;\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\treturn ret;\n}", "target": 1}
{"code": "static int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)\n{\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tpvc_device *pvc;\n\tstruct net_device *dev;\n\tint used;\n\tif ((pvc = add_pvc(frad, dlci)) == NULL) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_add_pvc()\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (*get_dev_p(pvc, type))\n\t\treturn -EEXIST;\n\tused = pvc_is_used(pvc);\n\tif (type == ARPHRD_ETHER)\n\t\tdev = alloc_netdev(0, \"pvceth%d\", ether_setup);\n\telse\n\t\tdev = alloc_netdev(0, \"pvc%d\", pvc_setup);\n\tif (!dev) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_pvc()\\n\");\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -ENOBUFS;\n\t}\n\tif (type == ARPHRD_ETHER)\n\t\trandom_ether_addr(dev->dev_addr);\n\telse {\n\t\t*(__be16*)dev->dev_addr = htons(dlci);\n\t\tdlci_to_q922(dev->broadcast, dlci);\n\t}\n\tdev->netdev_ops = &pvc_ops;\n\tdev->mtu = HDLC_MAX_MTU;\n\tdev->tx_queue_len = 0;\n\tdev->ml_priv = pvc;\n\tif (register_netdevice(dev) != 0) {\n\t\tfree_netdev(dev);\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -EIO;\n\t}\n\tdev->destructor = free_netdev;\n\t*get_dev_p(pvc, type) = dev;\n\tif (!used) {\n\t\tstate(hdlc)->dce_changed = 1;\n\t\tstate(hdlc)->dce_pvc_count++;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "std::string sanitizeNameForWindowList(const std::string& name) {\n    std::string result = name;\n    if (result[0] == '\\\"')\n        result[0] = ' ';\n    for (size_t i = 1; i < result.size(); ++i) {\n        if (result[i - 1] == '>' && result[i] == ']')\n            result[i] = ' ';\n        if (result[i] == '\\\"')\n            result[i] = ' ';\n    }\n    return result;\n}", "target": 1}
{"code": "Value sendrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 1)\n        throw runtime_error(\n            \"sendrawtransaction <hex string>\\n\"\n            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n    RPCTypeCheck(params, list_of(str_type));\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(-22, \"TX decode failed\");\n    }\n    uint256 hashTx = tx.GetHash();\n    CTransaction existingTx;\n    uint256 hashBlock = 0;\n    if (GetTransaction(hashTx, existingTx, hashBlock))\n    {\n        if (hashBlock != 0)\n            throw JSONRPCError(-5, string(\"transaction already in block \")+hashBlock.GetHex());\n    }\n    else\n    {\n        CTxDB txdb(\"r\");\n        if (!tx.AcceptToMemoryPool(txdb))\n            throw JSONRPCError(-22, \"TX rejected\");\n        SyncWithWallets(tx, NULL, true);\n    }\n    RelayMessage(CInv(MSG_TX, hashTx), tx);\n    return hashTx.GetHex();\n}", "target": 1}
{"code": "static int neightbl_fill_param_info(struct neigh_table *tbl,\n\t\t\t\t    struct neigh_parms *parms,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tstruct ndtmsg *ndtmsg;\n\tstruct nlmsghdr *nlh;\n\tnlh = NLMSG_NEW_ANSWER(skb, cb, RTM_NEWNEIGHTBL, sizeof(struct ndtmsg),\n\t\t\t       NLM_F_MULTI);\n\tndtmsg = NLMSG_DATA(nlh);\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\tRTA_PUT_STRING(skb, NDTA_NAME, tbl->id);\n\tif (neightbl_fill_parms(skb, parms) < 0)\n\t\tgoto rtattr_failure;\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_END(skb, nlh);\nrtattr_failure:\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_CANCEL(skb, nlh);\nnlmsg_failure:\n\treturn -1;\n}", "target": 1}
{"code": "exif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Loading entry 0x%x ('%s')...\", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\tif ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", doff+s, size);\t\n\t\treturn 0;\n\t}\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;\n\t}\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"MakerNote found with empty data\");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t       \"MakerNote found (%02x %02x %02x %02x \"\n\t\t\t\t\t       \"%02x %02x %02x...).\",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int net_ctl_permissions(struct ctl_table_header *head,\n\t\t\t       struct ctl_table *table)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\tkuid_t root_uid = make_kuid(net->user_ns, 0);\n\tkgid_t root_gid = make_kgid(net->user_ns, 0);\n \tif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\n\t    uid_eq(root_uid, current_uid())) {\n \t\tint mode = (table->mode >> 6) & 7;\n \t\treturn (mode << 6) | (mode << 3) | mode;\n \t}\n\tif (gid_eq(root_gid, current_gid())) {\n \t\tint mode = (table->mode >> 3) & 7;\n \t\treturn (mode << 3) | mode;\n \t}\n\treturn table->mode;\n}", "target": 1}
{"code": "test_custom_handler(void **state)\n{\n    (void) state;\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(1, \"cstm\", custom_err_handler);\n    assert_null(old);\n    unsigned i;\n    for (i = 1; i < 4; i++) {\n        TSS2_RC rc = TSS2_RC_LAYER(1) | i;\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"cstm:error %u\", i);\n        const char *e = Tss2_RC_Decode(rc);\n        assert_string_equal(e, buf);\n    }\n    TSS2_RC rc = TSS2_RC_LAYER(1) | 42;\n    const char *e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"cstm:0x2A\");\n    old = Tss2_RC_SetHandler(1, \"cstm\", NULL);\n    assert_ptr_equal(old, custom_err_handler);\n    e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"1:0x2A\");\n}", "target": 1}
{"code": "l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(ptr))); ptr++;\t\n\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(ptr))); ptr++;\t\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n\t\t\t     \"Direction-#%u\", *((const u_char *)ptr++))));\n\tif (length > 5) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length-5);\n\t}\n}", "target": 1}
{"code": "static void ssl_write_hostname_ext( ssl_context *ssl,\n                                    unsigned char *buf,\n                                    size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + SSL_MAX_CONTENT_LEN;\n    *olen = 0;\n    if( ssl->hostname == NULL )\n        return;\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding server name extension: %s\",\n                   ssl->hostname ) );\n    if( (size_t)(end - p) < ssl->hostname_len + 9 )\n    {\n         SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n         return;\n    }\n    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME      ) & 0xFF );\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 5) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 5)      ) & 0xFF );\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 3) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( (ssl->hostname_len + 3)      ) & 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME_HOSTNAME ) & 0xFF );\n    *p++ = (unsigned char)( ( ssl->hostname_len >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( ssl->hostname_len      ) & 0xFF );\n    memcpy( p, ssl->hostname, ssl->hostname_len );\n    *olen = ssl->hostname_len + 9;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                BatchToSpaceNDContext* op_context) {\n  TfLiteIntArray* input_size = op_context->input->dims;\n  const int* block_shape = GetTensorData<int32>(op_context->block_shape);\n  const int* crops = GetTensorData<int32>(op_context->crops);\n  int spatial_dims_num = input_size->size - 2;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);\n  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->crops), 2);\n  TF_LITE_ENSURE_EQ(context, op_context->crops->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, op_context->crops->dims->data[1], 2);\n  for (int i = 0; i < spatial_dims_num * 2; ++i) {\n    TF_LITE_ENSURE(context, crops[i] >= 0);\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);\n  int output_batch_size = input_size->data[0];\n  for (int dim = 0; dim < spatial_dims_num; ++dim) {\n    TF_LITE_ENSURE_EQ(context, output_batch_size % block_shape[dim], 0);\n    output_batch_size = output_batch_size / block_shape[dim];\n    output_size->data[dim + 1] = input_size->data[dim + 1] * block_shape[dim] -\n                                 crops[dim * 2] - crops[dim * 2 + 1];\n  }\n  output_size->data[0] = output_batch_size;\n  output_size->data[input_size->size - 1] =\n      input_size->data[input_size->size - 1];\n  return context->ResizeTensor(context, op_context->output, output_size);\n}", "target": 1}
{"code": "static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n\tif (!err) {\n\t\tif (sat) {\n\t\t\tsat->sat_family      = AF_APPLETALK;\n\t\t\tsat->sat_port        = ddp->deh_sport;\n\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\t}\n\t\tmsg->msg_namelen = sizeof(*sat);\n \t}\n \tskb_free_datagram(sk, skb);\t\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size)\n{\n    RAMBlock *block, *next_block;\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n    assert(size != 0); \n    if (QLIST_EMPTY(&uc->ram_list.blocks)) {\n        return 0;\n    }\n    RAMBLOCK_FOREACH(block) {\n        ram_addr_t candidate, next = RAM_ADDR_MAX;\n        candidate = block->offset + block->max_length;\n        candidate = ROUND_UP(candidate, BITS_PER_LONG << TARGET_PAGE_BITS);\n        RAMBLOCK_FOREACH(next_block) {\n            if (next_block->offset >= candidate) {\n                next = MIN(next, next_block->offset);\n            }\n        }\n        if (next - candidate >= size && next - candidate < mingap) {\n            offset = candidate;\n            mingap = next - candidate;\n        }\n    }\n    if (offset == RAM_ADDR_MAX) {\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n                (uint64_t)size);\n        abort();\n    }\n    return offset;\n}", "target": 1}
{"code": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\tmemset(&cai, 0, sizeof(cai));\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\tif (iaxs[callno]) {\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\treturn 1;\n}", "target": 1}
{"code": "header_read (SF_PRIVATE *psf, void *ptr, int bytes)\n{\tint count = 0 ;\n\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\treturn psf_fread (ptr, 1, bytes, psf) ;\n\tif (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))\n\t{\tint most ;\n\t\tmost = SIGNED_SIZEOF (psf->header) - psf->headend ;\n\t\tpsf_fread (psf->header + psf->headend, 1, most, psf) ;\n\t\tmemcpy (ptr, psf->header + psf->headend, most) ;\n\t\tpsf->headend = psf->headindex += most ;\n\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;\n\t\treturn bytes ;\n\t\t} ;\n\tif (psf->headindex + bytes > psf->headend)\n\t{\tcount = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;\n\t\tif (count != bytes - (int) (psf->headend - psf->headindex))\n\t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;\n\t\t\treturn count ;\n\t\t\t} ;\n\t\tpsf->headend += count ;\n\t\t} ;\n\tmemcpy (ptr, psf->header + psf->headindex, bytes) ;\n\tpsf->headindex += bytes ;\n\treturn bytes ;\n} ", "target": 1}
{"code": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n    lua_settop(L, 3);\n    return 1;\n}", "target": 1}
{"code": "static bool read_header_from_file(zckCtx *zck) {\n    if(zck->lead_size == 0 || zck->header_length == 0) {\n        set_error(zck, \"Lead and header sizes are both 0.  Have you run zck_read_lead() yet?\");\n        return false;\n    }\n    zck->header = zrealloc(zck->header, zck->lead_size + zck->header_length);\n    if (!zck->header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck->lead_string = zck->header;\n    char *header = zck->header + zck->lead_size;\n    size_t loaded = 0;\n    if(zck->header_length < zck->header_size - zck->lead_size) {\n        set_fatal_error(zck, \"Header size is too small for actual data\");\n        return false;\n    }\n    if(zck->lead_size < zck->header_size)\n        loaded = zck->header_size - zck->lead_size;\n    zck_log(ZCK_LOG_DEBUG, \"Reading the rest of the header: %llu bytes\",\n            (long long unsigned) zck->header_length);\n    if(loaded < zck->header_length) {\n        if(read_data(zck, header + loaded, zck->header_length - loaded) < zck->header_length - loaded) {\n            set_fatal_error(zck, \"Unable to read %llu bytes from the file\", zck->header_length - loaded);\n            return false;\n        }\n        zck->header_size = zck->lead_size + zck->header_length;\n    }\n    if(!hash_init(zck, &(zck->check_full_hash), &(zck->hash_type)))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), \"\\0ZCK1\", 5))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), zck->header+5,\n                    zck->hdr_digest_loc-5))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), header, zck->header_length))\n        return false;\n    int ret = validate_header(zck);\n    if(ret < 1) {\n        if(ret == -1)\n            set_fatal_error(zck, \"Header checksum failed verification\");\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n  if (rar->bytes_unconsumed > 0) {\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n    break;\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}", "target": 1}
{"code": "static void mpeg4_encode_gop_header(MpegEncContext *s)\n{\n    int hours, minutes, seconds;\n    int64_t time;\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, GOP_STARTCODE);\n    time = s->current_picture_ptr->f->pts;\n    if (s->reordered_input_picture[1])\n        time = FFMIN(time, s->reordered_input_picture[1]->f->pts);\n    time = time * s->avctx->time_base.num;\n    s->last_time_base = FFUDIV(time, s->avctx->time_base.den);\n    seconds = FFUDIV(time, s->avctx->time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n    put_bits(&s->pb, 5, hours);\n    put_bits(&s->pb, 6, minutes);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 6, seconds);\n    put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&s->pb, 1, 0);  \n    ff_mpeg4_stuffing(&s->pb);\n}", "target": 1}
{"code": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;\n}", "target": 1}
{"code": "ecc_gostdsa_verify (const struct ecc_curve *ecc,\n\t\t  const mp_limb_t *pp, \n\t\t  size_t length, const uint8_t *digest,\n\t\t  const mp_limb_t *rp, const mp_limb_t *sp,\n\t\t  mp_limb_t *scratch)\n{\n#define hp (scratch)\n#define vp (scratch + ecc->p.size)\n#define z1 (scratch + 3*ecc->p.size)\n#define z2 (scratch + 4*ecc->p.size)\n#define P1 (scratch + 4*ecc->p.size)\n#define P2 (scratch)\n  if (! (ecdsa_in_range (ecc, rp)\n\t && ecdsa_in_range (ecc, sp)))\n    return 0;\n  gost_hash (&ecc->q, hp, length, digest);\n  if (mpn_zero_p (hp, ecc->p.size))\n    mpn_add_1 (hp, hp, ecc->p.size, 1);\n  ecc->q.invert (&ecc->q, vp, hp, vp + ecc->p.size);\n  ecc_mod_mul (&ecc->q, z1, sp, vp, z1);\n  ecc_mod_mul (&ecc->q, z2, rp, vp, z2);\n  mpn_sub_n (z2, ecc->q.m, z2, ecc->p.size);\n  ecc->mul (ecc, P2, z2, pp, z2 + ecc->p.size);\n  ecc->mul_g (ecc, P1, z1, P1 + 3*ecc->p.size);\n  ecc->add_hhh (ecc, P1, P1, P2, P1 + 3*ecc->p.size);\n  ecc->h_to_a (ecc, 2, P2, P1, P1 + 3*ecc->p.size);\n  return (mpn_cmp (rp, P2, ecc->p.size) == 0);\n#undef P2\n#undef P1\n#undef z2\n#undef z1\n#undef hp\n#undef vp\n}", "target": 1}
{"code": "NOEXPORT unsigned __stdcall daemon_thread(void *arg) {\n    (void)arg; \n    tls_alloc(NULL, NULL, \"main\"); \n    main_init();\n    SetEvent(main_initialized); \n    while(main_configure(cmdline.config_file, NULL)) {\n        if(cmdline.config_file && *cmdline.config_file=='-')\n            cmdline.config_file=NULL; \n        unbind_ports(); \n        log_flush(LOG_MODE_ERROR); \n        PostMessage(hwnd, WM_INVALID_CONFIG, 0, 0); \n        WaitForSingleObject(config_ready, INFINITE);\n    }\n    PostMessage(hwnd, WM_VALID_CONFIG, 0, 0);\n    daemon_loop();\n    main_cleanup();\n    _endthreadex(0); \n    return 0;\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "mm_freelist(struct mm_master *mmalloc, struct mmtree *head)\n{\n\tstruct mm_share *mms, *next;\n\tfor (mms = RB_ROOT(head); mms; mms = next) {\n\t\tnext = RB_NEXT(mmtree, head, mms);\n\t\tRB_REMOVE(mmtree, head, mms);\n\t\tif (mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mmalloc, mms);\n\t}\n}", "target": 1}
{"code": "rdpdr_process(STREAM s)\n{\n\tuint32 handle;\n \tuint16 vmin;\n \tuint16 component;\n \tuint16 pakid;\n \tlogger(Protocol, Debug, \"rdpdr_process()\");\n\tin_uint16(s, component);\n\tin_uint16(s, pakid);\n\tif (component == RDPDR_CTYP_CORE)\n\t{\n\t\tswitch (pakid)\n\t\t{\n\t\t\tcase PAKID_CORE_DEVICE_IOREQUEST:\n\t\t\t\trdpdr_process_irp(s);\n\t\t\t\tbreak;\n\t\t\tcase PAKID_CORE_SERVER_ANNOUNCE:\n \t\t\t\tin_uint8s(s, 2);\t\n \t\t\t\tin_uint16_le(s, vmin);\t\n \t\t\t\tin_uint32_le(s, g_client_id);\t\n \t\t\t\tif (vmin < 0x000c)\n\t\t\t\t\tg_client_id = 0x815ed39d;\t\n\t\t\t\tg_epoch++;\n#if WITH_SCARD\n\t\t\t\tscard_release_all_contexts();\n#endif\n\t\t\t\trdpdr_send_client_announce_reply();\n\t\t\t\trdpdr_send_client_name_request();\n\t\t\t\tbreak;\n\t\t\tcase PAKID_CORE_CLIENTID_CONFIRM:\n\t\t\t\trdpdr_send_client_device_list_announce();\n\t\t\t\tbreak;\n\t\t\tcase PAKID_CORE_DEVICE_REPLY:\n\t\t\t\tin_uint32(s, handle);\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), server connected to resource %d\", handle);\n\t\t\t\tbreak;\n\t\t\tcase PAKID_CORE_SERVER_CAPABILITY:\n\t\t\t\trdpdr_send_client_capability_response();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), pakid 0x%x of component 0x%x\", pakid,\n\t\t\t\t       component);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (component == RDPDR_CTYP_PRN)\n\t{\n\t\tif (pakid == PAKID_PRN_CACHE_DATA)\n\t\t\tprintercache_process(s);\n\t}\n\telse\n\t\tlogger(Protocol, Warning, \"rdpdr_process(), unhandled component 0x%x\", component);\n}", "target": 1}
{"code": "local int construct(struct huffman *h, boost::int16_t *length, int n)\n{\n    int symbol;         \n    int len;            \n    int left;           \n\t boost::int16_t offs[MAXBITS+1];      \n    for (len = 0; len <= MAXBITS; len++)\n        h->count[len] = 0;\n    for (symbol = 0; symbol < n; symbol++)\n        (h->count[length[symbol]])++;   \n    if (h->count[0] == n)               \n        return 0;                       \n    left = 1;                           \n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;                     \n        left -= h->count[len];          \n        if (left < 0) return left;      \n    }                                   \n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + h->count[len];\n    for (symbol = 0; symbol < n; symbol++)\n        if (length[symbol] != 0)\n            h->symbol[offs[length[symbol]]++] = symbol;\n    return left;\n}", "target": 1}
{"code": "static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t  int fromlen, unsigned char *to, int tolen)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n \ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n \t\tswitch (pc->componentType) {\n \t\tcase 1:\n\t\t\tif (pc->lengthComponentIdent > 0)\n \t\t\t\tbreak;\n \t\tcase 2:\n \t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\ttolen -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n \t\t\tbreak;\n \t\tcase 5:\n \t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n \t\t\t\t\t\t    pc->lengthComponentIdent,\n \t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n \t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n \t}\n \tif (p > to + 1)\n \t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}", "target": 1}
{"code": "static void esp_do_dma(ESPState *s)\n{\n    uint32_t len;\n    int to_device;\n     len = s->dma_left;\n     if (s->do_cmd) {\n         trace_esp_do_dma(s->cmdlen, len);\n         s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);\n         return;\n     }\n        return;\n    }", "target": 1}
{"code": "int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tcm_id_priv = container_of(id, struct cm_id_private, id);\n\tif (smac != NULL)\n\t\tmemcpy(cm_id_priv->av.smac, smac, sizeof(cm_id_priv->av.smac));\n\tif (alt_smac != NULL)\n\t\tmemcpy(cm_id_priv->alt_av.smac, alt_smac,\n\t\t       sizeof(cm_id_priv->alt_av.smac));\n\treturn 0;\n}", "target": 1}
{"code": " static void numtostr(js_State *J, const char *fmt, int w, double n)\n {\n\tchar buf[32], *e;\n \tsprintf(buf, fmt, w, n);\n \te = strchr(buf, 'e');\n \tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}", "target": 1}
{"code": "fp_read(CBORDecoderObject *self, char *buf, const Py_ssize_t size)\n{\n    PyObject *obj, *size_obj;\n    char *data;\n    int ret = -1;\n    size_obj = PyLong_FromSsize_t(size);\n    if (size_obj) {\n        obj = PyObject_CallFunctionObjArgs(self->read, size_obj, NULL);\n        if (obj) {\n            assert(PyBytes_CheckExact(obj));\n            if (PyBytes_GET_SIZE(obj) == (Py_ssize_t) size) {\n                data = PyBytes_AS_STRING(obj);\n                memcpy(buf, data, size);\n                ret = 0;\n            } else {\n                PyErr_Format(\n                    _CBOR2_CBORDecodeEOF,\n                    \"premature end of stream (expected to read %zd bytes, \"\n                    \"got %zd instead)\", size, PyBytes_GET_SIZE(obj));\n            }\n            Py_DECREF(obj);\n        }\n        Py_DECREF(size_obj);\n    }\n    return ret;\n}", "target": 1}
{"code": "static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint result = 0;\n\tif (!priv->comm_is_ok)\n\t\treturn -EIO;\n\tusb_clear_halt(serial->dev, 0x81);\n\tusb_clear_halt(serial->dev, 0x02);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->bytes_in = 0;\n\tpriv->bytes_out = 0;\n\tpriv->cmd_count = 0;\n\tpriv->rx_flags = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tcypress_send(port);\n\tif (tty)\n\t\tcypress_set_termios(tty, port, &priv->tmp_termios);\n\tif (!port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"%s - interrupt_in_urb is empty!\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n\tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n\t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n\t\tport->interrupt_in_urb->transfer_buffer,\n\t\tport->interrupt_in_urb->transfer_buffer_length,\n\t\tcypress_read_int_callback, port, priv->read_urb_interval);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tcypress_set_dead(port);\n\t}\n\treturn result;\n} ", "target": 1}
{"code": "rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\trs_filter_graph_helper(str, filter);\n\tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n\t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\tg_string_free(str, TRUE);\n}", "target": 1}
{"code": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if (length>0) {\n        buffer=malloc((uint64_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "target": 1}
{"code": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}", "target": 1}
{"code": "  void OnReadAllMetadata(\n      const SessionStore::SessionInfo& session_info,\n      SessionStore::FactoryCompletionCallback callback,\n      std::unique_ptr<ModelTypeStore> store,\n       std::unique_ptr<ModelTypeStore::RecordList> record_list,\n       const base::Optional<syncer::ModelError>& error,\n       std::unique_ptr<syncer::MetadataBatch> metadata_batch) {\n     if (error) {\n       std::move(callback).Run(error, nullptr,\n                               nullptr);\n      return;\n    }\n    std::map<std::string, sync_pb::SessionSpecifics> initial_data;\n    for (ModelTypeStore::Record& record : *record_list) {\n      const std::string& storage_key = record.id;\n      SessionSpecifics specifics;\n      if (storage_key.empty() ||\n          !specifics.ParseFromString(std::move(record.value))) {\n        DVLOG(1) << \"Ignoring corrupt database entry with key: \" << storage_key;\n        continue;\n      }\n      initial_data[storage_key].Swap(&specifics);\n    }\n    auto session_store = std::make_unique<SessionStore>(\n        sessions_client_, session_info, std::move(store),\n        std::move(initial_data), metadata_batch->GetAllMetadata(),\n        restored_foreign_tab_callback_);\n    std::move(callback).Run(base::nullopt, std::move(session_store),\n                            std::move(metadata_batch));\n  }", "target": 1}
{"code": "void CharCodeToUnicode::addMapping(CharCode code, char *uStr, int n,\n\t\t\t\t   int offset) {\n  CharCode oldLen, i;\n  Unicode u;\n  char uHex[5];\n  int j;\n  if (code >= mapLen) {\n    oldLen = mapLen;\n    mapLen = (code + 256) & ~255;\n    map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode));\n    for (i = oldLen; i < mapLen; ++i) {\n      map[i] = 0;\n    }\n  }\n  if (n <= 4) {\n    if (sscanf(uStr, \"%x\", &u) != 1) {\n      error(-1, \"Illegal entry in ToUnicode CMap\");\n      return;\n    }\n    map[code] = u + offset;\n  } else {\n    if (sMapLen >= sMapSize) {\n      sMapSize = sMapSize + 16;\n      sMap = (CharCodeToUnicodeString *)\n\t       greallocn(sMap, sMapSize, sizeof(CharCodeToUnicodeString));\n    }\n    map[code] = 0;\n    sMap[sMapLen].c = code;\n    sMap[sMapLen].len = n / 4;\n    for (j = 0; j < sMap[sMapLen].len && j < maxUnicodeString; ++j) {\n      strncpy(uHex, uStr + j*4, 4);\n      uHex[4] = '\\0';\n      if (sscanf(uHex, \"%x\", &sMap[sMapLen].u[j]) != 1) {\n\terror(-1, \"Illegal entry in ToUnicode CMap\");\n      }\n    }\n    sMap[sMapLen].u[sMap[sMapLen].len - 1] += offset;\n    ++sMapLen;\n  }\n}", "target": 1}
{"code": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\t\t\t\tdiFree(inode);\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}", "target": 1}
{"code": "find_entry2modify(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, 0 ) );\n}", "target": 1}
{"code": "void unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma) {\n\t\tvma->anon_vma->degree--;\n\t\tvma->anon_vma = NULL;\n\t}\n\tunlock_anon_vma_root(root);\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}", "target": 1}
{"code": "rpl_daoack_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length)\n{\n        const struct nd_rpl_daoack *daoack = (const struct nd_rpl_daoack *)bp;\n        const char *dagid_str = \"<elided>\";\n        ND_TCHECK2(*daoack, ND_RPL_DAOACK_MIN_LEN);\n        if (length < ND_RPL_DAOACK_MIN_LEN)\n        \tgoto tooshort;\n        bp += ND_RPL_DAOACK_MIN_LEN;\n        length -= ND_RPL_DAOACK_MIN_LEN;\n        if(RPL_DAOACK_D(daoack->rpl_flags)) {\n                ND_TCHECK2(daoack->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, daoack->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,status:%u]\",\n                  dagid_str,\n                  daoack->rpl_daoseq,\n                  daoack->rpl_instanceid,\n                  daoack->rpl_status));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|dao-truncated]\"));\n\treturn;\ntooshort:\n\tND_PRINT((ndo,\" [|dao-length too short]\"));\n\treturn;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                SpaceToBatchNDContext* op_context) {\n  TfLiteIntArray* input_size = op_context->input->dims;\n  const int32* block_shape = GetTensorData<int32>(op_context->block_shape);\n  const int32* paddings_data = GetTensorData<int32>(op_context->paddings);\n  int spatial_dims_num = input_size->size - 2;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);\n  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->paddings), 2);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[1], 2);\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);\n  int output_batch_size = input_size->data[0];\n  for (int dim = 0; dim < spatial_dims_num; ++dim) {\n    int final_dim_size = (input_size->data[dim + 1] + paddings_data[dim * 2] +\n                          paddings_data[dim * 2 + 1]);\n    TF_LITE_ENSURE_EQ(context, final_dim_size % block_shape[dim], 0);\n    output_size->data[dim + 1] = final_dim_size / block_shape[dim];\n    output_batch_size *= block_shape[dim];\n  }\n  output_size->data[0] = output_batch_size;\n  output_size->data[input_size->size - 1] =\n      input_size->data[input_size->size - 1];\n  return context->ResizeTensor(context, op_context->output, output_size);\n}", "target": 1}
{"code": "mailimap_mailbox_data_status_free(struct mailimap_mailbox_data_status * info)\n{\n  mailimap_mailbox_free(info->st_mailbox);\n  clist_foreach(info->st_info_list, (clist_func) mailimap_status_info_free,\n\t\t NULL);\n  clist_free(info->st_info_list);\n  free(info);\n}", "target": 1}
{"code": "static char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n    if (size)\n      *size = 0;\n    if (is_stream)\n      *is_stream = 0;\n    start = ftell(fp);\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n    if (!entry)\n      return NULL;\n    fseek(fp, entry->offset, SEEK_SET);\n    obj_sz = 0;    \n    total_sz = 0;  \n    n_blks = 1;\n    data = malloc(blk_sz * n_blks);\n    memset(data, 0, blk_sz * n_blks);\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n        *(data + total_sz) = '\\0';\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (void *)strstr(data + search, \"endobj\") - (void *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n    if (size)\n      *size = obj_sz;\n    if (is_stream)\n      *is_stream = stream;\n    return data;\n}", "target": 1}
{"code": "error(int n, ...)\n{\nint ec;\nmacroexe *me;\nistackstr *fe;\nva_list ap;\nva_start(ap, n);\nif (n > error_maxerror)\n  {\n  (void)fprintf(stderr, \"** Unknown error number %d\\n\", n);\n  ec = ec_disaster;\n  }\nelse\n  {\n  ec = error_data[n].ec;\n  if (ec == ec_warning)\n    {\n    if (suppress_warnings) return;\n    (void)fprintf(stderr, \"** Warning: \");\n    }\n  else if (ec > ec_warning)\n    (void)fprintf(stderr, \"** Error: \");\n  (void)vfprintf(stderr, error_data[n].text, ap);\n  (void)fprintf(stderr, \"\\n\");\n  }\nva_end(ap);\nme = macrocurrent;\nfe = istack;\nif (from_type_ptr < 0) (void)fprintf(stderr, \"   Detected near end of file\\n\");\nelse for (int i = from_type_ptr; i >= 0; i--)\n  {\n  if (from_type[i] == FROM_MACRO)\n    {\n    const char *eof = (i == 0)? \" at end of input\" : \"\";\n    (void)fprintf(stderr, \"   Processing macro %s%s\\n\", me->macro->name, eof);\n    me = me->prev;\n    }\n  else\n    {\n    if (fe != NULL)\n      {\n      if (fe->linenumber > 0) \n        (void)fprintf(stderr, \"   Detected near line %d of %s\\n\",\n          fe->linenumber, fe->filename);\n      fe = fe->prev;\n      }\n    else\n      {\n      (void)fprintf(stderr, \"   Detected near end of file\\n\"); \n      }\n    }\n  }\nif (ec == ec_warning)\n  {\n  warning_count++;\n  if (warning_count > 40)\n    {\n    (void)fprintf(stderr, \"** Too many warnings - subsequent ones suppressed\\n\");\n    suppress_warnings = TRUE;\n    }\n  }\nelse if (ec > ec_warning)\n  {\n  return_code = EXIT_FAILURE;\n  error_count++;\n  if (error_count > 40)\n    {\n    (void)fprintf(stderr, \"** Too many errors\\n\");\n    ec = ec_failed;\n    }\n  }\nif (ec >= ec_failed)\n  {\n  (void)fprintf(stderr, \"** xfpt abandoned\\n\");\n  suppress_warnings = TRUE;  \n  exit(EXIT_FAILURE);\n  }\n(void)fprintf(stderr, \"\\n\");   \n}", "target": 1}
{"code": "get_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\treturn &context->ibucontext;\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\nerror_fail_uar_alloc:\n\tkfree(context);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "snmp_api_replace_oid(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  while(oid[i] != ((uint32_t)-1)) {\n    varbind->oid[i] = oid[i];\n    i++;\n  }\n  varbind->oid[i] = ((uint32_t)-1);\n}", "target": 1}
{"code": "bittok2str_internal(register const struct tok *lp, register const char *fmt,\n\t   register u_int v, const char *sep)\n{\n        static char buf[256]; \n        int buflen=0;\n        register u_int rotbit; \n        register u_int tokval;\n        const char * sepstr = \"\";\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   \n            rotbit=1;\n            while (rotbit != 0) {\n\t\tif (tokval == (v&rotbit)) {\n                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, \"%s%s\",\n                                     sepstr, lp->s);\n                    sepstr = sep;\n                    break;\n                }\n                rotbit=rotbit<<1; \n            }\n            lp++;\n\t}\n        if (buflen == 0)\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}", "target": 1}
{"code": "static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tremain = dp->logicalSize - dp->pos;\n\tif (remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif (remain == 0) {\n\t\t\treturn EOF;\n\t\t}\n\t\trlen = remain;\n\t}\n\tmemcpy(buf, (void *) ((char *) dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "plan_a (char const *filename)\n{\n  char const *s;\n  char const *lim;\n  char const **ptr;\n  char *buffer;\n  lin iline;\n  size_t size = instat.st_size;\n  if (! (size == instat.st_size\n\t && (buffer = malloc (size ? size : (size_t) 1))))\n    return false;\n  if (size)\n     {\n       if (S_ISREG (instat.st_mode))\n         {\n\t  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);\n \t  size_t buffered = 0, n;\n \t  if (ifd < 0)\n \t    pfatal (\"can't open file %s\", quotearg (filename));\n\t\t  size = buffered;\n\t\t  break;\n\t\t}\n\t      if (n == (size_t) -1)\n\t\t{\n\t\t  close (ifd);\n\t\t  free (buffer);\n\t\t  return false;\n\t\t}\n\t      buffered += n;\n\t    }\n\t  if (close (ifd) != 0)\n\t    read_fatal ();\n\t}", "target": 1}
{"code": "convert(\n    Imaging imOut, Imaging imIn, const char *mode, ImagingPalette palette, int dither) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (!imIn) {\n        return (Imaging)ImagingError_ModeError();\n    }\n    if (!mode) {\n        if (!imIn->palette) {\n            return (Imaging)ImagingError_ModeError();\n        }\n        mode = imIn->palette->mode;\n    } else {\n        if (!strcmp(imIn->mode, mode)) {\n            return ImagingCopy2(imOut, imIn);\n        }\n    }\n    if (strcmp(imIn->mode, \"P\") == 0 || strcmp(imIn->mode, \"PA\") == 0) {\n        return frompalette(imOut, imIn, mode);\n    }\n    if (strcmp(mode, \"P\") == 0 || strcmp(mode, \"PA\") == 0) {\n        return topalette(imOut, imIn, mode, palette, dither);\n    }\n    if (dither && strcmp(mode, \"1\") == 0) {\n        return tobilevel(imOut, imIn, dither);\n    }\n    convert = NULL;\n    for (y = 0; converters[y].from; y++) {\n        if (!strcmp(imIn->mode, converters[y].from) &&\n            !strcmp(mode, converters[y].to)) {\n            convert = converters[y].convert;\n            break;\n        }\n    }\n    if (!convert) {\n#ifdef notdef\n        return (Imaging)ImagingError_ValueError(\"conversion not supported\");\n#else\n        static char buf[100];\n        sprintf(buf, \"conversion from %.10s to %.10s not supported\", imIn->mode, mode);\n        return (Imaging)ImagingError_ValueError(buf);\n#endif\n    }\n    imOut = ImagingNew2Dirty(mode, imOut, imIn);\n    if (!imOut) {\n        return NULL;\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imOut;\n}", "target": 1}
{"code": "im_vips2dz( IMAGE *in, const char *filename )\n{\n\tchar *p, *q;\n\tchar name[FILENAME_MAX];\n\tchar mode[FILENAME_MAX];\n\tchar buf[FILENAME_MAX];\n\tint i;\n\tVipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; \n\tchar *suffix = \".jpeg\";\n\tint overlap = 0;\n\tint tile_size = 256;\n\tVipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; \n\tgboolean centre = FALSE;\n\tVipsAngle angle = VIPS_ANGLE_D0; \n\tim_strncpy( name, filename, FILENAME_MAX ); \n\tif( (p = strchr( name, ':' )) ) {\n\t\t*p = '\\0';\n\t\tim_strncpy( mode, p + 1, FILENAME_MAX ); \n\t}\n\tstrcpy( buf, mode ); \n\tp = &buf[0];\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 ) \n\t\t\treturn( -1 );\n\t\tlayout = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) \n\t\tsuffix = g_strdup( q );\n\tif( (q = im_getnextoption( &p )) ) \n\t\toverlap = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) \n\t\ttile_size = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tdepth = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( im_isprefix( \"cen\", q ) ) \n\t\t\tcentre = TRUE;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_ANGLE, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tangle = i;\n\t}\n\tif( vips_dzsave( in, name,\n\t\t\"layout\", layout,\n\t\t\"suffix\", suffix,\n\t\t\"overlap\", overlap,\n\t\t\"tile_size\", tile_size,\n\t\t\"depth\", depth,\n\t\t\"centre\", centre,\n\t\t\"angle\", angle,\n\t\tNULL ) )\n\t\treturn( -1 );\n\treturn( 0 );\n}", "target": 1}
{"code": "static inline void tss_invalidate_io_bitmap(struct tss_struct *tss)\n{\n\ttss->x86_tss.io_bitmap_base = IO_BITMAP_OFFSET_INVALID;\n}", "target": 1}
{"code": "GF_Err chnl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->layout.stream_structure = gf_bs_read_u8(bs);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.definedLayout = gf_bs_read_u8(bs);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 remain = (u32) ptr->size;\n\t\t\tif (ptr->layout.stream_structure & 2) remain--;\n\t\t\tptr->layout.channels_count = 0;\n\t\t\twhile (remain) {\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].position = gf_bs_read_u8(bs);\n\t\t\t\tremain--;\n\t\t\t\tif (ptr->layout.layouts[ptr->layout.channels_count].position == 126) {\n\t\t\t\t\tISOM_DECREASE_SIZE(s, 3)\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].azimuth = gf_bs_read_int(bs, 16);\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].elevation = gf_bs_read_int(bs, 8);\n\t\t\t\t\tremain-=3;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(s, 8)\n\t\t\tptr->layout.omittedChannelsMap = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.object_count = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static struct kobject *cdev_get(struct cdev *p)\n{\n\tstruct module *owner = p->owner;\n\tstruct kobject *kobj;\n\tif (owner && !try_module_get(owner))\n\t\treturn NULL;\n\tkobj = kobject_get(&p->kobj);\n\tif (!kobj)\n\t\tmodule_put(owner);\n\treturn kobj;\n}", "target": 1}
{"code": "static int date_from_ISO8601 (const char *text, time_t * value) {\n   struct tm tm;\n   int n;\n   int i;\n   char buf[30];\n\tif (strchr (text, '-')) {\n\t\tchar *p = (char *) text, *p2 = buf;\n\t\twhile (p && *p) {\n\t\t\tif (*p != '-') {\n\t\t\t\t*p2 = *p;\n\t\t\t\tp2++;\n\t\t\t\tif (p2-buf >= sizeof(buf)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\t\ttext = buf;\n\t}\n   tm.tm_isdst = -1;\n#define XMLRPC_IS_NUMBER(x) if (x < '0' || x > '9') return -1;\n   n = 1000;\n   tm.tm_year = 0;\n   for(i = 0; i < 4; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_year += (text[i]-'0')*n;\n      n /= 10;\n   }\n   n = 10;\n   tm.tm_mon = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_mon += (text[i+4]-'0')*n;\n      n /= 10;\n   }\n   tm.tm_mon --;\n   n = 10;\n   tm.tm_mday = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_mday += (text[i+6]-'0')*n;\n      n /= 10;\n   }\n   n = 10;\n   tm.tm_hour = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_hour += (text[i+9]-'0')*n;\n      n /= 10;\n   }\n   n = 10;\n   tm.tm_min = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_min += (text[i+12]-'0')*n;\n      n /= 10;\n   }\n   n = 10;\n   tm.tm_sec = 0;\n   for(i = 0; i < 2; i++) {\n      XMLRPC_IS_NUMBER(text[i])\n      tm.tm_sec += (text[i+15]-'0')*n;\n      n /= 10;\n   }\n   tm.tm_year -= 1900;\n   *value = mkgmtime(&tm);\n   return 0;\n}", "target": 1}
{"code": "Pl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                initializeVector();\n            }\n            else\n\t    {\n\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    getNext()->write(this->outbuf, bytes);\n    this->offset = 0;\n}", "target": 1}
{"code": "avp_find(struct l2tp_avp *avp, const u_char *pkt, int pktlen,\n    uint16_t vendor_id, uint16_t attr_type, int fill_data)\n{\n\tint avpsz;\n\twhile (pktlen >= 6 &&\n\t    (avpsz = avp_enum(avp, pkt, pktlen, fill_data)) > 0) {\n\t\tif (avp->vendor_id != vendor_id || avp->attr_type != attr_type) {\n\t\t\tif (avpsz < 6)\n\t\t\t\treturn NULL;\n\t\t\tpkt += avpsz;\n\t\t\tpktlen -= avpsz;\n\t\t\tcontinue;\n\t\t}\n\t\treturn avp;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "void check_system_chunk(struct btrfs_trans_handle *trans, u64 type)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_space_info *info;\n\tu64 left;\n\tu64 thresh;\n\tint ret = 0;\n\tu64 num_devs;\n\tlockdep_assert_held(&fs_info->chunk_mutex);\n\tinfo = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_SYSTEM);\nagain:\n\tspin_lock(&info->lock);\n\tleft = info->total_bytes - btrfs_space_info_used(info, true);\n\tspin_unlock(&info->lock);\n\tnum_devs = get_profile_num_devs(fs_info, type);\n\tthresh = btrfs_calc_metadata_size(fs_info, num_devs) +\n\t\tbtrfs_calc_insert_metadata_size(fs_info, 1);\n\tif (left < thresh && btrfs_test_opt(fs_info, ENOSPC_DEBUG)) {\n\t\tbtrfs_info(fs_info, \"left=%llu, need=%llu, flags=%llu\",\n\t\t\t   left, thresh, type);\n\t\tbtrfs_dump_space_info(fs_info, info, 0, 0);\n\t}\n\tif (left < thresh) {\n\t\tu64 flags = btrfs_system_alloc_profile(fs_info);\n\t\tu64 reserved = atomic64_read(&cur_trans->chunk_bytes_reserved);\n\t\tif (reserved > trans->chunk_bytes_reserved) {\n\t\t\tconst u64 min_needed = reserved - thresh;\n\t\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\t\twait_event(cur_trans->chunk_reserve_wait,\n\t\t\t   atomic64_read(&cur_trans->chunk_bytes_reserved) <=\n\t\t\t   min_needed);\n\t\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\t\tgoto again;\n\t\t}\n\t\tret = btrfs_alloc_chunk(trans, flags);\n\t}\n\tif (!ret) {\n\t\tret = btrfs_block_rsv_add(fs_info->chunk_root,\n\t\t\t\t\t  &fs_info->chunk_block_rsv,\n\t\t\t\t\t  thresh, BTRFS_RESERVE_NO_FLUSH);\n\t\tif (!ret) {\n\t\t\tatomic64_add(thresh, &cur_trans->chunk_bytes_reserved);\n\t\t\ttrans->chunk_bytes_reserved += thresh;\n\t\t}\n\t}\n}", "target": 1}
{"code": "smb_fdata(netdissect_options *ndo,\n          const u_char *buf, const char *fmt, const u_char *maxbuf,\n          int unicodestr)\n{\n    static int depth = 0;\n    char s[128];\n    char *p;\n    while (*fmt) {\n\tswitch (*fmt) {\n\tcase '*':\n\t    fmt++;\n \t    while (buf < maxbuf) {\n \t\tconst u_char *buf2;\n \t\tdepth++;\n\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);\n \t\tdepth--;\n \t\tif (buf2 == NULL)\n \t\t    return(NULL);\n\t\tif (buf2 == buf)\n\t\t    return(buf);\n\t\tbuf = buf2;\n\t    }\n\t    return(buf);\n\tcase '|':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    break;\n\tcase '%':\n\t    fmt++;\n\t    buf = maxbuf;\n\t    break;\n\tcase '#':\n\t    fmt++;\n\t    return(buf);\n\t    break;\n\tcase '[':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    memset(s, 0, sizeof(s));\n\t    p = strchr(fmt, ']');\n\t    if ((size_t)(p - fmt + 1) > sizeof(s)) {\n\t\treturn(buf);\n\t    }\n\t    strncpy(s, fmt, p - fmt);\n\t    s[p - fmt] = '\\0';\n\t    fmt = p + 1;\n\t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);\n\t    if (buf == NULL)\n\t\treturn(NULL);\n\t    break;\n\tdefault:\n\t    ND_PRINT((ndo, \"%c\", *fmt));\n\t    fmt++;\n\t    break;\n\t}\n    }\n    if (!depth && buf < maxbuf) {\n\tsize_t len = PTR_DIFF(maxbuf, buf);\n\tND_PRINT((ndo, \"Data: (%lu bytes)\\n\", (unsigned long)len));\n\tsmb_print_data(ndo, buf, len);\n\treturn(buf + len);\n    }\n    return(buf);\n}", "target": 1}
{"code": "static void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf) {\n\tsize_t i, j, k;\n\tRBinDwarfDIE *dies;\n\tRBinDwarfAttrValue *values;\n\tif (!inf || !f) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < inf->length; i++) {\n\t\tfprintf (f, \"  Compilation Unit @ offset 0x%\"PFMT64x\":\\n\", inf->comp_units [i].offset);\n\t\tfprintf (f, \"   Length:        0x%x\\n\", inf->comp_units [i].hdr.length);\n\t\tfprintf (f, \"   Version:       %d\\n\", inf->comp_units [i].hdr.version);\n\t\tfprintf (f, \"   Abbrev Offset: 0x%x\\n\", inf->comp_units [i].hdr.abbrev_offset);\n\t\tfprintf (f, \"   Pointer Size:  %d\\n\", inf->comp_units [i].hdr.pointer_size);\n\t\tdies = inf->comp_units[i].dies;\n\t\tfor (j = 0; j < inf->comp_units[i].length; j++) {\n\t\t\tfprintf (f, \"    Abbrev Number: %\"PFMT64u\" \", dies[j].abbrev_code);\n\t\t\tif (dies[j].tag && dies[j].tag <= DW_TAG_volatile_type &&\n\t\t\t\t       dwarf_tag_name_encodings[dies[j].tag]) {\n\t\t\t\tfprintf (f, \"(%s)\\n\", dwarf_tag_name_encodings[dies[j].tag]);\n\t\t\t} else {\n\t\t\t\tfprintf (f, \"(Unknown abbrev tag)\\n\");\n\t\t\t}\n\t\t\tif (!dies[j].abbrev_code) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalues = dies[j].attr_values;\n\t\t\tfor (k = 0; k < dies[j].length; k++) {\n\t\t\t\tif (!values[k].name)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (values[k].name < DW_AT_vtable_elem_location &&\n\t\t\t\t\t\tdwarf_attr_encodings[values[k].name]) {\n\t\t\t\t\tfprintf (f, \"     %-18s : \", dwarf_attr_encodings[values[k].name]);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf (f, \"     TODO\\t\");\n\t\t\t\t}\n\t\t\t\tr_bin_dwarf_dump_attr_value (&values[k], f);\n\t\t\t\tfprintf (f, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\tstruct address_space *mapping = file->f_mapping;\n\tunsigned int offset, this_len;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\tret = buf->ops->confirm(pipe, buf);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tindex = sd->pos >> PAGE_CACHE_SHIFT;\n\toffset = sd->pos & ~PAGE_CACHE_MASK;\n\tthis_len = sd->len;\n\tif (this_len + offset > PAGE_CACHE_SIZE)\n\t\tthis_len = PAGE_CACHE_SIZE - offset;\nfind_page:\n\tpage = find_lock_page(mapping, index);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tpage = page_cache_alloc_cold(mapping);\n\t\tif (unlikely(!page))\n\t\t\tgoto out_ret;\n\t\tret = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t}\n\tret = mapping->a_ops->prepare_write(file, page, offset, offset+this_len);\n\tif (unlikely(ret)) {\n\t\tloff_t isize = i_size_read(mapping->host);\n\t\tif (ret != AOP_TRUNCATED_PAGE)\n\t\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret == AOP_TRUNCATED_PAGE)\n\t\t\tgoto find_page;\n\t\tif (sd->pos + this_len > isize)\n\t\t\tvmtruncate(mapping->host, isize);\n\t\tgoto out_ret;\n\t}\n\tif (buf->page != page) {\n\t\tchar *src = buf->ops->map(pipe, buf, 1);\n\t\tchar *dst = kmap_atomic(page, KM_USER1);\n\t\tmemcpy(dst + offset, src + buf->offset, this_len);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(dst, KM_USER1);\n\t\tbuf->ops->unmap(pipe, buf, src);\n\t}\n\tret = mapping->a_ops->commit_write(file, page, offset, offset+this_len);\n\tif (ret) {\n\t\tif (ret == AOP_TRUNCATED_PAGE) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto find_page;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else\n\t\tret = this_len;\n\tmark_page_accessed(page);\nout:\n\tpage_cache_release(page);\n\tunlock_page(page);\nout_ret:\n\treturn ret;\n}", "target": 1}
{"code": "static int v2g_incoming_v2gtp(struct v2g_connection* conn) {\n    int rv;\n    rv = connection_read(conn, conn->buffer, V2GTP_HEADER_LENGTH);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    if (rv == 0)\n        return 1;\n    if (rv != V2GTP_HEADER_LENGTH) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) too short: expected %d, got %d\", V2GTP_HEADER_LENGTH, rv);\n        return -1;\n    }\n    rv = read_v2gtpHeader(conn->buffer, &conn->payload_len);\n    if (rv == -1) {\n        dlog(DLOG_LEVEL_ERROR, \"Invalid v2gtp header\");\n        return -1;\n    }\n    if (conn->payload_len + V2GTP_HEADER_LENGTH > DEFAULT_BUFFER_SIZE) {\n        dlog(DLOG_LEVEL_ERROR, \"payload too long: have %d, would need %d\", DEFAULT_BUFFER_SIZE,\n             conn->payload_len + V2GTP_HEADER_LENGTH);\n        return -1;\n    }\n    rv = connection_read(conn, &conn->buffer[V2GTP_HEADER_LENGTH], conn->payload_len);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    if (rv != conn->payload_len) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) too short: expected %d, got %d\", conn->payload_len, rv);\n        return -1;\n    }\n    conn->buffer_pos = V2GTP_HEADER_LENGTH;\n    conn->stream.size = conn->payload_len + V2GTP_HEADER_LENGTH;\n    return 0;\n}", "target": 1}
{"code": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif \n\ttrace_xfs_attr_leaf_clearflag(args);\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif \n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}", "target": 1}
{"code": "static void f2fs_put_super(struct super_block *sb)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tint i;\n\tf2fs_quota_off_umount(sb);\n\tmutex_lock(&sbi->umount_mutex);\n\tif (is_sbi_flag_set(sbi, SBI_IS_DIRTY) ||\n\t\t\t!is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG)) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\tf2fs_wait_discard_bios(sbi);\n\tif (f2fs_discard_en(sbi) && !sbi->discard_blks) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT | CP_TRIMMED,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\tf2fs_destroy_stats(sbi);\n\trelease_ino_entry(sbi, true);\n\tf2fs_leave_shrinker(sbi);\n\tmutex_unlock(&sbi->umount_mutex);\n\tf2fs_flush_merged_writes(sbi);\n\tiput(sbi->node_inode);\n\tiput(sbi->meta_inode);\n\tdestroy_node_manager(sbi);\n\tdestroy_segment_manager(sbi);\n\tkfree(sbi->ckpt);\n\tf2fs_unregister_sysfs(sbi);\n\tsb->s_fs_info = NULL;\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tkfree(sbi->raw_super);\n\tdestroy_device_list(sbi);\n\tmempool_destroy(sbi->write_io_dummy);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\tdestroy_percpu_info(sbi);\n\tfor (i = 0; i < NR_PAGE_TYPE; i++)\n\t\tkfree(sbi->write_io[i]);\n\tkfree(sbi);\n}", "target": 1}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "  virtual bool ms_verify_authorizer(Connection *con,\n\t\t\t\t    int peer_type,\n\t\t\t\t    int protocol,\n\t\t\t\t    ceph::bufferlist& authorizer,\n\t\t\t\t    ceph::bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid,\n\t\t\t\t    CryptoKey& session_key) { return false; }", "target": 1}
{"code": "WebGLObject::WebGLObject(WebGLRenderingContext* context)\n     : m_object(0)\n     , m_attachmentCount(0)\n     , m_deleted(false)\n{\n}", "target": 1}
{"code": "pdf_t *pdf_new(const char *name)\n{\n    const char *n;\n    pdf_t      *pdf;\n    pdf = calloc(1, sizeof(pdf_t));\n    if (name)\n    {\n        if ((n = strrchr(name, '/')))\n          ++n;\n        else\n          n = name;\n        pdf->name = malloc(strlen(n) + 1);\n        strcpy(pdf->name, n);\n    }\n    else \n    {\n        pdf->name = malloc(strlen(\"Unknown\") + 1);\n        strcpy(pdf->name, \"Unknown\");\n    }\n    return pdf;\n}", "target": 1}
{"code": "void CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = s;\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "bool format_go_output(const string& file_path) {\n  const string command = \"gofmt -w \" + file_path;\n  if (system(command.c_str()) == 0) {\n    return true;\n  }\n  fprintf(stderr, \"WARNING - Running '%s' failed.\\n\", command.c_str());\n  return false;\n}", "target": 1}
{"code": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}", "target": 1}
{"code": "static int inet_sk_reselect_saddr(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__be32 old_saddr = inet->inet_saddr;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\t__be32 new_saddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n\t\t\t      sk->sk_bound_dev_if, sk->sk_protocol,\n\t\t\t      inet->inet_sport, inet->inet_dport, sk, false);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\tsk_setup_caps(sk, &rt->dst);\n\tnew_saddr = rt->rt_src;\n\tif (new_saddr == old_saddr)\n\t\treturn 0;\n\tif (sysctl_ip_dynaddr > 1) {\n\t\tprintk(KERN_INFO \"%s(): shifting inet->saddr from %pI4 to %pI4\\n\",\n\t\t       __func__, &old_saddr, &new_saddr);\n\t}\n\tinet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\n\t__sk_prot_rehash(sk);\n\treturn 0;\n}", "target": 1}
{"code": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; \n  int restlen = srclen - chunks * chunklen; \n  int out_len = (chunks + 1) * endlen + srclen;\n  String ret(out_len, ReserveString);\n  char *dest = ret.bufferSlice().ptr;\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;\n  }\n  if (restlen) {\n    memcpy(q, p, restlen);\n    q += restlen;\n    memcpy(q, end, endlen);\n    q += endlen;\n  }\n  ret.setSize(q - dest);\n  return ret;\n}", "target": 1}
{"code": "crypt_pw_cmp(const char *userpwd, const char *dbpwd)\n{\n    int rc;\n    char *cp;\n    struct crypt_data data;\n    data.initialized = 0;\n    cp = crypt_r(userpwd, dbpwd, &data);\n    if (cp) {\n        rc = slapi_ct_memcmp(dbpwd, cp, strlen(dbpwd));\n    } else {\n        rc = -1;\n    }\n    return rc;\n}", "target": 1}
{"code": "static void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "int user_match(const struct key *key, const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}", "target": 1}
{"code": " xps_select_font_encoding(xps_font_t *font, int idx)\n {\n     byte *cmapdata, *entry;\n     int pid, eid;\n     if (idx < 0 || idx >= font->cmapsubcount)\n        return;\n     cmapdata = font->data + font->cmaptable;\n     entry = cmapdata + 4 + idx * 8;\n     pid = u16(entry + 0);\n     eid = u16(entry + 2);\n     font->cmapsubtable = font->cmaptable + u32(entry + 4);\n     font->usepua = (pid == 3 && eid == 0);\n }", "target": 1}
{"code": "rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n\tstruct netdev_desc *desc;\n\tint i;\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 3:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 4:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 5:\n\t\tnetif_stop_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 6:\n\t\tnetif_wake_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 7:\n\t\tprintk\n\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n\t\t     np->old_rx);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 8:\n\t\tprintk(\"TX ring:\\n\");\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tdesc = &np->tx_ring[i];\n\t\t\tprintk\n\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n\t\t\t     i,\n\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n\t\t\t     (u32)le64_to_cpu(desc->status),\n\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n\t\t\tprintk (\"\\n\");\n\t\t}\n\t\tprintk (\"\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {\n  Cursor c(buf.front());\n  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {\n    auto b = c.read<char>();\n    if (b == '\\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {\n      return i;\n    } else if (terminatorType_ != TerminatorType::NEWLINE &&\n               b == '\\r' && !c.isAtEnd() && c.read<char>() == '\\n') {\n      return i;\n    }\n  }\n  return -1;\n}", "target": 1}
{"code": "TEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *attrs = NULL;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tattrs = malloc(sizeof(TEE_Attribute) * attr_count);\n\tif (!attrs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n\t\t\t    attrs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\nout:\n\tfree(attrs);\n\treturn res;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }", "target": 1}
{"code": "int unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n        assert(f);\n        assert(ret);\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n        path_simplify(p, false);\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n                delete_trailing_chars(p, \"/\");\n                p = skip_leading_chars(p, \"/\");\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 1}
{"code": "static rsRetVal qAddDirect(qqueue_t *pThis, void* pUsr)\n{\n\tbatch_t singleBatch;\n\tbatch_obj_t batchObj;\n\tDEFiRet;\n\tASSERT(pThis != NULL);\n\tmemset(&batchObj, 0, sizeof(batch_obj_t));\n\tmemset(&singleBatch, 0, sizeof(batch_t));\n\tbatchObj.state = BATCH_STATE_RDY;\n\tbatchObj.pUsrp = (obj_t*) pUsr;\n\tbatchObj.bFilterOK = 1;\n\tsingleBatch.nElem = 1; \n\tsingleBatch.pElem = &batchObj;\n\tiRet = pThis->pConsumer(pThis->pUsr, &singleBatch, &pThis->bShutdownImmediate);\n\tobjDestruct(pUsr);\n\tRETiRet;\n}", "target": 1}
{"code": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\treturn -EIO;\n\t}\n\treturn brightness;\n}", "target": 1}
{"code": "jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong rem;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}", "target": 1}
{"code": "static void prekey_handler(const char *userid,\n\t\t\t   const uint8_t *key, size_t key_len,\n\t\t\t   uint16_t id, const char *clientid,\n\t\t\t   bool last, void *arg)\n{\n\tstruct session *sess;\n\tchar lclientid[64];\n\tint err;\n\toutput(\"prekey_handler: %zu bytes, user:%s[%u] -> %s\\n\",\n\t       key_len, userid, id, clientid);\n\terr = client_id_load(lclientid, sizeof(lclientid));\n\tif (err) {\n\t\tdebug(\"my clientid not set -- cannot store prekeys\\n\");\n\t\treturn;\n\t}\n\tsess = cryptobox_session_find(g_cryptobox, userid, clientid, lclientid);\n\tif (sess) {\n\t\toutput(\"prekey: session found\\n\");\n\t}\n\telse {\n\t\tinfo(\"conv: adding key to cryptobox for clientid=%s\\n\",\n\t\t     clientid);\n\t\terr = cryptobox_session_add_send(g_cryptobox, userid, clientid, lclientid,\n\t\t\t\t\t\t key, key_len);\n\t\tif (err) {\n\t\t\twarning(\"cryptobox_session_add_send failed (%m)\\n\",\n\t\t\t\terr);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void nft_lookup_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_lookup *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "ecc_ecdsa_sign (const struct ecc_curve *ecc,\n\t\tconst mp_limb_t *zp,\n\t\tconst mp_limb_t *kp,\n\t\tsize_t length, const uint8_t *digest,\n\t\tmp_limb_t *rp, mp_limb_t *sp,\n\t\tmp_limb_t *scratch)\n{\n#define P\t    scratch\n#define kinv\t    scratch\n#define hp\t    (scratch  + ecc->p.size) \n#define tp\t    (scratch + 2*ecc->p.size)\n  ecc->mul_g (ecc, P, kp, P + 3*ecc->p.size);\n  ecc->h_to_a (ecc, 2, rp, P, P + 3*ecc->p.size);\n  ecc->q.invert (&ecc->q, kinv, kp, tp);\n  ecc_hash (&ecc->q, hp, length, digest);\n  ecc_mod_mul (&ecc->q, tp, zp, rp, tp);\n  ecc_mod_add (&ecc->q, hp, hp, tp);\n  ecc_mod_mul (&ecc->q, tp, hp, kinv, tp);\n  mpn_copyi (sp, tp, ecc->p.size);\n#undef P\n#undef hp\n#undef kinv\n#undef tp\n}", "target": 1}
{"code": "TfLiteStatus SimpleOpEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = tflite::GetInput(context, node, 0);\n  const TfLiteTensor* input2 = tflite::GetInput(context, node, 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  int32_t* output_data = output->data.i32;\n  *output_data = *(input1->data.i32) + *(input2->data.i32);\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                               int bits, int row, int offset, int *minimum)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n  int16_t c[3] = {(int16_t)offset, (int16_t)offset, (int16_t)offset};\n  int col;\n  bit_state_t BS;\n  set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]);\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n      c[color] += get_huffman_diff(&BS, &HUF->tree);\n      if (c[color] < 0)\n      {\n        c_fix = 0;\n        if (c[color] < *minimum)\n          *minimum = c[color];\n      }\n      else\n      {\n        c_fix = c[color];\n      }\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] =\n            (uint16_t)c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = (uint8_t)c_fix;\n        break;\n      default:\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}", "target": 1}
{"code": "guestfs___first_line_of_file (guestfs_h *g, const char *filename)\n{\n  CLEANUP_FREE char **lines = NULL; \n  int64_t size;\n  char *ret;\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    return NULL;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return NULL;\n  }\n  lines = guestfs_head_n (g, 1, filename);\n  if (lines == NULL)\n    return NULL;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    return safe_strdup (g, \"\");\n  }\n  ret = lines[0];               \n  return ret;\n}", "target": 1}
{"code": "find_match_text(colnr_T startcol, int regstart, char_u *match_text)\n{\n    colnr_T col = startcol;\n    int\t    c1, c2;\n    int\t    len1, len2;\n    int\t    match;\n    for (;;)\n    {\n\tmatch = TRUE;\n\tlen2 = MB_CHAR2LEN(regstart); \n\tfor (len1 = 0; match_text[len1] != NUL; len1 += MB_CHAR2LEN(c1))\n\t{\n\t    c1 = PTR2CHAR(match_text + len1);\n\t    c2 = PTR2CHAR(rex.line + col + len2);\n\t    if (c1 != c2 && (!rex.reg_ic || MB_CASEFOLD(c1) != MB_CASEFOLD(c2)))\n\t    {\n\t\tmatch = FALSE;\n\t\tbreak;\n\t    }\n\t    len2 += MB_CHAR2LEN(c2);\n\t}\n\tif (match\n\t\t&& !(enc_utf8\n\t\t\t  && utf_iscomposing(PTR2CHAR(rex.line + col + len2))))\n\t{\n\t    cleanup_subexpr();\n\t    if (REG_MULTI)\n\t    {\n\t\trex.reg_startpos[0].lnum = rex.lnum;\n\t\trex.reg_startpos[0].col = col;\n\t\trex.reg_endpos[0].lnum = rex.lnum;\n\t\trex.reg_endpos[0].col = col + len2;\n\t    }\n\t    else\n\t    {\n\t\trex.reg_startp[0] = rex.line + col;\n\t\trex.reg_endp[0] = rex.line + col + len2;\n\t    }\n\t    return 1L;\n\t}\n\tcol += MB_CHAR2LEN(regstart); \n\tif (skip_to_start(regstart, &col) == FAIL)\n\t    break;\n    }\n    return 0L;\n}", "target": 1}
{"code": "static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n{\n\tuint64_t val = 0;\n\tuint16_t year = le32_to_cpu(timestamp->year);\n\tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n\tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n\tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n\tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n\tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n\tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n\tval |= ((uint64_t) year) << (6*8);\n\treturn val;\n}", "target": 1}
{"code": "static int bond_ipsec_add_sa(struct xfrm_state *xs)\n{\n\tstruct net_device *bond_dev = xs->xso.dev;\n\tstruct bonding *bond;\n\tstruct slave *slave;\n\tint err;\n\tif (!bond_dev)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\tbond = netdev_priv(bond_dev);\n\tslave = rcu_dereference(bond->curr_active_slave);\n\txs->xso.real_dev = slave->dev;\n\tbond->xs = xs;\n\tif (!(slave->dev->xfrmdev_ops\n\t      && slave->dev->xfrmdev_ops->xdo_dev_state_add)) {\n\t\tslave_warn(bond_dev, slave->dev, \"Slave does not support ipsec offload\\n\");\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\terr = slave->dev->xfrmdev_ops->xdo_dev_state_add(xs);\n\trcu_read_unlock();\n\treturn err;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_tensor = context->input(0);\n    const auto input_tensor_flat = input_tensor.flat<int32>();\n    const Tensor& input_splits = context->input(1);\n    const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();\n    TensorShape output_shape({input_splits.dim_size(0) - 1});\n    Tensor* output_tensor;\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n    auto output_tensor_flat = output_tensor->flat<tstring>();\n    int idx = 0;\n    for (int i = 1; i < input_splits_flat.size(); ++i) {\n      icu::UnicodeString unicode_string;\n      icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);\n      for (; idx < input_splits_flat(i); ++idx) {\n        int32 code_point = input_tensor_flat(idx);\n        if (!U_IS_UNICODE_CHAR(code_point)) {\n          if (error_options_.error_on_malformatting) {\n            context->CtxFailure(errors::InvalidArgument(\n                \"Code point is out of range for Unicode, or a noncharacter.\"));\n            return;\n          } else if (!error_options_.elide_replacement) {\n            code_point = error_options_.subst;\n          }\n        }\n        appendable_unicode_string.appendCodePoint(code_point);\n      }\n      tstring result;\n      Encode(encoding_, unicode_string, &result);\n      output_tensor_flat(i - 1) = std::move(result);\n    }\n  }", "target": 1}
{"code": "parse_notification_delta(xmlTextReaderPtr reader,\n    struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head *tmp;\n\tunsigned long serial;\n\tint error;\n\terror = delta_head_create(&tmp);\n\tif (error)\n\t\treturn error;\n\terror = parse_long(reader, RRDP_ATTR_SERIAL, &serial);\n\tif (error)\n\t\tgoto delta_destroy;\n\ttmp->serial = serial;\n\terror = parse_doc_data(reader, true, true, &tmp->doc_data);\n\tif (error)\n\t\tgoto delta_destroy;\n\terror = deltas_parsed_add(&ctx->deltas, &tmp);\n\tif (error)\n\t\tgoto delta_destroy;\n\treturn 0;\ndelta_destroy:\n\tdelta_head_destroy(tmp);\n\treturn error;\n}", "target": 1}
{"code": " int perf_config(config_fn_t fn, void *data)\n {\n \tint ret = 0, found = 0;\n\tchar *repo_config = NULL;\n \tconst char *home = NULL;\n\tif (config_exclusive_filename)\n\t\treturn perf_config_from_file(fn, config_exclusive_filename, data);\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\n\t\tret += perf_config_from_file(fn, perf_etc_perfconfig(),\n\t\t\t\t\t    data);\n\t\tfound += 1;\n\t}\n\thome = getenv(\"HOME\");\n\tif (perf_config_global() && home) {\n\t\tchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\n\t\tif (!access(user_config, R_OK)) {\n\t\t\tret += perf_config_from_file(fn, user_config, data);\n\t\t\tfound += 1;\n\t\t}\n \t\tfree(user_config);\n \t}\n\trepo_config = perf_pathdup(\"config\");\n\tif (!access(repo_config, R_OK)) {\n\t\tret += perf_config_from_file(fn, repo_config, data);\n\t\tfound += 1;\n\t}\n\tfree(repo_config);\n \tif (found == 0)\n \t\treturn -1;\n \treturn ret;\n}", "target": 1}
{"code": "static inline void ConvertLuvToXYZ(const double L,const double u,const double v,\n  double *X,double *Y,double *Z)\n{\n  assert(X != (double *) NULL);\n  assert(Y != (double *) NULL);\n  assert(Z != (double *) NULL);\n  if (L > (CIEK*CIEEpsilon))\n    *Y=(double) pow((L+16.0)/116.0,3.0);\n  else\n    *Y=L/CIEK;\n  *X=((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+\n    5.0*(*Y))/((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/\n    3.0)-(-1.0/3.0));\n  *Z=(*X*(((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-\n    5.0*(*Y);\n}", "target": 1}
{"code": "fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\n\tint ret;\n\tint sav_errno;\n\tif (fifo->name) {\n\t\tsav_errno = 0;\n\t\tif (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))\n\t\t\tfifo->created_fifo = true;\n\t\telse {\n\t\t\tsav_errno = errno;\n\t\t\tif (sav_errno != EEXIST)\n\t\t\t\tlog_message(LOG_INFO, \"Unable to create %snotify fifo %s\", type, fifo->name);\n\t\t}\n\t\tif (!sav_errno || sav_errno == EEXIST) {\n\t\t\tif (fifo->script)\n\t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n\t\t\t\tlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\n\t\t\t\tif (fifo->created_fifo) {\n\t\t\t\t\tunlink(fifo->name);\n\t\t\t\t\tfifo->created_fifo = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fifo->fd == -1) {\n\t\t\tFREE(fifo->name);\n\t\t\tfifo->name = NULL;\n\t\t}\n\t}\n}", "target": 1}
{"code": "spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                return;\n            }\n            iterator = it->second;\n        }\n        iterator->messages[messageId] = message;\n        if (!iterator->triggered) {\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }", "target": 1}
{"code": "struct edid *drm_load_edid_firmware(struct drm_connector *connector)\n{\n\tconst char *connector_name = connector->name;\n\tchar *edidname, *last, *colon, *fwstr, *edidstr, *fallback = NULL;\n\tstruct edid *edid;\n\tif (edid_firmware[0] == '\\0')\n\t\treturn ERR_PTR(-ENOENT);\n \tfwstr = kstrdup(edid_firmware, GFP_KERNEL);\n \tedidstr = fwstr;\n \twhile ((edidname = strsep(&edidstr, \",\"))) {\n\t\t\tif (strncmp(connector_name, edidname, colon - edidname))\n\t\t\t\tcontinue;\n\t\t\tedidname = colon + 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (*edidname != '\\0') \n\t\t\tfallback = edidname;\n\t}", "target": 1}
{"code": "static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    *base64,\n    message[MagickPathExtent];\n  const MagickInfo\n    *magick_info;\n  Image\n    *write_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  size_t\n    blob_length,\n    encode_length;\n  unsigned char\n    *blob;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  write_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(write_info,1,exception);\n  if (LocaleCompare(write_info->magick,\"INLINE\") == 0)\n    (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(write_info->magick,exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickMimeType(magick_info) == (const char *) NULL))\n    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n  (void) CopyMagickString(image->filename,write_info->filename,\n    MagickPathExtent);\n  blob_length=2048;\n  write_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (write_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      return(MagickTrue);\n    }\n  blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,\n    exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (blob == (unsigned char *) NULL)\n    return(MagickFalse);\n  encode_length=0;\n  base64=Base64Encode(blob,blob_length,&encode_length);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  if (base64 == (char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      base64=DestroyString(base64);\n      return(status);\n    }\n  (void) FormatLocaleString(message,MagickPathExtent,\"data:%s;base64,\",\n    GetMagickMimeType(magick_info));\n  (void) WriteBlobString(image,message);\n  (void) WriteBlobString(image,base64);\n  base64=DestroyString(base64);\n  return(MagickTrue);\n}", "target": 1}
{"code": "static int ghash_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n \tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n \tu8 *dst = dctx->buffer;\n \tif (dctx->bytes) {\n \t\tint n = min(srclen, dctx->bytes);\n \t\tu8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\t\twhile (n--)\n\t\t\t*pos++ ^= *src++;\n\t\tif (!dctx->bytes)\n\t\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t}\n\twhile (srclen >= GHASH_BLOCK_SIZE) {\n\t\tcrypto_xor(dst, src, GHASH_BLOCK_SIZE);\n\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t\tsrc += GHASH_BLOCK_SIZE;\n\t\tsrclen -= GHASH_BLOCK_SIZE;\n\t}\n\tif (srclen) {\n\t\tdctx->bytes = GHASH_BLOCK_SIZE - srclen;\n\t\twhile (srclen--)\n\t\t\t*dst++ ^= *src++;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "doc_data_init(struct doc_data *data)\n{\n\tdata->hash = NULL;\n\tdata->hash_len = 0;\n\tdata->uri = NULL;\n}", "target": 1}
{"code": "GF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu8 iv_size;\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tgf_bs_read_u8(bs); \n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); \n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 17);\n\tptr->key_info[0] = 0;\n\tptr->key_info[1] = 0;\n\tptr->key_info[2] = 0;\n\tptr->key_info[3] = iv_size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, ptr->key_info+4, 16);\n\tif (!iv_size && ptr->isProtected) {\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\tiv_size = ptr->key_info[20] = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);\n\t\tgf_bs_read_data(bs, ptr->key_info+21, iv_size);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, Cookie> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "mix_pool(byte *pool)\n{\n    char *hashbuf = pool + POOLSIZE;\n    char *p, *pend;\n    int i, n;\n    RMD160_CONTEXT md;\n    rmd160_init( &md );\n#if DIGESTLEN != 20\n#error must have a digest length of 20 for ripe-md-160\n#endif\n    pend = pool + POOLSIZE;\n    memcpy(hashbuf, pend - DIGESTLEN, DIGESTLEN );\n    memcpy(hashbuf+DIGESTLEN, pool, BLOCKLEN-DIGESTLEN);\n    rmd160_mixblock( &md, hashbuf);\n    memcpy(pool, hashbuf, DIGESTLEN);\n    p = pool;\n    for( n=1; n < POOLBLOCKS; n++ ) {\n\tmemcpy(hashbuf, p, DIGESTLEN );\n\tp += DIGESTLEN;\n\tif( p+DIGESTLEN+BLOCKLEN < pend )\n\t    memcpy(hashbuf+DIGESTLEN, p+DIGESTLEN, BLOCKLEN-DIGESTLEN);\n\telse {\n\t    char *pp = p+DIGESTLEN;\n\t    for(i=DIGESTLEN; i < BLOCKLEN; i++ ) {\n\t\tif( pp >= pend )\n\t\t    pp = pool;\n\t\thashbuf[i] = *pp++;\n\t    }\n\t}\n\trmd160_mixblock( &md, hashbuf);\n\tmemcpy(p, hashbuf, DIGESTLEN);\n    }\n    burn_stack (384); \n}", "target": 1}
{"code": "ext2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}", "target": 1}
{"code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n        if (ctxt) {\n               ctxt->options -= XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int hidp_setup_hid(struct hidp_session *session,\n\t\t\t\tstruct hidp_connadd_req *req)\n{\n\tstruct hid_device *hid;\n\tint err;\n\tsession->rd_data = kzalloc(req->rd_size, GFP_KERNEL);\n\tif (!session->rd_data)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {\n\t\terr = -EFAULT;\n\t\tgoto fault;\n\t}\n\tsession->rd_size = req->rd_size;\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\terr = PTR_ERR(hid);\n\t\tgoto fault;\n\t}\n\tsession->hid = hid;\n\thid->driver_data = session;\n\thid->bus     = BUS_BLUETOOTH;\n\thid->vendor  = req->vendor;\n\thid->product = req->product;\n\thid->version = req->version;\n\thid->country = req->country;\n\tstrncpy(hid->name, req->name, 128);\n\tsnprintf(hid->phys, sizeof(hid->phys), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->src);\n\tsnprintf(hid->uniq, sizeof(hid->uniq), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->dst);\n\thid->dev.parent = &session->conn->dev;\n\thid->ll_driver = &hidp_hid_driver;\n\thid->hid_get_raw_report = hidp_get_raw_report;\n\thid->hid_output_raw_report = hidp_output_raw_report;\n\tif (hid_ignore(hid)) {\n\t\thid_destroy_device(session->hid);\n\t\tsession->hid = NULL;\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\nfault:\n\tkfree(session->rd_data);\n\tsession->rd_data = NULL;\n\treturn err;\n}", "target": 1}
{"code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}", "target": 1}
{"code": "static void adpt_i2o_sys_shutdown(void)\n{\n\tadpt_hba *pHba, *pNext;\n\tstruct adpt_i2o_post_wait_data *p1, *old;\n\tprintk(KERN_INFO \"Shutting down Adaptec I2O controllers.\\n\");\n\tprintk(KERN_INFO \"   This could take a few minutes if there are many devices attached\\n\");\n\tfor (pHba = hba_chain; pHba; pHba = pNext) {\n\t\tpNext = pHba->next;\n\t\tadpt_i2o_delete_hba(pHba);\n\t}\n\tfor(p1 = adpt_post_wait_queue; p1;) {\n\t\told = p1;\n\t\tp1 = p1->next;\n\t\tkfree(old);\n\t}\n\tadpt_post_wait_queue = NULL;\n\tprintk(KERN_INFO \"Adaptec I2O controllers down.\\n\");\n}", "target": 1}
{"code": "static TEE_Result do_alloc_publickey(struct ecc_public_key *s, uint32_t type,\n\t\t\t\t     size_t size_bits __unused)\n{\n\tif (type != TEE_TYPE_ECDSA_PUBLIC_KEY &&\n\t    type != TEE_TYPE_ECDH_PUBLIC_KEY)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static int identity_count(void *v, const char *key, const char *val)\n{\n    int *count = v;\n    *count += strlen(key) * 3 + strlen(val) * 3 + 1;\n    return 1;\n}", "target": 1}
{"code": "process_bitmap_updates(STREAM s)\n {\n\tuint16 num_updates;\n \tuint16 left, top, right, bottom, width, height;\n\tuint16 cx, cy, bpp, Bpp, compress, bufsize, size;\n \tuint8 *data, *bmpdata;\n\tint i;\n \tlogger(Protocol, Debug, \"%s()\", __func__);\n\tin_uint16_le(s, num_updates);\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tin_uint16_le(s, left);\n\t\tin_uint16_le(s, top);\n\t\tin_uint16_le(s, right);\n\t\tin_uint16_le(s, bottom);\n\t\tin_uint16_le(s, width);\n\t\tin_uint16_le(s, height);\n\t\tin_uint16_le(s, bpp);\n\t\tBpp = (bpp + 7) / 8;\n\t\tin_uint16_le(s, compress);\n\t\tin_uint16_le(s, bufsize);\n\t\tcx = right - left + 1;\n\t\tcy = bottom - top + 1;\n\t\tlogger(Graphics, Debug,\n\t\t       \"process_bitmap_updates(), [%d,%d,%d,%d], [%d,%d], bpp=%d, compression=%d\",\n\t\t       left, top, right, bottom, width, height, Bpp, compress);\n\t\tif (!compress)\n\t\t{\n\t\t\tint y;\n\t\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\t\tfor (y = 0; y < height; y++)\n\t\t\t{\n\t\t\t\tin_uint8a(s, &bmpdata[(height - y - 1) * (width * Bpp)],\n\t\t\t\t\t  width * Bpp);\n\t\t\t}\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t\txfree(bmpdata);\n\t\t\tcontinue;\n\t\t}\n\t\tif (compress & 0x400)\n\t\t{\n\t\t\tsize = bufsize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin_uint8s(s, 2);\t\n\t\t\tin_uint16_le(s, size);\n\t\t\tin_uint8s(s, 4);\t\n\t\t}\n\t\tin_uint8p(s, data, size);\n \t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n \t\t{\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n \t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_bitmap_updates(), failed to decompress bitmap\");\n\t\t}\n \t\txfree(bmpdata);\n \t}\n }", "target": 1}
{"code": "absl::Status Ipv6Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET6);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv6 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tspin_unlock(&hb->lock);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\tbox = 0;\n\ttmpstream = 0;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n\t\tjas_stream_rewind(tmpstream);\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\treturn box;\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "MakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)\n{\n        char *filename = malloc(PATH_MAX + 1);\n        if (filename == NULL)\n            error(\"%s: malloc\", __func__);\n        if (Gflag != 0) {\n          struct tm *local_tm;\n          if ((local_tm = localtime(&Gflag_time)) == NULL) {\n                  error(\"%s: localtime\", __func__);\n          }\n          strftime(filename, PATH_MAX, orig_name, local_tm);\n        } else {\n          strncpy(filename, orig_name, PATH_MAX);\n        }\n\tif (cnt == 0 && max_chars == 0)\n\t\tstrncpy(buffer, filename, PATH_MAX + 1);\n\telse\n\t\tif (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)\n                  error(\"too many output files or filename is too long (> %d)\", PATH_MAX);\n        free(filename);\n}", "target": 1}
{"code": "GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (ptr->size) {\n\t\tGF_XtraTag *tag;\n\t\tu32 prop_type = 0;\n\t\tchar *data=NULL, *data2=NULL;\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 8)\n\t\ts32 tag_size = gf_bs_read_u32(bs);\n\t\tu32 name_size = gf_bs_read_u32(bs);\n\t\tif (tag_size < 8) return GF_ISOM_INVALID_FILE;\n\t\ttag_size -= 8;\n\t\tif ((tag_size>ptr->size) || (name_size>ptr->size)) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 10)\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)\n\t\tdata = gf_malloc(sizeof(char) * (name_size+1));\n\t\tgf_bs_read_data(bs, data, name_size);\n\t\tdata[name_size] = 0;\n\t\ttag_size-=name_size;\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+2));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;\n\t\tgf_list_add(ptr->tags, tag);\n\t\tif (tag_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] invalid tag size in Xtra !\\n\"));\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tret = key->type->instantiate(key, prep);\n\t\tif (ret == 0) {\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\t\t\t\t__key_link(key, _edit);\n\t\t\t}\n\t\t\tif (authkey)\n\t\t\t\tkey_revoke(authkey);\n\t\t\tif (prep->expiry != TIME_T_MAX) {\n\t\t\t\tkey->expiry = prep->expiry;\n\t\t\t\tkey_schedule_gc(prep->expiry + key_gc_delay);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret;\n}", "target": 1}
{"code": "TightDecoder::FilterGradient24(const rdr::U8 *inbuf,\n                               const PixelFormat& pf, PIXEL_T* outbuf,\n                               int stride, const Rect& r)\n{\n  int x, y, c;\n  rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    for (c = 0; c < 3; c++) {\n      pix[c] = inbuf[y*rectWidth*3+c] + prevRow[c];\n      thisRow[c] = pix[c];\n    }\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 0xff) {\n          est[c] = 0xff;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n        pix[c] = inbuf[(y*rectWidth+x)*3+c] + est[c];\n        thisRow[x*3+c] = pix[c];\n      }\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "bool GetURLRowForAutocompleteMatch(Profile* profile,\n                                   const AutocompleteMatch& match,\n                                   history::URLRow* url_row) {\n  DCHECK(url_row);\n  HistoryService* history_service =\n      profile->GetHistoryService(Profile::EXPLICIT_ACCESS);\n  if (!history_service)\n    return false;\n  history::URLDatabase* url_db = history_service->InMemoryDatabase();\n  return url_db && (url_db->GetRowForURL(match.destination_url, url_row) != 0);\n}", "target": 1}
{"code": "mm_make_entry(struct mm_master *mm, struct mmtree *head,\n    void *address, size_t size)\n{\n\tstruct mm_share *tmp, *tmp2;\n\tif (mm->mmalloc == NULL)\n\t\ttmp = xcalloc(1, sizeof(struct mm_share));\n\telse\n\t\ttmp = mm_xmalloc(mm->mmalloc, sizeof(struct mm_share));\n\ttmp->address = address;\n\ttmp->size = size;\n\ttmp2 = RB_INSERT(mmtree, head, tmp);\n\tif (tmp2 != NULL)\n\t\tfatal(\"mm_make_entry(%p): double address %p->%p(%zu)\",\n\t\t    mm, tmp2, address, size);\n\treturn (tmp);\n}", "target": 1}
{"code": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n \t\tconst int __user *, nodes,\n \t\tint __user *, status, int, flags)\n {\n\tconst struct cred *cred = current_cred(), *tcred;\n \tstruct task_struct *task;\n \tstruct mm_struct *mm;\n \tint err;\n\tnodemask_t task_nodes;\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n \t\trcu_read_unlock();\n \t\terr = -EPERM;\n \t\tgoto out;\n\t}\n\trcu_read_unlock();\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -EINVAL;\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\tmmput(mm);\n\treturn err;\nout:\n\tput_task_struct(task);\n\treturn err;\n}", "target": 1}
{"code": " void red_channel_pipes_add_type(RedChannel *channel, int pipe_item_type)\n {\n    RingItem *link;\n    RING_FOREACH(link, &channel->clients) {\n         red_channel_client_pipe_add_type(\n             SPICE_CONTAINEROF(link, RedChannelClient, channel_link),\n             pipe_item_type);\n    }\n}", "target": 1}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        DCHECK(attr != nullptr);\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 1}
{"code": " pvscsi_convert_sglist(PVSCSIRequest *r)\n {\n    int chunk_size;\n     uint64_t data_length = r->req.dataLen;\n     PVSCSISGState sg = r->sg;\n    while (data_length) {\n        while (!sg.resid) {\n             pvscsi_get_next_sg_elem(&sg);\n             trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                         r->sg.resid);\n         }\n        assert(data_length > 0);\n        chunk_size = MIN((unsigned) data_length, sg.resid);\n         if (chunk_size) {\n             qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n         }\n        sg.dataAddr += chunk_size;\n        data_length -= chunk_size;\n        sg.resid -= chunk_size;\n    }\n}", "target": 1}
{"code": "void gf_filter_pid_inst_del(GF_FilterPidInst *pidinst)\n{\n\tassert(pidinst);\n\tgf_filter_pid_inst_reset(pidinst);\n \tgf_fq_del(pidinst->packets, (gf_destruct_fun) pcki_del);\n\tgf_mx_del(pidinst->pck_mx);\n\tgf_list_del(pidinst->pck_reassembly);\n\tif (pidinst->props) {\n\t\tassert(pidinst->props->reference_count);\n\t\tif (safe_int_dec(&pidinst->props->reference_count) == 0) {\n\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_props_del(pidinst->props);\n\t\t}\n\t}\n\tgf_free(pidinst);\n}", "target": 1}
{"code": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\thash_len = digest_length(d);\n\t}\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\tpasswd2_sum = passwd1_sum + hash_len;\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\tif (ret < 0)\n\t\tgoto err;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, key, keylen) == 0)\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)\n\t\t\tret = 1;\n\t}\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\treturn ret;\n}", "target": 1}
{"code": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}", "target": 1}
{"code": "gst_vorbis_tag_add_coverart (GstTagList * tags, const gchar * img_data_base64,\n    gint base64_len)\n{\n  GstBuffer *img;\n  guchar *img_data;\n  gsize img_len;\n  guint save = 0;\n  gint state = 0;\n  if (base64_len < 2)\n    goto not_enough_data;\n  img_data = g_try_malloc0 (base64_len * 3 / 4);\n  if (img_data == NULL)\n    goto alloc_failed;\n  img_len = g_base64_decode_step (img_data_base64, base64_len, img_data,\n      &state, &save);\n  if (img_len == 0)\n    goto decode_failed;\n  img = gst_tag_image_data_to_image_buffer (img_data, img_len,\n      GST_TAG_IMAGE_TYPE_NONE);\n  if (img == NULL)\n    goto convert_failed;\n  gst_tag_list_add (tags, GST_TAG_MERGE_APPEND,\n      GST_TAG_PREVIEW_IMAGE, img, NULL);\n  gst_buffer_unref (img);\n  g_free (img_data);\n  return;\nnot_enough_data:\n  {\n    GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n    return;\n  }\nalloc_failed:\n  {\n    GST_WARNING (\"Couldn't allocate enough memory to decode COVERART tag\");\n    return;\n  }\ndecode_failed:\n  {\n    GST_WARNING (\"Couldn't decode bas64 image data from COVERART tag\");\n    g_free (img_data);\n    return;\n  }\nconvert_failed:\n  {\n    GST_WARNING (\"Couldn't extract image or image type from COVERART tag\");\n    g_free (img_data);\n    return;\n  }\n}", "target": 1}
{"code": "static void vgacon_restore_screen(struct vc_data *c)\n{\n\tc->vc_origin = c->vc_visible_origin;\n\tvgacon_scrollback_cur->save = 0;\n\tif (!vga_is_gfx && !vgacon_scrollback_cur->restore) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t    vga_vram_size : c->vc_screenbuf_size);\n\t\tvgacon_scrollback_cur->restore = 1;\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}", "target": 1}
{"code": "  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64 start, int64 limit) {\n      const int64 batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64 output_size_per_batch = grad_out->NumElements() / batch_size;\n      const int64 input_size_per_batch = grad_in.NumElements() / batch_size;\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n        const int64 output_start = start * output_size_per_batch;\n        const int64 output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64 index = input_start; index < input_end; index++) {\n          int64 grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64 cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n    const int64 batch_size = GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64 shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }", "target": 1}
{"code": "bool PDFDoc::setup(const GooString *ownerPassword, const GooString *userPassword) {\n  pdfdocLocker();\n  if (str->getLength() <= 0)\n  {\n    error(errSyntaxError, -1, \"Document stream is empty\");\n    return false;\n  }\n  str->setPos(0, -1);\n  if (str->getPos() < 0)\n  {\n    error(errSyntaxError, -1, \"Document base stream is not seekable\");\n    return false;\n  }\n  str->reset();\n  checkHeader();\n  bool wasReconstructed = false;\n  xref = new XRef(str, getStartXRef(), getMainXRefEntriesOffset(), &wasReconstructed);\n  if (!xref->isOk()) {\n    if (wasReconstructed) {\n      delete xref;\n      startXRefPos = -1;\n      xref = new XRef(str, getStartXRef(true), getMainXRefEntriesOffset(true), &wasReconstructed);\n    }\n    if (!xref->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read xref table\");\n      errCode = xref->getErrorCode();\n      return false;\n    }\n  }\n  if (!checkEncryption(ownerPassword, userPassword)) {\n    errCode = errEncrypted;\n    return false;\n  }\n  catalog = new Catalog(this);\n  if (catalog && !catalog->isOk()) {\n    if (!wasReconstructed)\n    {\n      delete catalog;\n      delete xref;\n      xref = new XRef(str, 0, 0, nullptr, true);\n      catalog = new Catalog(this);\n    }\n    if (catalog && !catalog->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read page catalog\");\n      errCode = errBadCatalog;\n      return false;\n    }\n  }\n  extractPDFSubtype();\n  return true;\n}", "target": 1}
{"code": "void recovery_character(const char *character)\n{\n    if (!awaiting_character) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");\n        layoutHome();\n        return;\n    }\n    char *pos = strchr(cipher, character[0]);\n    if (character[0] != ' ' && pos == NULL) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError, \"Character must be from a to z\");\n        layoutHome();\n        return;\n    }\n    static int uncyphered_word_count = 0;\n    static bool definitely_using_cipher = false;\n    static CONFIDENTIAL char coded_word[12];\n    static CONFIDENTIAL char decoded_word[12];\n    if (!mnemonic[0]) {\n        uncyphered_word_count = 0;\n        definitely_using_cipher = false;\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n    char decoded_character[2] = \" \";\n    if (character[0] != ' ') {\n        decoded_character[0] = english_alphabet[(int)(pos - cipher)];\n        strlcat(coded_word, character, sizeof(coded_word));\n        strlcat(decoded_word, decoded_character, sizeof(decoded_word));\n        if (enforce_wordlist && 4 <= strlen(coded_word)) {\n            bool maybe_not_using_cipher = attempt_auto_complete(coded_word);\n            bool maybe_using_cipher = attempt_auto_complete(decoded_word);\n            if (!maybe_not_using_cipher && maybe_using_cipher) {\n                definitely_using_cipher = true;\n            } else if (maybe_not_using_cipher && !definitely_using_cipher &&\n                       MAX_UNCYPHERED_WORDS < uncyphered_word_count++) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_SyntaxError,\n                                \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n                layoutHome();\n                return;\n            }\n        }\n    } else {\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n    strlcat(mnemonic, decoded_character, MNEMONIC_BUF);\n    next_character();\n}", "target": 1}
{"code": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t,tt;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "static void ssl_write_renegotiation_ext( ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + SSL_MAX_CONTENT_LEN;\n    *olen = 0;\n    if( ssl->renegotiation != SSL_RENEGOTIATION )\n        return;\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding renegotiation extension\" ) );\n    if( (size_t)(end - p) < 5 + ssl->verify_data_len )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n    *p++ = (unsigned char)( ( TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n    *p++ = 0x00;\n    *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;\n    *p++ = ssl->verify_data_len & 0xFF;\n    memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n    *olen = 5 + ssl->verify_data_len;\n}", "target": 1}
{"code": "CallResult<bool> isConstructor(Runtime &runtime, Callable *callable) {\n  if (!callable) {\n    return false;\n  }\n  while (BoundFunction *b = dyn_vmcast<BoundFunction>(callable)) {\n    callable = b->getTarget(runtime);\n  }\n  if (auto *func = dyn_vmcast<JSFunction>(callable)) {\n    auto *cb = func->getCodeBlock(runtime);\n    cb->lazyCompile(runtime);\n    return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(\n        true);\n  }\n  if (!vmisa<NativeFunction>(callable) || vmisa<NativeConstructor>(callable)) {\n    return true;\n  }\n  if (auto *cproxy = dyn_vmcast<JSCallableProxy>(callable)) {\n    return cproxy->isConstructor(runtime);\n  }\n  return false;\n}", "target": 1}
{"code": "parse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\t*ret_username = NULL;\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\tptr = user_input;\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\tif (*ptr == '\\0') {\n\t\treturn (PAM_BUF_ERR);\n\t}\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t'))\n\t\t\tbreak;\n\t\telse {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\tif ((*ret_username = malloc(index + 1)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\t(void) strcpy(*ret_username, username);\n\treturn (PAM_SUCCESS);\n}", "target": 1}
{"code": "static void bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tu32 i, insn_cnt = prog->len;\n\tbool pseudo_call;\n\tu8 code;\n\tint off;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tcode = insn->code;\n\t\tif (BPF_CLASS(code) != BPF_JMP)\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_CALL) {\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\tpseudo_call = true;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tpseudo_call = false;\n\t\t}\n\t\toff = pseudo_call ? insn->imm : insn->off;\n\t\tif (i < pos && i + off + 1 > pos)\n\t\t\toff += delta;\n\t\telse if (i > pos + delta && i + off + 1 <= pos + delta)\n\t\t\toff -= delta;\n\t\tif (pseudo_call)\n\t\t\tinsn->imm = off;\n\t\telse\n\t\t\tinsn->off = off;\n\t}\n}", "target": 1}
{"code": "static void process_COM (const uchar * Data, int length)\n{\n    int ch;\n    char Comment[MAX_COMMENT_SIZE+1];\n    int nch;\n    int a;\n    nch = 0;\n    if (length > MAX_COMMENT_SIZE) length = MAX_COMMENT_SIZE; \n    for (a=2;a<length;a++){\n        ch = Data[a];\n        if (ch == '\\r' && Data[a+1] == '\\n') continue; \n        if (ch >= 32 || ch == '\\n' || ch == '\\t'){\n            Comment[nch++] = (char)ch;\n        }else{\n            Comment[nch++] = '?';\n        }\n    }\n    Comment[nch] = '\\0'; \n    if (ShowTags){\n        printf(\"COM marker comment: %s\\n\",Comment);\n    }\n    strcpy(ImageInfo.Comments,Comment);\n}", "target": 1}
{"code": "static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n{\n    HLSContext *c = s->priv_data;\n    AVDictionary *tmp = NULL;\n    const char *proto_name = NULL;\n    int ret;\n    av_dict_copy(&tmp, opts, 0);\n    av_dict_copy(&tmp, opts2, 0);\n    if (av_strstart(url, \"crypto\", NULL)) {\n        if (url[6] == '+' || url[6] == ':')\n            proto_name = avio_find_protocol_name(url + 7);\n    }\n    if (!proto_name)\n        proto_name = avio_find_protocol_name(url);\n    if (!proto_name)\n         return AVERROR_INVALIDDATA;\n    if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))\n         return AVERROR_INVALIDDATA;\n     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n         ;\n     else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n        ;\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n        return AVERROR_INVALIDDATA;\n    ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n    if (ret >= 0) {\n        char *new_cookies = NULL;\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n        if (new_cookies) {\n            av_free(c->cookies);\n            c->cookies = new_cookies;\n        }\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    }\n    av_dict_free(&tmp);\n    if (is_http)\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n    return ret;\n}", "target": 1}
{"code": "void init_xml_schema()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"Schema\", rb_cObject);\n  cNokogiriXmlSchema = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n  rb_define_private_method(klass, \"validate_file\",     validate_file, 1);\n}", "target": 1}
{"code": "bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; \n    if(_members->Get(key,temp) && _isfield(temp)) \n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); \n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}", "target": 1}
{"code": "static int originates_from_local_legacy_unicast_socket(AvahiServer *s, const AvahiAddress *address, uint16_t port) {\n    assert(s);\n    assert(address);\n    assert(port > 0);\n    if (!s->config.enable_reflector)\n        return 0;\n    if (!avahi_address_is_local(s->monitor, address))\n        return 0;\n    if (address->proto == AVAHI_PROTO_INET && s->fd_legacy_unicast_ipv4 >= 0) {\n        struct sockaddr_in lsa;\n        socklen_t l = sizeof(lsa);\n        if (getsockname(s->fd_legacy_unicast_ipv4, (struct sockaddr*) &lsa, &l) != 0)\n            avahi_log_warn(\"getsockname(): %s\", strerror(errno));\n        else\n            return lsa.sin_port == port;\n    }\n    if (address->proto == AVAHI_PROTO_INET6 && s->fd_legacy_unicast_ipv6 >= 0) {\n        struct sockaddr_in6 lsa;\n        socklen_t l = sizeof(lsa);\n        if (getsockname(s->fd_legacy_unicast_ipv6, (struct sockaddr*) &lsa, &l) != 0)\n            avahi_log_warn(\"getsockname(): %s\", strerror(errno));\n        else\n            return lsa.sin6_port == port;\n    }\n    return 0;\n}", "target": 1}
{"code": "static s32 adpt_scsi_host_alloc(adpt_hba* pHba, struct scsi_host_template *sht)\n{\n\tstruct Scsi_Host *host;\n\thost = scsi_host_alloc(sht, sizeof(adpt_hba*));\n\tif (host == NULL) {\n\t\tprintk(\"%s: scsi_host_alloc returned NULL\\n\", pHba->name);\n\t\treturn -1;\n\t}\n\thost->hostdata[0] = (unsigned long)pHba;\n\tpHba->host = host;\n\thost->irq = pHba->pDev->irq;\n\thost->io_port = 0;\n\thost->n_io_port = 0;\n\thost->max_id = 16;\n\thost->max_lun = 256;\n\thost->max_channel = pHba->top_scsi_channel + 1;\n\thost->cmd_per_lun = 1;\n\thost->unique_id = (u32)sys_tbl_pa + pHba->unit;\n\thost->sg_tablesize = pHba->sg_tablesize;\n\thost->can_queue = pHba->post_fifo_size;\n\treturn 0;\n}", "target": 1}
{"code": "void Context::onLog() {\n  if (wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}", "target": 1}
{"code": "cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)\n{\n    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));\n    if (v == NULL) return NULL;\n    v ->List      = NULL;\n    v ->nColors   = 0;\n    v ->ContextID  = ContextID;\n    while (v -> Allocated < n)\n        GrowNamedColorList(v);\n    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));\n    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));\n    v->Prefix[32] = v->Suffix[32] = 0;\n    v -> ColorantCount = ColorantCount;\n    return v;\n}", "target": 1}
{"code": "int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}", "target": 1}
{"code": "static void adpt_i2o_report_hba_unit(adpt_hba* pHba, struct i2o_device *d)\n{\n\tchar buf[64];\n\tint unit = d->lct_data.tid;\n\tprintk(KERN_INFO \"TID %3.3d \", unit);\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 3, buf, 16)>=0)\n\t{\n\t\tbuf[16]=0;\n\t\tprintk(\" Vendor: %-12.12s\", buf);\n\t}\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 4, buf, 16)>=0)\n\t{\n\t\tbuf[16]=0;\n\t\tprintk(\" Device: %-12.12s\", buf);\n\t}\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 6, buf, 8)>=0)\n\t{\n\t\tbuf[8]=0;\n\t\tprintk(\" Rev: %-12.12s\\n\", buf);\n\t}\n#ifdef DEBUG\n\t printk(KERN_INFO \"\\tClass: %.21s\\n\", adpt_i2o_get_class_name(d->lct_data.class_id));\n\t printk(KERN_INFO \"\\tSubclass: 0x%04X\\n\", d->lct_data.sub_class);\n\t printk(KERN_INFO \"\\tFlags: \");\n\t if(d->lct_data.device_flags&(1<<0))\n\t\t  printk(\"C\");\t     \n\t if(d->lct_data.device_flags&(1<<1))\n\t\t  printk(\"U\");\t     \n\t if(!(d->lct_data.device_flags&(1<<4)))\n\t\t  printk(\"P\");\t     \n\t if(!(d->lct_data.device_flags&(1<<5)))\n\t\t  printk(\"M\");\t     \n\t printk(\"\\n\");\n#endif\n}", "target": 1}
{"code": "sudo_auth_init(const struct sudoers_context *ctx, struct passwd *pw,\n    unsigned int mode)\n{\n    sudo_auth *auth;\n    int status = AUTH_SUCCESS;\n    debug_decl(sudo_auth_init, SUDOERS_DEBUG_AUTH);\n    if (auth_switch[0].name == NULL)\n\tdebug_return_int(0);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (ISSET(mode, MODE_NONINTERACTIVE))\n\t    SET(auth->flags, FLAG_NONINTERACTIVE);\n\tif (auth->init && !IS_DISABLED(auth)) {\n\t    status = (auth->init)(ctx, pw, auth);\n\t    if (status == AUTH_FAILURE)\n\t\tSET(auth->flags, FLAG_DISABLED);\n\t    else if (status == AUTH_ERROR)\n\t\tbreak;\t\t\n\t}\n    }\n    if ((standalone = IS_STANDALONE(&auth_switch[0]))) {\n\tbool found = false;\n\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    if (!IS_STANDALONE(auth)) {\n\t\taudit_failure(ctx, ctx->runas.argv,\n\t\t    N_(\"invalid authentication methods\"));\n\t\tlog_warningx(ctx, SLOG_SEND_MAIL,\n\t\t    N_(\"Invalid authentication methods compiled into sudo!  \"\n\t\t    \"You may not mix standalone and non-standalone authentication.\"));\n\t\tdebug_return_int(-1);\n\t    }\n\t    if (!found) {\n\t\tfound = true;\n\t\tcontinue;\n\t    }\n\t    SET(auth->flags, FLAG_DISABLED);\n\t}\n    }\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (!IS_DISABLED(auth)) {\n\t    sudo_auth *first = auth;\n\t    for (; auth->name; auth++) {\n\t\tif (!IS_DISABLED(auth))\n\t\t    break;\n\t    }\n\t    if (auth->name == NULL)\n\t\tSET(first->flags, FLAG_ONEANDONLY);\n\t    break;\n\t}\n    }\n    debug_return_int(status == AUTH_ERROR ? -1 : 0);\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    DelogoContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    AVFrame *out;\n    int hsub0 = desc->log2_chroma_w;\n    int vsub0 = desc->log2_chroma_h;\n    int direct = 0;\n    int plane;\n    AVRational sar;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    sar = in->sample_aspect_ratio;\n    if (!sar.num)\n        sar.num = sar.den = 1;\n    for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n        int hsub = plane == 1 || plane == 2 ? hsub0 : 0;\n        int vsub = plane == 1 || plane == 2 ? vsub0 : 0;\n        apply_delogo(out->data[plane], out->linesize[plane],\n                     in ->data[plane], in ->linesize[plane],\n                     FF_CEIL_RSHIFT(inlink->w, hsub),\n                     FF_CEIL_RSHIFT(inlink->h, vsub),\n                     sar, s->x>>hsub, s->y>>vsub,\n                     FF_CEIL_RSHIFT(s->w + (s->x & ((1<<hsub)-1)), hsub),\n                     FF_CEIL_RSHIFT(s->h + (s->y & ((1<<vsub)-1)), vsub),\n                     s->band>>FFMIN(hsub, vsub),\n                     s->show, direct);\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "inline typename V::SetType FBUnserializer<V>::unserializeSet() {\n  p_ += CODE_SIZE;\n  unserializeInt64();\n  typename V::SetType ret = V::createSet();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::setAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "apr_byte_t oidc_cache_get(request_rec *r, const char *section, const char *key,\n\t\tchar **value) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tint encrypted = oidc_cfg_cache_encrypt(r);\n\tapr_byte_t rc = TRUE;\n\tchar *msg = NULL;\n\toidc_debug(r, \"enter: %s (section=%s, decrypt=%d, type=%s)\", key, section,\n\t\t\tencrypted, cfg->cache->name);\n\tif (encrypted == 1)\n\t\tkey = oidc_cache_get_hashed_key(r, cfg->crypto_passphrase, key);\n\tconst char *cache_value = NULL;\n\tif (cfg->cache->get(r, section, key, &cache_value) == FALSE) {\n\t\trc = FALSE;\n\t\tgoto out;\n\t}\n\tif (cache_value == NULL)\n\t\tgoto out;\n\tif (encrypted == 0) {\n\t\t*value = apr_pstrdup(r->pool, cache_value);\n\t\tgoto out;\n\t}\n\trc = (oidc_cache_crypto_decrypt(r, cache_value,\n\t\t\toidc_cache_hash_passphrase(r, cfg->crypto_passphrase),\n\t\t\t(unsigned char **) value) > 0);\nout:\n\tmsg = apr_psprintf(r->pool, \"from %s cache backend for %skey %s\",\n\t\t\tcfg->cache->name, encrypted ? \"encrypted \" : \"\", key);\n\tif (rc == TRUE)\n\t\tif (*value != NULL)\n\t\t\toidc_debug(r, \"cache hit: return %d bytes %s\",\n\t\t\t\t\t*value ? (int )strlen(*value) : 0, msg);\n\t\telse\n\t\t\toidc_debug(r, \"cache miss %s\", msg);\n\telse\n\t\toidc_warn(r, \"error retrieving value %s\", msg);\n\treturn rc;\n}", "target": 1}
{"code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n int new_mi_size;\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n if (cm->alloc_mi(cm, new_mi_size))\n goto fail;\n }\n if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols))\n goto fail;\n }\n if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n 2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n sizeof(*cm->above_context));\n if (!cm->above_context) goto fail;\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n }\n   return 0;\n  fail:\n   vp9_free_context_buffers(cm);\n   return 1;\n }", "target": 1}
{"code": "static int mct_u232_port_probe(struct usb_serial_port *port)\n{\n\tstruct mct_u232_private *priv;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->read_urb = port->serial->port[1]->interrupt_in_urb;\n\tpriv->read_urb->context = port;\n\tspin_lock_init(&priv->lock);\n\tusb_set_serial_port_data(port, priv);\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  int batches = input->dims->data[0];\n  int height = input->dims->data[1];\n  int width = input->dims->data[2];\n  int channels_out = input->dims->data[3];\n  auto padding = params->padding;\n  int out_width, out_height;\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width, 1, 1, height, width,\n      params->filter_height, params->filter_width, padding, &out_height,\n      &out_width);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    if (pool_type == kAverage || pool_type == kMax) {\n      TFLITE_DCHECK_LE(std::abs(input->params.scale - output->params.scale),\n                       1.0e-6);\n      TFLITE_DCHECK_EQ(input->params.zero_point, output->params.zero_point);\n    }\n    if (pool_type == kL2) {\n      TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n    }\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = batches;\n  output_size->data[1] = out_height;\n  output_size->data[2] = out_width;\n  output_size->data[3] = channels_out;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 1}
{"code": "static int ocfs2_prepare_page_for_write(struct inode *inode, u64 *p_blkno,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\t\tstruct page *page, u32 cpos,\n\t\t\t\t\tloff_t user_pos, unsigned user_len,\n\t\t\t\t\tint new)\n{\n\tint ret;\n\tunsigned int map_from = 0, map_to = 0;\n\tunsigned int cluster_start, cluster_end;\n\tunsigned int user_data_from = 0, user_data_to = 0;\n\tocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,\n\t\t\t\t\t&cluster_start, &cluster_end);\n\tif (page == wc->w_target_page) {\n\t\tmap_from = user_pos & (PAGE_CACHE_SIZE - 1);\n\t\tmap_to = map_from + user_len;\n\t\tif (new)\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    cluster_start, cluster_end,\n\t\t\t\t\t\t    new);\n\t\telse\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    map_from, map_to, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tuser_data_from = map_from;\n\t\tuser_data_to = map_to;\n\t\tif (new) {\n\t\t\tmap_from = cluster_start;\n\t\t\tmap_to = cluster_end;\n\t\t}\n\t} else {\n\t\tBUG_ON(!new);\n\t\tmap_from = cluster_start;\n\t\tmap_to = cluster_end;\n\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t    cluster_start, cluster_end, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (new && !PageUptodate(page))\n\t\tocfs2_clear_page_regions(page, OCFS2_SB(inode->i_sb),\n\t\t\t\t\t cpos, user_data_from, user_data_to);\n\tflush_dcache_page(page);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)\n{\n\tstruct file *filp;\n\tint ret;\n\tif (nd->intent.open.flags & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t}\n\tfilp = lookup_instantiate_filp(nd, path->dentry, NULL);\n\tif (!IS_ERR(filp)) {\n\t\tstruct nfs_open_context *ctx;\n\t\tctx = nfs_file_open_context(filp);\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, nd->intent.open.flags);\n\treturn ret;\n}", "target": 1}
{"code": " static inline void schedule_debug(struct task_struct *prev)\n {\n #ifdef CONFIG_SCHED_STACK_END_CHECK\n\tBUG_ON(task_stack_end_corrupted(prev));\n #endif\n \tif (unlikely(in_atomic_preempt_off())) {\n\t\t__schedule_bug(prev);\n\t\tpreempt_count_set(PREEMPT_DISABLED);\n\t}\n\trcu_sleep_check();\n\tprofile_hit(SCHED_PROFILING, __builtin_return_address(0));\n\tschedstat_inc(this_rq(), sched_count);\n}", "target": 1}
{"code": "void TestJlCompress::extractDir()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QDir curDir;\n    if (!curDir.mkpath(\"jlext/jldir\")) {\n        QFAIL(\"Couldn't mkpath jlext/jldir\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Couldn't create test files\");\n    }\n    if (!createTestArchive(zipName, fileNames)) {\n        QFAIL(\"Couldn't create test archive\");\n    }\n    QStringList extracted;\n    QCOMPARE((extracted = JlCompress::extractDir(zipName, \"jlext/jldir\"))\n        .count(), fileNames.count());\n    foreach (QString fileName, fileNames) {\n        QString fullName = \"jlext/jldir/\" + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = fileInfo.absoluteFilePath();\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n\t    absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    QCOMPARE((extracted = JlCompress::extractDir(&zipFile, \"jlext/jldir\"))\n        .count(), fileNames.count());\n    foreach (QString fileName, fileNames) {\n        QString fullName = \"jlext/jldir/\" + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = fileInfo.absoluteFilePath();\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n        absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    zipFile.close();\n    curDir.rmpath(\"jlext/jldir\");\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}", "target": 1}
{"code": "void json_object_seed(size_t seed) {\n    uint32_t new_seed = (uint32_t)seed;\n    if (hashtable_seed == 0) {\n        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n            if (new_seed == 0)\n                new_seed = generate_seed();\n            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n        } else {\n            do {\n#ifdef HAVE_SCHED_YIELD\n                sched_yield();\n#endif\n            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n        }\n    }\n}", "target": 1}
{"code": "void SetDashSize(double dashsize,double phase) {\n    if ( dashsize ) outpos += sprintf(outpos,\" [%12.3f] %12.3f d\",dashsize,phase);\n    else outpos += sprintf(outpos,\" [] 0 d\");\n}", "target": 1}
{"code": "static long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG;\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n \tif (!buf)\n \t\treturn -ENOMEM;\n\tif (copy_from_user(buf, (void *)arg, hdr.size_in)) {\n \t\tret = -EFAULT;\n \t\tgoto out;\n \t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    const RowPartitionType first_partition_type = row_partition_types_[0];\n    switch (first_partition_type) {\n      case RowPartitionType::FIRST_DIM_SIZE:\n        *result = first_partition_tensor.scalar<INDEX_TYPE>()();\n        return Status::OK();\n      case RowPartitionType::VALUE_ROWIDS:\n        return errors::InvalidArgument(\n            \"Cannot handle VALUE_ROWIDS in first dimension.\");\n      case RowPartitionType::ROW_SPLITS:\n        *result = first_partition_tensor.shape().dim_size(0) - 1;\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Cannot handle type \",\n            RowPartitionTypeToString(first_partition_type));\n    }\n  }", "target": 1}
{"code": "static int pfkey_recvmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *skb;\n\tint copied, err;\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\tmsg->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\terr = (flags & MSG_TRUNC) ? skb->len : copied;\n\tif (pfk->dump.dump != NULL &&\n\t    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\tpfkey_do_dump(pfk);\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}", "target": 1}
{"code": "bgp_capability_vty_out (struct vty *vty, struct peer *peer)\n{\n  char *pnt;\n  char *end;\n  struct capability cap;\n  pnt = peer->notify.data;\n  end = pnt + peer->notify.length;\n  while (pnt < end)\n    {\n      memcpy(&cap, pnt, sizeof(struct capability));\n      if (pnt + 2 > end)\n\treturn;\n      if (pnt + (cap.length + 2) > end)\n\treturn;\n      if (cap.code == CAPABILITY_CODE_MP)\n\t{\n\t  vty_out (vty, \"  Capability error for: Multi protocol \");\n\t  switch (ntohs (cap.mpc.afi))\n\t    {\n\t    case AFI_IP:\n\t      vty_out (vty, \"AFI IPv4, \");\n\t      break;\n\t    case AFI_IP6:\n\t      vty_out (vty, \"AFI IPv6, \");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"AFI Unknown %d, \", ntohs (cap.mpc.afi));\n\t      break;\n\t    }\n\t  switch (cap.mpc.safi)\n\t    {\n\t    case SAFI_UNICAST:\n\t      vty_out (vty, \"SAFI Unicast\");\n\t      break;\n\t    case SAFI_MULTICAST:\n\t      vty_out (vty, \"SAFI Multicast\");\n\t      break;\n\t    case SAFI_UNICAST_MULTICAST:\n\t      vty_out (vty, \"SAFI Unicast Multicast\");\n\t      break;\n\t    case BGP_SAFI_VPNV4:\n\t      vty_out (vty, \"SAFI MPLS-VPN\");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"SAFI Unknown %d \", cap.mpc.safi);\n\t      break;\n\t    }\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n      else if (cap.code >= 128)\n\tvty_out (vty, \"  Capability error: vendor specific capability code %d\",\n\t\t cap.code);\n      else\n\tvty_out (vty, \"  Capability error: unknown capability code %d\", \n\t\t cap.code);\n      pnt += cap.length + 2;\n    }\n}", "target": 1}
{"code": "    void assignRemoteEndpoints(\n            const ParticipantProxyData& ) override\n    {\n    }", "target": 1}
{"code": "static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\\n\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6)\n            parse_profile_level_id(s, h264_data, value);\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        int ret;\n        if (value[strlen(value) - 1] == ',') {\n            av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n            return 0;\n        }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "void SMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n    zis.setUnderlying(is, len - 4);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n    zis.removeUnderlying();\n    handler->handleClipboardProvide(flags, lengths, buffers);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}", "target": 1}
{"code": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\tpos = 2;\n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsysctl_head_finish(head);\n\treturn 0;\n}", "target": 1}
{"code": "mwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie)\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\treturn;\n}", "target": 1}
{"code": "static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      bool attach_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\tskb = tcp_make_synack(sk, dst, req, foc, attach_req);\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\t\terr = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\ndone:\n\treturn err;\n}", "target": 1}
{"code": "e1000_send_packet(E1000State *s, const uint8_t *buf, int size)\n{\n    static const int PTCregs[6] = { PTC64, PTC127, PTC255, PTC511,\n                                    PTC1023, PTC1522 };\n    NetClientState *nc = qemu_get_queue(s->nic);\n    if (s->phy_reg[PHY_CTRL] & MII_CR_LOOPBACK) {\n        nc->info->receive(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n    inc_tx_bcast_or_mcast_count(s, buf);\n    e1000x_increase_size_stats(s->mac_reg, PTCregs, size);\n}", "target": 1}
{"code": "void rdp_read_flow_control_pdu(wStream* s, UINT16* type)\n{\n\tUINT8 pduType;\n\tStream_Read_UINT8(s, pduType); \n\t*type = pduType;\n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)\n{\n  int stride;\n  U8 *buf;\n  int w, h, b;\n  w = r.width();\n  h = r.height();\n  b = format.bpp/8;\n  if (h == 0)\n    return;\n  buf = getBufferRW(r, &stride);\n  if (b == 1) {\n    while (h--) {\n      memset(buf, *(const U8*)pix, w);\n      buf += stride * b;\n    }\n  } else {\n    U8 *start;\n    int w1;\n    start = buf;\n    w1 = w;\n    while (w1--) {\n      memcpy(buf, pix, b);\n      buf += b;\n    }\n    buf += (stride - w) * b;\n    h--;\n    while (h--) {\n      memcpy(buf, start, w * b);\n      buf += stride * b;\n    }\n  }\n  commitBufferRW(r);\n}", "target": 1}
{"code": "static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\t\tBT_DBG(\"mtu %d\", opts.mtu);\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n \t\t\tbreak;\n \t\t}\n \t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n \t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "void *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        if (!buffers[i] ||\n            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n          abort();\n        }\n        buffer_pool_.push(buffers[i]);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n  if (is_pool_empty) {\n    Free(buffers);\n  }\n  return buffer;\n}", "target": 1}
{"code": "static int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,\n                              int32_t stream_id, const uint8_t *data,\n                              size_t len, void *user_data)\n{\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n    size_t offset = 0;\n    ogs_assert(session);\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return 0;\n    }\n    request = stream->request;\n    ogs_assert(request);\n    ogs_assert(data);\n    ogs_assert(len);\n    if (request->http.content == NULL) {\n        request->http.content_length = len;\n        request->http.content =\n            (char*)ogs_malloc(request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    } else {\n        offset = request->http.content_length;\n        if ((request->http.content_length + len) > OGS_HUGE_LEN) {\n            ogs_error(\"Overflow : Content-Length[%d], len[%d]\",\n                        (int)request->http.content_length, (int)len);\n            ogs_assert_if_reached();\n        }\n        request->http.content_length += len;\n        request->http.content = (char *)ogs_realloc(\n                request->http.content, request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    }\n    memcpy(request->http.content + offset, data, len);\n    request->http.content[request->http.content_length] = '\\0';\n    return 0;\n}", "target": 1}
{"code": "static s32 adpt_rescan(adpt_hba* pHba)\n{\n\ts32 rcode;\n\tulong flags = 0;\n\tif(pHba->host)\n\t\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tif ((rcode=adpt_i2o_lct_get(pHba)) < 0)\n\t\tgoto out;\n\tif ((rcode=adpt_i2o_reparse_lct(pHba)) < 0)\n\t\tgoto out;\n\trcode = 0;\nout:\tif(pHba->host)\n\t\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\treturn rcode;\n}", "target": 1}
{"code": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\tif (!commit_transaction)\n\t\treturn;\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}", "target": 1}
{"code": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}", "target": 1}
{"code": "static int rds_iw_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\tif (ret || cm_id->device->node_type != RDMA_NODE_RNIC)\n\t\tret = -EADDRNOTAVAIL;\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\trdma_destroy_id(cm_id);\n\treturn ret;\n}", "target": 1}
{"code": " pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n {\n     int i;\n    uint32_t txr_len_log2, rxr_len_log2;\n     uint32_t req_ring_size, cmp_ring_size;\n     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;\n    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)\n        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {\n        return -1;\n    }\n     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n     txr_len_log2 = pvscsi_log2(req_ring_size - 1);\n    }", "target": 1}
{"code": "static struct port_buffer *get_inbuf(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tif (port->inbuf)\n\t\treturn port->inbuf;\n\tbuf = virtqueue_get_buf(port->in_vq, &len);\n\tif (buf) {\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\tport->stats.bytes_received += len;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "void ha_maria::drop_table(const char *name)\n{\n  DBUG_ASSERT(file->s->temporary);\n  (void) ha_close();\n  (void) maria_delete_table_files(name, 1, MY_WME);\n}", "target": 1}
{"code": "devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,\n    int *eofp, caller_context_t *ct_unused, int flags_unused)\n{\n\tstruct sdev_node *sdvp = VTOSDEV(dvp);\n\tchar *ptr;\n\tsdcmn_err13((\"zv readdir of '%s' %s'\", sdvp->sdev_path,\n\t    sdvp->sdev_name));\n\tif (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {\n\t\tstruct vnode *vp;\n\t\trw_exit(&sdvp->sdev_contents);\n\t\t(void) devname_lookup_func(sdvp, \"dsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\t(void) devname_lookup_func(sdvp, \"rdsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tif (uiop->uio_offset == 0)\n\t\tdevzvol_prunedir(sdvp);\n\tptr = sdvp->sdev_path + strlen(ZVOL_DIR);\n\tif ((strcmp(ptr, \"/dsk\") == 0) || (strcmp(ptr, \"/rdsk\") == 0)) {\n\t\trw_exit(&sdvp->sdev_contents);\n\t\tdevzvol_create_pool_dirs(dvp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tptr = strchr(ptr + 1, '/') + 1;\n\trw_exit(&sdvp->sdev_contents);\n\tsdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);\n\trw_enter(&sdvp->sdev_contents, RW_READER);\n\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n}", "target": 1}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\tassert(game_config::path.empty() == false);\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\treturn result;\n}", "target": 1}
{"code": "x509stack_peek_level(struct cert_stack *stack)\n{\n\tstruct repo_level_node *repo = SLIST_FIRST(&stack->levels);\n\treturn (repo != NULL) ? repo->level : 0;\n}", "target": 1}
{"code": "void SystemClipboard::WriteImage(Image* image,\n                                 const KURL& url,\n                                 const String& title) {\n  DCHECK(image);\n  PaintImage paint_image = image->PaintImageForCurrentFrame();\n  SkBitmap bitmap;\n  if (sk_sp<SkImage> sk_image = paint_image.GetSkImage())\n    sk_image->asLegacyBitmap(&bitmap);\n   if (bitmap.isNull())\n     return;\n  if (!bitmap.getPixels())\n    return;\n   clipboard_->WriteImage(mojom::ClipboardBuffer::kStandard, bitmap);\n  if (url.IsValid() && !url.IsEmpty()) {\n#if !defined(OS_MACOSX)\n    clipboard_->WriteBookmark(mojom::ClipboardBuffer::kStandard,\n                              url.GetString(), NonNullString(title));\n#endif\n    clipboard_->WriteHtml(mojom::ClipboardBuffer::kStandard,\n                          URLToImageMarkup(url, title), KURL());\n  }\n  clipboard_->CommitWrite(mojom::ClipboardBuffer::kStandard);\n}", "target": 1}
{"code": "static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n \t\treturn;\n \t}\n \tif (status) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n \t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n \t\tmemcpy(command_info->result_buffer, &data[1],\n \t\t\t\t\t\turb->actual_length - 1);\n \t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}", "target": 1}
{"code": "void HTTPServer::handleRequest(Client *cl, HTTPRequest* req) {\n\tif (!req->parse()) {\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] There was an error processing the request of type: \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tstd::cout << req->getParseError() << std::endl;\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), req->getParseError());\n\t\treturn;\n\t}\n\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << req->methodIntToStr(req->getMethod()) << \" \" << req->getRequestUri() << std::endl;\n\tResourceHost* resHost = NULL;\n\tstd::string host = \"\";\n\tif (req->getVersion().compare(HTTP_VERSION_11) == 0) {\n\t\thost = req->getHeaderValue(\"Host\");\n\t\tif (host.find(\":\") == std::string::npos) {\n\t\t\thost.append(\":\" + std::to_string(listenPort));\n\t\t}\n\t\tstd::unordered_map<std::string, ResourceHost*>::const_iterator it = vhosts.find(host);\n\t\tif (it != vhosts.end())\n\t\t\tresHost = it->second;\n\t} else {\n\t\tif (hostList.size() > 0)\n\t\t\tresHost = hostList[0];\n\t}\n\tif (resHost == NULL) {\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), \"Invalid/No Host specified: \" + host);\n\t\treturn;\n\t}\n\tswitch (req->getMethod()) {\n\tcase Method(HEAD):\n\tcase Method(GET):\n\t\thandleGet(cl, req, resHost);\n\t\tbreak;\n\tcase Method(OPTIONS):\n\t\thandleOptions(cl, req);\n\t\tbreak;\n\tcase Method(TRACE):\n\t\thandleTrace(cl, req);\n\t\tbreak;\n\tdefault:\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] Could not handle or determine request of type \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tsendStatusResponse(cl, Status(NOT_IMPLEMENTED));\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "CURLcode Curl_http_done(struct connectdata *conn,\n                        CURLcode status, bool premature)\n{\n  struct SessionHandle *data = conn->data;\n  struct HTTP *http =data->req.protop;\n  Curl_unencode_cleanup(conn);\n#ifdef USE_SPNEGO\n  if(data->state.proxyneg.state == GSS_AUTHSENT ||\n      data->state.negotiate.state == GSS_AUTHSENT)\n    Curl_cleanup_negotiate(data);\n#endif\n  conn->fread_func = data->set.fread_func; \n  conn->fread_in = data->set.in; \n  conn->seek_func = data->set.seek_func; \n  conn->seek_client = data->set.seek_client; \n  if(http == NULL)\n    return CURLE_OK;\n  if(http->send_buffer) {\n    Curl_send_buffer *buff = http->send_buffer;\n    free(buff->buffer);\n    free(buff);\n    http->send_buffer = NULL; \n  }\n  if(HTTPREQ_POST_FORM == data->set.httpreq) {\n    data->req.bytecount = http->readbytecount + http->writebytecount;\n    Curl_formclean(&http->sendit); \n    if(http->form.fp) {\n      fclose(http->form.fp);\n      http->form.fp = NULL;\n    }\n  }\n  else if(HTTPREQ_PUT == data->set.httpreq)\n    data->req.bytecount = http->readbytecount + http->writebytecount;\n  if(status)\n    return status;\n  if(!premature && \n     !conn->bits.retry &&\n     !data->set.connect_only &&\n     ((http->readbytecount +\n       data->req.headerbytecount -\n       data->req.deductheadercount)) <= 0) {\n    failf(data, \"Empty reply from server\");\n    return CURLE_GOT_NOTHING;\n  }\n  return CURLE_OK;\n}", "target": 1}
{"code": "static inline void sem_getref_and_unlock(struct sem_array *sma)\n{\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "static bool allowed_problem_dir(const char *dir_name)\n{\n#if 0\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0\n     || (dir_name[len] != '/' && dir_name[len] != '\\0')\n     || strstr(dir_name + len, \"/.\")\n    ) {\n        return false;\n    }\n#endif\n    return true;\n}", "target": 1}
{"code": "do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n\t       IOBUF a, size_t *ret_len )\n{\n    int zrc;\n    int rc=0;\n    size_t n;\n    int nread, count;\n    int refill = !zs->avail_in;\n    if( DBG_FILTER )\n\tlog_debug(\"begin inflate: avail_in=%u, avail_out=%u, inbuf=%u\\n\",\n\t\t(unsigned)zs->avail_in, (unsigned)zs->avail_out,\n\t\t(unsigned)zfx->inbufsize );\n    do {\n\tif( zs->avail_in < zfx->inbufsize && refill ) {\n\t    n = zs->avail_in;\n\t    if( !n )\n            zs->next_in = BYTEF_CAST (zfx->inbuf);\n\t    count = zfx->inbufsize - n;\n\t    nread = iobuf_read( a, zfx->inbuf + n, count );\n\t    if( nread == -1 ) nread = 0;\n\t    n += nread;\n\t    if( nread < count && zfx->algo == 1 ) {\n\t\t*(zfx->inbuf + n) = 0xFF; \n\t\tzfx->algo1hack = 1;\n\t\tn++;\n\t    }\n\t    zs->avail_in = n;\n\t}\n\trefill = 1;\n\tif( DBG_FILTER )\n\t    log_debug(\"enter inflate: avail_in=%u, avail_out=%u\\n\",\n\t\t    (unsigned)zs->avail_in, (unsigned)zs->avail_out);\n\tzrc = inflate ( zs, Z_SYNC_FLUSH );\n\tif( DBG_FILTER )\n\t    log_debug(\"leave inflate: avail_in=%u, avail_out=%u, zrc=%d\\n\",\n\t\t   (unsigned)zs->avail_in, (unsigned)zs->avail_out, zrc);\n\tif( zrc == Z_STREAM_END )\n\t    rc = -1; \n\telse if( zrc != Z_OK && zrc != Z_BUF_ERROR ) {\n\t    if( zs->msg )\n\t\tlog_fatal(\"zlib inflate problem: %s\\n\", zs->msg );\n\t    else\n\t\tlog_fatal(\"zlib inflate problem: rc=%d\\n\", zrc );\n\t}\n    } while( zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR );\n    *ret_len = zfx->outbufsize - zs->avail_out;\n    if( DBG_FILTER )\n\tlog_debug(\"do_uncompress: returning %u bytes (%u ignored)\\n\",\n                  (unsigned int)*ret_len, (unsigned int)zs->avail_in );\n    return rc;\n}", "target": 1}
{"code": "  TestCertificateValidationContextConfig(\n      envoy::config::core::v3::TypedExtensionConfig config, bool allow_expired_certificate = false,\n      std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers = {})\n      : allow_expired_certificate_(allow_expired_certificate), api_(Api::createApiForTest()),\n        custom_validator_config_(config), san_matchers_(san_matchers){};", "target": 1}
{"code": "TfLiteStatus EvalHashtableSize(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  auto* output_data = GetTensorData<std::int64_t>(output_tensor);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  output_data[0] = lookup->Size();\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n     xattr_fidp->fs.xattr.flags = flags;\n     v9fs_string_init(&xattr_fidp->fs.xattr.name);\n     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n    xattr_fidp->fs.xattr.value = g_malloc(size);\n     err = offset;\n     put_fid(pdu, file_fidp);\n out_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}", "target": 1}
{"code": " static inline size_t GetPSDRowSize(Image *image)\n {\n   if (image->depth == 1)\n    return((image->columns+7)/8);\n   else\n     return(image->columns*GetPSDPacketSize(image));\n }", "target": 1}
{"code": "static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tstruct rtable *rt;\n \tstruct flowi4 fl4;\n \tint error = 0;\n \tif (sp->sa_protocol != PX_PROTO_PPTP)\n \t\treturn -EINVAL;\n\tif (lookup_chan_dst(sp->sa_addr.pptp.call_id, sp->sa_addr.pptp.sin_addr.s_addr))\n\t\treturn -EALREADY;\n\tlock_sock(sk);\n\tif (sk->sk_state & PPPOX_CONNECTED) {\n\t\terror = -EBUSY;\n\t\tgoto end;\n\t}\n\tif (sk->sk_state & PPPOX_DEAD) {\n\t\terror = -EALREADY;\n\t\tgoto end;\n\t}\n\tif (!opt->src_addr.sin_addr.s_addr || !sp->sa_addr.pptp.sin_addr.s_addr) {\n\t\terror = -EINVAL;\n\t\tgoto end;\n\t}\n\tpo->chan.private = sk;\n\tpo->chan.ops = &pptp_chan_ops;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk,\n\t\t\t\t   opt->dst_addr.sin_addr.s_addr,\n\t\t\t\t   opt->src_addr.sin_addr.s_addr,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_GRE, RT_CONN_FLAGS(sk), 0);\n\tif (IS_ERR(rt)) {\n\t\terror = -EHOSTUNREACH;\n\t\tgoto end;\n\t}\n\tsk_setup_caps(sk, &rt->dst);\n\tpo->chan.mtu = dst_mtu(&rt->dst);\n\tif (!po->chan.mtu)\n\t\tpo->chan.mtu = PPP_MRU;\n\tip_rt_put(rt);\n\tpo->chan.mtu -= PPTP_HEADER_OVERHEAD;\n\tpo->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);\n\terror = ppp_register_channel(&po->chan);\n\tif (error) {\n\t\tpr_err(\"PPTP: failed to register PPP channel (%d)\\n\", error);\n\t\tgoto end;\n\t}\n\topt->dst_addr = sp->sa_addr.pptp;\n\tsk->sk_state = PPPOX_CONNECTED;\n end:\n\trelease_sock(sk);\n\treturn error;\n}", "target": 1}
{"code": " */\nstatic void re_yyensure_buffer_stack (yyscan_t yyscanner)\n{\n\tyy_size_t num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!yyg->yy_buffer_stack) {\n\t\tnum_to_alloc = 1; \n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\t\tyy_size_t grow_size = 8 ;\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}", "target": 1}
{"code": "file_extension(const char *s)\t\n{\n  const char\t*extension;\t\n  static char\tbuf[1024];\t\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n    return (\"jpg\");\n  else if (!strncmp(s, \"data:image/png;\", 15))\n    return (\"png\");\n  else if ((extension = strrchr(s, '/')) != NULL)\n    extension ++;\n  else if ((extension = strrchr(s, '\\\\')) != NULL)\n    extension ++;\n  else\n    extension = s;\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n  strlcpy(buf, extension, sizeof(buf));\n  *(char *)strchr(buf, '#') = '\\0';\n  return (buf);\n}", "target": 1}
{"code": "int hashtable_set(hashtable_t *hashtable,\n                  const char *key, size_t serial,\n                  json_t *value)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t hash, index;\n    if(hashtable->size >= num_buckets(hashtable))\n        if(hashtable_do_rehash(hashtable))\n            return -1;\n    hash = hash_str(key);\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(pair)\n    {\n        json_decref(pair->value);\n        pair->value = value;\n    }\n    else\n    {\n        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);\n        if(!pair)\n            return -1;\n        pair->hash = hash;\n        pair->serial = serial;\n        strcpy(pair->key, key);\n        pair->value = value;\n        list_init(&pair->list);\n        insert_to_bucket(hashtable, bucket, &pair->list);\n        hashtable->size++;\n    }\n    return 0;\n}", "target": 1}
{"code": "AP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "static ssize_t inotify_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *pos)\n{\n\tsize_t event_size = sizeof (struct inotify_event);\n\tstruct inotify_device *dev;\n\tchar __user *start;\n\tint ret;\n\tDEFINE_WAIT(wait);\n\tstart = buf;\n\tdev = file->private_data;\n\twhile (1) {\n\t\tprepare_to_wait(&dev->wq, &wait, TASK_INTERRUPTIBLE);\n\t\tmutex_lock(&dev->ev_mutex);\n\t\tif (!list_empty(&dev->events)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&dev->ev_mutex);\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t}\n\tfinish_wait(&dev->wq, &wait);\n\tif (ret)\n\t\treturn ret;\n\twhile (1) {\n\t\tstruct inotify_kernel_event *kevent;\n\t\tret = buf - start;\n\t\tif (list_empty(&dev->events))\n\t\t\tbreak;\n\t\tkevent = inotify_dev_get_event(dev);\n\t\tif (event_size + kevent->event.len > count) {\n\t\t\tif (ret == 0 && count > 0) {\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tremove_kevent(dev, kevent);\n\t\tmutex_unlock(&dev->ev_mutex);\n\t\tif (copy_to_user(buf, &kevent->event, event_size)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuf += event_size;\n\t\tcount -= event_size;\n\t\tif (kevent->name) {\n\t\t\tif (copy_to_user(buf, kevent->name, kevent->event.len)){\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += kevent->event.len;\n\t\t\tcount -= kevent->event.len;\n\t\t}\n\t\tfree_kevent(kevent);\n\t\tmutex_lock(&dev->ev_mutex);\n\t}\n\tmutex_unlock(&dev->ev_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}", "target": 1}
{"code": "start_pass_merged_upsample(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  upsample->spare_full = FALSE;\n  upsample->rows_to_go = cinfo->output_height;\n}", "target": 1}
{"code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n}", "target": 1}
{"code": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *ndev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n\tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n}", "target": 1}
{"code": "static int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tint alt;\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn alt;\n\treturn usb_set_interface(udev,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n}", "target": 1}
{"code": "int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n    assert(obj->isarrlist);\n    if (mod>1)\n        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n    if (nsiz > MAX_ARRAY_LIST) {\n        Jsi_LogError(\"array size too large\");\n        return 0;\n    }\n    if (len >= obj->arrMaxSize) {\n        int oldsz = (nsiz-obj->arrMaxSize);\n        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n        obj->arrMaxSize = nsiz;\n    }\n    if (len>obj->arrCnt)\n        obj->arrCnt = len;\n    return nsiz;\n}", "target": 1}
{"code": "  void ValidateInputs(OpKernelContext* ctx,\n                      const CSRSparseMatrix& sparse_matrix,\n                      const Tensor& permutation_indices, int* batch_size,\n                      int64* num_rows) {\n    OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,\n                errors::InvalidArgument(\n                    \"Asked for a CSRSparseMatrix of type \",\n                    DataTypeString(DataTypeToEnum<T>::value),\n                    \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));\n    const Tensor& dense_shape = sparse_matrix.dense_shape();\n    const int rank = dense_shape.dim_size(0);\n    OP_REQUIRES(ctx, rank == 2 || rank == 3,\n                errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",\n                                        \"but dense_shape has size \", rank));\n    const int row_dim = (rank == 2) ? 0 : 1;\n    auto dense_shape_vec = dense_shape.vec<int64>();\n    *num_rows = dense_shape_vec(row_dim);\n    const int64 num_cols = dense_shape_vec(row_dim + 1);\n    OP_REQUIRES(ctx, *num_rows == num_cols,\n                errors::InvalidArgument(\"sparse matrix must be square; got: \",\n                                        *num_rows, \" != \", num_cols));\n    const TensorShape& perm_shape = permutation_indices.shape();\n    OP_REQUIRES(\n        ctx, perm_shape.dims() + 1 == rank,\n        errors::InvalidArgument(\n            \"sparse matrix must have the same rank as permutation; got: \", rank,\n            \" != \", perm_shape.dims(), \" + 1.\"));\n    OP_REQUIRES(\n        ctx, perm_shape.dim_size(rank - 2) == *num_rows,\n        errors::InvalidArgument(\n            \"permutation must have the same number of elements in each batch \"\n            \"as the number of rows in sparse matrix; got: \",\n            perm_shape.dim_size(rank - 2), \" != \", *num_rows));\n    *batch_size = sparse_matrix.batch_size();\n    if (*batch_size > 1) {\n      OP_REQUIRES(\n          ctx, perm_shape.dim_size(0) == *batch_size,\n          errors::InvalidArgument(\"permutation must have the same batch size \"\n                                  \"as sparse matrix; got: \",\n                                  perm_shape.dim_size(0), \" != \", *batch_size));\n    }\n  }", "target": 1}
{"code": "htmlGetText(tree_t *t)\t\t\n{\n  uchar\t\t*s,\t\t\n\t\t*s2,\t\t\n\t\t*tdata = NULL,\t\n\t\t*talloc = NULL;\t\n  size_t\tslen,\t\t\n\t\ttlen;\t\t\n  slen = 0;\n  s    = NULL;\n  while (t != NULL)\n  {\n    if (t->child)\n      tdata = talloc = htmlGetText(t->child);\n    else\n      tdata = t->data;\n    if (tdata != NULL)\n    {\n      tlen = strlen((char *)tdata);\n      if (s)\n        s2 = (uchar *)realloc(s, 1 + slen + tlen);\n      else\n        s2 = (uchar *)malloc(1 + tlen);\n      if (!s2)\n        break;\n      s = s2;\n      memcpy((char *)s + slen, (char *)tdata, tlen);\n      slen += tlen;\n      if (talloc)\n      {\n\tfree(talloc);\n\ttalloc = NULL;\n      }\n    }\n    t = t->next;\n  }\n  if (slen)\n    s[slen] = '\\0';\n  if (talloc)\n    free(talloc);\n  return (s);\n}", "target": 1}
{"code": "static int netbk_set_skb_gso(struct xenvif *vif,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct xen_netif_extra_info *gso)\n{\n\tif (!gso->u.gso.size) {\n\t\tnetdev_dbg(vif->dev, \"GSO size must not be zero.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) {\n\t\tnetdev_dbg(vif->dev, \"Bad GSO type %d.\\n\", gso->u.gso.type);\n\t\treturn -EINVAL;\n\t}\n\tskb_shinfo(skb)->gso_size = gso->u.gso.size;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\n\tskb_shinfo(skb)->gso_segs = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static void BenchmarkOpenCLDevices(MagickCLEnv clEnv)\n{\n  MagickCLDevice\n    device;\n  MagickCLEnv\n    testEnv;\n  size_t\n    i,\n    j;\n  testEnv=AcquireMagickCLEnv();\n  testEnv->library=openCL_library;\n  testEnv->devices=(MagickCLDevice *) AcquireMagickMemory(\n    sizeof(MagickCLDevice));\n  testEnv->number_devices=1;\n  testEnv->benchmark_thread_id=GetMagickThreadId();\n  testEnv->initialized=MagickTrue;\n  for (i = 0; i < clEnv->number_devices; i++)\n    clEnv->devices[i]->score=MAGICKCORE_OPENCL_UNDEFINED_SCORE;\n  for (i = 0; i < clEnv->number_devices; i++)\n  {\n    device=clEnv->devices[i];\n    if (device->score == MAGICKCORE_OPENCL_UNDEFINED_SCORE)\n      RunDeviceBenckmark(clEnv,testEnv,device);\n    for (j = i+1; j < clEnv->number_devices; j++)\n    {\n      MagickCLDevice\n        other_device;\n      other_device=clEnv->devices[j];\n      if (IsSameOpenCLDevice(device,other_device))\n        other_device->score=device->score;\n    }\n  }\n  testEnv->enabled=MagickFalse;\n  default_CLEnv=testEnv;\n  clEnv->cpu_score=RunOpenCLBenchmark(MagickTrue);\n  default_CLEnv=clEnv;\n  testEnv=RelinquishMagickCLEnv(testEnv);\n  CacheOpenCLBenchmarks(clEnv);\n}", "target": 1}
{"code": "static inline void pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tbuf->ops->get(pipe, buf);\n}", "target": 1}
{"code": "static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    clist_node_t new_queue = { .next = NULL };\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n    evtimer_del((evtimer_t *)(&_arq_timer),\n                &fbuf->sfr.arq_timeout_event.event);\n    fbuf->sfr.arq_timeout_event.event.next = NULL;\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        for (clist_node_t *node = clist_lpop(&_frame_queue);\n             node != NULL; node = clist_lpop(&_frame_queue)) {\n            _frame_queue_t *entry = (_frame_queue_t *)node;\n            if (entry->datagram_tag == fbuf->tag) {\n                gnrc_pktbuf_release(entry->frame);\n                entry->frame = NULL;\n                clist_rpush(&_frag_descs_free, node);\n            }\n            else {\n                clist_rpush(&new_queue, node);\n            }\n        }\n        _frame_queue = new_queue;\n    }\n    fbuf->offset = 0U;\n    fbuf->sfr.cur_seq = 0U;\n    fbuf->sfr.frags_sent = 0U;\n    for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);\n         node != NULL; node = clist_lpop(&fbuf->sfr.window)) {\n        clist_rpush(&_frag_descs_free, node);\n    }\n}", "target": 1}
{"code": "njs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n    code = (njs_vmcode_array_t *) pc;\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n    if (njs_fast_path(array != NULL)) {\n        if (code->ctor) {\n            value = array->start;\n            length = array->length;\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n        } else {\n            array->length = 0;\n        }\n        njs_set_array(&vm->retval, array);\n        return sizeof(njs_vmcode_array_t);\n    }\n    return NJS_ERROR;\n}", "target": 1}
{"code": "MonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\tMONO_ARCH_SAVE_REGS;\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\tklass = method->klass;\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);", "target": 1}
{"code": "int smb2_allocate_rsp_buf(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tsize_t small_sz = MAX_CIFS_SMALL_BUFFER_SIZE;\n\tsize_t large_sz = small_sz + work->conn->vals->max_trans_size;\n\tsize_t sz = small_sz;\n\tint cmd = le16_to_cpu(hdr->Command);\n\tif (cmd == SMB2_IOCTL_HE || cmd == SMB2_QUERY_DIRECTORY_HE)\n\t\tsz = large_sz;\n\tif (cmd == SMB2_QUERY_INFO_HE) {\n\t\tstruct smb2_query_info_req *req;\n\t\treq = smb2_get_msg(work->request_buf);\n\t\tif (req->InfoType == SMB2_O_INFO_FILE &&\n\t\t    (req->FileInfoClass == FILE_FULL_EA_INFORMATION ||\n\t\t     req->FileInfoClass == FILE_ALL_INFORMATION))\n\t\t\tsz = large_sz;\n\t}\n\tif (le32_to_cpu(hdr->NextCommand) > 0)\n\t\tsz = large_sz;\n\twork->response_buf = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->response_buf)\n\t\treturn -ENOMEM;\n\twork->response_sz = sz;\n\treturn 0;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    int istart = 0, n, i = 0, dir=1, idx=-1;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Obj *obj = _this->d.obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    if (!seq) {\n        goto bail;\n    }\n    n = Jsi_ObjGetLength(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {\n        istart = n-1;\n    }\n    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (op == 2) {\n        istart = n-1;\n        dir = -1;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    for (i = istart; ; i+=dir)\n    {\n        if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt)\n            break;\n        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {\n            idx = i;\n            break;\n        }\n    }\nbail:\n    if (op == 3)\n        Jsi_ValueMakeBool(interp, ret, (idx!=-1));\n    else\n        Jsi_ValueMakeNumber(interp, ret, idx);\n    return JSI_OK;\n}", "target": 1}
{"code": "void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {\n\tbin->header_offset = r_buf_read_le16_at (buf, 0x3c);\n\tbin->ne_header = R_NEW0 (NE_image_header);\n\tif (!bin->ne_header) {\n\t\treturn;\n\t}\n\tbin->buf = buf;\n\tr_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));\n\tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\tif (!bin->alignment) {\n\t\tbin->alignment = 1 << 9;\n\t}\n\tbin->os = __get_target_os (bin);\n\tut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;\n\tut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\tbin->segment_entries = calloc (1, size);\n\tif (!bin->segment_entries) {\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);\n\tbin->entry_table = calloc (1, bin->ne_header->EntryTableLength);\n\tr_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);\n\tbin->imports = r_bin_ne_get_imports (bin);\n\t__ne_get_resources (bin);\n}", "target": 1}
{"code": "bool IsPadOpSupported(const TfLiteRegistration* registration,\n                      const TfLiteNode* node, TfLiteContext* context) {\n  const TfLiteTensor* padding = GetInput(context, node, 1);\n  if (!IsConstantTensor(padding)) {\n    TF_LITE_KERNEL_LOG(context,\n                       \"%s: Only constant padding is supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  if (padding->dims->data[0] != 4 || padding->dims->data[1] != 2) {\n    TF_LITE_KERNEL_LOG(context, \"%s: Only 4D inputs are supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  const int32_t* padding_data = GetTensorData<int32_t>(padding);\n  if (!(padding_data[0] == 0 && padding_data[1] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for batch dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  if (!(padding_data[6] == 0 && padding_data[7] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for channel dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n \tmscfs_check_cache(priv->fs);\n \tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid= fs->cache.array[x].objectId.id;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; \n \t\t\tbuf += 2;\n\t\t\tcount+=2;\n \t\t}\n \t}\n \treturn count;\n}", "target": 1}
{"code": "void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mmu_notifier_range range;\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm,\n\t\t\t\taddress & HPAGE_PMD_MASK,\n\t\t\t\t(address & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE);\n\tmmu_notifier_invalidate_range_start(&range);\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, range.start, freeze);\nout:\n\tspin_unlock(ptl);\n\tmmu_notifier_invalidate_range_only_end(&range);\n}", "target": 1}
{"code": "static int r_cmd_java_call(void *user, const char *input) {\n\tRCore *core = (RCore *) user;\n\tint res = false;\n\tut32 i = 0;\n\tif (strncmp (input, \"java\", 4)) {\n\t\treturn false;\n\t}\n\tif (input[4] != ' ') {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\tfor (; i < END_CMDS; i++) {\n\t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n\t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));\n\t\tif (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {\n\t\t\tconst char *cmd = input + 5 + JAVA_CMDS[i].name_len;\n\t\t\tif (*cmd && *cmd == ' ') {\n\t\t\t\tcmd++;\n\t\t\t}\n\t\t\tres =  JAVA_CMDS[i].handler (core, cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  \n  c->set_output(1, c->Vector(nvals));        \n  c->set_output(2, c->Vector(rank));         \n  return Status::OK();\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_update_vhost_from_headers(request_rec *r)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"Host\");\n    int is_v6literal = 0;\n    int have_hostname_from_url = 0;\n    if (r->hostname) {\n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (r->status != HTTP_OK)\n        return;\n    if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n        if (have_hostname_from_url && host_header != NULL) {\n            const char *repl = construct_host_header(r, is_v6literal);\n            apr_table_setn(r->headers_in, \"Host\", repl);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"Replacing host header '%s' with host '%s' given \"\n                          \"in the request uri\", host_header, repl);\n        }\n    }\n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            check_hostalias(r);\n        else\n            check_serverpath(r);\n    }\n}", "target": 1}
{"code": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, \n\t\t\t     0, \n \t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n \t\t\t     10000\n \t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n \t\tstatus = get_unaligned_le16(status_buf);\n \t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\tkfree(status_buf);\n\treturn rc;\n}", "target": 1}
{"code": "struct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t* entry;\n\tbool sw = false;\n\tut8 b[1024];\n\tsize_t n = 0;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tentry = PE_(r_bin_pe_get_entrypoint) (pe);\n\tZERO_FILL (b);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\tif (b[0] == 0x55 && b[1] == 0x89 && b[3] == 0x83 && b[6] == 0xc7 && b[13] == 0xff && b[19] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 19);\n\t}\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[10] == 0xff && b[16] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 16);\n\t}\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[13] == 0xe8 && b[18] == 0x83 && b[21] == 0xe9) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 21);\n\t}\n\tif (sw) {\n\t\tfor (n = 0; n < sizeof (b) - 12; n++) {\n\t\t\tif (b[n] == 0xa1 && b[n + 5] == 0x89 && b[n + 8] == 0xe8) {\n\t\t\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}", "target": 1}
{"code": "kg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n    return code;\n}", "target": 1}
{"code": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n  register ssize_t\n    x;\n  register Quantum\n    *q;\n  ssize_t\n    count;\n  unsigned char\n    *graydata;\n  XCFPixelInfo\n     *xcfdata,\n     *xcfodata;\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n   if (xcfdata == (XCFPixelInfo *) NULL)\n     ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n       image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  \n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}", "target": 1}
{"code": "resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)\n{\n    int result;\n    u_char c;\n    int saw_digit;\n    int neg;\n    int too_large;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    too_large = 0;\n    neg = 0;\n    if (*bp == '-') {\n        neg = 1;\n        bp++;\n        len--;\n    }\n    result = 0;\n    saw_digit = 0;\n    for (;;) {\n        if (len == 0)\n            goto trunc;\n         ND_TCHECK(*bp);\n         c = *bp;\n         if (!(c >= '0' && c <= '9')) {\n            if (!saw_digit)\n                 goto invalid;\n             break;\n         }\n         c -= '0';\n        if (result > (INT_MAX / 10)) {\n            too_large = 1;\n        } else {\n            result *= 10;\n            if (result == INT_MAX && c > (INT_MAX % 10)) {\n                too_large = 1;\n            } else\n                result += c;\n        }\n        bp++;\n        len--;\n        saw_digit = 1;\n    }\n    if (!saw_digit)\n        goto invalid;\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n    if (*bp != '\\r')\n         goto invalid;\n     bp++;\n     len--;\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n    if (*bp != '\\n')\n         goto invalid;\n     bp++;\n     len--;\n     *endp = bp;\n    if (neg) {\n        if (too_large || result != 1)\n            return (-4);\n        result = -1;\n    }\n     return (too_large ? -3 : result);\n trunc:\n     return (-2);\n invalid:\n     return (-5);\n }", "target": 1}
{"code": "  void onComplete(const Status& status, ContextImpl& context) const override {\n    auto& completion_state = context.getCompletionState(this);\n    if (completion_state.is_completed_) {\n      return;\n    }\n    if (Status::Ok == status) {\n      completion_state.is_completed_ = true;\n      completeWithStatus(status, context);\n      return;\n    }\n    if (++completion_state.number_completed_children_ == verifiers_.size()) {\n      Status final_status = Status::JwtMissed;\n      for (const auto& it : verifiers_) {\n        Status child_status = context.getCompletionState(it.get()).status_;\n        if (child_status != Status::JwtMissed && child_status != Status::JwtUnknownIssuer) {\n          final_status = child_status;\n        }\n      }\n      if (is_allow_missing_or_failed_) {\n        final_status = Status::Ok;\n      } else if (is_allow_missing_ && final_status == Status::JwtMissed) {\n        final_status = Status::Ok;\n      }\n      completion_state.is_completed_ = true;\n      completeWithStatus(final_status, context);\n    }\n  }", "target": 1}
{"code": "shutdown_mib(void)\n{\n    unload_all_mibs();\n    if (tree_top) {\n        if (tree_top->label)\n            SNMP_FREE(tree_top->label);\n        SNMP_FREE(tree_top);\n    }\n    tree_head = NULL;\n    Mib = NULL;\n    if (_mibindexes) {\n        int i;\n        for (i = 0; i < _mibindex; ++i)\n            SNMP_FREE(_mibindexes[i]);\n        free(_mibindexes);\n        _mibindex = 0;\n        _mibindex_max = 0;\n        _mibindexes = NULL;\n    }\n    if (Prefix != NULL && Prefix != &Standard_Prefix[0])\n        SNMP_FREE(Prefix);\n    if (Prefix)\n        Prefix = NULL;\n    SNMP_FREE(confmibs);\n    SNMP_FREE(confmibdir);\n}", "target": 1}
{"code": "void rose_start_idletimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->idletimer);\n\tif (rose->idle > 0) {\n\t\trose->idletimer.function = rose_idletimer_expiry;\n\t\trose->idletimer.expires  = jiffies + rose->idle;\n\t\tadd_timer(&rose->idletimer);\n\t}\n}", "target": 1}
{"code": "snmp_oid_cmp_oid(uint32_t *oid1, uint32_t *oid2)\n{\n  uint8_t i;\n  i = 0;\n  while(oid1[i] != ((uint32_t)-1) &&\n        oid2[i] != ((uint32_t)-1)) {\n    if(oid1[i] != oid2[i]) {\n      if(oid1[i] < oid2[i]) {\n        return -1;\n      }\n      return 1;\n    }\n    i++;\n  }\n  if(oid1[i] == ((uint32_t)-1) &&\n     oid2[i] != ((uint32_t)-1)) {\n    return -1;\n  }\n  if(oid1[i] != ((uint32_t)-1) &&\n     oid2[i] == ((uint32_t)-1)) {\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1}
{"code": "static int logi_dj_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_report *dj_report = (struct dj_report *) data;\n\tunsigned long flags;\n\tbool report_processed = false;\n\tdbg_hid(\"%s, size:%d\\n\", __func__, size);\n \tspin_lock_irqsave(&djrcv_dev->lock, flags);\n \tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\n\t\tswitch (dj_report->report_type) {\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\t\tbreak;\n\t\tcase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\n\t\t\tif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\n\t\t\t    STATUS_LINKLOSS) {\n\t\t\t\tlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogi_dj_recv_forward_report(djrcv_dev, dj_report);\n\t\t}\n\t\treport_processed = true;\n\t}\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\treturn report_processed;\n}", "target": 1}
{"code": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MaxTextExtent];\n  const MagicInfo\n    *magic_info;\n  FILE\n    *ps_file;\n  ImageInfo\n    *clone_info;\n  Image\n    *image2;\n  unsigned char\n    magick[2*MaxTextExtent];\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MaxTextExtent, magick);\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n   if(exception->severity != UndefinedException) goto FINISH_UNL;\n   if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);\n  FormatLocaleString(clone_info->filename,MaxTextExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n  if (!image2)\n    goto FINISH_UNL;\n  (void) CopyMagickString(image2->filename,image->filename,MaxTextExtent);\n  (void) CopyMagickString(image2->magick_filename,image->magick_filename,MaxTextExtent);\n  (void) CopyMagickString(image2->magick,image->magick,MaxTextExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n  AppendImageToList(&image,image2);\n FINISH_UNL:\n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1}
{"code": "int VP8LBuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n                          const int code_lengths[], int code_lengths_size) {\n  int total_size;\n  assert(code_lengths_size <= MAX_CODE_LENGTHS_SIZE);\n  if (root_table == NULL) {\n    total_size = BuildHuffmanTable(NULL, root_bits,\n                                   code_lengths, code_lengths_size, NULL);\n  } else if (code_lengths_size <= SORTED_SIZE_CUTOFF) {\n    uint16_t sorted[SORTED_SIZE_CUTOFF];\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n  } else {   \n    uint16_t* const sorted =\n        (uint16_t*)WebPSafeMalloc(code_lengths_size, sizeof(*sorted));\n    if (sorted == NULL) return 0;\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n    WebPSafeFree(sorted);\n  }\n  return total_size;\n}", "target": 1}
{"code": "externalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: \n    default:\n      break;\n    }\n  }\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "status_t OMXNodeInstance::allocateBufferWithBackup(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n }\n Mutex::Autolock autoLock(mLock);\n if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {\n return BAD_VALUE;\n }\n bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;\n BufferMeta *buffer_meta = new BufferMeta(\n            params, portIndex,\n (portIndex == kPortIndexInput) && copy ,\n (portIndex == kPortIndexOutput) && copy ,\n            NULL );\n    OMX_BUFFERHEADERTYPE *header;\n    OMX_ERRORTYPE err = OMX_AllocateBuffer(\n            mHandle, &header, portIndex, buffer_meta, allottedSize);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(allocateBufferWithBackup, err,\n                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));\n delete buffer_meta;\n        buffer_meta = NULL;\n *buffer = 0;\n return StatusFromOMXError(err);\n     }\n     CHECK_EQ(header->pAppPrivate, buffer_meta);\n    memset(header->pBuffer, 0, header->nAllocLen);\n     *buffer = makeBufferID(header);\n    addActiveBuffer(portIndex, *buffer);\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, \"%zu@%p :> %u@%p\",\n            params->size(), params->pointer(), allottedSize, header->pBuffer));\n return OK;\n}", "target": 1}
{"code": "void CSecurityTLS::shutdown(bool needbye)\n{\n  if (session && needbye)\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS)\n      vlog.error(\"gnutls_bye failed\");\n  if (anon_cred) {\n    gnutls_anon_free_client_credentials(anon_cred);\n    anon_cred = 0;\n  }\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n    gnutls_global_deinit();\n  }\n}", "target": 1}
{"code": "static int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->id = CMD_SET_CTRL_MODE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd->u.ctrl_mode.tid = 0xff;\n\tcmd->u.ctrl_mode.channel = priv->channel;\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\tkfree(cmd);\n\treturn rc;\n}", "target": 1}
{"code": "void set_module_sig_enforced(void)\n{\n\tsig_enforce = true;\n}", "target": 1}
{"code": "static int nfs_readlink_req(struct nfs_priv *npriv, struct nfs_fh *fh,\n\t\t\t    char **target)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tuint32_t len;\n\tstruct packet *nfs_packet;\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\tp = nfs_add_fh3(p, fh);\n\tlen = p - &(data[0]);\n\tnfs_packet = rpc_req(npriv, PROG_NFS, NFSPROC3_READLINK, data, len);\n\tif (IS_ERR(nfs_packet))\n\t\treturn PTR_ERR(nfs_packet);\n\tp = (void *)nfs_packet->data + sizeof(struct rpc_reply) + 4;\n \tp = nfs_read_post_op_attr(p, NULL);\n \tlen = ntoh32(net_read_uint32(p)); \n \tp++;\n \t*target = xzalloc(len + 1);\n\treturn 0;\n}", "target": 1}
{"code": "  String_Obj Parser::parse_url_function_argument()\n  {\n    const char* p = position;\n    std::string uri(\"\");\n    if (lex< real_uri_value >(false)) {\n      uri = lexed.to_string();\n    }\n    if (peek< exactly< hash_lbrace > >()) {\n      const char* pp = position;\n      while (pp && peek< exactly< hash_lbrace > >(pp)) {\n        pp = sequence< interpolant, real_uri_value >(pp);\n      }\n      position = pp;\n      return parse_interpolated_chunk(Token(p, position));\n    }\n    else if (uri != \"\") {\n      std::string res = Util::rtrim(uri);\n      return SASS_MEMORY_NEW(String_Constant, pstate, res);\n    }\n    return 0;\n  }", "target": 1}
{"code": "hb_set_intersect (hb_set_t       *set,\n\t\t  const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->intersect (*other);\n}", "target": 1}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 15;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }", "target": 1}
{"code": "MemoryRegion *memory_map_ptr(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms, void *ptr)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram_ptr(uc, ram, size, ptr);\n    ram->perms = perms;\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "static int needs_empty_write(sector_t block, struct inode *inode)\n{\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\tbh_map.b_size = 1 << inode->i_blkbits;\n\terror = gfs2_block_map(inode, block, &bh_map, 0);\n\tif (unlikely(error))\n\t\treturn error;\n\treturn !buffer_mapped(&bh_map);\n}", "target": 1}
{"code": "initpyfribidi (void)\n{\n\tPyObject *module;\n\tmodule = Py_InitModule3 (\"pyfribidi\", PyfribidiMethods,\n\t\t\t\t _pyfribidi__doc__);\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n\tPyModule_AddStringConstant (module, \"__author__\",\n\t\t\t\t    \"Yaacov Zamir and Nir Soffer\");\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n \tchar *ptr;\n \tint err;\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n \tif (!file)\n \t\treturn -ENOMEM;\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\tkfree(file);\n\treturn err;\n}", "target": 1}
{"code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}", "target": 1}
{"code": "be32dec_vect(uint32_t *dst, const unsigned char *src, size_t len)\n{\n  size_t i;\n  uint32_t *s;\n  for (i = 0; i < len / 4; i++) {\n    s = (uint32_t *) (src + i * 4);\n    dst[i] = folly::Endian::big32(*s);\n  }\n}", "target": 1}
{"code": "QStringList QODBCDriver::tables(QSql::TableType type) const\n{\n    Q_D(const QODBCDriver);\n    QStringList tl;\n    if (!isOpen())\n        return tl;\n    SQLHANDLE hStmt;\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::tables: Unable to allocate handle\"_L1, d);\n        return tl;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    QStringList tableType;\n    if (type & QSql::Tables)\n        tableType += \"TABLE\"_L1;\n    if (type & QSql::Views)\n        tableType += \"VIEW\"_L1;\n    if (type & QSql::SystemTables)\n        tableType += \"SYSTEM TABLE\"_L1;\n    if (tableType.isEmpty())\n        return tl;\n    QString joinedTableTypeString = tableType.join(u',');\n    r = SQLTables(hStmt,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   toSQLTCHAR(joinedTableTypeString).data(),\n                   joinedTableTypeString.length() );\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::tables Unable to execute table list\"_L1, d);\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r != SQL_NO_DATA) {\n        qWarning() << \"QODBCDriver::tables failed to retrieve table/view list: (\" << r << \",\" << qWarnODBCHandle(SQL_HANDLE_STMT, hStmt) << \")\";\n        return QStringList();\n    }\n    while (r == SQL_SUCCESS) {\n        tl.append(qGetStringData(hStmt, 2, -1, d->unicode).toString());\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle\"_L1 + QString::number(r), d);\n    return tl;\n}", "target": 1}
{"code": "CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)\n{\n  ssize_t i;\n  ssize_t si;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *scratch = data->state.scratch;\n  char *newscratch = NULL;\n  char *oldscratch = NULL;\n  size_t eob_sent;\n   if(!scratch || data->set.crlf) {\n     oldscratch = scratch;\n    scratch = newscratch = malloc(2 * data->set.buffer_size);\n     if(!newscratch) {\n       failf(data, \"Failed to alloc scratch buffer!\");\n       return CURLE_OUT_OF_MEMORY;\n     }\n   }\n   eob_sent = smtp->eob;\n  for(i = 0, si = 0; i < nread; i++) {\n    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {\n      smtp->eob++;\n      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)\n        smtp->trailing_crlf = TRUE;\n      else\n        smtp->trailing_crlf = FALSE;\n    }\n    else if(smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n      si += smtp->eob - eob_sent;\n      if(SMTP_EOB[0] == data->req.upload_fromhere[i])\n        smtp->eob = 1;\n      else\n        smtp->eob = 0;\n      eob_sent = 0;\n      smtp->trailing_crlf = FALSE;\n    }\n    if(SMTP_EOB_FIND_LEN == smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],\n             SMTP_EOB_REPL_LEN - eob_sent);\n      si += SMTP_EOB_REPL_LEN - eob_sent;\n      smtp->eob = 0;\n      eob_sent = 0;\n    }\n    else if(!smtp->eob)\n      scratch[si++] = data->req.upload_fromhere[i];\n  }\n  if(smtp->eob - eob_sent) {\n    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n    si += smtp->eob - eob_sent;\n  }\n  if(si != nread) {\n    data->req.upload_fromhere = scratch;\n    data->state.scratch = scratch;\n    free(oldscratch);\n    data->req.upload_present = si;\n  }\n  else\n    free(newscratch);\n  return CURLE_OK;\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "static int is_userinfo_valid(const char *str, size_t len)\n{\n\tchar *valid = \"-._~!$&'()*+,;=:\";\n\tchar *p = str;\n\twhile (p - str < len) {\n\t\tif (isalpha(*p) || isdigit(*p) || strchr(valid, *p)) {\n\t\t\tp++;\n\t\t} else if (*p == '%' && p - str <= len - 3 && isdigit(*(p+1)) && isxdigit(*(p+2))) {\n\t\t\tp += 3;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "choose_filters(struct archive_read *a)\n{\n\tint number_bidders, i, bid, best_bid;\n\tstruct archive_read_filter_bidder *bidder, *best_bidder;\n\tstruct archive_read_filter *filter;\n\tssize_t avail;\n\tint r;\n\tfor (;;) {\n\t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);\n\t\tbest_bid = 0;\n\t\tbest_bidder = NULL;\n\t\tbidder = a->bidders;\n\t\tfor (i = 0; i < number_bidders; i++, bidder++) {\n\t\t\tif (bidder->bid != NULL) {\n\t\t\t\tbid = (bidder->bid)(bidder, a->filter);\n\t\t\t\tif (bid > best_bid) {\n\t\t\t\t\tbest_bid = bid;\n\t\t\t\t\tbest_bidder = bidder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (best_bidder == NULL) {\n\t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);\n\t\t\tif (avail < 0) {\n\t\t\t\t__archive_read_close_filters(a);\n\t\t\t\t__archive_read_free_filters(a);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->archive.compression_name = a->filter->name;\n\t\t\ta->archive.compression_code = a->filter->code;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\tfilter\n\t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n\t\tif (filter == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfilter->bidder = best_bidder;\n\t\tfilter->archive = a;\n\t\tfilter->upstream = a->filter;\n\t\ta->filter = filter;\n\t\tr = (best_bidder->init)(a->filter);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t__archive_read_close_filters(a);\n\t\t\t__archive_read_free_filters(a);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void serial_update_parameters(SerialState *s)\n{\n    int speed, parity, data_bits, stop_bits, frame_size;\n    QEMUSerialSetParams ssp;\n    if (s->divider == 0)\n        return;\n    frame_size = 1;\n    if (s->lcr & 0x08) {\n        frame_size++;\n        if (s->lcr & 0x10)\n            parity = 'E';\n        else\n            parity = 'O';\n    } else {\n            parity = 'N';\n    }\n    if (s->lcr & 0x04)\n        stop_bits = 2;\n    else\n        stop_bits = 1;\n    data_bits = (s->lcr & 0x03) + 5;\n    frame_size += data_bits + stop_bits;\n    speed = s->baudbase / s->divider;\n    ssp.speed = speed;\n    ssp.parity = parity;\n    ssp.data_bits = data_bits;\n    ssp.stop_bits = stop_bits;\n    s->char_transmit_time =  (NANOSECONDS_PER_SECOND / speed) * frame_size;\n    qemu_chr_fe_ioctl(s->chr, CHR_IOCTL_SERIAL_SET_PARAMS, &ssp);\n    DPRINTF(\"speed=%d parity=%c data=%d stop=%d\\n\",\n           speed, parity, data_bits, stop_bits);\n}", "target": 1}
{"code": "static void bt_for_each(struct blk_mq_hw_ctx *hctx,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t     \trq = blk_mq_tag_to_rq(hctx->tags, off + bit);\n\t\t\tif (rq->q == hctx->queue)\n\t\t\t\tfn(hctx, rq, data, reserved);\n\t\t}\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}", "target": 1}
{"code": "static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)\n{\n\tif (SSL_get_verify_result(ssl) != X509_V_OK) {\n\t\tunsigned char md[EVP_MAX_MD_SIZE];\n\t\tunsigned int n;\n\t\tchar *str;\n\t\tg_warning(\"Could not verify SSL servers certificate:\");\n\t\tif ((str = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get subject-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Subject : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif ((str = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get issuer-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Issuer  : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif (! X509_digest(cert, EVP_md5(), md, &n))\n\t\t\tg_warning(\"  Could not get fingerprint from peer certificate\");\n\t\telse {\n\t\t\tchar hex[] = \"0123456789ABCDEF\";\n\t\t\tchar fp[EVP_MAX_MD_SIZE*3];\n\t\t\tif (n < sizeof(fp)) {\n\t\t\t\tunsigned int i;\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tfp[i*3+0] = hex[(md[i] >> 4) & 0xF];\n\t\t\t\t\tfp[i*3+1] = hex[(md[i] >> 0) & 0xF];\n\t\t\t\t\tfp[i*3+2] = i == n - 1 ? '\\0' : ':';\n\t\t\t\t}\n\t\t\t\tg_warning(\"  MD5 Fingerprint : %s\", fp);\n\t\t\t}\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static int off_nominal_sync_run(struct ast_test *test, const char *domain, int rr_type,\n\t\tint rr_class, int expected_rcode)\n{\n\tstruct ast_dns_result *result;\n\tint res = 0;\n\tif (ast_dns_resolve(domain, rr_type, rr_class, &result)) {\n\t\tast_test_status_update(test, \"Failed to perform resolution :(\\n\");\n\t\treturn -1;\n\t}\n\tif (!result) {\n\t\tast_test_status_update(test, \"Resolution returned no result\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_dns_result_get_rcode(result) != expected_rcode) {\n\t\tast_test_status_update(test, \"Unexpected rcode from DNS resolution\\n\");\n\t\tres = -1;\n\t}\n\tif (ast_dns_result_get_records(result)) {\n\t\tast_test_status_update(test, \"DNS resolution returned records unexpectedly\\n\");\n\t\tres = -1;\n\t}\n\tast_dns_result_free(result);\n\treturn res;\n}", "target": 1}
{"code": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tcil_reset_classpermission(cp_set->set);\n}", "target": 1}
{"code": "xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,\n                const xmlChar *URI, int line, int nsNr, int tlen) {\n    const xmlChar *name;\n    GROW;\n    if ((RAW != '<') || (NXT(1) != '/')) {\n\txmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);\n\treturn;\n    }\n    SKIP(2);\n    if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {\n        if (ctxt->input->cur[tlen] == '>') {\n\t    ctxt->input->cur += tlen + 1;\n\t    ctxt->input->col += tlen + 1;\n\t    goto done;\n\t}\n\tctxt->input->cur += tlen;\n\tctxt->input->col += tlen;\n\tname = (xmlChar*)1;\n    } else {\n\tif (prefix == NULL)\n\t    name = xmlParseNameAndCompare(ctxt, ctxt->name);\n\telse\n\t    name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);\n    }\n    GROW;\n    if (ctxt->instate == XML_PARSER_EOF)\n        return;\n    SKIP_BLANKS;\n    if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {\n\txmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n    } else\n\tNEXT1;\n    if (name != (xmlChar*)1) {\n        if (name == NULL) name = BAD_CAST \"unparseable\";\n        if ((line == 0) && (ctxt->node != NULL))\n            line = ctxt->node->line;\n        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,\n\t\t     \"Opening and ending tag mismatch: %s line %d and %s\\n\",\n\t\t                ctxt->name, line, name);\n    }\ndone:\n    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&\n\t(!ctxt->disableSAX))\n\tctxt->sax->endElementNs(ctxt->userData, ctxt->name, prefix, URI);\n    spacePop(ctxt);\n    if (nsNr != 0)\n\tnsPop(ctxt, nsNr);\n    return;\n}", "target": 1}
{"code": "static inline void sem_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "init_util(void)\n{\n\tfilegen_register(statsdir, \"peerstats\",\t  &peerstats);\n\tfilegen_register(statsdir, \"loopstats\",\t  &loopstats);\n\tfilegen_register(statsdir, \"clockstats\",  &clockstats);\n\tfilegen_register(statsdir, \"rawstats\",\t  &rawstats);\n\tfilegen_register(statsdir, \"sysstats\",\t  &sysstats);\n\tfilegen_register(statsdir, \"protostats\",  &protostats);\n#ifdef AUTOKEY\n\tfilegen_register(statsdir, \"cryptostats\", &cryptostats);\n#endif\t\n#ifdef DEBUG_TIMING\n\tfilegen_register(statsdir, \"timingstats\", &timingstats);\n#endif\t\n\tstep_callback = &ntpd_time_stepped;\n#ifdef DEBUG\n\tatexit(&uninit_util);\n#endif \n}", "target": 1}
{"code": "IOBasicTypes::LongBufferSizeType ObjectByteWriterWithPosition::Write(const IOBasicTypes::Byte* inBuffer,IOBasicTypes::LongBufferSizeType inBufferSize)\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n    Local<Object> anArray = NEW_ARRAY((int)inBufferSize);\n    for(int i=0;i<(int)inBufferSize;++i)\n        anArray->Set(GET_CURRENT_CONTEXT, NEW_NUMBER(i),NEW_NUMBER(inBuffer[i]));\n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"write\")).ToLocalChecked();\n    if(value->IsUndefined() || !value->IsFunction())\n    {\n\t\tTHROW_EXCEPTION(\"write is not a function, it should be you know...\");\n        return 0;\n    }\n    Local<Function> func = Local<Function>::Cast(value);\n    Local<Value> args[1];\n    args[0] = anArray;\n\tLocal<Value> result = func->Call(GET_CURRENT_CONTEXT,  OBJECT_FROM_PERSISTENT(mObject), 1, args).ToLocalChecked();\n    if(result.IsEmpty())\n    {\n\t\tTHROW_EXCEPTION(\"wrong return value. it's empty. return the number of written characters\");\n\t\treturn 0;\n    }\n    else if(result->IsNumber())\n    {\n        return TO_UINT32(result)->Value();\n    }\n    else\n    {\n\t\tTHROW_EXCEPTION(\"wrong return value. write should return the number of written characters\");\n\t\treturn 0;\n    }\n}", "target": 1}
{"code": "void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        if (pSock->GetEncoding().empty()) {\n            pSock->SetEncoding(\"UTF-8\");\n        }\n    }\n#endif\n}", "target": 1}
{"code": "hb_set_subtract (hb_set_t       *set,\n\t\t const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->subtract (*other);\n}", "target": 1}
{"code": "static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint32_t str_j = 0;\n    uint32_t index1;\n    plist_data_t data = plist_new_plist_data();\n    data->type = PLIST_ARRAY;\n    data->length = size;\n    plist_t node = node_create(NULL, data);\n    for (j = 0; j < data->length; j++) {\n        str_j = j * bplist->ref_size;\n        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        plist_t val = parse_bin_node_at_index(bplist, index1);\n        if (!val) {\n            plist_free(node);\n            return NULL;\n        }\n        node_attach(node, val);\n    }\n    return node;\n}", "target": 1}
{"code": "ImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)\n{\n    UINT8 n;\n    UINT8* ptr;\n    if (strcmp(im->mode, \"1\") == 0 && state->xsize > state->bytes * 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    } else if (strcmp(im->mode, \"P\") == 0 && state->xsize > state->bytes) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    ptr = buf;\n    for (;;) {\n\tif (bytes < 1)\n\t    return ptr - buf;\n\tif ((*ptr & 0xC0) == 0xC0) {\n\t    if (bytes < 2)\n\t\treturn ptr - buf;\n\t    n = ptr[0] & 0x3F;\n\t    while (n > 0) {\n\t\tif (state->x >= state->bytes) {\n\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t    break;\n\t\t}\n\t\tstate->buffer[state->x++] = ptr[1];\n\t\tn--;\n\t    }\n\t    ptr += 2; bytes -= 2;\n\t} else {\n\t    state->buffer[state->x++] = ptr[0];\n\t    ptr++; bytes--;\n\t}\n\tif (state->x >= state->bytes) {\n        if (state->bytes % state->xsize && state->bytes > state->xsize) {\n            int bands = state->bytes / state->xsize;\n            int stride = state->bytes / bands;\n            int i;\n            for (i=1; i< bands; i++) {  \n                memmove(&state->buffer[i*state->xsize],\n                        &state->buffer[i*stride],\n                        state->xsize);\n            }\n        }\n\t    state->shuffle((UINT8*) im->image[state->y + state->yoff] +\n\t\t\t   state->xoff * im->pixelsize, state->buffer,\n\t\t\t   state->xsize);\n\t    state->x = 0;\n\t    if (++state->y >= state->ysize) {\n\t\treturn -1;\n\t    }\n\t}\n    }\n}", "target": 1}
{"code": "resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)\n{\n    int result;\n    u_char c;\n    int saw_digit;\n    int neg;\n    int too_large;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    too_large = 0;\n    neg = 0;\n    if (*bp == '-') {\n        neg = 1;\n        bp++;\n        len--;\n    }\n    result = 0;\n    saw_digit = 0;\n    for (;;) {\n        if (len == 0)\n            goto trunc;\n        ND_TCHECK(*bp);\n        c = *bp;\n        if (!(c >= '0' && c <= '9')) {\n            if (!saw_digit)\n                goto invalid;\n            break;\n        }\n        c -= '0';\n        if (result > (INT_MAX / 10)) {\n            too_large = 1;\n        } else {\n            result *= 10;\n            if (result == INT_MAX && c > (INT_MAX % 10)) {\n                too_large = 1;\n            } else\n                result += c;\n        }\n        bp++;\n        len--;\n        saw_digit = 1;\n    }\n    if (!saw_digit)\n        goto invalid;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\r')\n        goto invalid;\n    bp++;\n    len--;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\n')\n        goto invalid;\n    bp++;\n    len--;\n    *endp = bp;\n    if (neg) {\n        if (too_large || result != 1)\n            return (-4);\n        result = -1;\n    }\n    return (too_large ? -3 : result);\ntrunc:\n    return (-2);\ninvalid:\n    return (-5);\n}", "target": 1}
{"code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}", "target": 1}
{"code": "Http::FilterDataStatus Context::onResponseBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onResponseBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onResponseBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                                static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}", "target": 1}
{"code": "void FontInfoScanner::scanFonts(XRef *xrefA, Dict *resDict, std::vector<FontInfo*> *fontsList) {\n  GfxFontDict *gfxFontDict;\n  GfxFont *font;\n  gfxFontDict = nullptr;\n  const Object &fontObj = resDict->lookupNF(\"Font\");\n  if (fontObj.isRef()) {\n    Object obj2 = fontObj.fetch(xrefA);\n    if (obj2.isDict()) {\n      Ref r = fontObj.getRef();\n      gfxFontDict = new GfxFontDict(xrefA, &r, obj2.getDict());\n    }\n  } else if (fontObj.isDict()) {\n    gfxFontDict = new GfxFontDict(xrefA, nullptr, fontObj.getDict());\n  }\n  if (gfxFontDict) {\n    for (int i = 0; i < gfxFontDict->getNumFonts(); ++i) {\n      if ((font = gfxFontDict->getFont(i))) {\n        Ref fontRef = *font->getID();\n        if (fonts.find(fontRef.num) == fonts.end()) {\n\t  fontsList->push_back(new FontInfo(font, xrefA));\n          fonts.insert(fontRef.num);\n        }\n      }\n    }\n    delete gfxFontDict;\n  }\n  const char *resTypes[] = { \"XObject\", \"Pattern\" };\n  for (unsigned int resType = 0; resType < sizeof(resTypes) / sizeof(resTypes[0]); ++resType) {\n    Object objDict = resDict->lookup(resTypes[resType]);\n    if (objDict.isDict()) {\n      for (int i = 0; i < objDict.dictGetLength(); ++i) {\n        const Object &dictObjI = objDict.dictGetValNF(i);\n        if (dictObjI.isRef()) {\n          const Ref r = dictObjI.getRef();\n          if (visitedObjects.find(r.num) != visitedObjects.end()) {\n            continue;\n          }\n          visitedObjects.insert(r.num);\n        }\n        Object obj2 = dictObjI.fetch(xrefA);\n        if (obj2.isStream()) {\n          Object resObj = obj2.streamGetDict()->lookup(\"Resources\");\n          if (resObj.isDict() && resObj.getDict() != resDict) {\n            scanFonts(xrefA, resObj.getDict(), fontsList);\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "void ast_dns_resolver_completed(struct ast_dns_query *query)\n{\n\tsort_result(ast_dns_query_get_rr_type(query), query->result);\n\tquery->callback(query);\n}", "target": 1}
{"code": "struct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family)\n{\n    struct pico_socket_tcp *t = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!t)\n        return NULL;\n    t->sock.stack = S;\n    t->sock.timestamp = TCP_TIME;\n    pico_socket_set_family(&t->sock, family);\n    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);\n    t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n    t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n    t->tcpq_in.pool.compare = input_segment_compare;\n    t->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_hold.max_size = 2u * t->mss;\n    rto_set(t, PICO_TCP_RTO_MIN);\n    t->sock.opt_flags |= (1 << PICO_SOCKET_OPT_TCPNODELAY);\n    t->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n#endif\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n    tcp_set_space(t);\n    return &t->sock;\n}", "target": 1}
{"code": "double enclave_check_abi()\n{\n    double retval = NAN;\n    oe_result_t result = OE_UNEXPECTED;\n    abi_state_t before_ocall_state = {};\n    abi_state_t after_ocall_state = {};\n    typedef struct _host_check_abi_args_t\n    {\n        oe_result_t _result;\n        void* deepcopy_out_buffer;\n        size_t deepcopy_out_buffer_size;\n        double _retval;\n    } host_check_abi_args_t;\n    typedef struct _flat_ocall_args\n    {\n        oe_call_host_function_args_t host_function_args;\n        host_check_abi_args_t check_abi_args;\n    } flat_ocall_args_t;\n    static const size_t abi_fcn_id_host_check_abi = 0;\n    const flat_ocall_args_t args_template = {\n        {.function_id = abi_fcn_id_host_check_abi,\n         .input_buffer = NULL,\n         .input_buffer_size = sizeof(args_template.check_abi_args),\n         .output_buffer = NULL,\n         .output_buffer_size = sizeof(args_template.check_abi_args),\n         .output_bytes_written = 0,\n         .result = OE_UNEXPECTED},\n        {._result = OE_UNEXPECTED,\n         .deepcopy_out_buffer = NULL,\n         .deepcopy_out_buffer_size = 0,\n         ._retval = 0}};\n    flat_ocall_args_t* args =\n        (flat_ocall_args_t*)oe_allocate_ocall_buffer(sizeof(args_template));\n    if (!args)\n        goto done;\n    memcpy(args, &args_template, sizeof(args_template));\n    args->host_function_args.input_buffer = &args->check_abi_args;\n    args->host_function_args.output_buffer = &args->check_abi_args;\n    set_test_abi_state();\n    read_abi_state(&before_ocall_state);\n    result = oe_ocall(OE_OCALL_CALL_HOST_FUNCTION, (uint64_t)args, NULL);\n    read_abi_state(&after_ocall_state);\n    reset_test_abi_state();\n    if (result != OE_OK)\n        goto done;\n    if (args->host_function_args.result != OE_OK)\n        goto done;\n    if (args->host_function_args.output_bytes_written !=\n        sizeof(args_template.check_abi_args))\n        goto done;\n    if (args->check_abi_args._retval != EXPECTED_CHECK_ABI_RETURN_VALUE)\n        goto done;\n    if (!is_same_abi_state(&before_ocall_state, &after_ocall_state))\n        goto done;\n    retval = args->check_abi_args._retval;\ndone:\n    return retval;\n}", "target": 1}
{"code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n \tcase RXE_MEM_TYPE_MR:\n \tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n \tdefault:\n \t\treturn -EFAULT;\n\t}\n}", "target": 1}
{"code": " void ColorChooserDialog::DidCloseDialog(bool chose_color,\n                                         SkColor color,\n                                         RunState run_state) {\n  if (!listener_)\n    return;\n   EndRun(run_state);\n   CopyCustomColors(custom_colors_, g_custom_colors);\n  if (chose_color)\n    listener_->OnColorChosen(color);\n  listener_->OnColorChooserDialogClosed();\n }", "target": 1}
{"code": "MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    size_t needle_length = strlen(needle);\n    if (needle_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", needle_length);\n        return MOBI_PARAM_ERR;\n    }\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    unsigned char tag_open;\n    unsigned char tag_close;\n    if (type == T_CSS) {\n        tag_open = '{';\n        tag_close = '}';\n    } else {\n        tag_open = '<';\n        tag_close = '>';\n    }\n    unsigned char last_border = tag_close;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end && memcmp(data, needle, needle_length) == 0) {\n            if (last_border != tag_open) {\n                data += needle_length;\n                continue;\n            }\n            while (data >= data_start && !isspace(*data) && *data != tag_open && *data != '=' && *data != '(') {\n                data--;\n            }\n            result->is_url = (*data == '(');\n            result->start = ++data;\n            int i = 0;\n            while (data <= data_end && !isspace(*data) && *data != tag_close && *data != ')' && i < MOBI_ATTRVALUE_MAXSIZE) {\n                result->value[i++] = (char) *data++;\n            }\n            if (*(data - 1) == '/' && *data == '>') {\n                --data; --i;\n            }\n            result->end = data;\n            result->value[i] = '\\0';\n            return MOBI_SUCCESS;\n        }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "chdlc_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p)\n{\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\tif (caplen < CHDLC_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|chdlc]\"));\n\t\treturn (caplen);\n\t}\n        return (chdlc_print(ndo, p,length));\n}", "target": 1}
{"code": "void skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      prot.readBool(boolv);\n      return;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      prot.readByte(bytev);\n      return;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      prot.readI16(i16);\n      return;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      prot.readI32(i32);\n      return;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      prot.readI64(i64);\n      return;\n    }\n    case TType::T_DOUBLE: {\n      double dub;\n      prot.readDouble(dub);\n      return;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      prot.readFloat(flt);\n      return;\n    }\n    case TType::T_STRING: {\n      std::string str;\n      prot.readBinary(str);\n      return;\n    }\n    case TType::T_STRUCT: {\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      prot.readStructBegin(name);\n      while (true) {\n        prot.readFieldBegin(name, ftype, fid);\n        if (ftype == TType::T_STOP) {\n          break;\n        }\n        apache::thrift::skip(prot, ftype);\n        prot.readFieldEnd();\n      }\n      prot.readStructEnd();\n      return;\n    }\n    case TType::T_MAP: {\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      prot.readMapBegin(keyType, valType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, keyType);\n        apache::thrift::skip(prot, valType);\n      }\n      prot.readMapEnd();\n      return;\n    }\n    case TType::T_SET: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readSetBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readSetEnd();\n      return;\n    }\n    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}", "target": 1}
{"code": " static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n {\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n \treturn usb_serial_generic_open(tty, port);\n }", "target": 1}
{"code": "set_file_metadata (const char *origin_url, const char *referrer_url, FILE *fp)\n{\n  int retval = -1;\n  if (!origin_url || !fp)\n    return retval;\n  retval = write_xattr_metadata (\"user.xdg.origin.url\", escnonprint_uri (origin_url), fp);\n  if ((!retval) && referrer_url)\n    retval = write_xattr_metadata (\"user.xdg.referrer.url\", escnonprint_uri (referrer_url), fp);\n  return retval;\n}", "target": 1}
{"code": "TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,\n                                    const TfLiteTensor* input,\n                                    const TfLiteTensor* filter,\n                                    int16* depth_multiplier) {\n  int num_filter_channels = SizeOfDimension(filter, 3);\n  int num_input_channels = SizeOfDimension(input, 3);\n  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);\n  *depth_multiplier = num_filter_channels / num_input_channels;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int em_fxrstor(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tint rc;\n\trc = check_fxsr(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = segmented_read(ctxt, ctxt->memop.addr.mem, &fx_state, 512);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (fx_state.mxcsr >> 16)\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->ops->get_fpu(ctxt);\n\tif (ctxt->mode < X86EMUL_MODE_PROT64)\n\t\trc = fxrstor_fixup(ctxt, &fx_state);\n\tif (rc == X86EMUL_CONTINUE)\n\t\trc = asm_safe(\"fxrstor %[fx]\", : [fx] \"m\"(fx_state));\n\tctxt->ops->put_fpu(ctxt);\n\treturn rc;\n}", "target": 1}
{"code": "iscsi_aio_ioctl_cb(struct iscsi_context *iscsi, int status,\n                     void *command_data, void *opaque)\n{\n    IscsiAIOCB *acb = opaque;\n    if (status == SCSI_STATUS_CANCELLED) {\n        if (!acb->bh) {\n            acb->status = -ECANCELED;\n            iscsi_schedule_bh(acb);\n        }\n        return;\n    }\n    acb->status = 0;\n    if (status < 0) {\n        error_report(\"Failed to ioctl(SG_IO) to iSCSI lun. %s\",\n                     iscsi_get_error(iscsi));\n        acb->status = -iscsi_translate_sense(&acb->task->sense);\n    }\n    acb->ioh->driver_status = 0;\n    acb->ioh->host_status   = 0;\n    acb->ioh->resid         = 0;\n    acb->ioh->status        = status;\n#define SG_ERR_DRIVER_SENSE    0x08\n    if (status == SCSI_STATUS_CHECK_CONDITION && acb->task->datain.size >= 2) {\n        int ss;\n        acb->ioh->driver_status |= SG_ERR_DRIVER_SENSE;\n        acb->ioh->sb_len_wr = acb->task->datain.size - 2;\n        ss = (acb->ioh->mx_sb_len >= acb->ioh->sb_len_wr) ?\n             acb->ioh->mx_sb_len : acb->ioh->sb_len_wr;\n        memcpy(acb->ioh->sbp, &acb->task->datain.data[2], ss);\n    }\n    iscsi_schedule_bh(acb);\n}", "target": 1}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = *pmd;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}", "target": 1}
{"code": "static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\tif (**value == '\"') {\n\t\tend = strchr(*value + 1, '\"');\n\t\tif (!end) {\n\t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = '\\0';\n\t\tend++;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\treturn 1;\n}", "target": 1}
{"code": "long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n  ds = d;\n  for (si = s; si < se; ) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n    if (c != '.')\n      if (c != 0x3002)  \n        if (c != 0xFF0E)  \n          if (c != 0xFF61)  \n            continue;\n    rc = uv__idna_toascii_label(s, st, &d, de);\n    if (rc < 0)\n      return rc;\n    if (d < de)\n      *d++ = '.';\n    s = si;\n  }\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n    if (rc < 0)\n      return rc;\n  }\n  if (d < de)\n    *d++ = '\\0';\n  return d - ds;  \n}", "target": 1}
{"code": "parse_tag_11_packet(unsigned char *data, unsigned char *contents,\n\t\t    size_t max_contents_bytes, size_t *tag_11_contents_size,\n\t\t    size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tsize_t length_size;\n\tint rc = 0;\n\t(*packet_size) = 0;\n\t(*tag_11_contents_size) = 0;\n\tif (max_packet_size < 16) {\n\t\tprintk(KERN_ERR \"Maximum packet size too small\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_11_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\tgoto out;\n\t}\n\tif (body_size < 14) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += length_size;\n\t(*tag_11_contents_size) = (body_size - 14);\n\tif (unlikely((*packet_size) + body_size + 1 > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x62) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x08) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += 12; \n\tmemcpy(contents, &data[(*packet_size)], (*tag_11_contents_size));\n\t(*packet_size) += (*tag_11_contents_size);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*tag_11_contents_size) = 0;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\t\tret = 0;\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret == 0 ? link_ret : ret;\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t\n\t\t\treturn -EINVAL;\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn change;\n}", "target": 1}
{"code": "static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n\tstruct iw_exif_state *e, iw_uint32 ifd)\n{\n\tunsigned int tag_count;\n\tunsigned int i;\n\tunsigned int tag_pos;\n\tunsigned int tag_id;\n\tunsigned int v;\n\tdouble v_dbl;\n\tif(ifd<8 || ifd>e->d_len-18) return;\n\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n\tif(tag_count>1000) return; \n\tfor(i=0;i<tag_count;i++) {\n\t\ttag_pos = ifd+2+i*12;\n\t\tif(tag_pos+12 > e->d_len) return; \n\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n\t\tswitch(tag_id) {\n\t\tcase 274: \n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_orientation = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 296: \n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_density_unit = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 282: \n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_x = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 283: \n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_y = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "\t\tvoid PdfTranslator::setSource ( const std::string & source )\n\t\t{\n\t\t\tint dbg(0);\n\t\t\tstd::cerr<< ++dbg <<std::endl;\n\t\t\tif ( checkIsPDF ( source ) )\n\t\t\t{\n\t\t\t\tmultiSource.push_back ( source );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tifstream in ( source.c_str(), ifstream::in );\n\t\t\t\tif ( !in.good() )\n\t\t\t\t\tthrow runtime_error ( \"setSource() failed to open input file\" );\n\t\t\t\tchar *filenameBuffer = new char[1000];\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tin.getline ( filenameBuffer, 1000 );\n\t\t\t\t\tstd::string ts ( filenameBuffer, in.gcount() );\n\t\t\t\t\tif ( ts.size() > 4 ) \n\t\t\t\t\t{\n\t\t\t\t\t\tmultiSource.push_back ( ts );\n\t\t\t\t\t\tstd::cerr << \"Appending \"<< ts <<\" to source\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile ( !in.eof() );\n\t\t\t\tin.close();\n\t\t\t\tdelete [] filenameBuffer;\n\t\t\t}\n\t\t\tstd::cerr<< ++dbg <<std::endl;\n\t\t\tfor ( std::vector<std::string>::const_iterator ms = multiSource.begin(); ms != multiSource.end(); ++ms )\n\t\t\t{\n\t\t\t\tif ( ms == multiSource.begin() )\n\t\t\t\t{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tsourceDoc = new PdfMemDocument ( ( *ms ).c_str() );\n\t\t\t\t\t}\n\t\t\t\t\tcatch(PdfError& e)\n\t\t\t\t\t{\n                        std::cerr << \"Unable to create Document: \" << PdfError::ErrorMessage( e.GetError() ) << std::endl;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tPdfMemDocument mdoc ( ( *ms ).c_str() );\n\t\t\t\t\tsourceDoc->InsertPages ( mdoc, 0, mdoc.GetPageCount() );\n\t\t\t\t}\n\t\t\t}\n\t\t\tpcount = sourceDoc->GetPageCount();\n\t\t\tif ( pcount > 0 ) \n\t\t\t{\n\t\t\t\tPoDoFo::PdfRect rect ( sourceDoc->GetPage ( 0 )->GetMediaBox() );\n\t\t\t\tsourceWidth =  rect.GetWidth() - rect.GetLeft();\n\t\t\t\tsourceHeight =  rect.GetHeight() - rect.GetBottom() ;\n\t\t\t}\n\t\t}", "target": 1}
{"code": " status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\"ProCamera2Client[%d] (%p) PID: %d, dump:\\n\",\n             mCameraId,\n            getRemoteCallback()->asBinder().get(),\n            mClientPid);\n    result.append(\"  State: \");\n    mFrameProcessor->dump(fd, args);\n return dumpDevice(fd, args);\n}", "target": 1}
{"code": "static int translate_desc(struct vhost_dev *dev, u64 addr, u32 len,\n\t\t\t  struct iovec iov[], int iov_size)\n{\n\tconst struct vhost_memory_region *reg;\n\tstruct vhost_memory *mem;\n\tstruct iovec *_iov;\n\tu64 s = 0;\n\tint ret = 0;\n\trcu_read_lock();\n\tmem = rcu_dereference(dev->memory);\n\twhile ((u64)len > s) {\n\t\tu64 size;\n\t\tif (unlikely(ret >= iov_size)) {\n\t\t\tret = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\treg = find_region(mem, addr, len);\n\t\tif (unlikely(!reg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t_iov = iov + ret;\n\t\tsize = reg->memory_size - addr + reg->guest_phys_addr;\n\t\t_iov->iov_len = min((u64)len, size);\n\t\t_iov->iov_base = (void __user *)(unsigned long)\n\t\t\t(reg->userspace_addr + addr - reg->guest_phys_addr);\n\t\ts += size;\n\t\taddr += size;\n\t\t++ret;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 1}
{"code": "static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set (db, \"qnx.cpu\", r_strf (\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set (db, \"qnx.fpu\", r_strf (\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set (db, \"qnx.code_index\", r_strf (\"0x%x\", lmfh->code_index), 0);\n\tsdb_set (db, \"qnx.stack_index\", r_strf (\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set (db, \"qnx.heap_index\", r_strf (\"0x%x\", lmfh->heap_index), 0);\n\tsdb_set (db, \"qnx.argv_index\", r_strf (\"0x%x\", lmfh->argv_index), 0);\n\tsdb_set (db, \"qnx.code_offset\", r_strf (\"0x%x\", lmfh->code_offset), 0);\n\tsdb_set (db, \"qnx.stack_nbytes\", r_strf (\"0x%x\", lmfh->stack_nbytes), 0);\n\tsdb_set (db, \"qnx.heap_nbytes\", r_strf (\"0x%x\", lmfh->heap_nbytes), 0);\n\tsdb_set (db, \"qnx.image_base\", r_strf (\"0x%x\", lmfh->image_base), 0);\n\treturn true;\n}", "target": 1}
{"code": "static int efi_capsule_flush(struct file *file, fl_owner_t id)\n{\n\tint ret = 0;\n\tstruct capsule_info *cap_info = file->private_data;\n\tif (cap_info->index > 0) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t\tret = -ECANCELED;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\tif (info->attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);\n\tif (info->attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels > 1);\n\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n\tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n\t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))\n\t\t\treturn -EINVAL;\n\t\tparam.regd = hwsim_world_regdom_custom[idx];\n\t}\n\tret = mac80211_hwsim_new_radio(info, &param);\n\tkfree(hwname);\n\treturn ret;\n}", "target": 1}
{"code": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p)) {\n\t\t\t\twhile (last_dest->mnt_master != p) {\n\t\t\t\t\tlast_source = last_source->mnt_master;\n\t\t\t\t\tlast_dest = last_source->mnt_parent;\n\t\t\t\t}\n\t\t\t\tif (!peers(n, last_dest)) {\n\t\t\t\t\tlast_source = last_source->mnt_master;\n\t\t\t\t\tlast_dest = last_source->mnt_parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttype = CL_SLAVE;\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn 0;\n}", "target": 1}
{"code": "static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\treturn 0;\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\tif ((unsigned int) data != 0 ||\n\t\t\t    test_fp_ctl(data >> (BITS_PER_LONG - 32)))\n\t\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\t__poke_user_per(child, addr, data);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "p11_rpc_buffer_get_attribute (p11_buffer *buffer,\n\t\t\t      size_t *offset,\n\t\t\t      CK_ATTRIBUTE *attr)\n{\n\tuint32_t type, length;\n\tunsigned char validity;\n\tp11_rpc_attribute_serializer *serializer;\n\tp11_rpc_value_type value_type;\n\tif (!p11_rpc_buffer_get_uint32 (buffer, offset, &type))\n\t\treturn false;\n\tif (!p11_rpc_buffer_get_byte (buffer, offset, &validity))\n\t\treturn false;\n\tif (!validity) {\n\t\tattr->ulValueLen = ((CK_ULONG)-1);\n\t\tattr->type = type;\n\t\treturn true;\n\t}\n\tif (!p11_rpc_buffer_get_uint32 (buffer, offset, &length))\n\t\treturn false;\n\tvalue_type = map_attribute_to_value_type (type);\n\tassert (value_type < ELEMS (p11_rpc_attribute_serializers));\n\tserializer = &p11_rpc_attribute_serializers[value_type];\n\tassert (serializer != NULL);\n\tif (!serializer->decode (buffer, offset, attr->pValue, &attr->ulValueLen))\n\t\treturn false;\n\tif (!attr->pValue)\n\t\tattr->ulValueLen = length;\n\tattr->type = type;\n\treturn true;\n}", "target": 1}
{"code": "int test_sqr(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM a,c,d,e;\n\tint i;\n\tBN_init(&a);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(&a,40+i*10,0,0);\n\t\ta.neg=rand_neg();\n\t\tBN_sqr(&c,&a,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(&d,&e,&c,&a,ctx);\n\t\tBN_sub(&d,&d,&a);\n\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n\t\t    {\n\t\t    fprintf(stderr,\"Square test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\treturn(1);\n\t}", "target": 1}
{"code": "static MemTxResult address_space_write_continue(AddressSpace *as, hwaddr addr,\n                                                MemTxAttrs attrs,\n                                                const uint8_t *buf,\n                                                int len, hwaddr addr1,\n                                                hwaddr l, MemoryRegion *mr)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemTxResult result = MEMTX_OK;\n    bool release_lock = false;\n    for (;;) {\n        if (!memory_access_is_direct(mr, true)) {\n            release_lock |= prepare_mmio_access(mr);\n            l = memory_access_size(mr, l, addr1);\n            switch (l) {\n            case 8:\n                val = ldq_p(buf);\n                result |= memory_region_dispatch_write(mr, addr1, val, 8,\n                                                       attrs);\n                break;\n            case 4:\n                val = (uint32_t)ldl_p(buf);\n                result |= memory_region_dispatch_write(mr, addr1, val, 4,\n                                                       attrs);\n                break;\n            case 2:\n                val = lduw_p(buf);\n                result |= memory_region_dispatch_write(mr, addr1, val, 2,\n                                                       attrs);\n                break;\n            case 1:\n                val = ldub_p(buf);\n                result |= memory_region_dispatch_write(mr, addr1, val, 1,\n                                                       attrs);\n                break;\n            default:\n                abort();\n            }\n        } else {\n            ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n            memcpy(ptr, buf, l);\n            invalidate_and_set_dirty(mr, addr1, l);\n        }\n        if (release_lock) {\n            qemu_mutex_unlock_iothread();\n            release_lock = false;\n        }\n        len -= l;\n        buf += l;\n        addr += l;\n        if (!len) {\n            break;\n        }\n        l = len;\n        mr = address_space_translate(as, addr, &addr1, &l, true);\n    }\n    return result;\n}", "target": 1}
{"code": "bool f_libxml_disable_entity_loader(bool disable ) {\n  xmlParserInputBufferCreateFilenameFunc old;\n  if (disable) {\n    old = xmlParserInputBufferCreateFilenameDefault(hphp_libxml_input_buffer_noload);\n  } else {\n    old = xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }\n  return (old == hphp_libxml_input_buffer_noload);\n}", "target": 1}
{"code": "static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long start,\n\t\t\t\t\t unsigned long end,\n\t\t\t\t\t long adjust_next)\n{\n\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n\t\treturn;\n\t__vma_adjust_trans_huge(vma, start, end, adjust_next);\n}", "target": 1}
{"code": "static int ip_options_get_finish(struct net *net, struct ip_options **optp,\n\t\t\t\t struct ip_options *opt, int optlen)\n{\n\twhile (optlen & 3)\n\t\topt->__data[optlen++] = IPOPT_END;\n\topt->optlen = optlen;\n\tif (optlen && ip_options_compile(net, opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}", "target": 1}
{"code": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n \tint status = BLKIF_RSP_OKAY;\n \tstruct block_device *bdev = blkif->vbd.bdev;\n \tunsigned long secure;\n \tblkif->st_ds_req++;\n \txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n \terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n \t\t\t\t   req->u.discard.nr_sectors,\n \t\t\t\t   GFP_KERNEL, secure);\n \tif (err == -EOPNOTSUPP) {\n \t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n \t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}", "target": 1}
{"code": "static int snd_hrtimer_start(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\tatomic_set(&stime->running, 0);\n\thrtimer_cancel(&stime->hrt);\n\thrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),\n\t\t      HRTIMER_MODE_REL);\n\tatomic_set(&stime->running, 1);\n\treturn 0;\n}", "target": 1}
{"code": "inline void ComputeInterpolationWeights(\n    const int64 out_size, const int64 in_size, const float scale,\n    const int resolution, InterpolationCache<T_SCALE>* interpolation) {\n  const Scaler scaler;\n  interpolation->lower.resize(out_size + 1);\n  interpolation->upper.resize(out_size + 1);\n  interpolation->lerp.resize(out_size + 1);\n  interpolation->ilerp.resize(out_size + 1);\n  interpolation->lower[out_size] = 0;\n  interpolation->upper[out_size] = 0;\n  for (int64 i = out_size - 1; i >= 0; --i) {\n    const float in = scaler(i, scale);\n    const float in_f = std::floor(in);\n    interpolation->lower[i] =\n        std::max(static_cast<int64>(in_f), static_cast<int64>(0));\n    interpolation->upper[i] =\n        std::min(static_cast<int64>(std::ceil(in)), in_size - 1);\n    interpolation->lerp[i] = in - in_f;\n    interpolation->ilerp[i] =\n        static_cast<T_SCALE>((in - in_f) * (1 << resolution));\n  }\n}", "target": 1}
{"code": "secret (gcry_mpi_t output, gcry_mpi_t input, RSA_secret_key *skey )\n{\n  mpi_normalize (input);\n  if (!skey->p || !skey->q || !skey->u)\n    {\n      mpi_powm (output, input, skey->d, skey->n);\n    }\n  else\n    {\n      gcry_mpi_t m1 = mpi_alloc_secure( mpi_get_nlimbs(skey->n)+1 );\n      gcry_mpi_t m2 = mpi_alloc_secure( mpi_get_nlimbs(skey->n)+1 );\n      gcry_mpi_t h  = mpi_alloc_secure( mpi_get_nlimbs(skey->n)+1 );\n      mpi_sub_ui( h, skey->p, 1  );\n      mpi_fdiv_r( h, skey->d, h );\n      mpi_powm( m1, input, h, skey->p );\n      mpi_sub_ui( h, skey->q, 1  );\n      mpi_fdiv_r( h, skey->d, h );\n      mpi_powm( m2, input, h, skey->q );\n      mpi_sub( h, m2, m1 );\n      if ( mpi_has_sign ( h ) )\n        mpi_add ( h, h, skey->q );\n      mpi_mulm( h, skey->u, h, skey->q );\n      mpi_mul ( h, h, skey->p );\n      mpi_add ( output, m1, h );\n      mpi_free ( h );\n      mpi_free ( m1 );\n      mpi_free ( m2 );\n    }\n}", "target": 1}
{"code": "static void calc_coeff(double mu[4], const int index[4], int prefilter, double r2, double mul)\n{\n    double mul2 = mul * mul, mul3 = mul2 * mul;\n    double kernel[] = {\n        (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,\n        (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,\n        ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,\n         (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,\n     };\n    double mat_freq[13];\n     memcpy(mat_freq, kernel, sizeof(kernel));\n     memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel));\n     int n = 6;\n    coeff_filter(mat_freq, n, kernel);\n    for (int k = 0; k < 2 * prefilter; ++k)\n        coeff_blur121(mat_freq, ++n);\n    double vec_freq[13];\n    n = index[3] + prefilter + 3;\n    calc_gauss(vec_freq, n, r2);\n    memset(vec_freq + n + 1, 0, sizeof(vec_freq) - (n + 1) * sizeof(vec_freq[0]));\n    n -= 3;\n    coeff_filter(vec_freq, n, kernel);\n    for (int k = 0; k < prefilter; ++k)\n        coeff_blur121(vec_freq, --n);\n    double mat[4][4];\n    calc_matrix(mat, mat_freq, index);\n    double vec[4];\n    for (int i = 0; i < 4; ++i)\n        vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]];\n    for (int i = 0; i < 4; ++i) {\n        double res = 0;\n        for (int j = 0; j < 4; ++j)\n            res += mat[i][j] * vec[j];\n        mu[i] = FFMAX(0, res);\n    }\n}", "target": 1}
{"code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n \t\t\ts->append_char(s, c);\n \t\t}\n \t}\n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n }", "target": 1}
{"code": "R_API bool r_sys_mkdirp(const char *dir) {\n\tbool ret = true;\n\tchar slash = R_SYS_DIR[0];\n\tchar *path = strdup (dir), *ptr = path;\n\tif (!path) {\n\t\teprintf (\"r_sys_mkdirp: Unable to allocate memory\\n\");\n\t\treturn false;\n\t}\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __WINDOWS__\n\t{\n\t\tchar *p = strstr (ptr, \":\\\\\");\n\t\tif (p) {\n\t\t\tptr = p + 2;\n\t\t}\n\t}\n#endif\n\tfor (;;) {\n\t\tfor (; *ptr; ptr++) {\n\t\t\tif (*ptr == '/' || *ptr == '\\\\') {\n\t\t\t\tslash = *ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\tfree (path);\n\t\t\treturn false;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\tret = false;\n\t}\n\tfree (path);\n\treturn ret;\n}", "target": 1}
{"code": "static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}", "target": 1}
{"code": "Mgr::IoActionData::operator += (const IoActionData& stats)\n{\n    http_reads += stats.http_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        http_read_hist[i] += stats.http_read_hist[i];\n    ftp_reads += stats.ftp_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        ftp_read_hist[i] += stats.ftp_read_hist[i];\n    gopher_reads += stats.gopher_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        gopher_read_hist[i] += stats.gopher_read_hist[i];\n    return *this;\n}", "target": 1}
{"code": "void main_init() { \n#ifdef USE_SYSTEMD\n    int i;\n    systemd_fds=sd_listen_fds(1);\n    if(systemd_fds<0)\n        fatal(\"systemd initialization failed\");\n    listen_fds_start=SD_LISTEN_FDS_START;\n    for(i=0; i<systemd_fds; ++i)\n        set_nonblock(listen_fds_start+i, 1);\n#else\n    systemd_fds=0; \n    listen_fds_start=3; \n#endif\n    if(ssl_init()) \n        fatal(\"TLS initialization failed\");\n    if(sthreads_init()) \n        fatal(\"Threads initialization failed\");\n    options_defaults();\n    options_apply();\n#ifndef USE_FORK\n    get_limits(); \n#endif\n    fds=s_poll_alloc();\n    if(pipe_init(signal_pipe, \"signal_pipe\"))\n        fatal(\"Signal pipe initialization failed: \"\n            \"check your personal firewall\");\n    if(pipe_init(terminate_pipe, \"terminate_pipe\"))\n        fatal(\"Terminate pipe initialization failed: \"\n            \"check your personal firewall\");\n    stunnel_info(LOG_NOTICE);\n    if(systemd_fds>0)\n        s_log(LOG_INFO, \"Systemd socket activation: %d descriptors received\",\n            systemd_fds);\n}", "target": 1}
{"code": "static void draw_block_rectangle(uint8_t *buf, int sx, int sy, int w, int h, ptrdiff_t stride, int color)\n{\n    for (int x = sx; x < sx + w; x++)\n        buf[x] = color;\n    for (int y = sy; y < sy + h; y++) {\n        buf[sx] = color;\n        buf[sx + w - 1] = color;\n        buf += stride;\n    }\n    for (int x = sx; x < sx + w; x++)\n        buf[x] = color;\n}", "target": 1}
{"code": "static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {\n if (parcel == NULL) {\n SkDebugf(\"-------- unparcel parcel is NULL\\n\");\n return NULL;\n }\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n const bool        isMutable = p->readInt32() != 0;\n const SkColorType colorType = (SkColorType)p->readInt32();\n const SkAlphaType alphaType = (SkAlphaType)p->readInt32();\n const int         width = p->readInt32();\n const int         height = p->readInt32();\n const int         rowBytes = p->readInt32();\n const int         density = p->readInt32();\n if (kN32_SkColorType != colorType &&\n            kRGB_565_SkColorType != colorType &&\n            kARGB_4444_SkColorType != colorType &&\n            kIndex_8_SkColorType != colorType &&\n            kAlpha_8_SkColorType != colorType) {\n SkDebugf(\"Bitmap_createFromParcel unknown colortype: %d\\n\", colorType);\n         return NULL;\n     }\n    SkBitmap* bitmap = new SkBitmap;\n    bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes);\n     SkColorTable* ctable = NULL;\n     if (colorType == kIndex_8_SkColorType) {\n         int count = p->readInt32();\n         if (count > 0) {\n             size_t size = count * sizeof(SkPMColor);\n             const SkPMColor* src = (const SkPMColor*)p->readInplace(size);\n             ctable = new SkColorTable(src, count);\n         }\n     }\n    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable);\n     if (NULL == buffer) {\n         SkSafeUnref(ctable);\n        delete bitmap;\n         return NULL;\n     }\n SkSafeUnref(ctable);\n size_t size = bitmap->getSize();\n    android::Parcel::ReadableBlob blob;\n     android::status_t status = p->readBlob(size, &blob);\n     if (status) {\n         doThrowRE(env, \"Could not read bitmap from parcel blob.\");\n        delete bitmap;\n         return NULL;\n     }\n    bitmap->lockPixels();\n    memcpy(bitmap->getPixels(), blob.data(), size);\n    bitmap->unlockPixels();\n     blob.release();\n    return GraphicsJNI::createBitmap(env, bitmap, buffer, getPremulBitmapCreateFlags(isMutable),\n            NULL, NULL, density);\n }", "target": 1}
{"code": "void ntlm_write_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tStream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));\n\tStream_Write_UINT32(s, header->MessageType);\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tkfree(key->description);\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "rfbProcessClientMessage(rfbClientPtr cl)\n{\n    switch (cl->state) {\n    case RFB_PROTOCOL_VERSION:\n        rfbProcessClientProtocolVersion(cl);\n        return;\n    case RFB_SECURITY_TYPE:\n\trfbAuthProcessSecurityTypeMessage(cl);\n\treturn;\n#ifdef VINO_HAVE_GNUTLS\n    case RFB_TLS_HANDSHAKE:\n\trfbAuthProcessTLSHandshake(cl);\n\treturn;\n#endif\n    case RFB_AUTH_TYPE:\n\trfbAuthProcessAuthTypeMessage(cl);\n\treturn;\n    case RFB_AUTHENTICATION:\n        rfbAuthProcessClientMessage(cl);\n        return;\n    case RFB_AUTH_DEFERRED:\n\trfbLog(\"Authentication deferred - ignoring client message\\n\");\n\treturn;\n    case RFB_INITIALISATION:\n        rfbProcessClientInitMessage(cl);\n        return;\n    default:\n        rfbProcessClientNormalMessage(cl);\n        return;\n    }\n}", "target": 1}
{"code": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n  if (!s)\n    return -1;\n  while (*s)\n  {\n    SKIPWS(s);\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n       }\n       s++;\n       ptmp = tmp;\n      while (*s && *s != '\\\"')\n         *ptmp++ = *s++;\n       if (*s != '\\\"')\n         return -1;\n      s++; \n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n       s += 11;\n       SKIPWS(s);\n       ptmp = tmp;\n      while (isdigit((unsigned char) *s))\n         *ptmp++ = *s++;\n       *ptmp = '\\0';\n       if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\tu64 rem;\n\tnsec = rtc_time() * sgi_clock_period;\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int io_register_personality(struct io_ring_ctx *ctx)\n{\n\tconst struct cred *creds;\n\tu32 id;\n\tint ret;\n\tcreds = get_current_cred();\n\tret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,\n\t\t\tXA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);\n\tif (!ret)\n\t\treturn id;\n\tput_cred(creds);\n\treturn ret;", "target": 1}
{"code": "static void touch_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd)\n{\n\tpmd_t _pmd;\n\t_pmd = pmd_mkyoung(pmd_mkdirty(*pmd));\n\tif (pmdp_set_access_flags(vma, addr & HPAGE_PMD_MASK,\n\t\t\t\tpmd, _pmd,  1))\n\t\tupdate_mmu_cache_pmd(vma, addr, pmd);\n}", "target": 1}
{"code": "l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n}", "target": 1}
{"code": "static void ssl3_take_mac(SSL *s)\n        {\n        const char *sender;\n        int slen;\n        if (s->state & SSL_ST_CONNECT)\n                {\n                sender=s->method->ssl3_enc->server_finished_label;\n\t\tsender=s->method->ssl3_enc->client_finished_label;\n\t\tslen=s->method->ssl3_enc->client_finished_label_len;\n\t\t}\n\ts->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n\t\tsender,slen,s->s3->tmp.peer_finish_md);\n\t}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictFusedBatchNormGrad(\n    const OpContext& op_context, NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(1).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  const auto rsqrt_cost = Eigen::internal::functor_traits<\n      Eigen::internal::scalar_rsqrt_op<float>>::Cost;\n  ops = dims.iz * (dims.batch * dims.ix * dims.iy * 11 + 5 + rsqrt_cost);\n  node_costs->num_compute_ops = ops;\n  const int64_t size_nhwc =\n      CalculateTensorSize(op_info.inputs(1), &found_unknown_shapes);\n  const int64_t size_c =\n      CalculateTensorSize(op_info.inputs(2), &found_unknown_shapes);\n  node_costs->num_input_bytes_accessed = {size_nhwc, size_nhwc, size_c, size_c};\n  node_costs->num_output_bytes_accessed = {size_nhwc, size_c, size_c};\n  node_costs->internal_read_bytes = size_nhwc;\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "_gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,\n                      gcry_mpi_t r, gcry_mpi_t s,\n                      int flags, int hashalgo)\n{\n  gpg_err_code_t rc = 0;\n  int extraloops = 0;\n  gcry_mpi_t k, dr, sum, k_1, x;\n  mpi_point_struct I;\n  gcry_mpi_t hash;\n   const void *abuf;\n   unsigned int abits, qbits;\n   mpi_ec_t ctx;\n   if (DBG_CIPHER)\n     log_mpidump (\"ecdsa sign hash  \", input );\n  rc = _gcry_dsa_normalize_hash (input, &hash, qbits);\n  if (rc)\n    return rc;\n   if (rc)\n     return rc;\n   k = NULL;\n   dr = mpi_alloc (0);\n   sum = mpi_alloc (0);\n    {\n      do\n        {\n          mpi_free (k);\n          k = NULL;\n          if ((flags & PUBKEY_FLAG_RFC6979) && hashalgo)\n            {\n              if (!mpi_is_opaque (input))\n                {\n                  rc = GPG_ERR_CONFLICT;\n                  goto leave;\n                }\n              abuf = mpi_get_opaque (input, &abits);\n              rc = _gcry_dsa_gen_rfc6979_k (&k, skey->E.n, skey->d,\n                                            abuf, (abits+7)/8,\n                                            hashalgo, extraloops);\n              if (rc)\n                goto leave;\n              extraloops++;\n            }\n          else\n            k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);\n          _gcry_mpi_ec_mul_point (&I, k, &skey->E.G, ctx);\n          if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))\n            {\n              if (DBG_CIPHER)\n                log_debug (\"ecc sign: Failed to get affine coordinates\\n\");\n              rc = GPG_ERR_BAD_SIGNATURE;\n              goto leave;\n            }\n          mpi_mod (r, x, skey->E.n);  \n        }\n      while (!mpi_cmp_ui (r, 0));\n      mpi_mulm (dr, skey->d, r, skey->E.n); \n      mpi_addm (sum, hash, dr, skey->E.n);  \n      mpi_invm (k_1, k, skey->E.n);         \n      mpi_mulm (s, k_1, sum, skey->E.n);    \n    }\n  while (!mpi_cmp_ui (s, 0));\n  if (DBG_CIPHER)\n         }", "target": 1}
{"code": "static int dccp_setsockopt_change(struct sock *sk, int type,\n\t\t\t\t  struct dccp_so_feat __user *optval)\n{\n\tstruct dccp_so_feat opt;\n\tu8 *val;\n\tint rc;\n\tif (copy_from_user(&opt, optval, sizeof(opt)))\n\t\treturn -EFAULT;\n\tval = kmalloc(opt.dccpsf_len, GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(val, opt.dccpsf_val, opt.dccpsf_len)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free_val;\n\t}\n\trc = dccp_feat_change(dccp_msk(sk), type, opt.dccpsf_feat,\n\t\t\t      val, opt.dccpsf_len, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out_free_val;\nout:\n\treturn rc;\nout_free_val:\n\tkfree(val);\n\tgoto out;\n}", "target": 1}
{"code": "void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)\n{\n    ASSERT(client()->hasWebView());\n    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)\n        return;\n    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());\n    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));\n    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);\n    ResourceRequest& request = frameLoadRequest.resourceRequest();\n    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))\n        return;\n    if (!shouldClose(navigationType == NavigationTypeReload))\n         return;\n     m_frame->document()->cancelParsing();\n    detachDocumentLoader(m_provisionalDocumentLoader);\n    if (!m_frame->host())\n        return;\n    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));\n    m_provisionalDocumentLoader->setNavigationType(navigationType);\n    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);\n    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);\n    InspectorInstrumentation::didStartProvisionalLoad(m_frame);\n    m_frame->navigationScheduler().cancel();\n    m_checkTimer.stop();\n    m_loadType = type;\n    if (frameLoadRequest.form())\n        client()->dispatchWillSubmitForm(frameLoadRequest.form());\n    m_progressTracker->progressStarted();\n    if (m_provisionalDocumentLoader->isClientRedirect())\n        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());\n    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());\n    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;\n    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);\n    ASSERT(m_provisionalDocumentLoader);\n    m_provisionalDocumentLoader->startLoadingMainResource();\n    takeObjectSnapshot();\n}", "target": 1}
{"code": "decode_bits_in_field(const guint bit_offset, const gint no_of_bits, const guint64 value)\n{\n\tguint64 mask = 0,tmp;\n\tchar *str;\n\tint bit, str_p = 0;\n\tint i;\n\tmask = 1;\n\tmask = mask << (no_of_bits-1);\n\tstr=(char *)wmem_alloc0(wmem_packet_scope(), 256+64);\n\tfor(bit=0;bit<((int)(bit_offset&0x07));bit++){\n\t\tif(bit&&(!(bit%4))){\n\t\t\tstr[str_p] = ' ';\n\t\t\tstr_p++;\n\t\t}\n\t\tstr[str_p] = '.';\n\t\tstr_p++;\n\t}\n\tfor(i=0;i<no_of_bits;i++){\n\t\tif(bit&&(!(bit%4))){\n\t\t\tstr[str_p] = ' ';\n\t\t\tstr_p++;\n\t\t}\n\t\tif(bit&&(!(bit%8))){\n\t\t\tstr[str_p] = ' ';\n\t\t\tstr_p++;\n\t\t}\n\t\tbit++;\n\t\ttmp = value & mask;\n\t\tif(tmp != 0){\n\t\t\tstr[str_p] = '1';\n\t\t\tstr_p++;\n\t\t} else {\n\t\t\tstr[str_p] = '0';\n\t\t\tstr_p++;\n\t\t}\n\t\tmask = mask>>1;\n\t}\n\tfor(;bit%8;bit++){\n\t\tif(bit&&(!(bit%4))){\n\t\t\tstr[str_p] = ' ';\n\t\t\tstr_p++;\n\t\t}\n\t\tstr[str_p] = '.';\n\t\tstr_p++;\n\t}\n\treturn str;\n}", "target": 1}
{"code": "GF_Err tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"TrackEncryptionBox\", trace);\n\tfprintf(trace, \"isEncrypted=\\\"%d\\\"\", ptr->isProtected);\n\tif (ptr->Per_Sample_IV_Size)\n\t\tfprintf(trace, \" IV_size=\\\"%d\\\" KID=\\\"\", ptr->Per_Sample_IV_Size);\n\telse {\n\t\tfprintf(trace, \" constant_IV_size=\\\"%d\\\" constant_IV=\\\"\", ptr->constant_IV_size);\n\t\tdump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tfprintf(trace, \"\\\"  KID=\\\"\");\n\t}\n\tdump_data_hex(trace, (char *) ptr->KID, 16);\n\tif (ptr->version) \n\t\tfprintf(trace, \"\\\" crypt_byte_block=\\\"%d\\\" skip_byte_block=\\\"%d\", ptr->crypt_byte_block, ptr->skip_byte_block);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"TrackEncryptionBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayForeachCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) \n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_Obj *obj;\n    int curlen;\n    uint i;\n    Jsi_Value *func, *vpargs;\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, ret, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return rc;\n}", "target": 1}
{"code": "static TEE_Result do_allocate_keypair(struct ecc_keypair *key,\n\t\t\t\t      uint32_t type __unused,\n\t\t\t\t      size_t size_bits)\n{\n\tECC_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->d = crypto_bignum_allocate(size_bits);\n\tif (!key->d)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tECC_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n{\n\tstruct rtable *rt;\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options *opt = inet_rsk(req)->opt;\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n\t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt))\n\t\tgoto no_route;\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto route_err;\n\treturn &rt->dst;\nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}", "target": 1}
{"code": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\tNT_ASSERT(size);\n#pragma prefast(suppress : 30030)\t\t\n\tCS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\treturn block->data;\n}", "target": 1}
{"code": "bool ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return false;\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return false;\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return false;\n  }\n  CHECK_EQ(1, outputs.size());\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return false;\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return false;\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return false;\n  }\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n  return shape.IsCompatibleWith(new_dims);\n}", "target": 1}
{"code": "netsnmp_mibindex_lookup( const char *dirname )\n{\n    int i;\n    static char tmpbuf[300];\n    for (i=0; i<_mibindex; i++) {\n        if ( _mibindexes[i] &&\n             strcmp( _mibindexes[i], dirname ) == 0) {\n             snprintf(tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                      get_persistent_directory(), i);\n             tmpbuf[sizeof(tmpbuf)-1] = 0;\n             DEBUGMSGTL((\"mibindex\", \"lookup: %s (%d) %s\\n\", dirname, i, tmpbuf ));\n             return tmpbuf;\n        }\n    }\n    DEBUGMSGTL((\"mibindex\", \"lookup: (none)\\n\"));\n    return NULL;\n}", "target": 1}
{"code": "lzw_decoder_feed (LZWDecoder *self,\n                  guint8     *input,\n                  gsize       input_length,\n                  guint8     *output,\n                  gsize       output_length)\n{\n        gsize i, n_written = 0;\n        g_return_val_if_fail (LZW_IS_DECODER (self), 0);\n        if (self->last_code == self->eoi_code)\n                return 0;\n        for (i = 0; i < input_length; i++) {\n                guint8 d = input[i];\n                int n_available;\n                for (n_available = 8; n_available > 0; ) {\n                        int n_bits, new_bits;\n                        n_bits = MIN (self->code_size - self->code_bits, n_available);\n                        new_bits = d & ((1 << n_bits) - 1);\n                        d = d >> n_bits;\n                        n_available -= n_bits;\n                        self->code = new_bits << self->code_bits | self->code;\n                        self->code_bits += n_bits;\n                        if (self->code_bits < self->code_size)\n                                continue;\n                        if (self->code == self->eoi_code) {\n                                self->last_code = self->code;\n                                return n_written;\n                        }\n                        if (self->code == self->clear_code) {\n                                self->code_table_size = self->eoi_code + 1;\n                                self->code_size = self->min_code_size;\n                        } else {\n                                if (self->last_code != self->clear_code && self->code_table_size < MAX_CODES) {\n                                        if (self->code < self->code_table_size)\n                                                add_code (self, self->code);\n                                        else if (self->code == self->code_table_size)\n                                                add_code (self, self->last_code);\n                                        else {\n                                                self->last_code = self->eoi_code;\n                                                return output_length;\n                                        }\n                                        if (self->code_table_size == (1 << self->code_size) && self->code_size < LZW_CODE_MAX)\n                                                self->code_size++;\n                                }\n                                n_written += write_indexes (self, output + n_written, output_length - n_written);\n                        }\n                        self->last_code = self->code;\n                        self->code = 0;\n                        self->code_bits = 0;\n                        if (n_written >= output_length)\n                                return output_length;\n                }\n        }\n        return n_written;\n}", "target": 1}
{"code": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tint ret;\n\tif (unlikely(!out->f_op || !out->f_op->splice_write))\n\t\treturn -EINVAL;\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\tret = rw_verify_area(WRITE, out, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\treturn out->f_op->splice_write(pipe, out, ppos, len, flags);\n}", "target": 1}
{"code": "yank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\twhile (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0)\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}", "target": 1}
{"code": "int ext4_find_inline_data_nolock(struct inode *inode)\n{\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\tint error;\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\tif (!is.s.not_found) {\n\t\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t\t(void *)ext4_raw_inode(&is.iloc));\n\t\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\t\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t}\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}", "target": 1}
{"code": "static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n {\n \tint i;\n \tint nr = pagevec_count(pvec);\n\tint delta_munlocked;\n \tstruct pagevec pvec_putback;\n \tint pgrescued = 0;\n\tpagevec_init(&pvec_putback, 0);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n \t\t\t\tcontinue;\n \t\t\telse\n \t\t\t\t__munlock_isolation_failed(page);\n \t\t}\n \t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n \t\tpvec->pages[i] = NULL;\n \t}\n\tdelta_munlocked = -nr + pagevec_count(&pvec_putback);\n \t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n \tspin_unlock_irq(zone_lru_lock(zone));\n\tpagevec_release(&pvec_putback);\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\tget_page(page); \n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); \n\t\t\t}\n\t\t}\n\t}\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}", "target": 1}
{"code": "  static void setAppend(SetType& set, const VariantType& v) {\n    auto value_type = type(v);\n    if (value_type != HPHP::serialize::Type::INT64 &&\n        value_type != HPHP::serialize::Type::STRING) {\n      throw HPHP::serialize::UnserializeError(\n          \"Unsupported keyset element of type \" +\n          folly::to<std::string>(value_type));\n    }\n    set.append(v);\n  }", "target": 1}
{"code": "void RequestContext::AddInstanceIdentityToken() {\n  if (!method()) {\n    return;\n  }\n  const auto &audience = method()->backend_jwt_audience();\n  if (!audience.empty()) {\n    auto &token = service_context()\n                      ->global_context()\n                      ->GetInstanceIdentityToken(audience)\n                      ->GetAuthToken();\n    if (!token.empty()) {\n      std::string origin_auth_header;\n      if (request()->FindHeader(kAuthorizationHeader, &origin_auth_header)) {\n        Status status = request()->AddHeaderToBackend(\n            kXForwardedAuthorizationHeader, origin_auth_header);\n        if (!status.ok()) {\n          service_context()->env()->LogError(\n              \"Failed to set X-Forwarded-Authorization header to backend.\");\n        }\n      }\n      Status status = request()->AddHeaderToBackend(kAuthorizationHeader,\n                                                    kBearerPrefix + token);\n      if (!status.ok()) {\n        service_context()->env()->LogError(\n            \"Failed to set authorization header to backend.\");\n      }\n    }\n  }\n}", "target": 1}
{"code": "int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\n\tint m;\n\tassert(n >= 0 && n < 32);\n\tassert(!(v & (~JAS_ONES(n))));\n\tm = n - 1;\n\twhile (--n >= 0) {\n\t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\n\t\t\treturn EOF;\n\t\t}\n\t\tv <<= 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n\tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n\tvoid *memory;\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\treturn __dma_alloc(dev, size, handle, gfp, prot, true,\n\t\t\t   __builtin_return_address(0));\n}", "target": 1}
{"code": "int xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct xregs_state *xsave;\n\tint ret;\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn -ENODEV;\n\tif ((pos != 0) || (count < fpu_user_xstate_size))\n\t\treturn -EFAULT;\n\txsave = &fpu->state.xsave;\n\tfpu__activate_fpstate_write(fpu);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES)) {\n\t\tif (kbuf)\n\t\t\tret = copy_kernel_to_xstate(xsave, kbuf);\n\t\telse\n \t\t\tret = copy_user_to_xstate(xsave, ubuf);\n \t} else {\n \t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\n \t}\n\tif (ret)\n\t\tfpstate_init(&fpu->state);\n\txsave->i387.mxcsr &= mxcsr_feature_mask;\n\txsave->header.xfeatures &= xfeatures_mask;\n\tmemset(&xsave->header.reserved, 0, 48);\n\treturn ret;\n}", "target": 1}
{"code": "pacparser_find_proxy(const char *url, const char *host)\n{\n  char *error_prefix = \"pacparser.c: pacparser_find_proxy:\";\n  if (_debug()) print_error(\"DEBUG: Finding proxy for URL: %s and Host:\"\n                        \" %s\\n\", url, host);\n  jsval rval;\n  char *script;\n  if (url == NULL || (strcmp(url, \"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"URL not defined\");\n    return NULL;\n  }\n  if (host == NULL || (strcmp(host,\"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Host not defined\");\n    return NULL;\n  }\n  if (cx == NULL || global == NULL) {\n    print_error(\"%s %s\\n\", error_prefix, \"Pac parser is not initialized.\");\n    return NULL;\n  }\n  script = \"typeof(findProxyForURL);\";\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval);\n  if (strcmp(\"function\", JS_GetStringBytes(JS_ValueToString(cx, rval))) != 0) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Javascript function findProxyForURL not defined.\");\n    return NULL;\n  }\n  char *sanitized_url = str_replace(url, \"'\", \"%27\");\n  if (strchr(host, '\\'')) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t\"Invalid hostname: hostname can't have single quotes.\");\n    return NULL;\n  }\n  script = (char*) malloc(32 + strlen(url) + strlen(host));\n  script[0] = '\\0';\n  strcat(script, \"findProxyForURL('\");\n  strcat(script, sanitized_url);\n  strcat(script, \"', '\");\n  strcat(script, host);\n  strcat(script, \"')\");\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  if (!JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Problem in executing findProxyForURL.\");\n    free(sanitized_url);\n    free(script);\n    return NULL;\n  }\n  free(sanitized_url);\n  free(script);\n  return JS_GetStringBytes(JS_ValueToString(cx, rval));\n}", "target": 1}
{"code": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n        size2 = avio_rb32(pb);\n        ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, mime);\n        if (ret < 0)\n            return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}", "target": 1}
{"code": "static const char *adpt_i2o_get_class_name(int class)\n{\n\tint idx = 16;\n\tstatic char *i2o_class_name[] = {\n\t\t\"Executive\",\n\t\t\"Device Driver Module\",\n\t\t\"Block Device\",\n\t\t\"Tape Device\",\n\t\t\"LAN Interface\",\n\t\t\"WAN Interface\",\n\t\t\"Fibre Channel Port\",\n\t\t\"Fibre Channel Device\",\n\t\t\"SCSI Device\",\n\t\t\"ATE Port\",\n\t\t\"ATE Device\",\n\t\t\"Floppy Controller\",\n\t\t\"Floppy Device\",\n\t\t\"Secondary Bus Port\",\n\t\t\"Peer Transport Agent\",\n\t\t\"Peer Transport\",\n\t\t\"Unknown\"\n\t};\n\tswitch(class&0xFFF) {\n\tcase I2O_CLASS_EXECUTIVE:\n\t\tidx = 0; break;\n\tcase I2O_CLASS_DDM:\n\t\tidx = 1; break;\n\tcase I2O_CLASS_RANDOM_BLOCK_STORAGE:\n\t\tidx = 2; break;\n\tcase I2O_CLASS_SEQUENTIAL_STORAGE:\n\t\tidx = 3; break;\n\tcase I2O_CLASS_LAN:\n\t\tidx = 4; break;\n\tcase I2O_CLASS_WAN:\n\t\tidx = 5; break;\n\tcase I2O_CLASS_FIBRE_CHANNEL_PORT:\n\t\tidx = 6; break;\n\tcase I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL:\n\t\tidx = 7; break;\n\tcase I2O_CLASS_SCSI_PERIPHERAL:\n\t\tidx = 8; break;\n\tcase I2O_CLASS_ATE_PORT:\n\t\tidx = 9; break;\n\tcase I2O_CLASS_ATE_PERIPHERAL:\n\t\tidx = 10; break;\n\tcase I2O_CLASS_FLOPPY_CONTROLLER:\n\t\tidx = 11; break;\n\tcase I2O_CLASS_FLOPPY_DEVICE:\n\t\tidx = 12; break;\n\tcase I2O_CLASS_BUS_ADAPTER_PORT:\n\t\tidx = 13; break;\n\tcase I2O_CLASS_PEER_TRANSPORT_AGENT:\n\t\tidx = 14; break;\n\tcase I2O_CLASS_PEER_TRANSPORT:\n\t\tidx = 15; break;\n\t}\n\treturn i2o_class_name[idx];\n}", "target": 1}
{"code": "static int dv_extract_audio_info(DVDemuxContext* c, uint8_t* frame)\n{\n    const uint8_t* as_pack;\n    int freq, stype, smpls, quant, i, ach;\n    as_pack = dv_extract_pack(frame, dv_audio_source);\n    if (!as_pack || !c->sys) {    \n        c->ach = 0;\n        return 0;\n    }\n    smpls =  as_pack[1] & 0x3f;       \n    freq  = (as_pack[4] >> 3) & 0x07; \n     stype = (as_pack[3] & 0x1f);      \n     quant =  as_pack[4] & 0x07;       \n     ach = ((int[4]){  1,  0,  2,  4})[stype];\n     if (ach == 1 && quant && freq == 2)\n           if (!c->ast[i])\n               break;\n           avpriv_set_pts_info(c->ast[i], 64, 1, 30000);\n           c->ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n           c->ast[i]->codec->codec_id   = CODEC_ID_PCM_S16LE;\n           av_init_packet(&c->audio_pkt[i]);\n           c->audio_pkt[i].size         = 0;\n           c->audio_pkt[i].data         = c->audio_buf[i];\n           c->audio_pkt[i].stream_index = c->ast[i]->index;\n           c->audio_pkt[i].flags       |= AV_PKT_FLAG_KEY;\n       }", "target": 1}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 1}
{"code": "size_t CxMemFile::Read(void *buffer, size_t size, size_t count)\n{\n\tif (buffer==NULL) return 0;\n\tif (m_pBuffer==NULL) return 0;\n\tif (m_Position >= (int32_t)m_Size){\n\t\tm_bEOF = true;\n\t\treturn 0;\n\t}\n\tint32_t nCount = (int32_t)(count*size);\n\tif (nCount == 0) return 0;\n\tint32_t nRead;\n\tif (m_Position + nCount > (int32_t)m_Size){\n\t\tm_bEOF = true;\n\t\tnRead = (m_Size - m_Position);\n\t} else\n\t\tnRead = nCount;\n\tmemcpy(buffer, m_pBuffer + m_Position, nRead);\n\tm_Position += nRead;\n\treturn (size_t)(nRead/size);\n}", "target": 1}
{"code": "static int __init pcd_init(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpcd_init_units();\n\tif (pcd_detect())\n\t\treturn -ENODEV;\n\tpcd_probe_capabilities();\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n\t\t\tput_disk(cd->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tregister_cdrom(&cd->info);\n\t\t\tcd->disk->private_data = cd;\n\t\t\tadd_disk(cd->disk);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n  srcChars += srcStart;\n  if(srcLength < 0) {\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n  int32_t oldLength = length();\n  int32_t newLength = oldLength + srcLength;\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}", "target": 1}
{"code": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\tif (!asoc->temp) {\n \t\tlist_del(&asoc->asocs);\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\tasoc->base.dead = true;\n\tsctp_outq_free(&asoc->outqueue);\n\tsctp_ulpq_free(&asoc->ulpq);\n\tsctp_inq_free(&asoc->base.inqueue);\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\tsctp_ssnmap_free(asoc->ssnmap);\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\tasoc->peer.transport_count = 0;\n\tsctp_asconf_queue_teardown(asoc);\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictMaxPool(const OpContext& op_context,\n                                            NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int per_output_ops = dims.kx * dims.ky == 1 ? 1 : dims.kx * dims.ky - 1;\n  int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * per_output_ops;\n  node_costs->num_compute_ops = ops;\n  int64_t input_size = 0;\n  if (dims.ky >= dims.sy) {\n    input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  } else {  \n    const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype()));\n    input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz;\n  }\n  node_costs->num_input_bytes_accessed = {input_size};\n  const int64_t output_size =\n      CalculateOutputSize(op_info, &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "GopherStateData::iconUrl(const char gtype)\n{\n    switch (gtype) {\n    case GOPHER_DIRECTORY:\n        return mimeGetIconURL(\"internal-menu\");\n    case GOPHER_HTML:\n    case GOPHER_FILE:\n        return mimeGetIconURL(\"internal-text\");\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n        return mimeGetIconURL(\"internal-index\");\n    case GOPHER_IMAGE:\n    case GOPHER_GIF:\n    case GOPHER_PLUS_IMAGE:\n        return mimeGetIconURL(\"internal-image\");\n    case GOPHER_SOUND:\n    case GOPHER_PLUS_SOUND:\n        return mimeGetIconURL(\"internal-sound\");\n    case GOPHER_PLUS_MOVIE:\n        return mimeGetIconURL(\"internal-movie\");\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        return mimeGetIconURL(\"internal-telnet\");\n    case GOPHER_BIN:\n    case GOPHER_MACBINHEX:\n    case GOPHER_DOSBIN:\n    case GOPHER_UUENCODED:\n        return mimeGetIconURL(\"internal-binary\");\n    case GOPHER_INFO:\n        return nullptr;\n    case GOPHER_WWW:\n        return mimeGetIconURL(\"internal-link\");\n    default:\n        return mimeGetIconURL(\"internal-unknown\");\n    }\n}", "target": 1}
{"code": "void Con_Dump_f (void)\n{\n\tint\t\tl, x, i;\n\tshort\t*line;\n\tfileHandle_t\tf;\n\tint\t\tbufferlen;\n\tchar\t*buffer;\n\tchar\tfilename[MAX_QPATH];\n\tif (Cmd_Argc() != 2)\n\t{\n\t\tCom_Printf (\"usage: condump <filename>\\n\");\n\t\treturn;\n\t}\n\tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n\tCOM_DefaultExtension( filename, sizeof( filename ), \".txt\" );\n\tf = FS_FOpenFileWrite( filename );\n\tif (!f)\n\t{\n\t\tCom_Printf (\"ERROR: couldn't open %s.\\n\", filename);\n\t\treturn;\n\t}\n\tCom_Printf (\"Dumped console text to %s.\\n\", filename );\n\tfor (l = con.current - con.totallines + 1 ; l <= con.current ; l++)\n\t{\n\t\tline = con.text + (l%con.totallines)*con.linewidth;\n\t\tfor (x=0 ; x<con.linewidth ; x++)\n\t\t\tif ((line[x] & 0xff) != ' ')\n\t\t\t\tbreak;\n\t\tif (x != con.linewidth)\n\t\t\tbreak;\n\t}\n#ifdef _WIN32\n\tbufferlen = con.linewidth + 3 * sizeof ( char );\n#else\n\tbufferlen = con.linewidth + 2 * sizeof ( char );\n#endif\n\tbuffer = Hunk_AllocateTempMemory( bufferlen );\n\tbuffer[bufferlen-1] = 0;\n\tfor ( ; l <= con.current ; l++)\n\t{\n\t\tline = con.text + (l%con.totallines)*con.linewidth;\n\t\tfor(i=0; i<con.linewidth; i++)\n\t\t\tbuffer[i] = line[i] & 0xff;\n\t\tfor (x=con.linewidth-1 ; x>=0 ; x--)\n\t\t{\n\t\t\tif (buffer[x] == ' ')\n\t\t\t\tbuffer[x] = 0;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n#ifdef _WIN32\n\t\tQ_strcat(buffer, bufferlen, \"\\r\\n\");\n#else\n\t\tQ_strcat(buffer, bufferlen, \"\\n\");\n#endif\n\t\tFS_Write(buffer, strlen(buffer), f);\n\t}\n\tHunk_FreeTempMemory( buffer );\n\tFS_FCloseFile( f );\n}", "target": 1}
{"code": "void ContainerNode::parserInsertBefore(PassRefPtrWillBeRawPtr<Node> newChild, Node& nextChild)\n{\n    ASSERT(newChild);\n    ASSERT(nextChild.parentNode() == this);\n    ASSERT(!newChild->isDocumentFragment());\n    ASSERT(!isHTMLTemplateElement(this));\n    if (nextChild.previousSibling() == newChild || &nextChild == newChild) \n        return;\n    if (!checkParserAcceptChild(*newChild))\n        return;\n    RefPtrWillBeRawPtr<Node> protect(this);\n     while (RefPtrWillBeRawPtr<ContainerNode> parent = newChild->parentNode())\n         parent->parserRemoveChild(*newChild);\n     if (document() != newChild->document())\n         document().adoptNode(newChild.get(), ASSERT_NO_EXCEPTION);\n    {\n        EventDispatchForbiddenScope assertNoEventDispatch;\n        ScriptForbiddenScope forbidScript;\n        treeScope().adoptIfNeeded(*newChild);\n        insertBeforeCommon(nextChild, *newChild);\n        newChild->updateAncestorConnectedSubframeCountForInsertion();\n        ChildListMutationScope(*this).childAdded(*newChild);\n    }\n    notifyNodeInserted(*newChild, ChildrenChangeSourceParser);\n}", "target": 1}
{"code": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MaxTextExtent];\n  const char\n    *option;\n  graph_t\n    *graph;\n  Image\n    *image;\n  ImageInfo\n    *read_info;\n  MagickBooleanType\n    status;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MaxTextExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}", "target": 1}
{"code": " static void print_maps(struct pid_info_t* info)\n {\n     FILE *maps;\n     size_t offset;\n     char device[10];\n     long int inode;\n    char file[PATH_MAX];\n     strlcat(info->path, \"maps\", sizeof(info->path));\n    maps = fopen(info->path, \"r\");\n     if (!maps)\n         goto out;\n    while (fscanf(maps, \"%*x-%*x %*s %zx %s %ld %s\\n\", &offset, device, &inode,\n            file) == 4) {\n         if (inode == 0 || !strcmp(device, \"00:00\"))\n             continue;\n        printf(\"%-9s %5d %10s %4s %9s %18s %9zd %10ld %s\\n\",\n                info->cmdline, info->pid, info->user, \"mem\",\n \"???\", device, offset, inode, file);\n }\n    fclose(maps);\nout:\n    info->path[info->parent_length] = '\\0';\n}", "target": 1}
{"code": " choose_filters(struct archive_read *a)\n {\n\tint number_bidders, i, bid, best_bid;\n \tstruct archive_read_filter_bidder *bidder, *best_bidder;\n \tstruct archive_read_filter *filter;\n \tssize_t avail;\n \tint r;\n\tfor (;;) {\n \t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);\n \t\tbest_bid = 0;\n\t\tbest_bidder = NULL;\n\t\tbidder = a->bidders;\n\t\tfor (i = 0; i < number_bidders; i++, bidder++) {\n\t\t\tif (bidder->bid != NULL) {\n\t\t\t\tbid = (bidder->bid)(bidder, a->filter);\n\t\t\t\tif (bid > best_bid) {\n\t\t\t\t\tbest_bid = bid;\n\t\t\t\t\tbest_bidder = bidder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (best_bidder == NULL) {\n\t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);\n\t\t\tif (avail < 0) {\n\t\t\t\t__archive_read_close_filters(a);\n\t\t\t\t__archive_read_free_filters(a);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->archive.compression_name = a->filter->name;\n\t\t\ta->archive.compression_code = a->filter->code;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\tfilter\n\t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n\t\tif (filter == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfilter->bidder = best_bidder;\n\t\tfilter->archive = a;\n\t\tfilter->upstream = a->filter;\n\t\ta->filter = filter;\n\t\tr = (best_bidder->init)(a->filter);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t__archive_read_close_filters(a);\n\t\t\t__archive_read_free_filters(a);\n \t\t\treturn (ARCHIVE_FATAL);\n \t\t}\n \t}\n }", "target": 1}
{"code": "spnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap(minor_status,\n\t\t\tcontext_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n\t\treturn ret;\n\tbo->dumb = false;\n\tvirtio_gpu_init_ttm_placement(bo, pinned);\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\tif (ret != 0)\n\t\treturn ret;\n\t*bo_ptr = bo;\n\treturn 0;\n}", "target": 1}
{"code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\tunsigned short iport, rport;\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \trport = (unsigned short)atoi(rem_port);\n \tiport = (unsigned short)atoi(int_port);\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\tr = -1;\n\tswitch(r)\n\t{\n\t\tcase 1:\t\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& in_grads = context->input(0);\n    const Tensor& in_image = context->input(1);\n    const Tensor& out_image = context->input(2);\n    OP_REQUIRES(context, in_grads.dims() == 4 && in_image.dims() == 4,\n                errors::InvalidArgument(\"inputs must be 4-dimensional\"));\n    const int64_t batch = in_grads.dim_size(0);\n    const int64_t rows = in_grads.dim_size(1);\n    const int64_t cols = in_grads.dim_size(2);\n    const int64_t depth = in_grads.dim_size(3);\n    OP_REQUIRES(\n        context,\n        in_image.dim_size(0) == batch && in_image.dim_size(1) == rows &&\n            in_image.dim_size(2) == cols && in_image.dim_size(3) == depth &&\n            out_image.dim_size(0) == batch && out_image.dim_size(1) == rows &&\n            out_image.dim_size(2) == cols && out_image.dim_size(3) == depth,\n        errors::InvalidArgument(\n            \"input_grads, input_image, and out_image should have the same \"\n            \"shape\"));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({batch, rows, cols, depth}), &output));\n    LaunchLRNGrad<Device, T> launcher(depth_radius_, bias_, alpha_, beta_);\n    launcher.launch(context, this, in_grads, in_image, out_image, output);\n  }", "target": 1}
{"code": "int mutt_b64_decode(char *out, const char *in)\n{\n  int len = 0;\n  unsigned char digit4;\n  do\n  {\n    const unsigned char digit1 = in[0];\n    if ((digit1 > 127) || (base64val(digit1) == BAD))\n      return -1;\n    const unsigned char digit2 = in[1];\n    if ((digit2 > 127) || (base64val(digit2) == BAD))\n      return -1;\n    const unsigned char digit3 = in[2];\n    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))\n      return -1;\n    digit4 = in[3];\n    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))\n      return -1;\n    in += 4;\n    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);\n    len++;\n    if (digit3 != '=')\n    {\n      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);\n      len++;\n      if (digit4 != '=')\n      {\n        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);\n        len++;\n      }\n    }\n  } while (*in && digit4 != '=');\n  return len;\n}", "target": 1}
{"code": "static const char *quote_arg(const char *arg)\n{\n\tint len = 0, n = 0;\n\tint force_quotes = 0;\n\tchar *q, *d;\n\tconst char *p = arg;\n\tif (!*p) force_quotes = 1;\n\twhile (*p) {\n\t\tif (isspace(*p) || *p == '*' || *p == '?' || *p == '{' || *p == '\\'')\n\t\t\tforce_quotes = 1;\n\t\telse if (*p == '\"')\n\t\t\tn++;\n\t\telse if (*p == '\\\\') {\n\t\t\tint count = 0;\n\t\t\twhile (*p == '\\\\') {\n\t\t\t\tcount++;\n\t\t\t\tp++;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (*p == '\"')\n\t\t\t\tn += count*2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tlen++;\n\t\tp++;\n\t}\n\tif (!force_quotes && n == 0)\n\t\treturn arg;\n\td = q = xmalloc(st_add3(len, n, 3));\n\t*d++ = '\"';\n\twhile (*arg) {\n\t\tif (*arg == '\"')\n\t\t\t*d++ = '\\\\';\n\t\telse if (*arg == '\\\\') {\n\t\t\tint count = 0;\n\t\t\twhile (*arg == '\\\\') {\n\t\t\t\tcount++;\n\t\t\t\t*d++ = *arg++;\n\t\t\t}\n\t\t\tif (*arg == '\"') {\n\t\t\t\twhile (count-- > 0)\n\t\t\t\t\t*d++ = '\\\\';\n\t\t\t\t*d++ = '\\\\';\n\t\t\t}\n\t\t}\n\t\t*d++ = *arg++;\n\t}\n\t*d++ = '\"';\n\t*d++ = 0;\n\treturn q;\n}", "target": 1}
{"code": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n \t\t      gpointer user_data)\n {\n \tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler->opaque;\n \tif (!handler) {\n \t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n\t\t\t\t      \"unknown subtype\"));\n\t\treturn TRUE;\n\t}\n\tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n\tg_bus_unwatch_name(info->watcher_id);\n\tg_free(info);\n\tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}", "target": 1}
{"code": "static int websocket_send(lua_State *L) {\n    lastCFunction = __func__;\n    std::string str = checkstring(L, 1);\n    if (config.http_max_websocket_message > 0 && str.size() > (unsigned)config.http_max_websocket_message) luaL_error(L, \"Message is too large\");\n    ws_handle * ws = *(ws_handle**)lua_touserdata(L, lua_upvalueindex(1));\n    if (ws == NULL) luaL_error(L, \"attempt to use a closed file\");\n    std::lock_guard<std::mutex> lock(ws->lock);\n    if (ws->ws == NULL) return luaL_error(L, \"attempt to use a closed file\");\n    if (ws->ws->sendFrame(str.c_str(), str.size(), (int)WebSocket::FRAME_FLAG_FIN | (int)(lua_toboolean(L, 2) ? WebSocket::FRAME_BINARY : WebSocket::FRAME_TEXT)) < 1) \n        websocket_close(L);\n    return 0;\n}", "target": 1}
{"code": "int MonClient::handle_auth_request(\n  Connection *con,\n  AuthConnectionMeta *auth_meta,\n  bool more,\n  uint32_t auth_method,\n  const bufferlist& payload,\n  bufferlist *reply)\n{\n  auth_meta->auth_mode = payload[0];\n  if (auth_meta->auth_mode < AUTH_MODE_AUTHORIZER ||\n      auth_meta->auth_mode > AUTH_MODE_AUTHORIZER_MAX) {\n    return -EACCES;\n  }\n  AuthAuthorizeHandler *ah = get_auth_authorize_handler(con->get_peer_type(),\n\t\t\t\t\t\t\tauth_method);\n  if (!ah) {\n    lderr(cct) << __func__ << \" no AuthAuthorizeHandler found for auth method \"\n\t       << auth_method << dendl;\n    return -EOPNOTSUPP;\n  }\n  auto ac = &auth_meta->authorizer_challenge;\n  if (!HAVE_FEATURE(con->get_features(), CEPHX_V2)) {\n    if (cct->_conf->cephx_service_require_version >= 2) {\n      ldout(cct,10) << __func__ << \" client missing CEPHX_V2 (\"\n\t\t    << \"cephx_service_requre_version = \"\n\t\t    << cct->_conf->cephx_service_require_version << \")\" << dendl;\n      return -EACCES;\n    }\n    ac = nullptr;\n  }\n  bool was_challenge = (bool)auth_meta->authorizer_challenge;\n  bool isvalid = ah->verify_authorizer(\n    cct,\n    rotating_secrets.get(),\n    payload,\n    auth_meta->get_connection_secret_length(),\n    reply,\n    &con->peer_name,\n    &con->peer_global_id,\n    &con->peer_caps_info,\n    &auth_meta->session_key,\n    &auth_meta->connection_secret,\n    ac);\n  if (isvalid) {\n    handle_authentication_dispatcher->ms_handle_authentication(con);\n    return 1;\n  }\n  if (!more && !was_challenge && auth_meta->authorizer_challenge) {\n    ldout(cct,10) << __func__ << \" added challenge on \" << con << dendl;\n    return 0;\n  }\n  ldout(cct,10) << __func__ << \" bad authorizer on \" << con << dendl;\n  return -EACCES;\n}", "target": 1}
{"code": "add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    }\n    DEBUGMSGTL((\"parse-mibs\", \"Checking file: %s...\\n\",\n                tmpstr));\n    mibLine = 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        if (ip)\n            fprintf(ip, \"%s %s\\n\", token, d_name);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}", "target": 1}
{"code": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\tif (!domain)\n\t\treturn 0;\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n \t\tif (is_error_noslot_pfn(pfn)) {\n \t\t\tgfn += 1;\n \t\t\tcontinue;\n\t\t}\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n \t\tif (r) {\n \t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n \t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size);\n \t\t\tgoto unmap_pages;\n \t\t}\n\t\tgfn += page_size >> PAGE_SHIFT;\n\t}\n\treturn 0;\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}", "target": 1}
{"code": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}", "target": 1}
{"code": "int nfs4_do_close(struct path *path, struct nfs4_state *state, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\tcalldata = kmalloc(sizeof(*calldata), GFP_KERNEL);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\tcalldata->arg.stateid = &state->open_stateid;\n\tcalldata->arg.seqid = nfs_alloc_seqid(&state->owner->so_seqid);\n\tif (calldata->arg.seqid == NULL)\n\t\tgoto out_free_calldata;\n\tcalldata->arg.open_flags = 0;\n\tcalldata->arg.bitmask = server->attr_bitmask;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->path.mnt = mntget(path->mnt);\n\tcalldata->path.dentry = dget(path->dentry);\n\tmsg.rpc_argp = &calldata->arg,\n\tmsg.rpc_resp = &calldata->res,\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}", "target": 1}
{"code": "cvtchar(register const char *sp)\n{\n    unsigned char c = 0;\n    int len;\n    switch (*sp) {\n    case '\\\\':\n\tswitch (*++sp) {\n\tcase '\\'':\n\tcase '$':\n\tcase '\\\\':\n\tcase '%':\n\t    c = UChar(*sp);\n\t    len = 2;\n\t    break;\n\tcase '\\0':\n\t    c = '\\\\';\n\t    len = 1;\n\t    break;\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\t    len = 1;\n\t    while (isdigit(UChar(*sp))) {\n\t\tc = UChar(8 * c + (*sp++ - '0'));\n\t\tlen++;\n\t    }\n\t    break;\n\tdefault:\n\t    c = UChar(*sp);\n\t    len = (c != '\\0') ? 2 : 1;\n\t    break;\n\t}\n\tbreak;\n    case '^':\n\tc = UChar(*++sp);\n\tif (c == '?')\n\t    c = 127;\n\telse\n\t    c &= 0x1f;\n\tlen = 2;\n\tbreak;\n    default:\n\tc = UChar(*sp);\n\tlen = (c != '\\0') ? 1 : 0;\n    }\n    if (isgraph(c) && c != ',' && c != '\\'' && c != '\\\\' && c != ':') {\n\tdp = save_string(dp, \"%\\'\");\n\tdp = save_char(dp, c);\n\tdp = save_char(dp, '\\'');\n    } else if (c != '\\0') {\n\tdp = save_string(dp, \"%{\");\n\tif (c > 99)\n\t    dp = save_char(dp, c / 100 + '0');\n\tif (c > 9)\n\t    dp = save_char(dp, ((int) (c / 10)) % 10 + '0');\n\tdp = save_char(dp, c % 10 + '0');\n\tdp = save_char(dp, '}');\n    }\n    return len;\n}", "target": 1}
{"code": "gxps_archive_input_stream_read (GInputStream  *stream,\n\t\t\t\tvoid          *buffer,\n\t\t\t\tgsize          count,\n\t\t\t\tGCancellable  *cancellable,\n\t\t\t\tGError       **error)\n{\n\tGXPSArchiveInputStream *istream = GXPS_ARCHIVE_INPUT_STREAM (stream);\n        gssize                  bytes_read;\n\tif (g_cancellable_set_error_if_cancelled (cancellable, error))\n\t\treturn -1;\n        bytes_read = archive_read_data (istream->zip->archive, buffer, count);\n        if (bytes_read == 0 && istream->is_interleaved && !gxps_archive_input_stream_is_last_piece (istream)) {\n                gxps_archive_input_stream_next_piece (istream);\n                bytes_read = gxps_archive_input_stream_read (stream, buffer, count, cancellable, error);\n        }\n\treturn bytes_read;\n}", "target": 1}
{"code": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t}\n\telse if (rc == -ENODATA)\n\t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n\treturn rc;\n}", "target": 1}
{"code": "xfs_attr_calc_size(\n\tstruct xfs_inode \t*ip,\n\tint\t\t\tnamelen,\n\tint\t\t\tvaluelen,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount \t*mp = ip->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\tsize = xfs_attr_leaf_newentsize(namelen, valuelen,\n\t\t\t\t\tmp->m_sb.sb_blocksize, local);\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (mp->m_sb.sb_blocksize >> 1)) {\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\tuint\tdblocks = XFS_B_TO_FSB(mp, valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\treturn nblks;\n}", "target": 1}
{"code": "static int tc_fill_qdisc(struct sk_buff *skb, struct Qdisc *q, u32 clid,\n\t\t\t u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tstruct gnet_dump d;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = q->dev->ifindex;\n\ttcm->tcm_parent = clid;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = atomic_read(&q->refcnt);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, q->ops->id);\n\tif (q->ops->dump && q->ops->dump(q, skb) < 0)\n\t\tgoto rtattr_failure;\n\tq->qstats.qlen = q->q.qlen;\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS,\n\t\t\tTCA_XSTATS, q->stats_lock, &d) < 0)\n\t\tgoto rtattr_failure;\n\tif (q->ops->dump_stats && q->ops->dump_stats(q, &d) < 0)\n\t\tgoto rtattr_failure;\n\tif (gnet_stats_copy_basic(&d, &q->bstats) < 0 ||\n#ifdef CONFIG_NET_ESTIMATOR\n\t    gnet_stats_copy_rate_est(&d, &q->rate_est) < 0 ||\n#endif\n\t    gnet_stats_copy_queue(&d, &q->qstats) < 0)\n\t\tgoto rtattr_failure;\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto rtattr_failure;\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static int on_version_message(struct nvnc_client* client)\n{\n\tstruct nvnc* server = client->server;\n\tif (client->buffer_len - client->buffer_index < 12)\n\t\treturn 0;\n\tchar version_string[13];\n\tmemcpy(version_string, client->msg_buffer + client->buffer_index, 12);\n\tversion_string[12] = '\\0';\n\tif (strcmp(RFB_VERSION_MESSAGE, version_string) != 0)\n\t\treturn handle_unsupported_version(client);\n\tuint8_t buf[sizeof(struct rfb_security_types_msg) +\n\t\tSECURITY_TYPES_MAX] = {};\n\tstruct rfb_security_types_msg* security =\n\t\t(struct rfb_security_types_msg*)buf;\n\tsecurity->n = 0;\n\tif (server->auth_flags & NVNC_AUTH_REQUIRE_AUTH) {\n\t\tassert(server->auth_fn);\n#ifdef ENABLE_TLS\n\t\tif (server->tls_creds) {\n\t\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_VENCRYPT;\n\t\t}\n#endif\n#ifdef HAVE_CRYPTO\n\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES256;\n\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES;\n\t\tif (!(server->auth_flags & NVNC_AUTH_REQUIRE_ENCRYPTION)) {\n\t\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_APPLE_DH;\n\t\t}\n#endif\n\t} else {\n\t\tsecurity->n = 1;\n\t\tsecurity->types[0] = RFB_SECURITY_TYPE_NONE;\n\t}\n\tif (security->n == 0) {\n\t\tnvnc_log(NVNC_LOG_PANIC, \"Failed to satisfy requested security constraints\");\n\t}\n\tstream_write(client->net_stream, security, sizeof(*security) +\n\t\t\tsecurity->n, NULL, NULL);\n\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_SECURITY;\n\treturn 12;\n}", "target": 1}
{"code": "int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,\n    const char *name, size_t namelen)\n {\n \tchar *copy;\n\tif (name && memchr(name, '\\0', namelen))\n\t\treturn 0;\n\tif (mode == SET_HOST && id->hosts) {\n\t\tstring_stack_free(id->hosts);\n\t\tid->hosts = NULL;\n\t}\n\tif (name == NULL || namelen == 0)\n\t\treturn 1;\n\tcopy = strndup(name, namelen);\n\tif (copy == NULL)\n\t\treturn 0;\n\tif (id->hosts == NULL &&\n\t    (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {\n\t\tfree(copy);\n\t\treturn 0;\n\t}\n\tif (!sk_OPENSSL_STRING_push(id->hosts, copy)) {\n\t\tfree(copy);\n\t\tif (sk_OPENSSL_STRING_num(id->hosts) == 0) {\n\t\t\tsk_OPENSSL_STRING_free(id->hosts);\n\t\t\tid->hosts = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n {\n\tget_page(buf->page);\n }", "target": 1}
{"code": "static int discovery_stop(struct discovery_client *client)\n{\n\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\tif (adapter->discovery_discoverable)\n\t\tset_discovery_discoverable(adapter, false);\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\t\ttrigger_passive_scanning(adapter);\n\t\treturn 0;\n\t}\n\tcp.type = adapter->discovery_type;\n\tadapter->client = client;\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tstop_discovery_complete, adapter, NULL);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "int __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask)\n{\n\tstruct dentry *parent;\n\tstruct inode *p_inode;\n\tint ret = 0;\n\tif (!dentry)\n\t\tdentry = path->dentry;\n\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\treturn 0;\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\tif (unlikely(!fsnotify_inode_watches_children(p_inode)))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\telse if (p_inode->i_fsnotify_mask & mask) {\n\t\tmask |= FS_EVENT_ON_CHILD;\n\t\tif (path)\n\t\t\tret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\n\t\t\t\t       dentry->d_name.name, 0);\n\t\telse\n\t\t\tret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t       dentry->d_name.name, 0);\n\t}\n\tdput(parent);\n\treturn ret;\n}", "target": 1}
{"code": "static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"givcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<built-in>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; \n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  char ptr; \n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  return 1000000 - count; \n#else\n  return 1000000; \n#endif\n}", "target": 1}
{"code": "evbuffer_add(struct evbuffer *buf, const void *data_in, size_t datlen)\n{\n\tstruct evbuffer_chain *chain, *tmp;\n\tconst unsigned char *data = data_in;\n\tsize_t remain, to_alloc;\n\tint result = -1;\n\tEVBUFFER_LOCK(buf);\n\tif (buf->freeze_end) {\n\t\tgoto done;\n\t}\n\tchain = buf->last;\n\tif (chain == NULL) {\n\t\tchain = evbuffer_chain_new(datlen);\n\t\tif (!chain)\n\t\t\tgoto done;\n\t\tevbuffer_chain_insert(buf, chain);\n\t}\n\tif ((chain->flags & EVBUFFER_IMMUTABLE) == 0) {\n\t\tremain = (size_t)(chain->buffer_len - chain->misalign - chain->off);\n\t\tif (remain >= datlen) {\n\t\t\tmemcpy(chain->buffer + chain->misalign + chain->off,\n\t\t\t    data, datlen);\n\t\t\tchain->off += datlen;\n\t\t\tbuf->total_len += datlen;\n\t\t\tbuf->n_add_for_cb += datlen;\n\t\t\tgoto out;\n\t\t} else if (!CHAIN_PINNED(chain) &&\n\t\t    evbuffer_chain_should_realign(chain, datlen)) {\n\t\t\tevbuffer_chain_align(chain);\n\t\t\tmemcpy(chain->buffer + chain->off, data, datlen);\n\t\t\tchain->off += datlen;\n\t\t\tbuf->total_len += datlen;\n\t\t\tbuf->n_add_for_cb += datlen;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tremain = 0;\n\t}\n\tto_alloc = chain->buffer_len;\n\tif (to_alloc <= EVBUFFER_CHAIN_MAX_AUTO_SIZE/2)\n\t\tto_alloc <<= 1;\n\tif (datlen > to_alloc)\n\t\tto_alloc = datlen;\n\ttmp = evbuffer_chain_new(to_alloc);\n\tif (tmp == NULL)\n\t\tgoto done;\n\tif (remain) {\n\t\tmemcpy(chain->buffer + chain->misalign + chain->off,\n\t\t    data, remain);\n\t\tchain->off += remain;\n\t\tbuf->total_len += remain;\n\t\tbuf->n_add_for_cb += remain;\n\t}\n\tdata += remain;\n\tdatlen -= remain;\n\tmemcpy(tmp->buffer, data, datlen);\n\ttmp->off = datlen;\n\tevbuffer_chain_insert(buf, tmp);\n\tbuf->n_add_for_cb += datlen;\nout:\n\tevbuffer_invoke_callbacks(buf);\n\tresult = 0;\ndone:\n\tEVBUFFER_UNLOCK(buf);\n\treturn result;\n}", "target": 1}
{"code": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\n                            const char *snapshot_id,\n                            const char *name,\n                            Error **errp)\n{\n    int i, snapshot_index;\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *sn;\n    uint64_t *new_l1_table;\n    int new_l1_bytes;\n    int ret;\n    assert(bs->read_only);\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n    if (snapshot_index < 0) {\n        error_setg(errp,\n                   \"Can't find snapshot\");\n        return -ENOENT;\n    }\n     sn = &s->snapshots[snapshot_index];\n     new_l1_bytes = sn->l1_size * sizeof(uint64_t);\n     new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\n        return ret;\n    }", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const Tensor& input_min_tensor = ctx->input(1);\n    const Tensor& input_max_tensor = ctx->input(2);\n    int num_slices = 1;\n    if (axis_ > -1) {\n      num_slices = input.dim_size(axis_);\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n    Tensor float_output =\n        need_cast_ ? tensorflow::Tensor(DT_FLOAT, input.shape()) : *output;\n    if (num_slices == 1) {\n      const float min_range = input_min_tensor.flat<float>()(0);\n      const float max_range = input_max_tensor.flat<float>()(0);\n      DequantizeTensor(ctx, input, min_range, max_range, &float_output);\n    } else {\n      OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                  errors::Unimplemented(\"MIN_FIRST mode is not implemented for \"\n                                        \"Dequantize with axis != -1.\"));\n      int64 pre_dim = 1, post_dim = 1;\n      for (int i = 0; i < axis_; ++i) {\n        pre_dim *= float_output.dim_size(i);\n      }\n      for (int i = axis_ + 1; i < float_output.dims(); ++i) {\n        post_dim *= float_output.dim_size(i);\n      }\n      auto input_tensor = input.template bit_casted_shaped<T, 3>(\n          {pre_dim, num_slices, post_dim});\n      auto output_tensor =\n          float_output.flat_inner_outer_dims<float, 3>(axis_ - 1);\n      auto min_ranges = input_min_tensor.vec<float>();\n      auto max_ranges = input_max_tensor.vec<float>();\n      for (int i = 0; i < num_slices; ++i) {\n        DequantizeSlice(ctx->eigen_device<Device>(), ctx,\n                        input_tensor.template chip<1>(i), min_ranges(i),\n                        max_ranges(i), output_tensor.template chip<1>(i));\n      }\n    }\n    if (need_cast_) {\n      S* out_ptr = output->flat<S>().data();\n      float* in_ptr = float_output.flat<float>().data();\n      for (int64 i = 0; i < float_output.NumElements(); ++i) {\n        out_ptr[i] = static_cast<S>(in_ptr[i]);\n      }\n    }\n  }", "target": 1}
{"code": "doIgnoreSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n                const char *end, const char **nextPtr, XML_Bool haveMore) {\n  const char *next = *startPtr; \n  int tok;\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n  tok = XmlIgnoreSectionTok(enc, s, end, &next);\n#  ifdef XML_DTD\n  if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#  endif\n  *eventEndPP = next;\n  switch (tok) {\n  case XML_TOK_IGNORE_SECT:\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n    *startPtr = next;\n    *nextPtr = next;\n    if (parser->m_parsingStatus.parsing == XML_FINISHED)\n      return XML_ERROR_ABORTED;\n    else\n      return XML_ERROR_NONE;\n  case XML_TOK_INVALID:\n    *eventPP = next;\n    return XML_ERROR_INVALID_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_PARTIAL_CHAR;\n  case XML_TOK_PARTIAL:\n  case XML_TOK_NONE:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_SYNTAX; \n  default:\n    *eventPP = next;\n    return XML_ERROR_UNEXPECTED_STATE;\n  }\n}", "target": 1}
{"code": "static int ext4_xattr_make_inode_space(handle_t *handle, struct inode *inode,\n\t\t\t\t       struct ext4_inode *raw_inode,\n\t\t\t\t       int isize_diff, size_t ifree,\n\t\t\t\t       size_t bfree, int *total_ino)\n{\n\tstruct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);\n\tstruct ext4_xattr_entry *small_entry;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_entry *last;\n\tunsigned int entry_size;\t\n\tunsigned int total_size;\t\n\tunsigned int min_total_size;\n\tint error;\n\twhile (isize_diff > ifree) {\n\t\tentry = NULL;\n\t\tsmall_entry = NULL;\n\t\tmin_total_size = ~0U;\n\t\tlast = IFIRST(header);\n\t\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\t\ttotal_size = EXT4_XATTR_LEN(last->e_name_len);\n\t\t\tif (!last->e_value_inum)\n\t\t\t\ttotal_size += EXT4_XATTR_SIZE(\n\t\t\t\t\t       le32_to_cpu(last->e_value_size));\n\t\t\tif (total_size <= bfree &&\n\t\t\t    total_size < min_total_size) {\n\t\t\t\tif (total_size + ifree < isize_diff) {\n\t\t\t\t\tsmall_entry = last;\n\t\t\t\t} else {\n\t\t\t\t\tentry = last;\n\t\t\t\t\tmin_total_size = total_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (entry == NULL) {\n\t\t\tif (small_entry == NULL)\n\t\t\t\treturn -ENOSPC;\n\t\t\tentry = small_entry;\n\t\t}\n\t\tentry_size = EXT4_XATTR_LEN(entry->e_name_len);\n\t\ttotal_size = entry_size;\n\t\tif (!entry->e_value_inum)\n\t\t\ttotal_size += EXT4_XATTR_SIZE(\n\t\t\t\t\t      le32_to_cpu(entry->e_value_size));\n\t\terror = ext4_xattr_move_to_block(handle, inode, raw_inode,\n\t\t\t\t\t\t entry);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*total_ino -= entry_size;\n\t\tifree += total_size;\n\t\tbfree -= total_size;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n\t\t\t\t\t   __u8 type, __u8 flags, int paylen,\n\t\t\t\t\t   gfp_t gfp)\n{\n\tstruct sctp_chunkhdr *chunk_hdr;\n\tstruct sctp_chunk *retval;\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tskb = alloc_skb(SCTP_PAD4(sizeof(*chunk_hdr) + paylen), gfp);\n\tif (!skb)\n\t\tgoto nodata;\n\tchunk_hdr = (struct sctp_chunkhdr *)skb_put(skb, sizeof(*chunk_hdr));\n\tchunk_hdr->type\t  = type;\n\tchunk_hdr->flags  = flags;\n\tchunk_hdr->length = htons(sizeof(*chunk_hdr));\n\tsk = asoc ? asoc->base.sk : NULL;\n\tretval = sctp_chunkify(skb, asoc, sk, gfp);\n\tif (!retval) {\n\t\tkfree_skb(skb);\n\t\tgoto nodata;\n\t}\n\tretval->chunk_hdr = chunk_hdr;\n\tretval->chunk_end = ((__u8 *)chunk_hdr) + sizeof(*chunk_hdr);\n\tif (sctp_auth_send_cid(type, asoc))\n\t\tretval->auth = 1;\n\treturn retval;\nnodata:\n\treturn NULL;\n}", "target": 1}
{"code": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}", "target": 1}
{"code": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}", "target": 1}
{"code": "static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,\n\t\t\t      struct sys_reg_params *p,\n\t\t\t      const struct sys_reg_desc *r)\n{\n\tu64 idx;\n\tif (!kvm_arm_pmu_v3_ready(vcpu))\n\t\treturn trap_raz_wi(vcpu, p, r);\n\tif (r->CRn == 9 && r->CRm == 13) {\n\t\tif (r->Op2 == 2) {\n\t\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = vcpu_sys_reg(vcpu, PMSELR_EL0)\n\t\t\t      & ARMV8_PMU_COUNTER_MASK;\n\t\t} else if (r->Op2 == 0) {\n\t\t\tif (pmu_access_cycle_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = ARMV8_PMU_CYCLE_IDX;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t} else if (r->CRn == 14 && (r->CRm & 12) == 8) {\n\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n\t} else {\n\t\tBUG();\n\t}\n\tif (!pmu_counter_idx_valid(vcpu, idx))\n\t\treturn false;\n\tif (p->is_write) {\n\t\tif (pmu_access_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tkvm_pmu_set_counter_value(vcpu, idx, p->regval);\n\t} else {\n\t\tp->regval = kvm_pmu_get_counter_value(vcpu, idx);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "int bson_ensure_space( bson *b, const int bytesNeeded ) {\n    int pos = b->cur - b->data;\n    char *orig = b->data;\n    int new_size;\n    if ( pos + bytesNeeded <= b->dataSize )\n        return BSON_OK;\n    new_size = 1.5 * ( b->dataSize + bytesNeeded );\n    if( new_size < b->dataSize ) {\n        if( ( b->dataSize + bytesNeeded ) < INT_MAX )\n            new_size = INT_MAX;\n        else {\n            b->err = BSON_SIZE_OVERFLOW;\n            return BSON_ERROR;\n        }\n    }\n    b->data = bson_realloc( b->data, new_size );\n    if ( !b->data )\n        bson_fatal_msg( !!b->data, \"realloc() failed\" );\n    b->dataSize = new_size;\n    b->cur += b->data - orig;\n    return BSON_OK;\n}", "target": 1}
{"code": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler ? handler->opaque : NULL;\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n \t\t\t\t      \"unknown subtype\"));\n \t\treturn TRUE;\n \t}\n \tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}", "target": 1}
{"code": "bool Performance::PassesTimingAllowCheck(\n    const ResourceResponse& response,\n     const SecurityOrigin& initiator_security_origin,\n     const AtomicString& original_timing_allow_origin,\n     ExecutionContext* context) {\n   scoped_refptr<const SecurityOrigin> resource_origin =\n      SecurityOrigin::Create(response.Url());\n   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))\n     return true;\n  const AtomicString& timing_allow_origin_string =\n      original_timing_allow_origin.IsEmpty()\n          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)\n          : original_timing_allow_origin;\n  if (timing_allow_origin_string.IsEmpty() ||\n      EqualIgnoringASCIICase(timing_allow_origin_string, \"null\"))\n    return false;\n  if (timing_allow_origin_string == \"*\") {\n    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);\n    return true;\n  }\n  const String& security_origin = initiator_security_origin.ToString();\n  Vector<String> timing_allow_origins;\n  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);\n  if (timing_allow_origins.size() > 1) {\n    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);\n  } else if (timing_allow_origins.size() == 1 &&\n             timing_allow_origin_string != \"*\") {\n    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);\n  }\n  for (const String& allow_origin : timing_allow_origins) {\n    const String allow_origin_stripped = allow_origin.StripWhiteSpace();\n    if (allow_origin_stripped == security_origin ||\n        allow_origin_stripped == \"*\") {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "static int rtsx_usb_ms_drv_remove(struct platform_device *pdev)\n{\n\tstruct rtsx_usb_ms *host = platform_get_drvdata(pdev);\n\tstruct memstick_host *msh = host->msh;\n\tint err;\n\thost->eject = true;\n\tcancel_work_sync(&host->handle_req);\n\tmutex_lock(&host->host_mutex);\n\tif (host->req) {\n\t\tdev_dbg(ms_dev(host),\n\t\t\t\"%s: Controller removed during transfer\\n\",\n\t\t\tdev_name(&msh->dev));\n\t\thost->req->error = -ENOMEDIUM;\n\t\tdo {\n\t\t\terr = memstick_next_req(msh, &host->req);\n\t\t\tif (!err)\n\t\t\t\thost->req->error = -ENOMEDIUM;\n\t\t} while (!err);\n\t}\n\tmutex_unlock(&host->host_mutex);\n\tmemstick_remove_host(msh);\n\tmemstick_free_host(msh);\n\tif (pm_runtime_active(ms_dev(host)))\n\t\tpm_runtime_put(ms_dev(host));\n\tpm_runtime_disable(ms_dev(host));\n\tplatform_set_drvdata(pdev, NULL);\n\tdev_dbg(ms_dev(host),\n\t\t\": Realtek USB Memstick controller has been removed\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "char *strdup(const char *s1)\n{\n\tchar *s2 = 0;\n\tif (s1) {\n\t\ts2 = malloc(strlen(s1) + 1);\n\t\tstrcpy(s2, s1);\n\t}\n\treturn s2;\n}", "target": 1}
{"code": "add_link_ref(\n\tstruct link_ref **references,\n\tconst uint8_t *name, size_t name_size)\n{\n\tstruct link_ref *ref = calloc(1, sizeof(struct link_ref));\n\tif (!ref)\n\t\treturn NULL;\n\tref->id = hash_link_ref(name, name_size);\n\tref->next = references[ref->id % REF_TABLE_SIZE];\n\treferences[ref->id % REF_TABLE_SIZE] = ref;\n\treturn ref;\n}", "target": 1}
{"code": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n  const MagicInfo\n    *magic_info;    \n  FILE\n    *ps_file;\n  ImageInfo\n    *clone_info;\n  Image\n    *image2;\n  unsigned char\n    magick[2*MagickPathExtent];    \n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n  (void) CopyMagickMemory(clone_info->magick,magic_info->name,MagickPathExtent);\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n  if (!image2)\n    goto FINISH_UNL;\n  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n  AppendImageToList(&image,image2);\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1}
{"code": "lldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n    tlen = len;\n    tptr = pptr;\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n    if (tlen) {\n        oid_len = *tptr;\n        if (tlen < oid_len) {\n            return 0;\n        }\n        if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n    return 1;\n}", "target": 1}
{"code": "static void my_free(void *ptr)\n{\n    free_called += 1;\n    free(ptr);\n}", "target": 1}
{"code": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret)\n{\n\tMD5_CTX md5_secret, my_md5;\n\tunsigned char misc[AUTH_VECTOR_LEN];\n\tint i;\n\tint length = strlen(password);\n\tunsigned char hashed[256 + AUTH_PASS_LEN];\t\n\tunsigned char *vector;\n\tattribute_t *attr;\n\tif (length > MAXPASS) {\t\t\t\t\n\t\tlength = MAXPASS;\n\t}\n\tif (length == 0) {\n\t\tlength = AUTH_PASS_LEN;\t\t\t\n\t} if ((length & (AUTH_PASS_LEN - 1)) != 0) {\n\t\tlength += (AUTH_PASS_LEN - 1);\t\t\n\t\tlength &= ~(AUTH_PASS_LEN - 1);\t\t\n\t}\t\t\t\t\t\t\n\tmemset(hashed, 0, length);\n\tmemcpy(hashed, password, strlen(password));\n\tattr = find_attribute(request, PW_PASSWORD);\n\tif (type == PW_PASSWORD) {\n\t\tvector = request->vector;\n\t} else {\n\t\tvector = attr->data;\t\t\t\n\t}\n\tMD5Init(&md5_secret);\n\tMD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));\n\tmy_md5 = md5_secret;\t\t\t\t\n\tMD5Update(&my_md5, vector, AUTH_VECTOR_LEN);\n\tMD5Final(misc, &my_md5);\t\t\t\n\txor(hashed, misc, AUTH_PASS_LEN);\n\tfor (i = 1; i < (length >> 4); i++) {\n\t\tmy_md5 = md5_secret;\t\t\t\n\t\tMD5Update(&my_md5, &hashed[(i-1) * AUTH_PASS_LEN], AUTH_PASS_LEN);\n\t\tMD5Final(misc, &my_md5);\t\t\t\n\t\txor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);\n\t}\n\tif (type == PW_OLD_PASSWORD) {\n\t\tattr = find_attribute(request, PW_OLD_PASSWORD);\n\t}\n\tif (!attr) {\n\t\tadd_attribute(request, type, hashed, length);\n\t} else {\n\t\tmemcpy(attr->data, hashed, length); \n\t}\n}", "target": 1}
{"code": "MONGO_EXPORT mongo_cursor *gridfile_get_chunks( gridfile *gfile, int start, int size ) {\n    bson_iterator it;\n    bson_oid_t id;\n    bson gte;\n    bson query;\n    bson orderby;\n    bson command;\n    mongo_cursor *cursor;\n    bson_find( &it, gfile->meta, \"_id\" );\n    id = *bson_iterator_oid( &it );\n    bson_init( &query );\n    bson_append_oid( &query, \"files_id\", &id );\n    if ( size == 1 ) {\n        bson_append_int( &query, \"n\", start );\n    }\n    else {\n        bson_init( &gte );\n        bson_append_int( &gte, \"$gte\", start );\n        bson_finish( &gte );\n        bson_append_bson( &query, \"n\", &gte );\n        bson_destroy( &gte );\n    }\n    bson_finish( &query );\n    bson_init( &orderby );\n    bson_append_int( &orderby, \"n\", 1 );\n    bson_finish( &orderby );\n    bson_init( &command );\n    bson_append_bson( &command, \"query\", &query );\n    bson_append_bson( &command, \"orderby\", &orderby );\n    bson_finish( &command );\n    cursor = mongo_find( gfile->gfs->client, gfile->gfs->chunks_ns,\n                         &command, NULL, size, 0, 0 );\n    bson_destroy( &command );\n    bson_destroy( &query );\n    bson_destroy( &orderby );\n    return cursor;\n}", "target": 1}
{"code": "mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn (sshpam_authok == sshpam_ctxt);\n}", "target": 1}
{"code": "static int logi_dj_ll_raw_request(struct hid_device *hid,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t count, unsigned char report_type,\n\t\t\t\t  int reqtype)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\tu8 *out_buf;\n\tint ret;\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\tif (count < DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\tkfree(out_buf);\n\treturn ret;\n}", "target": 1}
{"code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    int name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    if (name_size == 0) return;\n    char* name = new char[name_size+1];\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; \n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 1}
{"code": "static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": "lprn_is_black(gx_device_printer * pdev, int r, int h, int bx)\n{\n    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;\n    int bh = lprn->nBh;\n    int bpl = gdev_mem_bytes_per_scan_line(pdev);\n    int x, y, y0;\n    byte *p;\n    int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;\n    y0 = (r + h - bh) % maxY;\n    for (y = 0; y < bh; y++) {\n        p = &lprn->ImageBuf[(y0 + y) * bpl + bx * lprn->nBw];\n        for (x = 0; x < lprn->nBw; x++)\n            if (p[x] != 0)\n                return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "void sqlite3Fts5UnicodeAscii(u8 *aArray, u8 *aAscii){\n  int i = 0;\n  int iTbl = 0;\n  while( i<128 ){\n    int bToken = aArray[ aFts5UnicodeData[iTbl] & 0x1F ];\n    int n = (aFts5UnicodeData[iTbl] >> 5) + i;\n    for(; i<128 && i<n; i++){\n      aAscii[i] = (u8)bToken;\n    }\n    iTbl++;\n  }\n}", "target": 1}
{"code": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n                case SIOCFINDIPDDPRT:\n\t\t\tspin_lock_bh(&ipddp_route_lock);\n\t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp)\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n\t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n                default:\n                        return -EINVAL;\n        }\n}", "target": 1}
{"code": "static bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\tif (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\tif (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": " void * calloc(size_t n, size_t lb)\n {\n #   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 1}
{"code": "static int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tuint32_t stride;\n\tchunk_t next_free;\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\te->new_chunk = ps->next_free;\n\tstride = (ps->exceptions_per_area + 1);\n\tnext_free = ++ps->next_free;\n\tif (sector_div(next_free, stride) == 1)\n\t\tps->next_free++;\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}", "target": 1}
{"code": "static inline void pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tbuf->ops->get(pipe, buf);\n}", "target": 1}
{"code": "static int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EAGAIN;\n\ttrace_f2fs_readpage(page, DATA);\n\tif (f2fs_has_inline_data(inode))\n\t\tret = f2fs_read_inline_data(inode, page);\n\tif (ret == -EAGAIN)\n\t\tret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);\n\treturn ret;\n}", "target": 1}
{"code": "static int oidc_cache_crypto_decrypt_impl(request_rec *r,\n\t\tunsigned char *ciphertext, int ciphertext_len, const unsigned char *aad,\n\t\tint aad_len, const unsigned char *tag, int tag_len, unsigned char *key,\n\t\tconst unsigned char *iv, int iv_len, unsigned char *plaintext) {\n\tEVP_CIPHER_CTX *ctx;\n\tint len;\n\tint plaintext_len;\n\tint ret;\n\tif (!(ctx = EVP_CIPHER_CTX_new())) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_new\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptInit_ex(ctx, OIDC_CACHE_CIPHER, NULL, NULL, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_IVLEN, iv_len, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptInit_ex(ctx, NULL, NULL, key, iv)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptUpdate(ctx, NULL, &len, aad, aad_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate aad: aad_len=%d\",\n\t\t\t\taad_len);\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate ciphertext\");\n\t\treturn -1;\n\t}\n\tplaintext_len = len;\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_TAG, tag_len,\n\t\t\t(void *) tag)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tret = EVP_DecryptFinal_ex(ctx, plaintext + len, &len);\n\tEVP_CIPHER_CTX_free(ctx);\n\tif (ret > 0) {\n\t\tplaintext_len += len;\n\t\treturn plaintext_len;\n\t} else {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptFinal_ex\");\n\t\treturn -1;\n\t}\n}", "target": 1}
{"code": "\t\tGetRunner(\n\t\t\tconst ReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tMaybeLocal<Object> maybe_options,\n\t\t\tbool inherit\n\t\t) :\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference},\n\t\t\t\toptions{maybe_options, inherit ?\n\t\t\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n\t\t\t\tinherit{inherit} {\n\t\t\tthat.CheckDisposed();\n\t\t\tkey = ExternalCopy::CopyIfPrimitive(key_handle);\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": " static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n {\n\tint ret;\n \tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n \t\treturn -ENODEV;\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n }", "target": 1}
{"code": "    bool fetch(const string & url, const string & expectedETag = \"\")\n    {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        data.clear();\n        if (requestHeaders) {\n            curl_slist_free_all(requestHeaders);\n            requestHeaders = 0;\n        }\n        if (!expectedETag.empty()) {\n            this->expectedETag = expectedETag;\n            requestHeaders = curl_slist_append(requestHeaders, (\"If-None-Match: \" + expectedETag).c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, requestHeaders);\n        if (showProgress) {\n            std::cerr << (format(\"downloading %1%... \") % url);\n            std::cerr.flush();\n            startTime = getTime();\n        }\n        CURLcode res = curl_easy_perform(curl);\n        if (showProgress)\n            std::cerr << \"\\n\";\n        checkInterrupt();\n        if (res == CURLE_WRITE_ERROR && etag == expectedETag) return false;\n        if (res != CURLE_OK)\n            throw DownloadError(format(\"unable to download %1%: %2% (%3%)\")\n                % url % curl_easy_strerror(res) % res);\n        long httpStatus = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpStatus);\n        if (httpStatus == 304) return false;\n        return true;\n    }", "target": 1}
{"code": "struct mosquitto *context__init(mosq_sock_t sock)\n{\n\tstruct mosquitto *context;\n\tchar address[1024];\n\tcontext = mosquitto__calloc(1, sizeof(struct mosquitto));\n\tif(!context) return NULL;\n#ifdef WITH_EPOLL\n\tcontext->ident = id_client;\n#else\n\tcontext->pollfd_index = -1;\n#endif\n\tmosquitto__set_state(context, mosq_cs_new);\n\tcontext->sock = sock;\n\tcontext->last_msg_in = db.now_s;\n\tcontext->next_msg_out = db.now_s + 60;\n\tcontext->keepalive = 60; \n\tcontext->clean_start = true;\n\tcontext->id = NULL;\n\tcontext->last_mid = 0;\n\tcontext->will = NULL;\n\tcontext->username = NULL;\n\tcontext->password = NULL;\n\tcontext->listener = NULL;\n\tcontext->acl_list = NULL;\n\tcontext->retain_available = true;\n\tcontext->is_bridge = false;\n\tcontext->in_packet.payload = NULL;\n\tpacket__cleanup(&context->in_packet);\n\tcontext->out_packet = NULL;\n\tcontext->current_out_packet = NULL;\n\tcontext->out_packet_count = 0;\n\tcontext->address = NULL;\n\tif((int)sock >= 0){\n\t\tif(!net__socket_get_address(sock, address, 1024, &context->remote_port)){\n\t\t\tcontext->address = mosquitto__strdup(address);\n\t\t}\n\t\tif(!context->address){\n\t\t\tmosquitto__free(context);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tcontext->bridge = NULL;\n\tcontext->msgs_in.inflight_maximum = db.config->max_inflight_messages;\n\tcontext->msgs_out.inflight_maximum = db.config->max_inflight_messages;\n\tcontext->msgs_in.inflight_quota = db.config->max_inflight_messages;\n\tcontext->msgs_out.inflight_quota = db.config->max_inflight_messages;\n\tcontext->max_qos = 2;\n#ifdef WITH_TLS\n\tcontext->ssl = NULL;\n#endif\n\tif((int)context->sock >= 0){\n\t\tHASH_ADD(hh_sock, db.contexts_by_sock, sock, sizeof(context->sock), context);\n\t}\n\treturn context;\n}", "target": 1}
{"code": "static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tstruct spi_nor *nor;\n\tstruct mtd_info *mtd;\n\tunsigned int cs;\n\tint i, ret;\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tif (of_property_read_u32(np, \"reg\", &cs)) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (cs > CQSPI_MAX_CHIPSELECT) {\n\t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n\t\t\tgoto err;\n\t\t}\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tnor = &f_pdata->nor;\n\t\tmtd = &nor->mtd;\n\t\tmtd->priv = nor;\n\t\tnor->dev = dev;\n\t\tspi_nor_set_flash_node(nor, np);\n\t\tnor->priv = f_pdata;\n\t\tnor->read_reg = cqspi_read_reg;\n\t\tnor->write_reg = cqspi_write_reg;\n\t\tnor->read = cqspi_read;\n\t\tnor->write = cqspi_write;\n\t\tnor->erase = cqspi_erase;\n\t\tnor->prepare = cqspi_prep;\n\t\tnor->unprepare = cqspi_unprep;\n\t\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t   dev_name(dev), cs);\n\t\tif (!mtd->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tf_pdata->registered = true;\n\t}\n\treturn 0;\nerr:\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\treturn ret;\n}", "target": 1}
{"code": "  void event_cb(drachtio::RequestHandler::GlobalInfo *g, curl_socket_t s,\n                       int action, const boost::system::error_code & error,\n                       int *fdp) {\n    std::shared_ptr<RequestHandler> p = RequestHandler::getInstance() ;\n    std::map<curl_socket_t, boost::asio::ip::tcp::socket *>& socket_map = p->getSocketMap() ;\n    boost::asio::deadline_timer& timer = p->getTimer() ;\n    if(socket_map.find(s) == socket_map.end()) {\n      DR_LOG(log_error) << \"event_cb: socket already closed\";\n      return;\n    }\n    if(*fdp == action || *fdp == CURL_POLL_INOUT) {\n      CURLMcode rc;\n      if(error)\n        action = CURL_CSELECT_ERR;\n      rc = curl_multi_socket_action(g->multi, s, action, &g->still_running);\n      mcode_test(\"event_cb: curl_multi_socket_action\", rc);\n      check_multi_info(g);\n      if(g->still_running <= 0) {\n        timer.cancel();\n      }\n      if(!error && socket_map.find(s) != socket_map.end() &&\n         (*fdp == action || *fdp == CURL_POLL_INOUT)) {\n        boost::asio::ip::tcp::socket *tcp_socket = socket_map.find(s)->second;\n        if(action == CURL_POLL_IN) {\n          tcp_socket->async_read_some(boost::asio::null_buffers(),\n                                      boost::bind(&event_cb, g, s,\n                                                  action, boost::placeholders::_1, fdp));\n        }\n        if(action == CURL_POLL_OUT) {\n          tcp_socket->async_write_some(boost::asio::null_buffers(),\n                                       boost::bind(&event_cb, g, s,\n                                                   action, boost::placeholders::_1, fdp));\n        } \n      }\n    }\n  }", "target": 1}
{"code": "static inline int restore_fpu_checking(struct task_struct *tsk)\n{\n\talternative_input(\n\t\tASM_NOP8 ASM_NOP2,\n\t\t\"emms\\n\\t\"\t\t\n\t\t\"fildl %P[addr]\",\t\n\t\tX86_FEATURE_FXSAVE_LEAK,\n\t\t[addr] \"m\" (tsk->thread.fpu.has_fpu));\n\treturn fpu_restore_checking(&tsk->thread.fpu);\n}", "target": 1}
{"code": "static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_info tfrc;\n\tconst void *val;\n\tswitch (optname) {\n \tcase DCCP_SOCKOPT_CCID_TX_INFO:\n \t\tif (len < sizeof(tfrc))\n \t\t\treturn -EINVAL;\n \t\ttfrc.tfrctx_x\t   = hc->tx_x;\n \t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n \t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;\n\t\ttfrc.tfrctx_rtt\t   = hc->tx_rtt;\n\t\ttfrc.tfrctx_p\t   = hc->tx_p;\n\t\ttfrc.tfrctx_rto\t   = hc->tx_t_rto;\n\t\ttfrc.tfrctx_ipi\t   = hc->tx_t_ipi;\n\t\tlen = sizeof(tfrc);\n\t\tval = &tfrc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "FindEmptyObjectSlot(\n\t\t    TPMI_DH_OBJECT  *handle         \n\t\t    )\n{\n    UINT32               i;\n    OBJECT              *object;\n    for(i = 0; i < MAX_LOADED_OBJECTS; i++)\n\t{\n\t    object = &s_objects[i];\n\t    if(object->attributes.occupied == CLEAR)\n\t\t{\n\t\t    if(handle)\n\t\t\t*handle = i + TRANSIENT_FIRST;\n\t\t    MemorySet(&object->attributes, 0, sizeof(OBJECT_ATTRIBUTES));\n\t\t    return object;\n\t\t}\n\t}\n    return NULL;\n}", "target": 1}
{"code": "int64_t OpLevelCostEstimator::CalculateOutputSize(const OpInfo& op_info,\n                                                  bool* found_unknown_shapes) {\n  int64_t total_output_size = 0;\n  for (const auto& output : op_info.outputs()) {\n    DataType dt = output.dtype();\n    const auto& original_output_shape = output.shape();\n    int64_t output_size = DataTypeSize(BaseType(dt));\n    int num_dims = std::max(1, original_output_shape.dim_size());\n    auto output_shape = MaybeGetMinimumShape(original_output_shape, num_dims,\n                                             found_unknown_shapes);\n    for (const auto& dim : output_shape.dim()) {\n      output_size *= dim.size();\n    }\n    total_output_size += output_size;\n    VLOG(1) << \"Output Size: \" << output_size\n            << \" Total Output Size:\" << total_output_size;\n  }\n  return total_output_size;\n}", "target": 1}
{"code": "static WCHAR* drive_file_combine_fullpath(const WCHAR* base_path, const WCHAR* path,\n                                          size_t PathLength)\n{\n\tWCHAR* fullpath;\n\tsize_t base_path_length;\n\tif (!base_path || (!path && (PathLength > 0)))\n\t\treturn NULL;\n\tbase_path_length = _wcslen(base_path) * 2;\n\tfullpath = (WCHAR*)calloc(1, base_path_length + PathLength + sizeof(WCHAR));\n\tif (!fullpath)\n\t{\n\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\treturn NULL;\n\t}\n\tCopyMemory(fullpath, base_path, base_path_length);\n\tif (path)\n\t\tCopyMemory((char*)fullpath + base_path_length, path, PathLength);\n\tdrive_file_fix_path(fullpath);\n\treturn fullpath;\n}", "target": 1}
{"code": "\tvoid verifyDirectoryPermissions(const string &path) {\n\t\tTRACE_POINT();\n\t\tstruct stat buf;\n\t\tif (stat(path.c_str(), &buf) == -1) {\n\t\t\tint e = errno;\n\t\t\tthrow FileSystemException(\"Cannot stat() \" + path, e, path);\n\t\t} else if (buf.st_mode != (S_IFDIR | parseModeString(\"u=rwx,g=rx,o=rx\"))) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong permissions\");\n\t\t} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong owner and group\");\n\t\t}\n\t}", "target": 1}
{"code": "static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n    wpc->version_five = 1;      \n    wpc->file_format = wpc->config.qmode = wpc->channel_layout = 0;\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n    if (bytecnt) {\n        wpc->file_format = *byteptr++;\n        wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n        bytecnt -= 2;\n        if (bytecnt) {\n            int nchans, i;\n            wpc->channel_layout = (int32_t) *byteptr++ << 16;\n            bytecnt--;\n            if (bytecnt) {\n                wpc->channel_layout += nchans = *byteptr++;\n                bytecnt--;\n                if (bytecnt) {\n                    if (bytecnt > nchans)\n                        return FALSE;\n                    wpc->channel_reordering = malloc (nchans);\n                    if (wpc->channel_reordering) {\n                        for (i = 0; i < nchans; ++i)\n                            if (bytecnt) {\n                                wpc->channel_reordering [i] = *byteptr++;\n                                bytecnt--;\n                            }\n                            else\n                                wpc->channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc->channel_layout += wpc->config.num_channels;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n    beyond = pData + stride * height;\n    pix = pData;\n    x = y = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            return OPJ_FALSE;\n        }\n        if (c) {\n            int j, c1_int;\n            OPJ_UINT8 c1;\n            c1_int = getc(IN);\n            if (c1_int == EOF) {\n                return OPJ_FALSE;\n            }\n            c1 = (OPJ_UINT8)c1_int;\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n            }\n        } else {\n            c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n            }\n            if (c == 0x00) { \n                x = 0;\n                ++y;\n                pix = pData + y * stride + x;\n            } else if (c == 0x01) { \n                break;\n            } else if (c == 0x02) { \n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { \n                int j;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    int c1_int;\n                    OPJ_UINT8 c1;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                    }\n                    c1 = (OPJ_UINT8)c1_int;\n                    *pix = c1;\n                }\n                if ((OPJ_UINT32)c & 1U) { \n                    c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n            }\n        }\n    }\n    return OPJ_TRUE;\n}", "target": 1}
{"code": "kdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code)\n        return code;\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n    return 0;\n}", "target": 1}
{"code": "null_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int length = h->len;\n\tu_int caplen = h->caplen;\n\tu_int family;\n\tif (caplen < NULL_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|null]\"));\n\t\treturn (NULL_HDRLEN);\n\t}\n\tmemcpy((char *)&family, (const char *)p, sizeof(family));\n\tif ((family & 0xFFFF0000) != 0)\n\t\tfamily = SWAPLONG(family);\n\tif (ndo->ndo_eflag)\n\t\tnull_hdr_print(ndo, family, length);\n\tlength -= NULL_HDRLEN;\n\tcaplen -= NULL_HDRLEN;\n\tp += NULL_HDRLEN;\n\tswitch (family) {\n\tcase BSD_AFNUM_INET:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_INET6_BSD:\n\tcase BSD_AFNUM_INET6_FREEBSD:\n\tcase BSD_AFNUM_INET6_DARWIN:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_ISO:\n\t\tisoclns_print(ndo, p, length, caplen);\n\t\tbreak;\n\tcase BSD_AFNUM_APPLETALK:\n\t\tatalk_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_IPX:\n\t\tipx_print(ndo, p, length);\n\t\tbreak;\n\tdefault:\n\t\tif (!ndo->ndo_eflag)\n\t\t\tnull_hdr_print(ndo, family, length + NULL_HDRLEN);\n\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\tND_DEFAULTPRINT(p, caplen);\n\t}\n\treturn (NULL_HDRLEN);\n}", "target": 1}
{"code": "    OFCondition operator()(ImagePixel& pixel)\n    {\n        (void)pixel;\n        Uint16 rows = 0;\n        Uint16 cols = 0;\n        m_CT.getRows(rows);\n        m_CT.getColumns(cols);\n        const size_t numFrames      = m_CT.m_Frames.size();\n        const size_t numBytesFrame  = m_CT.m_Frames[0]->length;\n        const size_t numPixelsFrame = rows * cols;\n        DcmPixelData* pixData = new DcmPixelData(DCM_PixelData);\n        OFCondition result;\n        if (pixData)\n        {\n            pixData->setVR(EVR_OW);\n            Uint16* ptr          = NULL;\n            size_t numBytesTotal = numBytesFrame * numFrames / 2;\n            if (numBytesTotal <= 4294967294UL)\n            {\n                result = pixData->createUint16Array(OFstatic_cast(Uint32, numBytesTotal), ptr);\n                if (ptr)\n                {\n                    for (size_t f = 0; f < numFrames; ++f)\n                    {\n                        memcpy(ptr, m_CT.m_Frames[f]->pixData, numBytesFrame);\n                        ptr += numPixelsFrame;\n                    }\n                    return m_Item.insert(pixData);\n                }\n            }\n            else\n            {\n                result = FG_EC_PixelDataTooLarge;\n                delete pixData;\n            }\n        }\n        return result;\n    }", "target": 1}
{"code": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"rng\");\n\trrng.seedsize = alg->cra_rng.seedsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {\n  if (HasTextBeingDragged())\n    return ui::DragDropTypes::DRAG_NONE;\n  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {\n    GURL url;\n    base::string16 title;\n    if (data.GetURLAndTitle(\n            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {\n      base::string16 text(\n          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));\n      if (model()->CanPasteAndGo(text)) {\n        model()->PasteAndGo(text);\n        return ui::DragDropTypes::DRAG_COPY;\n      }\n    }\n   } else if (data.HasString()) {\n     base::string16 text;\n     if (data.GetString(&text)) {\n      base::string16 collapsed_text(base::CollapseWhitespace(text, true));\n       if (model()->CanPasteAndGo(collapsed_text))\n         model()->PasteAndGo(collapsed_text);\n       return ui::DragDropTypes::DRAG_COPY;\n    }\n  }\n  return ui::DragDropTypes::DRAG_NONE;\n}", "target": 1}
{"code": "ga_concat_shorten_esc(garray_T *gap, char_u *str)\n{\n    char_u  *p;\n    char_u  *s;\n    int\t    c;\n    int\t    clen;\n    char_u  buf[NUMBUFLEN];\n    int\t    same_len;\n    if (str == NULL)\n    {\n\tga_concat(gap, (char_u *)\"NULL\");\n\treturn;\n    }\n    for (p = str; *p != NUL; ++p)\n    {\n\tsame_len = 1;\n\ts = p;\n\tc = mb_ptr2char_adv(&s);\n\tclen = s - p;\n\twhile (*s != NUL && c == mb_ptr2char(s))\n\t{\n\t    ++same_len;\n\t    s += clen;\n\t}\n\tif (same_len > 20)\n\t{\n\t    ga_concat(gap, (char_u *)\"\\\\[\");\n\t    ga_concat_esc(gap, p, clen);\n\t    ga_concat(gap, (char_u *)\" occurs \");\n\t    vim_snprintf((char *)buf, NUMBUFLEN, \"%d\", same_len);\n\t    ga_concat(gap, buf);\n\t    ga_concat(gap, (char_u *)\" times]\");\n\t    p = s - 1;\n\t}\n\telse\n\t    ga_concat_esc(gap, p, clen);\n    }\n}", "target": 1}
{"code": "int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tint error = 0;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tconst char *name = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (error < 0) {\n\t\t\t\tgossip_err(\"%s: posix_acl_equiv_mode err: %d\\n\",\n\t\t\t\t\t   __func__,\n\t\t\t\t\t   error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif (inode->i_mode != mode)\n\t\t\t\tSetModeFlag(orangefs_inode);\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"%s: invalid type %d!\\n\", __func__, type);\n\t\treturn -EINVAL;\n\t}\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: inode %pU, key %s type %d\\n\",\n\t\t     __func__, get_khandle_from_ino(inode),\n\t\t     name,\n\t\t     type);\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: name %s, value %p, size %zd, acl %p\\n\",\n\t\t     __func__, name, value, size, acl);\n\terror = orangefs_inode_setxattr(inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "static inline void ConvertRGBToCMYK(PixelInfo *pixel)\n{\n  MagickRealType\n    black,\n    blue,\n    cyan,\n    green,\n    magenta,\n    red,\n    yellow;\n  if (pixel->colorspace != sRGBColorspace)\n    {\n      red=QuantumScale*pixel->red;\n      green=QuantumScale*pixel->green;\n      blue=QuantumScale*pixel->blue;\n    }\n  else\n    {\n      red=QuantumScale*DecodePixelGamma(pixel->red);\n      green=QuantumScale*DecodePixelGamma(pixel->green);\n      blue=QuantumScale*DecodePixelGamma(pixel->blue);\n    }\n  if ((fabs((double) red) < MagickEpsilon) &&\n      (fabs((double) green) < MagickEpsilon) &&\n      (fabs((double) blue) < MagickEpsilon))\n    {\n      pixel->black=(MagickRealType) QuantumRange;\n      return;\n    }\n  cyan=(MagickRealType) (1.0-red);\n  magenta=(MagickRealType) (1.0-green);\n  yellow=(MagickRealType) (1.0-blue);\n  black=cyan;\n  if (magenta < black)\n    black=magenta;\n  if (yellow < black)\n    black=yellow;\n  cyan=(MagickRealType) ((cyan-black)/(1.0-black));\n  magenta=(MagickRealType) ((magenta-black)/(1.0-black));\n  yellow=(MagickRealType) ((yellow-black)/(1.0-black));\n  pixel->colorspace=CMYKColorspace;\n  pixel->red=QuantumRange*cyan;\n  pixel->green=QuantumRange*magenta;\n  pixel->blue=QuantumRange*yellow;\n  pixel->black=QuantumRange*black;\n}", "target": 1}
{"code": "static void ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "int bson_check_string( bson *b, const char *string,\n                       const int length ) {\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );\n}", "target": 1}
{"code": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); \n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); \n\treturn TRUE;\n}", "target": 1}
{"code": "int luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  int counthook;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  \n    ci->u.l.trap = 0;  \n    return 0;  \n  }\n  pc++;  \n  ci->u.l.savedpc = pc;  \n  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));\n  if (counthook)\n    resethookcount(L);  \n  else if (!(mask & LUA_MASKLINE))\n    return 1;  \n  if (ci->callstatus & CIST_HOOKYIELD) {  \n    ci->callstatus &= ~CIST_HOOKYIELD;  \n    return 1;  \n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))\n    L->top = ci->top;  \n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  \n  if (mask & LUA_MASKLINE) {\n    const Proto *p = ci_func(ci)->p;\n    int npci = pcRel(pc, p);\n    if (npci == 0 ||  \n        pc <= L->oldpc ||  \n        changedline(p, pcRel(L->oldpc, p), npci)) {  \n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  \n    }\n    L->oldpc = pc;  \n  }\n  if (L->status == LUA_YIELD) {  \n    if (counthook)\n      L->hookcount = 1;  \n    ci->u.l.savedpc--;  \n    ci->callstatus |= CIST_HOOKYIELD;  \n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  \n}", "target": 1}
{"code": "static void start_daemon()\n{\n\tstruct usb_sock_t *usb_sock;\n\tif (g_options.noprinter_mode == 0) {\n\t\tusb_sock = usb_open();\n\t\tif (usb_sock == NULL)\n\t\t\tgoto cleanup_usb;\n\t} else\n\t\tusb_sock = NULL;\n\tuint16_t desired_port = g_options.desired_port;\n\tstruct tcp_sock_t *tcp_socket;\n\twhile ((tcp_socket = tcp_open(desired_port)) == NULL &&\n\t       g_options.only_desired_port == 0) {\n\t\tdesired_port ++;\n\t\tif (desired_port == 1 || desired_port == 0)\n\t\t\tdesired_port = 49152;\n\t}\n\tif (tcp_socket == NULL)\n\t\tgoto cleanup_tcp;\n\tuint16_t real_port = tcp_port_number_get(tcp_socket);\n\tif (desired_port != 0 && g_options.only_desired_port == 1 &&\n\t    desired_port != real_port) {\n\t\tERR(\"Received port number did not match requested port number.\"\n\t\t    \" The requested port number may be too high.\");\n\t\tgoto cleanup_tcp;\n\t}\n\tprintf(\"%u|\", real_port);\n\tfflush(stdout);\n\tuint16_t pid;\n\tif (!g_options.nofork_mode && (pid = fork()) > 0) {\n\t\tprintf(\"%u|\", pid);\n\t\texit(0);\n\t}\n\tif (usb_can_callback(usb_sock))\n\t\tusb_register_callback(usb_sock);\n\tfor (;;) {\n\t\tstruct service_thread_param *args = calloc(1, sizeof(*args));\n\t\tif (args == NULL) {\n\t\t\tERR(\"Failed to alloc space for thread args\");\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\targs->usb_sock = usb_sock;\n\t\targs->tcp = tcp_conn_accept(tcp_socket);\n\t\tif (args->tcp == NULL) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\tint status = pthread_create(&args->thread_handle, NULL,\n\t\t                            &service_connection, args);\n\t\tif (status) {\n\t\t\tERR(\"Failed to spawn thread, error %d\", status);\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\tcontinue;\n\tcleanup_thread:\n\t\tif (args != NULL) {\n\t\t\tif (args->tcp != NULL)\n\t\t\t\ttcp_conn_close(args->tcp);\n\t\t\tfree(args);\n\t\t}\n\t\tbreak;\n\t}\ncleanup_tcp:\n\tif (tcp_socket!= NULL)\n\t\ttcp_close(tcp_socket);\ncleanup_usb:\n\tif (usb_sock != NULL)\n\t\tusb_close(usb_sock);\n\treturn;\n}", "target": 1}
{"code": "static HTTPAPI_RESULT ConstructHeadersString(HTTP_HEADERS_HANDLE httpHeadersHandle, wchar_t** httpHeaders)\n{\n    HTTPAPI_RESULT result;\n    size_t headersCount;\n    if (HTTPHeaders_GetHeaderCount(httpHeadersHandle, &headersCount) != HTTP_HEADERS_OK)\n    {\n        result = HTTPAPI_ERROR;\n        LogError(\"HTTPHeaders_GetHeaderCount failed (result = %\" PRI_MU_ENUM \").\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else\n    {\n        size_t i;\n        size_t toAlloc = 0;\n        for (i = 0; i < headersCount; i++)\n        {\n            char *temp;\n            if (HTTPHeaders_GetHeader(httpHeadersHandle, i, &temp) == HTTP_HEADERS_OK)\n            {\n                toAlloc += strlen(temp);\n                toAlloc += 2;\n                free(temp);\n            }\n            else\n            {\n                LogError(\"HTTPHeaders_GetHeader failed\");\n                break;\n            }\n        }\n        if (i < headersCount)\n        {\n            result = HTTPAPI_ERROR;\n        }\n        else\n        {\n            char *httpHeadersA;\n            size_t requiredCharactersForHeaders;\n            if ((httpHeadersA = ConcatHttpHeaders(httpHeadersHandle, toAlloc, headersCount)) == NULL)\n            {\n                result = HTTPAPI_ERROR;\n                LogError(\"Cannot concatenate headers\");\n            }\n            else if ((requiredCharactersForHeaders = MultiByteToWideChar(CP_ACP, 0, httpHeadersA, -1, NULL, 0)) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"MultiByteToWideChar failed, GetLastError=0x%08x (result = %\" PRI_MU_ENUM \")\", GetLastError(), MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n            }\n            else if ((*httpHeaders = (wchar_t*)malloc((requiredCharactersForHeaders + 1) * sizeof(wchar_t))) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"Cannot allocate memory (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n            }\n            else if (MultiByteToWideChar(CP_ACP, 0, httpHeadersA, -1, *httpHeaders, (int)requiredCharactersForHeaders) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"MultiByteToWideChar failed, GetLastError=0x%08x (result = %\" PRI_MU_ENUM \")\", GetLastError(), MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n                free(*httpHeaders);\n                *httpHeaders = NULL;\n            }\n            else\n            {\n                result = HTTPAPI_OK;\n            }\n            free(httpHeadersA);\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "bool ECDSA_Verification_Operation::verify(const uint8_t msg[], size_t msg_len,\n                                          const uint8_t sig[], size_t sig_len)\n   {\n   if(sig_len != m_group.get_order_bytes() * 2)\n      return false;\n   const BigInt e(msg, msg_len, m_group.get_order_bits());\n   const BigInt r(sig, sig_len / 2);\n   const BigInt s(sig + sig_len / 2, sig_len / 2);\n   if(r <= 0 || r >= m_group.get_order() || s <= 0 || s >= m_group.get_order())\n      return false;\n   const BigInt w = m_group.inverse_mod_order(s);\n   const BigInt u1 = m_group.multiply_mod_order(e, w);\n   const BigInt u2 = m_group.multiply_mod_order(r, w);\n   const PointGFp R = m_gy_mul.multi_exp(u1, u2);\n   if(R.is_zero())\n      return false;\n   const BigInt v = m_group.mod_order(R.get_affine_x());\n   return (v == r);\n   }", "target": 1}
{"code": "TfLiteStatus EvalSimple(TfLiteContext* context, TfLiteNode* node,\n                        const TfLiteTensor* lookup, const TfLiteTensor* value,\n                        TfLiteTensor* output) {\n  const int row_size = SizeOfDimension(value, 0);\n  const int row_bytes = value->bytes / row_size;\n  char* output_raw = GetTensorData<char>(output);\n  const char* value_raw = GetTensorData<char>(value);\n  const int32_t* lookup_data = GetTensorData<int32_t>(lookup);\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = lookup_data[i];\n    if (idx >= row_size || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, row_size - 1);\n      return kTfLiteError;\n    } else {\n      std::memcpy(output_raw + i * row_bytes, value_raw + idx * row_bytes,\n                  row_bytes);\n    }\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n \t\t\t\t       size_t len)\n {\n \tuaddr_t a;\n \tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n \t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n \t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n \t\tuint32_t attr;\n \t\tTEE_Result res;\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\tif (dump_one_state(x, 0, &info)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\treturn skb;\n}", "target": 1}
{"code": "ip_printroute(netdissect_options *ndo,\n              register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tif (length < 3) {\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\t\treturn;\n\t}\n\tif ((length + 1) & 3)\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tif (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)\n\t\tND_PRINT((ndo, \" [bad ptr %u]\", cp[2]));\n\tfor (len = 3; len < length; len += 4) {\n\t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, &cp[len])));\n\t\tif (ptr > len)\n\t\t\tND_PRINT((ndo, \",\"));\n\t}\n}", "target": 1}
{"code": "static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,\n                                          unsigned char *buf, int idx,\n                                          int width)\n{\n    size_t i, j;\n    if (bn_wexpand(b, top) == NULL)\n        return 0;\n    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {\n        ((unsigned char *)b->d)[i] = buf[j];\n    }\n    b->top = top;\n    bn_correct_top(b);\n    return 1;\n}", "target": 1}
{"code": "static inline int restore_fpu_checking(struct task_struct *tsk)\n{\n\talternative_input(\n\t\tASM_NOP8 ASM_NOP2,\n\t\t\"emms\\n\\t\"\t\t\n\t\t\"fildl %P[addr]\",\t\n\t\tX86_FEATURE_FXSAVE_LEAK,\n\t\t[addr] \"m\" (tsk->thread.fpu.has_fpu));\n\treturn fpu_restore_checking(&tsk->thread.fpu);\n}", "target": 1}
{"code": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}", "target": 1}
{"code": "defaults (void)\n{\n  char *tmp;\n  xzero (opt);\n  opt.cookies = true;\n  opt.verbose = -1;\n  opt.ntry = 20;\n  opt.reclevel = 5;\n  opt.add_hostdir = true;\n  opt.netrc = true;\n  opt.ftp_glob = true;\n  opt.htmlify = true;\n  opt.http_keep_alive = true;\n  opt.use_proxy = true;\n  tmp = getenv (\"no_proxy\");\n  if (tmp)\n    opt.no_proxy = sepstring (tmp);\n  opt.prefer_family = prefer_none;\n  opt.allow_cache = true;\n  opt.read_timeout = 900;\n  opt.use_robots = true;\n  opt.remove_listing = true;\n  opt.dot_bytes = 1024;\n  opt.dot_spacing = 10;\n  opt.dots_in_line = 50;\n  opt.dns_cache = true;\n  opt.ftp_pasv = true;\n#ifdef HAVE_SSL\n  opt.check_cert = true;\n#endif\n#if defined(WINDOWS) || defined(MSDOS) || defined(__CYGWIN__)\n  opt.restrict_files_os = restrict_windows;\n#else\n  opt.restrict_files_os = restrict_unix;\n#endif\n  opt.restrict_files_ctrl = true;\n  opt.restrict_files_nonascii = false;\n  opt.restrict_files_case = restrict_no_case_restriction;\n  opt.regex_type = regex_type_posix;\n  opt.max_redirect = 20;\n  opt.waitretry = 10;\n#ifdef ENABLE_IRI\n  opt.enable_iri = true;\n#else\n  opt.enable_iri = false;\n#endif\n  opt.locale = NULL;\n  opt.encoding_remote = NULL;\n  opt.useservertimestamps = true;\n  opt.show_all_dns_entries = false;\n  opt.warc_maxsize = 0; \n#ifdef HAVE_LIBZ\n  opt.warc_compression_enabled = true;\n#else\n  opt.warc_compression_enabled = false;\n#endif\n  opt.warc_digests_enabled = true;\n  opt.warc_cdx_enabled = false;\n  opt.warc_cdx_dedup_filename = NULL;\n  opt.warc_tempdir = NULL;\n  opt.warc_keep_log = true;\n  opt.start_pos = -1;\n  opt.show_progress = false;\n  opt.noscroll = false;\n}", "target": 1}
{"code": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; \n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  char ptr; \n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  return 1000000 - count; \n#else\n  return 1000000; \n#endif\n}", "target": 1}
{"code": "static inline int xrstor_state(struct xsave_struct *fx, u64 mask)\n{\n\tint err = 0;\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\t\"1: \" XRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\tasm volatile(\"2:\\n\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\top = pwcs;\n\twhile (*s && len > 0) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS));\n\t\t\t} else {\n\t\t\t\t*op++ = (wchar_t) u;\n\t\t\t}\n\t\t\ts += size;\n\t\t\tlen -= size;\n\t\t} else {\n\t\t\t*op++ = *s++;\n\t\t\tlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}", "target": 1}
{"code": "DltReturnValue dlt_file_message(DltFile *file, int index, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n    if (index >= file->counter) {\n        dlt_vlog(LOG_WARNING, \"Message %d out of range!\\r\\n\", index);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n    if (fseek(file->handle, file->index[index], SEEK_SET) != 0) {\n        dlt_vlog(LOG_WARNING, \"Seek to message %d to position %ld failed!\\r\\n\",\n                 index, file->index[index]);\n        return DLT_RETURN_ERROR;\n    }\n    if (dlt_file_read_header(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    if (dlt_file_read_data(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    file->position = index;\n    return DLT_RETURN_OK;\n}", "target": 1}
{"code": "static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\tif (serial->num_ports < 2)\n\t\treturn -1;\n\tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\treturn 0;\n}", "target": 1}
{"code": "static void __reg_assign_32_into_64(struct bpf_reg_state *reg)\n{\n\treg->umin_value = reg->u32_min_value;\n\treg->umax_value = reg->u32_max_value;\n\tif (reg->s32_min_value >= 0 && reg->s32_max_value >= 0)\n\t\treg->smax_value = reg->s32_max_value;\n\telse\n\t\treg->smax_value = U32_MAX;\n\tif (reg->s32_min_value >= 0)\n\t\treg->smin_value = reg->s32_min_value;\n\telse\n\t\treg->smin_value = 0;\n}", "target": 1}
{"code": "int nfc_fw_download(struct nfc_dev *dev, const char *firmware_name)\n{\n\tint rc = 0;\n\tpr_debug(\"%s do firmware %s\\n\", dev_name(&dev->dev), firmware_name);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dev_up) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->fw_download) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tdev->fw_download_in_progress = true;\n\trc = dev->ops->fw_download(dev, firmware_name);\n\tif (rc)\n\t\tdev->fw_download_in_progress = false;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n \tdebug3(\"%s\", __func__);\n \tbuffer_init(&m);\n\tbuffer_put_cstring(&m, authctxt->user);\n \tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n \tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n \tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}", "target": 1}
{"code": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n \tif (pqueue_size(queue->q) >= 100)\n \t\treturn 0;\n \trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n \titem = pitem_new(priority, rdata);\n \tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\titem->data = rdata;\n#ifndef OPENSSL_NO_SCTP\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n \tif (!ssl3_setup_buffers(s))\n \t\t{\n \t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n \t\tOPENSSL_free(rdata);\n \t\tpitem_free(item);\n\t\treturn(0);\n \t\t}\n \tif (pqueue_insert(queue->q, item) == NULL)\n \t\t{\n \t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n \t\tOPENSSL_free(rdata);\n \t\tpitem_free(item);\n\t\treturn(0);\n \t\t}\n \treturn(1);\n\t}", "target": 1}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tapply_proxy_config(t);\n\terror = git_stream_connect(t->io);\n \tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n \t    git_stream_is_encrypted(t->io)) {\n \t\tgit_cert *cert;\n\t\tint is_valid;\n \t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n \t\t\treturn error;\n \t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n \t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n \t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    mrb_stack_extend(mrb, len+2); \n    b = c->stbase+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    if (vmexec) {\n      c->ci--;                    \n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}", "target": 1}
{"code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    fclose(fp);\n    fp=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        fclose(fp);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}", "target": 1}
{"code": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, \n                                ecma_value_t key_arg, \n                                ecma_value_t value_arg, \n                                lit_magic_string_id_t lit_id) \n{\n  JERRY_ASSERT (container_p != NULL);\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} ", "target": 1}
{"code": "gvdb_table_write_contents_async (GHashTable          *table,\n                                 const gchar         *filename,\n                                 gboolean             byteswap,\n                                 GCancellable        *cancellable,\n                                 GAsyncReadyCallback  callback,\n                                 gpointer             user_data)\n{\n  struct gvdb_pointer root;\n  FileBuilder *fb;\n  WriteContentsData *data;\n  GString *str;\n  GBytes *bytes;\n  GFile *file;\n  GTask *task;\n  g_return_if_fail (table != NULL);\n  g_return_if_fail (filename != NULL);\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n  fb = file_builder_new (byteswap);\n  file_builder_add_hash (fb, table, &root);\n  str = file_builder_serialise (fb, root);\n  bytes = g_string_free_to_bytes (str);\n  file_builder_free (fb);\n  file = g_file_new_for_path (filename);\n  data = write_contents_data_new (bytes, file);\n  task = g_task_new (NULL, cancellable, callback, user_data);\n  g_task_set_task_data (task, data, (GDestroyNotify)write_contents_data_free);\n  g_task_set_source_tag (task, gvdb_table_write_contents_async);\n  g_file_replace_contents_async (file, str->str, str->len,\n                                 NULL, FALSE,\n                                 G_FILE_CREATE_PRIVATE | G_FILE_CREATE_REPLACE_DESTINATION,\n                                 cancellable, replace_contents_cb, g_steal_pointer (&task));\n  g_bytes_unref (bytes);\n  g_object_unref (file);\n}", "target": 1}
{"code": "static ssize_t read_mem(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t read, sz;\n\tvoid *ptr;\n\tif (p != *ppos)\n\t\treturn 0;\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\tread = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (sz > 0) {\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tcount -= sz;\n\t\t\tread += sz;\n\t\t}\n\t}\n#endif\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\t\tsz = size_inside_page(p, count);\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n\t\t\treturn -EPERM;\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr)\n\t\t\treturn -EFAULT;\n\t\tremaining = copy_to_user(buf, ptr, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\tread += sz;\n\t}\n\t*ppos += read;\n\treturn read;\n}", "target": 1}
{"code": "static void dtls1_clear_queues(SSL *s)\n\t{\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n\tDTLS1_RECORD_DATA *rdata;\n    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\twhile ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)\n\t\t{\n\t\tfrag = (hm_fragment *)item->data;\n\t\tOPENSSL_free(frag->fragment);\n\t\tOPENSSL_free(frag);\n\t\tpitem_free(item);\n\t\t}\n\t}", "target": 1}
{"code": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\tparent = me->real_parent;\n\tret = -EPERM;\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\toldcred = parent->replacement_session_keyring;\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tput_cred(cred);\n\treturn ret;\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n#else \n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif \n}", "target": 1}
{"code": "static int do_change_type(struct nameidata *nd, int flag)\n{\n\tstruct vfsmount *m, *mnt = nd->mnt;\n\tint recurse = flag & MS_REC;\n\tint type = flag & ~MS_REC;\n\tif (nd->dentry != nd->mnt->mnt_root)\n\t\treturn -EINVAL;\n\tdown_write(&namespace_sem);\n\tspin_lock(&vfsmount_lock);\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tspin_unlock(&vfsmount_lock);\n\tup_write(&namespace_sem);\n\treturn 0;\n}", "target": 1}
{"code": "mmsClient_handleFileOpenRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId, ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n        switch(tag) {\n        case 0xa0: \n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n            hasFileName = true;\n            break;\n        case 0x81: \n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n        case 0x00: \n            break;\n        default: \n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n    if (hasFileName) {\n        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n        if (frsm != NULL) {\n            MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);\n            if (obtainFileCall) {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);\n                obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n            }\n            FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);\n            if (fileHandle != NULL) {\n                frsm->fileHandle = fileHandle;\n                frsm->readPosition = filePosition;\n                frsm->frsmId = getNextFrsmId(connection);\n                frsm->obtainRequest = obtainFileCall;\n                mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n                        invokeId, response, filename, frsm);\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        }\n        else\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n    }\n    else\n        goto exit_invalid_parameter;\n    return;\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}", "target": 1}
{"code": "void ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t   ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\tint reserved = 0;\n\tstruct extent_status *es = NULL;\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\tif (!len)\n\t\treturn;\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\nretry:\n\tif (err && !es)\n\t\tes = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end, &reserved, es);\n\tif (es && !es->es_len)\n\t\t__es_free_extent(es);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err)\n\t\tgoto retry;\n\text4_es_print_tree(inode);\n\text4_da_release_space(inode, reserved);\n\treturn;\n}", "target": 1}
{"code": "static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n\t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n\t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (((int)arg >= cdi->capacity))\n\t\treturn -EINVAL;\n\treturn cdrom_slot_status(cdi, arg);\n}", "target": 1}
{"code": "int inet6_sk_rebuild_header(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dst_entry *dst;\n\tdst = __sk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = sk->sk_protocol;\n\t\tfl6.daddr = sk->sk_v6_daddr;\n\t\tfl6.saddr = np->saddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tfl6.fl6_sport = inet->inet_sport;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst)) {\n\t\t\tsk->sk_route_caps = 0;\n\t\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\t\treturn PTR_ERR(dst);\n\t\t}\n\t\t__ip6_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    qemu_vfree(r->iov.iov_base);\n}", "target": 1}
{"code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n \tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n \tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n \tassert(ss == len);\n\tif (pos > CDF_SEC_SIZE(h) * sst->sst_len) {\n \t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n \t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos, CDF_SEC_SIZE(h) * sst->sst_len));\n \t\treturn -1;\n \t}\n \t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}", "target": 1}
{"code": "static void mbochs_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\tmbochs_used_mbytes -= mdev_state->type->mbytes;\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n}", "target": 1}
{"code": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n \t\treturn ERR_PTR(-ENOMEM);\n \t}\n \td_instantiate(dentry, inode);\n \tdentry->d_fsdata = (void *)ns->ops;\n \td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n \tif (d) {\n\t\td_delete(dentry);\t\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}", "target": 1}
{"code": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n  ds = d;\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n    if (c != '.')\n      if (c != 0x3002)  \n        if (c != 0xFF0E)  \n          if (c != 0xFF61)  \n            continue;\n    rc = uv__idna_toascii_label(s, st, &d, de);\n    if (rc < 0)\n      return rc;\n    if (d < de)\n      *d++ = '.';\n    s = si;\n  }\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n    if (rc < 0)\n      return rc;\n  }\n  if (d < de)\n    *d++ = '\\0';\n  return d - ds;  \n}", "target": 1}
{"code": "void InputConnectionImpl::CommitText(const base::string16& text,\n                                     int new_cursor_pos) {\n  StartStateUpdateTimer();\n  std::string error;\n  if (!ime_engine_->ClearComposition(input_context_id_, &error))\n    LOG(ERROR) << \"ClearComposition failed: error=\\\"\" << error << \"\\\"\";\n  if (IsControlChar(text)) {\n    SendControlKeyEvent(text);\n    return;\n  }\n   if (!ime_engine_->CommitText(input_context_id_,\n                                base::UTF16ToUTF8(text).c_str(), &error))\n     LOG(ERROR) << \"CommitText failed: error=\\\"\" << error << \"\\\"\";\n }", "target": 1}
{"code": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n \tctl_dir = container_of(head, struct ctl_dir, header);\n \tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n \tpos = 2;\n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n \t\t\tbreak;\n \t\t}\n \t}\n \tsysctl_head_finish(head);\n \treturn 0;\n }", "target": 1}
{"code": "static bool CheckMov(const uint8* buffer, int buffer_size) {\n  RCHECK(buffer_size > 8);\n   int offset = 0;\n   while (offset + 8 < buffer_size) {\n    int atomsize = Read32(buffer + offset);\n     uint32 atomtype = Read32(buffer + offset + 4);\n     switch (atomtype) {\n      case TAG('f','t','y','p'):\n      case TAG('p','d','i','n'):\n      case TAG('m','o','o','v'):\n      case TAG('m','o','o','f'):\n      case TAG('m','f','r','a'):\n      case TAG('m','d','a','t'):\n      case TAG('f','r','e','e'):\n      case TAG('s','k','i','p'):\n      case TAG('m','e','t','a'):\n      case TAG('m','e','c','o'):\n      case TAG('s','t','y','p'):\n      case TAG('s','i','d','x'):\n      case TAG('s','s','i','x'):\n      case TAG('p','r','f','t'):\n      case TAG('b','l','o','c'):\n        break;\n      default:\n        return false;\n    }\n    if (atomsize == 1) {\n      if (offset + 16 > buffer_size)\n        break;\n      if (Read32(buffer + offset + 8) != 0)\n         break;  \n       atomsize = Read32(buffer + offset + 12);\n     }\n    if (atomsize <= 0)\n       break;  \n     offset += atomsize;\n   }\n  return true;\n}", "target": 1}
{"code": "h2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tassert(!WS_IsReserved(r2->req->ws));\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t\n\tif (req->req_body_status == NULL) {\n\t\tif (!http_GetHdr(req->http, H_Content_Length, NULL))\n\t\t\treq->req_body_status = BS_EOF;\n\t\telse\n\t\t\treq->req_body_status = BS_LENGTH;\n\t} else {\n\t\tassert (req->req_body_status == BS_NONE);\n\t\tr2->state = H2_S_CLOS_REM;\n\t\tif (http_GetContentLength(req->http) > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task->func = h2_do_req;\n\treq->task->priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); \n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static void perf_callchain_user_64(struct perf_callchain_entry *entry,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tunsigned long sp, next_sp;\n\tunsigned long next_ip;\n\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\tfor (;;) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\t\tif (next_sp - sp >= sizeof(struct signal_frame_64) &&\n\t\t    (is_sigreturn_64_address(next_ip, sp) ||\n\t\t     (level <= 1 && is_sigreturn_64_address(lr, sp))) &&\n\t\t    sane_signal_64_frame(sp)) {\n\t\t\tsigframe = (struct signal_frame_64 __user *) sp;\n\t\t\turegs = sigframe->uc.uc_mcontext.gp_regs;\n\t\t\tif (read_user_stack_64(&uregs[PT_NIP], &next_ip) ||\n\t\t\t    read_user_stack_64(&uregs[PT_LNK], &lr) ||\n\t\t\t    read_user_stack_64(&uregs[PT_R1], &sp))\n\t\t\t\treturn;\n\t\t\tlevel = 0;\n\t\t\tperf_callchain_store(entry, PERF_CONTEXT_USER);\n\t\t\tperf_callchain_store(entry, next_ip);\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 0)\n\t\t\tnext_ip = lr;\n\t\tperf_callchain_store(entry, next_ip);\n\t\t++level;\n\t\tsp = next_sp;\n\t}\n}", "target": 1}
{"code": "int AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe)\n{\n\tint n;\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tif(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n\tn = (u32) AVI->video_index[AVI->video_pos].len;\n\t*keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\tif (vidbuf == NULL) {\n\t\tAVI->video_pos++;\n\t\treturn n;\n\t}\n\tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n\t{\n\t\tAVI_errno = AVI_ERR_READ;\n\t\treturn -1;\n\t}\n\tAVI->video_pos++;\n\treturn n;\n}", "target": 1}
{"code": "static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {\n    if (bind(s,sa,len) == -1) {\n        anetSetError(err, \"bind: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    if (listen(s, backlog) == -1) {\n        anetSetError(err, \"listen: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}", "target": 1}
{"code": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), did_set);\n\t\t}", "target": 1}
{"code": "static void set_fdc(int drive)\n{\n\tif (drive >= 0 && drive < N_DRIVE) {\n\t\tfdc = FDC(drive);\n\t\tcurrent_drive = drive;\n\t}\n\tif (fdc != 1 && fdc != 0) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (FDCS->rawcmd == 2)\n\t\treset_fdc_info(1);\n\tif (fd_inb(FD_STATUS) != STATUS_READY)\n\t\tFDCS->reset = 1;\n}", "target": 1}
{"code": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tme = current;\n\twrite_lock_irq(&tasklist_lock);\n\tparent = me->real_parent;\n\tret = -EPERM;\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\toldcred = parent->replacement_session_keyring;\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\twrite_unlock_irq(&tasklist_lock);\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\tput_cred(cred);\n\treturn ret;\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n#else \n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif \n}", "target": 1}
{"code": "find_start_brace(void)\t    \n{\n    pos_T\tcursor_save;\n    pos_T\t*trypos;\n    pos_T\t*pos;\n    static pos_T\tpos_copy;\n    cursor_save = curwin->w_cursor;\n    while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)\n    {\n\tpos_copy = *trypos;\t\n\ttrypos = &pos_copy;\n\tcurwin->w_cursor = *trypos;\n\tpos = NULL;\n\tif ((colnr_T)cin_skip2pos(trypos) == trypos->col\n\t\t       && (pos = ind_find_start_CORS(NULL)) == NULL) \n\t    break;\n\tif (pos != NULL)\n\t    curwin->w_cursor.lnum = pos->lnum;\n    }\n    curwin->w_cursor = cursor_save;\n    return trypos;\n}", "target": 1}
{"code": "sysLocation_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"\");\n}", "target": 1}
{"code": "      DSA_Signature_Operation(const DSA_PrivateKey& dsa, const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_x(dsa.get_x()),\n         m_mod_q(dsa.group_q())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }", "target": 1}
{"code": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->arp))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, be32_to_cpu(nfserr));\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\tif (gdev->gd_maxcount != 0) {\n\t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\t\tif (nfserr) {\n\t\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\t\tgoto toosmall;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnfserr = nfserr_resource;\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = cpu_to_be32(1);\t\t\t\n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = 0;\n\t}\n\tnfserr = 0;\nout:\n\tkfree(gdev->gd_device);\n\tdprintk(\"%s: done: %d\\n\", __func__, be32_to_cpu(nfserr));\n\treturn nfserr;\ntoosmall:\n\tdprintk(\"%s: maxcount too small\\n\", __func__);\n\tneeded_len = xdr->buf->len + 4 ;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tnfserr = nfserr_resource;\n\t} else {\n\t\t*p++ = cpu_to_be32(needed_len);\n\t\tnfserr = nfserr_toosmall;\n\t}\n\tgoto out;\n}", "target": 1}
{"code": "png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n    {\n       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n       size_t row_factor =\n         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n          + 1 + (png_ptr->interlaced? 6: 0));\n       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit=PNG_UINT_31_MAX;\n       else\n          idat_limit = png_ptr->height * row_factor;\n       row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); \n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}", "target": 1}
{"code": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\ncheck:\n\twhile ((ptr = strstr(dir, \"\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\treturn rpath;\n}", "target": 1}
{"code": "SWFShape_setLeftFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tShapeRecord record;\n\tint idx;\n\tif ( shape->isEnded || shape->isMorph )\n\t\treturn;\n\tif(fill == NOFILL)\n\t{\n\t\trecord = addStyleRecord(shape);\n\t\trecord.record.stateChange->leftFill = 0;\n\t\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n\t\treturn;\n\t}\n\tidx = getFillIdx(shape, fill);\n\tif(idx == 0) \n\t{\n\t\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\t\tif(addFillStyle(shape, fill) < 0)\n \t\t\treturn;\t\t\n \t\tidx = getFillIdx(shape, fill);\n \t}\n \trecord = addStyleRecord(shape);\n \trecord.record.stateChange->leftFill = idx;\n\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n}", "target": 1}
{"code": "            Status readUTF8String( StringData* out ) {\n                int sz;\n                if ( !readNumber<int>( &sz ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n                if ( out ) {\n                    *out = StringData( _buffer + _position, sz );\n                }\n                if ( !skip( sz - 1 ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n                char c;\n                if ( !readNumber<char>( &c ) )\n                    return Status( ErrorCodes::InvalidBSON, \"invalid bson\" );\n                if ( c != 0 )\n                    return Status( ErrorCodes::InvalidBSON, \"not null terminate string\" );\n                return Status::OK();\n            }", "target": 1}
{"code": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\treturn 0;\n}", "target": 1}
{"code": "void SecurityManager::cancel_init()\n{\n    SecurityException exception;\n    if (local_participant_crypto_handle_)\n    {\n        crypto_plugin_->cryptokeyfactory()->unregister_participant(local_participant_crypto_handle_, exception);\n    }\n    if (crypto_plugin_ != nullptr)\n    {\n        delete crypto_plugin_;\n        crypto_plugin_ = nullptr;\n    }\n    if (access_plugin_ != nullptr)\n    {\n        delete access_plugin_;\n        access_plugin_ = nullptr;\n    }\n    delete authentication_plugin_;\n    authentication_plugin_ = nullptr;\n    disable_security_manager();\n}", "target": 1}
{"code": "buffer_add_range(int fd, struct evbuffer *evb, struct range *range)\n{\n\tchar\tbuf[BUFSIZ];\n\tsize_t\tn, range_sz;\n\tssize_t\tnread;\n\tif (lseek(fd, range->start, SEEK_SET) == -1)\n\t\treturn (0);\n\trange_sz = range->end - range->start + 1;\n\twhile (range_sz) {\n\t\tn = MINIMUM(range_sz, sizeof(buf));\n\t\tif ((nread = read(fd, buf, n)) == -1)\n\t\t\treturn (0);\n\t\tevbuffer_add(evb, buf, nread);\n\t\trange_sz -= nread;\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "static void __exit adpt_exit(void)\n{\n\tadpt_hba\t*pHba, *next;\n\tfor (pHba = hba_chain; pHba; pHba = next) {\n\t\tnext = pHba->next;\n\t\tadpt_release(pHba);\n\t}\n}", "target": 1}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n \t\treturn NULL;\n \t}\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n \t\tdprintk(\"%s: layout type %d not supported\\n\",\n \t\t\t__func__, layout_type);\n \t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 1}
{"code": "MediaStreamImpl::~MediaStreamImpl() {\n  DCHECK(!peer_connection_handler_);\n  if (dependency_factory_.get())\n    dependency_factory_->ReleasePeerConnectionFactory();\n  if (network_manager_) {\n    if (chrome_worker_thread_.IsRunning()) {\n       chrome_worker_thread_.message_loop()->PostTask(FROM_HERE, base::Bind(\n           &MediaStreamImpl::DeleteIpcNetworkManager,\n           base::Unretained(this)));\n     } else {\n       NOTREACHED() << \"Worker thread not running.\";\n     }\n  }\n}", "target": 1}
{"code": "void InitCodec(const vpx_codec_iface_t &iface, int width, int height,\n               vpx_codec_ctx_t *enc, vpx_codec_enc_cfg_t *cfg) {\n  ASSERT_EQ(vpx_codec_enc_config_default(&iface, cfg, 0), VPX_CODEC_OK);\n  cfg->g_w = width;\n  cfg->g_h = height;\n  cfg->g_lag_in_frames = 0;\n  cfg->g_pass = VPX_RC_ONE_PASS;\n  ASSERT_EQ(vpx_codec_enc_init(enc, &iface, cfg, 0), VPX_CODEC_OK);\n  ASSERT_EQ(vpx_codec_control_(enc, VP8E_SET_CPUUSED, 2), VPX_CODEC_OK);\n}", "target": 1}
{"code": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n {\n \tloff_t offset;\n \tint error;\n \t*prev = NULL;\t\n \tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n \t\treturn -EINVAL;\n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n \t\t\treturn -EINVAL;\n \t}\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n \toffset = (loff_t)(start - vma->vm_start)\n \t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n \tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n \t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n \t\t\t\toffset, end - start);\n \tdown_read(&current->mm->mmap_sem);\n \treturn error;\n }", "target": 1}
{"code": "int dccp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\tconst int flags = msg->msg_flags;\n\tconst int noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb;\n\tint rc, size;\n\tlong timeo;\n\ttrace_dccp_probe(sk, len);\n\tif (len > dp->dccps_mss_cache)\n\t\treturn -EMSGSIZE;\n\tlock_sock(sk);\n\tif (dccp_qpolicy_full(sk)) {\n\t\trc = -EAGAIN;\n\t\tgoto out_release;\n\t}\n\ttimeo = sock_sndtimeo(sk, noblock);\n\tif ((1 << sk->sk_state) & ~(DCCPF_OPEN | DCCPF_PARTOPEN))\n\t\tif ((rc = sk_stream_wait_connect(sk, &timeo)) != 0)\n\t\t\tgoto out_release;\n\tsize = sk->sk_prot->max_header + len;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (skb == NULL)\n\t\tgoto out_release;\n\tskb_reserve(skb, sk->sk_prot->max_header);\n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\trc = dccp_msghdr_parse(msg, skb);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\tdccp_qpolicy_push(sk, skb);\n\tif (!timer_pending(&dp->dccps_xmit_timer))\n\t\tdccp_write_xmit(sk);\nout_release:\n\trelease_sock(sk);\n\treturn rc ? : len;\nout_discard:\n\tkfree_skb(skb);\n\tgoto out_release;\n}", "target": 1}
{"code": "void test_base64_lengths(void)\n{\n  const char *in = \"FuseMuse\";\n  char out1[32];\n  char out2[32];\n  size_t enclen;\n  int declen;\n  enclen = mutt_b64_encode(out1, in, 0, 32);\n  if (!TEST_CHECK(enclen == 0))\n  {\n    TEST_MSG(\"Expected: %zu\", 0);\n    TEST_MSG(\"Actual  : %zu\", enclen);\n  }\n  out1[0] = '\\0';\n  declen = mutt_b64_decode(out2, out1);\n  if (!TEST_CHECK(declen == -1))\n  {\n    TEST_MSG(\"Expected: %zu\", -1);\n    TEST_MSG(\"Actual  : %zu\", declen);\n  }\n  for (size_t i = 1; i <= 8; ++i)\n  {\n    enclen = mutt_b64_encode(out1, in, i, 32);\n    size_t exp = ((i + 2) / 3) << 2;\n    if (!TEST_CHECK(enclen == exp))\n    {\n      TEST_MSG(\"Expected: %zu\", exp);\n      TEST_MSG(\"Actual  : %zu\", enclen);\n    }\n    declen = mutt_b64_decode(out2, out1);\n    if (!TEST_CHECK(declen == i))\n    {\n      TEST_MSG(\"Expected: %zu\", i);\n      TEST_MSG(\"Actual  : %zu\", declen);\n    }\n    out2[declen] = '\\0';\n    if (!TEST_CHECK(strncmp(out2, in, i) == 0))\n    {\n      TEST_MSG(\"Expected: %s\", in);\n      TEST_MSG(\"Actual  : %s\", out2);\n    }\n  }\n}", "target": 1}
{"code": "mm_share_sync(struct mm_master **pmm, struct mm_master **pmmalloc)\n{\n\tstruct mm_master *mm;\n\tstruct mm_master *mmalloc;\n\tstruct mm_master *mmold;\n\tstruct mmtree rb_free, rb_allocated;\n\tdebug3(\"%s: Share sync\", __func__);\n\tmm = *pmm;\n\tmmold = mm->mmalloc;\n\tmm_memvalid(mmold, mm, sizeof(*mm));\n\tmmalloc = mm_create(NULL, mm->size);\n\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\tmemcpy(mm, *pmm, sizeof(struct mm_master));\n\tmm->mmalloc = mmalloc;\n\trb_free = mm->rb_free;\n\trb_allocated = mm->rb_allocated;\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\tmm_sync_list(&rb_free, &mm->rb_free, mm, mmold);\n\tmm_sync_list(&rb_allocated, &mm->rb_allocated, mm, mmold);\n\tmm_destroy(mmold);\n\t*pmm = mm;\n\t*pmmalloc = mmalloc;\n\tdebug3(\"%s: Share sync end\", __func__);\n}", "target": 1}
{"code": "bool DNP3_Base::ParseAppLayer(Endpoint* endp)\n\t{\n\tbool orig = (endp == &orig_state);\n\tbinpac::DNP3::DNP3_Flow* flow = orig ? interp->upflow() : interp->downflow();\n\tu_char* data = endp->buffer + PSEUDO_TRANSPORT_INDEX; \n\tint len = endp->pkt_length - 5;\n\tint is_first = (endp->tpflags & 0x40) >> 6; \n\tint is_last = (endp->tpflags & 0x80) >> 7; \n\tint transport = PSEUDO_TRANSPORT_LEN;\n\tint i = 0;\n\twhile ( len > 0 )\n\t\t{\n\t\tint n = min(len, 16);\n\t\tif ( ! CheckCRC(n, data, data + n, \"app_chunk\") )\n\t\t\treturn false;\n\t\tassert(data + n < endp->buffer + endp->buffer_len);\n\t\tflow->flow_buffer()->BufferData(data + transport, data + n);\n\t\ttransport = 0;\n\t\tdata += n + 2;\n\t\tlen -= n;\n\t\t}\n\tif ( is_first )\n\t\tendp->encountered_first_chunk = true;\n\tif ( ! is_first && ! endp->encountered_first_chunk )\n\t\t{\n\t\tanalyzer->Weird(\"dnp3_first_application_layer_chunk_missing\");\n\t\treturn false;\n\t\t}\n\tif ( is_last )\n\t\t{\n\t\tflow->flow_buffer()->FinishBuffer();\n\t\tflow->FlowEOF();\n\t\tClearEndpointState(orig);\n\t\t}\n\treturn true;\n\t}", "target": 1}
{"code": "    void operator = (const IniSection &s)\n\t{\n\t    if (&s == this)\n\t    {\n\t\treturn;\n\t    } \n\t    IniBase::operator = (s);\n\t    ip = s.ip;\n\t    end_comment = s.end_comment; rewrite_by = s.rewrite_by;\n\t    container = s.container;\n\t    reindex ();\n\t}", "target": 1}
{"code": "static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_skcipher_setkey(private, key, keylen);\n}", "target": 1}
{"code": "  Ins_GETVARIATION( TT_ExecContext  exc,\n                    FT_Long*        args )\n  {\n    FT_UInt    num_axes = exc->face->blend->num_axis;\n    FT_Fixed*  coords   = exc->face->blend->normalizedcoords;\n    FT_UInt  i;\n    if ( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )\n    {\n      exc->error = FT_THROW( Stack_Overflow );\n       return;\n     }\n    for ( i = 0; i < num_axes; i++ )\n      args[i] = coords[i] >> 2; \n   }", "target": 1}
{"code": "void sw_crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto x = ctx->input(0);\n    auto i = ctx->input(1);\n    auto v = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(i.shape()),\n                errors::InvalidArgument(\"i must be a vector. \",\n                                        i.shape().DebugString()));\n    OP_REQUIRES(ctx, x.dims() == v.dims(),\n                errors::InvalidArgument(\n                    \"x and v shape doesn't match (ranks differ): \",\n                    x.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    for (int i = 1; i < x.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, x.dim_size(i) == v.dim_size(i),\n          errors::InvalidArgument(\"x and v shape doesn't match at index \", i,\n                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    Tensor y = x;  \n    if (x.NumElements() > 0 || v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }", "target": 1}
{"code": "int DCTStream::getChars(int nChars, unsigned char *buffer)\n{\n    for (int i = 0; i < nChars;) {\n        if (current == limit) {\n            if (!readLine())\n                return i;\n        }\n        int left = limit - current;\n        if (nChars < left)\n            left = nChars;\n        memcpy(buffer + i, current, left);\n        current += left;\n        i += left;\n    }\n    return nChars;\n}", "target": 1}
{"code": "exit_ext2_xattr(void)\n{\n\tmb_cache_destroy(ext2_xattr_cache);\n}", "target": 1}
{"code": "static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect)\n{\n    HTTPContext *s = h->priv_data;\n    URLContext *old_hd = s->hd;\n    int64_t old_off = s->off;\n    uint8_t old_buf[BUFFER_SIZE];\n    int old_buf_size, ret;\n    AVDictionary *options = NULL;\n    if (whence == AVSEEK_SIZE)\n        return s->filesize;\n    else if (!force_reconnect &&\n             ((whence == SEEK_CUR && off == 0) ||\n              (whence == SEEK_SET && off == s->off)))\n        return s->off;\n    else if ((s->filesize == -1 && whence == SEEK_END))\n        return AVERROR(ENOSYS);\n    if (whence == SEEK_CUR)\n        off += s->off;\n    else if (whence == SEEK_END)\n        off += s->filesize;\n    else if (whence != SEEK_SET)\n        return AVERROR(EINVAL);\n    if (off < 0)\n        return AVERROR(EINVAL);\n    s->off = off;\n    if (s->off && h->is_streamed)\n        return AVERROR(ENOSYS);\n    old_buf_size = s->buf_end - s->buf_ptr;\n    memcpy(old_buf, s->buf_ptr, old_buf_size);\n    s->hd = NULL;\n    if ((ret = http_open_cnx(h, &options)) < 0) {\n        av_dict_free(&options);\n        memcpy(s->buffer, old_buf, old_buf_size);\n        s->buf_ptr = s->buffer;\n        s->buf_end = s->buffer + old_buf_size;\n        s->hd      = old_hd;\n        s->off     = old_off;\n        return ret;\n    }\n    av_dict_free(&options);\n    ffurl_close(old_hd);\n    return off;\n}", "target": 1}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n \t\terr = do_remount_sb(sb, flags, data, 0);\n \tif (!err) {\n \t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n \t\tmnt->mnt.mnt_flags = mnt_flags;\n \t\ttouch_mnt_namespace(mnt->mnt_ns);\n \t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 1}
{"code": "int HTPFileOpenWithRange(HtpState *s, HtpTxUserData *txud, const uint8_t *filename,\n        uint16_t filename_len, const uint8_t *data, uint32_t data_len, uint64_t txid,\n        bstr *rawvalue, HtpTxUserData *htud)\n{\n    SCEnter();\n    uint16_t flags;\n    DEBUG_VALIDATE_BUG_ON(s == NULL);\n    HTTPContentRange crparsed;\n    if (HTPParseAndCheckContentRange(rawvalue, &crparsed, s, htud) != 0) {\n        return HTPFileOpen(s, txud, filename, filename_len, data, data_len, txid, STREAM_TOCLIENT);\n    }\n    flags = FileFlowToFlags(s->f, STREAM_TOCLIENT);\n    FileContainer *files = &txud->files_tc;\n    if (FileOpenFileWithId(files, &htp_sbcfg, s->file_track_id++, filename, filename_len, data,\n                data_len, flags) != 0) {\n        SCReturnInt(-1);\n    } else {\n        const HTPCfgDir *cfg = &s->cfg->response;\n        FileSetInspectSizes(files->tail, cfg->inspect_window, cfg->inspect_min_size);\n    }\n    txud->tx_data.files_opened++;\n    if (FileSetRange(files, crparsed.start, crparsed.end) < 0) {\n        SCLogDebug(\"set range failed\");\n    }\n    htp_tx_t *tx = htp_list_get(s->conn->transactions, txid);\n    if (!tx) {\n        SCReturnInt(-1);\n    }\n    uint8_t *keyurl;\n    uint32_t keylen;\n    if (tx->request_hostname != NULL) {\n        keylen = bstr_len(tx->request_hostname) + filename_len;\n        keyurl = SCMalloc(keylen);\n        if (keyurl == NULL) {\n            SCReturnInt(-1);\n        }\n        memcpy(keyurl, bstr_ptr(tx->request_hostname), bstr_len(tx->request_hostname));\n        memcpy(keyurl + bstr_len(tx->request_hostname), filename, filename_len);\n    } else {\n        SCReturnInt(0);\n    }\n    DEBUG_VALIDATE_BUG_ON(htud->file_range);\n    htud->file_range = HttpRangeContainerOpenFile(keyurl, keylen, s->f, &crparsed, &htp_sbcfg,\n            filename, filename_len, flags, data, data_len);\n    SCFree(keyurl);\n    if (htud->file_range == NULL) {\n        SCReturnInt(-1);\n    }\n    SCReturnInt(0);\n}", "target": 1}
{"code": "void vrend_renderer_context_destroy(uint32_t handle)\n{\n   struct vrend_decode_ctx *ctx;\n   bool ret;\n    if (handle >= VREND_MAX_CTX)\n       return;\n    ctx = dec_ctx[handle];\n    if (!ctx)\n       return;\n      vrend_hw_switch_context(dec_ctx[0]->grctx, true);\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_n( pj_scanner *scanner,\n\t\t\t    unsigned N, pj_str_t *out)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    pj_strset(out, scanner->curptr, N);\n    scanner->curptr += N;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "static int http_read_stream(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int err, new_location, read_ret;\n    int64_t seek_ret;\n    if (!s->hd)\n        return AVERROR_EOF;\n    if (s->end_chunked_post && !s->end_header) {\n        err = http_read_header(h, &new_location);\n        if (err < 0)\n            return err;\n    }\n    if (s->chunksize >= 0) {\n        if (!s->chunksize) {\n            char line[32];\n                do {\n                    if ((err = http_get_line(s, line, sizeof(line))) < 0)\n                        return err;\n                } while (!*line);    \n                s->chunksize = strtoll(line, NULL, 16);\n                av_log(NULL, AV_LOG_TRACE, \"Chunked encoding data size: %\"PRId64\"'\\n\",\n                        s->chunksize);\n                if (!s->chunksize)\n                    return 0;\n        }\n        size = FFMIN(size, s->chunksize);\n    }\n#if CONFIG_ZLIB\n    if (s->compressed)\n        return http_buf_read_compressed(h, buf, size);\n#endif \n    read_ret = http_buf_read(h, buf, size);\n    if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)\n        || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {\n        int64_t target = h->is_streamed ? 0 : s->off;\n        if (s->reconnect_delay > s->reconnect_delay_max)\n            return AVERROR(EIO);\n        av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRId64\" error=%s.\\n\", s->off, av_err2str(read_ret));\n        av_usleep(1000U*1000*s->reconnect_delay);\n        s->reconnect_delay = 1 + 2*s->reconnect_delay;\n        seek_ret = http_seek_internal(h, target, SEEK_SET, 1);\n        if (seek_ret != target) {\n            av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRId64\".\\n\", target);\n            return read_ret;\n        }\n        read_ret = http_buf_read(h, buf, size);\n    } else\n        s->reconnect_delay = 0;\n    return read_ret;\n}", "target": 1}
{"code": "struct dst_entry *inet6_csk_route_req(const struct sock *sk,\n\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t      const struct request_sock *req,\n\t\t\t\t      u8 proto)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = proto;\n\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tfl6->saddr = ireq->ir_v6_loc_addr;\n\tfl6->flowi6_oif = ireq->ir_iif;\n\tfl6->flowi6_mark = ireq->ir_mark;\n\tfl6->fl6_dport = ireq->ir_rmt_port;\n\tfl6->fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(fl6));\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\treturn dst;\n}", "target": 1}
{"code": "AP4_VisualSampleEntry::ReadFields(AP4_ByteStream& stream)\n{\n    AP4_Result result = AP4_SampleEntry::ReadFields(stream);\n    if (result < 0) return result;\n    stream.ReadUI16(m_Predefined1);\n    stream.ReadUI16(m_Reserved2);\n    stream.Read(m_Predefined2, sizeof(m_Predefined2));\n    stream.ReadUI16(m_Width);\n    stream.ReadUI16(m_Height);\n    stream.ReadUI32(m_HorizResolution);\n    stream.ReadUI32(m_VertResolution);\n    stream.ReadUI32(m_Reserved3);\n    stream.ReadUI16(m_FrameCount);\n    char compressor_name[33];\n    compressor_name[32] = 0;\n    stream.Read(compressor_name, 32);\n    int name_length = compressor_name[0];\n    if (name_length < 32) {\n        compressor_name[name_length+1] = 0; \n        m_CompressorName = &compressor_name[1];\n    }\n    stream.ReadUI16(m_Depth);\n    stream.ReadUI16(m_Predefined3);\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  xmlRelaxNGPtr schema;\n  VALUE errors = rb_ary_new();\n  VALUE rb_schema;\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlRelaxNGParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n \t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n \t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n \t\tif (key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \t\tkfree(key->description);\n #ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "TfLiteStatus MockCustom::Invoke(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n  const int32_t* input_data = input->data.i32;\n  const TfLiteTensor* weight = tflite::GetInput(context, node, 1);\n  const uint8_t* weight_data = weight->data.uint8;\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  int32_t* output_data = output->data.i32;\n  output_data[0] =\n      0;  \n  output_data[0] = input_data[0] + weight_data[0];\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "int options_cmdline(char *arg1, char *arg2) {\n    char *name;\n    CONF_TYPE type;\n#ifdef USE_WIN32\n    (void)arg2; \n#endif\n    if(!arg1) {\n        name=\n#ifdef CONFDIR\n            CONFDIR\n#ifdef USE_WIN32\n            \"\\\\\"\n#else\n            \"/\"\n#endif\n#endif\n            \"stunnel.conf\";\n        type=CONF_FILE;\n    } else if(!strcasecmp(arg1, \"-help\")) {\n        parse_global_option(CMD_PRINT_HELP, NULL, NULL);\n        parse_service_option(CMD_PRINT_HELP, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-version\")) {\n        parse_global_option(CMD_PRINT_DEFAULTS, NULL, NULL);\n        parse_service_option(CMD_PRINT_DEFAULTS, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-sockets\")) {\n        socket_options_print();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-options\")) {\n        print_ssl_options();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else\n#ifndef USE_WIN32\n    if(!strcasecmp(arg1, \"-fd\")) {\n        if(!arg2) {\n            s_log(LOG_ERR, \"No file descriptor specified\");\n            print_syntax();\n            return 1;\n        }\n        name=arg2;\n        type=CONF_FD;\n    } else\n#endif\n    {\n        name=arg1;\n        type=CONF_FILE;\n    }\n    if(type==CONF_FILE) {\n#ifdef HAVE_REALPATH\n        char *real_path=NULL;\n#ifdef MAXPATHLEN\n        real_path=malloc(MAXPATHLEN);\n#endif\n        real_path=realpath(name, real_path);\n        if(!real_path) {\n            s_log(LOG_ERR, \"Invalid configuration file name \\\"%s\\\"\", name);\n            ioerror(\"realpath\");\n            return 1;\n        }\n        configuration_file=str_dup(real_path);\n        free(real_path);\n#else\n        configuration_file=str_dup(name);\n#endif\n#ifndef USE_WIN32\n    } else if(type==CONF_FD) {\n        configuration_file=str_dup(name);\n#endif\n    }\n    return options_parse(type);\n}", "target": 1}
{"code": "xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){\n    xmlNodePtr cur = NULL;\n    unsigned long val;\n    xmlChar str[20];\n    if (nargs == 0) {\n\tcur = ctxt->context->node;\n    } else if (nargs == 1) {\n\txmlXPathObjectPtr obj;\n\txmlNodeSetPtr nodelist;\n\tint i, ret;\n\tif ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n\t    ctxt->error = XPATH_INVALID_TYPE;\n\t    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid arg expecting a node-set\\n\");\n\t    return;\n\t}\n\tobj = valuePop(ctxt);\n\tnodelist = obj->nodesetval;\n\tif ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n\t    xmlXPathFreeObject(obj);\n\t    valuePush(ctxt, xmlXPathNewCString(\"\"));\n\t    return;\n\t}\n\tcur = nodelist->nodeTab[0];\n\tfor (i = 1;i < nodelist->nodeNr;i++) {\n\t    ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n\t    if (ret == -1)\n\t        cur = nodelist->nodeTab[i];\n\t}\n\txmlXPathFreeObject(obj);\n    } else {\n\txsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid number of args %d\\n\", nargs);\n\tctxt->error = XPATH_INVALID_ARITY;\n\treturn;\n    }\n    val = (unsigned long)((char *)cur - (char *)0);\n    val /= sizeof(xmlNode);\n    sprintf((char *)str, \"id%ld\", val);\n    valuePush(ctxt, xmlXPathNewString(str));\n}", "target": 1}
{"code": "bool SimpleMessenger::verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t\tint protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n\t\t\t\t\tbool& isvalid,CryptoKey& session_key)\n{\n  return ms_deliver_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid,session_key);\n}", "target": 1}
{"code": "sudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw,\n    char **user_env[])\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->begin_session && !IS_DISABLED(auth)) {\n\t    int status = (auth->begin_session)(ctx, pw, user_env, auth);\n\t    if (status != AUTH_SUCCESS) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}", "target": 1}
{"code": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n \tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n \tdm_get(md);\n \treturn md;\n }", "target": 1}
{"code": "static int sony_init_ff(struct sony_sc *sc)\n{\n\tstruct hid_input *hidinput = list_entry(sc->hdev->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *input_dev = hidinput->input;\n\tinput_set_capability(input_dev, EV_FF, FF_RUMBLE);\n\treturn input_ff_create_memless(input_dev, NULL, sony_play_effect);\n}", "target": 1}
{"code": "get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\treturn 0;\n}", "target": 1}
{"code": "cib_recv_plaintext(int sock)\n{\n    char *buf = NULL;\n    ssize_t rc = 0;\n    ssize_t len = 0;\n    ssize_t chunk_size = 512;\n    buf = calloc(1, chunk_size);\n    while (1) {\n        errno = 0;\n        rc = read(sock, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n        if (errno == EINTR || errno == EAGAIN) {\n            crm_trace(\"Retry: %d\", (int)rc);\n            if (rc > 0) {\n                len += rc;\n                buf = realloc(buf, len + chunk_size);\n                CRM_ASSERT(buf != NULL);\n            }\n        } else if (rc < 0) {\n            crm_perror(LOG_ERR, \"Error receiving message: %d\", (int)rc);\n            goto bail;\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else {\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n}", "target": 1}
{"code": "void WifiPacket::handle_prism(const u_char *pc, size_t len)\n{\n    prism2_pkthdr hdr;\n    hdr.host_time \t= EXTRACT_LE_32BITS(pc+32);\n    hdr.mac_time \t= EXTRACT_LE_32BITS(pc+44);\n    hdr.channel \t= EXTRACT_LE_32BITS(pc+56);\n    hdr.rssi \t\t= EXTRACT_LE_32BITS(pc+68);\n    hdr.sq \t\t= EXTRACT_LE_32BITS(pc+80);\n    hdr.signal  \t= EXTRACT_LE_32BITS(pc+92);\n    hdr.noise   \t= EXTRACT_LE_32BITS(pc+104);\n    hdr.rate\t\t= EXTRACT_LE_32BITS(pc+116)/2;\n    hdr.istx\t\t= EXTRACT_LE_32BITS(pc+128);\n    cbs->HandlePrism( *this, &hdr, pc + 144, len - 144);\n    handle_80211(pc+144,len-144);\n}", "target": 1}
{"code": "static void *HTPStateGetTx(void *alstate, uint64_t tx_id)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL)\n        return htp_list_get(http_state->conn->transactions, tx_id);\n    else\n        return NULL;\n}", "target": 1}
{"code": "static CURLcode read_data(struct connectdata *conn,\n                          curl_socket_t fd,\n                          struct krb5buffer *buf)\n{\n  int len;\n  void *tmp = NULL;\n  CURLcode result;\n  result = socket_read(fd, &len, sizeof(len));\n  if(result)\n    return result;\n  if(len) {\n    len = ntohl(len);\n    tmp = Curl_saferealloc(buf->data, len);\n  }\n  if(tmp == NULL)\n    return CURLE_OUT_OF_MEMORY;\n  buf->data = tmp;\n  result = socket_read(fd, buf->data, len);\n  if(result)\n    return result;\n  buf->size = conn->mech->decode(conn->app_data, buf->data, len,\n                                 conn->data_prot, conn);\n  buf->index = 0;\n  return CURLE_OK;\n}", "target": 1}
{"code": "rndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\tBUFPUTSL(ob, \"<q>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</q>\");\n\treturn 1;\n}", "target": 1}
{"code": "static int smb2_calc_max_out_buf_len(struct ksmbd_work *work,\n\t\t\t\t     unsigned short hdr2_len,\n\t\t\t\t     unsigned int out_buf_len)\n{\n\tint free_len;\n\tif (out_buf_len > work->conn->vals->max_trans_size)\n\t\treturn -EINVAL;\n\tfree_len = (int)(work->response_sz -\n\t\t\t (get_rfc1002_len(work->response_buf) + 4)) -\n\t\thdr2_len;\n\tif (free_len < 0)\n\t\treturn -EINVAL;\n\treturn min_t(int, out_buf_len, free_len);\n}", "target": 1}
{"code": "static ExprList *exprListAppendList(\n  Parse *pParse,          \n  ExprList *pList,        \n  ExprList *pAppend,      \n  int bIntToNull\n){\n  if( pAppend ){\n    int i;\n    int nInit = pList ? pList->nExpr : 0;\n    for(i=0; i<pAppend->nExpr; i++){\n      Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);\n      if( bIntToNull && pDup && pDup->op==TK_INTEGER ){\n        pDup->op = TK_NULL;\n        pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);\n      }\n      pList = sqlite3ExprListAppend(pParse, pList, pDup);\n      if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;\n    }\n  }\n  return pList;\n}", "target": 1}
{"code": "void AcceptRoutingHandler<Pipeline, R>::onRoutingData(\n    uint64_t connId,\n    typename RoutingDataHandler<R>::RoutingData& routingData) {\n  auto routingPipelineIter = routingPipelines_.find(connId);\n  if (routingPipelineIter == routingPipelines_.end()) {\n    VLOG(2) << \"Connection has already been closed, \"\n               \"or routed to a worker thread.\";\n    return;\n  }\n  auto routingPipeline = std::move(routingPipelineIter->second);\n  routingPipelines_.erase(routingPipelineIter);\n  auto socket = std::dynamic_pointer_cast<folly::AsyncSocket>(\n      routingPipeline->getTransport());\n  routingPipeline->transportInactive();\n  socket->detachEventBase();\n  uint64_t hash = std::hash<R>()(routingData.routingData);\n  auto acceptor = acceptors_[hash % acceptors_.size()];\n  acceptor->getEventBase()->runInEventBaseThread(\n      [ =, routingData = std::move(routingData) ]() mutable {\n        socket->attachEventBase(acceptor->getEventBase());\n        auto routingHandler =\n            routingPipeline->template getHandler<RoutingDataHandler<R>>();\n        DCHECK(routingHandler);\n        auto transportInfo = routingPipeline->getTransportInfo();\n        auto pipeline = childPipelineFactory_->newPipeline(\n            socket, routingData.routingData, routingHandler, transportInfo);\n        auto connection =\n            new typename ServerAcceptor<Pipeline>::ServerConnection(pipeline);\n        acceptor->addConnection(connection);\n        pipeline->transportActive();\n        pipeline->read(routingData.bufQueue);\n      });\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    Buffer* buf = nullptr;\n    OP_REQUIRES_OK(ctx, GetBuffer(ctx, def(), &buf));\n    core::ScopedUnref scope(buf);\n    Buffer::Tuple tuple;\n    std::size_t index = ctx->input(0).scalar<int>()();\n    OP_REQUIRES_OK(ctx, buf->Peek(index, &tuple));\n    OP_REQUIRES(\n        ctx, tuple.size() == (size_t)ctx->num_outputs(),\n        errors::InvalidArgument(\"Mismatch stage/unstage: \", tuple.size(),\n                                \" vs. \", ctx->num_outputs()));\n    for (size_t i = 0; i < tuple.size(); ++i) {\n      ctx->set_output(i, tuple[i]);\n    }\n  }", "target": 1}
{"code": "static int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\toidc_debug(r, \"enter\");\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_get_redirect_uri(r, c));\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}", "target": 1}
{"code": "decodeJsonStructure(void *dst, const UA_DataType *type, CtxJson *ctx, \n                    ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) moveToken;\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    uintptr_t ptr = (uintptr_t)dst;\n    status ret = UA_STATUSCODE_GOOD;\n    u8 membersSize = type->membersSize;\n    const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n    UA_STACKARRAY(DecodeEntry, entries, membersSize);\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        entries[i].type = mt;\n        if(!m->isArray) {\n            ptr += m->padding;\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = decodeJsonJumpTable[mt->typeKind];\n            entries[i].found = false;\n            ptr += mt->memSize;\n        } else {\n            ptr += m->padding;\n            ptr += sizeof(size_t);\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = (decodeJsonSignature)Array_decodeJson;\n            entries[i].found = false;\n            ptr += sizeof(void*);\n        }\n    }\n    ret = decodeFields(ctx, parseCtx, entries, membersSize, type);\n    ctx->depth--;\n    return ret;\n}", "target": 1}
{"code": "sp<ABuffer> decodeBase64(const AString &s) {\n size_t n = s.size();\n if ((n % 4) != 0) {\n return NULL;\n }\n size_t padding = 0;\n if (n >= 1 && s.c_str()[n - 1] == '=') {\n        padding = 1;\n if (n >= 2 && s.c_str()[n - 2] == '=') {\n            padding = 2;\n if (n >= 3 && s.c_str()[n - 3] == '=') {\n                padding = 3;\n }\n }\n }\n size_t outLen = (n / 4) * 3 - padding;\n    sp<ABuffer> buffer = new ABuffer(outLen);\n uint8_t *out = buffer->data();\n if (out == NULL || buffer->size() < outLen) {\n return NULL;\n }\n size_t j = 0;\n uint32_t accum = 0;\n for (size_t i = 0; i < n; ++i) {\n char c = s.c_str()[i];\n unsigned value;\n if (c >= 'A' && c <= 'Z') {\n            value = c - 'A';\n } else if (c >= 'a' && c <= 'z') {\n            value = 26 + c - 'a';\n } else if (c >= '0' && c <= '9') {\n            value = 52 + c - '0';\n } else if (c == '+') {\n            value = 62;\n } else if (c == '/') {\n            value = 63;\n } else if (c != '=') {\n return NULL;\n } else {\n if (i < n - padding) {\n return NULL;\n }\n            value = 0;\n }\n         accum = (accum << 6) | value;\n         if (((i + 1) % 4) == 0) {\n            out[j++] = (accum >> 16);\n             if (j < outLen) { out[j++] = (accum >> 8) & 0xff; }\n             if (j < outLen) { out[j++] = accum & 0xff; }\n            accum = 0;\n }\n }\n return buffer;\n}", "target": 1}
{"code": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n     ctx = (krb5_gss_ctx_id_t) context_handle;\n    if (! ctx->established) {\n         *minor_status = KG_CTX_INCOMPLETE;\n         return(GSS_S_NO_CONTEXT);\n     }\n     if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                      KG_TOK_DEL_CTX)))\n         return(majerr);\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n }", "target": 1}
{"code": "static void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tif (fepriv)\n\t\tdvb_free_device(fepriv->dvbdev);\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\tif (fepriv)\n\t\tkfree(fepriv);\n}", "target": 1}
{"code": "    Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) {\n        if (!getSSLManager()) {\n            return Status(ErrorCodes::ProtocolError,\n                          \"SSL support is required for the MONGODB-X509 mechanism.\");\n        }\n        if(user.getDB() != \"$external\") {\n            return Status(ErrorCodes::ProtocolError,\n                          \"X.509 authentication must always use the $external database.\");\n        }\n        ClientBasic *client = ClientBasic::getCurrent();\n        AuthorizationSession* authorizationSession = client->getAuthorizationSession();\n        std::string subjectName = client->port()->getX509SubjectName();\n        if (user.getUser() != subjectName) {\n            return Status(ErrorCodes::AuthenticationFailed,\n                          \"There is no x.509 client certificate matching the user.\");\n        }\n        else {\n            std::string srvSubjectName = getSSLManager()->getServerSubjectName();\n            std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find(\",OU=\"));\n            std::string peerClusterId = subjectName.substr(subjectName.find(\",OU=\"));\n            fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName);\n            int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); \n            if (srvClusterId == peerClusterId) {\n                if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||\n                    clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {\n                    return Status(ErrorCodes::AuthenticationFailed, \"The provided certificate \" \n                                  \"can only be used for cluster authentication, not client \" \n                                  \"authentication. The current configuration does not allow \" \n                                  \"x.509 cluster authentication, check the --clusterAuthMode flag\");\n                }\n                authorizationSession->grantInternalAuthorization();\n            }\n            else {\n                if (_isX509AuthDisabled) {\n                    return Status(ErrorCodes::BadValue,\n                                  _x509AuthenticationDisabledMessage);\n                }\n                Status status = authorizationSession->addAndAuthorizeUser(user);\n                if (!status.isOK()) {\n                    return status;\n                }\n            }\n            return Status::OK();\n        }\n    }", "target": 1}
{"code": "int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n{\n\tint rc = MOSQ_ERR_SUCCESS, rc2;\n\tstruct mosquitto__subhier *subhier;\n\tchar **split_topics = NULL;\n\tchar *local_topic = NULL;\n\tassert(topic);\n\tif(sub__topic_tokenise(topic, &local_topic, &split_topics, NULL)) return 1;\n\tdb__msg_store_ref_inc(*stored);\n\tHASH_FIND(hh, db.subs, split_topics[0], strlen(split_topics[0]), subhier);\n\tif(subhier){\n\t\trc = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n\t}\n\tif(retain){\n\t\trc2 = retain__store(topic, *stored, split_topics);\n\t\tif(rc2) rc = rc2;\n\t}\n\tmosquitto__free(split_topics);\n\tmosquitto__free(local_topic);\n\tdb__msg_store_ref_dec(stored);\n\treturn rc;\n}", "target": 1}
{"code": "int BUFFER_append(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)\n{\n    int result;\n    if ( (handle1 == NULL) || (handle2 == NULL) || (handle1 == handle2) )\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        BUFFER* b1 = (BUFFER*)handle1;\n        BUFFER* b2 = (BUFFER*)handle2;\n        if (b1->buffer == NULL)\n        {\n            result = MU_FAILURE;\n        }\n        else if (b2->buffer == NULL)\n        {\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (b2->size ==0)\n            {\n                result = 0;\n            }\n            else\n            {\n                unsigned char* temp = (unsigned char*)realloc(b1->buffer, b1->size + b2->size);\n                if (temp == NULL)\n                {\n                    LogError(\"Failure: allocating temp buffer.\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    b1->buffer = temp;\n                    (void)memcpy(&b1->buffer[b1->size], b2->buffer, b2->size);\n                    b1->size += b2->size;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}", "target": 1}
{"code": "deltas_head_add(struct deltas_head *deltas, unsigned long max_serial,\n    unsigned long serial, char *uri, unsigned char *hash, size_t hash_len)\n{\n\tstruct delta_head *elem;\n\tsize_t position;\n\tint error;\n\tposition = deltas->capacity - 1 - (max_serial - serial);\n\tif (position < 0 || position > deltas->capacity - 1)\n\t\treturn -EINVAL;\n\tif (deltas->array[position] != NULL)\n\t\treturn -EEXIST;\n\telem = NULL;\n\terror = delta_head_create(&elem);\n\tif (error)\n\t\treturn error;\n\telem->serial = serial;\n\telem->doc_data.uri = strdup(uri);\n\tif (elem->doc_data.uri == NULL) {\n\t\tfree(elem);\n\t\treturn pr_enomem();\n\t}\n\telem->doc_data.hash_len = hash_len;\n\telem->doc_data.hash = malloc(hash_len);\n\tif (elem->doc_data.hash == NULL) {\n\t\tfree(elem->doc_data.uri);\n\t\tfree(elem);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(elem->doc_data.hash, hash, hash_len);\n\tdeltas->array[position] = elem;\n\tdeltas->len++;\n\treturn 0;\n}", "target": 1}
{"code": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}", "target": 1}
{"code": "static void add_probe(const char *name)\n {\n \tstruct module_entry *m;\n \tm = get_or_add_modentry(name);\n \tif (!(option_mask32 & (OPT_REMOVE | OPT_SHOW_DEPS))\n \t && (m->flags & MODULE_FLAG_LOADED)\n\t && strncmp(m->modname, \"symbol:\", 7) == 0\n\t) {\n\t\tG.need_symbols = 1;\n\t}\n}", "target": 1}
{"code": "void removeAllDOMObjects()\n{\n     DOMDataStore& store = DOMData::getCurrentStore();\n     v8::HandleScope scope;\n    if (isMainThread()) {\n        DOMData::removeObjectsFromWrapperMap<Node>(&store, store.domNodeMap());\n        DOMData::removeObjectsFromWrapperMap<Node>(&store, store.activeDomNodeMap());\n    }\n     DOMData::removeObjectsFromWrapperMap<void>(&store, store.domObjectMap());\n }", "target": 1}
{"code": "static const char *adpt_info(struct Scsi_Host *host)\n{\n\tadpt_hba* pHba;\n\tpHba = (adpt_hba *) host->hostdata[0];\n\treturn (char *) (pHba->detail);\n}", "target": 1}
{"code": "static int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\tstrcpy(buff,\"/tmp/nodau.XXXXXX\");\n\tfd = mkstemp(buff);\n\tif (fd < 0)\n\t\treturn 1;\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\tl = strstr(b,\"-----\");\n\t\t\t\tif (l) {\n\t\t\t\t\tl += 6;\n\t\t\t\t\tif (db_update(name,l))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tprintf(\"%s saved\\n\",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\tsz = sprintf(\n\t\tb,\n\t\t\"%s (%s)\\nText above this line is ignored\\n-----\\n%s\",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\tst = execl(editor,editor,buff,(char*)NULL);\n\texit(st);\n\treturn 1;\n}", "target": 1}
{"code": "  static Status ParseEquation(const string& equation,\n                              OperandLabels* input_labels,\n                              Labels* output_labels,\n                              std::vector<DimensionType>* label_types,\n                              OperandLabelCounts* input_label_counts,\n                              LabelCounts* output_label_counts,\n                              gtl::InlinedVector<bool, 2>* input_has_ellipsis,\n                              bool* output_has_ellipsis) {\n    gtl::InlinedVector<string, 2> input_str;\n    string output_str;\n    TF_RETURN_IF_ERROR(ParseEinsumEquation(equation, &input_str, &output_str));\n    absl::flat_hash_map<char, int> label_mapping;\n    int num_inputs = input_str.size();\n    input_labels->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      MapToLabels(input_str[i], &input_labels->at(i), &label_mapping);\n    }\n    MapToLabels(output_str, output_labels, &label_mapping);\n    int num_labels = label_mapping.size();\n    input_label_counts->resize(num_inputs);\n    input_has_ellipsis->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      input_label_counts->at(i).resize(num_labels);\n      for (const int label : input_labels->at(i)) {\n        if (label != kEllipsisLabel)\n          input_label_counts->at(i)[label] += 1;\n        else\n          input_has_ellipsis->at(i) = true;\n      }\n    }\n    output_label_counts->resize(num_labels);\n    for (const int label : *output_labels) {\n      if (label != kEllipsisLabel)\n        output_label_counts->at(label) += 1;\n      else\n        *output_has_ellipsis = true;\n    }\n    label_types->resize(num_labels);\n    for (int label = 0; label < num_labels; ++label) {\n      if (label == kEllipsisLabel) continue;\n      bool removed = (*output_label_counts)[label] == 0;\n      bool unique = num_inputs == 1 || (*input_label_counts)[0][label] == 0 ||\n                    (*input_label_counts)[1][label] == 0;\n      (*label_types)[label] = GetDimensionType(removed, unique);\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "MagickExport void *ResizeQuantumMemory(void *memory,const size_t count,\n  const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    {\n      memory=RelinquishMagickMemory(memory);\n      return((void *) NULL);\n    }\n  extent=count*quantum;\n  return(ResizeMagickMemory(memory,extent));\n}", "target": 1}
{"code": "static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)\n\t{\n\tunsigned char buf[4096];\n\tint r = 0, i;\n\tBIO *tmpout = NULL;\n\tif (out == NULL)\n\t\ttmpout = BIO_new(BIO_s_null());\n\telse if (flags & CMS_TEXT)\n\t\t{\n\t\ttmpout = BIO_new(BIO_s_mem());\n\t\tBIO_set_mem_eof_return(tmpout, 0);\n\t\t}\n\telse\n\t\ttmpout = out;\n\tif(!tmpout)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tfor (;;)\n\t{\n\t\ti=BIO_read(in,buf,sizeof(buf));\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\tif (BIO_method_type(in) == BIO_TYPE_CIPHER)\n\t\t\t\t{\n\t\t\t\tif (!BIO_get_cipher_status(in))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (i < 0)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\t\t}\n\t\tif (tmpout && (BIO_write(tmpout, buf, i) != i))\n\t\t\tgoto err;\n\t}\n\tif(flags & CMS_TEXT)\n\t\t{\n\t\tif(!SMIME_text(tmpout, out))\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,CMS_R_SMIME_TEXT_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\tr = 1;\n\terr:\n\tif (tmpout && (tmpout != out))\n\t\tBIO_free(tmpout);\n\treturn r;\n\t}", "target": 1}
{"code": "static int ssl_parse_supported_elliptic_curves( ssl_context *ssl,\n                                                const unsigned char *buf,\n                                                size_t len )\n{\n    size_t list_size, our_size;\n    const unsigned char *p;\n    const ecp_curve_info *curve_info, **curves;\n    list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );\n    if( list_size + 2 != len ||\n        list_size % 2 != 0 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n    our_size = list_size / 2 + 1;\n    if( our_size > POLARSSL_ECP_DP_MAX )\n        our_size = POLARSSL_ECP_DP_MAX;\n    if( ( curves = polarssl_malloc( our_size * sizeof( *curves ) ) ) == NULL )\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    memset( (void *) curves, 0, our_size * sizeof( *curves ) );\n    ssl->handshake->curves = curves;\n    p = buf + 2;\n    while( list_size > 0 && our_size > 1 )\n    {\n        curve_info = ecp_curve_info_from_tls_id( ( p[0] << 8 ) | p[1] );\n        if( curve_info != NULL )\n        {\n            *curves++ = curve_info;\n            our_size--;\n        }\n        list_size -= 2;\n        p += 2;\n    }\n    return( 0 );\n}", "target": 1}
{"code": "void CSecurityTLS::initGlobal()\n{\n  static bool globalInitDone = false;\n  if (!globalInitDone) {\n    gnutls_global_init();\n    globalInitDone = true;\n  }\n}", "target": 1}
{"code": "  Value GetValueOrCreatePlaceholder(StringRef full_name) {\n    StringRef node_name;\n    StringRef output_name = \"\";\n    bool is_control_dep = full_name[0] == '^';\n    int output_num = 0;\n    if (is_control_dep) full_name = full_name.drop_front();\n    {\n      size_t colon_sep = full_name.find_first_of(':');\n      if (colon_sep == StringRef::npos) {\n        node_name = full_name;\n      } else {\n        node_name = full_name.take_front(colon_sep);\n        output_name = full_name.drop_front(colon_sep + 1);\n      }\n      colon_sep = output_name.find_last_of(':');\n      if (colon_sep != StringRef::npos) {\n        unsigned long long value;\n        if (!llvm::getAsUnsignedInteger(output_name.drop_front(colon_sep + 1),\n                                        10, value))\n          output_num = value;\n        output_name = output_name.take_front(colon_sep);\n      }\n    }\n    llvm::StringMap<SmallVector<Value, 1>>& op_info = values_map_[node_name];\n    SmallVector<Value, 1>& base_operation = op_info[\"^\"];\n    if (base_operation.empty()) {\n      OperationState state(loc_, mlir_placeholder_);\n      state.addAttribute(TFGraphDialect::getNameAttrKey(),\n                         builder_.getStringAttr(node_name));\n      state.types.push_back(placeholder_ty_);\n      state.types.push_back(control_ty_);\n      Operation* placeholder = builder_.create(state);\n      base_operation.push_back(placeholder->getResult(1));\n      base_operation.push_back(placeholder->getResult(0));\n    }\n    if (is_control_dep) return base_operation[0];\n    SmallVector<Value, 1>& value_info = op_info[output_name];\n    if (value_info.size() <= output_num)\n      value_info.resize(output_num + 1, Value{});\n    if (!value_info[output_num]) {\n      value_info[output_num] = builder_.create<GetResultOp>(\n          loc_, base_operation[1], output_name, output_num);\n    }\n    return value_info[output_num];\n  }", "target": 1}
{"code": "static void O_getOwnPropertyDescriptor(js_State *J)\n{\n\tjs_Object *obj;\n\tjs_Property *ref;\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\tref = jsV_getproperty(J, obj, js_tostring(J, 2));\n\tif (!ref) {\n\t\tjs_pushundefined(J);\n\t} else {\n\t\tjs_newobject(J);\n\t\tif (!ref->getter && !ref->setter) {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t\tjs_setproperty(J, -2, \"value\");\n\t\t\tjs_pushboolean(J, !(ref->atts & JS_READONLY));\n\t\t\tjs_setproperty(J, -2, \"writable\");\n\t\t} else {\n\t\t\tif (ref->getter)\n\t\t\t\tjs_pushobject(J, ref->getter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_setproperty(J, -2, \"get\");\n\t\t\tif (ref->setter)\n\t\t\t\tjs_pushobject(J, ref->setter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_setproperty(J, -2, \"set\");\n\t\t}\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTENUM));\n\t\tjs_setproperty(J, -2, \"enumerable\");\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTCONF));\n\t\tjs_setproperty(J, -2, \"configurable\");\n\t}\n}", "target": 1}
{"code": "static struct inet_frag_queue *inet_frag_intern(struct netns_frags *nf,\n\t\tstruct inet_frag_queue *qp_in, struct inet_frags *f,\n\t\tvoid *arg)\n{\n\tstruct inet_frag_bucket *hb;\n\tstruct inet_frag_queue *qp;\n\tunsigned int hash;\n\tread_lock(&f->lock); \n\thash = f->hashfn(qp_in);\n\thb = &f->hash[hash];\n\tspin_lock(&hb->chain_lock);\n#ifdef CONFIG_SMP\n\thlist_for_each_entry(qp, &hb->chain, list) {\n\t\tif (qp->net == nf && f->match(qp, arg)) {\n\t\t\tatomic_inc(&qp->refcnt);\n\t\t\tspin_unlock(&hb->chain_lock);\n\t\t\tread_unlock(&f->lock);\n\t\t\tqp_in->last_in |= INET_FRAG_COMPLETE;\n\t\t\tinet_frag_put(qp_in, f);\n\t\t\treturn qp;\n\t\t}\n\t}\n#endif\n\tqp = qp_in;\n\tif (!mod_timer(&qp->timer, jiffies + nf->timeout))\n\t\tatomic_inc(&qp->refcnt);\n\tatomic_inc(&qp->refcnt);\n\thlist_add_head(&qp->list, &hb->chain);\n\tspin_unlock(&hb->chain_lock);\n\tread_unlock(&f->lock);\n\tinet_frag_lru_add(nf, qp);\n\treturn qp;\n}", "target": 1}
{"code": "static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)\n{\n\txmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);\n\tif (!result) {\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\t\tthrow XMLException(\"Invalid XPath: \" + xpath);\n\t}\n\tif (result->type != XPATH_NODESET) {\n\t\txmlXPathFreeObject(result);\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\t\tthrow XMLException(\"Only nodeset result types are supported.\");\n\t}\n\txmlNodeSet* nodeset = result->nodesetval;\n\tXMLSharedNodeList* nodes = new XMLSharedNodeList();\n\tif (nodeset) {\n\t\tfor (int i = 0; i < nodeset->nodeNr; ++i) {\n\t\t\tXMLNode* node = readnode(nodeset->nodeTab[i]);\n\t\t\tnodes->push_back(boost::shared_ptr<XMLNode>(node));\n\t\t}\n\t} else {\n\t}\n\txmlXPathFreeObject(result);\n\treturn nodes;\n}", "target": 1}
{"code": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma)\n{\n\tunsigned long hstart, hend;\n\tif (!vma->anon_vma)\n\t\treturn 0;\n\tif (vma->vm_file || vma->vm_ops)\n\t\treturn 0;\n\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma);\n\treturn 0;\n}", "target": 1}
{"code": "compat_mpt_command(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_ioctl_command32 karg32;\n\tstruct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;\n\tstruct mpt_ioctl_command karg;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\tif (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32)))\n\t\treturn -EFAULT;\n\tiocnumX = karg32.hdr.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mpt_command @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mpt_command() called\\n\",\n\t    iocp->name));\n\tkarg.hdr.iocnum = karg32.hdr.iocnum;\n\tkarg.hdr.port = karg32.hdr.port;\n\tkarg.timeout = karg32.timeout;\n\tkarg.maxReplyBytes = karg32.maxReplyBytes;\n\tkarg.dataInSize = karg32.dataInSize;\n\tkarg.dataOutSize = karg32.dataOutSize;\n\tkarg.maxSenseBytes = karg32.maxSenseBytes;\n\tkarg.dataSgeOffset = karg32.dataSgeOffset;\n\tkarg.replyFrameBufPtr = (char __user *)(unsigned long)karg32.replyFrameBufPtr;\n\tkarg.dataInBufPtr = (char __user *)(unsigned long)karg32.dataInBufPtr;\n\tkarg.dataOutBufPtr = (char __user *)(unsigned long)karg32.dataOutBufPtr;\n\tkarg.senseDataPtr = (char __user *)(unsigned long)karg32.senseDataPtr;\n\tret = mptctl_do_mpt_command (karg, &uarg->MF);\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\treturn ret;\n}", "target": 1}
{"code": "blkcpy(void * dest, void * src, size_t len)\n{\n  memcpy(dest, src, len);\n}", "target": 1}
{"code": "char *RootdExpandPathName(const char *name)\n{\n   const char *patbuf = name;\n   while (*patbuf == ' ')\n      patbuf++;\n   for (const char *p = patbuf; *p; p++)\n      if (strchr(shellMeta, *p))\n         goto needshell;\n   return strdup(name);\nneedshell:\n   char escPatbuf[kMAXPATHLEN];\n   EscChar(patbuf, escPatbuf, sizeof(escPatbuf), shellStuff, shellEscape);\n   char cmd[kMAXPATHLEN];\n#ifdef __hpux\n   strlcpy(cmd, \"/bin/echo \", sizeof(cmd));\n#else\n   strlcpy(cmd, \"echo \", sizeof(cmd));\n#endif\n   if (escPatbuf[0] == '~') {\n      const char *hd;\n      if (escPatbuf[1] != '\\0' && escPatbuf[1] != '/') {\n         char uname[70], *p, *q;\n         for (p = &escPatbuf[1], q = uname; *p && *p !='/';)\n            *q++ = *p++;\n         *q = '\\0';\n         hd = HomeDirectory(uname);\n         if (hd == 0)\n            strcat(cmd, escPatbuf);\n         else {\n            strcat(cmd, hd);\n            strcat(cmd, p);\n         }\n      } else {\n         hd = HomeDirectory(0);\n         if (hd == 0) {\n            Error(ErrSys, kErrFatal, \"RootdExpandPathName: no home directory\");\n            return 0;\n         }\n         strcat(cmd, hd);\n         strcat(cmd, &escPatbuf[1]);\n      }\n   } else\n      strcat(cmd, escPatbuf);\n   FILE *pf;\n   if ((pf = ::popen(&cmd[0], \"r\")) == 0) {\n      Error(ErrSys, kErrFatal, \"RootdExpandPathName: error in popen(%s)\", cmd);\n      return 0;\n   }\n   char expPatbuf[kMAXPATHLEN];\n   int  ch, i, cnt = 0;\nagain:\n   for (i = 0, ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\\n'; i++, ch = fgetc(pf)) {\n      expPatbuf[i] = ch;\n      cnt++;\n   }\n   if (cnt == 0 && ch == EOF) goto again;\n   expPatbuf[cnt] = '\\0';\n   while (ch != EOF) {\n      ch = fgetc(pf);\n      if (ch == ' ' || ch == '\\t') {\n         ::pclose(pf);\n         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: expression ambigous\");\n         return 0;\n      }\n   }\n   ::pclose(pf);\n   return strdup(expPatbuf);\n}", "target": 1}
{"code": "char* parse_content_length( char* buffer, char* end, int* length)\n{\n\tint number;\n\tchar *p;\n\tint  size;\n\tp = buffer;\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\tnumber = number*10 + (*p)-'0';\n\t\tif (number<0) {\n\t\t\tLM_ERR(\"number overflow at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\tif ( (*(p++)!='\\n') && (*(p-1)!='\\r' || *(p++)!='\\n' ) )\n\t\tgoto error;\n\t*length = number;\n\treturn p;\nerror:\n\tLM_ERR(\"parse error near char [%d][%c]\\n\",*p,*p);\n\treturn 0;\n}", "target": 1}
{"code": "verify_host_key(char *host, struct sockaddr *hostaddr, Key *host_key)\n{\n\tint flags = 0;\n\tchar *fp;\n\tfp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);\n\tdebug(\"Server host key: %s %s\", key_type(host_key), fp);\n\tfree(fp);\n\tif (!key_is_cert(host_key) && options.verify_host_key_dns &&\n\t    verify_host_key_dns(host, hostaddr, host_key, &flags) == 0) {\n\t\tif (flags & DNS_VERIFY_FOUND) {\n\t\t\tif (options.verify_host_key_dns == 1 &&\n\t\t\t    flags & DNS_VERIFY_MATCH &&\n\t\t\t    flags & DNS_VERIFY_SECURE)\n\t\t\t\treturn 0;\n\t\t\tif (flags & DNS_VERIFY_MATCH) {\n\t\t\t\tmatching_host_key_dns = 1;\n\t\t\t} else {\n\t\t\t\twarn_changed_key(host_key);\n\t\t\t\terror(\"Update the SSHFP RR in DNS with the new \"\n\t\t\t\t    \"host key to get rid of this message.\");\n\t\t\t}\n\t\t}\n\t}\n\treturn check_host_key(host, hostaddr, options.port, host_key, RDRW,\n\t    options.user_hostfiles, options.num_user_hostfiles,\n\t    options.system_hostfiles, options.num_system_hostfiles);\n}", "target": 1}
{"code": "int LightProcess::pclose(FILE *f) {\n  if (!Available()) {\n    return ::pclose(f);\n  }\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  std::map<int64_t, int64_t>::iterator it = g_procs[id].m_popenMap.find((int64_t)f);\n  if (it == g_procs[id].m_popenMap.end()) {\n    return ::pclose(f);\n  }\n  int64_t f2 = it->second;\n  g_procs[id].m_popenMap.erase((int64_t)f);\n  fclose(f);\n  fprintf(g_procs[id].m_fout, \"pclose\\n%\" PRId64 \"\\n\", f2);\n  fflush(g_procs[id].m_fout);\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  int ret = -1;\n  sscanf(buf, \"%d\", &ret);\n  if (ret < 0) {\n    read_buf(g_procs[id].m_fin, buf);\n    sscanf(buf, \"%d\", &errno);\n  }\n  return ret;\n}", "target": 1}
{"code": "static void ConvertLoopSlice(ModSample &src, ModSample &dest, SmpLength start, SmpLength len, bool loop)\n{\n\tif(!src.HasSampleData()) return;\n\tdest.FreeSample();\n\tdest = src;\n\tdest.nLength = len;\n\tdest.pSample = nullptr;\n\tif(!dest.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\tif(len != src.nLength)\n\t\tMemsetZero(dest.cues);\n\tstd::memcpy(dest.pSample8, src.pSample8 + start, len);\n\tdest.uFlags.set(CHN_LOOP, loop);\n\tif(loop)\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = len;\n\t} else\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = 0;\n\t}\n}", "target": 1}
{"code": "PGTYPESdate_from_asc(char *str, char **endptr)\n{\n\tdate\t\tdDate;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + 1];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\tbool\t\tEuroDates = FALSE;\n\terrno = 0;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\treturn INT_MIN;\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, EuroDates) != 0)\n\t{\n\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\treturn INT_MIN;\n\t}\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tbreak;\n\t\tcase DTK_EPOCH:\n\t\t\tif (GetEpochTime(tm) < 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\t\treturn INT_MIN;\n\t}\n\tdDate = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - date2j(2000, 1, 1));\n\treturn dDate;\n}", "target": 1}
{"code": "process_rs(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tdouble delay;\n\tdouble next;\n\tstruct timeval tv;\n\tuint8_t *opt_str;\n\tlen -= sizeof(struct nd_router_solicit);\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_solicit));\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"trailing garbage in RS\");\n\t\t\treturn;\n\t\t}\n\t\toptlen = (opt_str[1] << 3);\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"zero length option in RS\");\n\t\t\treturn;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"option length greater than total length in RS\");\n\t\t\treturn;\n\t\t}\n\t\tif (*opt_str == ND_OPT_SOURCE_LINKADDR &&\n\t\t    IN6_IS_ADDR_UNSPECIFIED(&addr->sin6_addr)) {\n\t\t\tflog(LOG_WARNING, \"received icmpv6 RS packet with unspecified source address and there is a lladdr option\");\n\t\t\treturn;\n\t\t}\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n\tgettimeofday(&tv, NULL);\n\tdelay = MAX_RA_DELAY_TIME * rand() / (RAND_MAX +1.0);\n\tif (iface->UnicastOnly) {\n\t\tdlog(LOG_DEBUG, 5, \"random mdelay for %s: %g seconds.\", iface->Name, delay/1000.0);\n\t\tmdelay(delay);\n\t\tsend_ra_forall(iface, &addr->sin6_addr);\n\t}\n\telse if ( timevaldiff(&tv, &iface->last_multicast) / 1000.0 < iface->MinDelayBetweenRAs ) {\n\t\tnext = iface->MinDelayBetweenRAs - (tv.tv_sec + tv.tv_usec / 1000000.0) + (iface->last_multicast.tv_sec + iface->last_multicast.tv_usec / 1000000.0) + delay/1000.0;\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n\telse {\n\t\tsend_ra_forall(iface, NULL);\n\t\tnext = rand_between(iface->MinRtrAdvInterval, iface->MaxRtrAdvInterval);\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n}", "target": 1}
{"code": "snmp_ber_decode_null(unsigned char *buf, uint32_t *buff_len)\n{\n  buf++;\n  (*buff_len)--;\n  buf++;\n  (*buff_len)--;\n  return buf;\n}", "target": 1}
{"code": "GF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\ts->size += 51 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}", "target": 1}
{"code": "std::set<std::string> GetDistinctHosts(const URLPatternSet& host_patterns,\n                                       bool include_rcd,\n                                       bool exclude_file_scheme) {\n  typedef base::StringPairs HostVector;\n  HostVector hosts_best_rcd;\n  for (const URLPattern& pattern : host_patterns) {\n    if (exclude_file_scheme && pattern.scheme() == url::kFileScheme)\n       continue;\n     std::string host = pattern.host();\n     if (pattern.match_subdomains())\n      host = \"*.\" + host;\n    std::string rcd;\n    size_t reg_len =\n        net::registry_controlled_domains::PermissiveGetHostRegistryLength(\n            host, net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES,\n            net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);\n    if (reg_len && reg_len != std::string::npos) {\n      if (include_rcd)  \n        rcd = host.substr(host.size() - reg_len);\n      host = host.substr(0, host.size() - reg_len);\n    }\n    HostVector::iterator it = hosts_best_rcd.begin();\n    for (; it != hosts_best_rcd.end(); ++it) {\n      if (it->first == host)\n        break;\n    }\n    if (it != hosts_best_rcd.end()) {\n      if (include_rcd && RcdBetterThan(rcd, it->second))\n        it->second = rcd;\n    } else {  \n      hosts_best_rcd.push_back(std::make_pair(host, rcd));\n    }\n  }\n  std::set<std::string> distinct_hosts;\n  for (const auto& host_rcd : hosts_best_rcd)\n    distinct_hosts.insert(host_rcd.first + host_rcd.second);\n  return distinct_hosts;\n}", "target": 1}
{"code": "vrrp_print_stats(void)\n{\n\tFILE *file;\n\tfile = fopen (stats_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tstats_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tlist l = vrrp_data->vrrp;\n\telement e;\n\tvrrp_t *vrrp;\n\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\t\tfprintf(file, \"VRRP Instance: %s\\n\", vrrp->iname);\n\t\tfprintf(file, \"  Advertisements:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->advert_rcvd);\n\t\tfprintf(file, \"    Sent: %d\\n\", vrrp->stats->advert_sent);\n\t\tfprintf(file, \"  Became master: %d\\n\", vrrp->stats->become_master);\n\t\tfprintf(file, \"  Released master: %d\\n\",\n\t\t\tvrrp->stats->release_master);\n\t\tfprintf(file, \"  Packet Errors:\\n\");\n\t\tfprintf(file, \"    Length: %\" PRIu64 \"\\n\", vrrp->stats->packet_len_err);\n\t\tfprintf(file, \"    TTL: %\" PRIu64 \"\\n\", vrrp->stats->ip_ttl_err);\n\t\tfprintf(file, \"    Invalid Type: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->invalid_type_rcvd);\n\t\tfprintf(file, \"    Advertisement Interval: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->advert_interval_err);\n\t\tfprintf(file, \"    Address List: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->addr_list_err);\n\t\tfprintf(file, \"  Authentication Errors:\\n\");\n\t\tfprintf(file, \"    Invalid Type: %d\\n\",\n\t\t\tvrrp->stats->invalid_authtype);\n#ifdef _WITH_VRRP_AUTH_\n\t\tfprintf(file, \"    Type Mismatch: %d\\n\",\n\t\t\tvrrp->stats->authtype_mismatch);\n\t\tfprintf(file, \"    Failure: %d\\n\",\n\t\t\tvrrp->stats->auth_failure);\n#endif\n\t\tfprintf(file, \"  Priority Zero:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_rcvd);\n\t\tfprintf(file, \"    Sent: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_sent);\n\t}\n\tfclose(file);\n}", "target": 1}
{"code": "static Jsi_RC WebSocketVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *verStr = NULL;\n    verStr = lws_get_library_version();\n    if (verStr) {\n        char buf[100], *cp;\n        snprintf(buf, sizeof(buf), \"%s\", verStr);\n        cp = Jsi_Strchr(buf, ' ');\n        if (cp) *cp = 0;\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "gboolean textview_uri_security_check(TextView *textview, ClickableText *uri)\n{\n\tgchar *visible_str;\n\tgboolean retval = TRUE;\n\tif (is_uri_string(uri->uri) == FALSE)\n\t\treturn TRUE;\n\tvisible_str = textview_get_visible_uri(textview, uri);\n\tif (visible_str == NULL)\n\t\treturn TRUE;\n\tg_strstrip(visible_str);\n\tif (strcmp(visible_str, uri->uri) != 0 && is_uri_string(visible_str)) {\n\t\tgchar *uri_path;\n\t\tgchar *visible_uri_path;\n\t\turi_path = get_uri_path(uri->uri);\n\t\tvisible_uri_path = get_uri_path(visible_str);\n\t\tif (path_cmp(uri_path, visible_uri_path) != 0)\n\t\t\tretval = FALSE;\n\t}\n\tif (retval == FALSE) {\n\t\tgchar *msg;\n\t\tAlertValue aval;\n\t\tmsg = g_markup_printf_escaped(\"%s\\n\\n\"\n\t\t\t\t\t\t\"<b>%s</b> %s\\n\\n\"\n\t\t\t\t\t\t\"<b>%s</b> %s\\n\\n\"\n\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t_(\"The real URL is different from the displayed URL.\"),\n\t\t\t\t\t\t_(\"Displayed URL:\"), visible_str,\n\t\t\t\t\t\t_(\"Real URL:\"), uri->uri,\n\t\t\t\t\t\t_(\"Open it anyway?\"));\n\t\taval = alertpanel_full(_(\"Phishing attempt warning\"), msg,\n\t\t\t\t       GTK_STOCK_CANCEL, _(\"_Open URL\"), NULL, ALERTFOCUS_FIRST,\n\t\t\t\t\t\t\t FALSE, NULL, ALERT_WARNING);\n\t\tg_free(msg);\n\t\tif (aval == G_ALERTALTERNATE)\n\t\t\tretval = TRUE;\n\t}\n\tg_free(visible_str);\n\treturn retval;\n}", "target": 1}
{"code": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n \tfor (tidno = 0, tid = &an->tid[tidno];\n \t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n\t\tif (!tid->sched)\n\t\t\tcontinue;\n \t\tac = tid->ac;\n \t\ttxq = ac->txq;\n \t\tath_txq_lock(sc, txq);\n \t\tbuffered = ath_tid_has_buffered(tid);\n \t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\t\tath_txq_unlock(sc, txq);\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}", "target": 1}
{"code": "int anetUnixServer(char *err, char *path, mode_t perm, int backlog)\n{\n    int s;\n    struct sockaddr_un sa;\n    if (strlen(path) > sizeof(sa.sun_path)-1) {\n        anetSetError(err,\"unix socket path too long (%zu), must be under %zu\", strlen(path), sizeof(sa.sun_path));\n        return ANET_ERR;\n    }\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n    memset(&sa,0,sizeof(sa));\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)\n        return ANET_ERR;\n    if (perm)\n        chmod(sa.sun_path, perm);\n    return s;\n}", "target": 1}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n   while(--alloc > 0) {\n     in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n       char hexstr[3];\n       char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 1}
{"code": "static int intel_vgpu_mmap(struct mdev_device *mdev, struct vm_area_struct *vma)\n{\n\tunsigned int index;\n\tu64 virtaddr;\n\tunsigned long req_size, pgoff = 0;\n\tpgprot_t pg_prot;\n\tstruct intel_vgpu *vgpu = mdev_get_drvdata(mdev);\n\tindex = vma->vm_pgoff >> (VFIO_PCI_OFFSET_SHIFT - PAGE_SHIFT);\n\tif (index >= VFIO_PCI_ROM_REGION_INDEX)\n\t\treturn -EINVAL;\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\tif (index != VFIO_PCI_BAR2_REGION_INDEX)\n\t\treturn -EINVAL;\n\tpg_prot = vma->vm_page_prot;\n\tvirtaddr = vma->vm_start;\n\treq_size = vma->vm_end - vma->vm_start;\n\tpgoff = vgpu_aperture_pa_base(vgpu) >> PAGE_SHIFT;\n\treturn remap_pfn_range(vma, virtaddr, pgoff, req_size, pg_prot);\n}", "target": 1}
{"code": "next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}", "target": 1}
{"code": "int main(int argc, char *argv[]) {\n  struct mschm_decompressor *chmd;\n  struct mschmd_header *chm;\n  struct mschmd_file *file, **f;\n  unsigned int numf, i;\n  setbuf(stdout, NULL);\n  setbuf(stderr, NULL);\n  user_umask = umask(0); umask(user_umask);\n  MSPACK_SYS_SELFTEST(i);\n  if (i) return 0;\n  if ((chmd = mspack_create_chm_decompressor(NULL))) {\n    for (argv++; *argv; argv++) {\n      printf(\"%s\\n\", *argv);\n      if ((chm = chmd->open(chmd, *argv))) {\n\tfor (numf=0, file=chm->files; file; file = file->next) numf++;\n\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));\n\t    }\n\t    free(outname);\n\t  }\n\t  free(f);\n\t}\n\tchmd->close(chmd, chm);\n      }\n      else {\n\tprintf(\"%s: can't open -- %s\\n\", *argv, ERROR(chmd));\n      }\n    }\n    mspack_destroy_chm_decompressor(chmd);\n  }\n  return 0;\n}", "target": 1}
{"code": "static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}", "target": 1}
{"code": " pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n {\n     uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n    if (ready_ptr != mgr->consumed_ptr) {\n         uint32_t next_ready_ptr =\n             mgr->consumed_ptr++ & mgr->txr_len_mask;\n         uint32_t next_ready_page =\n        return mgr->req_ring_pages_pa[next_ready_page] +\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n    } else {\n        return 0;\n    }\n}", "target": 1}
{"code": "struct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)\n{\n\tkref_get(&local->ref);\n\treturn local;\n}", "target": 1}
{"code": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *mac_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\tint type = skb_shinfo(skb)->gso_type;\n\t\tif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\tif ((skb_headroom(skb) < frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +\n\t\t     unfrag_ip6hlen;\n\tmac_start = skb_mac_header(skb);\n\tmemmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);\n\tskb->mac_header -= frag_hdr_sz;\n\tskb->network_header -= frag_hdr_sz;\n\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\tfptr->nexthdr = nexthdr;\n\tfptr->reserved = 0;\n\tipv6_select_ident(fptr);\n\tsegs = skb_segment(skb, features);\nout:\n\treturn segs;\n}", "target": 1}
{"code": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n {\n \tint ok = 0;\n \tunsigned char challenge[30];\n\tunsigned char signature[256];\n\tunsigned int siglen = sizeof signature;\n \tconst EVP_MD *md = EVP_sha1();\n \tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n \tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n \tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n \tok = 1;\n err:\n \tif (NULL != pubkey)\n \t\tEVP_PKEY_free(pubkey);\n \tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}", "target": 1}
{"code": " bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,\n                                              const GURL& referrer_url) {\n  if (IsDownloadFromMiniGallery(download_url) &&\n      StartsWithASCII(referrer_url.spec(),\n                      extension_urls::kMiniGalleryBrowsePrefix, false)) {\n    return true;\n  }\n  const Extension* download_extension = GetExtensionByWebExtent(download_url);\n  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);\n  const Extension* webstore_app = GetWebStoreApp();\n   bool referrer_valid = (referrer_extension == webstore_app);\n   bool download_valid = (download_extension == webstore_app);\n   GURL store_url =\n       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(\n           switches::kAppsGalleryURL));\n  if (!store_url.is_empty()) {\n    std::string store_tld =\n        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);\n    if (!referrer_valid) {\n      std::string referrer_tld =\n          net::RegistryControlledDomainService::GetDomainAndRegistry(\n              referrer_url);\n      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);\n    }\n    if (!download_valid) {\n      std::string download_tld =\n          net::RegistryControlledDomainService::GetDomainAndRegistry(\n              download_url);\n      download_valid = (download_tld == store_tld);\n    }\n  }\n  return (referrer_valid && download_valid);\n}", "target": 1}
{"code": "resolve_op_end (FlatpakTransaction *self,\n                FlatpakTransactionOperation *op,\n                const char *checksum,\n                GFile *sideload_path,\n                GBytes *metadata_bytes)\n{\n  g_autoptr(GBytes) old_metadata_bytes = NULL;\n  old_metadata_bytes = load_deployed_metadata (self, op->ref, NULL, NULL);\n  mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes);\n  emit_eol_and_maybe_skip (self, op);\n }", "target": 1}
{"code": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n \tif (!data)\n \t\treturn 1;\n \tif (report->id == REPORT_KEY_STATE) {\n \t\tif (data->input_keys)\n \t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}", "target": 1}
{"code": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}", "target": 1}
{"code": "static void vgacon_scrollback_init(int vc_num)\n{\n\tint pitch = vga_video_num_columns * 2;\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tint rows = size / pitch;\n\tvoid *data;\n\tdata = kmalloc_array(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024,\n\t\t\t     GFP_NOWAIT);\n\tvgacon_scrollbacks[vc_num].data = data;\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\tvgacon_scrollback_cur->rows = rows - 1;\n\tvgacon_scrollback_cur->size = rows * pitch;\n\tvgacon_scrollback_reset(vc_num, size);\n}", "target": 1}
{"code": "flatpak_run_apply_env_vars (FlatpakBwrap *bwrap, FlatpakContext *context)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  g_hash_table_iter_init (&iter, context->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *var = key;\n      const char *val = value;\n      if (val && val[0] != 0)\n        flatpak_bwrap_set_env (bwrap, var, val, TRUE);\n      else\n        flatpak_bwrap_unset_env (bwrap, var);\n    }\n}", "target": 1}
{"code": "static void save_client_addr(struct ip_addr *client_ip, uint8_t *hwaddr)\n{\n\tuint8_t d = (uint8_t)ip4_addr4(client_ip);\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tmemcpy(ip_table.client_mac[d], hwaddr, 6); \n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\", __func__,\n\t\tip4_addr1(client_ip), ip4_addr2(client_ip), ip4_addr3(client_ip), ip4_addr4(client_ip),\n\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#endif\t\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n}", "target": 1}
{"code": "Status RangeSize(const Tensor* start_t, const Tensor* limit_t,\n                 const Tensor* delta_t, InferenceContext* const c) {\n  T start = start_t->scalar<T>()();\n  T limit = limit_t->scalar<T>()();\n  T delta = delta_t->scalar<T>()();\n  if (start > limit && delta > T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start <= limit when delta > 0: \", start, \"/\", limit);\n  }\n  if (start < limit && delta < T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start >= limit when delta < 0: \", start, \"/\", limit);\n  }\n  if (delta == T(0)) {\n    return errors::InvalidArgument(\"Requires delta != 0\");\n  }\n  auto size = (std::is_integral<T>::value\n                   ? ((Eigen::numext::abs(limit - start) +\n                       Eigen::numext::abs(delta) - T(1)) /\n                      Eigen::numext::abs(delta))\n                   : (Eigen::numext::ceil(\n                         Eigen::numext::abs((limit - start) / delta))));\n  if (size > std::numeric_limits<int64_t>::max()) {\n    return errors::InvalidArgument(\"Requires ((limit - start) / delta) <= \",\n                                   std::numeric_limits<int64_t>::max());\n  }\n  c->set_output(0, c->Vector(static_cast<int64_t>(size)));\n  return Status::OK();\n}", "target": 1}
{"code": "static int ldb_lock_backend_callback(struct ldb_request *req,\n\t\t\t\t     struct ldb_reply *ares)\n{\n\tstruct ldb_db_lock_context *lock_context;\n\tint ret;\n\tlock_context = talloc_get_type(req->context,\n\t\t\t\t       struct ldb_db_lock_context);\n\tif (!ares) {\n\t\treturn ldb_module_done(lock_context->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\tif (ares->error != LDB_SUCCESS || ares->type == LDB_REPLY_DONE) {\n\t\tret = ldb_module_done(lock_context->req, ares->controls,\n\t\t\t\t      ares->response, ares->error);\n\t\ttalloc_free(lock_context);\n\t\treturn ret;\n\t}\n\tswitch (ares->type) {\n\tcase LDB_REPLY_ENTRY:\n\t\treturn ldb_module_send_entry(lock_context->req, ares->message,\n\t\t\t\t\t     ares->controls);\n\tcase LDB_REPLY_REFERRAL:\n\t\treturn ldb_module_send_referral(lock_context->req,\n\t\t\t\t\t\tares->referral);\n\tdefault:\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n}", "target": 1}
{"code": "mark_trusted_task_thread_func (GTask        *task,\n                               gpointer      source_object,\n                               gpointer      task_data,\n                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n    common = (CommonJob *) job;\n    nautilus_progress_info_start (job->common.progress);\n    mark_desktop_file_trusted (common,\n                               cancellable,\n                               job->file,\n                               job->interactive);\n}", "target": 1}
{"code": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,\n\t\t\t\t       u64 devid, u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\twhile (fs_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(fs_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) {\n\t\t\tdevice = find_device(fs_devices, devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tfs_devices = fs_devices->seed;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "int PackTmt::readFileHeader() {\n#define H(x) get_le16(h + 2 * (x))\n#define H4(x) get_le32(h + (x))\n    unsigned char h[0x40];\n    int ic;\n    unsigned exe_offset = 0;\n    adam_offset = 0;\n    for (ic = 0; ic < 20; ic++) {\n        fi->seek(adam_offset, SEEK_SET);\n        fi->readx(h, sizeof(h));\n        if (memcmp(h, \"MZ\", 2) == 0) \n        {\n            exe_offset = adam_offset;\n            adam_offset += H(2) * 512 + H(1);\n            if (H(1))\n                adam_offset -= 512;\n            if (H(0x18 / 2) == 0x40 && H4(0x3c))\n                adam_offset = H4(0x3c);\n        } else if (memcmp(h, \"BW\", 2) == 0)\n            adam_offset += H(2) * 512 + H(1);\n        else if (memcmp(h, \"PMW1\", 4) == 0) {\n            fi->seek(adam_offset + H4(0x18), SEEK_SET);\n            adam_offset += H4(0x24);\n            int objs = H4(0x1c);\n            while (objs--) {\n                fi->readx(h, 0x18);\n                adam_offset += H4(4);\n            }\n        } else if (memcmp(h, \"LE\", 2) == 0) {\n            unsigned offs = exe_offset + (H4(0x14) - 1) * H4(0x28) + H4(0x2c);\n            fi->seek(adam_offset + 0x80, SEEK_SET);\n            fi->readx(h, 4);\n            adam_offset = offs + H4(0);\n        } else if (memcmp(h, \"Adam\", 4) == 0)\n            break;\n        else\n            return 0;\n    }\n    if (ic == 20)\n        return 0;\n    fi->seek(adam_offset, SEEK_SET);\n    fi->readx(&ih, sizeof(ih));\n    unsigned const imagesize = ih.imagesize;\n    unsigned const entry = ih.entry;\n    unsigned const relocsize = ih.relocsize;\n    if (!imagesize || file_size <= imagesize || file_size <= entry || file_size <= relocsize) {\n        printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,\n                  entry, relocsize);\n        return 0;\n    }\n    return UPX_F_TMT_ADAM;\n#undef H4\n#undef H\n}", "target": 1}
{"code": "void ipc_rcu_putref(void *ptr)\n{\n\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n\t\treturn;\n\tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}", "target": 1}
{"code": "mptctl_eventreport (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventreport\t karg;\n\tMPT_ADAPTER\t\t *ioc;\n\tint\t\t\t iocnum;\n\tint\t\t\t numBytes, maxEvents, max;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventreport() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventreport called.\\n\",\n\t    ioc->name));\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);\n\tmax = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents;\n\tif ((max < 1) || !ioc->events)\n\t\treturn -ENODATA;\n\tioc->aen_event_read_flag=0;\n\tnumBytes = max * sizeof(MPT_IOCTL_EVENTS);\n\tif (copy_to_user(uarg->eventData, ioc->events, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, ioc->events);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "    void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Reading TIFF file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"TIFF\");\n        }\n        clearMetadata();\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n        Exiv2::ExifKey            key(\"Exif.Image.InterColorProfile\");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n    } ", "target": 1}
{"code": "load_kernel_module_list (void)\n{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n  if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read /proc/modules: %s\", error->message);\n      return modules;\n    }\n  start = modules_data;\n  while (TRUE)\n    {\n      end = strchr (start, ' ');\n      if (end == NULL)\n        break;\n      g_hash_table_add (modules, g_strndup (start, (end - start)));\n      start = strchr (end, '\\n');\n      if (start == NULL)\n        break;\n      start++;\n    }\n  return modules;\n}", "target": 1}
{"code": "valid_length(uint8_t option, int dl, int *type)\n{\n const struct dhcp_opt *opt;\n ssize_t sz;\n if (dl == 0)\n return -1;\n for (opt = dhcp_opts; opt->option; opt++) {\n if (opt->option != option)\n continue;\n \t\tif (type)\n \t\t\t*type = opt->type;\n \t\tif (opt->type == 0 ||\n \t\t    opt->type & (STRING | RFC3442 | RFC5969))\n \t\t\treturn 0;\n \t\tsz = 0;\n\t\tif (opt->type & (UINT32 | IPV4))\n \t\t\tsz = sizeof(uint32_t);\n\t\tif (opt->type & UINT16)\n \t\t\tsz = sizeof(uint16_t);\n\t\tif (opt->type & UINT8)\n \t\t\tsz = sizeof(uint8_t);\n\t\tif (opt->type & (IPV4 | ARRAY))\n\t\t\treturn dl % sz;\n\t\treturn (dl == sz ? 0 : -1);\n \t}\n return 0;\n}", "target": 1}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n \t\t\tif (s_den == 0) {\n \t\t\t\treturn 0;\n \t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n \t\t\t}\n \t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": " static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n {\n \tint start = 0;\n \tu32 prev_legacy, cur_legacy;\n \tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n \tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n \tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n \t       sizeof(kvm->arch.vpit->pit_state.channels));\n \tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n \tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n \treturn 0;\n }", "target": 1}
{"code": "Chunk::Chunk( ContainerChunk* parent, RIFF_MetaHandler* handler, bool skip, ChunkType c )\n{\n\tchunkType = c; \n\tthis->parent = parent;\n\tthis->oldSize = 0;\n\tthis->hasChange = false; \n\tXMP_IO* file = handler->parent->ioRef;\n \tthis->oldPos = file->Offset();\n \tthis->id = XIO::ReadUns32_LE( file );\n\tthis->oldSize = XIO::ReadUns32_LE( file ) + 8;\n \tXMP_Int64 chunkEnd = this->oldPos + this->oldSize;\n\tif ( parent != 0 ) chunkLimit = parent->oldPos + parent->oldSize;\n\tif ( chunkEnd > chunkLimit ) {\n\t\tbool isUpdate = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenForUpdate );\n\t\tbool repairFile = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenRepairFile );\n\t\tif ( (! isUpdate) || (repairFile && (parent == 0)) ) {\n\t\t\tthis->oldSize = chunkLimit - this->oldPos;\n\t\t} else {\n\t\t\tXMP_Throw ( \"Bad RIFF chunk size\", kXMPErr_BadFileFormat );\n\t\t}\n\t}\n\tthis->newSize = this->oldSize;\n\tthis->needSizeFix = false;\n\tif ( skip ) file->Seek ( (this->oldSize - 8), kXMP_SeekFromCurrent );\n\tif ( this->parent != NULL )\n\t{\n\t\tthis->parent->children.push_back( this );\n\t\tif( this->chunkType == chunk_VALUE )\n\t\t\tthis->parent->childmap.insert( std::make_pair( this->id, (ValueChunk*) this ) );\n\t}\n}", "target": 1}
{"code": "static void ext4_clamp_want_extra_isize(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    sbi->s_want_extra_isize == 0) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO,\n\t\t\t \"required extra inode space not available\");\n\t}\n}", "target": 1}
{"code": "void Part::slotOpenExtractedEntry(KJob *job)\n{\n    if (!job->error()) {\n        OpenJob *openJob = qobject_cast<OpenJob*>(job);\n        Q_ASSERT(openJob);\n        m_tmpExtractDirList << openJob->tempDir();\n        const QString fullName = openJob->validatedFilePath();\n        bool isWritable = m_model->archive() && !m_model->archive()->isReadOnly();\n        if (!isWritable) {\n            QFile::setPermissions(fullName, QFileDevice::ReadOwner | QFileDevice::ReadGroup | QFileDevice::ReadOther);\n        }\n        if (isWritable) {\n            m_fileWatcher = new QFileSystemWatcher;\n            connect(m_fileWatcher, &QFileSystemWatcher::fileChanged, this, &Part::slotWatchedFileModified);\n            m_fileWatcher->addPath(fullName);\n        }\n        if (qobject_cast<OpenWithJob*>(job)) {\n            const QList<QUrl> urls = {QUrl::fromUserInput(fullName, QString(), QUrl::AssumeLocalFile)};\n            KRun::displayOpenWithDialog(urls, widget());\n         } else {\n             KRun::runUrl(QUrl::fromUserInput(fullName, QString(), QUrl::AssumeLocalFile),\n                          QMimeDatabase().mimeTypeForFile(fullName).name(),\n                         widget());\n         }\n     } else if (job->error() != KJob::KilledJobError) {\n         KMessageBox::error(widget(), job->errorString());\n    }\n    setReadyGui();\n}", "target": 1}
{"code": "bool ChromeDownloadManagerDelegate::IsDangerousFile(\n    const DownloadItem& download,\n    const FilePath& suggested_path,\n     bool visited_referrer_before) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)\n    return false;\n  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&\n      download_crx_util::IsExtensionDownload(download) &&\n      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {\n    return true;\n  }\n  if (ShouldOpenFileBasedOnExtension(suggested_path) &&\n      download.HasUserGesture())\n    return false;\n   download_util::DownloadDangerLevel danger_level =\n       download_util::GetFileDangerLevel(suggested_path.BaseName());\n  if (danger_level == download_util::AllowOnUserGesture)\n     return !download.HasUserGesture() || !visited_referrer_before;\n   return danger_level == download_util::Dangerous;\n }", "target": 1}
{"code": "inline std::unique_ptr<Response> ClientImpl::send_with_content_provider(\n    Request &req, const char *body, size_t content_length,\n    ContentProvider content_provider,\n    ContentProviderWithoutLength content_provider_without_length,\n    const std::string &content_type, Error &error) {\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_) { req.headers.emplace(\"Content-Encoding\", \"gzip\"); }\n#endif\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_ && !content_provider_without_length) {\n    detail::gzip_compressor compressor;\n    if (content_provider) {\n      auto ok = true;\n      size_t offset = 0;\n      DataSink data_sink;\n      data_sink.write = [&](const char *data, size_t data_len) -> bool {\n        if (ok) {\n          auto last = offset + data_len == content_length;\n          auto ret = compressor.compress(\n              data, data_len, last,\n              [&](const char *compressed_data, size_t compressed_data_len) {\n                req.body.append(compressed_data, compressed_data_len);\n                return true;\n              });\n          if (ret) {\n            offset += data_len;\n          } else {\n            ok = false;\n          }\n        }\n        return ok;\n      };\n      while (ok && offset < content_length) {\n        if (!content_provider(offset, content_length - offset, data_sink)) {\n          error = Error::Canceled;\n          return nullptr;\n        }\n      }\n    } else {\n      if (!compressor.compress(body, content_length, true,\n                               [&](const char *data, size_t data_len) {\n                                 req.body.append(data, data_len);\n                                 return true;\n                               })) {\n        error = Error::Compression;\n        return nullptr;\n      }\n    }\n  } else\n#endif\n  {\n    if (content_provider) {\n      req.content_length_ = content_length;\n      req.content_provider_ = std::move(content_provider);\n      req.is_chunked_content_provider_ = false;\n    } else if (content_provider_without_length) {\n      req.content_length_ = 0;\n      req.content_provider_ = detail::ContentProviderAdapter(\n          std::move(content_provider_without_length));\n      req.is_chunked_content_provider_ = true;\n      req.headers.emplace(\"Transfer-Encoding\", \"chunked\");\n    } else {\n      req.body.assign(body, content_length);\n      ;\n    }\n  }\n  auto res = detail::make_unique<Response>();\n  return send(req, *res, error) ? std::move(res) : nullptr;\n}", "target": 1}
{"code": "static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\n\t\t\t\t  int offset, size_t count)\n{\n\tint len = iov_length(from, count) - offset;\n\tint copy = skb_headlen(skb);\n\tint size, offset1 = 0;\n\tint i = 0;\n\twhile (count && (offset >= from->iov_len)) {\n\t\toffset -= from->iov_len;\n\t\t++from;\n\t\t--count;\n\t}\n\twhile (count && (copy > 0)) {\n\t\tsize = min_t(unsigned int, copy, from->iov_len - offset);\n\t\tif (copy_from_user(skb->data + offset1, from->iov_base + offset,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (copy > size) {\n\t\t\t++from;\n\t\t\t--count;\n\t\t\toffset = 0;\n\t\t} else\n\t\t\toffset += size;\n\t\tcopy -= size;\n\t\toffset1 += size;\n\t}\n\tif (len == offset1)\n\t\treturn 0;\n\twhile (count--) {\n\t\tstruct page *page[MAX_SKB_FRAGS];\n\t\tint num_pages;\n\t\tunsigned long base;\n\t\tunsigned long truesize;\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif ((num_pages != size) ||\n\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {\n\t\t\tint off = base & ~PAGE_MASK;\n\t\t\tint size = min_t(int, len, PAGE_SIZE - off);\n\t\t\t__skb_fill_page_desc(skb, i, page[i], off, size);\n\t\t\tskb_shinfo(skb)->nr_frags++;\n\t\t\tbase += size;\n\t\t\tlen -= size;\n\t\t\ti++;\n\t\t}\n\t\toffset = 0;\n\t\t++from;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static SDL_Surface* Create_Surface_Solid(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf;\n    Sint64 size;\n    void *pixels, *ptr;\n    Sint64 pitch = width + alignment;\n    pitch += alignment;\n    pitch &= ~alignment;\n    size = height * pitch + sizeof (void *) + alignment;\n    if (size < 0 || size > SDL_MAX_SINT32) {\n        return NULL;\n    }\n    ptr = SDL_malloc((size_t)size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n    pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n    ((void **)pixels)[-1] = ptr;\n    textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);\n    if (textbuf == NULL) {\n        SDL_free(ptr);\n        return NULL;\n    }\n    textbuf->flags &= ~SDL_PREALLOC;\n    textbuf->flags |= SDL_SIMD_ALIGNED;\n    SDL_memset(pixels, 0, height * pitch);\n    *color = 1;\n    {\n        SDL_Palette *palette = textbuf->format->palette;\n        palette->colors[0].r = 255 - fg.r;\n        palette->colors[0].g = 255 - fg.g;\n        palette->colors[0].b = 255 - fg.b;\n        palette->colors[1].r = fg.r;\n        palette->colors[1].g = fg.g;\n        palette->colors[1].b = fg.b;\n        palette->colors[1].a = fg.a;\n    }\n    SDL_SetColorKey(textbuf, SDL_TRUE, 0);\n    return textbuf;", "target": 1}
{"code": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n{\n\tint ok = 0;\n\tunsigned char challenge[30];\n\tunsigned char signature[256];\n\tunsigned int siglen = sizeof signature;\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n\tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tok = 1;\nerr:\n\tif (NULL != pubkey)\n\t\tEVP_PKEY_free(pubkey);\n\tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}", "target": 1}
{"code": "        unsigned int GetU32LE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos + 3];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 0];\n            return nRes;\n        }", "target": 1}
{"code": "PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; \n\t}\n\tif (oldlen > new_size) {\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\tinverse_map = unescape_inverse_map(all, flags);\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\nempty_source:\t\n\t*newlen = retlen;\n\treturn ret;\n}", "target": 1}
{"code": "char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {\n\tchar *cookieValue = NULL;\n\tchar *chunkValue = NULL;\n\tint i = 0;\n\tif (chunkSize == 0) {\n\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t} else {\n\t\tint chunkCount = oidc_util_get_chunked_count(r, cookieName);\n\t\tif (chunkCount > 0) {\n\t\t\tcookieValue = \"\";\n\t\t\tfor (i = 0; i < chunkCount; i++) {\n\t\t\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));\n\t\t\t\tif (chunkValue != NULL)\n\t\t\t\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue, chunkValue);\n\t\t\t}\n\t\t} else {\n\t\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t\t}\n\t}\n\treturn cookieValue;\n}", "target": 1}
{"code": "ngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n    dd(\"before: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n    for (i = 0; ; i++) {\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n    dd(\"after: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n    return NGX_OK;\n}", "target": 1}
{"code": "static void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen)\n{\n  struct host_query *hquery = (struct host_query*)arg;\n  int addinfostatus = ARES_SUCCESS;\n  hquery->timeouts += timeouts;\n  hquery->remaining--;\n  if (status == ARES_SUCCESS)\n    {\n      addinfostatus = ares__parse_into_addrinfo(abuf, alen, hquery->ai);\n    }\n  else if (status == ARES_EDESTRUCTION)\n    {\n      end_hquery(hquery, status);\n    }\n  if (!hquery->remaining)\n    {\n      if (addinfostatus != ARES_SUCCESS)\n        {\n          end_hquery(hquery, addinfostatus);\n        }\n      else if (hquery->ai->nodes)\n        {\n          end_hquery(hquery, ARES_SUCCESS);\n        }\n      else if (status == ARES_ENOTFOUND)\n        {\n          next_lookup(hquery, status);\n        }\n      else\n        {\n          end_hquery(hquery, status);\n        }\n    }\n}", "target": 1}
{"code": "Bool rfbOptPamAuth(void)\n{\n  SecTypeData *s;\n  for (s = secTypes; s->name != NULL; s++) {\n    if ((!strcmp(s->name, \"unixlogin\") ||\n         !strcmp(&s->name[strlen(s->name) - 5], \"plain\")) && s->enabled)\n      return TRUE;\n  }\n  return FALSE;\n}", "target": 1}
{"code": "exit_ext2_xattr(void)\n{\n}", "target": 1}
{"code": "static bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; \n\tbool result = true;\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; \n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tgoto done;\nunref:\n\tgluster_cache_refresh(fs, path);\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\treturn result;\n}", "target": 1}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(\n        OMX_BUFFERHEADERTYPE **header,\n        OMX_U32 portIndex,\n        OMX_PTR appPrivate,\n        OMX_U32 size,\n        OMX_U8 *ptr) {\n     Mutex::Autolock autoLock(mLock);\n     CHECK_LT(portIndex, mPorts.size());\n     *header = new OMX_BUFFERHEADERTYPE;\n     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);\n     (*header)->nVersion.s.nVersionMajor = 1;\n (*header)->nVersion.s.nVersionMinor = 0;\n (*header)->nVersion.s.nRevision = 0;\n (*header)->nVersion.s.nStep = 0;\n (*header)->pBuffer = ptr;\n (*header)->nAllocLen = size;\n (*header)->nFilledLen = 0;\n (*header)->nOffset = 0;\n (*header)->pAppPrivate = appPrivate;\n (*header)->pPlatformPrivate = NULL;\n (*header)->pInputPortPrivate = NULL;\n (*header)->pOutputPortPrivate = NULL;\n (*header)->hMarkTargetComponent = NULL;\n (*header)->pMarkData = NULL;\n (*header)->nTickCount = 0;\n (*header)->nTimeStamp = 0;\n (*header)->nFlags = 0;\n     (*header)->nOutputPortIndex = portIndex;\n     (*header)->nInputPortIndex = portIndex;\n    PortInfo *port = &mPorts.editItemAt(portIndex);\n     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);\n     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);\n    port->mBuffers.push();\n BufferInfo *buffer =\n &port->mBuffers.editItemAt(port->mBuffers.size() - 1);\n    buffer->mHeader = *header;\n    buffer->mOwnedByUs = false;\n if (port->mBuffers.size() == port->mDef.nBufferCountActual) {\n        port->mDef.bPopulated = OMX_TRUE;\n        checkTransitions();\n }\n return OMX_ErrorNone;\n}", "target": 1}
{"code": "static bool checkCurl() {\n\tconst char nul[] = R_SYS_DEVNULL;\n\tif (r_sys_cmdf (\"curl --version > %s\", nul) != 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "create_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\tcheck_spnego_options(spnego_ctx);\n\treturn (spnego_ctx);\n}", "target": 1}
{"code": "int qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_snmp_ureq *ureq;\n\tint req_len;\n\tstruct qeth_arp_query_info qinfo = {0, };\n\tint rc = 0;\n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n\t\treturn -EFAULT;\n\tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n\tif (IS_ERR(ureq)) {\n\t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}", "target": 1}
{"code": "static int putreg(struct task_struct *child,\n\tunsigned long regno, unsigned long value)\n{\n\tunsigned long tmp; \n\tif (test_tsk_thread_flag(child, TIF_IA32))\n\t\tvalue &= 0xffffffff;\n\tswitch (regno) {\n\t\tcase offsetof(struct user_regs_struct,fs):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.fsindex = value & 0xffff; \n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,gs):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.gsindex = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,ds):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.ds = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,es): \n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.es = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,ss):\n\t\t\tif ((value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tvalue &= 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,fs_base):\n\t\t\tif (value >= TASK_SIZE_OF(child))\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.fs = value;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,gs_base):\n\t\t\tif (value >= TASK_SIZE_OF(child))\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.gs = value;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct, eflags):\n\t\t\tvalue &= FLAG_MASK;\n\t\t\ttmp = get_stack_long(child, EFL_OFFSET); \n\t\t\ttmp &= ~FLAG_MASK; \n\t\t\tvalue |= tmp;\n\t\t\tbreak;\n\t\tcase offsetof(struct user_regs_struct,cs): \n\t\t\tif ((value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tvalue &= 0xffff;\n\t\t\tbreak;\n\t}\n\tput_stack_long(child, regno - sizeof(struct pt_regs), value);\n\treturn 0;\n}", "target": 1}
{"code": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}", "target": 1}
{"code": "bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n  DCHECK(!options.executable);\n  DCHECK(!mapped_file_);\n  if (options.size == 0)\n    return false;\n   uint32 rounded_size = (options.size + 0xffff) & ~0xffff;\n   name_ = ASCIIToWide(options.name == NULL ? \"\" : *options.name);\n   mapped_file_ = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,\n       PAGE_READWRITE, 0, static_cast<DWORD>(rounded_size),\n      name_.empty() ? NULL : name_.c_str());\n  if (!mapped_file_)\n    return false;\n  created_size_ = options.size;\n  if (GetLastError() == ERROR_ALREADY_EXISTS) {\n    created_size_ = 0;\n    if (!options.open_existing) {\n      Close();\n      return false;\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "void ChromeContentRendererClient::RenderThreadStarted() {\n  chrome_observer_.reset(new ChromeRenderProcessObserver());\n  extension_dispatcher_.reset(new ExtensionDispatcher());\n  histogram_snapshots_.reset(new RendererHistogramSnapshots());\n  net_predictor_.reset(new RendererNetPredictor());\n  spellcheck_.reset(new SpellCheck());\n  visited_link_slave_.reset(new VisitedLinkSlave());\n  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());\n  RenderThread* thread = RenderThread::current();\n  thread->AddFilter(new DevToolsAgentFilter());\n  thread->AddObserver(chrome_observer_.get());\n  thread->AddObserver(extension_dispatcher_.get());\n  thread->AddObserver(histogram_snapshots_.get());\n  thread->AddObserver(phishing_classifier_.get());\n  thread->AddObserver(spellcheck_.get());\n  thread->AddObserver(visited_link_slave_.get());\n  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());\n  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());\n  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());\n  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();\n  if (search_extension)\n    thread->RegisterExtension(search_extension);\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDomAutomationController)) {\n    thread->RegisterExtension(DomAutomationV8Extension::Get());\n  }\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n           switches::kEnableIPCFuzzing)) {\n     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());\n   }\n   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));\n   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);\n   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));\n   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);\n}", "target": 1}
{"code": "static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n{\n\tconst char* loc_name        \t= NULL;\n\tint         loc_name_len    \t= 0;\n\tchar*       tag_value\t\t= NULL;\n\tchar*       empty_result\t= \"\";\n\tint         result    \t\t= 0;\n\tchar*       msg        \t\t= NULL;\n\tUErrorCode  status          \t= U_ZERO_ERROR;\n\tintl_error_reset( NULL TSRMLS_CC );\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n\t&loc_name ,&loc_name_len ) == FAILURE) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to parse input params\", tag_name );\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_FALSE;\n    }\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\ttag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);\n\tif( result == -1 ) {\n\t\tif( tag_value){\n\t\t\tefree( tag_value);\n\t\t}\n\t\tRETURN_STRING( empty_result , TRUE);\n\t}\n\tif( tag_value){\n\t\tRETURN_STRING( tag_value , FALSE);\n\t}\n\tif( result ==0) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to get locale %s\", tag_name , tag_name );\n\t\tintl_error_set( NULL, status, msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_NULL();\n\t}\n}", "target": 1}
{"code": "ext4_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}", "target": 1}
{"code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}", "target": 1}
{"code": "static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,\n  Image *image)\n{\n  char\n    *base64,\n    message[MaxTextExtent];\n  const MagickInfo\n    *magick_info;\n  ExceptionInfo\n    *exception;\n  Image\n    *write_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  size_t\n    blob_length,\n    encode_length;\n  unsigned char\n    *blob;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  exception=(&image->exception);\n  write_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(write_info,1,exception);\n  if (LocaleCompare(write_info->magick,\"INLINE\") == 0)\n    (void) CopyMagickString(write_info->magick,image->magick,MaxTextExtent);\n   magick_info=GetMagickInfo(write_info->magick,exception);\n   if ((magick_info == (const MagickInfo *) NULL) ||\n       (GetMagickMimeType(magick_info) == (const char *) NULL))\n    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n   (void) CopyMagickString(image->filename,write_info->filename,MaxTextExtent);\n   blob_length=2048;\n   write_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (write_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      return(MagickTrue);\n    }\n  blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,\n    exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (blob == (unsigned char *) NULL)\n    return(MagickFalse);\n  encode_length=0;\n  base64=Base64Encode(blob,blob_length,&encode_length);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  if (base64 == (char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      base64=DestroyString(base64);\n      return(status);\n    }\n  (void) FormatLocaleString(message,MaxTextExtent,\"data:%s;base64,\",\n    GetMagickMimeType(magick_info));\n  (void) WriteBlobString(image,message);\n  (void) WriteBlobString(image,base64);\n  base64=DestroyString(base64);\n  return(MagickTrue);\n}", "target": 1}
{"code": "zrestore(i_ctx_t *i_ctx_p)\n {\n     os_ptr op = osp;\n    alloc_save_t *asave;\n    bool last;\n    vm_save_t *vmsave;\n    int code = restore_check_operand(op, &asave, idmemory);\n     if (code < 0)\n         return code;\n     if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n               (ulong) alloc_save_client_data(asave),\n                (ulong) op->value.saveid);\n     if (I_VALIDATE_BEFORE_RESTORE)\n         ivalidate_clean_spaces(i_ctx_p);\n        ivalidate_clean_spaces(i_ctx_p);\n     {\n         int code;\n        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0\n             ) {\n             osp++;\n             return code;\n         }\n     }\n     restore_fix_stack(i_ctx_p, &o_stack, asave, false);\n    }", "target": 1}
{"code": "static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tgoto error;\n\t}\n\treturn cmpt;\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > A - skb->len)\n \t\treturn 0;\n \tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\treturn 0;\n}", "target": 1}
{"code": "gs_heap_alloc_bytes(gs_memory_t * mem, uint size, client_name_t cname)\n{\n    gs_malloc_memory_t *mmem = (gs_malloc_memory_t *) mem;\n    byte *ptr = 0;\n#ifdef DEBUG\n    const char *msg;\n    static const char *const ok_msg = \"OK\";\n#  define set_msg(str) (msg = (str))\n#else\n#  define set_msg(str) DO_NOTHING\n#endif\n    if (mmem->monitor)\n        gx_monitor_enter(mmem->monitor);\n    if (size > mmem->limit - sizeof(gs_malloc_block_t)) {\n        set_msg(\"exceeded limit\");\n     } else {\n         uint added = size + sizeof(gs_malloc_block_t);\n        if (mmem->limit - added < mmem->used)\n             set_msg(\"exceeded limit\");\n         else if ((ptr = (byte *) Memento_label(malloc(added), cname)) == 0)\n             set_msg(\"failed\");\n        else {\n            gs_malloc_block_t *bp = (gs_malloc_block_t *) ptr;\n            set_msg(ok_msg);\n            if (mmem->allocated)\n                mmem->allocated->prev = bp;\n            bp->next = mmem->allocated;\n            bp->prev = 0;\n            bp->size = size;\n            bp->type = &st_bytes;\n            bp->cname = cname;\n            mmem->allocated = bp;\n            ptr = (byte *) (bp + 1);\n            mmem->used += size + sizeof(gs_malloc_block_t);\n            if (mmem->used > mmem->max_used)\n                mmem->max_used = mmem->used;\n        }\n    }\n    if (mmem->monitor)\n        gx_monitor_leave(mmem->monitor);\t\n    if (ptr)\n        gs_alloc_fill(ptr, gs_alloc_fill_alloc, size);\n#ifdef DEBUG\n    if (gs_debug_c('a') || msg != ok_msg)\n        dmlprintf6(mem, \"[a+]gs_malloc(%s)(%u) = 0x%lx: %s, used=%ld, max=%ld\\n\",\n                   client_name_string(cname), size, (ulong) ptr, msg, mmem->used, mmem->max_used);\n#endif\n    return ptr;\n#undef set_msg\n}", "target": 1}
{"code": "xfs_attr_shortform_verify(\n\tstruct xfs_inode\t\t*ip)\n{\n\tstruct xfs_attr_shortform\t*sfp;\n\tstruct xfs_attr_sf_entry\t*sfep;\n\tstruct xfs_attr_sf_entry\t*next_sfep;\n\tchar\t\t\t\t*endp;\n\tstruct xfs_ifork\t\t*ifp;\n\tint\t\t\t\ti;\n\tint64_t\t\t\t\tsize;\n\tASSERT(ip->i_afp->if_format == XFS_DINODE_FMT_LOCAL);\n\tifp = XFS_IFORK_PTR(ip, XFS_ATTR_FORK);\n\tsfp = (struct xfs_attr_shortform *)ifp->if_u1.if_data;\n\tsize = ifp->if_bytes;\n\tif (size < sizeof(struct xfs_attr_sf_hdr))\n\t\treturn __this_address;\n\tendp = (char *)sfp + size;\n\tsfep = &sfp->list[0];\n\tfor (i = 0; i < sfp->hdr.count; i++) {\n\t\tif (((char *)sfep + sizeof(*sfep)) >= endp)\n\t\t\treturn __this_address;\n\t\tif (sfep->namelen == 0)\n\t\t\treturn __this_address;\n\t\tnext_sfep = XFS_ATTR_SF_NEXTENTRY(sfep);\n\t\tif ((char *)next_sfep > endp)\n\t\t\treturn __this_address;\n\t\tif (sfep->flags & ~XFS_ATTR_NSP_ONDISK_MASK)\n\t\t\treturn __this_address;\n\t\tif (hweight8(sfep->flags & XFS_ATTR_NSP_ONDISK_MASK) > 1)\n\t\t\treturn __this_address;\n\t\tsfep = next_sfep;\n\t}\n\tif ((void *)sfep != (void *)endp)\n\t\treturn __this_address;\n\treturn NULL;\n}", "target": 1}
{"code": "inline void* Zone::New(int size) {\n  ASSERT(scope_nesting_ > 0);\n  size = RoundUp(size, kAlignment);\n  if (kPointerSize == 4 && kAlignment == 4) {\n    position_ += ((~size) & 4) & (reinterpret_cast<intptr_t>(position_) & 4);\n  } else {\n    ASSERT(kAlignment >= kPointerSize);\n  }\n  Address result = position_;\n  if (size > limit_ - position_) {\n     result = NewExpand(size);\n  } else {\n     position_ += size;\n  }\n  ASSERT(IsAddressAligned(result, kAlignment, 0));\n  allocation_size_ += size;\n  return reinterpret_cast<void*>(result);\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictAvgPoolGrad(const OpContext& op_context,\n                                                NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  bool shape_found = false;\n  TensorShapeProto x_shape;\n  if (op_info.inputs_size() >= 1 && op_info.inputs(0).has_value()) {\n    const TensorProto& value = op_info.inputs(0).value();\n    shape_found = GetTensorShapeProtoFromTensorProto(value, &x_shape);\n  }\n  if (!shape_found && op_info.outputs_size() > 0) {\n    x_shape = op_info.outputs(0).shape();\n    shape_found = true;\n  }\n  if (!shape_found) {\n    x_shape.Clear();\n    for (int i = 0; i < 4; ++i) {\n      x_shape.add_dim()->set_size(1);\n    }\n    found_unknown_shapes = true;\n  }\n  ConvolutionDimensions dims =\n      OpDimensionsFromInputs(x_shape, op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    ops = dims.batch * dims.iz * (dims.ix * dims.iy + dims.ox * dims.oy);\n  } else {\n    ops = dims.batch * dims.iz *\n          (dims.ix * dims.iy + dims.ox * dims.oy * (dims.kx * dims.ky + 1));\n  }\n  auto s = PredictDefaultNodeCosts(ops, op_context, &found_unknown_shapes,\n                                   node_costs);\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  return s;\n}", "target": 1}
{"code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n \t\t\tioc->aic->exit(ioc->aic);\n \t\tcfq_exit(ioc);\n\t\tput_io_context(ioc);\n \t}\n }", "target": 1}
{"code": "static INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tStream_Write_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Write_UINT8(s, brush->data[7]);\n\t\tStream_Write_UINT8(s, brush->data[6]);\n\t\tStream_Write_UINT8(s, brush->data[5]);\n\t\tStream_Write_UINT8(s, brush->data[4]);\n\t\tStream_Write_UINT8(s, brush->data[3]);\n\t\tStream_Write_UINT8(s, brush->data[2]);\n\t\tStream_Write_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\treturn &new_mnt->mnt;\n}", "target": 1}
{"code": "snmp_mib_find(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(!snmp_oid_cmp_oid(oid, resource->oid)) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\t\t\tASSERT(redir_index < IOAPIC_NUM_PINS);\n\t\t\tredir_content = ioapic->redirtbl[redir_index].bits;\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n #else\n \tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n \treturn mobj;\n #endif\n }", "target": 1}
{"code": "static int phar_tar_process_metadata(phar_entry_info *entry, php_stream *fp TSRMLS_DC) \n{\n\tchar *metadata;\n\tsize_t save = php_stream_tell(fp), read;\n\tphar_entry_info *mentry;\n\tmetadata = (char *) emalloc(entry->uncompressed_filesize + 1);\n\tread = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n\tif (read != entry->uncompressed_filesize) {\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\tif (phar_parse_metadata(&metadata, &entry->metadata, entry->uncompressed_filesize TSRMLS_CC) == FAILURE) {\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\tif (entry->filename_len == sizeof(\".phar/.metadata.bin\")-1 && !memcmp(entry->filename, \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1)) {\n\t\tentry->phar->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t} else if (entry->filename_len >= sizeof(\".phar/.metadata/\") + sizeof(\"/.metadata.bin\") - 1 && SUCCESS == zend_hash_find(&(entry->phar->manifest), entry->filename + sizeof(\".phar/.metadata/\") - 1, entry->filename_len - (sizeof(\"/.metadata.bin\") - 1 + sizeof(\".phar/.metadata/\") - 1), (void *)&mentry)) {\n\t\tmentry->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t}\n\tefree(metadata);\n\tphp_stream_seek(fp, save, SEEK_SET);\n\treturn SUCCESS;\n}", "target": 1}
{"code": "extract_argv (EvDocument *document, gint page)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\tchar **argv;\n\tchar *command_line, *quoted_archive, *quoted_filename;\n\tGError *err = NULL;\n\tif (g_strrstr (comics_document->page_names->pdata[page], \"--checkpoint-action=\"))\n\t{\n\t\tg_warning (\"File unsupported\\n\");\n\t\tgtk_main_quit ();\n\t}\n        if (page >= comics_document->page_names->len)\n                return NULL;\n\tif (comics_document->regex_arg) {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename =\n\t\t\tcomics_regex_quote (comics_document->page_names->pdata[page]);\n\t} else {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename = g_shell_quote (comics_document->page_names->pdata[page]);\n\t}\n\tcommand_line = g_strdup_printf (\"%s %s %s\",\n\t\t\t\t\tcomics_document->extract_command,\n\t\t\t\t\tquoted_archive,\n\t\t\t\t\tquoted_filename);\n\tg_free (quoted_archive);\n\tg_free (quoted_filename);\n\tg_shell_parse_argv (command_line, NULL, &argv, &err);\n\tg_free (command_line);\n\tif (err) {\n\t\tg_warning (_(\"Error %s\"), err->message);\n\t\tg_error_free (err);\n\t\treturn NULL;\n\t}\n\treturn argv;\n}", "target": 1}
{"code": "snmp_ber_encode_null(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  (*out_len)++;\n  *out-- = 0x00;\n  out = snmp_ber_encode_type(out, out_len, type);\n  return out;\n}", "target": 1}
{"code": "hb_set_union (hb_set_t       *set,\n\t      const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->union_ (*other);\n}", "target": 1}
{"code": "static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp;\n\tstruct sem_array *sma;\n\trcu_read_lock();\n\tipcp = ipc_obtain_object(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp)) {\n\t\tsma = ERR_CAST(ipcp);\n\t\tgoto err;\n\t}\n\tspin_lock(&ipcp->lock);\n\tif (!ipcp->deleted)\n\t\treturn container_of(ipcp, struct sem_array, sem_perm);\n\tspin_unlock(&ipcp->lock);\n\tsma = ERR_PTR(-EINVAL);\nerr:\n\trcu_read_unlock();\n\treturn sma;\n}", "target": 1}
{"code": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n \t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n \t\tflush_dcache_page(page);\n \t\tif (!tmp) {\n \t\t\tunlock_page(page);\n \t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n \t\treq->page_descs[req->num_pages].length = tmp;\n \t\treq->num_pages++;\n\t\tiov_iter_advance(ii, tmp);\n \t\tcount += tmp;\n \t\tpos += tmp;\n \t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\treturn count > 0 ? count : err;\n}", "target": 1}
{"code": "static void ssdp_recv(int sd)\n{\n \tssize_t len;\n \tstruct sockaddr sa;\n \tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n \tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n \tif (len > 0) {\n\t\tbuf[len] = 0;\n \t\tif (sa.sa_family != AF_INET)\n \t\t\treturn;\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \"No matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"Matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\ttype = strcasestr(buf, \"\\r\\nST:\");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \"No Search Type (ST:) found in M-SEARCH *, assuming \" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\t\t\tptr = strstr(type, \"\\r\\n\");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * ST: %s from %s port %d\", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * for unsupported ST: %s from %s\", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}", "target": 1}
{"code": "__global__ void UnsortedSegmentCustomKernel(const Index input_outer_dim_size,\n                                            const Index inner_dim_size,\n                                            const Index output_outer_dim_size,\n                                            const Index* segment_ids,\n                                            const T* input, T* output) {\n  const Index input_total_size = input_outer_dim_size * inner_dim_size;\n  const Index output_total_size = output_outer_dim_size * inner_dim_size;\n  for (int input_index : GpuGridRangeX(input_total_size)) {\n    const Index input_segment_index = input_index / inner_dim_size;\n    const Index segment_offset = input_index % inner_dim_size;\n    const Index output_segment_index = segment_ids[input_segment_index];\n    if (output_segment_index < 0 || output_segment_index >= output_total_size) {\n      continue;\n    }\n    const Index output_index =\n        output_segment_index * inner_dim_size + segment_offset;\n    KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n  }\n}", "target": 1}
{"code": "  void readStructEnd() {\n    lastFieldId_ = nestedStructFieldIds_.back();\n    nestedStructFieldIds_.pop_back();\n  }", "target": 1}
{"code": "static int php_openssl_validate_iv(char **piv, size_t *piv_len, size_t iv_required_len,\n\t\tzend_bool *free_iv, EVP_CIPHER_CTX *cipher_ctx, struct php_openssl_cipher_mode *mode) \n{\n\tchar *iv_new;\n\tif (*piv_len == iv_required_len) {\n\t\treturn SUCCESS;\n\t}\n\tif (mode->is_aead) {\n\t\tif (EVP_CIPHER_CTX_ctrl(cipher_ctx, mode->aead_ivlen_flag, *piv_len, NULL) != 1) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Setting of IV length for AEAD mode failed\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\tiv_new = ecalloc(1, iv_required_len + 1);\n\tif (*piv_len == 0) {\n\t\t*piv_len = iv_required_len;\n\t\t*piv = iv_new;\n\t\t*free_iv = 1;\n\t\treturn SUCCESS;\n\t}\n\tif (*piv_len < iv_required_len) {\n\t\tphp_error_docref(NULL, E_WARNING,\n\t\t\t\t\"IV passed is only %zd bytes long, cipher expects an IV of precisely %zd bytes, padding with \\\\0\",\n\t\t\t\t*piv_len, iv_required_len);\n\t\tmemcpy(iv_new, *piv, *piv_len);\n\t\t*piv_len = iv_required_len;\n\t\t*piv = iv_new;\n\t\t*free_iv = 1;\n\t\treturn SUCCESS;\n\t}\n\tphp_error_docref(NULL, E_WARNING,\n\t\t\t\"IV passed is %zd bytes long which is longer than the %zd expected by selected cipher, truncating\",\n\t\t\t*piv_len, iv_required_len);\n\tmemcpy(iv_new, *piv, iv_required_len);\n\t*piv_len = iv_required_len;\n\t*piv = iv_new;\n\t*free_iv = 1;\n\treturn SUCCESS;\n}", "target": 1}
{"code": " static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n {\n\tstruct serial_icounter_struct icount;\n \tstruct sb_uart_icount cnow;\n \tstruct sb_uart_port *port = state->port;\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}", "target": 1}
{"code": "GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void tiny_dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size)\n{\n    if (!pb_parse(entry, msg, msg_size, msg_tiny)) {\n        call_msg_failure_handler(FailureType_Failure_UnexpectedMessage,\n                                 \"Could not parse tiny protocol buffer message\");\n        return;\n    }\n    msg_tiny_id = entry->msg_id;\n}", "target": 1}
{"code": "char *QuotedString::extractFrom(char *input, char **endPtr) {\n  char firstChar = *input;\n  if (!isQuote(firstChar)) {\n    return NULL;\n  }\n  char stopChar = firstChar;  \n  char *startPtr = input + 1;  \n  char *readPtr = startPtr;\n  char *writePtr = startPtr;\n  char c;\n  for (;;) {\n    c = *readPtr++;\n    if (c == '\\0') {\n      return NULL;\n    }\n    if (c == stopChar) {\n      break;\n    }\n    if (c == '\\\\') {\n      c = unescapeChar(*readPtr++);\n    }\n    *writePtr++ = c;\n  }\n  *writePtr = '\\0';\n  *endPtr = readPtr;\n  return startPtr;\n}", "target": 1}
{"code": "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n{\n\tif (prev_options != NULL) {\n\t\t*prev_options = MBREX(regex_default_options);\n\t}\n\tif (prev_syntax != NULL) {\n\t\t*prev_syntax = MBREX(regex_default_syntax);\n\t}\n\tMBREX(regex_default_options) = options;\n\tMBREX(regex_default_syntax) = syntax;\n}", "target": 1}
{"code": "void nft_byteorder_eval(const struct nft_expr *expr,\n\t\t\tstruct nft_regs *regs,\n\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_byteorder *priv = nft_expr_priv(expr);\n\tu32 *src = &regs->data[priv->sreg];\n\tu32 *dst = &regs->data[priv->dreg];\n\tu16 *s16, *d16;\n\tunsigned int i;\n\ts16 = (void *)src;\n\td16 = (void *)dst;\n\tswitch (priv->size) {\n\tcase 8: {\n\t\tu64 src64;\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = nft_reg_load64(&src[i]);\n\t\t\t\tnft_reg_store64(&dst[i],\n\t\t\t\t\t\tbe64_to_cpu((__force __be64)src64));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = (__force __u64)\n\t\t\t\t\tcpu_to_be64(nft_reg_load64(&src[i]));\n\t\t\t\tnft_reg_store64(&dst[i], src64);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = ntohl((__force __be32)src[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = (__force __u32)htonl(src[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = ntohs((__force __be16)s16[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = (__force __u16)htons(s16[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "bool DNP3_Base::ProcessData(int len, const u_char* data, bool orig)\n\t{\n\tEndpoint* endp = orig ? &orig_state : &resp_state;\n\twhile ( len )\n\t\t{\n\t\tif ( endp->in_hdr )\n\t\t\t{\n\t\t\tif ( ! AddToBuffer(endp, PSEUDO_APP_LAYER_INDEX, &data, &len) )\n\t\t\t\treturn true;\n\t\t\tif( endp->buffer[0] != 0x05 || endp->buffer[1] != 0x64 )\n\t\t\t\t{\n\t\t\t\tanalyzer->Weird(\"dnp3_header_lacks_magic\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\tif ( ! CheckCRC(PSEUDO_LINK_LAYER_LEN, endp->buffer, endp->buffer + PSEUDO_LINK_LAYER_LEN, \"header\") )\n\t\t\t\t{\n\t\t\t\tanalyzer->ProtocolViolation(\"broken_checksum\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\tanalyzer->ProtocolConfirmation();\n\t\t\tif ( (endp->buffer[PSEUDO_LENGTH_INDEX] + 3) == (char)PSEUDO_LINK_LAYER_LEN  )\n\t\t\t\t{\n\t\t\t\tClearEndpointState(orig);\n\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\tu_char ctrl = endp->buffer[PSEUDO_CONTROL_FIELD_INDEX];\n\t\t\tif ( orig != (bool)(ctrl & 0x80) )\n\t\t\t\tanalyzer->Weird(\"dnp3_unexpected_flow_direction\");\n\t\t\tendp->pkt_length = endp->buffer[PSEUDO_LENGTH_INDEX];\n\t\t\tendp->tpflags = endp->buffer[PSEUDO_TRANSPORT_INDEX];\n\t\t\tendp->in_hdr = false; \n\t\t\tif ( ++endp->pkt_cnt == 1 )\n\t\t\t\tinterp->NewData(orig, endp->buffer, endp->buffer + PSEUDO_LINK_LAYER_LEN);\n\t\t\t}\n\t\tif ( ! endp->in_hdr )\n\t\t\t{\n\t\t\tassert(endp->pkt_length);\n\t\t\tint n = PSEUDO_APP_LAYER_INDEX + (endp->pkt_length - 5) + ((endp->pkt_length - 5) / 16) * 2\n\t\t\t\t\t+ 2 * ( ((endp->pkt_length - 5) % 16 == 0) ? 0 : 1) - 1 ;\n\t\t\tif ( ! AddToBuffer(endp, n, &data, &len) )\n\t\t\t\treturn true;\n\t\t\tif ( ! ParseAppLayer(endp) )\n\t\t\t\treturn false;\n\t\t\tendp->buffer_len = 0;\n\t\t\tendp->in_hdr = true;\n\t\t\t}\n\t\t}\n\treturn true;\n\t}", "target": 1}
{"code": "void AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)av1, GF_FALSE);\n\tif (av1->emul_esd) gf_odf_desc_del((GF_Descriptor *)av1->emul_esd);\n\tav1->emul_esd = gf_odf_desc_esd_new(2);\n\tav1->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\tav1->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;\n\tif (btrt) {\n\t\tav1->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tav1->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tav1->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (av1->av1_config) {\n\t\tGF_AV1Config *av1_cfg = AV1_DuplicateConfig(av1->av1_config->config);\n\t\tif (av1_cfg) {\n\t\t\tgf_odf_av1_cfg_write(av1_cfg, &av1->emul_esd->decoderConfig->decoderSpecificInfo->data, &av1->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_av1_cfg_del(av1_cfg);\n\t\t}\n\t}\n}", "target": 1}
{"code": "tca_get_fill(struct sk_buff *skb, struct tc_action *a, u32 pid, u32 seq,\n             u16 flags, int event, int bind, int ref)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\tif (tcf_action_dump(skb, a, bind, ref) < 0)\n\t\tgoto rtattr_failure;\n\tx->rta_len = skb->tail - (u8*)x;\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n         *elem_rtrn = NULL;\n         *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n         *index_rtrn = NULL;\n        return true;\n     case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 1}
{"code": "static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n \t\t}\n \t\tsec.level = rfcomm_pi(sk)->sec_level;\n \t\tlen = min_t(unsigned int, len, sizeof(sec));\n \t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "Stream *Parser::makeStream(Object &&dict, Guchar *fileKey,\n\t\t\t   CryptAlgorithm encAlgorithm, int keyLength,\n\t\t\t   int objNum, int objGen, int recursion,\n                           GBool strict) {\n  BaseStream *baseStr;\n  Stream *str;\n  Goffset length;\n  Goffset pos, endPos;\n  lexer->skipToNextLine();\n  if (!(str = lexer->getStream())) {\n    return nullptr;\n  }\n  pos = str->getPos();\n  Object obj = dict.dictLookup(\"Length\", recursion);\n  if (obj.isInt()) {\n    length = obj.getInt();\n  } else if (obj.isInt64()) {\n    length = obj.getInt64();\n  } else {\n    error(errSyntaxError, getPos(), \"Bad 'Length' attribute in stream\");\n    if (strict) return nullptr;\n    length = 0;\n  }\n  if (xref && xref->getStreamEnd(pos, &endPos)) {\n    length = endPos - pos;\n  }\n  if (!lexer->getStream()) {\n    return nullptr;\n  }\n  baseStr = lexer->getStream()->getBaseStream();\n  if (Lexer::LOOK_VALUE_NOT_CACHED != lexer->lookCharLastValueCached) {\n      pos = pos - 1;\n      lexer->lookCharLastValueCached = Lexer::LOOK_VALUE_NOT_CACHED;\n  }\n  lexer->setPos(pos + length);\n  shift();  \n  shift(\"endstream\", objNum);  \n  if (buf1.isCmd(\"endstream\")) {\n    shift();\n  } else {\n    error(errSyntaxError, getPos(), \"Missing 'endstream' or incorrect stream length\");\n    if (strict) return nullptr;\n    if (xref && lexer->getStream()) {\n      length = lexer->getPos() - pos;\n      if (buf1.isCmd(\"endstream\")) {\n        dict.dictSet(\"Length\", Object(length));\n      }\n    } else {\n      length += 5000;\n    }\n  }\n  str = baseStr->makeSubStream(pos, gTrue, length, std::move(dict));\n  if (fileKey) {\n    str = new DecryptStream(str, fileKey, encAlgorithm, keyLength,\n\t\t\t    objNum, objGen);\n  }\n  str = str->addFilters(str->getDict(), recursion);\n  return str;\n}", "target": 1}
{"code": "static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct in6_addr *final_p, final;\n\tstruct flowi6 fl6;\n\tint err = -1;\n\tstruct dst_entry *dst;\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\tfl6.saddr = ireq->ir_v6_loc_addr;\n\tfl6.flowlabel = 0;\n\tfl6.flowi6_oif = ireq->ir_iif;\n\tfl6.fl6_dport = ireq->ir_rmt_port;\n\tfl6.fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto done;\n\t}\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tdh->dccph_checksum = dccp_v6_csum_finish(skb,\n\t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n\t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\terr = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\ndone:\n\tdst_release(dst);\n\treturn err;\n}", "target": 1}
{"code": "static void _imap_quote_string (char *dest, size_t dlen, const char *src,\n                                const char *to_quote)\n{\n  char *pt;\n  const char *s;\n  pt = dest;\n  s  = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr (to_quote, *s))\n    {\n      dlen -= 2;\n      if (!dlen)\n\tbreak;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = 0;\n}", "target": 1}
{"code": " native_handle_t* native_handle_create(int numFds, int numInts)\n {\n    native_handle_t* h = malloc(\n            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));\n     if (h) {\n         h->version = sizeof(native_handle_t);\n         h->numFds = numFds;\n        h->numInts = numInts;\n }\n return h;\n}", "target": 1}
{"code": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n \tinode->i_uid = current_fsuid();\n \tif (dir && dir->i_mode & S_ISGID) {\n \t\tinode->i_gid = dir->i_gid;\n \t\tif (S_ISDIR(mode))\n \t\t\tmode |= S_ISGID;\n \t} else\n \t\tinode->i_gid = current_fsgid();\n \tinode->i_mode = mode;\n}", "target": 1}
{"code": "static int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "get_html_data (MAPI_Attr *a)\n{\n    VarLenData **body = XCALLOC(VarLenData*, a->num_values + 1);\n    int j;\n    for (j = 0; j < a->num_values; j++)\n    {\n\tbody[j] = XMALLOC(VarLenData, 1);\n\tbody[j]->len = a->values[j].len;\n\tbody[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n\tmemmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n    }\n    return body;\n}", "target": 1}
{"code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\tif (line == NULL)\n\t\t\treturn;\n\t\tfilter_data(fs->id, line);\n\t\tgoto nextline;\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\texdata = (epass2003_exdata *)card->drv_data;\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n\tif (2 == cipher_len)\n \t\treturn -1;\n \tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}", "target": 1}
{"code": "static const char *sip_endpoint_identifier_type2str(enum ast_sip_endpoint_identifier_type method)\n{\n\tconst char *str = \"<unknown>\";\n\tswitch (method) {\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME:\n\t\tstr = \"username\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME:\n\t\tstr = \"auth_username\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_IP:\n\t\tstr = \"ip\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER:\n\t\tstr = \"header\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI:\n\t\tstr = \"request_uri\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT:\n\t\tstr = \"transport\";\n\t\tbreak;\n\t}\n\treturn str;\n}", "target": 1}
{"code": "print_set_output(char *name, TBOOLEAN datablock, TBOOLEAN append_p)\n{\n    if (print_out && print_out != stderr && print_out != stdout) {\n#ifdef PIPES\n\tif (print_out_name[0] == '|') {\n\t    if (0 > pclose(print_out))\n\t\tperror(print_out_name);\n\t} else\n#endif\n\t    if (0 > fclose(print_out))\n\t\tperror(print_out_name);\n    }\n    free(print_out_name);\n    print_out_name = NULL;\n    print_out_var = NULL;\n    if (! name) {\n\tprint_out = stderr;\n\treturn;\n    }\n    if (strcmp(name, \"-\") == 0) {\n\tprint_out = stdout;\n\treturn;\n    }\n#ifdef PIPES\n    if (name[0] == '|') {\n\trestrict_popen();\n\tprint_out = popen(name + 1, \"w\");\n\tif (!print_out)\n\t    perror(name);\n\telse\n\t    print_out_name = name;\n\treturn;\n    }\n#endif\n    if (!datablock) {\n\tprint_out = fopen(name, append_p ? \"a\" : \"w\");\n\tif (!print_out) {\n\t    perror(name);\n\t    return;\n\t}\n    } else {\n\tprint_out_var = add_udv_by_name(name);\n\tif (!append_p)\n\t    gpfree_datablock(&print_out_var->udv_value);\n\tif (print_out_var->udv_value.type != DATABLOCK) {\n\t    free_value(&print_out_var->udv_value);\n\t    print_out_var->udv_value.type = DATABLOCK;\n\t    print_out_var->udv_value.v.data_array = NULL;\n\t}\n    }\n    print_out_name = name;\n}", "target": 1}
{"code": "static int decode_tree_entry(struct tree_desc *desc, const char *buf, unsigned long size, struct strbuf *err)\n{\n\tconst char *path;\n\tunsigned int mode, len;\n\tif (size < 23 || buf[size - 21]) {\n\t\tstrbuf_addstr(err, _(\"too-short tree object\"));\n\t\treturn -1;\n\t}\n\tpath = get_mode(buf, &mode);\n\tif (!path) {\n\t\tstrbuf_addstr(err, _(\"malformed mode in tree entry\"));\n\t\treturn -1;\n\t}\n\tif (!*path) {\n\t\tstrbuf_addstr(err, _(\"empty filename in tree entry\"));\n\t\treturn -1;\n\t}\n\tlen = strlen(path) + 1;\n\tdesc->entry.path = path;\n\tdesc->entry.mode = canon_mode(mode);\n\tdesc->entry.oid  = (const struct object_id *)(path + len);\n\treturn 0;\n}", "target": 1}
{"code": "char *Hub::inflate(char *data, size_t &length) {\n    dynamicInflationBuffer.clear();\n    inflationStream.next_in = (Bytef *) data;\n    inflationStream.avail_in = length;\n    int err;\n    do {\n        inflationStream.next_out = (Bytef *) inflationBuffer;\n        inflationStream.avail_out = LARGE_BUFFER_SIZE;\n        err = ::inflate(&inflationStream, Z_FINISH);\n        if (!inflationStream.avail_in) {\n            break;\n        }\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n    } while (err == Z_BUF_ERROR);\n    inflateReset(&inflationStream);\n    if (err != Z_BUF_ERROR && err != Z_OK) {\n        length = 0;\n        return nullptr;\n    }\n    if (dynamicInflationBuffer.length()) {\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n        length = dynamicInflationBuffer.length();\n        return (char *) dynamicInflationBuffer.data();\n    }\n    length = LARGE_BUFFER_SIZE - inflationStream.avail_out;\n    return inflationBuffer;\n}", "target": 1}
{"code": "rdpBitmapCache* bitmap_cache_new(rdpSettings* settings)\n{\n\tint i;\n\trdpBitmapCache* bitmapCache;\n\tbitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache));\n\tif (!bitmapCache)\n\t\treturn NULL;\n\tbitmapCache->settings = settings;\n\tbitmapCache->update = ((freerdp*)settings->instance)->update;\n\tbitmapCache->context = bitmapCache->update->context;\n\tbitmapCache->maxCells = settings->BitmapCacheV2NumCells;\n\tbitmapCache->cells = (BITMAP_V2_CELL*)calloc(bitmapCache->maxCells, sizeof(BITMAP_V2_CELL));\n\tif (!bitmapCache->cells)\n\t\tgoto fail;\n\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t{\n\t\tbitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries;\n\t\tbitmapCache->cells[i].entries =\n\t\t    (rdpBitmap**)calloc((bitmapCache->cells[i].number + 1), sizeof(rdpBitmap*));\n\t\tif (!bitmapCache->cells[i].entries)\n\t\t\tgoto fail;\n\t}\n\treturn bitmapCache;\nfail:\n\tif (bitmapCache->cells)\n\t{\n\t\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t\t\tfree(bitmapCache->cells[i].entries);\n\t}\n\tfree(bitmapCache);\n\treturn NULL;\n}", "target": 1}
{"code": "krb5_gss_context_time(minor_status, context_handle, time_rec)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    OM_uint32 *time_rec;\n{\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    if ((code = krb5_timeofday(ctx->k5_context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, ctx->k5_context);\n        return(GSS_S_FAILURE);\n    }\n    if ((lifetime = ctx->krb_times.endtime - now) <= 0) {\n        *time_rec = 0;\n        *minor_status = 0;\n        return(GSS_S_CONTEXT_EXPIRED);\n    } else {\n        *time_rec = lifetime;\n        *minor_status = 0;\n        return(GSS_S_COMPLETE);\n    }\n}", "target": 1}
{"code": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\t\tmemcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);\n\t\tpos += fraglen;\n\t}\n\tskb->len = hdrlen + per_fragm;\n\treturn 0;\n}", "target": 1}
{"code": "static int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\tvgacon_scrollback_switch(c->vc_num);\n\treturn 0;\t\t\n}", "target": 1}
{"code": "static s32 adpt_i2o_hrt_get(adpt_hba* pHba)\n{\n\tu32 msg[6];\n\tint ret, size = sizeof(i2o_hrt);\n\tdo {\n\t\tif (pHba->hrt == NULL) {\n\t\t\tpHba->hrt = dma_alloc_coherent(&pHba->pDev->dev,\n\t\t\t\t\tsize, &pHba->hrt_pa, GFP_KERNEL);\n\t\t\tif (pHba->hrt == NULL) {\n\t\t\t\tprintk(KERN_CRIT \"%s: Hrt Get failed; Out of memory.\\n\", pHba->name);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tmsg[0]= SIX_WORD_MSG_SIZE| SGL_OFFSET_4;\n\t\tmsg[1]= I2O_CMD_HRT_GET<<24 | HOST_TID<<12 | ADAPTER_TID;\n\t\tmsg[2]= 0;\n\t\tmsg[3]= 0;\n\t\tmsg[4]= (0xD0000000 | size);    \n\t\tmsg[5]= (u32)pHba->hrt_pa;\t\n\t\tif ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg),20))) {\n\t\t\tprintk(KERN_ERR \"%s: Unable to get HRT (status=%#10x)\\n\", pHba->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (pHba->hrt->num_entries * pHba->hrt->entry_len << 2 > size) {\n\t\t\tint newsize = pHba->hrt->num_entries * pHba->hrt->entry_len << 2;\n\t\t\tdma_free_coherent(&pHba->pDev->dev, size,\n\t\t\t\tpHba->hrt, pHba->hrt_pa);\n\t\t\tsize = newsize;\n\t\t\tpHba->hrt = NULL;\n\t\t}\n\t} while(pHba->hrt == NULL);\n\treturn 0;\n}                                                                                                                                       ", "target": 1}
{"code": "ModuleExport size_t RegisterMPCImage(void)\n{\n  MagickInfo\n    *entry;\n   entry=SetMagickInfo(\"CACHE\");\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n   entry->stealth=MagickTrue;\n   (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"MPC\");\n   entry->decoder=(DecodeImageHandler *) ReadMPCImage;\n   entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n   entry->magick=(IsImageFormatHandler *) IsMPC;\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n   (void) RegisterMagickInfo(entry);\n   return(MagickImageCoderSignature);\n}", "target": 1}
{"code": "eval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n    rettv->v_type = VAR_UNKNOWN;\n    if (**arg == '{')\n    {\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ')')\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    ret = FAIL;\n\t}\n\t++*arg;\n    }\n    if (ret != OK)\n\treturn FAIL;\n    else if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_nowhitespace));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n    if (evaluate)\n\tclear_tv(&base);\n    return ret;\n}", "target": 1}
{"code": "pci_get_cfgdata8(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= PCI_REGMAX);\n\treturn (*(uint8_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "ArgParser::parseServerArgs(ServerArgs& args, int argc, const char* const* argv)\n{\n    setArgsBase(args);\n    updateCommonArgs(argv);\n    for (int i = 1; i < argc; ++i) {\n        if (parsePlatformArg(args, argc, argv, i)) {\n            continue;\n        }\n        else if (parseGenericArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (parseDeprecatedArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (isArg(i, argc, argv, \"-a\", \"--address\", 1)) {\n            args.m_barrierAddress = argv[++i];\n        }\n        else if (isArg(i, argc, argv, \"-c\", \"--config\", 1)) {\n            args.m_configFile = argv[++i];\n        }\n        else if (isArg(i, argc, argv, NULL, \"--screen-change-script\", 1)) {\n            args.m_screenChangeScript = argv[++i];\n        }\n        else {\n            LOG((CLOG_PRINT \"%s: unrecognized option `%s'\" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));\n            return false;\n        }\n    }\n    if (checkUnexpectedArgs()) {\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n \tfor (i = 1; i < view->n; ++i) {\n \t\tconst struct user_regset *regset = &view->regsets[i];\n \t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type &&\n \t\t    (!regset->active || regset->active(t->task, regset))) {\n \t\t\tint ret;\n \t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,\n\t\tu64 remaining, u64 expires)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime;\n\tu64 starting_runtime = remaining;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > remaining)\n\t\t\truntime = remaining;\n\t\tremaining -= runtime;\n\t\tcfs_rq->runtime_remaining += runtime;\n\t\tcfs_rq->runtime_expires = expires;\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\nnext:\n\t\trq_unlock_irqrestore(rq, &rf);\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn starting_runtime - remaining;\n}", "target": 1}
{"code": "static int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n}", "target": 1}
{"code": "krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n    *minor_status = 0;\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n    *data_set = GSS_C_NO_BUFFER_SET;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (!ctx->established)\n        return GSS_S_NO_CONTEXT;\n    for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n    *minor_status = EINVAL;\n    return GSS_S_UNAVAILABLE;\n}", "target": 1}
{"code": "   ExtensionBookmarksTest()\n      : client_(NULL), model_(NULL), node_(NULL), folder_(NULL) {}", "target": 1}
{"code": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n \t\t\tstrcpy(buf, \"????\");\n \t\t\tbreak;\n \t\t}\n\t\tstrcat(line, buf);\n\t\tstrcat(line, \" \");\n \t\te = e->next;\n \t}\n \tline[strlen(line)-1] = 0; \n \treturn line;\n }", "target": 1}
{"code": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n  gnutls_datum_t psession;\n  int ret;\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n  psession.data = session_data;\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n       gnutls_assert ();\n       return ret;\n     }\n  *session_data_size = psession.size;\n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n   if (session_data != NULL)\n     memcpy (session_data, psession.data, psession.size);\n  ret = 0;\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}", "target": 1}
{"code": "parse_key_usage (PKT_signature * sig)\n{\n  int key_usage = 0;\n  const byte *p;\n  size_t n;\n  byte flags;\n  p = parse_sig_subpkt (sig->hashed, SIGSUBPKT_KEY_FLAGS, &n);\n  if (p && n)\n    {\n      flags = *p;\n      if (flags & 1)\n\t{\n\t  key_usage |= PUBKEY_USAGE_CERT;\n\t  flags &= ~1;\n\t}\n      if (flags & 2)\n\t{\n\t  key_usage |= PUBKEY_USAGE_SIG;\n\t  flags &= ~2;\n\t}\n      if (flags & (0x04 | 0x08))\n\t{\n\t  key_usage |= PUBKEY_USAGE_ENC;\n\t  flags &= ~(0x04 | 0x08);\n\t}\n      if (flags & 0x20)\n\t{\n\t  key_usage |= PUBKEY_USAGE_AUTH;\n\t  flags &= ~0x20;\n\t}\n      if (flags)\n\tkey_usage |= PUBKEY_USAGE_UNKNOWN;\n    }\n  return key_usage;\n}", "target": 1}
{"code": " static byte parseHexByte(const char * &str) {\n     byte b = parseHexChar(str[0]);\n    if (str[1] == ':' || str[1] == '\\0') {\n        str += 2;\n        return b;\n     } else {\n         b = b << 4 | parseHexChar(str[1]);\n        str += 3;\n        return b;\n     }\n }", "target": 1}
{"code": "find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  guchar *match;\n  int i;\n  if (client->auth_end_offset > 0)\n    {\n      gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;\n      gsize to_match = MIN (left, buffer->pos);\n      if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)\n        {\n          client->auth_end_offset += to_match;\n          if (client->auth_end_offset == strlen (AUTH_END_STRING))\n            return to_match;\n          return -1;\n        }\n      client->auth_end_offset = -1;\n    }\n  match = memmem (buffer, buffer->pos,\n                  AUTH_END_STRING, strlen (AUTH_END_STRING));\n  if (match != NULL)\n    return match - buffer->data + strlen (AUTH_END_STRING);\n  for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)\n    {\n      if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)\n        {\n          client->auth_end_offset = i;\n          break;\n        }\n    }\n  return -1;\n}", "target": 1}
{"code": "Literal *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { \n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          llvm_unreachable(\"Invalid literal kind.\");\n      }\n      break;\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n    default:\n      break;\n  }\n  return nullptr;\n}", "target": 1}
{"code": " ScopedSharedBufferHandle WrapSharedMemoryHandle(\n     const base::SharedMemoryHandle& memory_handle,\n     size_t size,\n    bool read_only) {\n   if (!memory_handle.IsValid())\n     return ScopedSharedBufferHandle();\n   MojoPlatformHandle platform_handle;\n  platform_handle.struct_size = sizeof(MojoPlatformHandle);\n  platform_handle.type = kPlatformSharedBufferHandleType;\n#if defined(OS_MACOSX) && !defined(OS_IOS)\n  platform_handle.value =\n      static_cast<uint64_t>(memory_handle.GetMemoryObject());\n#else\n  platform_handle.value =\n      PlatformHandleValueFromPlatformFile(memory_handle.GetHandle());\n#endif\n   MojoPlatformSharedBufferHandleFlags flags =\n       MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_NONE;\n  if (read_only)\n    flags |= MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n   MojoSharedBufferGuid guid;\n   guid.high = memory_handle.GetGUID().GetHighForSerialization();\n  guid.low = memory_handle.GetGUID().GetLowForSerialization();\n  MojoHandle mojo_handle;\n  MojoResult result = MojoWrapPlatformSharedBufferHandle(\n      &platform_handle, size, &guid, flags, &mojo_handle);\n  CHECK_EQ(result, MOJO_RESULT_OK);\n   return ScopedSharedBufferHandle(SharedBufferHandle(mojo_handle));\n }", "target": 1}
{"code": "static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\tstruct msghdr *msg, size_t len, int noblock, int flags,\n\t\tint *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_ieee802154 *saddr;\n\tsaddr = (struct sockaddr_ieee802154 *)msg->msg_name;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n \tif (saddr) {\n \t\tsaddr->family = AF_IEEE802154;\n \t\tsaddr->addr = mac_cb(skb)->sa;\n\t}\n\tif (addr_len)\n \t\t*addr_len = sizeof(*saddr);\n \tif (flags & MSG_TRUNC)\n \t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}", "target": 1}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\t*_request = NULL;\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n}", "target": 1}
{"code": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MaxTextExtent];\n  const MagicInfo\n    *magic_info;\n  FILE\n    *ps_file;\n  ImageInfo\n    *clone_info;\n  Image\n    *image2;\n  unsigned char\n    magick[2*MaxTextExtent];\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MaxTextExtent, magick);\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n   if(exception->severity != UndefinedException) goto FINISH_UNL;\n   if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n  (void) CopyMagickMemory(clone_info->magick,magic_info->name,MaxTextExtent);\n  FormatLocaleString(clone_info->filename,MaxTextExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n  if (!image2)\n    goto FINISH_UNL;\n  (void) CopyMagickMemory(image2->filename,image->filename,MaxTextExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MaxTextExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MaxTextExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n  AppendImageToList(&image,image2);\n FINISH_UNL:\n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1}
{"code": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\tstrlcpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "png_set_PLTE(png_structp png_ptr, png_infop info_ptr,\n    png_colorp palette, int num_palette)\n {\n    png_debug1(1, \"in %s storage function\", \"PLTE\");\n    if (png_ptr == NULL || info_ptr == NULL)\n       return;\n   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)\n    {\n       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n          png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n#ifdef PNG_FREE_ME_SUPPORTED\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n #endif\n    png_ptr->palette = (png_colorp)png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * png_sizeof(png_color));\n   png_memcpy(png_ptr->palette, palette, num_palette * png_sizeof(png_color));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n#ifdef PNG_FREE_ME_SUPPORTED\n   info_ptr->free_me |= PNG_FREE_PLTE;\n#else\n   png_ptr->flags |= PNG_FLAG_FREE_PLTE;\n#endif\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "target": 1}
{"code": "size_t mobi_get_attribute_value(char *value, const unsigned char *data, const size_t size, const char *attribute, bool only_quoted) {\n    if (!data) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return SIZE_MAX;\n    }\n    size_t length = size;\n    size_t attr_length = strlen(attribute);\n    if (attr_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", attr_length);\n        return SIZE_MAX;\n    }\n    char attr[MOBI_ATTRNAME_MAXSIZE + 2];\n    strcpy(attr, attribute);\n    strcat(attr, \"=\");\n    attr_length++;\n    if (size < attr_length) {\n        return SIZE_MAX;\n    }\n    unsigned char last_border = '\\0';\n    do {\n        if (*data == '<' || *data == '>') {\n            last_border = *data;\n        }\n        if (length > attr_length + 1 && memcmp(data, attr, attr_length) == 0) {\n            size_t offset = size - length;\n            if (last_border == '>') {\n                data += attr_length;\n                length -= attr_length - 1;\n                continue;\n            }\n            if (offset > 0) {\n                if (data[-1] != '<' && !isspace(data[-1])) {\n                    data += attr_length;\n                    length -= attr_length - 1;\n                    continue;\n                }\n            }\n            data += attr_length;\n            length -= attr_length;\n            unsigned char separator;\n            if (*data != '\\'' && *data != '\"') {\n                if (only_quoted) {\n                    continue;\n                }\n                separator = ' ';\n            } else {\n                separator = *data;\n                data++;\n                length--;\n            }\n            size_t j;\n            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            if (*(data - 1) == '/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            return size - length - j;\n        }\n        data++;\n    } while (--length);\n    value[0] = '\\0';\n    return SIZE_MAX;\n}", "target": 1}
{"code": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new ();\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif \n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\t\tg_object_unref (logger);\n\t}\n\treturn session;\n}", "target": 1}
{"code": "static void vgacon_scrollback_update(struct vc_data *c, int t, int count)\n{\n\tvoid *p;\n\tif (!vgacon_scrollback_cur->data || !vgacon_scrollback_cur->size ||\n\t    c->vc_num != fg_console)\n\t\treturn;\n\tp = (void *) (c->vc_origin + t * c->vc_size_row);\n\twhile (count--) {\n\t\tif ((vgacon_scrollback_cur->tail + c->vc_size_row) >\n\t\t    vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\t\tscr_memcpyw(vgacon_scrollback_cur->data +\n\t\t\t    vgacon_scrollback_cur->tail,\n\t\t\t    p, c->vc_size_row);\n\t\tvgacon_scrollback_cur->cnt++;\n\t\tp += c->vc_size_row;\n\t\tvgacon_scrollback_cur->tail += c->vc_size_row;\n\t\tif (vgacon_scrollback_cur->tail >= vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\t\tif (vgacon_scrollback_cur->cnt > vgacon_scrollback_cur->rows)\n\t\t\tvgacon_scrollback_cur->cnt = vgacon_scrollback_cur->rows;\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}", "target": 1}
{"code": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\tif (line == NULL)\n\t\treturn (0);\n\tif (*line != '<')\n\t\treturn (0);\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "static inline void find_entity_for_char(\n\tunsigned int k,\n\tenum entity_charset charset,\n\tconst entity_stage1_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len,\n\tunsigned char *old,\n\tsize_t oldlen,\n\tsize_t *cursor)\n{\n\tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n\tconst entity_stage3_row *c;\n\tif (stage1_idx > 0x1D) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\tc = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)];\n\tif (!c->ambiguous) {\n\t\t*entity     = (const unsigned char *)c->data.ent.entity;\n\t\t*entity_len = c->data.ent.entity_len;\n\t} else {\n\t\tsize_t\t cursor_before\t= *cursor;\n\t\tint\t\t status\t\t\t= SUCCESS;\n\t\tunsigned next_char;\n\t\tif (!(*cursor < oldlen))\n\t\t\tgoto no_suitable_2nd;\n\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status); \n\t\tif (status == FAILURE)\n\t\t\tgoto no_suitable_2nd;\n\t\t{\n\t\t\tconst entity_multicodepoint_row *s, *e;\n\t\t\ts = &c->data.multicodepoint_table[1];\n\t\t\te = s - 1 + c->data.multicodepoint_table[0].leading_entry.size;\n\t\t\tfor ( ; s <= e; s++) {\n\t\t\t\tif (s->normal_entry.second_cp == next_char) {\n\t\t\t\t\t*entity     = s->normal_entry.entity;\n\t\t\t\t\t*entity_len = s->normal_entry.entity_len;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nno_suitable_2nd:\n\t\t*cursor = cursor_before;\n\t\t*entity = (const unsigned char *)\n\t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n\t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n\t}\t\n}", "target": 1}
{"code": "void LineTo(double x1,double y1) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f l\",x1,y1);\n}", "target": 1}
{"code": "static unsigned int stack_maxrandom_size(void)\n{\n\tunsigned int max = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n\t}\n\treturn max;\n}", "target": 1}
{"code": "static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\tsctp_association_hold(asoc);\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n \t\trelease_sock(sk);\n \t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tBUG_ON(sk != asoc->base.sk);\n \t\tlock_sock(sk);\n \t\t*timeo_p = current_timeo;\n\t}\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\tsctp_association_put(asoc);\n\treturn err;\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}", "target": 1}
{"code": "static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = false;\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n\tport->serio = NULL;\n}", "target": 1}
{"code": "BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(\n    TabContents* tab_contents,\n    const string16& utf16_name)\n    : PluginInfoBarDelegate(tab_contents, utf16_name) {\n  UserMetrics::RecordAction(UserMetricsAction(\"BlockedPluginInfobar.Shown\"));\n  std::string name = UTF16ToUTF8(utf16_name);\n  if (name == webkit::npapi::PluginGroup::kJavaGroupName)\n    UserMetrics::RecordAction(\n        UserMetricsAction(\"BlockedPluginInfobar.Shown.Java\"));\n  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)\n    UserMetrics::RecordAction(\n        UserMetricsAction(\"BlockedPluginInfobar.Shown.QuickTime\"));\n  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)\n    UserMetrics::RecordAction(\n        UserMetricsAction(\"BlockedPluginInfobar.Shown.Shockwave\"));\n   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)\n     UserMetrics::RecordAction(\n         UserMetricsAction(\"BlockedPluginInfobar.Shown.RealPlayer\"));\n }", "target": 1}
{"code": "bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n    pop_finished_files();\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n        free = BSIZE - copy;\n    }\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n    return true;\n}", "target": 1}
{"code": "static pdf_creator_t *new_creator(int *n_elements)\n{\n    pdf_creator_t *daddy;\n    static const pdf_creator_t creator_template[] = \n    {\n        {\"Title\",        \"\"},\n        {\"Author\",       \"\"},\n        {\"Subject\",      \"\"},\n        {\"Keywords\",     \"\"},\n        {\"Creator\",      \"\"},\n        {\"Producer\",     \"\"},\n        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n    daddy = malloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n    if (n_elements)\n      *n_elements = sizeof(creator_template) / sizeof(creator_template[0]);\n    return daddy;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    ValidateInputTensors(ctx, in0, in1);\n    MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n    OP_REQUIRES(\n        ctx, bcast.IsValid(),\n        errors::InvalidArgument(\n            \"In[0] and In[1] must have compatible batch dimensions: \",\n            in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n    TensorShape out_shape = bcast.output_batch_shape();\n    auto batch_size = bcast.output_batch_size();\n    auto d0 = in0.dim_size(in0.dims() - 2);  \n    auto d1 = in0.dim_size(in0.dims() - 1);\n    Tensor in0_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n        errors::Internal(\"Failed to reshape In[0] from \",\n                         in0.shape().DebugString()));\n    auto d2 = in1.dim_size(in1.dims() - 2);\n    auto d3 = in1.dim_size(in1.dims() - 1);\n    Tensor in1_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n        errors::Internal(\"Failed to reshape In[1] from \",\n                         in1.shape().DebugString()));\n    OP_REQUIRES(ctx, d1 == d2,\n                errors::InvalidArgument(\n                    \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                    in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                    \" \", lower_, \" \", adjoint_));\n    out_shape.AddDim(d1);\n    out_shape.AddDim(d3);\n    Tensor* out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n    if (out->NumElements() == 0) {\n      return;\n    }\n    Tensor out_reshaped;\n    OP_REQUIRES(ctx,\n                out_reshaped.CopyFrom(*out, TensorShape({batch_size, d1, d3})),\n                errors::Internal(\"Failed to reshape output from \",\n                                 out->shape().DebugString()));\n    LaunchBatchBandedTriangularSolve<Scalar>::Launch(\n        ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n        &out_reshaped);\n  }", "target": 1}
{"code": "static int match_func(struct libmnt_fs *fs,\n\t\t      void *data __attribute__ ((__unused__)))\n{\n\tint rc = flags & FL_INVERT ? 1 : 0;\n\tconst char *m;\n\tvoid *md;\n\tm = get_match(COL_FSTYPE);\n\tif (m && !mnt_fs_match_fstype(fs, m))\n\t\treturn rc;\n\tm = get_match(COL_OPTIONS);\n\tif (m && !mnt_fs_match_options(fs, m))\n\t\treturn rc;\n\tmd = get_match_data(COL_MAJMIN);\n\tif (md && mnt_fs_get_devno(fs) != *((dev_t *) md))\n\t\treturn rc;\n\tm = get_match(COL_TARGET);\n\tif (m && !mnt_fs_match_target(fs, m, cache))\n\t\treturn rc;\n\tm = get_match(COL_SOURCE);\n\tif (m && !mnt_fs_match_source(fs, m, cache))\n\t\treturn rc;\n\tif ((flags & FL_DF) && !(flags & FL_ALL)) {\n\t\tconst char *type = mnt_fs_get_fstype(fs);\n\t\tif (type && strstr(type, \"tmpfs\"))\t\n\t\t\treturn !rc;\n\t\tif (mnt_fs_is_pseudofs(fs))\n\t\t\treturn rc;\n\t}\n\tif ((flags & FL_REAL) && mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\tif ((flags & FL_PSEUDO) && !mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\tif ((flags & FL_SHADOWED)) {\n\t\tstruct libmnt_table *tb = NULL;\n\t\tmnt_fs_get_table(fs, &tb);\n\t\tif (tb && mnt_table_over_fs(tb, fs, NULL) != 0)\n\t\t\treturn rc;\n\t}\n\tif ((flags & FL_DELETED) && !mnt_fs_is_deleted(fs))\n\t\treturn rc;\n\treturn !rc;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    INDEX_TYPE first_dimension;\n    OP_REQUIRES_OK(context, GetFirstDimensionSize(context, &first_dimension));\n    vector<INDEX_TYPE> output_size;\n    OP_REQUIRES_OK(context,\n                   CalculateOutputSize(first_dimension, context, &output_size));\n    vector<INDEX_TYPE> multiplier;\n    multiplier.resize(ragged_rank_ + 1);\n    multiplier[multiplier.size() - 1] = 1;\n    for (int i = multiplier.size() - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * output_size[i + 1];\n    }\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context,\n                   TensorShapeUtils::MakeShape(output_size, &output_shape));\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, output_shape, &output_tensor));\n    const INDEX_TYPE full_size = multiplier[0] * output_size[0];\n    if (full_size > 0) {\n      vector<INDEX_TYPE> output_index, new_output_index;\n      int nvals = context->input(kValueInputIndex).shape().dim_size(0);\n      output_index.reserve(nvals);\n      new_output_index.reserve(nvals);\n      CalculateFirstParentOutputIndex(first_dimension, multiplier[0],\n                                      output_size[0], &output_index);\n      for (int i = 1; i <= ragged_rank_; ++i) {\n        OP_REQUIRES_OK(context, CalculateOutputIndex(\n                                    context, i - 1, output_index, multiplier[i],\n                                    output_size[i], &new_output_index));\n        output_index.swap(new_output_index);\n        new_output_index.clear();\n      }\n      SetOutput(context, ragged_rank_, output_index, output_tensor);\n    }\n  }", "target": 1}
{"code": "static struct btrfs_device *btrfs_find_device_by_path(\n\t\tstruct btrfs_fs_info *fs_info, const char *device_path)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh;\n\tstruct btrfs_device *device;\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    fs_info->bdev_holder, 0, &bdev, &bh);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\tif (btrfs_fs_incompat(fs_info, METADATA_UUID))\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->metadata_uuid);\n\telse\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid);\n\tbrelse(bh);\n\tif (!device)\n\t\tdevice = ERR_PTR(-ENOENT);\n\tblkdev_put(bdev, FMODE_READ);\n\treturn device;\n}", "target": 1}
{"code": "fst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct ifreq *ifr)\n{\n\tsync_serial_settings sync;\n\tint i;\n\tswitch (port->hwif) {\n\tcase E1:\n\t\tifr->ifr_settings.type = IF_IFACE_E1;\n\t\tbreak;\n\tcase T1:\n\t\tifr->ifr_settings.type = IF_IFACE_T1;\n\t\tbreak;\n\tcase V35:\n\t\tifr->ifr_settings.type = IF_IFACE_V35;\n\t\tbreak;\n\tcase V24:\n\t\tifr->ifr_settings.type = IF_IFACE_V24;\n\t\tbreak;\n\tcase X21D:\n\t\tifr->ifr_settings.type = IF_IFACE_X21D;\n\t\tbreak;\n\tcase X21:\n\tdefault:\n\t\tifr->ifr_settings.type = IF_IFACE_X21;\n\t\tbreak;\n\t}\n\tif (ifr->ifr_settings.size == 0) {\n\t\treturn 0;\t\n\t}\n\tif (ifr->ifr_settings.size < sizeof (sync)) {\n\t\treturn -ENOMEM;\n \t}\n \ti = port->index;\n \tsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\n \tsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\n\t    INTCLK ? CLOCK_INT : CLOCK_EXT;\n\tsync.loopback = 0;\n\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {\n\t\treturn -EFAULT;\n\t}\n\tifr->ifr_settings.size = sizeof (sync);\n\treturn 0;\n}", "target": 1}
{"code": "static void iowarrior_disconnect(struct usb_interface *interface)\n{\n\tstruct iowarrior *dev;\n\tint minor;\n\tdev = usb_get_intfdata(interface);\n\tmutex_lock(&iowarrior_open_disc_lock);\n\tusb_set_intfdata(interface, NULL);\n\tdev->present = 0;\n\tminor = dev->minor;\n\tmutex_unlock(&iowarrior_open_disc_lock);\n\tusb_deregister_dev(interface, &iowarrior_class);\n\tmutex_lock(&dev->mutex);\n\tmutex_unlock(&dev->mutex);\n\tif (dev->opened) {\n\t\tusb_kill_urb(dev->int_in_urb);\n\t\twake_up_interruptible(&dev->read_wait);\n\t\twake_up_interruptible(&dev->write_wait);\n\t} else {\n\t\tiowarrior_delete(dev);\n\t}\n\tdev_info(&interface->dev, \"I/O-Warror #%d now disconnected\\n\",\n\t\t minor - IOWARRIOR_MINOR_BASE);\n}", "target": 1}
{"code": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"sock=%p\\n\", sock);\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "parse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t\tif (argc > MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}", "target": 1}
{"code": "static int bson_append_estart( bson *b, int type, const char *name, const int dataSize ) {\n    const int len = strlen( name ) + 1;\n    if ( b->finished ) {\n        b->err |= BSON_ALREADY_FINISHED;\n        return BSON_ERROR;\n    }\n    if ( bson_ensure_space( b, 1 + len + dataSize ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n    if( bson_check_field_name( b, ( const char * )name, len - 1 ) == BSON_ERROR ) {\n        bson_builder_error( b );\n        return BSON_ERROR;\n    }\n    bson_append_byte( b, ( char )type );\n    bson_append( b, name, len );\n    return BSON_OK;\n}", "target": 1}
{"code": "mptctl_mpt_command (unsigned long arg)\n{\n\tstruct mpt_ioctl_command __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_command  karg;\n\tMPT_ADAPTER\t*ioc;\n\tint\t\tiocnum;\n\tint\t\trc;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_mpt_command - \"\n\t\t\t\"Unable to read in mpt_ioctl_command struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_mpt_command() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\trc = mptctl_do_mpt_command (karg, &uarg->MF);\n\treturn rc;\n}", "target": 1}
{"code": "static inline Quantum ClampPixel(const MagickRealType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) value);\n#else\n  if (value < 0.0f)\n    return(0.0);\n  if (value >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n  return(value);\n#endif\n}", "target": 1}
{"code": "gimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n  GimpImage           *image;\n  GimpImage           *loaded_image;\n  GimpPlugInProcedure *proc;\n  gchar               *filename;\n  GFile               *file;\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  filename = g_build_filename (g_get_tmp_dir (), \"gimp-test.xcf\", NULL);\n  file = g_file_new_for_path (filename);\n  g_free (filename);\n  proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL );\n  file_save (gimp,\n             image,\n             NULL ,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE ,\n             FALSE ,\n             FALSE ,\n             NULL );\n  loaded_image = gimp_test_load_image (image->gimp, file);\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}", "target": 1}
{"code": "static irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\tif (sunkbd->reset <= -1) {\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tswitch (data) {\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_ALLUP: \n\t\tbreak;\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "id3_skip (SF_PRIVATE * psf)\n{\tunsigned char\tbuf [10] ;\n\tmemset (buf, 0, sizeof (buf)) ;\n\tpsf_binheader_readf (psf, \"pb\", 0, buf, 10) ;\n\tif (buf [0] == 'I' && buf [1] == 'D' && buf [2] == '3')\n\t{\tint\toffset = buf [6] & 0x7f ;\n\t\toffset = (offset << 7) | (buf [7] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [8] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [9] & 0x7f) ;\n\t\tpsf_log_printf (psf, \"ID3 length : %d\\n--------------------\\n\", offset) ;\n\t\tif (offset < 0)\n\t\t\treturn 0 ;\n \t\tpsf->fileoffset += offset + 10 ;\n\t\tpsf_binheader_readf (psf, \"p\", psf->fileoffset) ;\n\t\treturn 1 ;\n \t\t} ;\n \treturn 0 ;\n} ", "target": 1}
{"code": "void *hashtable_get(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n    return pair->value;\n}", "target": 1}
{"code": "int ip_options_get(struct net *net, struct ip_options **optp,\n\t\t   unsigned char *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen)\n\t\tmemcpy(opt->__data, data, optlen);\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}", "target": 1}
{"code": "get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}", "target": 1}
{"code": "static int restrictedFile(const char *filename)\n{\n\tif (!live_dangerously && !strncasecmp(filename, \"/\", 1) &&\n\t\t strncasecmp(filename, ast_config_AST_CONFIG_DIR, strlen(ast_config_AST_CONFIG_DIR))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_reportstat_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "static void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n    pj_scan_get_newline(scanner);\n}", "target": 1}
{"code": "struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)\n{\n\tint err;\n\tstruct nfs_client *clp = nfs_alloc_client(cl_init);\n\tif (IS_ERR(clp))\n\t\treturn clp;\n\terr = nfs_get_cb_ident_idr(clp, cl_init->minorversion);\n\tif (err)\n\t\tgoto error;\n\tif (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\tspin_lock_init(&clp->cl_lock);\n\tINIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);\n\tINIT_LIST_HEAD(&clp->cl_ds_clients);\n\trpc_init_wait_queue(&clp->cl_rpcwaitq, \"NFS client\");\n\tclp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;\n\tclp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];\n\tclp->cl_mig_gen = 1;\n#if IS_ENABLED(CONFIG_NFS_V4_1)\n\tinit_waitqueue_head(&clp->cl_lock_waitq);\n#endif\n\tINIT_LIST_HEAD(&clp->pending_cb_stateids);\n\treturn clp;\nerror:\n\tnfs_free_client(clp);\n\treturn ERR_PTR(err);\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 3>::ConstTensor input,\n                  bool signed_input, int num_bits, bool range_given,\n                  Tensor* input_min_tensor, Tensor* input_max_tensor,\n                  QuantizerRoundMode round_mode, bool narrow_range,\n                  typename TTypes<T, 3>::Tensor out) {\n    QuantizeAndDequantizePerChannelImpl<CPUDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }", "target": 1}
{"code": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\tpn = ppp_pernet(net);\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = net;\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif \n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\treturn 0;\n}", "target": 1}
{"code": "bool FontData::Bound(int32_t offset, int32_t length) {\n  if (offset + length > Size() || offset < 0 || length < 0)\n    return false;\n  bound_offset_ += offset;\n  bound_length_ = length;\n  return true;\n}", "target": 1}
{"code": "utf8_str (const gchar *utf8,\n          gchar       *buf)\n{\n  char_str (g_utf8_get_char (utf8), buf);\n  return buf;\n}", "target": 1}
{"code": "setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}", "target": 1}
{"code": "AP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tstruct dev_pagemap *pgmap = NULL;\n\tint nr_start = *nr, ret = 0;\n\tpte_t *ptep, *ptem;\n\tptem = ptep = pte_offset_map(&pmd, addr);\n\tdo {\n\t\tpte_t pte = gup_get_pte(ptep);\n\t\tstruct page *head, *page;\n\t\tif (pte_protnone(pte))\n\t\t\tgoto pte_unmap;\n\t\tif (!pte_access_permitted(pte, write))\n\t\t\tgoto pte_unmap;\n\t\tif (pte_devmap(pte)) {\n\t\t\tpgmap = get_dev_pagemap(pte_pfn(pte), pgmap);\n\t\t\tif (unlikely(!pgmap)) {\n\t\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\t\tgoto pte_unmap;\n\t\t\t}\n\t\t} else if (pte_special(pte))\n\t\t\tgoto pte_unmap;\n\t\tVM_BUG_ON(!pfn_valid(pte_pfn(pte)));\n\t\tpage = pte_page(pte);\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto pte_unmap;\n\t\tif (unlikely(pte_val(pte) != pte_val(*ptep))) {\n\t\t\tput_page(head);\n\t\t\tgoto pte_unmap;\n\t\t}\n\t\tVM_BUG_ON_PAGE(compound_head(page) != head, page);\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t} while (ptep++, addr += PAGE_SIZE, addr != end);\n\tret = 1;\npte_unmap:\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\tpte_unmap(ptem);\n\treturn ret;\n}", "target": 1}
{"code": "static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n    return OPJ_FALSE;\n}", "target": 1}
{"code": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\t\tcatcount++;\n\t}\n\tif (!ast_strlen_zero(category) && catcount == 0) { \n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg,\n                                          char *buffer) {\n  uint16_t offset = 4 + (5 * 32);\n  int16_t len = msg->data_length - offset;\n  if (msg->has_data_length && len > 0) {\n    memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);\n    return len < 256 ? (uint8_t)len : 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t\n\t\t\treturn -EINVAL;\n \t\tnew_data = memdup_user(tlv, size);\n \t\tif (IS_ERR(new_data))\n \t\t\treturn PTR_ERR(new_data);\n \t\tchange = ue->tlv_data_size != size;\n \t\tif (!change)\n \t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n \t\tkfree(ue->tlv_data);\n \t\tue->tlv_data = new_data;\n \t\tue->tlv_data_size = size;\n \t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n \t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n \t}\n \treturn change;\n }", "target": 1}
{"code": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off;\n    init_get_bits(&gb, buf, size * 8);\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n        put_bits(&pb, 3, 5); \n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n    adts->write_adts = 1;\n    return 0;\n}", "target": 1}
{"code": "cib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type)\n{\n    int rc = pcmk_ok;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    if (private->passwd == NULL) {\n        struct termios settings;\n        int rc;\n        rc = tcgetattr(0, &settings);\n        settings.c_lflag &= ~ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n        fprintf(stderr, \"Password: \");\n        private->passwd = calloc(1, 1024);\n        rc = scanf(\"%s\", private->passwd);\n        fprintf(stdout, \"\\n\");\n        if (rc < 1) {\n            private->passwd = NULL;\n        }\n        settings.c_lflag |= ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n    }\n    if (private->server == NULL || private->user == NULL) {\n        rc = -EINVAL;\n    }\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->command));\n    }\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->callback));\n    }\n    if (rc == pcmk_ok) {\n        xmlNode *hello =\n            cib_create_op(0, private->callback.token, CRM_OP_REGISTER, NULL, NULL, NULL, 0, NULL);\n        crm_xml_add(hello, F_CIB_CLIENTNAME, name);\n        crm_send_remote_msg(private->command.session, hello, private->command.encrypted);\n        free_xml(hello);\n    }\n    if (rc == pcmk_ok) {\n        fprintf(stderr, \"%s: Opened connection to %s:%d\\n\", name, private->server, private->port);\n        cib->state = cib_connected_command;\n        cib->type = cib_command;\n    } else {\n        fprintf(stderr, \"%s: Connection to %s:%d failed: %s\\n\",\n                name, private->server, private->port, pcmk_strerror(rc));\n    }\n    return rc;\n}", "target": 1}
{"code": "PHPAPI zend_string *php_escape_shell_cmd(char *str)\n{\n\tregister int x, y, l = (int)strlen(str);\n\tsize_t estimate = (2 * l) + 1;\n\tzend_string *cmd;\n#ifndef PHP_WIN32\n\tchar *p = NULL;\n#endif\n\tcmd = zend_string_alloc(2 * l, 0);\n\tfor (x = 0, y = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (str[x]) {\n#ifndef PHP_WIN32\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n\t\t\t\tif (!p && (p = memchr(str + x + 1, str[x], l - x - 1))) {\n\t\t\t\t} else if (p && *p == str[x]) {\n\t\t\t\t\tp = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\t\t}\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t\t\tbreak;\n#else\n\t\t\tcase '%':\n\t\t\tcase '!':\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n#endif\n\t\t\tcase '#': \n\t\t\tcase '&':\n\t\t\tcase ';':\n\t\t\tcase '`':\n\t\t\tcase '|':\n\t\t\tcase '*':\n\t\t\tcase '?':\n\t\t\tcase '~':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase '^':\n\t\t\tcase '(':\n\t\t\tcase ')':\n\t\t\tcase '[':\n\t\t\tcase ']':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '$':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\x0A': \n\t\t\tcase '\\xFF':\n#ifdef PHP_WIN32\n\t\t\t\tZSTR_VAL(cmd)[y++] = '^';\n#else\n\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n#endif\n\t\t\tdefault:\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y] = '\\0';\n\tif ((estimate - y) > 4096) {\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\tZSTR_LEN(cmd) = y;\n\treturn cmd;\n}", "target": 1}
{"code": "HandleCoRREBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n    rfbRREHeader hdr;\n    int i;\n    CARDBPP pix;\n    uint8_t *ptr;\n    int x, y, w, h;\n    if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader))\n\treturn FALSE;\n    hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);\n    if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))\n\treturn FALSE;\n    client->GotFillRect(client, rx, ry, rw, rh, pix);\n    if (hdr.nSubrects * (4 + (BPP / 8)) > RFB_BUFFER_SIZE || !ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8))))\n\treturn FALSE;\n    ptr = (uint8_t *)client->buffer;\n    for (i = 0; i < hdr.nSubrects; i++) {\n\tpix = *(CARDBPP *)ptr;\n\tptr += BPP/8;\n\tx = *ptr++;\n\ty = *ptr++;\n\tw = *ptr++;\n\th = *ptr++;\n\tclient->GotFillRect(client, rx+x, ry+y, w, h, pix);\n    }\n    return TRUE;\n}", "target": 1}
{"code": "int nego_recv(rdpTransport* transport, wStream* s, void* extra)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\trdpNego* nego = (rdpNego*)extra;\n\tif (!tpkt_read_header(s, &length))\n\t\treturn -1;\n\tif (!tpdu_read_connection_confirm(s, &li, length))\n\t\treturn -1;\n\tif (li > 6)\n\t{\n\t\tStream_Read_UINT8(s, type); \n\t\tswitch (type)\n\t\t{\n\t\t\tcase TYPE_RDP_NEG_RSP:\n\t\t\t\tnego_process_negotiation_response(nego, s);\n\t\t\t\tWLog_DBG(TAG, \"selected_protocol: %\" PRIu32 \"\", nego->SelectedProtocol);\n\t\t\t\tif (nego->SelectedProtocol)\n\t\t\t\t{\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_HYBRID) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_HYBRID]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_SSL) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_SSL]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\t\t{\n\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_RDP_NEG_FAILURE:\n\t\t\t\tnego_process_negotiation_failure(nego, s);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (li == 6)\n\t{\n\t\tWLog_DBG(TAG, \"no rdpNegData\");\n\t\tif (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FINAL;\n\t}\n\telse\n\t{\n\t\tWLog_ERR(TAG, \"invalid negotiation response\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\t\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n\t\tif (iRight - iLeft + 1 > windows_size)  {\n\t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n\t\t\t}\n\t\t}\n\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n\t\t}\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "blockmix_salsa8(uint32_t * Bin, uint32_t * Bout, uint32_t * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[(2 * r - 1) * 16], 64);\n  for (i = 0; i < 2 * r; i += 2) {\n    blkxor(X, &Bin[i * 16], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 8], X, 64);\n    blkxor(X, &Bin[i * 16 + 16], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 8 + r * 16], X, 64);\n  }\n}", "target": 1}
{"code": "aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\tif (bytesread < dword)\n \t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n \tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n \t\tfree (psf->channel_map) ;\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\treturn 0 ;\n} ", "target": 1}
{"code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\tif (!update || !s)\n\t\treturn NULL;\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       \n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\tStream_Seek_UINT8(s);                      \n\tStream_Seek_UINT8(s);                      \n\tStream_Read_UINT8(s, bitmapData->codecID); \n\tStream_Read_UINT16(s, bitmapData->width);  \n\tStream_Read_UINT16(s, bitmapData->height); \n\tStream_Read_UINT32(s, new_len);            \n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\tif (!new_data)\n\t\tgoto fail;\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}", "target": 1}
{"code": "int sas_discover_sata(struct domain_device *dev)\n{\n\tint res;\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\treturn -ENODEV;\n\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\tsas_fill_in_rphy(dev, dev->rphy);\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n \tif (!addr)\n \t\treturn -ENODEV;\n\tio->io_cleanup = mem_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n \treturn 0;\n }", "target": 1}
{"code": "urlCheckRequest(const HttpRequest * r)\n{\n    if (r->method == Http::METHOD_CONNECT)\n        return true;\n    if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)\n        return (r->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0 || r->url.path() != AnyP::Uri::Asterisk());\n    if (r->method == Http::METHOD_PURGE)\n        return true;\n    switch (r->url.getScheme()) {\n    case AnyP::PROTO_URN:\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_CACHE_OBJECT:\n        return true;\n    case AnyP::PROTO_FTP:\n        if (r->method == Http::METHOD_PUT ||\n                r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD )\n            return true;\n        return false;\n    case AnyP::PROTO_GOPHER:\n    case AnyP::PROTO_WAIS:\n    case AnyP::PROTO_WHOIS:\n        if (r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD)\n            return true;\n        return false;\n    case AnyP::PROTO_HTTPS:\n#if USE_OPENSSL || USE_GNUTLS\n        return true;\n#else\n        return false;\n#endif\n    default:\n        return false;\n    }\n    return false;\n}", "target": 1}
{"code": "status_t ESDS::parseESDescriptor(size_t offset, size_t size) {\n if (size < 3) {\n return ERROR_MALFORMED;\n }\n    offset += 2; \n    size -= 2;\n unsigned streamDependenceFlag = mData[offset] & 0x80;\n unsigned URL_Flag = mData[offset] & 0x40;\n unsigned OCRstreamFlag = mData[offset] & 0x20;\n ++offset;\n     --size;\n     if (streamDependenceFlag) {\n         offset += 2;\n         size -= 2;\n     }\n if (URL_Flag) {\n if (offset >= size) {\n             return ERROR_MALFORMED;\n         }\n         unsigned URLlength = mData[offset];\n         offset += URLlength + 1;\n         size -= URLlength + 1;\n     }\n     if (OCRstreamFlag) {\n         offset += 2;\n         size -= 2;\n if ((offset >= size || mData[offset] != kTag_DecoderConfigDescriptor)\n && offset - 2 < size\n && mData[offset - 2] == kTag_DecoderConfigDescriptor) {\n            offset -= 2;\n            size += 2;\n            ALOGW(\"Found malformed 'esds' atom, ignoring missing OCR_ES_Id.\");\n }\n }\n if (offset >= size) {\n return ERROR_MALFORMED;\n }\n uint8_t tag;\n size_t sub_offset, sub_size;\n status_t err = skipDescriptorHeader(\n            offset, size, &tag, &sub_offset, &sub_size);\n if (err != OK) {\n return err;\n }\n if (tag != kTag_DecoderConfigDescriptor) {\n return ERROR_MALFORMED;\n }\n    err = parseDecoderConfigDescriptor(sub_offset, sub_size);\n return err;\n}", "target": 1}
{"code": "header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "NOEXPORT int dh_init(SERVICE_OPTIONS *section) {\n    DH *dh=NULL;\n    int i, n;\n    char description[128];\n    STACK_OF(SSL_CIPHER) *ciphers;\n    section->option.dh_temp_params=0; \n    ciphers=SSL_CTX_get_ciphers(section->ctx);\n    if(!ciphers)\n        return 1; \n    n=sk_SSL_CIPHER_num(ciphers);\n    for(i=0; i<n; ++i) {\n        *description='\\0';\n        SSL_CIPHER_description(sk_SSL_CIPHER_value(ciphers, i),\n            description, sizeof description);\n        if(strstr(description, \" Kx=DH\")) {\n            s_log(LOG_INFO, \"DH initialization needed for %s\",\n                SSL_CIPHER_get_name(sk_SSL_CIPHER_value(ciphers, i)));\n            break;\n        }\n    }\n    if(i==n) { \n        s_log(LOG_INFO, \"DH initialization not needed\");\n        return 0; \n    }\n    s_log(LOG_DEBUG, \"DH initialization\");\n#ifndef OPENSSL_NO_ENGINE\n    if(!section->engine) \n#endif\n        dh=dh_read(section->cert);\n    if(dh) {\n        SSL_CTX_set_tmp_dh(section->ctx, dh);\n        s_log(LOG_INFO, \"%d-bit DH parameters loaded\", 8*DH_size(dh));\n        DH_free(dh);\n        return 0; \n    }\n    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_DH]);\n    SSL_CTX_set_tmp_dh(section->ctx, dh_params);\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_DH]);\n    dh_temp_params=1; \n    section->option.dh_temp_params=1; \n    s_log(LOG_INFO, \"Using dynamic DH parameters\");\n    return 0; \n}", "target": 1}
{"code": "decode_bytestring(CBORDecoderObject *self, uint8_t subtype)\n{\n    uint64_t length = 0;\n    bool indefinite = true;\n    PyObject *ret;\n    char length_hex[17];\n    if (decode_length(self, subtype, &length, &indefinite) == -1)\n        return NULL;\n    if (length > (uint64_t)PY_SSIZE_T_MAX - (uint64_t)PyBytesObject_SIZE) {\n        sprintf(length_hex, \"%llX\", length);\n        PyErr_Format(\n                _CBOR2_CBORDecodeValueError,\n                \"excessive bytestring size 0x%s\", length_hex);\n        return NULL;\n    }\n    if (indefinite)\n        ret = decode_indefinite_bytestrings(self);\n    else\n        ret = decode_definite_bytestring(self, (Py_ssize_t)length);\n    set_shareable(self, ret);\n    return ret;\n}", "target": 1}
{"code": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n {\n     struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n     state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n         (state->mode == COPY ? state->length :\n             (state->mode == MATCH ? state->was - state->length : 0));\n }", "target": 1}
{"code": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n    clear(); \n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n    return response();\n}", "target": 1}
{"code": "static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tunsigned int *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\tif(value_count!=1) return 0;\n\tif(field_type==3) { \n\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\telse if(field_type==4) { \n\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n\t\t\t\t struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t\t struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_tsk_mgmt *srp_tsk;\n\tstruct se_cmd *cmd;\n\tstruct se_session *sess = ch->sess;\n\tuint64_t unpacked_lun;\n\tuint32_t tag = 0;\n\tint tcm_tmr;\n\tint rc;\n\tBUG_ON(!send_ioctx);\n\tsrp_tsk = recv_ioctx->ioctx.buf;\n\tcmd = &send_ioctx->cmd;\n\tpr_debug(\"recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld\"\n\t\t \" cm_id %p sess %p\\n\", srp_tsk->tsk_mgmt_func,\n\t\t srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);\n\tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n\tsend_ioctx->cmd.tag = srp_tsk->tag;\n\ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n\tif (tcm_tmr < 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n\t\tgoto fail;\n\t}\n\tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n\t\t\t\t       sizeof(srp_tsk->lun));\n\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n\t\tif (rc < 0) {\n\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n\t\t\tgoto fail;\n\t\t}\n\t\ttag = srp_tsk->task_tag;\n\t}\n\trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n\t\t\t\tTARGET_SCF_ACK_KREF);\n\tif (rc != 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\tgoto fail;\n\t}\n\treturn;\nfail:\n\ttransport_send_check_condition_and_sense(cmd, 0, 0); \n}", "target": 1}
{"code": "AnyP::UriScheme::defaultPort() const\n{\n    switch (theScheme_) {\n    case AnyP::PROTO_HTTP:\n        return 80;\n    case AnyP::PROTO_HTTPS:\n        return 443;\n    case AnyP::PROTO_FTP:\n        return 21;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS:\n        return 5683;\n    case AnyP::PROTO_GOPHER:\n        return 70;\n    case AnyP::PROTO_WAIS:\n        return 210;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return CACHE_HTTP_PORT;\n    case AnyP::PROTO_WHOIS:\n        return 43;\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "static bool ntlmssp_check_buffer(const struct ntlmssp_buffer *buffer,\n\t\t\t\t size_t data_size, const char **error)\n{\n\tuint32_t offset = read_le32(&buffer->offset);\n\tuint16_t length = read_le16(&buffer->length);\n\tuint16_t space = read_le16(&buffer->space);\n\tif (length == 0 && space == 0)\n\t\treturn TRUE;\n\tif (offset >= data_size) {\n\t\t*error = \"buffer offset out of bounds\";\n\t\treturn FALSE;\n\t}\n\tif (offset + space > data_size) {\n\t\t*error = \"buffer end out of bounds\";\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {\n size_t oldSize = mSize;\n size_t offset = 0;\n while (mSize >= 10 && offset <= mSize - 10) {\n if (!memcmp(&mData[offset], \"\\0\\0\\0\\0\", 4)) {\n break;\n }\n size_t dataSize;\n if (iTunesHack) {\n            dataSize = U32_AT(&mData[offset + 4]);\n } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {\n return false;\n }\n if (dataSize > mSize - 10 - offset) {\n return false;\n }\n uint16_t flags = U16_AT(&mData[offset + 8]);\n uint16_t prevFlags = flags;\n if (flags & 1) {\n if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {\n return false;\n }\n            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);\n            mSize -= 4;\n            dataSize -= 4;\n            flags &= ~1;\n }\n if ((flags & 2) && (dataSize >= 2)) {\n size_t readOffset = offset + 11;\n size_t writeOffset = offset + 11;\n for (size_t i = 0; i + 1 < dataSize; ++i) {\n if (mData[readOffset - 1] == 0xff\n && mData[readOffset] == 0x00) {\n ++readOffset;\n                     --mSize;\n                     --dataSize;\n                 }\n                mData[writeOffset++] = mData[readOffset++];\n             }\n             if (readOffset <= oldSize) {\n                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);\n } else {\n                ALOGE(\"b/34618607 (%zu %zu %zu %zu)\", readOffset, writeOffset, oldSize, mSize);\n                android_errorWriteLog(0x534e4554, \"34618607\");\n }\n }\n        flags &= ~2;\n if (flags != prevFlags || iTunesHack) {\n WriteSyncsafeInteger(&mData[offset + 4], dataSize);\n            mData[offset + 8] = flags >> 8;\n            mData[offset + 9] = flags & 0xff;\n }\n        offset += 10 + dataSize;\n }\n    memset(&mData[mSize], 0, oldSize - mSize);\n return true;\n}", "target": 1}
{"code": "static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n                          Error **errp)\n{\n    BDRVParallelsState *s = bs->opaque;\n    int i;\n    struct parallels_header ph;\n    int ret;\n    bs->read_only = 1; \n    ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));\n    if (ret < 0) {\n        goto fail;\n    }\n    if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n        (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n        error_setg(errp, \"Image not in Parallels format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n    bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n    s->tracks = le32_to_cpu(ph.tracks);\n    s->catalog_size = le32_to_cpu(ph.catalog_entries);\n    if (s->catalog_size > INT_MAX / 4) {\n        error_setg(errp, \"Catalog too large\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n    ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    }\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\n}", "target": 1}
{"code": "pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,\n\t\t      int atomic)\n{\n\tunsigned long copy;\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\t\tif (atomic) {\n\t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tfrom += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n \tif (mode->indent_level < MAX_INDENT_LEVEL)\n \t    tbl->indent -= INDENT_INCR;\n     }\n     offset = tbl->indent;\n     if (cmd == HTML_DT) {\n \tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n \t    offset -= INDENT_INCR;\n     }\n     if (tbl->indent > 0) {\n \tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}", "target": 1}
{"code": "void Filter::onUpstreamEvent(Network::ConnectionEvent event) {\n  bool connecting = connecting_;\n  connecting_ = false;\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    upstream_.reset();\n    disableIdleTimer();\n    if (connecting) {\n      if (event == Network::ConnectionEvent::RemoteClose) {\n        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);\n        read_callbacks_->upstreamHost()->outlierDetector().putResult(\n            Upstream::Outlier::Result::LocalOriginConnectFailed);\n      }\n      initializeUpstreamConnection();\n    } else {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {\n        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);\n      }\n    }\n  }\n}", "target": 1}
{"code": "regional_create_custom(size_t size)\n{\n\tstruct regional* r = (struct regional*)malloc(size);\n\tlog_assert(sizeof(struct regional) <= size);\n\tif(!r) return NULL;\n\tr->first_size = size;\n\tregional_init(r);\n\treturn r;\n}", "target": 1}
{"code": "static Status ValidateSavedTensors(const GraphDef& graph_def) {\n  for (const auto& node : graph_def.node()) {\n    const auto node_iterator = node.attr().find(\"value\");\n    if (node_iterator != node.attr().end()) {\n      AttrValue node_value = node_iterator->second;\n      if (node_value.has_tensor()) {\n        const PartialTensorShape node_shape(node_value.tensor().tensor_shape());\n        if (node_shape.num_elements() < 0) {\n          return errors::FailedPrecondition(\n              \"Saved model contains node \\\"\", node.name(), \"\\\" (op \\\"\",\n              node.op(), \"\\\") which initializes from a tensor with \",\n              node_shape.num_elements(), \" elements\");\n        }\n      }\n    } else if (node.op() == \"Const\") {\n      return errors::FailedPrecondition(\n          \"Saved model contains node \\\"\", node.name(),\n          \"\\\" which is a constant tensor but no value has been provided\");\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static int EscChar(const char *src, char *dst, int dstlen, const char *specchars, char escchar)\n{\n   const char *p;\n   char *q, *end = dst+dstlen-1;\n   for (p = src, q = dst; *p && q < end; ) {\n      if (strchr(specchars, *p)) {\n         *q++ = escchar;\n         if (q < end)\n            *q++ = *p++;\n      } else\n         *q++ = *p++;\n   }\n   *q = '\\0';\n   if (*p != 0)\n      return -1;\n   return q-dst;\n}", "target": 1}
{"code": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n \tint ret;\n \twhile (ptr) {\n\t\tret = copy_to_user(param, ptr, sizeof(*ptr));\n \t\tif (ret)\n \t\t\treturn -EFAULT;\n \t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n\t     void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tconst EVP_MD *type;\n        unsigned char *buf_in=NULL;\n        int ret= -1,i,inl;\n        EVP_MD_CTX_init(&ctx);\n        i=OBJ_obj2nid(a->algorithm);\n        type=EVP_get_digestbyname(OBJ_nid2sn(i));\n\tif (!EVP_VerifyInit_ex(&ctx,type, NULL))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\tif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\n\t\t\t(unsigned int)signature->length,pkey) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}", "target": 1}
{"code": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\tif (cpuhw->n_limited)\n\t\tfreeze_limited_counters(cpuhw, mfspr(SPRN_PMC5),\n\t\t\t\t\tmfspr(SPRN_PMC6));\n\tperf_read_regs(regs);\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\tfor (i = 0; i < cpuhw->n_events; ++i) {\n\t\tevent = cpuhw->event[i];\n\t\tif (!event->hw.idx || is_limited_pmc(event->hw.idx))\n\t\t\tcontinue;\n\t\tval = read_pmc(event->hw.idx);\n\t\tif ((int)val < 0) {\n\t\t\tfound = 1;\n\t\t\trecord_and_restart(event, val, regs, nmi);\n\t\t}\n\t}\n\tif (!found) {\n\t\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\t\tif (is_limited_pmc(i + 1))\n\t\t\t\tcontinue;\n\t\t\tval = read_pmc(i + 1);\n\t\t\tif ((int)val < 0)\n\t\t\t\twrite_pmc(i + 1, 0);\n\t\t}\n\t}\n\twrite_mmcr0(cpuhw, cpuhw->mmcr[0]);\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}", "target": 1}
{"code": "char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n{\n\tchar         *d   = NULL;\n\tchar         *out = NULL;\n\tM_fs_error_t  res;\n#ifdef _WIN32\n\tsize_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;\n\td = M_malloc_zero(len);\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/var/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n#endif\n\tif (d != NULL) {\n\t\tres = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tout = NULL;\n\t\t}\n\t}\n\tM_free(d);\n\treturn out;\n}", "target": 1}
{"code": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tif (!dst)\n\t\tgoto out;\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\nout:\n\treturn dst;\n}", "target": 1}
{"code": " std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name) {\n   assert(!command_line.empty());\n   assert(!switch_name.empty());\n   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);\n   std::wstring switch_with_equal = L\"--\" + switch_name + L\"=\";\n  for (size_t i = 1; i < as_array.size(); ++i) {\n    const std::wstring& arg = as_array[i];\n     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)\n       return arg.substr(switch_with_equal.size());\n   }\n  return std::wstring();\n}", "target": 1}
{"code": "UNCURL_EXPORT int32_t uncurl_ws_accept(struct uncurl_conn *ucc, char **origins, int32_t n_origins)\n{\n\tint32_t e;\n\te = uncurl_read_header(ucc);\n\tif (e != UNCURL_OK) return e;\n\tuncurl_set_header_str(ucc, \"Upgrade\", \"websocket\");\n\tuncurl_set_header_str(ucc, \"Connection\", \"Upgrade\");\n\tchar *origin = NULL;\n \te = uncurl_get_header_str(ucc, \"Origin\", &origin);\n \tif (e != UNCURL_OK) return e;\n \tbool origin_ok = false;\n\tfor (int32_t x = 0; x < n_origins; x++)\n\t\tif (strstr(origin, origins[x])) {origin_ok = true; break;}\n \tif (!origin_ok) return UNCURL_WS_ERR_ORIGIN;\n\tchar *sec_key = NULL;\n\te = uncurl_get_header_str(ucc, \"Sec-WebSocket-Key\", &sec_key);\n\tif (e != UNCURL_OK) return e;\n\tchar *accept_key = ws_create_accept_key(sec_key);\n\tuncurl_set_header_str(ucc, \"Sec-WebSocket-Accept\", accept_key);\n\tfree(accept_key);\n\te = uncurl_write_header(ucc, \"101\", \"Switching Protocols\", UNCURL_RESPONSE);\n\tif (e != UNCURL_OK) return e;\n\tucc->ws_mask = 0;\n\treturn UNCURL_OK;\n}", "target": 1}
{"code": "static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;\n\tint ret;\n \tif (!is_irq_none(vdev))\n \t\treturn -EINVAL;\n\tvdev->ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);\n \tif (!vdev->ctx)\n \t\treturn -ENOMEM;\n\tret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);\n\tif (ret < nvec) {\n\t\tif (ret > 0)\n\t\t\tpci_free_irq_vectors(pdev);\n\t\tkfree(vdev->ctx);\n\t\treturn ret;\n\t}\n\tvdev->num_ctx = nvec;\n\tvdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :\n\t\t\t\tVFIO_PCI_MSI_IRQ_INDEX;\n\tif (!msix) {\n\t\tvdev->msi_qmax = fls(nvec * 2 - 1) - 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       union cpu_time_count cpu,\n\t\t\t       struct timespec *tp)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ttp->tv_sec = div_long_long_rem(cpu.sched,\n\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);\n\t} else {\n\t\tcputime_to_timespec(cpu.cpu, tp);\n\t}\n}", "target": 1}
{"code": "int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tint len;\n\tchar *data;\n\tconst char *name = gfs2_acl_name(type);\n\tif (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))\n\t\treturn -E2BIG;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t\tif (mode != inode->i_mode) {\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\tif (acl) {\n\t\tlen = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tdata = kmalloc(len, GFP_NOFS);\n\t\tif (data == NULL)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, data, len);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\terror = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);\n\tif (error)\n\t\tgoto out;\n\tset_cached_acl(inode, type, acl);\nout:\n\tkfree(data);\n\treturn error;\n}", "target": 1}
{"code": "static void DetectFlow(ThreadVars *tv,\n                        DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\n                        Packet *p)\n {\n    if ((p->flags & PKT_NOPACKET_INSPECTION) ||\n        (PACKET_TEST_ACTION(p, ACTION_DROP)))\n    {\n        const int pass = ((p->flow->flags & FLOW_NOPACKET_INSPECTION));\n        const AppProto alproto = FlowGetAppProtocol(p->flow);\n        if (pass && AppLayerParserProtocolSupportsTxs(p->proto, alproto)) {\n            uint8_t flags;\n            if (p->flowflags & FLOW_PKT_TOSERVER) {\n                flags = STREAM_TOSERVER;\n            } else {\n                flags = STREAM_TOCLIENT;\n            }\n             flags = FlowGetDisruptionFlags(p->flow, flags);\n             DeStateUpdateInspectTransactionId(p->flow, flags, true);\n         }\n         return;\n     }\n    (void)DetectRun(tv, de_ctx, det_ctx, p);\n}", "target": 1}
{"code": "static MagickBooleanType DrawStrokePolygon(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n  MagickBooleanType\n    closed_path;\n  MagickStatusType\n    status;\n  PrimitiveInfo\n    *stroke_polygon;\n  register const PrimitiveInfo\n    *p,\n    *q;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    begin draw-stroke-polygon\");\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->fill=draw_info->stroke;\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,\n      MagickTrue,exception);\n  clone_info->stroke.alpha=(Quantum) TransparentAlpha;\n  clone_info->stroke_width=0.0;\n  clone_info->fill_rule=NonZeroRule;\n  status=MagickTrue;\n  for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)\n  {\n    stroke_polygon=TraceStrokePolygon(draw_info,p);\n    status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon,exception);\n    if (status == 0)\n      break;\n    stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);\n    q=p+p->coordinates-1;\n    closed_path=(q->point.x == p->point.x) && (q->point.y == p->point.y) ?\n      MagickTrue : MagickFalse;\n    if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))\n      {\n        DrawRoundLinecap(image,draw_info,p,exception);\n        DrawRoundLinecap(image,draw_info,q,exception);\n      }\n  }\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    end draw-stroke-polygon\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 1}
{"code": "static void Process_ipfix_template_withdraw(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\nipfix_template_record_t *ipfix_template_record;\n \twhile ( size_left ) {\n \t\tuint32_t id;\n \t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n \t\tsize_left \t\t-= 4;\n\t\tid \t  = ntohs(ipfix_template_record->TemplateID);\n\t\tif ( id == IPFIX_TEMPLATE_FLOWSET_ID ) {\n\t\t\tremove_all_translation_tables(exporter);\n\t\t\tReInitExtensionMapList(fs);\n\t\t} else {\n\t\t\tremove_translation_table(fs, exporter, id);\n\t\t}\n\t\tDataPtr = DataPtr + 4;\n\t\tif ( size_left < 4 ) {\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t}\n} ", "target": 1}
{"code": "        int          Read(void* pDestBuffer, int nSize)\n        {\n            if ( m_nPos + nSize >= m_nLen )\n                nSize = m_nLen - m_nPos - 1;\n            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );\n            m_nPos += nSize;\n            return nSize;\n        }", "target": 1}
{"code": "int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == '%')\n                ptr++;\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n            else {\n                if (*ptr == ' ')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 3);\n}", "target": 1}
{"code": "static int _nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred, struct nfs4_state **res)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tint status;\n\tstatus = -ENOMEM;\n\tif (!(sp = nfs4_get_state_owner(server, cred))) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_recover_expired_lease(server);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (path->dentry->d_inode != NULL)\n\t\tnfs4_return_incompatible_delegation(path->dentry->d_inode, flags & (FMODE_READ|FMODE_WRITE));\n\tstatus = -ENOMEM;\n\topendata = nfs4_opendata_alloc(path, sp, flags, sattr);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\tif (path->dentry->d_inode != NULL)\n\t\topendata->state = nfs4_get_open_state(path->dentry->d_inode, sp);\n\tstatus = _nfs4_proc_open(opendata);\n\tif (status != 0)\n\t\tgoto err_opendata_put;\n\tif (opendata->o_arg.open_flags & O_EXCL)\n\t\tnfs4_exclusive_attrset(opendata, sattr);\n\tstate = nfs4_opendata_to_nfs4_state(opendata);\n\tstatus = PTR_ERR(state);\n\tif (IS_ERR(state))\n\t\tgoto err_opendata_put;\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\t*res = state;\n\treturn 0;\nerr_opendata_put:\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\t*res = NULL;\n\treturn status;\n}", "target": 1}
{"code": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu64 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\tseq = half_md4_transform(hash, keyptr->secret);\n\tseq |= ((u64)keyptr->count) << (32 - HASH_BITS);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 1}
{"code": "bool MemoryManager::validate_user_read(const Process& process, VirtualAddress vaddr) const\n{\n    auto* region = region_from_vaddr(process, vaddr);\n    return region && region->is_readable();\n}", "target": 1}
{"code": " struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) \n\t\t\tnum = p->addr.port + 1;\n\t}\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n \treturn new_port;\n }", "target": 1}
{"code": " void buffer_slow_realign(struct buffer *buf)\n {\n       if (buf->i) {\n               int block1 = buf->i;\n               int block2 = 0;\n               if (buf->p + buf->i > buf->data + buf->size) {\n                       block1 = buf->data + buf->size - buf->p;\n                       block2 = buf->p + buf->i - (buf->data + buf->size);\n               }\n               if (block2)\n                       memcpy(swap_buffer, buf->data, block2);\n               memmove(buf->data, buf->p, block1);\n               if (block2)\n                       memcpy(buf->data + block1, swap_buffer, block2);\n        }\n        buf->p = buf->data;\n }", "target": 1}
{"code": "LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n    if (type != EXPR_TYPE_INT)\n         return false;\n     str = xkb_atom_text(ctx, field);\n     if (istreq(str, \"all\")) {\n         *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n    *val_rtrn = (1u << ndx);\n    return true;\n}", "target": 1}
{"code": "gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\tint y;\n\tif (crop->width<=0 || crop->height<=0) {\n\t\treturn NULL;\n\t}\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t\tgdImagePaletteCopy(dst, src);\n\t}\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->transparent = src->transparent;\n\tif (crop->x < 0 || crop->x>=src->sx || crop->y<0 || crop->y>=src->sy) {\n\t\treturn dst;\n\t}\n\tif ((src->sx - crop->width) < crop->x) {\n\t\tcrop->width = src->sx - crop->x;\n\t}\n\tif ((src->sy - crop->height) < crop->y) {\n\t\tcrop->height = src->sy - crop->y;\n\t}\n#if 0\nprintf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n#endif\n\ty = crop->y;\n\tif (src->trueColor) {\n\t\tunsigned int dst_y = 0;\n\t\twhile (y < (crop->y + (crop->height - 1))) {\n\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n\t\t}\n\t} else {\n\t\tint x;\n\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n\t\t\t}\n\t\t}\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}", "target": 1}
{"code": "void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)\n{\n    Q_UNUSED(bufferInfo);\n    if (!msg.contains(' '))\n        return;\n    QString target = msg.section(' ', 0, 0);\n    QByteArray encMsg = userEncode(target, msg.section(' ', 1));\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));\n#else\n    putPrivmsg(serverEncode(target), encMsg);\n#endif\n}", "target": 1}
{"code": "static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tiput(io->inode);\n\tkfree(io);\n}", "target": 1}
{"code": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\treturn &new_mnt->mnt;\n}", "target": 1}
{"code": "Client::connect()\n{\n    if (m_stream != NULL) {\n        return;\n    }\n    if (m_suspended) {\n        m_connectOnResume = true;\n        return;\n    }\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (m_useSecureNetwork) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n    }\n    try {\n        m_serverAddress.resolve();\n        if (m_serverAddress.getAddress() != NULL) {\n          LOG((CLOG_NOTE \"connecting to '%s': %s:%i\",\n          m_serverAddress.getHostname().c_str(),\n          ARCH->addrToString(m_serverAddress.getAddress()).c_str(),\n          m_serverAddress.getPort()));\n        }\n        IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()),\n                                                      security_level);\n        m_socket = dynamic_cast<TCPSocket*>(socket);\n        m_stream = socket;\n        m_stream = new PacketStreamFilter(m_events, m_stream, true);\n        LOG((CLOG_DEBUG1 \"connecting to server\"));\n        setupConnecting();\n        setupTimer();\n        socket->connect(m_serverAddress);\n    }\n    catch (XBase& e) {\n        cleanupTimer();\n        cleanupConnecting();\n        cleanupStream();\n        LOG((CLOG_DEBUG1 \"connection failed\"));\n        sendConnectionFailedEvent(e.what());\n        return;\n    }\n}", "target": 1}
{"code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n \tmm_init_cpumask(mm);\n \tmm_init_aio(mm);\n \tmm_init_owner(mm, p);\n \tmmu_notifier_mm_init(mm);\n \tinit_tlb_flush_pending(mm);\n #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "target": 1}
{"code": "gopherMimeCreate(GopherStateData * gopherState)\n{\n    StoreEntry *entry = gopherState->entry;\n    const char *mime_type = nullptr;\n    const char *mime_enc = nullptr;\n    switch (gopherState->type_id) {\n    case GOPHER_DIRECTORY:\n    case GOPHER_INDEX:\n    case GOPHER_HTML:\n    case GOPHER_WWW:\n    case GOPHER_CSO:\n        mime_type = \"text/html\";\n        break;\n    case GOPHER_GIF:\n    case GOPHER_IMAGE:\n    case GOPHER_PLUS_IMAGE:\n        mime_type = \"image/gif\";\n        break;\n    case GOPHER_SOUND:\n    case GOPHER_PLUS_SOUND:\n        mime_type = \"audio/basic\";\n        break;\n    case GOPHER_PLUS_MOVIE:\n        mime_type = \"video/mpeg\";\n        break;\n    case GOPHER_MACBINHEX:\n    case GOPHER_DOSBIN:\n    case GOPHER_UUENCODED:\n    case GOPHER_BIN:\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_bin;\n        break;\n    case GOPHER_FILE:\n    default:\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_text;\n        break;\n    }\n    assert(entry->isEmpty());\n    HttpReply *reply = new HttpReply;\n    entry->buffer();\n    reply->setHeaders(Http::scOkay, \"Gatewaying\", mime_type, -1, -1, -2);\n    if (mime_enc)\n        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);\n    entry->replaceHttpReply(reply);\n    gopherState->reply_ = reply;\n}", "target": 1}
{"code": "static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n    wpc->version_five = 1;      \n    wpc->file_format = wpc->config.qmode = wpc->channel_layout = 0;\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n    if (bytecnt) {\n        wpc->file_format = *byteptr++;\n        wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n        bytecnt -= 2;\n        if (bytecnt) {\n            int nchans, i;\n            wpc->channel_layout = (int32_t) *byteptr++ << 16;\n            bytecnt--;\n            if (bytecnt) {\n                wpc->channel_layout += nchans = *byteptr++;\n                bytecnt--;\n                if (bytecnt) {\n                    if (bytecnt > nchans)\n                        return FALSE;\n                    wpc->channel_reordering = malloc (nchans);\n                    if (wpc->channel_reordering) {\n                        for (i = 0; i < nchans; ++i)\n                            if (bytecnt) {\n                                wpc->channel_reordering [i] = *byteptr++;\n                                bytecnt--;\n                            }\n                            else\n                                wpc->channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc->channel_layout += wpc->config.num_channels;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\tconst int angle_rounded = (int)floor(angle * 100);\n\tif (bgcolor < 0) {\n\t\treturn NULL;\n\t}\n\tif (src->trueColor == 0) {\n\t\tif (bgcolor >= 0) {\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\n\t\t}\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\tswitch (angle_rounded) {\n\t\tcase 9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\t\tcase 18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\t\tcase 27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "  clientpairingsecret(std::shared_ptr<safe::queue_t<crypto::x509_t>> &add_cert, pair_session_t &sess, pt::ptree &tree, const args_t &args) {\n    auto &client = sess.client;\n    auto pairingsecret = util::from_hex_vec(get_arg(args, \"clientpairingsecret\"), true);\n    if (pairingsecret.size() <= 16) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\"root.<xmlattr>.status_message\", \"Clientpairingsecret too short\");\n      return;\n    }\n    std::string_view secret { pairingsecret.data(), 16 };\n    std::string_view sign { pairingsecret.data() + secret.size(), pairingsecret.size() - secret.size() };\n    auto x509 = crypto::x509(client.cert);\n    auto x509_sign = crypto::signature(x509);\n    std::string data;\n    data.reserve(sess.serverchallenge.size() + x509_sign.size() + secret.size());\n    data.insert(std::end(data), std::begin(sess.serverchallenge), std::end(sess.serverchallenge));\n    data.insert(std::end(data), std::begin(x509_sign), std::end(x509_sign));\n    data.insert(std::end(data), std::begin(secret), std::end(secret));\n    auto hash = crypto::hash(data);\n    if (!std::memcmp(hash.data(), sess.clienthash.data(), hash.size()) && crypto::verify256(crypto::x509(client.cert), secret, sign)) {\n      tree.put(\"root.paired\", 1);\n      add_cert->raise(crypto::x509(client.cert));\n      auto it = map_id_sess.find(client.uniqueID);\n      update_id_client(client.uniqueID, std::move(client.cert), op_e::ADD);\n      map_id_sess.erase(it);\n    }\n    else {\n      map_id_sess.erase(client.uniqueID);\n      tree.put(\"root.paired\", 0);\n    }\n    tree.put(\"root.<xmlattr>.status_code\", 200);\n  }", "target": 1}
{"code": "asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct oabi_flock64 user;\n\tstruct flock64 kernel;\n\tmm_segment_t fs = USER_DS; \n\tunsigned long local_arg = arg;\n\tint ret;\n\tswitch (cmd) {\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t\t   sizeof(user)))\n\t\t\treturn -EFAULT;\n\t\tkernel.l_type\t= user.l_type;\n\t\tkernel.l_whence\t= user.l_whence;\n\t\tkernel.l_start\t= user.l_start;\n\t\tkernel.l_len\t= user.l_len;\n\t\tkernel.l_pid\t= user.l_pid;\n\t\tlocal_arg = (unsigned long)&kernel;\n\t\tfs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t}\n\tret = sys_fcntl64(fd, cmd, local_arg);\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\tif (!ret) {\n\t\t\tuser.l_type\t= kernel.l_type;\n\t\t\tuser.l_whence\t= kernel.l_whence;\n\t\t\tuser.l_start\t= kernel.l_start;\n\t\t\tuser.l_len\t= kernel.l_len;\n\t\t\tuser.l_pid\t= kernel.l_pid;\n\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t\t &user, sizeof(user)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tset_fs(fs);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int X509_aux_print(BIO *out, X509 *x, int indent)\n{\n    char oidstr[80], first;\n    STACK_OF(ASN1_OBJECT) *trust, *reject;\n    const unsigned char *alias, *keyid;\n    int keyidlen;\n    int i;\n    if (X509_trusted(x) == 0)\n        return 1;\n    trust = X509_get0_trust_objects(x);\n    reject = X509_get0_reject_objects(x);\n    if (trust) {\n        first = 1;\n        BIO_printf(out, \"%*sTrusted Uses:\\n%*s\", indent, \"\", indent + 2, \"\");\n        for (i = 0; i < sk_ASN1_OBJECT_num(trust); i++) {\n            if (!first)\n                BIO_puts(out, \", \");\n            else\n                first = 0;\n            OBJ_obj2txt(oidstr, sizeof(oidstr),\n                        sk_ASN1_OBJECT_value(trust, i), 0);\n            BIO_puts(out, oidstr);\n        }\n        BIO_puts(out, \"\\n\");\n    } else\n        BIO_printf(out, \"%*sNo Trusted Uses.\\n\", indent, \"\");\n    if (reject) {\n        first = 1;\n        BIO_printf(out, \"%*sRejected Uses:\\n%*s\", indent, \"\", indent + 2, \"\");\n        for (i = 0; i < sk_ASN1_OBJECT_num(reject); i++) {\n            if (!first)\n                BIO_puts(out, \", \");\n            else\n                first = 0;\n            OBJ_obj2txt(oidstr, sizeof(oidstr),\n                        sk_ASN1_OBJECT_value(reject, i), 0);\n            BIO_puts(out, oidstr);\n        }\n        BIO_puts(out, \"\\n\");\n    } else\n        BIO_printf(out, \"%*sNo Rejected Uses.\\n\", indent, \"\");\n    alias = X509_alias_get0(x, NULL);\n    if (alias)\n        BIO_printf(out, \"%*sAlias: %s\\n\", indent, \"\", alias);\n    keyid = X509_keyid_get0(x, &keyidlen);\n    if (keyid) {\n        BIO_printf(out, \"%*sKey Id: \", indent, \"\");\n        for (i = 0; i < keyidlen; i++)\n            BIO_printf(out, \"%s%02X\", i ? \":\" : \"\", keyid[i]);\n        BIO_write(out, \"\\n\", 1);\n    }\n    return 1;\n}", "target": 1}
{"code": "native_handle* Parcel::readNativeHandle() const\n{\n int numFds, numInts;\n status_t err;\n    err = readInt32(&numFds);\n if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n     if (err != NO_ERROR) return 0;\n     native_handle* h = native_handle_create(numFds, numInts);\n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n         if (h->data[i] < 0) err = BAD_VALUE;\n }\n    err = read(h->data + numFds, sizeof(int)*numInts);\n if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n }\n return h;\n}", "target": 1}
{"code": " void WebPageSerializerImpl::openTagToString(Element* element,\n                                             SerializeDomParam* param)\n {\n    bool needSkip;\n    StringBuilder result;\n    result.append(preActionBeforeSerializeOpenTag(element, param, &needSkip));\n    if (needSkip)\n        return;\n    result.append('<');\n    result.append(element->nodeName().lower());\n    AttributeCollection attributes = element->attributes();\n    AttributeCollection::iterator end = attributes.end();\n    for (AttributeCollection::iterator it = attributes.begin(); it != end; ++it) {\n        result.append(' ');\n        result.append(it->name().toString());\n        result.appendLiteral(\"=\\\"\");\n        if (!it->value().isEmpty()) {\n            const String& attrValue = it->value();\n            const QualifiedName& attrName = it->name();\n             if (element->hasLegalLinkAttribute(attrName)) {\n                 if (attrValue.startsWith(\"javascript:\", TextCaseInsensitive)) {\n                    result.append(attrValue);\n                 } else {\n                     WebLocalFrameImpl* subFrame = WebLocalFrameImpl::fromFrameOwnerElement(element);\n                    String completeURL = subFrame ? subFrame->frame()->document()->url() :\n                                                    param->document->completeURL(attrValue);\n                    if (m_localLinks.contains(completeURL)) {\n                        if (!param->directoryName.isEmpty()) {\n                            result.appendLiteral(\"./\");\n                             result.append(param->directoryName);\n                             result.append('/');\n                         }\n                        result.append(m_localLinks.get(completeURL));\n                     } else {\n                        result.append(completeURL);\n                     }\n                 }\n             } else {\n                if (param->isHTMLDocument)\n                    result.append(m_htmlEntities.convertEntitiesInString(attrValue));\n                else\n                    result.append(m_xmlEntities.convertEntitiesInString(attrValue));\n            }\n        }\n        result.append('\\\"');\n    }\n    String addedContents = postActionAfterSerializeOpenTag(element, param);\n    if (element->hasChildren() || param->haveAddedContentsBeforeEnd)\n        result.append('>');\n    result.append(addedContents);\n    saveHTMLContentToBuffer(result.toString(), param);\n}", "target": 1}
{"code": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n\tint err;\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\tdget(upper);\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\tif (!err)\n\t\td_drop(dentry);\n\tinode_unlock(dir);\n\treturn err;\n}", "target": 1}
{"code": "void nfc_unregister_device(struct nfc_dev *dev)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\trc = nfc_genl_device_removed(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s \"\n\t\t\t \"was removed\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (dev->rfkill) {\n\t\trfkill_unregister(dev->rfkill);\n\t\trfkill_destroy(dev->rfkill);\n\t}\n\tdevice_unlock(&dev->dev);\n\tif (dev->ops->check_presence) {\n\t\tdevice_lock(&dev->dev);\n\t\tdev->shutting_down = true;\n\t\tdevice_unlock(&dev->dev);\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\t\tcancel_work_sync(&dev->check_pres_work);\n\t}\n\tnfc_llcp_unregister_device(dev);\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\tdevice_del(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n}", "target": 1}
{"code": "int RGWPostObj_ObjStore_S3::get_tags()\n{\n  string tags_str;\n  if (part_str(parts, \"tagging\", &tags_str)) {\n    RGWObjTagsXMLParser parser;\n    if (!parser.init()){\n      ldout(s->cct, 0) << \"Couldn't init RGWObjTags XML parser\" << dendl;\n      err_msg = \"Server couldn't process the request\";\n      return -EINVAL; \n    }\n    if (!parser.parse(tags_str.c_str(), tags_str.size(), 1)) {\n      ldout(s->cct,0 ) << \"Invalid Tagging XML\" << dendl;\n      err_msg = \"Invalid Tagging XML\";\n      return -EINVAL;\n    }\n    RGWObjTagSet_S3 *obj_tags_s3;\n    RGWObjTagging_S3 *tagging;\n    tagging = static_cast<RGWObjTagging_S3 *>(parser.find_first(\"Tagging\"));\n    obj_tags_s3 = static_cast<RGWObjTagSet_S3 *>(tagging->find_first(\"TagSet\"));\n    if(!obj_tags_s3){\n      return -ERR_MALFORMED_XML;\n    }\n    RGWObjTags obj_tags;\n    int r = obj_tags_s3->rebuild(obj_tags);\n    if (r < 0)\n      return r;\n    bufferlist tags_bl;\n    obj_tags.encode(tags_bl);\n    ldout(s->cct, 20) << \"Read \" << obj_tags.count() << \"tags\" << dendl;\n    attrs[RGW_ATTR_TAGS] = tags_bl;\n  }\n  return 0;\n}", "target": 1}
{"code": "  RectangleRequest(const struct RectangleRequest &req)\n    : Explicit()\n  {\n    memcpy(this,&req,sizeof(struct RectangleRequest));\n    rr_pNext = NULL;\n  }", "target": 1}
{"code": "void HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {\n  if (data.empty()) {\n    return;\n  }\n  if (!header.empty()) {\n    header.append(\",\", 1);\n  }\n  header.append(data.data(), data.size());\n}", "target": 1}
{"code": "static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t     struct file *out, loff_t *ppos,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tunsigned nbuf;\n\tunsigned idx;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_dev *fud;\n\tsize_t rem;\n\tssize_t ret;\n\tfud = fuse_get_dev(out);\n\tif (!fud)\n\t\treturn -EPERM;\n\tpipe_lock(pipe);\n\tbufs = kvmalloc_array(pipe->nrbufs, sizeof(struct pipe_buffer),\n\t\t\t      GFP_KERNEL);\n\tif (!bufs) {\n\t\tpipe_unlock(pipe);\n\t\treturn -ENOMEM;\n\t}\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tpipe_buf_get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\tfuse_copy_init(&cs, 0, NULL);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\tret = fuse_dev_do_write(fud, &cs, len);\n\tpipe_lock(pipe);\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\nout:\n\tkvfree(bufs);\n\treturn ret;\n}", "target": 1}
{"code": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t old_val;\n     trace_esp_mem_readb(saddr, s->rregs[saddr]);\n     switch (saddr) {\n     case ESP_FIFO:\n        if (s->ti_size > 0) {\n             s->ti_size--;\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n                qemu_log_mask(LOG_UNIMP,\n                              \"esp: PIO data read not implemented\\n\");\n                s->rregs[ESP_FIFO] = 0;\n            } else {\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n            }\n             esp_raise_irq(s);\n         }\n        if (s->ti_size == 0) {\n             s->ti_rptr = 0;\n             s->ti_wptr = 0;\n         }\n            s->ti_wptr = 0;\n        }\n        break;\n    case ESP_RINTR:\n        old_val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        esp_lower_irq(s);\n        return old_val;\n    case ESP_TCHI:\n        if (!s->tchi_written) {\n            return s->chip_id;\n        }\n    default:\n        break;\n    }", "target": 1}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\tif (current != task)\n\t\treturn -EACCES;\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n\t\t\tsa.aad.op = OP_SETPROCATTR;\n\t\t\tsa.aad.info = name;\n\t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n\t\t\t\t\t&sa, NULL);\n\t\t}\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}", "target": 1}
{"code": "void ip_options_build(struct sk_buff * skb, struct ip_options * opt,\n\t\t\t    __be32 daddr, struct rtable *rt, int is_frag)\n{\n\tunsigned char *iph = skb_network_header(skb);\n\tmemcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));\n\tmemcpy(iph+sizeof(struct iphdr), opt->__data, opt->optlen);\n\topt = &(IPCB(skb)->opt);\n\tif (opt->srr)\n\t\tmemcpy(iph+opt->srr+iph[opt->srr+1]-4, &daddr, 4);\n\tif (!is_frag) {\n\t\tif (opt->rr_needaddr)\n\t\t\tip_rt_get_source(iph+opt->rr+iph[opt->rr+2]-5, rt);\n\t\tif (opt->ts_needaddr)\n\t\t\tip_rt_get_source(iph+opt->ts+iph[opt->ts+2]-9, rt);\n\t\tif (opt->ts_needtime) {\n\t\t\tstruct timespec tv;\n\t\t\t__be32 midtime;\n\t\t\tgetnstimeofday(&tv);\n\t\t\tmidtime = htonl((tv.tv_sec % 86400) * MSEC_PER_SEC + tv.tv_nsec / NSEC_PER_MSEC);\n\t\t\tmemcpy(iph+opt->ts+iph[opt->ts+2]-5, &midtime, 4);\n\t\t}\n\t\treturn;\n\t}\n\tif (opt->rr) {\n\t\tmemset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);\n\t\topt->rr = 0;\n\t\topt->rr_needaddr = 0;\n\t}\n\tif (opt->ts) {\n\t\tmemset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);\n\t\topt->ts = 0;\n\t\topt->ts_needaddr = opt->ts_needtime = 0;\n\t}\n}", "target": 1}
{"code": "int btrfs_scrub_progress(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n\tif (dev)\n\t\tsctx = dev->scrub_ctx;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}", "target": 1}
{"code": "static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inI2outR2_tail(pcrc, r);\n\tif ( e > STF_FAIL) {\n\t\tint v2_notify_num = e - STF_FAIL;\n\t\tDBG_log(\n\t\t\t\"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\",\n\t\t\tenum_name(&ikev2_notify_names, v2_notify_num));\n\t} else if ( e != STF_OK) {\n\t\tDBG_log(\"ikev2_parent_inI2outR2_tail returned %s\",\n\t\t\tenum_name(&stfstatus_name, e));\n\t}\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n \t\terror = add_push_report_pkt(push, pkt);\n \t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "void put_busid_priv(struct bus_id_priv *bid)\n{\n\tspin_unlock(&bid->busid_lock);\n}", "target": 1}
{"code": "pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n\t\t\tint atomic)\n{\n\tunsigned long copy;\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\t\tif (atomic) {\n\t\t\tif (__copy_from_user_inatomic(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_from_user(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tto += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n    if (!ok)\n        return ((int)n);\n    if (n < 6) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n     }\n     p = d = (unsigned char *)s->init_msg;\n     n2l(p, s->session->tlsext_tick_lifetime_hint);\n     n2s(p, ticklen);\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    OPENSSL_free(s->session->tlsext_tick);\n    s->session->tlsext_ticklen = 0;\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n               EVP_sha256(), NULL);\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}", "target": 1}
{"code": "static int sock_close(struct inode *inode, struct file *filp)\n{\n\tsock_release(SOCKET_I(inode));\n\treturn 0;\n}", "target": 1}
{"code": " struct crypto_template *crypto_lookup_template(const char *name)\n {\n\treturn try_then_request_module(__crypto_lookup_template(name), \"%s\",\n\t\t\t\t       name);\n }", "target": 1}
{"code": "ctcompare(const char *a,\t\t\n          const char *b)\t\t\n{\n  int\tresult = 0;\t\t\t\n  while (*a && *b)\n  {\n    result |= *a ^ *b;\n    a ++;\n    b ++;\n  }\n  return (result);\n}", "target": 1}
{"code": "write_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);\n\t\tstrs = backtrace_symbols(buffer, nptrs);\n\t\tif (strs == NULL) {\n\t\t\tlog_message(LOG_INFO, \"Unable to get stack backtrace\");\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 1; i < nptrs - 2; i++)\n\t\t\tlog_message(LOG_INFO, \"  %s\", strs[i]);\n\t\tfree(strs);\n\t}\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_CODE );\n}", "target": 1}
{"code": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n }", "target": 1}
{"code": "char *enl_ipc_get(const char *msg_data)\n{\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* axis,\n                                 const TfLiteTensor* input, int num_splits) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n  const int input_size = SizeOfDimension(input, axis_value);\n  TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,\n                     \"Not an even split\");\n  const int slice_size = input_size / num_splits;\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = slice_size;\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret != -EEXIST ? ret : 0;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "struct crypto_template *crypto_lookup_template(const char *name)\n{\n\treturn try_then_request_module(__crypto_lookup_template(name), \"%s\",\n\t\t\t\t       name);\n}", "target": 1}
{"code": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source)\n{\n\tvoid *old_p, *retval;\n\tif ((old_p = zend_hash_index_find_ptr(&xlat_table, (zend_ulong)source)) != NULL) {\n\t\treturn old_p;\n\t}\n        retval = ZCG(mem);\n        ZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n        memcpy(retval, source, size);\n        if (free_source) {\n                efree(source);\n        }\n       zend_shared_alloc_register_xlat_entry(source, retval);\n        return retval;\n }", "target": 1}
{"code": "nautilus_file_mark_desktop_file_trusted (GFile              *file,\n                                         GtkWindow          *parent_window,\n                                         gboolean            interactive,\n                                         NautilusOpCallback  done_callback,\n                                         gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_trusted_task_thread_func);\n    g_object_unref (task);\n}", "target": 1}
{"code": "void diff_addremove(struct diff_options *options,\n\t\t    int addremove, unsigned mode,\n\t\t    const unsigned char *sha1,\n\t\t    const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(mode))\n\t\treturn;\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF))\n\t\taddremove = (addremove == '+' ? '-' :\n\t\t\t     addremove == '-' ? '+' : addremove);\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\tif (addremove != '+')\n\t\tfill_filespec(one, sha1, mode);\n\tif (addremove != '-')\n\t\tfill_filespec(two, sha1, mode);\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}", "target": 1}
{"code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n   clone = mrb_obj_value(p);\n   init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n   return clone;\n }", "target": 1}
{"code": "std::set<std::string> getMounts(Computer * computer, const std::string& comp_path) {\n    std::vector<std::string> elems = split(comp_path, \"/\\\\\");\n    std::list<std::string> pathc;\n    std::set<std::string> retval;\n    for (std::string s : elems) {\n        if (s == \"..\") { if (pathc.empty()) return retval; else pathc.pop_back(); }\n        else if (!s.empty() && !std::all_of(s.begin(), s.end(), [](const char c)->bool{return c == '.';})) {\n            s.erase(std::remove_if(s.begin(), s.end(), [](char c)->bool{return c=='\"'||c==':'||c=='<'||c=='>'||c=='?'||c=='|';}), s.end());\n            pathc.push_back(s);\n        }\n    }\n    for (const auto& m : computer->mounts)\n        if (pathc.size() + 1 == std::get<0>(m).size() && std::equal(pathc.begin(), pathc.end(), std::get<0>(m).begin()))\n            retval.insert(std::get<0>(m).back());\n    return retval;\n}", "target": 1}
{"code": "cib_send_plaintext(int sock, xmlNode * msg)\n{\n    char *xml_text = dump_xml_unformatted(msg);\n    if (xml_text != NULL) {\n        int rc = 0;\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n        len++;                  \n        crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n        rc = write(sock, unsent, len);\n        if (rc < 0) {\n            switch (errno) {\n                case EINTR:\n                case EAGAIN:\n                    crm_trace(\"Retry\");\n                    goto retry;\n                default:\n                    crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, len);\n                    break;\n            }\n        } else if (rc < len) {\n            crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n            goto retry;\n        } else {\n            crm_trace(\"Sent %d bytes: %.100s\", rc, xml_text);\n        }\n    }\n    free(xml_text);\n    return NULL;\n}", "target": 1}
{"code": "  Status check_index_ordering(const Tensor& indices) {\n    auto findices = indices.flat<int>();\n    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {\n      if (findices(i) < findices(i + 1)) {\n        continue;\n      }\n      return Status(\n          errors::InvalidArgument(\"Indices are not strictly ordered\"));\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static void ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t       struct sk_buff *skb, u32 mtu)\n{\n\tstruct rt6_info *rt6 = (struct rt6_info *)dst;\n\tdst_confirm(dst);\n\tif (mtu < dst_mtu(dst) && rt6->rt6i_dst.plen == 128) {\n\t\tstruct net *net = dev_net(dst->dev);\n\t\trt6->rt6i_flags |= RTF_MODIFIED;\n\t\tif (mtu < IPV6_MIN_MTU) {\n\t\t\tu32 features = dst_metric(dst, RTAX_FEATURES);\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\t\tfeatures |= RTAX_FEATURE_ALLFRAG;\n\t\t\tdst_metric_set(dst, RTAX_FEATURES, features);\n\t\t}\n\t\tdst_metric_set(dst, RTAX_MTU, mtu);\n\t\trt6_update_expires(rt6, net->ipv6.sysctl.ip6_rt_mtu_expires);\n\t}\n}", "target": 1}
{"code": "bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *done_key)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\tget_random_bytes(buf, nbytes);\n\t*done = true;\n\tspin_unlock_irqrestore(&lock, flags);\n\t__net_random_once_disable_jump(done_key);\n\treturn true;\n}", "target": 1}
{"code": "rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n {\n \tint phy_addr;\n \tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n\tstruct netdev_desc *desc;\n\tint i;\n \tphy_addr = np->phy_addr;\n \tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n \t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n \t\tbreak;\n\tcase SIOCDEVPRIVATE + 3:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 4:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 5:\n\t\tnetif_stop_queue (dev);\n \t\tbreak;\n\tcase SIOCDEVPRIVATE + 6:\n\t\tnetif_wake_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 7:\n\t\tprintk\n\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n\t\t     np->old_rx);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 8:\n\t\tprintk(\"TX ring:\\n\");\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tdesc = &np->tx_ring[i];\n\t\t\tprintk\n\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n\t\t\t     i,\n\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n\t\t\t     (u32)le64_to_cpu(desc->status),\n\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n\t\t\tprintk (\"\\n\");\n\t\t}\n\t\tprintk (\"\\n\");\n\t\tbreak;\n \tdefault:\n \t\treturn -EOPNOTSUPP;\n \t}\n\treturn 0;\n}", "target": 1}
{"code": "static void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) {\n\tif (!num || !offset || (st32)num < 0) {\n\t\treturn;\n\t}\n\tut64 total_size = num * sizeof (struct relocation_info);\n\tif (offset > bin->size) {\n\t\treturn;\n\t}\n\tif (total_size > bin->size) {\n\t\ttotal_size = bin->size - offset;\n\t\tnum = total_size /= sizeof (struct relocation_info);\n\t}\n\tstruct relocation_info *info = calloc (num, sizeof (struct relocation_info));\n\tif (!info) {\n\t\treturn;\n\t}\n\tif (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) {\n\t\tfree (info);\n\t\treturn;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct relocation_info a_info = info[i];\n\t\tut32 sym_num = a_info.r_symbolnum;\n\t\tif (sym_num > bin->nsymtab) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 stridx = bin->symtab[sym_num].n_strx;\n\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\tif (!sym_name) {\n\t\t\tcontinue;\n\t\t}\n\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\tif (!reloc) {\n\t\t\tfree (info);\n\t\t\tfree (sym_name);\n\t\t\treturn;\n\t\t}\n\t\treloc->addr = offset_to_vaddr (bin, a_info.r_address);\n\t\treloc->offset = a_info.r_address;\n\t\treloc->ord = sym_num;\n\t\treloc->type = a_info.r_type; \n\t\treloc->external = a_info.r_extern;\n\t\treloc->pc_relative = a_info.r_pcrel;\n\t\treloc->size = a_info.r_length;\n\t\tr_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1);\n\t\tr_skiplist_insert (relocs, reloc);\n\t\tfree (sym_name);\n\t}\n\tfree (info);\n}", "target": 1}
{"code": "addMultirowsForm(Buffer *buf, AnchorList *al)\n{\n    int i, j, k, col, ecol, pos;\n    Anchor a_form, *a;\n    Line *l, *ls;\n    if (al == NULL || al->nanchor == 0)\n\treturn;\n    for (i = 0; i < al->nanchor; i++) {\n\ta_form = al->anchors[i];\n\tal->anchors[i].rows = 1;\n\tif (a_form.hseq < 0 || a_form.rows <= 1)\n\t    continue;\n\tfor (l = buf->firstLine; l != NULL; l = l->next) {\n\t    if (l->linenumber == a_form.y)\n\t\tbreak;\n\t}\n\tif (!l)\n\t    continue;\n\tif (a_form.y == a_form.start.line)\n\t    ls = l;\n\telse {\n\t    for (ls = l; ls != NULL;\n\t\t ls = (a_form.y < a_form.start.line) ? ls->next : ls->prev) {\n\t\tif (ls->linenumber == a_form.start.line)\n\t\t    break;\n\t    }\n\t    if (!ls)\n\t\tcontinue;\n\t}\n\tcol = COLPOS(ls, a_form.start.pos);\n\tecol = COLPOS(ls, a_form.end.pos);\n\tfor (j = 0; l && j < a_form.rows; l = l->next, j++) {\n\t    pos = columnPos(l, col);\n\t    if (j == 0) {\n\t\tbuf->hmarklist->marks[a_form.hseq].line = l->linenumber;\n\t\tbuf->hmarklist->marks[a_form.hseq].pos = pos;\n\t    }\n\t    if (a_form.start.line == l->linenumber)\n\t\tcontinue;\n\t    buf->formitem = putAnchor(buf->formitem, a_form.url,\n\t\t\t\t      a_form.target, &a, NULL, NULL, '\\0',\n\t\t\t\t      l->linenumber, pos);\n\t    a->hseq = a_form.hseq;\n\t    a->y = a_form.y;\n\t    a->end.pos = pos + ecol - col;\n\t    l->lineBuf[pos - 1] = '[';\n\t    l->lineBuf[a->end.pos] = ']';\n\t    for (k = pos; k < a->end.pos; k++)\n\t\tl->propBuf[k] |= PE_FORM;\n\t}\n    }\n}", "target": 1}
{"code": "\tPong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n\t\tPushParamRef(cookie);\n\t}", "target": 1}
{"code": "static void cmd_anal_ucall_ref(RCore *core, ut64 addr) {\n\tRAnalFunction * fcn = r_anal_get_function_at (core->anal, addr);\n\tif (fcn) {\n\t\tr_cons_printf (\" ; %s\", fcn->name);\n\t} else {\n\t\tr_cons_printf (\" ; 0x%\" PFMT64x, addr);\n\t}\n}", "target": 1}
{"code": "static void pcrypt_free(struct crypto_instance *inst)\n{\n\tstruct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);\n\tcrypto_drop_aead(&ctx->spawn);\n\tkfree(inst);\n}", "target": 1}
{"code": "bit_write_MC (Bit_Chain *dat, BITCODE_MC val)\n{\n  int i, j;\n  int negative = 0;\n  unsigned char byte[5];\n  BITCODE_UMC mask = 0x0000007f;\n  BITCODE_UMC value = (BITCODE_UMC)val;\n  if (val < 0)\n    {\n      negative = 1;\n      value = (BITCODE_UMC)-val;\n    }\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  if (negative)\n    byte[i] |= 0x40;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n \tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n \tstruct pmu *leader_pmu = event->group_leader->pmu;\n \tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n \t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, event) >= 0;\n}", "target": 1}
{"code": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\twhile (ptr) {\n\t\tret = copy_to_user(param, ptr, sizeof(*ptr));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void *enc_untrusted_realloc(void *ptr, size_t size) {\n  MessageWriter input;\n  input.Push(reinterpret_cast<uint64_t>(ptr));\n  input.Push(static_cast<uint64_t>(size));\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kReallocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_realloc\", 2);\n  void *result = output.next<void *>();\n  int klinux_errno = output.next<int>();\n  if (!result && size != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}", "target": 1}
{"code": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n \t\tl = 0;\n \t}\n \tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n \t\t}\n\t\tobj->state = EError;\n\t\treturn;\n \t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n \tif(xml) {\n \t\tfree(xml);\n \t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}", "target": 1}
{"code": "  Status CheckInputs(Tensor group_size_t, Tensor group_key_t) {\n    if (group_size_t.dims() > 0) {\n      return errors::Internal(\n          \"Unexpected dimensions on input group_size. \"\n          \"It shoulbe a scalar, got tensor with shape \",\n          group_size_t.shape().DebugString());\n    }\n    if (group_key_t.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_key, got \",\n                              group_key_t.shape().DebugString());\n    }\n    auto group_size = group_size_t.unaligned_flat<int32>()(0);\n    if (group_size <= 0) {\n      return errors::InvalidArgument(\n          \"group_size must be positive integer but got \", group_size);\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}", "target": 1}
{"code": "    long WebPImage::getHeaderOffset(byte *data, long data_size,\n                                    byte *header, long header_size) {\n        long pos = -1;\n        for (long i=0; i < data_size - header_size; i++) {\n            if (memcmp(header, &data[i], header_size) == 0) {\n                pos = i;\n                break;\n            }\n        }\n        return pos;\n    }", "target": 1}
{"code": "static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "    void StackMsg::appendLine( char *szLine, bool complete ) {\n        if( complete ) {\n            m_os.flush() ;\n            m_sipMessage = m_os.str() ;\n            m_sipMessage.resize( m_sipMessage.length() - 1) ;\n            boost::replace_all(m_sipMessage, \"\\n\", DR_CRLF);\n        }\n        else if( 0 == strcmp(szLine, \"\\n\") ) {\n            m_os << endl ;\n        }\n        else {\n            int i = 0 ;\n            while( ' ' == szLine[i] && '\\0' != szLine[i]) i++ ;\n            m_os << ( szLine + i ) ;\n        }\n    }", "target": 1}
{"code": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tptrdiff_t need_size = (char *) offset - memory + size;\n\tif (need_size < 0 || need_size > total_size) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "fmtstr(char **sbuffer,\n       char **buffer,\n       size_t *currlen,\n       size_t *maxlen, const char *value, int flags, int min, int max)\n{\n    int padlen, strln;\n    int cnt = 0;\n    if (value == 0)\n        value = \"<NULL>\";\n    for (strln = 0; value[strln]; ++strln) ;\n    padlen = min - strln;\n    if (padlen < 0)\n        padlen = 0;\n    if (flags & DP_F_MINUS)\n        padlen = -padlen;\n    while ((padlen > 0) && (cnt < max)) {\n        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\n        --padlen;\n        ++cnt;\n    }\n    while (*value && (cnt < max)) {\n        doapr_outch(sbuffer, buffer, currlen, maxlen, *value++);\n        ++cnt;\n    }\n    while ((padlen < 0) && (cnt < max)) {\n        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\n        ++padlen;\n        ++cnt;\n    }\n}", "target": 1}
{"code": "prepenv(const struct rule *rule)\n{\n\tstatic const char *safeset[] = {\n\t\t\"DISPLAY\", \"HOME\", \"LOGNAME\", \"MAIL\",\n\t\t\"PATH\", \"TERM\", \"USER\", \"USERNAME\",\n\t\tNULL\n\t};\n\tstruct env *env;\n\tenv = createenv(rule);\n\tif (!(rule->options & KEEPENV))\n\t\tfillenv(env, safeset);\n\tif (rule->envlist)\n\t\tfillenv(env, rule->envlist);\n\treturn flattenenv(env);\n}", "target": 1}
{"code": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n\t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n\t\t\t\t\t\t\t  dirname);\n\t\t\tif (subdir) {\n\t\t\t\tg_object_unref (subdir);\n\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n\t\t\t} else\n\t\t\t\tdir = tar_create_dir (dir, dirname);\n\t\t}\n\t\tg_free (dirname);\n\t}\n}", "target": 1}
{"code": "\tPong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n\t\tPushParamRef(cookie);\n\t}", "target": 1}
{"code": "folly::Optional<Param> ReadRecordLayer::readEvent(\n    folly::IOBufQueue& socketBuf) {\n  if (!unparsedHandshakeData_.empty()) {\n    auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n    if (param) {\n      VLOG(8) << \"Received handshake message \"\n              << toString(boost::apply_visitor(EventVisitor(), *param));\n      return param;\n    }\n  }\n  while (true) {\n    auto message = read(socketBuf);\n    if (!message) {\n      return folly::none;\n    }\n    if (!unparsedHandshakeData_.empty() &&\n        message->type != ContentType::handshake) {\n      throw std::runtime_error(\"spliced handshake data\");\n    }\n    switch (message->type) {\n      case ContentType::alert: {\n        auto alert = decode<Alert>(std::move(message->fragment));\n        if (alert.description == AlertDescription::close_notify) {\n          return Param(CloseNotify(socketBuf.move()));\n        } else {\n          return Param(std::move(alert));\n        }\n      }\n      case ContentType::handshake: {\n        unparsedHandshakeData_.append(std::move(message->fragment));\n        auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n        if (param) {\n          VLOG(8) << \"Received handshake message \"\n                  << toString(boost::apply_visitor(EventVisitor(), *param));\n          return param;\n        } else {\n          continue;\n        }\n      }\n      case ContentType::application_data:\n        return Param(AppData(std::move(message->fragment)));\n      default:\n        throw std::runtime_error(\"unknown content type\");\n    }\n  }\n}", "target": 1}
{"code": "static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfca_poll *nfca_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));\n\tdata += 2;\n\tnfca_poll->nfcid1_len = *data++;\n\tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n\t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);\n\tmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\n\tdata += nfca_poll->nfcid1_len;\n\tnfca_poll->sel_res_len = *data++;\n\tif (nfca_poll->sel_res_len != 0)\n\t\tnfca_poll->sel_res = *data++;\n\tpr_debug(\"sel_res_len %d, sel_res 0x%x\\n\",\n\t\t nfca_poll->sel_res_len,\n\t\t nfca_poll->sel_res);\n\treturn data;\n}", "target": 1}
{"code": "static int sgi_timer_set(struct k_itimer *timr, int flags,\n\tstruct itimerspec * new_setting,\n\tstruct itimerspec * old_setting)\n{\n\tunsigned long when, period, irqflags;\n\tint err = 0;\n\tcnodeid_t nodeid;\n\tstruct mmtimer *base;\n\tstruct rb_node *n;\n\tif (old_setting)\n\t\tsgi_timer_get(timr, old_setting);\n\tsgi_timer_del(timr);\n\twhen = timespec_to_ns(new_setting->it_value);\n\tperiod = timespec_to_ns(new_setting->it_interval);\n\tif (when == 0)\n\t\treturn 0;\n\tbase = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);\n\tif (base == NULL)\n\t\treturn -ENOMEM;\n\tif (flags & TIMER_ABSTIME) {\n\t\tstruct timespec n;\n\t\tunsigned long now;\n\t\tgetnstimeofday(&n);\n\t\tnow = timespec_to_ns(n);\n\t\tif (when > now)\n\t\t\twhen -= now;\n\t\telse\n\t\t\twhen = 0;\n\t}\n\twhen = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();\n\tperiod = (period + sgi_clock_period - 1)  / sgi_clock_period;\n\tpreempt_disable();\n\tnodeid =  cpu_to_node(smp_processor_id());\n\tspin_lock_irqsave(&timers[nodeid].lock, irqflags);\n\tbase->timer = timr;\n\tbase->cpu = smp_processor_id();\n\ttimr->it.mmtimer.clock = TIMER_SET;\n\ttimr->it.mmtimer.node = nodeid;\n\ttimr->it.mmtimer.incr = period;\n\ttimr->it.mmtimer.expires = when;\n\tn = timers[nodeid].next;\n\tmmtimer_add_list(base);\n\tif (timers[nodeid].next == n) {\n\t\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\t\tpreempt_enable();\n\t\treturn err;\n\t}\n\tif (n)\n\t\tmmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);\n\tmmtimer_set_next_timer(nodeid);\n\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\tpreempt_enable();\n\treturn err;\n}", "target": 1}
{"code": "static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n {\n \tint sock[2] = {-1, -1};\n \tpid_t qpid, cpid = -1;\n\tFILE *pids_file = NULL;\n\tbool answer = false, fail = false;\n\tpids_file = open_pids_file(contrl, cg);\n\tif (!pids_file)\n\t\treturn false;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\tcpid = fork();\n\tif (cpid == -1)\n\t\tgoto out;\n\tif (!cpid) { \n\t\tfclose(pids_file);\n\t\tpid_from_ns_wrapper(sock[1], tpid);\n\t}\n\tconst char *ptr = buf;\n\twhile (sscanf(ptr, \"%d\", &qpid) == 1) {\n\t\tstruct ucred cred;\n\t\tchar v;\n\t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {\n\t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n \t\tif (recv_creds(sock[0], &cred, &v)) {\n \t\t\tif (v == '0') {\n \t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n \t\t\t\t\tfail = true;\n \t\t\t}\n\t\t}\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (!ptr)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\tqpid = -1;\n\tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))\n\t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");\n\tif (!fail)\n\t\tanswer = true;\nout:\n\tif (cpid != -1)\n\t\twait_for_pid(cpid);\n\tif (sock[0] != -1) {\n\t\tclose(sock[0]);\n\t\tclose(sock[1]);\n\t}\n\tif (pids_file) {\n\t\tif (fclose(pids_file) != 0)\n\t\t\tanswer = false;\n\t}\n\treturn answer;\n}", "target": 1}
{"code": "IW_IMPL(int) iw_get_i32le(const iw_byte *b)\n{\n\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));\n}", "target": 1}
{"code": "GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) \n {\n \tif (ms)\n \t{\n\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n \t\tif (nestsize == 0 && ms->nest_level == 0)\n \t\t\tnestsize = ms->buffer_size_longs;\n\t\tif (size + 2 <= nestsize) return GPMF_OK;\n\t}\n\treturn GPMF_ERROR_BAD_STRUCTURE;\n}", "target": 1}
{"code": "lyd_new(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new(parent, snode, 0);\n}", "target": 1}
{"code": "get_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)\n{\n    static gprinc_ret               ret;\n    char                            *prime_arg, *funcname;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gprinc_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    funcname = \"kadm5_get_principal\";\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_principal(handle, arg->princ, &ret.rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "target": 1}
{"code": " MagickExport int LocaleLowercase(const int c)\n {\n  if (c < 0)\n     return(c);\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n    return(tolower_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(tolower((int) ((unsigned char) c)));\n}", "target": 1}
{"code": "static void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        vnc_client_error(vs);\n         return;\n     }\n     vs->client_pf.rmax = red_max;\n     vs->client_pf.rbits = hweight_long(red_max);\n     vs->client_pf.rshift = red_shift;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n    set_pixel_conversion(vs);\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);\n}", "target": 1}
{"code": "static void sctp_close(struct sock *sk, long timeout)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos, *temp;\n\tunsigned int data_was_unread;\n\tpr_debug(\"%s: sk:%p, timeout:%ld\\n\", __func__, sk, timeout);\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsk->sk_state = SCTP_SS_CLOSING;\n\tep = sctp_sk(sk)->ep;\n\tdata_was_unread = sctp_queue_purge_ulpevents(&sk->sk_receive_queue);\n\tdata_was_unread += sctp_queue_purge_ulpevents(&sctp_sk(sk)->pd_lobby);\n\tlist_for_each_safe(pos, temp, &ep->asocs) {\n\t\tasoc = list_entry(pos, struct sctp_association, asocs);\n\t\tif (sctp_style(sk, TCP)) {\n\t\t\tif (sctp_state(asoc, CLOSED)) {\n\t\t\t\tsctp_unhash_established(asoc);\n\t\t\t\tsctp_association_free(asoc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (data_was_unread || !skb_queue_empty(&asoc->ulpq.lobby) ||\n\t\t    !skb_queue_empty(&asoc->ulpq.reasm) ||\n\t\t    (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime)) {\n\t\t\tstruct sctp_chunk *chunk;\n\t\t\tchunk = sctp_make_abort_user(asoc, NULL, 0);\n\t\t\tif (chunk)\n\t\t\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\t} else\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\trelease_sock(sk);\n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\tsock_put(sk);\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}", "target": 1}
{"code": "static void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}", "target": 1}
{"code": "sraSpanInsertAfter(sraSpan *newspan, sraSpan *after) {\n  newspan->_next = after->_next;\n  newspan->_prev = after;\n  after->_next->_prev = newspan;\n  after->_next = newspan;\n}", "target": 1}
{"code": "compile_get_env(char_u **arg, cctx_T *cctx)\n{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start - 1);\n\treturn FAIL;\n    }\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayJoinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    const char *jstr = \"\";\n    int argc, curlen;\n    Jsi_DString dStr = {};\n    curlen = Jsi_ObjGetLength(interp, _this->d.obj);\n    if (curlen == 0) {\n        goto bail;\n    }\n    if (Jsi_ValueGetLength(interp, args) >= 1) {\n        Jsi_Value *sc = Jsi_ValueArrayIndex(interp, args, 0);\n        if (sc != NULL)\n            jstr = Jsi_ValueToString(interp, sc, NULL);\n    }\n    if (0 == (argc=Jsi_ObjGetLength(interp, _this->d.obj))) {\n        goto bail;\n    }\n    int i;\n    for (i = 0; i < argc; ++i) {\n        const char *cp;\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, _this, i);\n        if (!ov) {\n            continue;\n            cp = \"\";\n        } else\n            cp = Jsi_ValueToString(interp, ov, NULL);\n        if (i && jstr[0])\n            Jsi_DSAppend(&dStr, jstr, NULL);\n        Jsi_DSAppend(&dStr, cp, NULL);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeStringDup(interp, ret, \"\");\n    return JSI_OK;        \n}", "target": 1}
{"code": " status_t NuPlayer::GenericSource::setBuffers(\n         bool audio, Vector<MediaBuffer *> &buffers) {\n    if (mIsWidevine && !audio && mVideoTrack.mSource != NULL) {\n         return mVideoTrack.mSource->setBuffers(buffers);\n     }\n     return INVALID_OPERATION;\n}", "target": 1}
{"code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\tCloseHandle(Token);\n\treturn 0;\n#else\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tchar *crypt_password;\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n#ifdef HAVE_GETSPNAM\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\tuser_password = user->pw_passwd;\n#endif\n\tcrypt_password = crypt(password, user_password);\n\tif (crypt_password == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\tif (strcmp(user_password, crypt_password) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)\n{\n\tunsigned int i;\n\tstruct hash_cell *hc;\n\tsize_t len, needed = 0;\n\tstruct gendisk *disk;\n\tstruct dm_name_list *orig_nl, *nl, *old_nl = NULL;\n\tuint32_t *event_nr;\n\tdown_write(&_hash_lock);\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tneeded += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);\n\t\t\tneeded += align_val(sizeof(uint32_t));\n\t\t}\n\t}\n\tnl = orig_nl = get_result_buffer(param, param_size, &len);\n\tif (len < needed) {\n\t\tparam->flags |= DM_BUFFER_FULL_FLAG;\n\t\tgoto out;\n\t}\n\tparam->data_size = param->data_start + needed;\n\tnl->dev = 0;\t\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tif (old_nl)\n\t\t\t\told_nl->next = (uint32_t) ((void *) nl -\n\t\t\t\t\t\t\t   (void *) old_nl);\n\t\t\tdisk = dm_disk(hc->md);\n\t\t\tnl->dev = huge_encode_dev(disk_devt(disk));\n\t\t\tnl->next = 0;\n\t\t\tstrcpy(nl->name, hc->name);\n\t\t\told_nl = nl;\n\t\t\tevent_nr = align_ptr(nl->name + strlen(hc->name) + 1);\n\t\t\t*event_nr = dm_get_event_nr(hc->md);\n\t\t\tnl = align_ptr(event_nr + 1);\n\t\t}\n\t}\n\tBUG_ON((char *)nl - (char *)orig_nl != needed);\n out:\n\tup_write(&_hash_lock);\n\treturn 0;\n}", "target": 1}
{"code": "utils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n                                                const std::string &value) {\n  ngx_table_elt_t *h = nullptr;\n  for (auto &h_in : r_->headers_in) {\n    if (key.size() == h_in.key.len &&\n        strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data),\n                    h_in.key.len) == 0) {\n      h = &h_in;\n      break;\n    }\n  }\n  if (h == nullptr) {\n    h = reinterpret_cast<ngx_table_elt_t *>(\n        ngx_list_push(&r_->headers_in.headers));\n    if (h == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->lowcase_key =\n        reinterpret_cast<u_char *>(ngx_pcalloc(r_->pool, key.size()));\n    if (h->lowcase_key == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->hash = ngx_hash_strlow(\n        h->lowcase_key,\n        reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())),\n        key.size());\n  }\n  if (ngx_str_copy_from_std(r_->pool, key, &h->key) != NGX_OK ||\n      ngx_str_copy_from_std(r_->pool, value, &h->value) != NGX_OK) {\n    return utils::Status(Code::INTERNAL, \"Out of memory\");\n  }\n  ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n                 \"updates header to backend: \\\"%V: %V\\\"\", &h->key, &h->value);\n  return utils::Status::OK;\n}", "target": 1}
{"code": "bool Decode(string_view encoded, std::string* raw) {\n  for (auto iter = encoded.begin(); iter != encoded.end(); ++iter) {\n    if (*iter == '%') {\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int h_decimal = 0;\n      if (!HexToDecimal(*iter, &h_decimal)) {\n        return false;\n      }\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int l_decimal = 0;\n      if (!HexToDecimal(*iter, &l_decimal)) {\n        return false;\n      }\n      raw->push_back(static_cast<char>((h_decimal << 4) + l_decimal));\n    } else if (*iter > 127 || *iter < 0) {\n      return false;\n    } else {\n      raw->push_back(*iter);\n    }\n  }\n  return true;\n}", "target": 1}
{"code": " void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n {\n }", "target": 1}
{"code": "static int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym, wordsize;\n\tut32 stype;\n\twordsize = MACH0_(get_bits)(bin) / 8;\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case (T / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return false;\n\t}\n#undef CASE\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j=0, sym=-1; bin->sects[i].reserved1+j < bin->nindirectsyms; j++)\n\t\t\t\tif (idx == bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\tsym = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n\t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static bool acl_group_override(connection_struct *conn,\n\t\t\t\tgid_t prim_gid,\n\t\t\t\tconst char *fname)\n{\n\tSMB_STRUCT_STAT sbuf;\n\tif ((errno != EPERM) && (errno != EACCES)) {\n\t\treturn false;\n\t}\n\tif (lp_acl_group_control(SNUM(conn)) &&\n\t\t\tcurrent_user_in_group(prim_gid)) {\n\t\treturn true;\n\t}\n\tif (lp_dos_filemode(SNUM(conn)) &&\n\t\t\tcan_write_to_file(conn, fname, &sbuf)) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static void mutt_decode_uuencoded (STATE *s, LOFF_T len, int istext, iconv_t cd)\n{\n  char tmps[SHORT_STRING];\n  char linelen, c, l, out;\n  char *pt;\n  char bufi[BUFI_SIZE];\n  size_t k = 0;\n  if (istext)\n    state_set_prefix(s);\n  while (len > 0)\n  {\n    if ((fgets(tmps, sizeof(tmps), s->fpin)) == NULL)\n      return;\n    len -= mutt_strlen(tmps);\n    if ((!mutt_strncmp (tmps, \"begin\", 5)) && ISSPACE (tmps[5]))\n      break;\n  }\n  while (len > 0)\n  {\n    if ((fgets(tmps, sizeof(tmps), s->fpin)) == NULL)\n      return;\n    len -= mutt_strlen(tmps);\n    if (!mutt_strncmp (tmps, \"end\", 3))\n      break;\n    pt = tmps;\n    linelen = decode_byte (*pt);\n    pt++;\n    for (c = 0; c < linelen;)\n    {\n      for (l = 2; l <= 6; l += 2)\n      {\n\tout = decode_byte (*pt) << l;\n\tpt++;\n\tout |= (decode_byte (*pt) >> (6 - l));\n\tbufi[k++] = out;\n\tc++;\n\tif (c == linelen)\n\t  break;\n      }\n      mutt_convert_to_state (cd, bufi, &k, s);\n      pt++;\n    }\n  }\n  mutt_convert_to_state (cd, bufi, &k, s);\n  mutt_convert_to_state (cd, 0, 0, s);\n  state_reset_prefix(s);\n}", "target": 1}
{"code": "static void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n     p=PushLongPixel(MSBEndian,p,&count);\n     if (id == 0x0000040f)\n       {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n         break;\n       }\n     p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "void vp8_deblock(VP8_COMMON *cm, YV12_BUFFER_CONFIG *source,\n                 YV12_BUFFER_CONFIG *post, int q, int low_var_thresh,\n                 int flag) {\n  double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065;\n  int ppl = (int)(level + .5);\n  const MODE_INFO *mode_info_context = cm->show_frame_mi;\n  int mbr, mbc;\n  unsigned char *ylimits = cm->pp_limits_buffer;\n  unsigned char *uvlimits = cm->pp_limits_buffer + 16 * cm->mb_cols;\n  (void)low_var_thresh;\n  (void)flag;\n  if (ppl > 0) {\n    for (mbr = 0; mbr < cm->mb_rows; ++mbr) {\n      unsigned char *ylptr = ylimits;\n      unsigned char *uvlptr = uvlimits;\n      for (mbc = 0; mbc < cm->mb_cols; ++mbc) {\n        unsigned char mb_ppl;\n        if (mode_info_context->mbmi.mb_skip_coeff) {\n          mb_ppl = (unsigned char)ppl >> 1;\n        } else {\n          mb_ppl = (unsigned char)ppl;\n        }\n        memset(ylptr, mb_ppl, 16);\n        memset(uvlptr, mb_ppl, 8);\n        ylptr += 16;\n        uvlptr += 8;\n        mode_info_context++;\n      }\n      mode_info_context++;\n      vpx_post_proc_down_and_across_mb_row(\n          source->y_buffer + 16 * mbr * source->y_stride,\n          post->y_buffer + 16 * mbr * post->y_stride, source->y_stride,\n          post->y_stride, source->y_width, ylimits, 16);\n      vpx_post_proc_down_and_across_mb_row(\n          source->u_buffer + 8 * mbr * source->uv_stride,\n          post->u_buffer + 8 * mbr * post->uv_stride, source->uv_stride,\n          post->uv_stride, source->uv_width, uvlimits, 8);\n      vpx_post_proc_down_and_across_mb_row(\n          source->v_buffer + 8 * mbr * source->uv_stride,\n          post->v_buffer + 8 * mbr * post->uv_stride, source->uv_stride,\n          post->uv_stride, source->uv_width, uvlimits, 8);\n    }\n  } else {\n    vp8_yv12_copy_frame(source, post);\n  }\n}", "target": 1}
{"code": "static void adpt_i386_info(sysInfo_S* si)\n{\n\tswitch (boot_cpu_data.x86) {\n\tcase CPU_386:\n\t\tsi->processorType = PROC_386;\n\t\tbreak;\n\tcase CPU_486:\n\t\tsi->processorType = PROC_486;\n\t\tbreak;\n\tcase CPU_586:\n\t\tsi->processorType = PROC_PENTIUM;\n\t\tbreak;\n\tdefault:  \n\t\tsi->processorType = PROC_PENTIUM;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n        PG(allow_url_fopen) = old_allow_url_fopen;\n        if (ctxt) {\n                ctxt->keepBlanks = 0;\n               ctxt->options -= XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "match_expr(struct search_node_list *head, struct eventlog *evlog, bool last_match)\n{\n    struct search_node *sn;\n    bool res = false, matched = last_match;\n    int rc;\n    debug_decl(match_expr, SUDO_DEBUG_UTIL);\n    STAILQ_FOREACH(sn, head, entries) {\n\tswitch (sn->type) {\n\tcase ST_EXPR:\n\t    res = match_expr(&sn->u.expr, evlog, matched);\n\t    break;\n\tcase ST_CWD:\n\t    if (evlog->cwd != NULL)\n\t\tres = strcmp(sn->u.cwd, evlog->cwd) == 0;\n\t    break;\n\tcase ST_HOST:\n\t    if (evlog->submithost != NULL)\n\t\tres = strcmp(sn->u.host, evlog->submithost) == 0;\n\t    break;\n\tcase ST_TTY:\n\t    if (evlog->ttyname != NULL)\n\t\tres = strcmp(sn->u.tty, evlog->ttyname) == 0;\n\t    break;\n\tcase ST_RUNASGROUP:\n\t    if (evlog->rungroup != NULL)\n\t\tres = strcmp(sn->u.runas_group, evlog->rungroup) == 0;\n\t    break;\n\tcase ST_RUNASUSER:\n\t    if (evlog->runuser != NULL)\n\t\tres = strcmp(sn->u.runas_user, evlog->runuser) == 0;\n\t    break;\n\tcase ST_USER:\n\t    if (evlog->submituser != NULL)\n\t\tres = strcmp(sn->u.user, evlog->submituser) == 0;\n\t    break;\n\tcase ST_PATTERN:\n\t    rc = regexec(&sn->u.cmdre, evlog->command, 0, NULL, 0);\n\t    if (rc && rc != REG_NOMATCH) {\n\t\tchar buf[BUFSIZ];\n\t\tregerror(rc, &sn->u.cmdre, buf, sizeof(buf));\n\t\tsudo_fatalx(\"%s\", buf);\n\t    }\n\t    res = rc == REG_NOMATCH ? 0 : 1;\n\t    break;\n\tcase ST_FROMDATE:\n\t    res = sudo_timespeccmp(&evlog->submit_time, &sn->u.tstamp, >=);\n\t    break;\n\tcase ST_TODATE:\n\t    res = sudo_timespeccmp(&evlog->submit_time, &sn->u.tstamp, <=);\n\t    break;\n\tdefault:\n\t    sudo_fatalx(U_(\"unknown search type %d\"), sn->type);\n\t}\n\tif (sn->negated)\n\t    res = !res;\n\tmatched = sn->or ? (res || last_match) : (res && last_match);\n\tlast_match = matched;\n    }\n    debug_return_bool(matched);\n}", "target": 1}
{"code": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n        assert(path);\n        if (parents)\n                mkdir_parents(path, 0755);\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n        if (fd < 0)\n                return -errno;\n        if (mode > 0) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "mm_malloc(struct mm_master *mm, size_t size)\n{\n\tstruct mm_share *mms, *tmp;\n\tif (size == 0)\n\t\tfatal(\"mm_malloc: try to allocate 0 space\");\n\tif (size > SIZE_MAX - MM_MINSIZE + 1)\n\t\tfatal(\"mm_malloc: size too big\");\n\tsize = ((size + (MM_MINSIZE - 1)) / MM_MINSIZE) * MM_MINSIZE;\n\tRB_FOREACH(mms, mmtree, &mm->rb_free) {\n\t\tif (mms->size >= size)\n\t\t\tbreak;\n\t}\n\tif (mms == NULL)\n\t\treturn (NULL);\n\tmemset(mms->address, 0xd0, size);\n\ttmp = mm_make_entry(mm, &mm->rb_allocated, mms->address, size);\n\tmms->size -= size;\n\tmms->address = (char *)mms->address + size;\n\tif (mms->size == 0) {\n\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\t\tif (mm->mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mm->mmalloc, mms);\n\t}\n\treturn (tmp->address);\n}", "target": 1}
{"code": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}", "target": 1}
{"code": "static void *__dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  struct dma_attrs *attrs)\n{\n\tif (dev == NULL) {\n\t\tWARN_ONCE(1, \"Use an actual device structure for DMA allocation\\n\");\n\t\treturn NULL;\n\t}\n\tif (IS_ENABLED(CONFIG_ZONE_DMA) &&\n\t    dev->coherent_dma_mask <= DMA_BIT_MASK(32))\n\t\tflags |= GFP_DMA;\n\tif (IS_ENABLED(CONFIG_DMA_CMA) && (flags & __GFP_WAIT)) {\n\t\tstruct page *page;\n\t\tvoid *addr;\n\t\tsize = PAGE_ALIGN(size);\n\t\tpage = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT,\n\t\t\t\t\t\t\tget_order(size));\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\t*dma_handle = phys_to_dma(dev, page_to_phys(page));\n\t\taddr = page_address(page);\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(addr, 0, size);\n\t\treturn addr;\n\t} else {\n\t\treturn swiotlb_alloc_coherent(dev, size, dma_handle, flags);\n\t}\n}", "target": 1}
{"code": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}", "target": 1}
{"code": "static inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t\n\t\tanon_vma->parent = anon_vma;\n\t\tanon_vma->root = anon_vma;\n\t}\n\treturn anon_vma;\n}", "target": 1}
{"code": "static long compat_adpt_ioctl(struct file *file,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode;\n\tlong ret;\n\tinode = file_inode(file);\n\tmutex_lock(&adpt_mutex);\n\tswitch(cmd) {\n\t\tcase DPT_SIGNATURE:\n\t\tcase I2OUSRCMD:\n\t\tcase DPT_CTRLINFO:\n\t\tcase DPT_SYSINFO:\n\t\tcase DPT_BLINKLED:\n\t\tcase I2ORESETCMD:\n\t\tcase I2ORESCANCMD:\n\t\tcase (DPT_TARGET_BUSY & 0xFFFF):\n\t\tcase DPT_TARGET_BUSY:\n\t\t\tret = adpt_ioctl(inode, file, cmd, arg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret =  -ENOIOCTLCMD;\n\t}\n\tmutex_unlock(&adpt_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "void BufferQueueConsumer::dump(String8& result, const char* prefix) const {\n const IPCThreadState* ipc = IPCThreadState::self();\n const pid_t pid = ipc->getCallingPid();\n const uid_t uid = ipc->getCallingUid();\n if ((uid != AID_SHELL)\n && !PermissionCache::checkPermission(String16(\n             \"android.permission.DUMP\"), pid, uid)) {\n         result.appendFormat(\"Permission Denial: can't dump BufferQueueConsumer \"\n                 \"from pid=%d, uid=%d\\n\", pid, uid);\n     } else {\n         mCore->dump(result, prefix);\n     }\n}", "target": 1}
{"code": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n\t}\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}", "target": 1}
{"code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\n{\n    auto* zei = entries.getUnchecked (index);\n   #if JUCE_WINDOWS\n    auto entryPath = zei->entry.filename;\n   #else\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\n   #endif\n    if (entryPath.isEmpty())\n        return Result::ok();\n    auto targetFile = targetDirectory.getChildFile (entryPath);\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\n        return targetFile.createDirectory(); \n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\n    if (in == nullptr)\n        return Result::fail (\"Failed to open the zip file for reading\");\n    if (targetFile.exists())\n    {\n        if (! shouldOverwriteFiles)\n            return Result::ok();\n        if (! targetFile.deleteFile())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n    }\n    if (! targetFile.getParentDirectory().createDirectory())\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\n    if (zei->entry.isSymbolicLink)\n    {\n        String originalFilePath (in->readEntireStreamAsString()\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\n    }\n    else\n    {\n        FileOutputStream out (targetFile);\n        if (out.failedToOpen())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n        out << *in;\n    }\n    targetFile.setCreationTime (zei->entry.fileTime);\n    targetFile.setLastModificationTime (zei->entry.fileTime);\n    targetFile.setLastAccessTime (zei->entry.fileTime);\n    return Result::ok();\n}", "target": 1}
{"code": "static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n             break;\n         c++;\n     }\n     if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n         return ret;\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n    *rval = c & s->cbits;\n    return 0;\n}", "target": 1}
{"code": "static int holtekff_init(struct hid_device *hid)\n{\n\tstruct holtekff_device *holtekff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output report found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport = list_entry(report_list->next, struct hid_report, list);\n\tif (report->maxfield < 1 || report->field[0]->report_count != 7) {\n\t\thid_err(hid, \"unexpected output report layout\\n\");\n\t\treturn -ENODEV;\n\t}\n\tholtekff = kzalloc(sizeof(*holtekff), GFP_KERNEL);\n\tif (!holtekff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\tholtekff->field = report->field[0];\n\tholtekff_send(holtekff, hid, stop_all4);\n\tholtekff_send(holtekff, hid, stop_all6);\n\terror = input_ff_create_memless(dev, holtekff, holtekff_play);\n\tif (error) {\n\t\tkfree(holtekff);\n\t\treturn error;\n\t}\n\thid_info(hid, \"Force feedback for Holtek On Line Grip based devices by Anssi Hannula <anssi.hannula@iki.fi>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n    PJ_UNUSED_ARG(ses);\n    *hdr = (pjmedia_rtp_hdr*)pkt;\n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n    if ((*hdr)->x) {\n        if (offset + sizeof (pjmedia_rtp_ext_hdr) > (unsigned)pkt_len)\n            return PJMEDIA_RTP_EINLEN;\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n    if (offset > pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->headend)\n\t\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;\n\t\t\tpsf->headindex = position ;\n\t\t\tbreak ;\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->headindex + position < 0)\n\t\t\t\tbreak ;\n\t\t\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (psf->headindex + position <= psf->headend)\n\t\t\t{\tpsf->headindex += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\t\t\tif (psf->headindex + position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t\n\t\t\t\tpsf->headindex = psf->headend ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\tbreak ;\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;\n\t\t\tbreak ;\n\t\t} ;\n\treturn ;\n} ", "target": 1}
{"code": "void svhandler_flash_pgm_blk(void) {\n  uint32_t beginAddr = _param_1;\n  uint32_t data = _param_2;\n  uint32_t length = _param_3;\n  if (beginAddr + length < beginAddr) return;\n  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&\n       (beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||\n      (((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&\n       ((beginAddr + length) <=\n        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {\n    return;\n  }\n  if (((beginAddr >= BLDR_FLASH_SECT_START) &&\n       (beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||\n      (((beginAddr + length) >= BLDR_FLASH_SECT_START) &&\n       ((beginAddr + length) <=\n        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_program(beginAddr, (uint8_t *)data, length);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "void pin_remove(struct fs_pin *pin)\n{\n\tspin_lock(&pin_lock);\n\thlist_del(&pin->m_list);\n\thlist_del(&pin->s_list);\n\tspin_unlock(&pin_lock);\n\tspin_lock_irq(&pin->wait.lock);\n\tpin->done = 1;\n\twake_up_locked(&pin->wait);\n\tspin_unlock_irq(&pin->wait.lock);\n}", "target": 1}
{"code": "static void adpt_alpha_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_ALPHA;\n}", "target": 1}
{"code": " void red_channel_pipes_add_empty_msg(RedChannel *channel, int msg_type)\n {\n    RingItem *link;\n    RING_FOREACH(link, &channel->clients) {\n         red_channel_client_pipe_add_empty_msg(\n             SPICE_CONTAINEROF(link, RedChannelClient, channel_link),\n             msg_type);\n    }\n}", "target": 1}
{"code": "int ssl_set_hostname( ssl_context *ssl, const char *hostname )\n{\n    if( hostname == NULL )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    ssl->hostname_len = strlen( hostname );\n    if( ssl->hostname_len + 1 == 0 )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    ssl->hostname = polarssl_malloc( ssl->hostname_len + 1 );\n    if( ssl->hostname == NULL )\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    memcpy( ssl->hostname, (const unsigned char *) hostname,\n            ssl->hostname_len );\n    ssl->hostname[ssl->hostname_len] = '\\0';\n    return( 0 );\n}", "target": 1}
{"code": "static PCRE2_SPTR SLJIT_FUNC do_extuni_no_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR bptr;\nuint32_t c;\nGETCHARINC(c, cc);\nlgb = UCD_GRAPHBREAK(c);\nwhile (cc < end_subject)\n  {\n  c = *cc;\n  rgb = UCD_GRAPHBREAK(c);\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0) break;\n  if (lgb == ucp_gbRegionalIndicator && rgb == ucp_gbRegionalIndicator)\n    {\n    ricount = 0;\n    bptr = cc - 1;\n    while (bptr > start_subject)\n      {\n      bptr--;\n      c = *bptr;\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegionalIndicator) break;\n      ricount++;\n      }\n    if ((ricount & 1) != 0) break;  \n    }\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n  cc++;\n  }\nreturn cc;\n}", "target": 1}
{"code": "de_dotdot( char* file )\n    {\n    char* cp;\n    char* cp2;\n    int l;\n    while ( ( cp = strstr( file, \"\n\t{\n\tfor ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )\n\t    continue;\n\t(void) strcpy( cp + 1, cp2 );\n\t}\n    while ( strncmp( file, \"./\", 2 ) == 0 )\n\t(void) memmove( file, file + 2, strlen( file ) - 1 );\n    while ( ( cp = strstr( file, \"/./\") ) != (char*) 0 )\n\t(void) memmove( cp, cp + 2, strlen( file ) - 1 );\n    for (;;)\n\t{\n\twhile ( strncmp( file, \"../\", 3 ) == 0 )\n\t    (void) memmove( file, file + 3, strlen( file ) - 2 );\n\tcp = strstr( file, \"/../\" );\n\tif ( cp == (char*) 0 )\n\t    break;\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\t(void) strcpy( cp2 + 1, cp + 4 );\n\t}\n    while ( ( l = strlen( file ) ) > 3 &&\n\t    strcmp( ( cp = file + l - 3 ), \"/..\" ) == 0 )\n\t{\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\tif ( cp2 < file )\n\t    break;\n\t*cp2 = '\\0';\n\t}\n    }", "target": 1}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}", "target": 1}
{"code": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n    for (i = 0; i < probe_packet->buf_size; i++) {\n        temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if ((temp_buffer & 0xffffff00) != 0x100)\n            continue;\n        if (temp_buffer == VOP_START_CODE)\n            VOP++;\n        else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n            VISO++;\n        else if (temp_buffer < 0x120)\n            VO++;\n        else if (temp_buffer < 0x130)\n            VOL++;\n        else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                 !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}", "target": 1}
{"code": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n \t\tu32 id = new_map->extent[0].lower_first;\n \t\tif (cap_setid == CAP_SETUID) {\n \t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n \t\t\t\treturn true;\n \t\t}\n \t\telse if (cap_setid == CAP_SETGID) {\n \t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n \t\t\t\treturn true;\n \t\t}\n \t}\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "static void consume_one_event(unsigned cpu,\n\t\t\t      struct evtchn_fifo_control_block *control_block,\n\t\t\t      unsigned priority, unsigned long *ready,\n\t\t\t      bool drop)\n{\n\tstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\n\tuint32_t head;\n\tevtchn_port_t port;\n\tevent_word_t *word;\n\thead = q->head[priority];\n\tif (head == 0) {\n\t\tvirt_rmb(); \n\t\thead = control_block->head[priority];\n\t}\n\tport = head;\n\tword = event_word_from_port(port);\n\thead = clear_linked(word);\n\tif (head == 0)\n\t\tclear_bit(priority, ready);\n\tif (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {\n\t\tif (unlikely(drop))\n\t\t\tpr_warn(\"Dropping pending event for port %u\\n\", port);\n\t\telse\n\t\t\thandle_irq_for_port(port);\n\t}\n\tq->head[priority] = head;\n}", "target": 1}
{"code": "compute_tag(dns_name_t *name, dns_rdata_dnskey_t *dnskey, isc_mem_t *mctx,\n\t    dns_keytag_t *tag)\n{\n\tisc_result_t result;\n\tdns_rdata_t rdata = DNS_RDATA_INIT;\n\tunsigned char data[4096];\n\tisc_buffer_t buffer;\n\tdst_key_t *dstkey = NULL;\n\tisc_buffer_init(&buffer, data, sizeof(data));\n\tdns_rdata_fromstruct(&rdata, dnskey->common.rdclass,\n\t\t\t     dns_rdatatype_dnskey, dnskey, &buffer);\n\tresult = dns_dnssec_keyfromrdata(name, &rdata, mctx, &dstkey);\n\tif (result == ISC_R_SUCCESS)\n\t\t*tag = dst_key_id(dstkey);\n\tdst_key_free(&dstkey);\n\treturn (result);\n}", "target": 1}
{"code": "Fraction::Fraction(int32_t num,int32_t den)\n{\n  int32_t g = gcd(num, den);\n  if (num == std::numeric_limits<int32_t>::min() && g == -1) {\n    num++;\n  }\n  if (den == std::numeric_limits<int32_t>::min() && g == -1) {\n    den++;\n  }\n  numerator = num / g;\n  denominator = den / g;\n  while (denominator > MAX_FRACTION_DENOMINATOR) {\n    numerator >>= 1;\n    denominator >>= 1;\n  }\n}", "target": 1}
{"code": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; \n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n    rc = (digp && (p == pend)) ? 0 : -1;\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}", "target": 1}
{"code": "void AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->deleteEvidence(idx);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n     char *password = *passptr;\n    if (!(mask & KADM5_ATTRIBUTES) ||\n         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n         return;\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n    *passptr = NULL;\n}", "target": 1}
{"code": "lyd_new_output(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new(parent, snode, 0);\n}", "target": 1}
{"code": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  \n\tURI_CHAR * write = dest;\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n \t\tconst URI_CHAR * const value = queryList->value;\n \t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n \t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n \t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n \t\tif (dest == NULL) {\n \t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\t\tqueryList = queryList->next;\n\t}\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; \n\t\t}\n\t}\n\treturn URI_SUCCESS;\n}", "target": 1}
{"code": "njs_promise_prototype_then(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t                 ret;\n    njs_value_t               *promise, *fulfilled, *rejected, constructor;\n    njs_object_t              *object;\n    njs_function_t            *function;\n    njs_promise_capability_t  *capability;\n    promise = njs_argument(args, 0);\n    if (njs_slow_path(!njs_is_object(promise))) {\n        goto failed;\n    }\n    object = njs_object_proto_lookup(njs_object(promise), NJS_PROMISE,\n                                     njs_object_t);\n    if (njs_slow_path(object == NULL)) {\n        goto failed;\n    }\n    function = njs_promise_create_function(vm, sizeof(njs_promise_context_t));\n    function->u.native = njs_promise_constructor;\n    njs_set_function(&constructor, function);\n    ret = njs_value_species_constructor(vm, promise, &constructor,\n                                        &constructor);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    capability = njs_promise_new_capability(vm, &constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NJS_ERROR;\n    }\n    fulfilled = njs_arg(args, nargs, 1);\n    rejected = njs_arg(args, nargs, 2);\n    return njs_promise_perform_then(vm, promise, fulfilled, rejected,\n                                    capability);\nfailed:\n    njs_type_error(vm, \"required a promise object\");\n    return NJS_ERROR;\n}", "target": 1}
{"code": "ExecAlterObjectDependsStmt(AlterObjectDependsStmt *stmt, ObjectAddress *refAddress)\n{\n\tObjectAddress address;\n\tObjectAddress refAddr;\n\tRelation\trel;\n\taddress =\n\t\tget_object_address_rv(stmt->objectType, stmt->relation, (List *) stmt->object,\n\t\t\t\t\t\t\t  &rel, AccessExclusiveLock, false);\n\tif (rel)\n\t\ttable_close(rel, NoLock);\n\trefAddr = get_object_address(OBJECT_EXTENSION, (Node *) stmt->extname,\n\t\t\t\t\t\t\t\t &rel, AccessExclusiveLock, false);\n\tAssert(rel == NULL);\n\tif (refAddress)\n\t\t*refAddress = refAddr;\n\trecordDependencyOn(&address, &refAddr, DEPENDENCY_AUTO_EXTENSION);\n\treturn address;\n}", "target": 1}
{"code": "static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n\tut32 i = 0;\n\twhile (buf + i < max && buf[i] != eoc) {\n\t\ti += 1;\n\t}\n\tif (buf[i] != eoc) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}", "target": 1}
{"code": "GF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;", "target": 1}
{"code": "int delete_sdp_line( struct sip_msg * msg, char * s)\n{\n\tchar * start,*end;\n\tif( !s )\n\t\treturn 1;\n\tstart = s;\n\tend  = s;\n\twhile(*start != '\\n')\n\t\tstart--;\n\tstart++;\n\twhile(*end != '\\n')\n\t\tend++;\n\tend++;\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "parse_tsquery(char *buf,\n\t\t\t  PushFunction pushval,\n\t\t\t  Datum opaque,\n\t\t\t  bool isplain)\n{\n\tstruct TSQueryParserStateData state;\n\tint\t\t\ti;\n\tTSQuery\t\tquery;\n\tint\t\t\tcommonlen;\n\tQueryItem  *ptr;\n\tListCell   *cell;\n\tstate.buffer = buf;\n\tstate.buf = buf;\n\tstate.state = (isplain) ? WAITSINGLEOPERAND : WAITFIRSTOPERAND;\n\tstate.count = 0;\n\tstate.polstr = NIL;\n\tstate.valstate = init_tsvector_parser(state.buffer, true, true);\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\tmakepol(&state, pushval, opaque);\n\tclose_tsvector_parser(state.valstate);\n\tif (list_length(state.polstr) == 0)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query doesn't contain lexemes: \\\"%s\\\"\",\n\t\t\t\t\t\tstate.buffer)));\n\t\tquery = (TSQuery) palloc(HDRSIZETQ);\n\t\tSET_VARSIZE(query, HDRSIZETQ);\n\t\tquery->size = 0;\n\t\treturn query;\n\t}\n\tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n\tquery = (TSQuery) palloc0(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = list_length(state.polstr);\n\tptr = GETQUERY(query);\n\ti = 0;\n\tforeach(cell, state.polstr)\n\t{\n\t\tQueryItem  *item = (QueryItem *) lfirst(cell);\n\t\tswitch (item->type)\n\t\t{\n\t\t\tcase QI_VAL:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperand));\n\t\t\t\tbreak;\n\t\t\tcase QI_VALSTOP:\n\t\t\t\tptr[i].type = QI_VALSTOP;\n\t\t\t\tbreak;\n\t\t\tcase QI_OPR:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperator));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized QueryItem type: %d\", item->type);\n\t\t}\n\t\ti++;\n\t}\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\tfindoprnd(ptr, query->size);\n\treturn query;\n}", "target": 1}
{"code": "static inline void fuse_make_bad(struct inode *inode)\n{\n\tset_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);\n}", "target": 1}
{"code": "inline bool loadModule(const char* filename, IR::Module& outModule)\n{\n\tstd::vector<U8> fileBytes;\n\tif(!loadFile(filename, fileBytes)) { return false; }\n\tif(*(U32*)fileBytes.data() == 0x6d736100)\n\t{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }\n\telse\n\t{\n\t\tfileBytes.push_back(0);\n\t\tstd::vector<WAST::Error> parseErrors;\n\t\tif(!WAST::parseModule(\n\t\t\t   (const char*)fileBytes.data(), fileBytes.size(), outModule, parseErrors))\n\t\t{\n\t\t\tLog::printf(Log::error, \"Error parsing WebAssembly text file:\\n\");\n\t\t\treportParseErrors(filename, parseErrors);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}", "target": 1}
{"code": " int devmem_is_allowed(unsigned long pagenr)\n {\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n \t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n }", "target": 1}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tapply_proxy_config(t);\n\terror = git_stream_connect(t->io);\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "smb2_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t *of = NULL;\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t\n\t    &reserved1,\t\t\t\n\t    &reserved2,\t\t\t\n\t    &smb2fid.persistent,\t\n\t    &smb2fid.temporal);\t\t\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\tof = sr->fid_ofile;\n\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t\t\n\t    0); \t\t\n\treturn (SDRC_SUCCESS);\n}", "target": 1}
{"code": "http_splitheader(struct http *hp, int req)\n{\n\tchar *p, *q, **hh;\n\tint n;\n\tchar buf[20];\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\tif (req) {\n\t\tmemset(hp->req, 0, sizeof hp->req);\n\t\thh = hp->req;\n\t} else {\n\t\tmemset(hp->resp, 0, sizeof hp->resp);\n\t\thh = hp->resp;\n\t}\n\tn = 0;\n\tp = hp->rxbuf;\n\twhile (vct_islws(*p))\n\t\tp++;\n\thh[n++] = p;\n\twhile (!vct_islws(*p))\n\t\tp++;\n\tassert(!vct_iscrlf(*p));\n\t*p++ = '\\0';\n\twhile (vct_issp(*p))\t\t\n\t\tp++;\n\tassert(!vct_iscrlf(*p));\n\thh[n++] = p;\n\twhile (!vct_islws(*p))\n\t\tp++;\n\tif (vct_iscrlf(*p)) {\n\t\thh[n++] = NULL;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t} else {\n\t\t*p++ = '\\0';\n\t\twhile (vct_issp(*p))\t\t\n\t\t\tp++;\n\t\thh[n++] = p;\n\t\twhile (!vct_iscrlf(*p))\n\t\t\tp++;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t}\n\tassert(n == 3);\n\twhile (*p != '\\0') {\n\t\tassert(n < MAX_HDR);\n\t\tif (vct_iscrlf(*p))\n\t\t\tbreak;\n\t\thh[n++] = p++;\n\t\twhile (*p != '\\0' && !vct_iscrlf(*p))\n\t\t\tp++;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t}\n\tp += vct_skipcrlf(p);\n\tassert(*p == '\\0');\n\tfor (n = 0; n < 3 || hh[n] != NULL; n++) {\n\t\tsprintf(buf, \"http[%2d] \", n);\n\t\tvtc_dump(hp->vl, 4, buf, hh[n], -1);\n\t}\n}", "target": 1}
{"code": "LoadPage::LoadPage():\n\tjsdelay(200),\n\twindowStatus(\"\"),\n\tzoomFactor(1.0),\n\trepeatCustomHeaders(false),\n\tblockLocalFileAccess(false),\n\tstopSlowScripts(true),\n\tdebugJavascript(false),\n\tloadErrorHandling(abort),\n\tmediaLoadErrorHandling(ignore),\n\tcacheDir(\"\"),\n\tproxyHostNameLookup(false) {};", "target": 1}
{"code": "int JSStream::DoWrite(WriteWrap* w,\n                      uv_buf_t* bufs,\n                      size_t count,\n                      uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n  HandleScope scope(env()->isolate());\n  Context::Scope context_scope(env()->context());\n  Local<Array> bufs_arr = Array::New(env()->isolate(), count);\n  Local<Object> buf;\n  for (size_t i = 0; i < count; i++) {\n    buf = Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();\n    bufs_arr->Set(i, buf);\n  }\n  Local<Value> argv[] = {\n    w->object(),\n    bufs_arr\n  };\n  TryCatch try_catch(env()->isolate());\n  Local<Value> value;\n  int value_int = UV_EPROTO;\n  if (!MakeCallback(env()->onwrite_string(),\n                    arraysize(argv),\n                    argv).ToLocal(&value) ||\n      !value->Int32Value(env()->context()).To(&value_int)) {\n    if (!try_catch.HasTerminated())\n      FatalException(env()->isolate(), try_catch);\n  }\n  return value_int;\n}", "target": 1}
{"code": "int credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\tcredential_clear(c);\n\tproto_end = strstr(url, \":\n\tif (!proto_end)\n\t\treturn 0;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\tif (!at || slash <= at) {\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 1}
{"code": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\tif (pmd_trans_unstable(pmd)) {\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n\t\tgoto out;\n\t}\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\t\tif (pte_none(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { \n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}", "target": 1}
{"code": "struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n \talg = crypto_alg_lookup(name, type, mask);\n \tif (!alg) {\n\t\trequest_module(\"%s\", name);\n \t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n \t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"%s-all\", name);\n \t\talg = crypto_alg_lookup(name, type, mask);\n \t}\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\treturn crypto_larval_add(name, type, mask);\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_advance_n( pj_scanner *scanner,\n\t\t\t\t unsigned N, pj_bool_t skip_ws)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    scanner->curptr += N;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "xml_read_notification(xmlTextReaderPtr reader, void *arg)\n{\n\tstruct rdr_notification_ctx *ctx = arg;\n\txmlReaderTypes type;\n\txmlChar const *name;\n\tint error;\n\terror = 0;\n\tname = xmlTextReaderConstLocalName(reader);\n\ttype = xmlTextReaderNodeType(reader);\n\tswitch (type) {\n\tcase XML_READER_TYPE_ELEMENT:\n\t\tif (xmlStrEqual(name, BAD_CAST RRDP_ELEM_DELTA)) {\n\t\t\terror = parse_notification_delta(reader, ctx);\n\t\t} else if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_SNAPSHOT)) {\n\t\t\terror = parse_doc_data(reader, true, true,\n\t\t\t    &ctx->notification->snapshot);\n\t\t} else if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_NOTIFICATION)) {\n\t\t\terror = parse_global_data(reader,\n\t\t\t    &ctx->notification->global_data, NULL, 0);\n\t\t\trdr_notification_ctx_init(ctx);\n\t\t} else {\n\t\t\treturn pr_val_err(\"Unexpected '%s' element\", name);\n\t\t}\n\t\tbreak;\n\tcase XML_READER_TYPE_END_ELEMENT:\n\t\tif (xmlStrEqual(name, BAD_CAST RRDP_ELEM_NOTIFICATION)) {\n\t\t\terror = order_notification_deltas(ctx);\n\t\t\trdr_notification_ctx_cleanup(ctx);\n\t\t\treturn error; \n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (error) {\n\t\trdr_notification_ctx_cleanup(ctx);\n\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "hb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->symmetric_difference (*other);\n}", "target": 1}
{"code": "void CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n    cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n    cluaopen_globals(_state);\n    execfile(\"dlua/macro.lua\", true, true);\n    execstring(\"chk_startgame = { }\", \"base\");\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n    lua_register(_state, \"crawl_require\", _clua_require);\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}", "target": 1}
{"code": "Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,\n                                  int input_index) {\n  DataType src_out = src->output_type(output_index);\n  DataType dst_in = dst->input_type(input_index);\n  if (!TypesCompatible(dst_in, src_out)) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(), \" was passed \",\n        DataTypeString(src_out), \" from \", src->name(), \":\", output_index,\n        \" incompatible with expected \", DataTypeString(dst_in), \".\");\n  }\n  g_->AddEdge(src, output_index, dst, input_index);\n  return Status::OK();\n}", "target": 1}
{"code": "void sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "static void cleanup_shm_refs(const uint64_t *saved_attr,\n\t\t\t     struct tee_ta_param *param, uint32_t num_params)\n{\n\tsize_t n;\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (saved_attr[n]) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n#ifdef CFG_CORE_DYN_SHM\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n#endif\n\t\t\tmobj_put(param->u[n].mem.mobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "struct tcp_sock_t *tcp_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"callocing this failed\");\n\t\tgoto error;\n\t}\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"sockect open failed\");\n\t\tgoto error;\n\t}\n\tstruct sockaddr_in6 addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_any;\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"Bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"listen failed on socket\");\n\t\tgoto error;\n\t}\n\treturn this;\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "long video_ioctl2(struct file *file,\n\t       unsigned int cmd, unsigned long arg)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tunsigned long n = cmd_input_size(cmd);\n\t\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\t\tgoto out;\n\t\t\tif (n < _IOC_SIZE(cmd))\n\t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\n\t\t} else {\n\t\t\tmemset(parg, 0, _IOC_SIZE(cmd));\n\t\t}\n\t}\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\tif (has_array_args) {\n\t\tmbuf = kmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\terr = __video_do_ioctl(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\tif (has_array_args) {\n\t\t*kernel_ptr = user_ptr;\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_array_args;\n\t}\n\tif (err < 0)\n\t\tgoto out;\nout_array_args:\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\nout:\n\tkfree(mbuf);\n\treturn err;\n}", "target": 1}
{"code": "CURLcode Curl_auth_create_plain_message(struct Curl_easy *data,\n                                        const char *userp,\n                                        const char *passwdp,\n                                        char **outptr, size_t *outlen)\n{\n  CURLcode result;\n  char *plainauth;\n  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n   plen = strlen(passwdp);\n  if((ulen > SIZE_T_MAX/2) || (plen > (SIZE_T_MAX/2 - 2)))\n     return CURLE_OUT_OF_MEMORY;\n   plainlen = 2 * ulen + plen + 2;\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';\n  memcpy(plainauth + ulen + 1, userp, ulen);\n  plainauth[2 * ulen + 1] = '\\0';\n  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);\n  result = Curl_base64_encode(data, plainauth, plainlen, outptr, outlen);\n  free(plainauth);\n  return result;\n}", "target": 1}
{"code": " ip_printts(netdissect_options *ndo,\n            register const u_char *cp, u_int length)\n {\n\tregister u_int ptr;\n\tregister u_int len;\n\tint hoplen;\n\tconst char *type;\n \tif (length < 4) {\n \t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\t\treturn;\n \t}\n \tND_PRINT((ndo, \" TS{\"));\n \thoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n \tif ((length - 4) & (hoplen-1))\n \t\tND_PRINT((ndo, \"[bad length %u]\", length));\n \tptr = cp[2] - 1;\n \tlen = 0;\n \tif (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)\n \t\tND_PRINT((ndo, \"[bad ptr %u]\", cp[2]));\n \tswitch (cp[3]&0xF) {\n \tcase IPOPT_TS_TSONLY:\n \t\tND_PRINT((ndo, \"TSONLY\"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\t\tND_PRINT((ndo, \"TS+ADDR\"));\n\t\tbreak;\n\tcase 2:\n\t\tND_PRINT((ndo, \"PRESPEC2.0\"));\n\t\tbreak;\n\tcase 3:\t\t\t\n\t\tND_PRINT((ndo, \"PRESPEC\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"[bad ts type %d]\", cp[3]&0xF));\n\t\tgoto done;\n\t}\n\ttype = \" \";\n \tfor (len = 4; len < length; len += hoplen) {\n \t\tif (ptr == len)\n \t\t\ttype = \" ^ \";\n \t\tND_PRINT((ndo, \"%s%d@%s\", type, EXTRACT_32BITS(&cp[len+hoplen-4]),\n \t\t       hoplen!=8 ? \"\" : ipaddr_string(ndo, &cp[len])));\n \t\ttype = \" \";\n\t}\ndone:\n\tND_PRINT((ndo, \"%s\", ptr == len ? \" ^ \" : \"\"));\n\tif (cp[3]>>4)\n \t\tND_PRINT((ndo, \" [%d hops not recorded]} \", cp[3]>>4));\n \telse\n \t\tND_PRINT((ndo, \"}\"));", "target": 1}
{"code": "process_bitmap_updates(STREAM s)\n{\n\tuint16 num_updates;\n\tuint16 left, top, right, bottom, width, height;\n\tuint16 cx, cy, bpp, Bpp, compress, bufsize, size;\n\tuint8 *data, *bmpdata;\n\tint i;\n\tin_uint16_le(s, num_updates);\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tin_uint16_le(s, left);\n\t\tin_uint16_le(s, top);\n\t\tin_uint16_le(s, right);\n\t\tin_uint16_le(s, bottom);\n\t\tin_uint16_le(s, width);\n\t\tin_uint16_le(s, height);\n\t\tin_uint16_le(s, bpp);\n\t\tBpp = (bpp + 7) / 8;\n\t\tin_uint16_le(s, compress);\n\t\tin_uint16_le(s, bufsize);\n\t\tcx = right - left + 1;\n\t\tcy = bottom - top + 1;\n\t\tDEBUG((\"BITMAP_UPDATE(l=%d,t=%d,r=%d,b=%d,w=%d,h=%d,Bpp=%d,cmp=%d)\\n\",\n\t\t       left, top, right, bottom, width, height, Bpp, compress));\n\t\tif (!compress)\n\t\t{\n\t\t\tint y;\n\t\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\t\tfor (y = 0; y < height; y++)\n\t\t\t{\n\t\t\t\tin_uint8a(s, &bmpdata[(height - y - 1) * (width * Bpp)],\n\t\t\t\t\t  width * Bpp);\n\t\t\t}\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t\txfree(bmpdata);\n\t\t\tcontinue;\n\t\t}\n\t\tif (compress & 0x400)\n\t\t{\n\t\t\tsize = bufsize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin_uint8s(s, 2);\t\n\t\t\tin_uint16_le(s, size);\n\t\t\tin_uint8s(s, 4);\t\n\t\t}\n\t\tin_uint8p(s, data, size);\n\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n\t\t{\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDEBUG_RDP5((\"Failed to decompress data\\n\"));\n\t\t}\n\t\txfree(bmpdata);\n\t}\n}", "target": 1}
{"code": "void deletesuccessor(file_t **existing, file_t *duplicate, int matchconfirmed,\n      int (*comparef)(file_t *f1, file_t *f2), struct log_info *loginfo)\n{\n  file_t *to_keep;\n  file_t *to_delete;\n  if (comparef(duplicate, *existing) >= 0)\n  {\n    to_keep = *existing;\n    to_delete = duplicate;\n  }\n  else\n  {\n    to_keep = duplicate;\n    to_delete = *existing;\n    *existing = duplicate;\n  }\n  if (!ISFLAG(flags, F_HIDEPROGRESS)) fprintf(stderr, \"\\r%40s\\r\", \" \");\n  if (loginfo)\n    log_begin_set(loginfo);\n  printf(\"   [+] %s\\n\", to_keep->d_name);\n  if (loginfo)\n    log_file_remaining(loginfo, to_keep->d_name);\n  if (matchconfirmed)\n  {\n    if (remove(to_delete->d_name) == 0) {\n      printf(\"   [-] %s\\n\", to_delete->d_name);\n      if (loginfo)\n        log_file_deleted(loginfo, to_delete->d_name);\n    } else {\n      printf(\"   [!] %s \", to_delete->d_name);\n      printf(\"-- unable to delete file!\\n\");\n      if (loginfo)\n        log_file_remaining(loginfo, to_delete->d_name);\n    }\n  }\n  else\n  {\n    printf(\"   [!] %s\\n\", to_delete->d_name);\n    printf(\" -- unable to confirm match; file not deleted!\\n\");\n    if (loginfo)\n      log_file_remaining(loginfo, to_delete->d_name);\n  }\n  if (loginfo)\n    log_end_set(loginfo);\n  printf(\"\\n\");\n}", "target": 1}
{"code": " dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n {\n #ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n \tif (poke_int3_handler(regs))\n \t\treturn;\n \tist_enter(regs);\n \tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n #ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n \t\t\tSIGTRAP) == NOTIFY_STOP)\n \t\tgoto exit;\n\tdebug_stack_usage_inc();\n \tcond_local_irq_enable(regs);\n \tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n \tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\n exit:\n \tist_exit(regs);\n }", "target": 1}
{"code": "static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)\n{\n    AcpiPciHpState *s = opaque;\n     uint32_t val = 0;\n     int bsel = s->hotplug_select;\n    if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n         return 0;\n     }\n    switch (addr) {\n    case PCI_UP_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].up;\n        if (!s->legacy_piix) {\n            s->acpi_pcihp_pci_status[bsel].up = 0;\n        }\n        ACPI_PCIHP_DPRINTF(\"pci_up_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_DOWN_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].down;\n        ACPI_PCIHP_DPRINTF(\"pci_down_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_EJ_BASE:\n        ACPI_PCIHP_DPRINTF(\"pci_features_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_RMV_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;\n        ACPI_PCIHP_DPRINTF(\"pci_rmv_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_SEL_BASE:\n        val = s->hotplug_select;\n        ACPI_PCIHP_DPRINTF(\"pci_sel_read %\" PRIu32 \"\\n\", val);\n    default:\n        break;\n    }\n    return val;\n}", "target": 1}
{"code": "static int xen_netbk_get_extras(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_extra_info *extras,\n\t\t\t\tint work_to_do)\n{\n\tstruct xen_netif_extra_info extra;\n\tRING_IDX cons = vif->tx.req_cons;\n\tdo {\n\t\tif (unlikely(work_to_do-- <= 0)) {\n\t\t\tnetdev_dbg(vif->dev, \"Missing extra info\\n\");\n\t\t\treturn -EBADR;\n\t\t}\n\t\tmemcpy(&extra, RING_GET_REQUEST(&vif->tx, cons),\n\t\t       sizeof(extra));\n\t\tif (unlikely(!extra.type ||\n\t\t\t     extra.type >= XEN_NETIF_EXTRA_TYPE_MAX)) {\n\t\t\tvif->tx.req_cons = ++cons;\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Invalid extra type: %d\\n\", extra.type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&extras[extra.type - 1], &extra, sizeof(extra));\n\t\tvif->tx.req_cons = ++cons;\n\t} while (extra.flags & XEN_NETIF_EXTRA_FLAG_MORE);\n\treturn work_to_do;\n}", "target": 1}
{"code": "file_continue(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    es_ptr pscratch = esp - 2;\n    file_enum *pfen = r_ptr(esp - 1, file_enum);\n    int devlen = esp[-3].value.intval;\n    gx_io_device *iodev = r_ptr(esp - 4, gx_io_device);\n    uint len = r_size(pscratch);\n    uint code;\n    if (len < devlen)\n        return_error(gs_error_rangecheck);     \n    do {\n        memcpy((char *)pscratch->value.bytes, iodev->dname, devlen);\n        code = iodev->procs.enumerate_next(pfen, (char *)pscratch->value.bytes + devlen,\n                    len - devlen);\n        if (code == ~(uint) 0) {    \n            esp -= 5;               \n            return o_pop_estack;\n         } else if (code > len)      \n             return_error(gs_error_rangecheck);\n         else if (iodev != iodev_default(imemory)\n              || (check_file_permissions_reduced(i_ctx_p, (char *)pscratch->value.bytes, code + devlen, iodev, \"PermitFileReading\")) == 0) {\n             push(1);\n             ref_assign(op, pscratch);\n             r_set_size(op, code + devlen);\n            push_op_estack(file_continue);  \n            *++esp = pscratch[2];   \n            return o_push_estack;\n        }\n    } while(1);\n}", "target": 1}
{"code": " static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n {\n     const char *perm = \"add\";\n     return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n }", "target": 1}
{"code": "static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      const struct iovec *iov, loff_t offset,\n\t\t\t      unsigned long nr_segs)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\tsize_t count = iov_length(iov, nr_segs);\n\tloff_t final_size = offset + count;\n\tif (rw == WRITE && final_size <= inode->i_size) {\n\t\tiocb->private = NULL;\n\t\tEXT4_I(inode)->cur_aio_dio = NULL;\n\t\tif (!is_sync_kiocb(iocb)) {\n\t\t\tiocb->private = ext4_init_io_end(inode);\n\t\t\tif (!iocb->private)\n\t\t\t\treturn -ENOMEM;\n\t\t\tEXT4_I(inode)->cur_aio_dio = iocb->private;\n\t\t}\n\t\tret = blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\t inode->i_sb->s_bdev, iov,\n\t\t\t\t\t offset, nr_segs,\n\t\t\t\t\t ext4_get_block_write,\n\t\t\t\t\t ext4_end_io_dio);\n\t\tif (iocb->private)\n\t\t\tEXT4_I(inode)->cur_aio_dio = NULL;\n\t\tif (ret != -EIOCBQUEUED && ret <= 0 && iocb->private) {\n\t\t\text4_free_io_end(iocb->private);\n\t\t\tiocb->private = NULL;\n\t\t} else if (ret > 0 && ext4_test_inode_state(inode,\n\t\t\t\t\t\tEXT4_STATE_DIO_UNWRITTEN)) {\n\t\t\tint err;\n\t\t\terr = ext4_convert_unwritten_extents(inode,\n\t\t\t\t\t\t\t     offset, ret);\n\t\t\tif (err < 0)\n\t\t\t\tret = err;\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t\t}\n\t\treturn ret;\n\t}\n\treturn ext4_ind_direct_IO(rw, iocb, iov, offset, nr_segs);\n}", "target": 1}
{"code": "void BaseAudioContext::Initialize() {\n  if (IsDestinationInitialized())\n    return;\n  FFTFrame::Initialize();\n  audio_worklet_ = AudioWorklet::Create(this);\n   if (destination_node_) {\n     destination_node_->Handler().Initialize();\n     listener_ = AudioListener::Create(*this);\n  }\n}", "target": 1}
{"code": "tiff_document_get_thumbnail (EvDocument      *document,\n\t\t\t     EvRenderContext *rc)\n{\n\tTiffDocument *tiff_document = TIFF_DOCUMENT (document);\n\tint width, height;\n\tint scaled_width, scaled_height;\n\tfloat x_res, y_res;\n\tgint rowstride, bytes;\n\tguchar *pixels = NULL;\n\tGdkPixbuf *pixbuf;\n\tGdkPixbuf *scaled_pixbuf;\n\tGdkPixbuf *rotated_pixbuf;\n\tpush_handlers ();\n\tif (TIFFSetDirectory (tiff_document->tiff, rc->page->index) != 1) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\tif (!TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGEWIDTH, &width)) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\tif (! TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGELENGTH, &height)) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\ttiff_document_get_resolution (tiff_document, &x_res, &y_res);\n\tpop_handlers ();\n\tif (width <= 0 || height <= 0)\n\t\treturn NULL;                \n\tif (width >= INT_MAX / 4)\n\t\treturn NULL;                \n\trowstride = width * 4;\n\tif (height >= INT_MAX / rowstride)\n\t\treturn NULL;                \n\tbytes = height * rowstride;\n\tpixels = g_try_malloc (bytes);\n\tif (!pixels)\n\t\treturn NULL;\n\tpixbuf = gdk_pixbuf_new_from_data (pixels, GDK_COLORSPACE_RGB, TRUE, 8, \n\t\t\t\t\t   width, height, rowstride,\n\t\t\t\t\t   (GdkPixbufDestroyNotify) g_free, NULL);\n\tTIFFReadRGBAImageOriented (tiff_document->tiff,\n\t\t\t\t   width, height,\n\t\t\t\t   (uint32 *)pixels,\n\t\t\t\t   ORIENTATION_TOPLEFT, 0);\n\tpop_handlers ();\n\tev_render_context_compute_scaled_size (rc, width, height * (x_res / y_res),\n\t\t\t\t\t       &scaled_width, &scaled_height);\n\tscaled_pixbuf = gdk_pixbuf_scale_simple (pixbuf,\n\t\t\t\t\t\t scaled_width, scaled_height,\n\t\t\t\t\t\t GDK_INTERP_BILINEAR);\n\tg_object_unref (pixbuf);\n\trotated_pixbuf = gdk_pixbuf_rotate_simple (scaled_pixbuf, 360 - rc->rotation);\n\tg_object_unref (scaled_pixbuf);\n\treturn rotated_pixbuf;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64 weights_size = weights.size();\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 1}
{"code": "eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     WebKitWebFrame *frame;\n     JSGlobalContextRef context;\n     JSObjectRef globalobject;\n    JSStringRef var_name;\n     JSStringRef js_script;\n     JSValueRef js_result;\n    JSStringRef js_result_string;\n    size_t js_result_size;\n    js_init();\n    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));\n     context = webkit_web_frame_get_global_context(frame);\n     globalobject = JSContextGetGlobalObject(context);\n    var_name = JSStringCreateWithUTF8CString(\"Uzbl\");\n    JSObjectSetProperty(context, globalobject, var_name,\n                        JSObjectMake(context, uzbl.js.classref, NULL),\n                        kJSClassAttributeNone, NULL);\n     js_script = JSStringCreateWithUTF8CString(script);\n     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n    if (js_result && !JSValueIsUndefined(context, js_result)) {\n        js_result_string = JSValueToStringCopy(context, js_result, NULL);\n        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);\n        if (js_result_size) {\n            char js_result_utf8[js_result_size];\n            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);\n            g_string_assign(result, js_result_utf8);\n        }\n        JSStringRelease(js_result_string);\n     }\n    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n    JSStringRelease(var_name);\n     JSStringRelease(js_script);\n }", "target": 1}
{"code": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\tmight_sleep();\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\tanon_vma_lock_write(anon_vma);\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\treturn 0;\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const float input_min_float = ctx->input(1).flat<float>()(0);\n    const float input_max_float = ctx->input(2).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &output_min));\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_max));\n    qint32 used_min_quantized;\n    qint32 used_max_quantized;\n    CalculateUsedRange(input, &used_min_quantized, &used_max_quantized);\n    const float used_min_float = std::min(\n        0.0f,\n        QuantizedToFloat(used_min_quantized, input_min_float, input_max_float));\n    const float used_max_float =\n        QuantizedToFloat(used_max_quantized, input_min_float, input_max_float);\n    output_min->flat<float>().setConstant(used_min_float);\n    output_max->flat<float>().setConstant(used_max_float);\n  }", "target": 1}
{"code": "inline typename V::VectorType FBUnserializer<V>::unserializeVector() {\n  p_ += CODE_SIZE;\n  typename V::VectorType ret = V::createVector();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "static int em_ret(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\treturn em_pop(ctxt);\n}", "target": 1}
{"code": "int mnt_fs_is_deleted(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_DELETED;\n}", "target": 1}
{"code": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n}", "target": 1}
{"code": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n \tchar *p2;\n \tstruct debug_data *d = f->private_data;\n\tpdata = kmalloc(cnt, GFP_KERNEL);\n \tif (pdata == NULL)\n \t\treturn 0;\n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n \t\tkfree(pdata);\n \t\treturn 0;\n \t}\n \tp0 = pdata;\n \tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\treturn (ssize_t)cnt;\n}", "target": 1}
{"code": " void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n        ALOGE(\"memset buffer too small: got %lu, expected %zu\", outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \"29422022\");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n return NULL;\n }\n return memset(outHeader->pBuffer, c, len);\n}", "target": 1}
{"code": "void crypto_bignum_free(struct bignum *a)\n{\n\tif (a)\n\t\tpanic();\n}", "target": 1}
{"code": "static void kiocb_batch_free(struct kiocb_batch *batch)\n {\n \tstruct kiocb *req, *n;\n \tlist_for_each_entry_safe(req, n, &batch->head, ki_batch) {\n \t\tlist_del(&req->ki_batch);\n \t\tkmem_cache_free(kiocb_cachep, req);\n \t}\n }", "target": 1}
{"code": "x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)\n{\n\tunsigned int first = 0;\n\tunsigned int last = ARR_SIZE(insn_regs_intel) - 1;\n\tunsigned int mid = ARR_SIZE(insn_regs_intel) / 2;\n\tif (!intel_regs_sorted) {\n\t\tmemcpy(insn_regs_intel_sorted, insn_regs_intel,\n\t\t\t\tsizeof(insn_regs_intel_sorted));\n\t\tqsort(insn_regs_intel_sorted,\n\t\t\t\tARR_SIZE(insn_regs_intel_sorted),\n\t\t\t\tsizeof(struct insn_reg), regs_cmp);\n\t\tintel_regs_sorted = true;\n\t}\n\twhile (first <= last) {\n\t\tif (insn_regs_intel_sorted[mid].insn < id) {\n\t\t\tfirst = mid + 1;\n\t\t} else if (insn_regs_intel_sorted[mid].insn == id) {\n\t\t\tif (access) {\n\t\t\t\t*access = insn_regs_intel_sorted[mid].access;\n\t\t\t}\n\t\t\treturn insn_regs_intel_sorted[mid].reg;\n\t\t} else {\n\t\t\tif (mid == 0)\n\t\t\t\tbreak;\n\t\t\tlast = mid - 1;\n\t\t}\n\t\tmid = (first + last) / 2;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": " Response PageHandler::SetDownloadBehavior(const std::string& behavior,\n                                           Maybe<std::string> download_path) {\n   WebContentsImpl* web_contents = GetWebContents();\n   if (!web_contents)\n     return Response::InternalError();\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Allow &&\n      !download_path.isJust())\n    return Response::Error(\"downloadPath not provided\");\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Default) {\n    DevToolsDownloadManagerHelper::RemoveFromWebContents(web_contents);\n    download_manager_delegate_ = nullptr;\n    return Response::OK();\n  }\n  content::BrowserContext* browser_context = web_contents->GetBrowserContext();\n  DCHECK(browser_context);\n  content::DownloadManager* download_manager =\n      content::BrowserContext::GetDownloadManager(browser_context);\n  download_manager_delegate_ =\n      DevToolsDownloadManagerDelegate::TakeOver(download_manager);\n  DevToolsDownloadManagerHelper::CreateForWebContents(web_contents);\n  DevToolsDownloadManagerHelper* download_helper =\n      DevToolsDownloadManagerHelper::FromWebContents(web_contents);\n  download_helper->SetDownloadBehavior(\n      DevToolsDownloadManagerHelper::DownloadBehavior::DENY);\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Allow) {\n    download_helper->SetDownloadBehavior(\n        DevToolsDownloadManagerHelper::DownloadBehavior::ALLOW);\n    download_helper->SetDownloadPath(download_path.fromJust());\n  }\n  return Response::OK();\n}", "target": 1}
{"code": "dig_t bn_get_prime(int pos) {\n\tif (pos >= BASIC_TESTS) {\n\t\treturn 0;\n\t}\n\treturn primes[pos];\n}", "target": 1}
{"code": "main_get_appheader (xd3_stream *stream, main_file *ifile,\n\t\t    main_file *output, main_file *sfile)\n{\n  uint8_t *apphead;\n  usize_t appheadsz;\n  int ret;\n  if (! option_use_appheader) { return; }\n  ret = xd3_get_appheader (stream, & apphead, & appheadsz);\n  if (ret != 0) { return; }\n  if (appheadsz > 0)\n    {\n      char *start = (char*)apphead;\n      char *slash;\n      int   place = 0;\n      char *parsed[4];\n      memset (parsed, 0, sizeof (parsed));\n      while ((slash = strchr (start, '/')) != NULL)\n\t{\n\t  *slash = 0;\n\t  parsed[place++] = start;\n\t  start = slash + 1;\n\t}\n      parsed[place++] = start;\n      if (place == 2 || place == 4)\n\t{\n\t  main_get_appheader_params (output, parsed, 1, \"output\", ifile);\n\t}\n      if (place == 4)\n\t{\n\t  main_get_appheader_params (sfile, parsed+2, 0, \"source\", ifile);\n\t}\n    }\n  option_use_appheader = 0;\n  return;\n}", "target": 1}
{"code": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\tsprintf(address, \"%s:%s\", url, port);\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\tclear_pool_work(pool);\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int ath6kl_wmi_pstream_timeout_event_rx(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t       int len)\n{\n\tstruct wmi_pstream_timeout_event *ev;\n\tif (len < sizeof(struct wmi_pstream_timeout_event))\n\t\treturn -EINVAL;\n\tev = (struct wmi_pstream_timeout_event *) datap;\n\tspin_lock_bh(&wmi->lock);\n\twmi->stream_exist_for_ac[ev->traffic_class] = 0;\n\twmi->fat_pipe_exist &= ~(1 << ev->traffic_class);\n\tspin_unlock_bh(&wmi->lock);\n\tath6kl_indicate_tx_activity(wmi->parent_dev, ev->traffic_class, false);\n\treturn 0;\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageJpegPtr(gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageJpegCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "void ida_free(struct ida *ida, unsigned int id)\n{\n\tXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\n\tunsigned bit = id % IDA_BITMAP_BITS;\n\tstruct ida_bitmap *bitmap;\n\tunsigned long flags;\n\tif ((int)id < 0)\n\t\treturn;\n\txas_lock_irqsave(&xas, flags);\n\tbitmap = xas_load(&xas);\n\tif (xa_is_value(bitmap)) {\n\t\tunsigned long v = xa_to_value(bitmap);\n\t\tif (bit >= BITS_PER_XA_VALUE)\n\t\t\tgoto err;\n\t\tif (!(v & (1UL << bit)))\n\t\t\tgoto err;\n\t\tv &= ~(1UL << bit);\n\t\tif (!v)\n\t\t\tgoto delete;\n\t\txas_store(&xas, xa_mk_value(v));\n\t} else {\n\t\tif (!test_bit(bit, bitmap->bitmap))\n\t\t\tgoto err;\n\t\t__clear_bit(bit, bitmap->bitmap);\n\t\txas_set_mark(&xas, XA_FREE_MARK);\n\t\tif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\n\t\t\tkfree(bitmap);\ndelete:\n\t\t\txas_store(&xas, NULL);\n\t\t}\n\t}\n\txas_unlock_irqrestore(&xas, flags);\n\treturn;\n err:\n\txas_unlock_irqrestore(&xas, flags);\n\tWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}", "target": 1}
{"code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "target": 1}
{"code": "inline bool ResolveAxis(const int num_dims, const int* axis,\n                        const int64_t num_axis, int* out_axis,\n                        int* out_num_axis) {\n  *out_num_axis = 0;  \n  if (num_dims == 0) {\n    return true;\n  }\n  for (int64_t idx = 0; idx < num_axis; ++idx) {\n    int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];\n    TFLITE_DCHECK(current >= 0 && current < num_dims);\n    bool is_dup = false;\n    for (int j = 0; j < *out_num_axis; ++j) {\n      if (out_axis[j] == current) {\n        is_dup = true;\n        break;\n      }\n    }\n    if (!is_dup) {\n      out_axis[*out_num_axis] = current;\n      *out_num_axis += 1;\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n\tint i;\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)\n\t\treturn 0;\n\tfor (i = 0; i < bin->nsegs; ++i)\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)\n\t\t\treturn bin->segs[i].vmaddr;\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n    if (!batched_input_) {\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    auto batched_splits_top_vec =\n        batched_ragged_input.splits(0).vec<SPLIT_TYPE>();\n    int num_components = batched_splits_top_vec.size() - 1;\n    OP_REQUIRES(context, num_components >= 0,\n                errors::Internal(\"Invalid split argument.\"));\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n    Tensor* encoded_vector;\n    int output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (int i = 0; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }", "target": 1}
{"code": "mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tu32 data_size;\n\tu32 offset;\n\tint err;\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\treturn err;\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");\n\tif (err)\n\t\tgoto free_data;\n\tfor (offset = 0; offset < crdump_size; offset += data_size) {\n\t\tif (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)\n\t\t\tdata_size = crdump_size - offset;\n\t\telse\n\t\t\tdata_size = MLX5_CR_DUMP_CHUNK_SIZE;\n\t\terr = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,\n\t\t\t\t\t      data_size);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}", "target": 1}
{"code": "static int do_i2c_loop(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tint alen;\n\tuint\taddr;\n\tuint\tlength;\n\tu_char\tbytes[16];\n\tint\tdelay;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tlength = 1;\n\tlength = hextoul(argv[3], NULL);\n\tif (length > sizeof(bytes))\n\t\tlength = sizeof(bytes);\n\tdelay = 1000;\n\tif (argc > 3)\n\t\tdelay = dectoul(argv[4], NULL);\n\twhile (1) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, bytes, length);\n#else\n\t\tret = i2c_read(chip, addr, alen, bytes, length);\n#endif\n\t\tif (ret)\n\t\t\ti2c_report_err(ret, I2C_ERR_READ);\n\t\tudelay(delay);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(\n    const GURL& document_url,\n    std::string* error) {\n  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {\n    if (error)\n      *error = errors::kCannotScriptGallery;\n     return true;\n   }\n  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {\n     if (error)\n       *error = errors::kCannotScriptNtp;\n     return true;\n  }\n  return false;\n}", "target": 1}
{"code": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n    SafeStringValue(path);\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n    if (status < 0) {\n\tclose(fd);\n        rsock_sys_fail_path(\"connect(2)\", path);\n    }\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    close(fd);\n            rsock_sys_fail_path(\"listen(2)\", path);\n\t}\n    }\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n    return sock;\n}", "target": 1}
{"code": "static void sdp_copy_raw_data(tCONN_CB* p_ccb, bool offset) {\n unsigned int cpy_len, rem_len;\n uint32_t list_len;\n uint8_t* p;\n uint8_t type;\n#if (SDP_DEBUG_RAW == TRUE)\n uint8_t num_array[SDP_MAX_LIST_BYTE_COUNT];\n uint32_t i;\n for (i = 0; i < p_ccb->list_len; i++) {\n    snprintf((char*)&num_array[i * 2], sizeof(num_array) - i * 2, \"%02X\",\n (uint8_t)(p_ccb->rsp_list[i]));\n }\n  SDP_TRACE_WARNING(\"result :%s\", num_array);\n#endif\n if (p_ccb->p_db->raw_data) {\n    cpy_len = p_ccb->p_db->raw_size - p_ccb->p_db->raw_used;\n    list_len = p_ccb->list_len;\n     p = &p_ccb->rsp_list[0];\n     if (offset) {\n       type = *p++;\n       p = sdpu_get_len_from_type(p, type, &list_len);\n     }\n     if (list_len < cpy_len) {\n       cpy_len = list_len;\n }\n    rem_len = SDP_MAX_LIST_BYTE_COUNT - (unsigned int)(p - &p_ccb->rsp_list[0]);\n if (cpy_len > rem_len) {\n      SDP_TRACE_WARNING(\"rem_len :%d less than cpy_len:%d\", rem_len, cpy_len);\n      cpy_len = rem_len;\n }\n    SDP_TRACE_WARNING(\n \"%s: list_len:%d cpy_len:%d p:%p p_ccb:%p p_db:%p raw_size:%d \"\n \"raw_used:%d raw_data:%p\",\n        __func__, list_len, cpy_len, p, p_ccb, p_ccb->p_db,\n        p_ccb->p_db->raw_size, p_ccb->p_db->raw_used, p_ccb->p_db->raw_data);\n    memcpy(&p_ccb->p_db->raw_data[p_ccb->p_db->raw_used], p, cpy_len);\n    p_ccb->p_db->raw_used += cpy_len;\n }\n}", "target": 1}
{"code": "static void ipmr_destroy_unres(struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\tatomic_dec(&cache_resolve_queue_len);\n\twhile((skb=skb_dequeue(&c->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -ETIMEDOUT;\n\t\t\tnetlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n\tkmem_cache_free(mrt_cachep, c);\n}", "target": 1}
{"code": "static int http1_on_response(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_response_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.status_str && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}", "target": 1}
{"code": "static inline void arch_dup_mmap(struct mm_struct *oldmm,\n\t\t\t\t struct mm_struct *mm)\n{\n\tif (oldmm->context.asce_limit < mm->context.asce_limit)\n\t\tcrst_table_downgrade(mm, oldmm->context.asce_limit);\n}", "target": 1}
{"code": "get_page_size_area_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgpointer         data)\n{\n\tgboolean *got_size = data;\n\t*got_size = TRUE;\n}", "target": 1}
{"code": "void AverageEvalQuantizedInt8(TfLiteContext* context, TfLiteNode* node,\n                              TfLitePoolParams* params, OpData* data,\n                              const TfLiteTensor* input, TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                        \\\n  tflite::PoolParams op_params;                                           \\\n  op_params.stride_height = params->stride_height;                        \\\n  op_params.stride_width = params->stride_width;                          \\\n  op_params.filter_height = params->filter_height;                        \\\n  op_params.filter_width = params->filter_width;                          \\\n  op_params.padding_values.height = data->padding.height;                 \\\n  op_params.padding_values.width = data->padding.width;                   \\\n  op_params.quantized_activation_min = activation_min;                    \\\n  op_params.quantized_activation_max = activation_max;                    \\\n  type::AveragePool(op_params, GetTensorShape(input),                     \\\n                    GetTensorData<int8_t>(input), GetTensorShape(output), \\\n                    GetTensorData<int8_t>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_integer_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_integer_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[4];\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}", "target": 1}
{"code": "mp_dss_print(netdissect_options *ndo,\n             const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_dss *mdss = (const struct mp_dss *) opt;\n        if ((opt_len != mp_dss_len(mdss, 1) &&\n             opt_len != mp_dss_len(mdss, 0)) || flags & TH_SYN)\n                return 0;\n        if (mdss->flags & MP_DSS_F)\n                ND_PRINT((ndo, \" fin\"));\n        opt += 4;\n        if (mdss->flags & MP_DSS_A) {\n                ND_PRINT((ndo, \" ack \"));\n                if (mdss->flags & MP_DSS_a) {\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                } else {\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                }\n        }\n        if (mdss->flags & MP_DSS_M) {\n                ND_PRINT((ndo, \" seq \"));\n                if (mdss->flags & MP_DSS_m) {\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                } else {\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                }\n                ND_PRINT((ndo, \" subseq %u\", EXTRACT_32BITS(opt)));\n                opt += 4;\n                ND_PRINT((ndo, \" len %u\", EXTRACT_16BITS(opt)));\n                opt += 2;\n                if (opt_len == mp_dss_len(mdss, 1))\n                        ND_PRINT((ndo, \" csum 0x%x\", EXTRACT_16BITS(opt)));\n        }\n        return 1;\n}", "target": 1}
{"code": "processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n#ifdef XML_DTD\n  entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (const char *)entity->textPtr;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_FALSE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif \n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE,\n                       XML_ACCOUNT_ENTITY_EXPANSION);\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n#ifdef XML_DTD\n      entityTrackingOnClose(parser, entity, __LINE__);\n#endif \n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}", "target": 1}
{"code": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\tshow(obj, path, name, cb_data);\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.line_number_table_attr.line_number_table = r_list_newf (free);\n\tut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr->info.line_number_table_attr.line_number_table;\n\tif (linenum_len > sz) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->file_offset = curpos;\n\t\tlnattr->size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "int DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info, X509& leaf_cert,\n    const Network::TransportSocketOptions* transport_socket_options) {\n  if (verify_trusted_ca_) {\n    int ret = X509_verify_cert(store_ctx);\n    if (ssl_extended_info) {\n      ssl_extended_info->setCertificateValidationStatus(\n          ret == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n    if (ret <= 0) {\n      stats_.fail_verify_error_.inc();\n      ENVOY_LOG(debug, \"{}\", Utility::getX509VerificationErrorInfo(store_ctx));\n      return allow_untrusted_certificate_ ? 1 : ret;\n    }\n  }\n  Envoy::Ssl::ClientValidationStatus validated =\n      verifyCertificate(&leaf_cert,\n                        transport_socket_options != nullptr\n                            ? transport_socket_options->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        subject_alt_name_matchers_);\n  if (ssl_extended_info) {\n    if (ssl_extended_info->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    } else if (validated != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    }\n  }\n  int validation_status = verify_trusted_ca_\n                              ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                              : validated == Envoy::Ssl::ClientValidationStatus::Validated;\n  return allow_untrusted_certificate_ ? 1 : validation_status;\n}", "target": 1}
{"code": "pci_set_cfgdata16(struct pci_vdev *dev, int offset, uint16_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\t*(uint16_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "pktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tif_printer printer;\n\tconst pktap_header_t *hdr;\n\tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n\tcase PKT_REC_PACKET:\n\t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n\t\t} else {\n\t\t\tif (!ndo->ndo_eflag)\n\t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (hdrlen);\n}", "target": 1}
{"code": "SplashBitmap::SplashBitmap(int widthA, int heightA, int rowPad,\n\t\t\t   SplashColorMode modeA, GBool alphaA,\n\t\t\t   GBool topDown) {\n  width = widthA;\n  height = heightA;\n  mode = modeA;\n  switch (mode) {\n  case splashModeMono1:\n    rowSize = (width + 7) >> 3;\n    break;\n  case splashModeMono8:\n    rowSize = width;\n    break;\n  case splashModeRGB8:\n  case splashModeBGR8:\n    rowSize = width * 3;\n    break;\n  case splashModeXBGR8:\n    rowSize = width * 4;\n    break;\n#if SPLASH_CMYK\n  case splashModeCMYK8:\n    rowSize = width * 4;\n    break;\n#endif\n  }\n  rowSize += rowPad - 1;\n  rowSize -= rowSize % rowPad;\n  data = (SplashColorPtr)gmalloc(rowSize * height);\n  if (!topDown) {\n    data += (height - 1) * rowSize;\n    rowSize = -rowSize;\n  }\n  if (alphaA) {\n    alpha = (Guchar *)gmalloc(width * height);\n  } else {\n    alpha = NULL;\n  }\n}", "target": 1}
{"code": "static void dhcps_send_ack(struct pbuf *packet_buffer)\n{\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n\t\t\t      \t\t\tDHCP_MESSAGE_TYPE_ACK));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t   &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}", "target": 1}
{"code": "static unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned int random_variable = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}", "target": 1}
{"code": "RestStatus RestAuthHandler::execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { \n    return RestStatus::DONE;\n  }\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n  _username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(_username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      std::string jwt = generateJwt(_username, password);\n      resultBuilder.add(\"jwt\", VPackValue(jwt));\n    }\n    _isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}", "target": 1}
{"code": "test_compare_files (const char* tgt, const char *rec)\n{\n  FILE *orig, *recons;\n  static uint8_t obuf[TESTBUFSIZE], rbuf[TESTBUFSIZE];\n  xoff_t offset = 0;\n  size_t i;\n  size_t oc, rc;\n  xoff_t diffs = 0;\n  if ((orig = fopen (tgt, \"r\")) == NULL)\n    {\n      XPR(NT \"open %s failed\\n\", tgt);\n      return get_errno ();\n    }\n  if ((recons = fopen (rec, \"r\")) == NULL)\n    {\n      XPR(NT \"open %s failed\\n\", rec);\n      return get_errno ();\n    }\n  for (;;)\n    {\n      oc = fread (obuf, 1, TESTBUFSIZE, orig);\n      rc = fread (rbuf, 1, TESTBUFSIZE, recons);\n      if (oc != rc)\n\t{\n\t  return XD3_INTERNAL;\n\t}\n      if (oc == 0)\n\t{\n\t  break;\n\t}\n      for (i = 0; i < oc; i += 1)\n\t{\n\t  if (obuf[i] != rbuf[i])\n \t    {\n\t      XPR(NT \"byte %u (read %u @ %\"Q\"u) %d != %d\\n\", \n\t\t  (int)i, (int)oc, offset, obuf[i], rbuf[i]);\n\t      diffs++;\n\t      return XD3_INTERNAL;\n\t    }\n\t}\n      offset += oc;\n    }\n    fclose (orig);\n    fclose (recons);\n    if (diffs != 0) \n      {\n\treturn XD3_INTERNAL;\n      }\n    return 0;\n}", "target": 1}
{"code": "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String&  ,\n                         int  , int  ) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n  int server_count = memcached_server_count(&data->m_memcache);\n  Array return_val;\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n    stat = stats + server_id;\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n  free(stats);\n  return return_val;\n}", "target": 1}
{"code": "ServerSecurityFeature::ServerSecurityFeature(\n    application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "rrd_info_t *rrd_graph_v(\n    int argc,\n    char **argv)\n{\n    image_desc_t im;\n    rrd_info_t *grinfo;\n    rrd_graph_init(&im);\n    rrd_graph_options(argc, argv, &im);\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    if (optind >= argc) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        rrd_set_error(\"missing filename\");\n        return NULL;\n    }\n    if (strlen(argv[optind]) >= MAXPATH) {\n        rrd_set_error(\"filename (including path) too long\");\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    strncpy(im.graphfile, argv[optind], MAXPATH - 1);\n    im.graphfile[MAXPATH - 1] = '\\0';\n    if (strcmp(im.graphfile, \"-\") == 0) {\n        im.graphfile[0] = '\\0';\n    }\n    rrd_graph_script(argc, argv, &im, 1);\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    if (graph_paint(&im) == -1) {\n      rrd_info_free(im.grinfo);\n      im_free(&im);\n      return NULL;\n    }\n    if (im.imginfo && *im.imginfo) {\n        rrd_infoval_t info;\n        char     *path;\n        char     *filename;\n        if (bad_format_imginfo(im.imginfo)) {\n            rrd_info_free(im.grinfo);\n            im_free(&im);\n            rrd_set_error(\"bad format for imginfo\");\n            return NULL;\n        }\n        path = strdup(im.graphfile);\n        filename = basename(path);\n        info.u_str =\n            sprintf_alloc(im.imginfo,\n                          filename,\n                          (long) (im.zoom *\n                                  im.ximg), (long) (im.zoom * im.yimg));\n        grinfo_push(&im, sprintf_alloc(\"image_info\"), RD_I_STR, info);\n        free(info.u_str);\n        free(path);\n    }\n    if (im.rendered_image) {\n        rrd_infoval_t img;\n        img.u_blo.size = im.rendered_image_size;\n        img.u_blo.ptr = im.rendered_image;\n        grinfo_push(&im, sprintf_alloc(\"image\"), RD_I_BLO, img);\n    }\n    grinfo = im.grinfo;\n    im_free(&im);\n    return grinfo;\n}", "target": 1}
{"code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        files[file->file_type] = file;\n    }\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n    return UpdateDerivedKeymapFields(keymap);\n}", "target": 1}
{"code": "static void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\tcrypto_bignum_free(*bn);\n\t*bn = NULL;\n}", "target": 1}
{"code": "ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n    case EXPR_INVERT:\n    case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n        if (ok)\n            *set_rtrn = !*set_rtrn;\n        return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}", "target": 1}
{"code": "GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)\n{\n\tu32 i, orient, sign;\n\ts32 value;\n\tFixed tang[4], delta;\n\ts32 dir;\n\tif (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;\n\tdir = 1;\n\tif(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);\n\torient = gf_bs_read_int(bs, 2);\n\tif ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;\n\tfor(i=0; i<NbComp; i++) {\n\t\tvalue = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );\n\t\tsign = (value >= 0) ? 1 : -1;\n\t\tm_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);\n\t}\n\tdelta = 1;\n\tfor (i=0; i<NbComp; i++) {\n\t\ttang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );\n\t\tdelta += gf_mulfix(tang[i], tang[i]);\n\t}\n\tdelta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );\n\tm_ft[orient] = delta;\n\tfor (i=0; i<NbComp; i++) {\n\t\tm_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "strip_leading_slashes (char *name, int strip_leading)\n{\n  int s = strip_leading;\n  char *p, *n;\n  for (p = n = name;  *p;  p++)\n    {\n      if (ISSLASH (*p))\n\t{\n\t  while (ISSLASH (p[1]))\n\t    p++;\n\t  if (strip_leading < 0 || --s >= 0)\n\t      n = p+1;\n\t}\n    }\n  if ((strip_leading < 0 || s <= 0) && *n)\n    {\n      memmove (name, n, strlen (n) + 1);\n      return true;\n    }\n  else\n    return false;\n}", "target": 1}
{"code": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\tStream_Read_UINT16(s, updateType); \n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\nfail:\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "SCM_DEFINE (scm_mkdir, \"mkdir\", 1, 1, 0,\n            (SCM path, SCM mode),\n\t    \"Create a new directory named by @var{path}.  If @var{mode} is omitted\\n\"\n\t    \"then the permissions of the directory file are set using the current\\n\"\n\t    \"umask.  Otherwise they are set to the decimal value specified with\\n\"\n\t    \"@var{mode}.  The return value is unspecified.\")\n#define FUNC_NAME s_scm_mkdir\n{\n  int rv;\n  mode_t mask;\n  if (SCM_UNBNDP (mode))\n    {\n      mask = umask (0);\n      umask (mask);\n      STRING_SYSCALL (path, c_path, rv = mkdir (c_path, 0777 ^ mask));\n    }\n  else\n    {\n      STRING_SYSCALL (path, c_path, rv = mkdir (c_path, scm_to_uint (mode)));\n    }\n  if (rv != 0)\n    SCM_SYSERROR;\n  return SCM_UNSPECIFIED;\n}", "target": 1}
{"code": "static const struct usb_cdc_union_desc *\nims_pcu_get_cdc_union_desc(struct usb_interface *intf)\n{\n\tconst void *buf = intf->altsetting->extra;\n\tsize_t buflen = intf->altsetting->extralen;\n\tstruct usb_cdc_union_desc *union_desc;\n\tif (!buf) {\n\t\tdev_err(&intf->dev, \"Missing descriptor data\\n\");\n\t\treturn NULL;\n\t}\n\tif (!buflen) {\n\t\tdev_err(&intf->dev, \"Zero length descriptor\\n\");\n\t\treturn NULL;\n\t}\n\twhile (buflen > 0) {\n\t\tunion_desc = (struct usb_cdc_union_desc *)buf;\n\t\tif (union_desc->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t\t    union_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) {\n\t\t\tdev_dbg(&intf->dev, \"Found union header\\n\");\n\t\t\treturn union_desc;\n\t\t}\n\t\tbuflen -= union_desc->bLength;\n\t\tbuf += union_desc->bLength;\n\t}\n\tdev_err(&intf->dev, \"Missing CDC union descriptor\\n\");\n\treturn NULL;", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    auto in0_flat = in0.flat<Tin>();\n    auto in1_flat = in1.flat<Tin>();\n    const Device& eigen_device = ctx->eigen_device<Device>();\n    Tensor* out = nullptr;\n    if (std::is_same<Tin, Tout>::value) {\n      OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                              {0, 1}, 0, in0.shape(), &out));\n    } else {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, in0.shape(), &out));\n    }\n    auto out_flat = out->flat<Tout>();\n    functor::SimpleBinaryFunctor<Device, Functor>()(eigen_device, out_flat,\n                                                    in0_flat, in1_flat);\n  }", "target": 1}
{"code": "static int smtp_command_parse_parameters(struct smtp_command_parser *parser)\n{\n\tconst unsigned char *p, *mp;\n\tuoff_t max_size = (parser->auth_response ?\n\t\tparser->limits.max_auth_size :\n\t\tparser->limits.max_parameters_size);\n\tp = parser->cur + parser->state.poff;\n\twhile (p < parser->end) {\n\t\tunichar_t ch;\n\t\tint nch = 1;\n\t\tif (parser->auth_response)\n\t\t\tch = *p;\n\t\telse {\n\t\t\tnch = uni_utf8_get_char_n(p, (size_t)(p - parser->end),\n\t\t\t\t\t\t  &ch);\n\t\t}\n\t\tif (nch < 0) {\n\t\t\tsmtp_command_parser_error(parser,\n\t\t\t\tSMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,\n\t\t\t\t\"Invalid UTF-8 character in command parameters\");\n\t\t\treturn -1;\n\t\t}\n\t\tif ((parser->auth_response || (ch & 0x80) == 0x00) &&\n\t\t    !smtp_char_is_textstr((unsigned char)ch))\n\t\t\tbreak;\n\t\tp += nch;\n\t}\n\tif (max_size > 0 && (uoff_t)(p - parser->cur) > max_size) {\n\t\tsmtp_command_parser_error(parser,\n\t\t\tSMTP_COMMAND_PARSE_ERROR_LINE_TOO_LONG,\n\t\t\t\"%s line is too long\",\n\t\t\t(parser->auth_response ?\n\t\t\t\t\"AUTH response\" : \"Command\"));\n\t\treturn -1;\n\t}\n\tparser->state.poff = p - parser->cur;\n\tif (p == parser->end)\n\t\treturn 0;\n\tmp = p;\n\tif (mp > parser->cur) {\n\t\twhile (mp > parser->cur && (*(mp-1) == ' ' || *(mp-1) == '\\t'))\n\t\t\tmp--;\n\t}\n\tif (!parser->auth_response && mp > parser->cur && *parser->cur == ' ') {\n\t\tsmtp_command_parser_error(parser,\n\t\t\tSMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,\n\t\t\t\"Duplicate space after command name\");\n\t\treturn -1;\n\t}\n\tparser->state.cmd_params = i_strdup_until(parser->cur, mp);\n\tparser->cur = p;\n\tparser->state.poff = 0;\n\treturn 1;\n}", "target": 1}
{"code": "static int selinux_ptrace_traceme(struct task_struct *parent)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    task_sid_subj(parent), task_sid_obj(current),\n\t\t\t    SECCLASS_PROCESS, PROCESS__PTRACE, NULL);\n}", "target": 1}
{"code": "cpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}", "target": 1}
{"code": "spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "int BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max)\n{\n    int i, j, k = 0;\n    BN_ULONG mask;\n    if (BN_is_zero(a))\n        return 0;\n    for (i = a->top - 1; i >= 0; i--) {\n        if (!a->d[i])\n            continue;\n        mask = BN_TBIT;\n        for (j = BN_BITS2 - 1; j >= 0; j--) {\n            if (a->d[i] & mask) {\n                if (k < max)\n                    p[k] = BN_BITS2 * i + j;\n                k++;\n            }\n            mask >>= 1;\n        }\n    }\n    if (k < max) {\n        p[k] = -1;\n        k++;\n    }\n    return k;\n}", "target": 1}
{"code": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n \tstruct ieee80211_radiotap_header *radiotap_header,\n \tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n {\n \tif (radiotap_header->it_version)\n \t\treturn -EINVAL;\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n \t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader >\n \t\t\t    (unsigned long)iterator->_max_length)\n \t\t\t\treturn -EINVAL;\n \t\t}\n\t\titerator->_arg += sizeof(uint32_t);\n\t}\n\titerator->this_arg = iterator->_arg;\n\treturn 0;\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tif (!sk) {\n\t\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\t\ts->ax25_dev = NULL;\n\t\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tif (sk->sk_socket) {\n\t\t\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\t\t\tax25_dev_put(ax25_dev);\n\t\t\t}\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "gen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n    if (is_splat || n > limit || cursp() >= slimit) { \n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  \n  }\n  return n;\n}", "target": 1}
{"code": "lyd_new_yangdata(const struct lys_module *module, const char *name_template, const char *name)\n{\n    const struct lys_node *schema = NULL, *snode;\n    if (!module || !name_template || !name) {\n        LOGARG;\n        return NULL;\n    }\n    schema = lyp_get_yang_data_template(module, name_template, strlen(name_template));\n    if (!schema) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find yang-data template \\\"%s\\\".\", name_template);\n        return NULL;\n    }\n    if (lys_getnext_data(module, schema, name, strlen(name), LYS_CONTAINER, &snode) || !snode) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a container child of \\\"%s:%s\\\".\",\n               name, module->name, schema->name);\n        return NULL;\n    }\n    return _lyd_new(NULL, snode, 0);\n}", "target": 1}
{"code": "ikev2_sub_print(netdissect_options *ndo,\n\t\tstruct isakmp *base,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ikev2_sub0_print(ndo, base, np,\n\t\t\t\t      ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1}
{"code": "mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tu32 data_size;\n\tu32 offset;\n\tint err;\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\treturn err;\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");\n\tif (err)\n\t\tgoto free_data;\n\tfor (offset = 0; offset < crdump_size; offset += data_size) {\n\t\tif (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)\n\t\t\tdata_size = crdump_size - offset;\n\t\telse\n\t\t\tdata_size = MLX5_CR_DUMP_CHUNK_SIZE;\n\t\terr = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,\n\t\t\t\t\t      data_size);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}", "target": 1}
{"code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n\tbee_t *bee = ic->bee;\n\tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\tif (bee->ui->ft_in_start) {\n\t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n\t} else {\n\t\treturn NULL;\n\t}\n}", "target": 1}
{"code": "SProcXSendExtensionEvent(ClientPtr client)\n {\n     CARD32 *p;\n     int i;\n    xEvent eventT;\n     xEvent *eventP;\n     EventSwapPtr proc;\n    REQUEST(xSendExtensionEventReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);\n    swapl(&stuff->destination);\n    swaps(&stuff->count);\n    if (stuff->length !=\n        bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +\n        bytes_to_int32(stuff->num_events * sizeof(xEvent)))\n        return BadLength;\n    eventP = (xEvent *) &stuff[1];\n    for (i = 0; i < stuff->num_events; i++, eventP++) {\n        proc = EventSwapVector[eventP->u.u.type & 0177];\n        if (proc == NotImplemented)     \n            return BadValue;\n        (*proc) (eventP, &eventT);\n        *eventP = eventT;\n    }\n    p = (CARD32 *) (((xEvent *) &stuff[1]) + stuff->num_events);\n    SwapLongs(p, stuff->count);\n    return (ProcXSendExtensionEvent(client));\n}", "target": 1}
{"code": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "int ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}", "target": 1}
{"code": "void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n{\n\tstruct rdma_umap_priv *priv, *next_priv;\n\tlockdep_assert_held(&ufile->hw_destroy_rwsem);\n\twhile (1) {\n\t\tstruct mm_struct *mm = NULL;\n\t\tmutex_lock(&ufile->umap_lock);\n\t\twhile (!list_empty(&ufile->umaps)) {\n\t\t\tint ret;\n\t\t\tpriv = list_first_entry(&ufile->umaps,\n\t\t\t\t\t\tstruct rdma_umap_priv, list);\n\t\t\tmm = priv->vma->vm_mm;\n\t\t\tret = mmget_not_zero(mm);\n\t\t\tif (!ret) {\n\t\t\t\tlist_del_init(&priv->list);\n\t\t\t\tmm = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\t\tif (!mm)\n\t\t\treturn;\n \t\tdown_write(&mm->mmap_sem);\n \t\tmutex_lock(&ufile->umap_lock);\n \t\tlist_for_each_entry_safe (priv, next_priv, &ufile->umaps,\n \t\t\t\t\t  list) {\n\t\t\tstruct vm_area_struct *vma = priv->vma;\n\t\t\tif (vma->vm_mm != mm)\n\t\t\t\tcontinue;\n\t\t\tlist_del_init(&priv->list);\n\t\t\tzap_vma_ptes(vma, vma->vm_start,\n\t\t\t\t     vma->vm_end - vma->vm_start);\n \t\t\tvma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);\n \t\t}\n \t\tmutex_unlock(&ufile->umap_lock);\n \t\tup_write(&mm->mmap_sem);\n \t\tmmput(mm);\n \t}\n}", "target": 1}
{"code": "static void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; \n    settings.maxconns = 1024;         \n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.oldest_cas = 0;          \n    settings.evict_to_free = 1;       \n    settings.socketpath = NULL;       \n    settings.factor = 1.25;\n    settings.chunk_size = 48;         \n    settings.num_threads = 4;         \n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.reqs_per_event = 20;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; \n    settings.slab_page_size = 1024 * 1024; \n    settings.slab_chunk_size_max = settings.slab_page_size / 2;\n    settings.sasl = false;\n    settings.maxconns_fast = true;\n    settings.lru_crawler = false;\n    settings.lru_crawler_sleep = 100;\n    settings.lru_crawler_tocrawl = 0;\n    settings.lru_maintainer_thread = false;\n    settings.lru_segmented = true;\n    settings.hot_lru_pct = 20;\n    settings.warm_lru_pct = 40;\n    settings.hot_max_factor = 0.2;\n    settings.warm_max_factor = 2.0;\n    settings.inline_ascii_response = false;\n    settings.temp_lru = false;\n    settings.temporary_ttl = 61;\n    settings.idle_timeout = 0; \n    settings.hashpower_init = 0;\n    settings.slab_reassign = true;\n    settings.slab_automove = 1;\n    settings.slab_automove_ratio = 0.8;\n    settings.slab_automove_window = 30;\n    settings.shutdown_command = false;\n    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;\n    settings.flush_enabled = true;\n    settings.dump_enabled = true;\n    settings.crawls_persleep = 1000;\n    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;\n    settings.logger_buf_size = LOGGER_BUF_SIZE;\n    settings.drop_privileges = true;\n#ifdef MEMCACHED_DEBUG\n    settings.relaxed_privileges = false;\n#endif\n}", "target": 1}
{"code": "int AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous)\n{\n\tint nr, todo;\n\ts64 pos;\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tnr = 0; \n\tif (bytes==0) {\n\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t}\n\t*continuous = 1;\n\twhile(bytes>0)\n\t{\n\t\ts64 ret;\n\t\tint left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb);\n\t\tif(left==0)\n\t\t{\n\t\t\tif(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n\t\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t\t\t*continuous = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(bytes<left)\n\t\t\ttodo = bytes;\n\t\telse\n\t\t\ttodo = left;\n\t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n\t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n\t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n\t\t{\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n\t\t\tAVI_errno = AVI_ERR_READ;\n\t\t\treturn -1;\n\t\t}\n\t\tbytes -= todo;\n\t\tnr    += todo;\n\t\tAVI->track[AVI->aptr].audio_posb += todo;\n\t}\n\treturn nr;\n}", "target": 1}
{"code": "int use_env()\n{\n    int indent;\n    size_t flags = 0;\n    json_t *json;\n    json_error_t error;\n    #ifdef _WIN32\n    _setmode(_fileno(stdout), _O_BINARY);\n    _setmode(_fileno(stderr), _O_BINARY);\n    #endif\n    indent = getenv_int(\"JSON_INDENT\");\n    if(indent < 0 || indent > 255) {\n        fprintf(stderr, \"invalid value for JSON_INDENT: %d\\n\", indent);\n        return 2;\n    }\n    if(indent > 0)\n        flags |= JSON_INDENT(indent);\n    if(getenv_int(\"JSON_COMPACT\") > 0)\n        flags |= JSON_COMPACT;\n    if(getenv_int(\"JSON_ENSURE_ASCII\"))\n        flags |= JSON_ENSURE_ASCII;\n    if(getenv_int(\"JSON_PRESERVE_ORDER\"))\n        flags |= JSON_PRESERVE_ORDER;\n    if(getenv_int(\"JSON_SORT_KEYS\"))\n         flags |= JSON_SORT_KEYS;\n    if(getenv_int(\"STRIP\")) {\n        size_t size = 0, used = 0;\n        char *buffer = NULL;\n        while(1) {\n            size_t count;\n            size = (size == 0 ? 128 : size * 2);\n            buffer = realloc(buffer, size);\n            if(!buffer) {\n                fprintf(stderr, \"Unable to allocate %d bytes\\n\", (int)size);\n                return 1;\n            }\n            count = fread(buffer + used, 1, size - used, stdin);\n            if(count < size - used) {\n                buffer[used + count] = '\\0';\n                break;\n            }\n            used += count;\n        }\n        json = json_loads(strip(buffer), 0, &error);\n        free(buffer);\n    }\n    else\n        json = json_loadf(stdin, 0, &error);\n    if(!json) {\n        fprintf(stderr, \"%d %d %d\\n%s\\n\",\n            error.line, error.column,\n            error.position, error.text);\n        return 1;\n    }\n    json_dumpf(json, stdout, flags);\n    json_decref(json);\n    return 0;\n}", "target": 1}
{"code": "gopherSendRequest(int, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *)data;\n    MemBuf mb;\n    mb.init();\n    if (gopherState->type_id == GOPHER_CSO) {\n        const char *t = strchr(gopherState->request, '?');\n        if (t)\n            ++t;        \n        else\n            t = \"\";\n        mb.appendf(\"query %s\\r\\nquit\", t);\n    } else {\n        if (gopherState->type_id == GOPHER_INDEX) {\n            if (char *t = strchr(gopherState->request, '?'))\n                *t = '\\t';\n        }\n        mb.append(gopherState->request, strlen(gopherState->request));\n    }\n    mb.append(\"\\r\\n\", 2);\n    debugs(10, 5, gopherState->serverConn);\n    AsyncCall::Pointer call = commCbCall(5,5, \"gopherSendComplete\",\n                                         CommIoCbPtrFun(gopherSendComplete, gopherState));\n    Comm::Write(gopherState->serverConn, &mb, call);\n    if (!gopherState->entry->makePublic())\n        gopherState->entry->makePrivate(true);\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif(im->trueColor) {\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif(!pim) {\n\t\t\treturn;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\tGIFEncode(\n\t    out, tim->sx, tim->sy, interlace, 0, tim->transparent, BitsPerPixel,\n\t    tim->red, tim->green, tim->blue, tim);\n\tif(pim) {\n\t\tgdImageDestroy(\tpim);\n\t}\n}", "target": 1}
{"code": "cnt_recv_prep(struct req *req, const char *ci)\n{\n\tconst char *xff;\n\tif (req->restarts == 0) {\n\t\thttp_CollectHdr(req->http, H_X_Forwarded_For);\n\t\tif (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {\n\t\t\thttp_Unset(req->http, H_X_Forwarded_For);\n\t\t\thttp_PrintfHeader(req->http, \"X-Forwarded-For: %s, %s\",\n\t\t\t    xff, ci);\n\t\t} else {\n\t\t\thttp_PrintfHeader(req->http, \"X-Forwarded-For: %s\", ci);\n\t\t}\n\t\thttp_CollectHdr(req->http, H_Cache_Control);\n\t\treq->director_hint = VCL_DefaultDirector(req->vcl);\n\t\treq->d_ttl = -1;\n\t\treq->d_grace = -1;\n\t\treq->disable_esi = 0;\n\t\treq->hash_always_miss = 0;\n\t\treq->hash_ignore_busy = 0;\n\t\treq->client_identity = NULL;\n\t\treq->storage = NULL;\n\t}\n\treq->vdc->retval = 0;\n\treq->is_hit = 0;\n\treq->is_hitmiss = 0;\n\treq->is_hitpass = 0;\n}", "target": 1}
{"code": "void close_all_sockets(atransport* t) {\n    asocket* s;\n    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n            local_socket_close(s);\n             goto restart;\n         }\n     }\n}", "target": 1}
{"code": "static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct hidp_connadd_req ca;\n\tstruct hidp_conndel_req cd;\n\tstruct hidp_connlist_req cl;\n\tstruct hidp_conninfo ci;\n\tstruct socket *csock;\n\tstruct socket *isock;\n\tint err;\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\tswitch (cmd) {\n\tcase HIDPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);\n\t\tif (!csock)\n\t\t\treturn err;\n\t\tisock = sockfd_lookup(ca.intr_sock, &err);\n\t\tif (!isock) {\n \t\t\tsockfd_put(csock);\n \t\t\treturn err;\n \t\t}\n \t\terr = hidp_connection_add(&ca, csock, isock);\n \t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\terr = -EFAULT;\n\t\tsockfd_put(csock);\n\t\tsockfd_put(isock);\n\t\treturn err;\n\tcase HIDPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\t\treturn hidp_connection_del(&cd);\n\tcase HIDPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\t\terr = hidp_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tcase HIDPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\terr = hidp_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}", "target": 1}
{"code": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n  int i;\n  int count;\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n  array = object_as_array(object);\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n    array->items->count = count;\n  }\n  item->parent = object;\n  array->items->objects[index] = item;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "static int r_cmd_java_call(void *user, const char *input) {\n\tRCore *core = (RCore *) user;\n\tint res = false;\n\tut32 i = 0;\n\tif (strncmp (input, \"java\", 4)) {\n\t\treturn false;\n\t}\n\tif (input[4] != ' ') {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\tfor (; i < END_CMDS; i++) {\n\t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n\t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));\n\t\tif (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {\n\t\t\tconst char *cmd = input + 5 + JAVA_CMDS[i].name_len;\n\t\t\tif (*cmd && *cmd == ' ') {\n\t\t\t\tcmd++;\n\t\t\t}\n\t\t\tres =  JAVA_CMDS[i].handler (core, cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "}\nvoid print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)\n{\n\tu32 i, count;\n\tcount =  gf_isom_get_udta_count(file, track_number);\n\tif (!count) return;\n\tif (has_itags) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 type;\n\t\t\tbin128 uuid;\n\t\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\t\tif (type == GF_ISOM_BOX_TYPE_META) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) return;\n\t}\n\tfprintf(stderr, \"%d UDTA types: \", count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}", "target": 1}
{"code": "sf_open_virtual\t(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)\n{\tSF_PRIVATE \t*psf ;\n\tif (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_read in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_write in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tpsf->virtual_io = SF_TRUE ;\n\tpsf->vio = *sfvirtual ;\n\tpsf->vio_user_data = user_data ;\n\tpsf->file.mode = mode ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n  if (!p_env) return NULL;\n  if (p_env->b_cdtext_error) return NULL;\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n       if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n         p_env->b_cdtext_error = true;\n        cdtext_destroy (p_env->cdtext);\n         free(p_env->cdtext);\n         p_env->cdtext = NULL;\n       }\n      }\n      free(p_cdtext_data);\n    }\n  }", "target": 1}
{"code": "void dev_load(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\trcu_read_lock();\n\tdev = dev_get_by_name_rcu(net, name);\n\trcu_read_unlock();\n\tif (!dev && capable(CAP_NET_ADMIN))\n\t\trequest_module(\"%s\", name);\n}", "target": 1}
{"code": "static Jsi_RC SysTimesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    int i, n=1, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueIsBoolean(interp, func)) {\n        bool bv;\n        if (argc != 1)\n            return Jsi_LogError(\"bool must be only arg\");\n        Jsi_GetBoolFromValue(interp, func, &bv);\n        double now = jsi_GetTimestamp();\n        if (bv)\n            interp->timesStart = now;\n        else {\n            char buf[100];\n            snprintf(buf, sizeof(buf), \" (times = %.6f sec)\\n\", (now-interp->timesStart));\n            Jsi_Puts(interp, jsi_Stderr, buf, -1);\n        }\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Wide diff, start, end;\n    if (!Jsi_ValueIsFunction(interp, func))\n        return Jsi_LogError(\"arg1: expected function|bool\");\n    if (argc > 1 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n) != JSI_OK)\n        return JSI_ERROR;\n    if (n<=0) \n        return Jsi_LogError(\"count not > 0: %d\", n);\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    start = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    for (i=0; i<n && rc == JSI_OK; i++) {\n        rc = Jsi_FunctionInvoke(interp, func, NULL, ret, NULL);\n    }\n    gettimeofday(&tv, NULL);\n    end = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    diff = (end - start);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)diff);\n    return rc;\n}", "target": 1}
{"code": "void ComparisonQuantized(const TfLiteTensor* input1, const TfLiteTensor* input2,\n                         TfLiteTensor* output, bool requires_broadcast) {\n  if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n    auto input1_offset = -input1->params.zero_point;\n    auto input2_offset = -input2->params.zero_point;\n    const int left_shift = 8;\n    int32 input1_multiplier;\n    int input1_shift;\n    QuantizeMultiplierSmallerThanOneExp(input1->params.scale,\n                                        &input1_multiplier, &input1_shift);\n    int32 input2_multiplier;\n    int input2_shift;\n    QuantizeMultiplierSmallerThanOneExp(input2->params.scale,\n                                        &input2_multiplier, &input2_shift);\n    ComparisonParams op_params;\n    op_params.left_shift = left_shift;\n    op_params.input1_offset = input1_offset;\n    op_params.input1_multiplier = input1_multiplier;\n    op_params.input1_shift = input1_shift;\n    op_params.input2_offset = input2_offset;\n    op_params.input2_multiplier = input2_multiplier;\n    op_params.input2_shift = input2_shift;\n    if (requires_broadcast) {\n      reference_ops::BroadcastComparison4DSlowWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    } else {\n      reference_ops::ComparisonWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    }\n  }\n}", "target": 1}
{"code": "int MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tms_adpcm_state decoderState[2];\n\tms_adpcm_state *state[2];\n\tint channelCount = m_track->f.channelCount;\n\tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictorIndex = *encoded++;\n\t\tassert(state[i]->predictorIndex < m_numCoefficients);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\t\tcode = *encoded >> 4;\n\t\tnewSample = decodeSample(*state[0], code, coefficient[0]);\n\t\t*decoded++ = newSample;\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = decodeSample(*state[1], code, coefficient[1]);\n\t\t*decoded++ = newSample;\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\treturn outputLength;\n}", "target": 1}
{"code": "choose_windows(s)\nconst char *s;\n{\n    register int i;\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' == winchoices[i].procs->name[0])\n            continue;\n        if ('-' == winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            windowprocs = *winchoices[i].procs;\n            if (last_winchoice && last_winchoice->ini_routine)\n                (*last_winchoice->ini_routine)(WININIT_UNDO);\n            if (winchoices[i].ini_routine)\n                (*winchoices[i].ini_routine)(WININIT);\n            last_winchoice = &winchoices[i];\n            return;\n        }\n    }\n    if (!windowprocs.win_raw_print)\n        windowprocs.win_raw_print = def_raw_print;\n    if (!windowprocs.win_wait_synch)\n        windowprocs.win_wait_synch = def_wait_synch;\n    if (!winchoices[0].procs) {\n        raw_printf(\"No window types?\");\n        nh_terminate(EXIT_FAILURE);\n    }\n    if (!winchoices[1].procs) {\n        config_error_add(\n                     \"Window type %s not recognized.  The only choice is: %s\",\n                         s, winchoices[0].procs->name);\n    } else {\n        char buf[BUFSZ];\n        boolean first = TRUE;\n        buf[0] = '\\0';\n        for (i = 0; winchoices[i].procs; i++) {\n            if ('+' == winchoices[i].procs->name[0])\n                continue;\n            if ('-' == winchoices[i].procs->name[0])\n                continue;\n            Sprintf(eos(buf), \"%s%s\",\n                    first ? \"\" : \", \", winchoices[i].procs->name);\n            first = FALSE;\n        }\n        config_error_add(\"Window type %s not recognized.  Choices are:  %s\",\n                         s, buf);\n    }\n    if (windowprocs.win_raw_print == def_raw_print\n            || WINDOWPORT(\"safe-startup\"))\n        nh_terminate(EXIT_SUCCESS);\n}", "target": 1}
{"code": " void altivec_unavailable_exception(struct pt_regs *regs)\n {\n#if !defined(CONFIG_ALTIVEC)\n \tif (user_mode(regs)) {\n \t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n \t\treturn;\n \t}\n#endif\n \tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n \t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n \tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}", "target": 1}
{"code": "void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stw_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "static bool l2cap_check_enc_key_size(struct hci_conn *hcon)\n{\n\treturn (!test_bit(HCI_CONN_ENCRYPT, &hcon->flags) ||\n\t\thcon->enc_key_size > HCI_MIN_ENC_KEY_SIZE);\n}", "target": 1}
{"code": "virDomainGetTime(virDomainPtr dom,\n                 long long *seconds,\n                 unsigned int *nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",\n                     seconds, nseconds, flags);\n     virResetLastError();\n     virCheckDomainReturn(dom, -1);\n     if (dom->conn->driver->domainGetTime) {\n         int ret = dom->conn->driver->domainGetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}", "target": 1}
{"code": "static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *par, char *attribute_content, GF_Err *out_e)\n{\n\tchar *content = attribute_content;\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"defer\")) {\n\t\tpar->defer = 1;\n\t\tcontent += 4;\n\t} else {\n\t\tcontent = attribute_content;\n\t}\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"none\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_NONE;\n\t\tcontent+=4;\n\t} else if (strstr(content, \"xMinYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX;\n\t\tcontent+=8;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\twhile (*content == ' ') content++;\n\tif (*content == 0) return;\n\tif (strstr(content, \"meet\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_MEET;\n\t} else if (strstr(content, \"slice\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_SLICE;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}", "target": 1}
{"code": " void BookmarksIOFunction::ShowSelectFileDialog(\n     ui::SelectFileDialog::Type type,\n     const base::FilePath& default_path) {\n   AddRef();\n  WebContents* web_contents = dispatcher()->delegate()->\n      GetAssociatedWebContents();\n  select_file_dialog_ = ui::SelectFileDialog::Create(\n      this, new ChromeSelectFilePolicy(web_contents));\n  ui::SelectFileDialog::FileTypeInfo file_type_info;\n  file_type_info.extensions.resize(1);\n  file_type_info.extensions[0].push_back(FILE_PATH_LITERAL(\"html\"));\n  if (type == ui::SelectFileDialog::SELECT_OPEN_FILE)\n    file_type_info.support_drive = true;\n  select_file_dialog_->SelectFile(type,\n                                  string16(),\n                                  default_path,\n                                  &file_type_info,\n                                  0,\n                                  FILE_PATH_LITERAL(\"\"),\n                                  NULL,\n                                  NULL);\n}", "target": 1}
{"code": "static void set_k_acc(struct SYMBOL *s)\n{\n\tint i, j, nacc;\n\tchar accs[8], pits[8];\n\tstatic char sharp_tb[8] = {26, 23, 27, 24, 21, 25, 22};\n\tstatic char flat_tb[8] = {22, 25, 21, 24, 20, 23, 26};\n\tif (s->u.key.sf > 0) {\n\t\tfor (nacc = 0; nacc < s->u.key.sf; nacc++) {\n\t\t\taccs[nacc] = A_SH;\n\t\t\tpits[nacc] = sharp_tb[nacc];\n\t\t}\n\t} else {\n\t\tfor (nacc = 0; nacc < -s->u.key.sf; nacc++) {\n\t\t\taccs[nacc] = A_FT;\n\t\t\tpits[nacc] = flat_tb[nacc];\n\t\t}\n\t}\n\tfor (i = 0; i < s->u.key.nacc; i++) {\n\t\tfor (j = 0; j < nacc; j++) {\n\t\t\tif (pits[j] == s->u.key.pits[i]) {\n\t\t\t\taccs[j] = s->u.key.accs[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == nacc) {\n\t\t\taccs[j] = s->u.key.accs[i];\n\t\t\tpits[j] = s->u.key.pits[i];\n\t\t\tnacc++;\t\t\n\t\t}\n\t}\n\tfor (i = 0; i < nacc; i++) {\n\t\ts->u.key.accs[i] = accs[i];\n\t\ts->u.key.pits[i] = pits[i];\n\t}\n\ts->u.key.nacc = nacc;\n}", "target": 1}
{"code": "static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)\n{\n\tuint64_t max_vars = PG(max_input_vars);\n\tvars->ptr = vars->str.c;\n\tvars->end = vars->str.c + vars->str.len;\n\twhile (add_post_var(arr, vars, eof TSRMLS_CC)) {\n\t\tif (++vars->cnt > max_vars) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\t\"Input variables exceeded %\" PRIu64 \". \"\n\t\t\t\t\t\"To increase the limit change max_input_vars in php.ini.\",\n\t\t\t\t\tmax_vars);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\tif (!eof) {\n\t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n\t}\n\treturn SUCCESS;\n}", "target": 1}
{"code": "kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code)\n        return code;\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n    return 0;\n}", "target": 1}
{"code": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        num_key_aliases++;\n    }\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}", "target": 1}
{"code": "decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \n\tif (0 == plen) {\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\tif (32 > plen)\n\t\treturn -1;\n        plen-=32; \n\tif (64 < plen)\n\t\treturn -1;\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\treturn 5 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::AccessibilityScrollToPoint(\n    int acc_obj_id, gfx::Point point) {\n  if (!host_)\n    return;\n  host_->AccessibilityScrollToPoint(acc_obj_id, point);\n}", "target": 0}
{"code": "static ssize_t disk_range_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\treturn sprintf(buf, \"%d\\n\", disk->minors);\n}", "target": 0}
{"code": "void RenderView::OnNotifyRendererViewType(ViewType::Type type) {\n  if (view_type_ != ViewType::INVALID) {\n    if (type == ViewType::EXTENSION_MOLE ||\n        type == ViewType::EXTENSION_TOOLSTRIP) {\n      ExtensionProcessBindings::SetViewType(webview(), type);\n    }\n  }\n  view_type_ = type;\n}", "target": 0}
{"code": "PgDatabase *register_auto_database(const char *name)\n{\n\tPgDatabase *db;\n\tint len;\n\tchar *cs;\n\tif (!cf_autodb_connstr)\n\t\treturn NULL;\n\tlen = strlen(cf_autodb_connstr);\n\tcs = malloc(len + 1);\n\tif (!cs)\n\t\treturn NULL;\n\tmemcpy(cs, cf_autodb_connstr, len + 1);\n\tparse_database(NULL, (char*)name, cs);\n\tfree(cs);\n\tdb = find_database(name);\n\tif (db) {\n\t\tdb->db_auto = 1;\n\t\tif (db->pool_size < 0)\n\t\t\tdb->pool_size = cf_default_pool_size;\n\t\tif (db->res_pool_size < 0)\n\t\t\tdb->res_pool_size = cf_res_pool_size;\n\t}\n\treturn db;\n}", "target": 0}
{"code": "static void draw_fill_color_rgb( wmfAPI* API, const wmfRGB* rgb )\n{\n  PixelWand\n    *fill_color;\n  fill_color=NewPixelWand();\n  PixelSetRedQuantum(fill_color,ScaleCharToQuantum(rgb->r));\n  PixelSetGreenQuantum(fill_color,ScaleCharToQuantum(rgb->g));\n  PixelSetBlueQuantum(fill_color,ScaleCharToQuantum(rgb->b));\n  PixelSetAlphaQuantum(fill_color,OpaqueAlpha);\n  DrawSetFillColor(WmfDrawingWand,fill_color);\n  fill_color=DestroyPixelWand(fill_color);\n}", "target": 0}
{"code": "void HTMLMediaElement::ClearWeakMembers(Visitor* visitor) {\n  if (!ThreadHeap::IsHeapObjectAlive(audio_source_node_)) {\n    GetAudioSourceProvider().SetClient(nullptr);\n    audio_source_node_ = nullptr;\n  }\n}", "target": 0}
{"code": "void V8DOMWrapper::setHiddenWindowReference(Frame* frame, const int internalIndex, v8::Handle<v8::Object> jsObject)\n{\n    if (!frame)\n        return; \n    v8::Handle<v8::Context> context = getWrapperContext(frame);\n    if (context.IsEmpty())\n        return;\n    ASSERT(internalIndex < V8Custom::kDOMWindowInternalFieldCount);\n    v8::Handle<v8::Object> global = context->Global();\n    global = V8DOMWrapper::lookupDOMWrapper(V8ClassIndex::DOMWINDOW, global);\n    ASSERT(!global.IsEmpty());\n    ASSERT(global->GetInternalField(internalIndex)->IsUndefined());\n    global->SetInternalField(internalIndex, jsObject);\n}", "target": 0}
{"code": "parse_EXIT(char *arg OVS_UNUSED, const struct ofpact_parse_params *pp)\n{\n    ofpact_put_EXIT(pp->ofpacts);\n    return NULL;\n}", "target": 0}
{"code": "    const XmpData& Image::xmpData() const\n    {\n        return xmpData_;\n    }", "target": 0}
{"code": "static int do_check_common(struct bpf_verifier_env *env, int subprog)\n{\n\tbool pop_log = !(env->log.level & BPF_LOG_LEVEL2);\n\tstruct bpf_verifier_state *state;\n\tstruct bpf_reg_state *regs;\n\tint ret, i;\n\tenv->prev_linfo = NULL;\n\tenv->pass_cnt++;\n\tstate = kzalloc(sizeof(struct bpf_verifier_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\tstate->curframe = 0;\n\tstate->speculative = false;\n\tstate->branches = 1;\n\tstate->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);\n\tif (!state->frame[0]) {\n\t\tkfree(state);\n\t\treturn -ENOMEM;\n\t}\n\tenv->cur_state = state;\n\tinit_func_state(env, state->frame[0],\n\t\t\tBPF_MAIN_FUNC ,\n\t\t\t0 ,\n\t\t\tsubprog);\n\tregs = state->frame[state->curframe]->regs;\n\tif (subprog || env->prog->type == BPF_PROG_TYPE_EXT) {\n\t\tret = btf_prepare_func_args(env, subprog, regs);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tfor (i = BPF_REG_1; i <= BPF_REG_5; i++) {\n\t\t\tif (regs[i].type == PTR_TO_CTX)\n\t\t\t\tmark_reg_known_zero(env, regs, i);\n\t\t\telse if (regs[i].type == SCALAR_VALUE)\n\t\t\t\tmark_reg_unknown(env, regs, i);\n\t\t\telse if (regs[i].type == PTR_TO_MEM_OR_NULL) {\n\t\t\t\tconst u32 mem_size = regs[i].mem_size;\n\t\t\t\tmark_reg_known_zero(env, regs, i);\n\t\t\t\tregs[i].mem_size = mem_size;\n\t\t\t\tregs[i].id = ++env->id_gen;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tregs[BPF_REG_1].type = PTR_TO_CTX;\n\t\tmark_reg_known_zero(env, regs, BPF_REG_1);\n\t\tret = btf_check_subprog_arg_match(env, subprog, regs);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto out;\n\t}\n\tret = do_check(env);\nout:\n\tif (env->cur_state) {\n\t\tfree_verifier_state(env->cur_state, true);\n\t\tenv->cur_state = NULL;\n\t}\n\twhile (!pop_stack(env, NULL, NULL, false));\n\tif (!ret && pop_log)\n\t\tbpf_vlog_reset(&env->log, 0);\n\tfree_states(env);\n\treturn ret;\n}", "target": 0}
{"code": "    **/\n    T cubic_cut_atX(const float fx, const int y, const int z, const int c, const T& out_value) const {\n      return cimg::type<T>::cut(cubic_atX(fx,y,z,c,out_value));", "target": 0}
{"code": "clear_status_flags_on_sybil(routerstatus_t *rs)\n{\n  rs->is_authority = rs->is_exit = rs->is_stable = rs->is_fast =\n    rs->is_flagged_running = rs->is_named = rs->is_valid =\n    rs->is_hs_dir = rs->is_v2_dir = rs->is_possible_guard = 0;\n}", "target": 0}
{"code": "static int lua_ap_escape_logitem(lua_State *L)\n{\n    char           *returnValue;\n    request_rec    *r;\n    const char     *str;\n    luaL_checktype(L, 1, LUA_TUSERDATA);\n    r = ap_lua_check_request_rec(L, 1);\n    luaL_checktype(L, 2, LUA_TSTRING);\n    str = lua_tostring(L, 2);\n    returnValue = ap_escape_logitem(r->pool, str);\n    lua_pushstring(L, returnValue);\n    return 1;\n}", "target": 0}
{"code": "static int rr_index_first(READ_RECORD *info)\n{\n  int tmp;\n  if ((tmp = info->table->file->prepare_index_scan())) \n  {\n    tmp= rr_handle_error(info, tmp);\n    return tmp;\n  }\n  tmp= info->table->file->ha_index_first(info->record);\n  info->read_record= rr_index;\n  if (tmp)\n    tmp= rr_handle_error(info, tmp);\n  return tmp;\n}", "target": 0}
{"code": "FPDF_SYSTEMTIME PDFiumEngine::Form_GetLocalTime(FPDF_FORMFILLINFO* param) {\n  base::Time time = base::Time::Now();\n  base::Time::Exploded exploded;\n  time.LocalExplode(&exploded);\n  FPDF_SYSTEMTIME rv;\n  rv.wYear = exploded.year;\n  rv.wMonth = exploded.month;\n  rv.wDayOfWeek = exploded.day_of_week;\n  rv.wDay = exploded.day_of_month;\n  rv.wHour = exploded.hour;\n  rv.wMinute = exploded.minute;\n  rv.wSecond = exploded.second;\n  rv.wMilliseconds = exploded.millisecond;\n  return rv;\n}", "target": 0}
{"code": "static int isofs_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret;\n\tif (create) {\n\t\tprintk(KERN_DEBUG \"%s: Kernel tries to allocate a block\\n\", __func__);\n\t\treturn -EROFS;\n\t}\n\tret = isofs_get_blocks(inode, iblock, &bh_result, 1);\n\treturn ret < 0 ? ret : 0;\n}", "target": 0}
{"code": "_dbus_windows_get_datadir (void)\n{\n\treturn _dbus_replace_install_prefix(DBUS_DATADIR);\n}", "target": 0}
{"code": "Method* InstanceKlass::lookup_method_in_ordered_interfaces(Symbol* name,\n                                                         Symbol* signature) const {\n  Method* m = NULL;\n  if (default_methods() != NULL) {\n    m = find_method(default_methods(), name, signature);\n  }\n  if (m == NULL) {\n    m = lookup_method_in_all_interfaces(name, signature, find_defaults);\n  }\n  return m;\n}", "target": 0}
{"code": "static int fts3EvalTestDeferredAndNear(Fts3Cursor *pCsr, int *pRc){\n  int rc = *pRc;\n  int bMiss = 0;\n  if( rc==SQLITE_OK ){\n    if( pCsr->pDeferred ){\n      rc = fts3CursorSeek(0, pCsr);\n      if( rc==SQLITE_OK ){\n        rc = sqlite3Fts3CacheDeferredDoclists(pCsr);\n      }\n    }\n    bMiss = (0==fts3EvalTestExpr(pCsr, pCsr->pExpr, &rc));\n    sqlite3Fts3FreeDeferredDoclists(pCsr);\n    *pRc = rc;\n  }\n  return (rc==SQLITE_OK && bMiss);\n}", "target": 0}
{"code": "Status IndexedDBDatabase::OpenCursorOperation(\n    std::unique_ptr<OpenCursorOperationParams> params,\n    IndexedDBTransaction* transaction) {\n  IDB_TRACE1(\n      \"IndexedDBDatabase::OpenCursorOperation\", \"txn.id\", transaction->id());\n  if (params->task_type == blink::mojom::IDBTaskType::Preemptive)\n    transaction->AddPreemptiveEvent();\n  Status s = Status::OK();\n  std::unique_ptr<IndexedDBBackingStore::Cursor> backing_store_cursor;\n  if (params->index_id == IndexedDBIndexMetadata::kInvalidId) {\n    if (params->cursor_type == indexed_db::CURSOR_KEY_ONLY) {\n      DCHECK_EQ(params->task_type, blink::mojom::IDBTaskType::Normal);\n      backing_store_cursor = backing_store_->OpenObjectStoreKeyCursor(\n          transaction->BackingStoreTransaction(),\n          id(),\n          params->object_store_id,\n          *params->key_range,\n          params->direction,\n          &s);\n    } else {\n      backing_store_cursor = backing_store_->OpenObjectStoreCursor(\n          transaction->BackingStoreTransaction(),\n          id(),\n          params->object_store_id,\n          *params->key_range,\n          params->direction,\n          &s);\n    }\n  } else {\n    DCHECK_EQ(params->task_type, blink::mojom::IDBTaskType::Normal);\n    if (params->cursor_type == indexed_db::CURSOR_KEY_ONLY) {\n      backing_store_cursor = backing_store_->OpenIndexKeyCursor(\n          transaction->BackingStoreTransaction(),\n          id(),\n          params->object_store_id,\n          params->index_id,\n          *params->key_range,\n          params->direction,\n          &s);\n    } else {\n      backing_store_cursor = backing_store_->OpenIndexCursor(\n          transaction->BackingStoreTransaction(),\n          id(),\n          params->object_store_id,\n          params->index_id,\n          *params->key_range,\n          params->direction,\n          &s);\n    }\n  }\n  if (!s.ok()) {\n    DLOG(ERROR) << \"Unable to open cursor operation: \" << s.ToString();\n    return s;\n  }\n  if (!backing_store_cursor) {\n    params->callbacks->OnSuccess(nullptr);\n    return s;\n  }\n  std::unique_ptr<IndexedDBCursor> cursor = std::make_unique<IndexedDBCursor>(\n      std::move(backing_store_cursor), params->cursor_type, params->task_type,\n      transaction);\n  IndexedDBCursor* cursor_ptr = cursor.get();\n  transaction->RegisterOpenCursor(cursor_ptr);\n  params->callbacks->OnSuccess(std::move(cursor), cursor_ptr->key(),\n                               cursor_ptr->primary_key(), cursor_ptr->Value());\n  return s;\n}", "target": 0}
{"code": "inline void Splash::pipeIncX(SplashPipe *pipe) {\n  ++pipe->x;\n  if (state->softMask) {\n    ++pipe->softMaskPtr;\n  }\n  switch (bitmap->mode) {\n  case splashModeMono1:\n    if (!(pipe->destColorMask >>= 1)) {\n      pipe->destColorMask = 0x80;\n      ++pipe->destColorPtr;\n    }\n    break;\n  case splashModeMono8:\n    ++pipe->destColorPtr;\n    break;\n  case splashModeRGB8:\n  case splashModeBGR8:\n    pipe->destColorPtr += 3;\n    break;\n  case splashModeXBGR8:\n    pipe->destColorPtr += 4;\n    break;\n#if SPLASH_CMYK\n  case splashModeCMYK8:\n    pipe->destColorPtr += 4;\n    break;\n  case splashModeDeviceN8:\n    pipe->destColorPtr += (SPOT_NCOMPS+4);\n    break;\n#endif\n  }\n  if (pipe->destAlphaPtr) {\n    ++pipe->destAlphaPtr;\n  }\n  if (pipe->alpha0Ptr) {\n    ++pipe->alpha0Ptr;\n  }\n}", "target": 0}
{"code": "int HttpStreamParser::DoReadHeaders() {\n  io_state_ = STATE_READ_HEADERS_COMPLETE;\n  if (read_buf_->RemainingCapacity() == 0)\n    read_buf_->SetCapacity(read_buf_->capacity() + kHeaderBufInitialSize);\n  CHECK(read_buf_->data());\n  return connection_->socket()->Read(read_buf_,\n                                     read_buf_->RemainingCapacity(),\n                                     io_callback_);\n}", "target": 0}
{"code": "cib_remote_connection_destroy(gpointer user_data)\n{\n    cib_client_t *client = user_data;\n    int csock = 0;\n    if (client == NULL) {\n        return;\n    }\n    crm_trace(\"Cleaning up after client disconnect: %s/%s\",\n              crm_str(client->name), client->id);\n    if (client->id != NULL) {\n        if (!g_hash_table_remove(client_list, client->id)) {\n            crm_err(\"Client %s not found in the hashtable\", client->name);\n        }\n    }\n    crm_trace(\"Destroying %s (%p)\", client->name, user_data);\n    num_clients--;\n    crm_trace(\"Num unfree'd clients: %d\", num_clients);\n    if (client->remote_auth_timeout) {\n        g_source_remove(client->remote_auth_timeout);\n    }\n    if (client->encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        if (client->session) {\n            void *sock_ptr = gnutls_transport_get_ptr(*client->session);\n            csock = GPOINTER_TO_INT(sock_ptr);\n            if (client->handshake_complete) {\n                gnutls_bye(*client->session, GNUTLS_SHUT_WR);\n            }\n            gnutls_deinit(*client->session);\n            gnutls_free(client->session);\n        }\n#endif\n    } else {\n        csock = GPOINTER_TO_INT(client->session);\n    }\n    client->session = NULL;\n    if (csock > 0) {\n        close(csock);\n    }\n    free(client->name);\n    free(client->callback_id);\n    free(client->id);\n    free(client->user);\n    free(client->recv_buf);\n    free(client);\n    crm_trace(\"Freed the cib client\");\n    if (cib_shutdown_flag) {\n        cib_shutdown(0);\n    }\n    return;\n}", "target": 0}
{"code": "isofs_dentry_cmpi_ms(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 1, 1);\n}", "target": 0}
{"code": "LibRaw_buffer_datastream::LibRaw_buffer_datastream(void *buffer, size_t bsize)\n{\n  buf = (unsigned char *)buffer;\n  streampos = 0;\n  streamsize = bsize;\n}", "target": 0}
{"code": "    bool utf8ToUcs2le(std::string& str)\n    {\n        return mb2wc(CP_UTF8, str);\n    }", "target": 0}
{"code": "static int rb_head_page_set_head(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t struct buffer_page *head,\n\t\t\t\t struct buffer_page *prev,\n\t\t\t\t int old_flag)\n{\n\treturn rb_head_page_set(cpu_buffer, head, prev,\n\t\t\t\told_flag, RB_PAGE_HEAD);\n}", "target": 0}
{"code": "static int putint(jas_stream_t *out, int sgnd, int prec, long val)\n{\n\tint n;\n\tint c;\n\tif (sgnd) {\n\t\tabort();\n\t}\n\tval &= (1 << prec) - 1;\n\tn = (prec + 7) / 8;\n\twhile (--n >= 0) {\n\t\tc = (val >> (n * 8)) & 0xff;\n\t\tif (jas_stream_putc(out, c) != c)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "start_al_pair_from_min(line_list *ll, contour_cursor *q)\n{\n    int dir, code;\n    const fill_options * const fo = ll->fo;\n    do {\n        code = gx_flattened_iterator__next(&q->fi);\n        if (code < 0)\n            return code;\n        q->more_flattened = code;\n        dir = compute_dir(fo, q->fi.ly0, q->fi.ly1);\n        if (q->fi.ly0 > fo->ymax && ll->y_break > q->fi.y0)\n            ll->y_break = q->fi.ly0;\n        if (q->fi.ly1 > fo->ymax && ll->y_break > q->fi.ly1)\n            ll->y_break = q->fi.ly1;\n        if (q->fi.ly0 >= fo->ymin) {\n            if (dir == DIR_UP && ll->main_dir == DIR_DOWN) {\n                code = add_y_curve_part(ll, q->prev, q->pseg, DIR_DOWN, &q->fi,\n                                        true, true, q->monotonic_x);\n                if (code < 0)\n                    return code;\n                code = add_y_curve_part(ll, q->prev, q->pseg, DIR_UP, &q->fi,\n                                        q->more_flattened, false, q->monotonic_x);\n                if (code < 0)\n                    return code;\n            } else if (q->fi.ly1 < fo->ymin) {\n                code = add_y_curve_part(ll, q->prev, q->pseg, DIR_DOWN, &q->fi,\n                                        true, false, q->monotonic_x);\n                if (code < 0)\n                    return code;\n            }\n        } else if (q->fi.ly1 >= fo->ymin) {\n            code = add_y_curve_part(ll, q->prev, q->pseg, DIR_UP, &q->fi,\n                                    q->more_flattened, false, q->monotonic_x);\n            if (code < 0)\n                return code;\n        }\n        q->first_flattened = false;\n        q->dir = dir;\n        if (dir == DIR_DOWN || dir == DIR_UP)\n            ll->main_dir = dir;\n    } while(q->more_flattened);\n    return 0;\n}", "target": 0}
{"code": "double AccessibilityUIElement::maxValue()\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return 0.0f;\n    GValue value = G_VALUE_INIT;\n    atk_value_get_maximum_value(ATK_VALUE(m_element), &value);\n    if (!G_VALUE_HOLDS_FLOAT(&value))\n        return 0.0f;\n    return g_value_get_float(&value);\n}", "target": 0}
{"code": "sds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen, reqlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n    if (avail >= addlen) return s;\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    reqlen = newlen = (len+addlen);\n    assert(newlen > len);   \n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n    type = sdsReqType(newlen);\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > reqlen);  \n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}", "target": 0}
{"code": "static void tcp_incr_quickack(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tunsigned quickacks = tcp_sk(sk)->rcv_wnd / (2 * icsk->icsk_ack.rcv_mss);\n\tif (quickacks == 0)\n\t\tquickacks = 2;\n\tif (quickacks > icsk->icsk_ack.quick)\n\t\ticsk->icsk_ack.quick = min(quickacks, TCP_MAX_QUICKACKS);\n}", "target": 0}
{"code": "void license_write_encrypted_premaster_secret_blob(wStream* s, LICENSE_BLOB* blob, UINT32 ModulusLength)\n{\n\tUINT32 length;\n\tlength = ModulusLength + 8;\n\tif (blob->length > ModulusLength)\n\t{\n\t\tfprintf(stderr, \"license_write_encrypted_premaster_secret_blob: invalid blob\\n\");\n\t\treturn;\n\t}\n\tStream_EnsureRemainingCapacity(s, length + 4);\n\tStream_Write_UINT16(s, blob->type); \n\tStream_Write_UINT16(s, length); \n\tif (blob->length > 0)\n\t\tStream_Write(s, blob->data, blob->length); \n\tStream_Zero(s, length - blob->length);\n}", "target": 0}
{"code": "directory_caches_unknown_auth_certs(const or_options_t *options)\n{\n  return dir_server_mode(options) || options->BridgeRelay;\n}", "target": 0}
{"code": "do_curl_setattr(CurlObject *co, char *name, PyObject *v)\n{\n    assert_curl_state(co);\n    return my_setattr(&co->dict, name, v);\n}", "target": 0}
{"code": "Variant HHVM_FUNCTION(imagecolorsforindex, const Resource& image,\n                                           int64_t index) {\n  gdImagePtr im = get_valid_image_resource(image);\n  if (!im) return false;\n  if (index >= 0 &&\n      (gdImageTrueColor(im) || index < gdImageColorsTotal(im))) {\n    return make_map_array(\n      s_red,  gdImageRed(im,index),\n      s_green, gdImageGreen(im,index),\n      s_blue, gdImageBlue(im,index),\n      s_alpha, gdImageAlpha(im,index)\n    );\n  }\n  raise_warning(\"Color index %\" PRId64 \" out of range\", index);\n  return false;\n}", "target": 0}
{"code": "static int __cpuinit slab_cpuup_callback(struct notifier_block *nfb,\n\t\tunsigned long action, void *hcpu)\n{\n\tlong cpu = (long)hcpu;\n\tstruct kmem_cache *s;\n\tunsigned long flags;\n\tswitch (action) {\n\tcase CPU_UP_PREPARE:\n\tcase CPU_UP_PREPARE_FROZEN:\n\t\tinit_alloc_cpu_cpu(cpu);\n\t\tdown_read(&slub_lock);\n\t\tlist_for_each_entry(s, &slab_caches, list)\n\t\t\ts->cpu_slab[cpu] = alloc_kmem_cache_cpu(s, cpu,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tup_read(&slub_lock);\n\t\tbreak;\n\tcase CPU_UP_CANCELED:\n\tcase CPU_UP_CANCELED_FROZEN:\n\tcase CPU_DEAD:\n\tcase CPU_DEAD_FROZEN:\n\t\tdown_read(&slub_lock);\n\t\tlist_for_each_entry(s, &slab_caches, list) {\n\t\t\tstruct kmem_cache_cpu *c = get_cpu_slab(s, cpu);\n\t\t\tlocal_irq_save(flags);\n\t\t\t__flush_cpu_slab(s, cpu);\n\t\t\tlocal_irq_restore(flags);\n\t\t\tfree_kmem_cache_cpu(c, cpu);\n\t\t\ts->cpu_slab[cpu] = NULL;\n\t\t}\n\t\tup_read(&slub_lock);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}", "target": 0}
{"code": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "void handle_get_plugin_schema_resp(nng_aio *aio, neu_resp_check_schema_t *resp)\n{\n    if (resp->exist) {\n        char * schema_path = NULL;\n        size_t len         = 0;\n        char * buf         = NULL;\n        if (0 > neu_asprintf(&schema_path, \"%s/schema/%s.json\", g_plugin_dir,\n                             resp->schema)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n        if (NULL == buf) {\n            free(schema_path);\n            if (0 > neu_asprintf(&schema_path, \"%s/custom/schema/%s.json\",\n                                 g_plugin_dir, resp->schema)) {\n                NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                    neu_http_response(aio, error_code.error, result_error);\n                });\n                return;\n            }\n            buf = file_string_read(&len, schema_path);\n        }\n        if (NULL == buf) {\n            free(schema_path);\n            if (0 > neu_asprintf(&schema_path, \"%s/system/schema/%s.json\",\n                                 g_plugin_dir, resp->schema)) {\n                NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                    neu_http_response(aio, error_code.error, result_error);\n                });\n                return;\n            }\n            buf = file_string_read(&len, schema_path);\n        }\n        if (NULL == buf) {\n            nlog_info(\"open %s error: %d\", schema_path, errno);\n            neu_http_not_found(aio, \"{\\\"status\\\": \\\"error\\\"}\");\n            free(schema_path);\n            return;\n        }\n        neu_http_ok(aio, buf);\n        free(buf);\n        free(schema_path);\n    } else {\n        NEU_JSON_RESPONSE_ERROR(NEU_ERR_PLUGIN_NOT_FOUND, {\n            neu_http_response(aio, error_code.error, result_error);\n        });\n    }\n}", "target": 0}
{"code": "njs_string_bytes_from(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_value_t  *value;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_string(value)) {\n        return njs_string_bytes_from_string(vm, value, njs_arg(args, nargs, 2));\n    } else if (njs_is_object(value)) {\n        if (njs_is_object_string(value)) {\n            value = njs_object_value(value);\n            return njs_string_bytes_from_string(vm, value,\n                                                njs_arg(args, nargs, 2));\n        }\n        return njs_string_bytes_from_array_like(vm, value);\n    }\n    njs_type_error(vm, \"value must be a string or array-like object\");\n    return NJS_ERROR;\n}", "target": 0}
{"code": "scan_env_add_mem_entry(ScanEnv* env)\n{\n  int i, need, alloc;\n  Node** p;\n  need = env->num_mem + 1;\n  if (need > ONIG_MAX_CAPTURE_GROUP_NUM)\n    return ONIGERR_TOO_MANY_CAPTURE_GROUPS;\n  if (need >= SCANENV_MEMNODES_SIZE) {\n    if (env->mem_alloc <= need) {\n      if (IS_NULL(env->mem_nodes_dynamic)) {\n\talloc = INIT_SCANENV_MEMNODES_ALLOC_SIZE;\n\tp = (Node** )xmalloc(sizeof(Node*) * alloc);\n\txmemcpy(p, env->mem_nodes_static,\n\t\tsizeof(Node*) * SCANENV_MEMNODES_SIZE);\n      }\n      else {\n\talloc = env->mem_alloc * 2;\n\tp = (Node** )xrealloc(env->mem_nodes_dynamic, sizeof(Node*) * alloc);\n      }\n      CHECK_NULL_RETURN_MEMERR(p);\n      for (i = env->num_mem + 1; i < alloc; i++)\n\tp[i] = NULL_NODE;\n      env->mem_nodes_dynamic = p;\n      env->mem_alloc = alloc;\n    }\n  }\n  env->num_mem++;\n  return env->num_mem;\n}", "target": 0}
{"code": "void vhost_poll_init(struct vhost_poll *poll, vhost_work_fn_t fn,\n\t\t     unsigned long mask, struct vhost_dev *dev)\n{\n\tinit_waitqueue_func_entry(&poll->wait, vhost_poll_wakeup);\n\tinit_poll_funcptr(&poll->table, vhost_poll_func);\n\tpoll->mask = mask;\n\tpoll->dev = dev;\n\tvhost_work_init(&poll->work, fn);\n}", "target": 0}
{"code": "TIFFjpeg_read_scanlines(JPEGState* sp, JSAMPARRAY scanlines, int max_lines)\n{\n\treturn CALLJPEG(sp, -1, (int) jpeg_read_scanlines(&sp->cinfo.d,\n\t    scanlines, (JDIMENSION) max_lines));\n}", "target": 0}
{"code": "static void reds_accept(int fd, int event, void *data)\n{\n    RedsState *reds = (RedsState*) data;\n    int socket;\n    if ((socket = accept(fd, NULL, 0)) == -1) {\n        spice_warning(\"accept failed, %s\", strerror(errno));\n        return;\n    }\n    if (spice_server_add_client(reds, socket, 0) < 0) {\n        socket_close(socket);\n    }\n}", "target": 0}
{"code": "input_reply(struct input_ctx *ictx, const char *fmt, ...)\n{\n\tva_list\tap;\n\tchar   *reply;\n\tva_start(ap, fmt);\n\tvasprintf(&reply, fmt, ap);\n\tva_end(ap);\n\tbufferevent_write(ictx->wp->event, reply, strlen(reply));\n\tfree(reply);\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::OnCandidateWindowHidden() {\n  host_->CandidateWindowHidden();\n}", "target": 0}
{"code": "  static Status Compute(OpKernelContext* context,\n                        const typename TTypes<T, 1>::ConstTensor& values,\n                        const typename TTypes<T, 1>::ConstTensor& value_range,\n                        int32_t nbins, typename TTypes<Tout, 1>::Tensor& out) {\n    const CPUDevice& d = context->eigen_device<CPUDevice>();\n    Tensor index_to_bin_tensor;\n    TF_RETURN_IF_ERROR(context->forward_input_or_allocate_temp(\n        {0}, DataTypeToEnum<int32>::value, TensorShape({values.size()}),\n        &index_to_bin_tensor));\n    auto index_to_bin = index_to_bin_tensor.flat<int32>();\n    const double step = static_cast<double>(value_range(1) - value_range(0)) /\n                        static_cast<double>(nbins);\n    const double nbins_minus_1 = static_cast<double>(nbins - 1);\n    const Eigen::Tensor<int32, 1, 1> nans_tensor =\n        values.isnan().template cast<int32>();\n    const Eigen::Tensor<int32, 0, 1> reduced_tensor = nans_tensor.sum();\n    const int num_nans = reduced_tensor(0);\n    if (num_nans > 0) {\n      return errors::InvalidArgument(\"Histogram values must not contain NaN\");\n    }\n    index_to_bin.device(d) =\n        ((values.cwiseMax(value_range(0)) - values.constant(value_range(0)))\n             .template cast<double>() /\n         step)\n            .cwiseMin(nbins_minus_1)\n            .template cast<int32>();\n    out.setZero();\n    for (int32_t i = 0; i < index_to_bin.size(); i++) {\n      out(index_to_bin(i)) += Tout(1);\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "int tls1_set_sigalgs(CERT *c, const int *psig_nids, size_t salglen, int client)\n\t{\n\tunsigned char *sigalgs, *sptr;\n\tint rhash, rsign;\n\tsize_t i;\n\tif (salglen & 1)\n\t\treturn 0;\n\tsigalgs = OPENSSL_malloc(salglen);\n\tif (sigalgs == NULL)\n\t\treturn 0;\n\tfor (i = 0, sptr = sigalgs; i < salglen; i+=2)\n\t\t{\n\t\trhash = tls12_find_id(*psig_nids++, tls12_md,\n\t\t\t\t\tsizeof(tls12_md)/sizeof(tls12_lookup));\n\t\trsign = tls12_find_id(*psig_nids++, tls12_sig,\n\t\t\t\tsizeof(tls12_sig)/sizeof(tls12_lookup));\n\t\tif (rhash == -1 || rsign == -1)\n\t\t\tgoto err;\n\t\t*sptr++ = rhash;\n\t\t*sptr++ = rsign;\n\t\t}\n\tif (client)\n\t\t{\n\t\tif (c->client_sigalgs)\n\t\t\tOPENSSL_free(c->client_sigalgs);\n\t\tc->client_sigalgs = sigalgs;\n\t\tc->client_sigalgslen = salglen;\n\t\t}\n\telse\n\t\t{\n\t\tif (c->conf_sigalgs)\n\t\t\tOPENSSL_free(c->conf_sigalgs);\n\t\tc->conf_sigalgs = sigalgs;\n\t\tc->conf_sigalgslen = salglen;\n\t\t}\n\treturn 1;\n\terr:\n\tOPENSSL_free(sigalgs);\n\treturn 0;\n\t}", "target": 0}
{"code": "static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,\n                                 size_t bytewidth, unsigned char filterType, size_t length)\n{\n  size_t i;\n  switch(filterType)\n  {\n    case 0:\n      for(i = 0; i < length; i++) recon[i] = scanline[i];\n      break;\n    case 1:\n      for(i = 0; i < bytewidth; i++) recon[i] = scanline[i];\n      for(i = bytewidth; i < length; i++) recon[i] = scanline[i] + recon[i - bytewidth];\n      break;\n    case 2:\n      if(precon)\n      {\n        for(i = 0; i < length; i++) recon[i] = scanline[i] + precon[i];\n      }\n      else\n      {\n        for(i = 0; i < length; i++) recon[i] = scanline[i];\n      }\n      break;\n    case 3:\n      if(precon)\n      {\n        for(i = 0; i < bytewidth; i++) recon[i] = scanline[i] + precon[i] / 2;\n        for(i = bytewidth; i < length; i++) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);\n      }\n      else\n      {\n        for(i = 0; i < bytewidth; i++) recon[i] = scanline[i];\n        for(i = bytewidth; i < length; i++) recon[i] = scanline[i] + recon[i - bytewidth] / 2;\n      }\n      break;\n    case 4:\n      if(precon)\n      {\n        for(i = 0; i < bytewidth; i++)\n        {\n          recon[i] = (scanline[i] + precon[i]); \n        }\n        for(i = bytewidth; i < length; i++)\n        {\n          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));\n        }\n      }\n      else\n      {\n        for(i = 0; i < bytewidth; i++)\n        {\n          recon[i] = scanline[i];\n        }\n        for(i = bytewidth; i < length; i++)\n        {\n          recon[i] = (scanline[i] + recon[i - bytewidth]);\n        }\n      }\n      break;\n    default: return 36; \n  }\n  return 0;\n}", "target": 0}
{"code": "euckr_is_allowed_reverse_match(const UChar* s, const UChar* end ARG_UNUSED, OnigEncoding enc ARG_UNUSED)\n{\n  const UChar c = *s;\n  if (c <= 0x7e) return TRUE;\n  else           return FALSE;\n}", "target": 0}
{"code": "void FileSystemOperation::DidGetMetadata(\n    const GetMetadataCallback& callback,\n    base::PlatformFileError rv,\n    const base::PlatformFileInfo& file_info,\n    const FilePath& platform_path) {\n  callback.Run(rv, file_info, platform_path);\n}", "target": 0}
{"code": "uipbuf_search_header(uint8_t *buffer, uint16_t size, uint8_t protocol)\n{\n  uint8_t *nbuf;\n  uint8_t next_proto;\n  nbuf = uipbuf_get_next_header(buffer, size, &next_proto, true);\n  while(nbuf != NULL && next_proto != protocol && uip_is_proto_ext_hdr(next_proto)) {\n    nbuf = uipbuf_get_next_header(nbuf, size - (nbuf - buffer), &next_proto, false);\n  }\n  if(next_proto == protocol) {\n    return nbuf;\n  } else {\n    return NULL;\n  }\n}", "target": 0}
{"code": "sha1_digest(const unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_dig(EVP_sha1(), input, length, output);\n}", "target": 0}
{"code": "    void appendEndElementNSCallback()\n    {\n        PendingEndElementNSCallback* callback = new PendingEndElementNSCallback;\n        m_callbacks.append(callback);\n    }", "target": 0}
{"code": "static inline void verify_event(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t void *event)\n{\n}", "target": 0}
{"code": "void WebContentsImpl::ShowCreatedWidget(int route_id,\n                                        const gfx::Rect& initial_pos) {\n  ShowCreatedWidget(route_id, false, initial_pos);\n}", "target": 0}
{"code": " void free_user_ns(struct user_namespace *ns)\n{\n\tstruct user_namespace *parent;\n\tdo {\n\t\tparent = ns->parent;\n\t\tproc_free_inum(ns->proc_inum);\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\tns = parent;\n\t} while (atomic_dec_and_test(&parent->count));\n}", "target": 0}
{"code": "static void xennet_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t     struct ethtool_stats *stats, u64 * data)\n{\n\tvoid *np = netdev_priv(dev);\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(xennet_stats); i++)\n\t\tdata[i] = atomic_read((atomic_t *)(np + xennet_stats[i].offset));\n}", "target": 0}
{"code": "    int XmpTextValue::read(const std::string& buf)\n    {\n        std::string b = buf;\n        std::string type;\n        if (buf.length() > 5 && buf.substr(0, 5) == \"type=\") {\n            std::string::size_type pos = buf.find_first_of(' ');\n            type = buf.substr(5, pos-5);\n            if (type[0] == '\"') type = type.substr(1);\n            if (type[type.length()-1] == '\"') type = type.substr(0, type.length()-1);\n            b.clear();\n            if (pos != std::string::npos) b = buf.substr(pos+1);\n        }\n        if (!type.empty()) {\n            if (type == \"Alt\") {\n                setXmpArrayType(XmpValue::xaAlt);\n            }\n            else if (type == \"Bag\") {\n                setXmpArrayType(XmpValue::xaBag);\n            }\n            else if (type == \"Seq\") {\n                setXmpArrayType(XmpValue::xaSeq);\n            }\n            else if (type == \"Struct\") {\n                setXmpStruct();\n            }\n            else {\n                throw Error(kerInvalidXmpText, type);\n            }\n        }\n        value_ = b;\n        return 0;\n    }", "target": 0}
{"code": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tif (!timr->it_interval)\n\t\treturn;\n\ttimr->it_overrun += (unsigned int) hrtimer_forward(timer,\n\t\t\t\t\t\ttimer->base->get_time(),\n\t\t\t\t\t\ttimr->it_interval);\n\thrtimer_restart(timer);\n}", "target": 0}
{"code": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}", "target": 0}
{"code": "void dccp_set_state(struct sock *sk, const int state)\n{\n\tconst int oldstate = sk->sk_state;\n\tdccp_pr_debug(\"%s(%p) %-10.10s -> %s\\n\",\n\t\t      dccp_role(sk), sk,\n\t\t      dccp_state_name(oldstate), dccp_state_name(state));\n\tWARN_ON(state == oldstate);\n\tswitch (state) {\n\tcase DCCP_OPEN:\n\t\tif (oldstate != DCCP_OPEN)\n\t\t\tDCCP_INC_STATS(DCCP_MIB_CURRESTAB);\n\t\tbreak;\n\tcase DCCP_CLOSED:\n\t\tif (oldstate == DCCP_CLOSING || oldstate == DCCP_OPEN)\n\t\t\tDCCP_INC_STATS(DCCP_MIB_ESTABRESETS);\n\t\tsk->sk_prot->unhash(sk);\n\t\tif (inet_csk(sk)->icsk_bind_hash != NULL &&\n\t\t    !(sk->sk_userlocks & SOCK_BINDPORT_LOCK))\n\t\t\tinet_put_port(&dccp_hashinfo, sk);\n\tdefault:\n\t\tif (oldstate == DCCP_OPEN)\n\t\t\tDCCP_DEC_STATS(DCCP_MIB_CURRESTAB);\n\t}\n\tsk->sk_state = state;\n}", "target": 0}
{"code": "bool ParamTraits<base::FileDescriptor>::Read(const Message* m,\n                                             PickleIterator* iter,\n                                             param_type* r) {\n  bool valid;\n  if (!ReadParam(m, iter, &valid))\n    return false;\n  if (!valid) {\n    r->fd = -1;\n    r->auto_close = false;\n    return true;\n  }\n  return m->ReadFileDescriptor(iter, r);\n}", "target": 0}
{"code": "ProcDestroyWindow(ClientPtr client)\n{\n    WindowPtr pWin;\n    REQUEST(xResourceReq);\n    int rc;\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupWindow(&pWin, stuff->id, client, DixDestroyAccess);\n    if (rc != Success)\n        return rc;\n    if (pWin->parent) {\n        rc = dixLookupWindow(&pWin, pWin->parent->drawable.id, client,\n                             DixRemoveAccess);\n        if (rc != Success)\n            return rc;\n        FreeResource(stuff->id, RT_NONE);\n    }\n    return Success;\n}", "target": 0}
{"code": "static void http_silent_debug(int line, struct session *s)\n{\n\tint size = 0;\n\tsize += snprintf(trash + size, trashlen - size,\n\t\t\t \"[%04d] req: p=%d(%d) s=%d bf=%08x an=%08x data=%p size=%d l=%d w=%p r=%p lr=%p sm=%d fw=%ld tf=%08x\\n\",\n\t\t\t line,\n\t\t\t s->si[0].state, s->si[0].fd, s->txn.req.msg_state, s->req->flags, s->req->analysers,\n\t\t\t s->req->data, s->req->size, s->req->l, s->req->w, s->req->r, s->req->lr, s->req->send_max, s->req->to_forward, s->txn.flags);\n\twrite(-1, trash, size);\n\tsize = 0;\n\tsize += snprintf(trash + size, trashlen - size,\n\t\t\t \" %04d  rep: p=%d(%d) s=%d bf=%08x an=%08x data=%p size=%d l=%d w=%p r=%p lr=%p sm=%d fw=%ld\\n\",\n\t\t\t line,\n\t\t\t s->si[1].state, s->si[1].fd, s->txn.rsp.msg_state, s->rep->flags, s->rep->analysers,\n\t\t\t s->rep->data, s->rep->size, s->rep->l, s->rep->w, s->rep->r, s->rep->lr, s->rep->send_max, s->rep->to_forward);\n\twrite(-1, trash, size);\n}", "target": 0}
{"code": "static void pfkey_dump_sp_done(struct pfkey_sock *pfk)\n{\n\txfrm_policy_walk_done(&pfk->dump.u.policy);\n}", "target": 0}
{"code": "void ewk_view_tooltip_text_set(Evas_Object* ewkView, const char* text)\n{\n    DBG(\"ewkView=%p text=%s\", ewkView, text);\n    evas_object_smart_callback_call(ewkView, \"tooltip,text,set\", (void*)text);\n}", "target": 0}
{"code": "njs_string_new(njs_vm_t *vm, njs_value_t *value, const u_char *start,\n    uint32_t size, uint32_t length)\n{\n    u_char  *p;\n    p = njs_string_alloc(vm, value, size, length);\n    if (njs_fast_path(p != NULL)) {\n        memcpy(p, start, size);\n        return NJS_OK;\n    }\n    return NJS_ERROR;\n}", "target": 0}
{"code": "mbc_case_fold(OnigCaseFoldType flag,\n\t      const UChar** pp, const UChar* end ARG_UNUSED, UChar* lower,\n\t      OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  if (*p == SHARP_s && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    *lower++ = 's';\n    *lower   = 's';\n    (*pp)++;\n    return 2;\n  }\n  *lower = ENC_ISO_8859_9_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1;\n}", "target": 0}
{"code": "static int ac_interception(struct vcpu_svm *svm)\n{\n\tkvm_queue_exception_e(&svm->vcpu, AC_VECTOR, 0);\n\treturn 1;\n}", "target": 0}
{"code": "setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n\tif (efi_enabled(EFI_OLD_MEMMAP))\n\t\treturn 0;\n\tparams->secure_boot = boot_params.secure_boot;\n\tei->efi_loader_signature = current_ei->efi_loader_signature;\n\tei->efi_systab = current_ei->efi_systab;\n\tei->efi_systab_hi = current_ei->efi_systab_hi;\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}", "target": 0}
{"code": "static void namespace_unlock(void)\n{\n\tstruct mount *mnt;\n\tstruct hlist_head head = unmounted;\n\tif (likely(hlist_empty(&head))) {\n\t\tup_write(&namespace_sem);\n\t\treturn;\n\t}\n\thead.first->pprev = &head.first;\n\tINIT_HLIST_HEAD(&unmounted);\n\thlist_for_each_entry(mnt, &head, mnt_hash)\n\t\tif (mnt->mnt_ex_mountpoint.mnt)\n\t\t\tmntget(mnt->mnt_ex_mountpoint.mnt);\n\tup_write(&namespace_sem);\n\tsynchronize_rcu();\n\twhile (!hlist_empty(&head)) {\n\t\tmnt = hlist_entry(head.first, struct mount, mnt_hash);\n\t\thlist_del_init(&mnt->mnt_hash);\n\t\tif (mnt->mnt_ex_mountpoint.mnt)\n\t\t\tpath_put(&mnt->mnt_ex_mountpoint);\n\t\tmntput(&mnt->mnt);\n\t}\n}", "target": 0}
{"code": "Eina_Bool ewk_view_navigate_possible(Evas_Object* ewkView, int steps)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_navigate_possible(smartData->main_frame, steps);\n}", "target": 0}
{"code": "    uint32_t TiffEntryBase::doSizeImage() const\n    {\n        return 0;\n    } ", "target": 0}
{"code": "free_debug_memory (void)\n{\n  unsigned int i;\n  free_all_abbrevs ();\n  free (cu_abbrev_map);\n  cu_abbrev_map = NULL;\n  next_free_abbrev_map_entry = 0;\n  free (shndx_pool);\n  shndx_pool = NULL;\n  shndx_pool_size = 0;\n  shndx_pool_used = 0;\n  free (cu_sets);\n  cu_sets = NULL;\n  cu_count = 0;\n  free (tu_sets);\n  tu_sets = NULL;\n  tu_count = 0;\n  memset (level_type_signed, 0, sizeof level_type_signed);\n  cu_tu_indexes_read = -1;\n  for (i = 0; i < max; i++)\n    free_debug_section ((enum dwarf_section_display_enum) i);\n  if (debug_information != NULL)\n    {\n      for (i = 0; i < alloc_num_debug_info_entries; i++)\n\t{\n\t  if (debug_information [i].max_loc_offsets)\n\t    {\n\t      free (debug_information [i].loc_offsets);\n\t      free (debug_information [i].have_frame_base);\n\t    }\n\t  if (debug_information [i].max_range_lists)\n\t    free (debug_information [i].range_lists);\n\t}\n      free (debug_information);\n      debug_information = NULL;\n      alloc_num_debug_info_entries = num_debug_info_entries = 0;\n    }\n  separate_info * d;\n  separate_info * next;\n  for (d = first_separate_info; d != NULL; d = next)\n    {\n      close_debug_file (d->handle);\n      free ((void *) d->filename);\n      next = d->next;\n      free ((void *) d);\n    }\n  first_separate_info = NULL;\n  free_dwo_info ();\n}", "target": 0}
{"code": "void qxl_render_update(PCIQXLDevice *qxl)\n{\n    QXLCookie *cookie;\n    qemu_mutex_lock(&qxl->ssd.lock);\n    if (!runstate_is_running() || !qxl->guest_primary.commands ||\n        qxl->mode == QXL_MODE_UNDEFINED) {\n        qxl_render_update_area_unlocked(qxl);\n        qemu_mutex_unlock(&qxl->ssd.lock);\n        graphic_hw_update_done(qxl->ssd.dcl.con);\n        return;\n    }\n    qxl->guest_primary.commands = 0;\n    qxl->render_update_cookie_num++;\n    qemu_mutex_unlock(&qxl->ssd.lock);\n    cookie = qxl_cookie_new(QXL_COOKIE_TYPE_RENDER_UPDATE_AREA,\n                            0);\n    qxl_set_rect_to_surface(qxl, &cookie->u.render.area);\n    qxl_spice_update_area(qxl, 0, &cookie->u.render.area, NULL,\n                          0, 1 , QXL_ASYNC, cookie);\n}", "target": 0}
{"code": "bool HTMLFormControlElement::checkValidity(Vector<RefPtr<FormAssociatedElement> >* unhandledInvalidControls, CheckValidityDispatchEvents dispatchEvents)\n{\n    if (!willValidate() || isValidFormControlElement())\n        return true;\n    if (dispatchEvents == CheckValidityDispatchEventsNone)\n        return false;\n    RefPtr<HTMLFormControlElement> protector(this);\n    RefPtr<Document> originalDocument(document());\n    bool needsDefaultAction = dispatchEvent(Event::createCancelable(EventTypeNames::invalid));\n    if (needsDefaultAction && unhandledInvalidControls && inDocument() && originalDocument == document())\n        unhandledInvalidControls->append(this);\n    return false;\n}", "target": 0}
{"code": "static int perf_ftrace_function_unregister(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\treturn unregister_ftrace_function(ops);\n}", "target": 0}
{"code": "int afSyncFile (AFfilehandle handle)\n{\n\tif (!_af_filehandle_ok(handle))\n\t\treturn -1;\n\tif (handle->access == _AF_WRITE_ACCESS)\n\t{\n\t\tint\tfilefmt = handle->fileFormat;\n\t\tint\ttrackno;\n\t\tfor (trackno = 0; trackno < handle->trackCount; trackno++)\n\t\t{\n\t\t\t_Track\t*track = &handle->tracks[trackno];\n\t\t\tif (track->ms->isDirty() && track->ms->setup(handle, track) == AF_FAIL)\n\t\t\t\treturn -1;\n\t\t\tif (track->ms->sync(handle, track) != AF_SUCCEED)\n\t\t\t\treturn -1;\n\t\t}\n\t\tif (_af_units[filefmt].write.update != NULL &&\n\t\t\t_af_units[filefmt].write.update(handle) != AF_SUCCEED)\n\t\t\treturn AF_FAIL;\n\t}\n\telse if (handle->access == _AF_READ_ACCESS)\n\t{\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode %d\",\n\t\t\thandle->access);\n\t\treturn AF_FAIL;\n\t}\n\treturn AF_SUCCEED;\n}", "target": 0}
{"code": "static bool need_debug_guardpage(void)\n{\n\tif (!debug_pagealloc_enabled())\n\t\treturn false;\n\tif (!debug_guardpage_minorder())\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "void RenderView::LoadNavigationErrorPage(WebFrame* frame,\n                                         const WebURLRequest& failed_request,\n                                         const WebURLError& error,\n                                         const std::string& html,\n                                         bool replace) {\n  GURL failed_url = error.unreachableURL;\n  std::string alt_html;\n  if (html.empty()) {\n    int resource_id;\n    DictionaryValue error_strings;\n    if (error.reason == net::ERR_CACHE_MISS &&\n        EqualsASCII(failed_request.httpMethod(), \"POST\")) {\n      GetFormRepostErrorValues(failed_url, &error_strings);\n      resource_id = IDR_ERROR_NO_DETAILS_HTML;\n    } else {\n      GetLocalizedErrorValues(error, &error_strings);\n      resource_id = IDR_NET_ERROR_HTML;\n    }\n    alt_html = GetAltHTMLForTemplate(error_strings, resource_id);\n  } else {\n    alt_html = html;\n  }\n  frame->loadHTMLString(alt_html,\n                        GURL(kUnreachableWebDataURL),\n                        failed_url,\n                        replace);\n}", "target": 0}
{"code": "bool FrameLoader::prepareRequestForThisFrame(FrameLoadRequest& request)\n{\n    if (!request.requester())\n        return true;\n    KURL url = request.resourceRequest().url();\n    if (m_frame->script()->executeScriptIfJavaScriptURL(url))\n        return false;\n    if (!request.requester()->canDisplay(url)) {\n        reportLocalLoadFailed(m_frame, url.elidedString());\n        return false;\n    }\n    if (request.requester() && !request.formState() && request.frameName().isEmpty())\n        request.setFrameName(m_frame->document()->baseTarget());\n    if (request.requester() == m_frame->document()->securityOrigin())\n        setReferrerForFrameRequest(request.resourceRequest(), request.shouldSendReferrer());\n    return true;\n}", "target": 0}
{"code": "static int decode_cbf_luma(thread_context* tctx,\n\t\t\t   int trafoDepth)\n{\n  logtrace(LogSlice,\"# cbf_luma\\n\");\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_CBF_LUMA + (trafoDepth==0)]);\n  logtrace(LogSlice,\"> cbf_luma = %d\\n\",bit);\n  logtrace(LogSymbols,\"$1 cbf_luma=%d\\n\",bit);\n  return bit;\n}", "target": 0}
{"code": "TEST(InMatchExpression, ChangingCollationAfterAddingEqualitiesPreservesEqualities) {\n    BSONObj obj1 = BSON(\"\"\n                        << \"string1\");\n    BSONObj obj2 = BSON(\"\"\n                        << \"string2\");\n    CollatorInterfaceMock collatorAlwaysEqual(CollatorInterfaceMock::MockType::kAlwaysEqual);\n    CollatorInterfaceMock collatorReverseString(CollatorInterfaceMock::MockType::kReverseString);\n    InMatchExpression in(\"\");\n    in.setCollator(&collatorAlwaysEqual);\n    std::vector<BSONElement> equalities{obj1.firstElement(), obj2.firstElement()};\n    ASSERT_OK(in.setEqualities(std::move(equalities)));\n    ASSERT(in.getEqualities().size() == 1);\n    in.setCollator(&collatorReverseString);\n    ASSERT(in.getEqualities().size() == 2);\n    ASSERT(in.getEqualities().count(obj1.firstElement()));\n    ASSERT(in.getEqualities().count(obj2.firstElement()));\n}", "target": 0}
{"code": "int ewk_view_setting_font_minimum_size_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, 0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, 0);\n    return priv->settings.fontMinimumSize;\n}", "target": 0}
{"code": "DLLEXPORT tjhandle DLLCALL tjInitTransform(void)\n{\n\ttjinstance *this=NULL;  tjhandle handle=NULL;\n\tif((this=(tjinstance *)malloc(sizeof(tjinstance)))==NULL)\n\t{\n\t\tsnprintf(errStr, JMSG_LENGTH_MAX,\n\t\t\t\"tjInitTransform(): Memory allocation failure\");\n\t\treturn NULL;\n\t}\n\tMEMZERO(this, sizeof(tjinstance));\n\thandle=_tjInitCompress(this);\n\tif(!handle) return NULL;\n\thandle=_tjInitDecompress(this);\n\treturn handle;\n}", "target": 0}
{"code": "int cap_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\tbool effective, has_cap = false;\n\tint ret;\n\teffective = false;\n\tret = get_file_caps(bprm, &effective, &has_cap);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!issecure(SECURE_NOROOT)) {\n\t\tif (has_cap && new->uid != 0 && new->euid == 0) {\n\t\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\t\tgoto skip;\n\t\t}\n\t\tif (new->euid == 0 || new->uid == 0) {\n\t\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t\t old->cap_inheritable);\n\t\t}\n\t\tif (new->euid == 0)\n\t\t\teffective = true;\n\t}\nskip:\n\tif (!cap_issubset(new->cap_permitted, old->cap_permitted))\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\tif ((new->euid != old->uid ||\n\t     new->egid != old->gid ||\n\t     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&\n\t    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {\n\t\tif (!capable(CAP_SETUID)) {\n\t\t\tnew->euid = new->uid;\n\t\t\tnew->egid = new->gid;\n\t\t}\n\t\tnew->cap_permitted = cap_intersect(new->cap_permitted,\n\t\t\t\t\t\t   old->cap_permitted);\n\t}\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\tif (effective)\n\t\tnew->cap_effective = new->cap_permitted;\n\telse\n\t\tcap_clear(new->cap_effective);\n\tbprm->cap_effective = effective;\n\tif (!cap_isclear(new->cap_effective)) {\n\t\tif (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||\n\t\t    new->euid != 0 || new->uid != 0 ||\n\t\t    issecure(SECURE_NOROOT)) {\n\t\t\tret = audit_log_bprm_fcaps(bprm, new, old);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\treturn 0;\n}", "target": 0}
{"code": "nfsd4_secinfo_no_name(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_secinfo_no_name *sin)\n{\n\t__be32 err;\n\tswitch (sin->sin_style) {\n\tcase NFS4_SECINFO_STYLE4_CURRENT_FH:\n\t\tbreak;\n\tcase NFS4_SECINFO_STYLE4_PARENT:\n\t\terr = nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_inval;\n\t}\n\tsin->sin_exp = exp_get(cstate->current_fh.fh_export);\n\tfh_put(&cstate->current_fh);\n\treturn nfs_ok;\n}", "target": 0}
{"code": "void gf_propalloc_del(void *it)\n{\n\tGF_PropertyEntry *pe = (GF_PropertyEntry *)it;\n\tif (pe->prop.value.data.ptr) gf_free(pe->prop.value.data.ptr);\n\tgf_free(pe);\n}", "target": 0}
{"code": "    void OffsetWriter::writeOffsets(BasicIo& io) const\n    {\n        for (OffsetList::const_iterator it = offsetList_.begin(); it != offsetList_.end(); ++it) {\n            io.seek(it->second.origin_, BasicIo::beg);\n            byte buf[4] = { 0, 0, 0, 0 };\n            l2Data(buf, it->second.target_, it->second.byteOrder_);\n            io.write(buf, 4);\n        }\n    }", "target": 0}
{"code": "irc_server_set_buffer_title (struct t_irc_server *server)\n{\n    char *title;\n    int length;\n    if (server && server->buffer)\n    {\n        if (server->is_connected)\n        {\n            length = 16 +\n                ((server->current_address) ? strlen (server->current_address) : 16) +\n                16 + ((server->current_ip) ? strlen (server->current_ip) : 16) + 1;\n            title = malloc (length);\n            if (title)\n            {\n                snprintf (title, length, \"IRC: %s/%d (%s)\",\n                          server->current_address,\n                          server->current_port,\n                          (server->current_ip) ? server->current_ip : \"\");\n                weechat_buffer_set (server->buffer, \"title\", title);\n                free (title);\n            }\n        }\n        else\n        {\n            weechat_buffer_set (server->buffer, \"title\", \"\");\n        }\n    }\n}", "target": 0}
{"code": "event_sched_out(struct perf_event *event,\n\t\t  struct perf_cpu_context *cpuctx,\n\t\t  struct perf_event_context *ctx)\n{\n\tu64 tstamp = perf_event_time(event);\n\tu64 delta;\n\tif (event->state == PERF_EVENT_STATE_INACTIVE\n\t    && !event_filter_match(event)) {\n\t\tdelta = tstamp - event->tstamp_stopped;\n\t\tevent->tstamp_running += delta;\n\t\tevent->tstamp_stopped = tstamp;\n\t}\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\treturn;\n\tperf_pmu_disable(event->pmu);\n\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\tif (event->pending_disable) {\n\t\tevent->pending_disable = 0;\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\t}\n\tevent->tstamp_stopped = tstamp;\n\tevent->pmu->del(event, 0);\n\tevent->oncpu = -1;\n\tif (!is_software_event(event))\n\t\tcpuctx->active_oncpu--;\n\tctx->nr_active--;\n\tif (event->attr.freq && event->attr.sample_freq)\n\t\tctx->nr_freq--;\n\tif (event->attr.exclusive || !cpuctx->active_oncpu)\n\t\tcpuctx->exclusive = 0;\n\tif (is_orphaned_child(event))\n\t\tschedule_orphans_remove(ctx);\n\tperf_pmu_enable(event->pmu);\n}", "target": 0}
{"code": "static int gen8_emit_flush_render(struct i915_request *request,\n\t\t\t\t  u32 mode)\n{\n\tbool vf_flush_wa = false, dc_flush_wa = false;\n\tu32 *cs, flags = 0;\n\tint len;\n\tflags |= PIPE_CONTROL_CS_STALL;\n\tif (mode & EMIT_FLUSH) {\n\t\tflags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;\n\t\tflags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;\n\t\tflags |= PIPE_CONTROL_DC_FLUSH_ENABLE;\n\t\tflags |= PIPE_CONTROL_FLUSH_ENABLE;\n\t}\n\tif (mode & EMIT_INVALIDATE) {\n\t\tflags |= PIPE_CONTROL_TLB_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_QW_WRITE;\n\t\tflags |= PIPE_CONTROL_STORE_DATA_INDEX;\n\t\tif (IS_GEN(request->i915, 9))\n\t\t\tvf_flush_wa = true;\n\t\tif (IS_KBL_REVID(request->i915, 0, KBL_REVID_B0))\n\t\t\tdc_flush_wa = true;\n\t}\n\tlen = 6;\n\tif (vf_flush_wa)\n\t\tlen += 6;\n\tif (dc_flush_wa)\n\t\tlen += 12;\n\tcs = intel_ring_begin(request, len);\n\tif (IS_ERR(cs))\n\t\treturn PTR_ERR(cs);\n\tif (vf_flush_wa)\n\t\tcs = gen8_emit_pipe_control(cs, 0, 0);\n\tif (dc_flush_wa)\n\t\tcs = gen8_emit_pipe_control(cs, PIPE_CONTROL_DC_FLUSH_ENABLE,\n\t\t\t\t\t    0);\n\tcs = gen8_emit_pipe_control(cs, flags, LRC_PPHWSP_SCRATCH_ADDR);\n\tif (dc_flush_wa)\n\t\tcs = gen8_emit_pipe_control(cs, PIPE_CONTROL_CS_STALL, 0);\n\tintel_ring_advance(request, cs);\n\treturn 0;\n}", "target": 0}
{"code": "static void usb_net_handle_data(USBDevice *dev, USBPacket *p)\n{\n    USBNetState *s = (USBNetState *) dev;\n    switch(p->pid) {\n    case USB_TOKEN_IN:\n        switch (p->ep->nr) {\n        case 1:\n            usb_net_handle_statusin(s, p);\n            break;\n        case 2:\n            usb_net_handle_datain(s, p);\n            break;\n        default:\n            goto fail;\n        }\n        break;\n    case USB_TOKEN_OUT:\n        switch (p->ep->nr) {\n        case 2:\n            usb_net_handle_dataout(s, p);\n            break;\n        default:\n            goto fail;\n        }\n        break;\n    default:\n    fail:\n        p->status = USB_RET_STALL;\n        break;\n    }\n    if (p->status == USB_RET_STALL) {\n        fprintf(stderr, \"usbnet: failed data transaction: \"\n                        \"pid 0x%x ep 0x%x len 0x%zx\\n\",\n                        p->pid, p->ep->nr, p->iov.size);\n    }\n}", "target": 0}
{"code": "ex_cd(exarg_T *eap)\n{\n    char_u\t*new_dir;\n    new_dir = eap->arg;\n#if !defined(UNIX) && !defined(VMS)\n    if (*new_dir == NUL)\n\tex_pwd(NULL);\n    else\n#endif\n    {\n\tcdscope_T\tscope = CDSCOPE_GLOBAL;\n\tif (eap->cmdidx == CMD_lcd || eap->cmdidx == CMD_lchdir)\n\t    scope = CDSCOPE_WINDOW;\n\telse if (eap->cmdidx == CMD_tcd || eap->cmdidx == CMD_tchdir)\n\t    scope = CDSCOPE_TABPAGE;\n\tif (changedir_func(new_dir, eap->forceit, scope))\n\t{\n\t    if (KeyTyped || p_verbose >= 5)\n\t\tex_pwd(eap);\n\t}\n    }\n}", "target": 0}
{"code": "WebKit::WebSpeechInputController* RenderView::speechInputController(\n    WebKit::WebSpeechInputListener* listener) {\n  if (!speech_input_dispatcher_.get())\n    speech_input_dispatcher_.reset(new SpeechInputDispatcher(this, listener));\n  return speech_input_dispatcher_.get();\n}", "target": 0}
{"code": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\tmutex_lock(&register_mutex);\n\tlist_del(&timeri->open_list);\n\tsnd_timer_stop(timeri);\n\ttimer = timeri->timer;\n\tif (timer) {\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tspin_lock_irq(&slave_active_lock);\n\t\tspin_lock(&timer->lock);\n\t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n\t\t\t\t\t open_list) {\n\t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n\t\t\tslave->master = NULL;\n\t\t\tslave->timer = NULL;\n\t\t\tlist_del_init(&slave->ack_list);\n\t\t\tlist_del_init(&slave->active_list);\n\t\t}\n\t\tspin_unlock(&timer->lock);\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\t\ttimer = NULL;\n\t}\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer) {\n\t\tif (list_empty(&timer->open_list_head) && timer->hw.close)\n\t\t\ttimer->hw.close(timer);\n\t\tif (timer->card)\n\t\t\tput_device(&timer->card->card_dev);\n\t\tmodule_put(timer->module);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "getName(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tchar *t;\n\tswitch( act->Type ) \t\n\t{\n\tcase PUSH_STRING: \n\t\tif (!act->p.String) \n\t\t{\n\t\t        SWF_warn(\"WARNING: Call to getName with NULL string.\\n\");\n\t\t        break;\n\t\t}\n\t\telse if (strlen(act->p.String)) \n\t\t{\n\t\t        t=malloc(strlen(act->p.String)+3);\n\t\t        strcpyext(t,act->p.String);\n\t\t        return t;\n\t\t}\n\t\telse\n\t\t{\n\t\t        char *return_string = \"this\";\n\t                t=malloc(strlen(return_string)+1); \n\t                strcpyext(t,return_string);\n\t\t\treturn t;\n\t\t}\n#if 0\n\t  case 4: \n\t\tt=malloc(5); \n  \t\tsprintf(t,\"R%d\", act->p.RegisterNumber );\n  \t\treturn t;\n#endif\n\tcase PUSH_CONSTANT: \n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant8])+1);\n\t\tstrcpyext(t,pool[act->p.Constant8]);\n\t\tif(strlen(t)) \n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tcase PUSH_CONSTANT16: \n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant16])+1);\n\t\tstrcpyext(t,pool[act->p.Constant16]);\n\t\tif(strlen(t)) \n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tdefault: \n\t\treturn getString(act);\n\t}\n\tt = malloc(sizeof(char));\n\tstrcpyext(t,\"\");\n\treturn t;\n}", "target": 0}
{"code": "void gf_fs_run_step(GF_FilterSession *fsess)\n{\n\tgf_fs_thread_proc(&fsess->main_th);\n}", "target": 0}
{"code": "void FrameLoader::setFirstPartyForCookies(const KURL& url)\n{\n    m_frame->document()->setFirstPartyForCookies(url);\n    for (Frame* child = m_frame->tree()->firstChild(); child; child = child->tree()->nextSibling())\n        child->loader()->setFirstPartyForCookies(url);\n}", "target": 0}
{"code": "isofile_hd_cmp_node(const struct archive_rb_node *n1,\n    const struct archive_rb_node *n2)\n{\n\tconst struct hardlink *h1 = (const struct hardlink *)n1;\n\tconst struct hardlink *h2 = (const struct hardlink *)n2;\n\treturn (strcmp(archive_entry_pathname(h1->file_list.first->entry),\n\t\t       archive_entry_pathname(h2->file_list.first->entry)));\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoGetVertexAttribiv(\n    GLuint index, GLenum pname, GLint* params) {\n  VertexAttribManager::VertexAttribInfo* info =\n      vertex_attrib_manager_->GetVertexAttribInfo(index);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glGetVertexAttribiv: index out of range\");\n    return;\n  }\n  switch (pname) {\n    case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: {\n        BufferManager::BufferInfo* buffer = info->buffer();\n        if (buffer && !buffer->IsDeleted()) {\n          GLuint client_id;\n          buffer_manager()->GetClientId(buffer->service_id(), &client_id);\n          *params = client_id;\n        }\n        break;\n      }\n    case GL_VERTEX_ATTRIB_ARRAY_ENABLED:\n      *params = info->enabled();\n      break;\n    case GL_VERTEX_ATTRIB_ARRAY_SIZE:\n      *params = info->size();\n      break;\n    case GL_VERTEX_ATTRIB_ARRAY_STRIDE:\n      *params = info->gl_stride();\n      break;\n    case GL_VERTEX_ATTRIB_ARRAY_TYPE:\n      *params = info->type();\n      break;\n    case GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:\n      *params = static_cast<GLint>(info->normalized());\n      break;\n    case GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE:\n      *params = info->divisor();\n      break;\n    case GL_CURRENT_VERTEX_ATTRIB:\n      params[0] = static_cast<GLint>(info->value().v[0]);\n      params[1] = static_cast<GLint>(info->value().v[1]);\n      params[2] = static_cast<GLint>(info->value().v[2]);\n      params[3] = static_cast<GLint>(info->value().v[3]);\n      break;\n    default:\n      NOTREACHED();\n      break;\n  }\n}", "target": 0}
{"code": "struct sock *nfc_llcp_accept_dequeue(struct sock *parent,\n\t\t\t\t     struct socket *newsock)\n{\n\tstruct nfc_llcp_sock *lsk, *n, *llcp_parent;\n\tstruct sock *sk;\n\tllcp_parent = nfc_llcp_sock(parent);\n\tlist_for_each_entry_safe(lsk, n, &llcp_parent->accept_queue,\n\t\t\t\t accept_queue) {\n\t\tsk = &lsk->sk;\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state == LLCP_CLOSED) {\n\t\t\trelease_sock(sk);\n\t\t\tnfc_llcp_accept_unlink(sk);\n\t\t\tcontinue;\n\t\t}\n\t\tif (sk->sk_state == LLCP_CONNECTED || !newsock) {\n\t\t\tlist_del_init(&lsk->accept_queue);\n\t\t\tsock_put(sk);\n\t\t\tif (newsock)\n\t\t\t\tsock_graft(sk, newsock);\n\t\t\trelease_sock(sk);\n\t\t\tpr_debug(\"Returning sk state %d\\n\", sk->sk_state);\n\t\t\tsk_acceptq_removed(parent);\n\t\t\treturn sk;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "  explicit ShutdownWatchDogThread(const base::TimeDelta& duration)\n      : base::Watchdog(duration, \"Shutdown watchdog thread\", true) {\n  }", "target": 0}
{"code": "cardos_lifecycle_get(sc_card_t *card, int *mode)\n{\n\tsc_apdu_t\tapdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint\t\tr;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0x01, 0x83);\n\tapdu.cla = 0x00;\n\tapdu.le = 256;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.resp = rbuf;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"Card returned error\");\n\tif (apdu.resplen < 1) {\n\t\tLOG_TEST_RET(card->ctx, r, \"Lifecycle byte not in response\");\n\t}\n\tr = SC_SUCCESS;\n\tswitch (rbuf[0]) {\n\tcase 0x10:\n\t\t*mode = SC_CARDCTRL_LIFECYCLE_USER;\n\t\tbreak;\n\tcase 0x20:\n\t\t*mode = SC_CARDCTRL_LIFECYCLE_ADMIN;\n\t\tbreak;\n\tcase 0x34: \n\t\t*mode = SC_CARDCTRL_LIFECYCLE_OTHER;\n\t\tbreak;\n\tdefault:\n\t\tsc_log(card->ctx,  \"Unknown lifecycle byte %d\", rbuf[0]);\n\t\tr = SC_ERROR_INTERNAL;\n\t}\n\tLOG_FUNC_RETURN(card->ctx, r);\n}", "target": 0}
{"code": "spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}", "target": 0}
{"code": "static inline void net_tx_pkt_sendv(struct NetTxPkt *pkt,\n    NetClientState *nc, const struct iovec *iov, int iov_cnt)\n{\n    if (pkt->is_loopback) {\n        qemu_receive_packet_iov(nc, iov, iov_cnt);\n    } else {\n        qemu_sendv_packet(nc, iov, iov_cnt);\n    }\n}", "target": 0}
{"code": "ldns_str2rdf_eui48(ldns_rdf **rd, const char *str)\n{\n\tunsigned int a, b, c, d, e, f;\n\tuint8_t bytes[6];\n\tint l;\n\tif (sscanf(str, \"%2x-%2x-%2x-%2x-%2x-%2x%n\",\n\t\t\t&a, &b, &c, &d, &e, &f, &l) != 6 ||\n\t\t\tl != (int)strlen(str)) {\n\t\treturn LDNS_STATUS_INVALID_EUI48;\n\t} else {\n\t\tbytes[0] = a;\n\t\tbytes[1] = b;\n\t\tbytes[2] = c;\n\t\tbytes[3] = d;\n\t\tbytes[4] = e;\n\t\tbytes[5] = f;\n\t\t*rd = ldns_rdf_new_frm_data(LDNS_RDF_TYPE_EUI48, 6, &bytes);\n\t}\n\treturn *rd ? LDNS_STATUS_OK : LDNS_STATUS_MEM_ERR;\n}", "target": 0}
{"code": "void blk_mq_freeze_queue_start(struct request_queue *q)\n{\n\tint freeze_depth;\n\tfreeze_depth = atomic_inc_return(&q->mq_freeze_depth);\n\tif (freeze_depth == 1) {\n\t\tpercpu_ref_kill(&q->mq_usage_counter);\n\t\tblk_mq_run_hw_queues(q, false);\n\t}\n}", "target": 0}
{"code": "bool CLua::is_path_safe(string s, bool trusted)\n{\n    lowercase(s);\n    return s.find(\"..\") == string::npos && shell_safe(s.c_str())\n           && (trusted || s.find(\"dlua\") != 0);\n}", "target": 0}
{"code": "Module *PCM::createDecompress(_Track *track, AFvirtualfile *fh, bool canSeek,\n\tbool headerless, AFframecount *chunkframes)\n{\n\treturn new PCM(Decompress, track, fh, canSeek);\n}", "target": 0}
{"code": "i915_gem_execbuffer_retire_commands(struct drm_device *dev,\n\t\t\t\t    struct drm_file *file,\n\t\t\t\t    struct intel_ring_buffer *ring)\n{\n\tring->gpu_caches_dirty = true;\n\t(void)i915_add_request(ring, file, NULL);\n}", "target": 0}
{"code": "void WebContentsImpl::DidGetRedirectForResourceRequest(\n  const ResourceRedirectDetails& details) {\n  controller_.ssl_manager()->DidReceiveResourceRedirect(details);\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DidGetRedirectForResourceRequest(details));\n  NotificationService::current()->Notify(\n      NOTIFICATION_RESOURCE_RECEIVED_REDIRECT,\n      Source<WebContents>(this),\n      Details<const ResourceRedirectDetails>(&details));\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoTexParameteriv(\n  GLenum target, GLenum pname, const GLint* params) {\n  TextureManager::TextureInfo* info = GetTextureInfoForTarget(target);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glTexParameteriv: unknown texture\");\n    return;\n  }\n  if (!texture_manager()->SetParameter(info, pname, *params)) {\n    SetGLError(GL_INVALID_ENUM, \"glTexParameteriv: param GL_INVALID_ENUM\");\n    return;\n  }\n  glTexParameteriv(target, pname, params);\n}", "target": 0}
{"code": "static int sqfs_get_metablk_pos(u32 *pos_list, void *table, u32 offset,\n\t\t\t\tint metablks_count)\n{\n\tu32 data_size, cur_size = 0;\n\tint j, ret = 0;\n\tbool comp;\n\tif (!metablks_count)\n\t\treturn -EINVAL;\n\tfor (j = 0; j < metablks_count; j++) {\n\t\tret = sqfs_read_metablock(table, offset + cur_size, &comp,\n\t\t\t\t\t  &data_size);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t\tcur_size += data_size + SQFS_HEADER_SIZE;\n\t\tpos_list[j] = cur_size;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "int PrintWebViewHelper::PrintPreviewContext::last_error() const {\n  return error_;\n}", "target": 0}
{"code": "bool SVGDocumentExtensions::isSVGRootWithRelativeLengthDescendents(SVGSVGElement* svgRoot) const\n{\n    return m_relativeLengthSVGRoots.contains(svgRoot);\n}", "target": 0}
{"code": "int svm_register_enc_region(struct kvm *kvm,\n\t\t\t    struct kvm_enc_region *range)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct enc_region *region;\n\tint ret = 0;\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\tif (range->addr > ULONG_MAX || range->size > ULONG_MAX)\n\t\treturn -EINVAL;\n\tregion = kzalloc(sizeof(*region), GFP_KERNEL_ACCOUNT);\n\tif (!region)\n\t\treturn -ENOMEM;\n\tregion->pages = sev_pin_memory(kvm, range->addr, range->size, &region->npages, 1);\n\tif (IS_ERR(region->pages)) {\n\t\tret = PTR_ERR(region->pages);\n\t\tgoto e_free;\n\t}\n\tsev_clflush_pages(region->pages, region->npages);\n\tregion->uaddr = range->addr;\n\tregion->size = range->size;\n\tmutex_lock(&kvm->lock);\n\tlist_add_tail(&region->list, &sev->regions_list);\n\tmutex_unlock(&kvm->lock);\n\treturn ret;\ne_free:\n\tkfree(region);\n\treturn ret;\n}", "target": 0}
{"code": "asmlinkage long sys_stime(time_t __user *tptr)\n{\n\tstruct timespec tv;\n\tint err;\n\tif (get_user(tv.tv_sec, tptr))\n\t\treturn -EFAULT;\n\ttv.tv_nsec = 0;\n\terr = security_settime(&tv, NULL);\n\tif (err)\n\t\treturn err;\n\tdo_settimeofday(&tv);\n\treturn 0;\n}", "target": 0}
{"code": "static int bnx2x_gunzip(struct bnx2x *bp, const u8 *zbuf, int len)\n{\n\tint n, rc;\n\tif ((zbuf[0] != 0x1f) || (zbuf[1] != 0x8b) || (zbuf[2] != Z_DEFLATED)) {\n\t\tBNX2X_ERR(\"Bad gzip header\\n\");\n\t\treturn -EINVAL;\n\t}\n\tn = 10;\n#define FNAME\t\t\t\t0x8\n\tif (zbuf[3] & FNAME)\n\t\twhile ((zbuf[n++] != 0) && (n < len));\n\tbp->strm->next_in = (typeof(bp->strm->next_in))zbuf + n;\n\tbp->strm->avail_in = len - n;\n\tbp->strm->next_out = bp->gunzip_buf;\n\tbp->strm->avail_out = FW_BUF_SIZE;\n\trc = zlib_inflateInit2(bp->strm, -MAX_WBITS);\n\tif (rc != Z_OK)\n\t\treturn rc;\n\trc = zlib_inflate(bp->strm, Z_FINISH);\n\tif ((rc != Z_OK) && (rc != Z_STREAM_END))\n\t\tnetdev_err(bp->dev, \"Firmware decompression error: %s\\n\",\n\t\t\t   bp->strm->msg);\n\tbp->gunzip_outlen = (FW_BUF_SIZE - bp->strm->avail_out);\n\tif (bp->gunzip_outlen & 0x3)\n\t\tnetdev_err(bp->dev,\n\t\t\t   \"Firmware decompression error: gunzip_outlen (%d) not aligned\\n\",\n\t\t\t\tbp->gunzip_outlen);\n\tbp->gunzip_outlen >>= 2;\n\tzlib_inflateEnd(bp->strm);\n\tif (rc == Z_STREAM_END)\n\t\treturn 0;\n\treturn rc;\n}", "target": 0}
{"code": "static int unix_autobind(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk);\n\tstatic u32 ordernum = 1;\n\tstruct unix_address *addr;\n\tint err;\n\tunsigned int retries = 0;\n\terr = mutex_lock_interruptible(&u->readlock);\n\tif (err)\n\t\treturn err;\n\terr = 0;\n\tif (u->addr)\n\t\tgoto out;\n\terr = -ENOMEM;\n\taddr = kzalloc(sizeof(*addr) + sizeof(short) + 16, GFP_KERNEL);\n\tif (!addr)\n\t\tgoto out;\n\taddr->name->sun_family = AF_UNIX;\n\tatomic_set(&addr->refcnt, 1);\nretry:\n\taddr->len = sprintf(addr->name->sun_path+1, \"%05x\", ordernum) + 1 + sizeof(short);\n\taddr->hash = unix_hash_fold(csum_partial(addr->name, addr->len, 0));\n\tspin_lock(&unix_table_lock);\n\tordernum = (ordernum+1)&0xFFFFF;\n\tif (__unix_find_socket_byname(net, addr->name, addr->len, sock->type,\n\t\t\t\t      addr->hash)) {\n\t\tspin_unlock(&unix_table_lock);\n\t\tcond_resched();\n\t\tif (retries++ == 0xFFFFF) {\n\t\t\terr = -ENOSPC;\n\t\t\tkfree(addr);\n\t\t\tgoto out;\n\t\t}\n\t\tgoto retry;\n\t}\n\taddr->hash ^= sk->sk_type;\n\t__unix_remove_socket(sk);\n\tu->addr = addr;\n\t__unix_insert_socket(&unix_socket_table[addr->hash], sk);\n\tspin_unlock(&unix_table_lock);\n\terr = 0;\nout:\tmutex_unlock(&u->readlock);\n\treturn err;\n}", "target": 0}
{"code": "AddParserToList(parserList_t **ppListRoot, parser_t *pParser)\n{\n\tparserList_t *pThis;\n\tparserList_t *pTail;\n\tDEFiRet;\n\tCHKmalloc(pThis = MALLOC(sizeof(parserList_t)));\n\tpThis->pParser = pParser;\n\tpThis->pNext = NULL;\n\tif(*ppListRoot == NULL) {\n\t\tpThis->pNext = *ppListRoot;\n\t\t*ppListRoot = pThis;\n\t} else {\n\t\tfor(pTail = *ppListRoot ; pTail->pNext != NULL ; pTail = pTail->pNext)\n\t\t\t;\n\t\tpTail->pNext = pThis;\n\t}\nDBGPRINTF(\"DDDDD: added parser '%s' to list %p\\n\", pParser->pName, ppListRoot);\nfinalize_it:\n\tRETiRet;\n}", "target": 0}
{"code": "entry_repeat_range(regex_t* reg, int id, int lower, int upper)\n{\n#define REPEAT_RANGE_ALLOC  4\n  OnigRepeatRange* p;\n  if (reg->repeat_range_alloc == 0) {\n    p = (OnigRepeatRange* )xmalloc(sizeof(OnigRepeatRange) * REPEAT_RANGE_ALLOC);\n    CHECK_NULL_RETURN_MEMERR(p);\n    reg->repeat_range = p;\n    reg->repeat_range_alloc = REPEAT_RANGE_ALLOC;\n  }\n  else if (reg->repeat_range_alloc <= id) {\n    int n;\n    n = reg->repeat_range_alloc + REPEAT_RANGE_ALLOC;\n    p = (OnigRepeatRange* )xrealloc(reg->repeat_range,\n                                    sizeof(OnigRepeatRange) * n);\n    CHECK_NULL_RETURN_MEMERR(p);\n    reg->repeat_range = p;\n    reg->repeat_range_alloc = n;\n  }\n  else {\n    p = reg->repeat_range;\n  }\n  p[id].lower = lower;\n  p[id].upper = (IS_REPEAT_INFINITE(upper) ? 0x7fffffff : upper);\n  return 0;\n}", "target": 0}
{"code": "file_pipe2file(struct magic_set *ms, int fd, const void *startbuf,\n    size_t nbytes)\n{\n\tchar buf[4096];\n\tssize_t r;\n\tint tfd;\n\t(void)strlcpy(buf, \"/tmp/file.XXXXXX\", sizeof buf);\n#ifndef HAVE_MKSTEMP\n\t{\n\t\tchar *ptr = mktemp(buf);\n\t\ttfd = open(ptr, O_RDWR|O_TRUNC|O_EXCL|O_CREAT, 0600);\n\t\tr = errno;\n\t\t(void)unlink(ptr);\n\t\terrno = r;\n\t}\n#else\n\t{\n\t\tint te;\n\t\ttfd = mkstemp(buf);\n\t\tte = errno;\n\t\t(void)unlink(buf);\n\t\terrno = te;\n\t}\n#endif\n\tif (tfd == -1) {\n\t\tfile_error(ms, errno,\n\t\t    \"cannot create temporary file for pipe copy\");\n\t\treturn -1;\n\t}\n\tif (swrite(tfd, startbuf, nbytes) != (ssize_t)nbytes)\n\t\tr = 1;\n\telse {\n\t\twhile ((r = sread(fd, buf, sizeof(buf), 1)) > 0)\n\t\t\tif (swrite(tfd, buf, (size_t)r) != r)\n\t\t\t\tbreak;\n\t}\n\tswitch (r) {\n\tcase -1:\n\t\tfile_error(ms, errno, \"error copying from pipe to temp file\");\n\t\treturn -1;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tfile_error(ms, errno, \"error while writing to temp file\");\n\t\treturn -1;\n\t}\n\tif ((fd = dup2(tfd, fd)) == -1) {\n\t\tfile_error(ms, errno, \"could not dup descriptor for temp file\");\n\t\treturn -1;\n\t}\n\t(void)close(tfd);\n\tif (FINFO_LSEEK_FUNC(fd, (off_t)0, SEEK_SET) == (off_t)-1) {\n\t\tfile_badseek(ms);\n\t\treturn -1;\n\t}\n\treturn fd;\n}", "target": 0}
{"code": "int http_header_add_tail(struct buffer *b, struct http_msg *msg,\n\t\t\t struct hdr_idx *hdr_idx, const char *text)\n{\n\tint bytes, len;\n\tlen = strlen(text);\n\tbytes = buffer_insert_line2(b, b->data + msg->eoh, text, len);\n\tif (!bytes)\n\t\treturn -1;\n\thttp_msg_move_end(msg, bytes);\n\treturn hdr_idx_add(len, 1, hdr_idx, hdr_idx->tail);\n}", "target": 0}
{"code": "static gboolean avrcp_search_rsp(struct avctp *conn, uint8_t *operands,\n\t\t\t\t\tsize_t operand_count, void *user_data)\n{\n\tstruct avrcp_browsing_header *pdu = (void *) operands;\n\tstruct avrcp *session = (void *) user_data;\n\tstruct avrcp_player *player = session->controller->player;\n\tstruct media_player *mp = player->user_data;\n\tint ret;\n\tif (pdu == NULL) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\tif (pdu->params[0] != AVRCP_STATUS_SUCCESS || operand_count < 7) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tplayer->uid_counter = get_be16(&pdu->params[1]);\n\tret = get_be32(&pdu->params[3]);\ndone:\n\tmedia_player_search_complete(mp, ret);\n\treturn FALSE;\n}", "target": 0}
{"code": "static void bnx2x_config_mf_bw(struct bnx2x *bp)\n{\n\tif (bp->link_vars.link_up) {\n\t\tbnx2x_cmng_fns_init(bp, true, CMNG_FNS_MINMAX);\n\t\tbnx2x_link_sync_notify(bp);\n\t}\n\tstorm_memset_cmng(bp, &bp->cmng, BP_PORT(bp));\n}", "target": 0}
{"code": "static void *do_smb_super_data_conv(void *raw_data)\n{\n\tstruct smb_mount_data *s = raw_data;\n\tstruct compat_smb_mount_data *c_s = raw_data;\n\tif (c_s->version != SMB_MOUNT_OLDVERSION)\n\t\tgoto out;\n\ts->dir_mode = c_s->dir_mode;\n\ts->file_mode = c_s->file_mode;\n\ts->gid = c_s->gid;\n\ts->uid = c_s->uid;\n\ts->mounted_uid = c_s->mounted_uid;\n out:\n\treturn raw_data;\n}", "target": 0}
{"code": "fbFetch_x4r4g4b4 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD16 *pixel = (const CARD16 *)bits + x;\n    const CARD16 *end = pixel + width;\n    while (pixel < end) {\n        CARD32  p = READ(pixel++);\n        CARD32  r,g,b;\n        r = ((p & 0x0f00) | ((p & 0x0f00) >> 4)) << 12;\n        g = ((p & 0x00f0) | ((p & 0x00f0) >> 4)) << 8;\n        b = ((p & 0x000f) | ((p & 0x000f) << 4));\n        WRITE(buffer++, (0xff000000 | r | g | b));\n    }\n}", "target": 0}
{"code": "    uint32_t TiffImageEntry::doSizeData() const\n    {\n        uint32_t len = 0;\n        if (group() > mnId) { \n            len = sizeImage();\n        }\n        return len;\n    } ", "target": 0}
{"code": "            AuthenticationInfo(\n                    AuthenticationStatus auth_status)\n                : identity_handle_(nullptr)\n                , handshake_handle_(nullptr)\n                , auth_status_(auth_status)\n                , expected_sequence_number_(0)\n                , change_sequence_number_(SequenceNumber_t::unknown())\n                , handshake_requests_sent_(0)\n            {\n            }", "target": 0}
{"code": "rb_update_iter_read_stamp(struct ring_buffer_iter *iter,\n\t\t\t  struct ring_buffer_event *event)\n{\n\tu64 delta;\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\treturn;\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\tdelta = rb_event_time_stamp(event);\n\t\titer->read_stamp += delta;\n\t\treturn;\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\tdelta = rb_event_time_stamp(event);\n\t\titer->read_stamp = delta;\n\t\treturn;\n\tcase RINGBUF_TYPE_DATA:\n\t\titer->read_stamp += event->time_delta;\n\t\treturn;\n\tdefault:\n\t\tRB_WARN_ON(iter->cpu_buffer, 1);\n\t}\n\treturn;\n}", "target": 0}
{"code": "void sqlite3Fts3Dequote(char *z){\n  char quote;                     \n  quote = z[0];\n  if( quote=='[' || quote=='\\'' || quote=='\"' || quote=='`' ){\n    int iIn = 1;                  \n    int iOut = 0;                 \n    if( quote=='[' ) quote = ']';  \n    while( ALWAYS(z[iIn]) ){\n      if( z[iIn]==quote ){\n        if( z[iIn+1]!=quote ) break;\n        z[iOut++] = quote;\n        iIn += 2;\n      }else{\n        z[iOut++] = z[iIn++];\n      }\n    }\n    z[iOut] = '\\0';\n  }\n}", "target": 0}
{"code": "GF_Err schm_box_size(GF_Box *s)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += 8;\n\tif (ptr->flags & 0x000001) ptr->size += 1 + (ptr->URI ? strlen(ptr->URI) : 0);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static MagickBooleanType SetPixelCacheExtent(Image *image,MagickSizeType length)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  MagickOffsetType\n    count,\n    extent,\n    offset;\n  cache_info=(CacheInfo *) image->cache;\n  if (image->debug != MagickFalse)\n    {\n      char\n        format[MagickPathExtent],\n        message[MagickPathExtent];\n      (void) FormatMagickSize(length,MagickFalse,\"B\",MagickPathExtent,format);\n      (void) FormatLocaleString(message,MagickPathExtent,\n        \"extend %s (%s[%d], disk, %s)\",cache_info->filename,\n        cache_info->cache_filename,cache_info->file,format);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  if (length != (MagickSizeType) ((MagickOffsetType) length))\n    return(MagickFalse);\n  offset=(MagickOffsetType) lseek(cache_info->file,0,SEEK_END);\n  if (offset < 0)\n    return(MagickFalse);\n  if ((MagickSizeType) offset >= length)\n    count=(MagickOffsetType) 1;\n  else\n    {\n      extent=(MagickOffsetType) length-1;\n      count=WritePixelCacheRegion(cache_info,extent,1,(const unsigned char *)\n        \"\");\n      if (count != 1)\n        return(MagickFalse);\n#if defined(MAGICKCORE_HAVE_POSIX_FALLOCATE)\n      if (cache_info->synchronize != MagickFalse)\n        (void) posix_fallocate(cache_info->file,offset+1,extent-offset);\n#endif\n#if defined(SIGBUS)\n      (void) signal(SIGBUS,CacheSignalHandler);\n#endif\n    }\n  offset=(MagickOffsetType) lseek(cache_info->file,0,SEEK_SET);\n  if (offset < 0)\n    return(MagickFalse);\n  return(MagickTrue);\n}", "target": 0}
{"code": "static int __grow_ple_window(int val)\n{\n\tif (ple_window_grow < 1)\n\t\treturn ple_window;\n\tval = min(val, ple_window_actual_max);\n\tif (ple_window_grow < ple_window)\n\t\tval *= ple_window_grow;\n\telse\n\t\tval += ple_window_grow;\n\treturn val;\n}", "target": 0}
{"code": "clamp_default(const fz_colorspace *cs, const float *src, float *dst)\n{\n\tint i;\n\tfor (i = 0; i < cs->n; i++)\n\t\tdst[i] = fz_clamp(src[i], 0, 1);\n}", "target": 0}
{"code": "SPICE_GNUC_VISIBLE void spice_server_vm_stop(SpiceServer *reds)\n{\n    reds->vm_running = FALSE;\n    for (auto dev: reds->char_devices) {\n        dev->stop();\n    }\n    reds_on_vm_stop(reds);\n}", "target": 0}
{"code": "AP_DECLARE(void) ap_setup_auth_internal(apr_pool_t *ptemp)\n{\n    int total_auth_hooks = 0;\n    int total_auth_providers = 0;\n    auth_internal_per_conf = 0;\n    if (_hooks.link_access_checker) {\n        total_auth_hooks += _hooks.link_access_checker->nelts;\n    }\n    if (_hooks.link_access_checker_ex) {\n        total_auth_hooks += _hooks.link_access_checker_ex->nelts;\n    }\n    if (_hooks.link_check_user_id) {\n        total_auth_hooks += _hooks.link_check_user_id->nelts;\n    }\n    if (_hooks.link_auth_checker) {\n        total_auth_hooks += _hooks.link_auth_checker->nelts;\n    }\n    if (total_auth_hooks > auth_internal_per_conf_hooks) {\n        return;\n    }\n    total_auth_providers +=\n        ap_list_provider_names(ptemp, AUTHN_PROVIDER_GROUP,\n                               AUTHN_PROVIDER_VERSION)->nelts;\n    total_auth_providers +=\n        ap_list_provider_names(ptemp, AUTHZ_PROVIDER_GROUP,\n                               AUTHZ_PROVIDER_VERSION)->nelts;\n    if (total_auth_providers > auth_internal_per_conf_providers) {\n        return;\n    }\n    auth_internal_per_conf = 1;\n}", "target": 0}
{"code": "epass2003_select_aid(struct sc_card *card, const sc_path_t * in_path, sc_file_t ** file_out)\n{\n\tint r = 0;\n\tif (card->cache.valid\n\t\t\t&& card->cache.current_path.type == SC_PATH_TYPE_DF_NAME\n\t\t\t&& card->cache.current_path.len == in_path->len\n\t\t\t&& memcmp(card->cache.current_path.value, in_path->value, in_path->len) == 0) {\n\t\tif (file_out) {\n\t\t\t*file_out = sc_file_new();\n\t\t\tif (!file_out)\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t}\n\telse {\n\t\tr = iso_ops->select_file(card, in_path, file_out);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\t\tcard->cache.current_path.type = SC_PATH_TYPE_DF_NAME;\n\t\tcard->cache.current_path.len = in_path->len;\n\t\tmemcpy(card->cache.current_path.value, in_path->value, in_path->len);\n\t}\n\tif (file_out) {\n\t\tsc_file_t *file = *file_out;\n\t\tfile->type = SC_FILE_TYPE_DF;\n\t\tfile->ef_structure = SC_FILE_EF_UNKNOWN;\n\t\tfile->path.len = 0;\n\t\tfile->size = 0;\n\t\tmemcpy(file->name, in_path->value, in_path->len);\n\t\tfile->namelen = in_path->len;\n\t\tfile->id = 0x0000;\n\t}\n\tLOG_FUNC_RETURN(card->ctx, r);\n}", "target": 0}
{"code": "static void init_object(struct kmem_cache *s, void *object, int active)\n{\n\tu8 *p = object;\n\tif (s->flags & __OBJECT_POISON) {\n\t\tmemset(p, POISON_FREE, s->objsize - 1);\n\t\tp[s->objsize - 1] = POISON_END;\n\t}\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p + s->objsize,\n\t\t\tactive ? SLUB_RED_ACTIVE : SLUB_RED_INACTIVE,\n\t\t\ts->inuse - s->objsize);\n}", "target": 0}
{"code": "yin_read_submodule(struct lys_module *module, const char *data, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lyxml_elem *yin;\n    struct lys_submodule *submodule = NULL;\n    const char *value;\n    yin = lyxml_parse_mem(ctx, data, LYXML_PARSE_NOMIXEDCONTENT);\n    if (!yin) {\n        return NULL;\n    }\n    if (!yin->name || strcmp(yin->name, \"submodule\")) {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yin->name);\n        goto error;\n    }\n    GETVAL(ctx, value, yin, \"name\");\n    if (lyp_check_identifier(ctx, value, LY_IDENT_NAME, NULL, NULL)) {\n        goto error;\n    }\n    submodule = calloc(1, sizeof *submodule);\n    LY_CHECK_ERR_GOTO(!submodule, LOGMEM(ctx), error);\n    submodule->ctx = ctx;\n    submodule->name = lydict_insert(ctx, value, strlen(value));\n    submodule->type = 1;\n    submodule->implemented = module->implemented;\n    submodule->belongsto = module;\n    if (lyp_check_circmod_add((struct lys_module *)submodule)) {\n        goto error;\n    }\n    LOGVRB(\"Reading submodule \\\"%s\\\".\", submodule->name);\n    if (read_sub_module(module, submodule, yin, unres)) {\n        goto error;\n    }\n    lyp_sort_revisions((struct lys_module *)submodule);\n    lyxml_free(ctx, yin);\n    lyp_check_circmod_pop(ctx);\n    LOGVRB(\"Submodule \\\"%s\\\" successfully parsed.\", submodule->name);\n    return submodule;\nerror:\n    lyxml_free(ctx, yin);\n    if (!submodule) {\n        LOGERR(ctx, ly_errno, \"Submodule parsing failed.\");\n        return NULL;\n    }\n    LOGERR(ctx, ly_errno, \"Submodule \\\"%s\\\" parsing failed.\", submodule->name);\n    unres_schema_free((struct lys_module *)submodule, &unres, 0);\n    lyp_check_circmod_pop(ctx);\n    lys_sub_module_remove_devs_augs((struct lys_module *)submodule);\n    lys_submodule_module_data_free(submodule);\n    lys_submodule_free(submodule, NULL);\n    return NULL;\n}", "target": 0}
{"code": "sanitize (GPtrArray *array)\n{\n        int i;\n        GPtrArray *new;\n        g_debug (\"before sanitizing\");\n        for (i = 0; i < array->len; ++i) {\n                if (array->pdata[i]) {\n                        print_configuration (array->pdata[i], \"before\");\n                }\n        }\n        for (i = 1; i < array->len; ++i) {\n                int j;\n                for (j = 0; j < i; ++j) {\n                        GnomeRRConfig *this = array->pdata[j];\n                        GnomeRRConfig *other = array->pdata[i];\n                        if (this && other && gnome_rr_config_equal (this, other)) {\n                                g_debug (\"removing duplicate configuration\");\n                                gnome_rr_config_free (this);\n                                array->pdata[j] = NULL;\n                                break;\n                        }\n                }\n        }\n        for (i = 0; i < array->len; ++i) {\n                GnomeRRConfig *config = array->pdata[i];\n                if (config) {\n                        gboolean all_off = TRUE;\n                        int j;\n                        for (j = 0; config->outputs[j] != NULL; ++j) {\n                                if (config->outputs[j]->on)\n                                        all_off = FALSE;\n                        }\n                        if (all_off) {\n                                gnome_rr_config_free (array->pdata[i]);\n                                array->pdata[i] = NULL;\n                        }\n                }\n        }\n        new = g_ptr_array_new ();\n        for (i = 0; i < array->len; ++i) {\n                if (array->pdata[i]) {\n                        g_ptr_array_add (new, array->pdata[i]);\n                        print_configuration (array->pdata[i], \"Final\");\n                }\n        }\n        if (new->len > 0) {\n                g_ptr_array_add (new, NULL);\n        } else {\n                g_ptr_array_free (new, TRUE);\n                new = NULL;\n        }\n        g_ptr_array_free (array, TRUE);\n        return new;\n}", "target": 0}
{"code": "static long shm_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tif (!sfd->file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\treturn sfd->file->f_op->fallocate(file, mode, offset, len);\n}", "target": 0}
{"code": "static void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t struct desc_struct *desc, u32 base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tstruct kvm_segment var;\n\tvar.selector = selector;\n\tvar.base = get_desc_base(desc);\n#ifdef CONFIG_X86_64\n\tvar.base |= ((u64)base3) << 32;\n#endif\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}", "target": 0}
{"code": "irc_server_msgq_add_msg (struct t_irc_server *server, const char *msg)\n{\n    struct t_irc_message *message;\n    if (!server->unterminated_message && !msg[0])\n        return;\n    message = malloc (sizeof (*message));\n    if (!message)\n    {\n        weechat_printf (server->buffer,\n                        _(\"%s%s: not enough memory for received message\"),\n                        weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        return;\n    }\n    message->server = server;\n    if (server->unterminated_message)\n    {\n        message->data = malloc (strlen (server->unterminated_message) +\n                                strlen (msg) + 1);\n        if (!message->data)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%s%s: not enough memory for received message\"),\n                            weechat_prefix (\"error\"), IRC_PLUGIN_NAME);\n        }\n        else\n        {\n            strcpy (message->data, server->unterminated_message);\n            strcat (message->data, msg);\n        }\n        free (server->unterminated_message);\n        server->unterminated_message = NULL;\n    }\n    else\n        message->data = strdup (msg);\n    message->next_message = NULL;\n    if (irc_msgq_last_msg)\n    {\n        irc_msgq_last_msg->next_message = message;\n        irc_msgq_last_msg = message;\n    }\n    else\n    {\n        irc_recv_msgq = message;\n        irc_msgq_last_msg = message;\n    }\n}", "target": 0}
{"code": "  static std::string getProtobufBinaryStringFromMessage(const Protobuf::Message& message) {\n    std::string pb_binary_str;\n    pb_binary_str.reserve(message.ByteSizeLong());\n    message.SerializeToString(&pb_binary_str);\n    return pb_binary_str;\n  }", "target": 0}
{"code": "TEST_F(QueryPlannerTest, IntersectBasicTwoPredCompoundMatchesIdxOrder1) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN | QueryPlannerParams::INDEX_INTERSECTION;\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    runQuery(fromjson(\"{a:1, b:1}\"));\n    assertNumSolutions(3U);\n    assertSolutionExists(\n        \"{fetch: {filter: {b:1}, node: \"\n        \"{ixscan: {filter: null, pattern: {a:1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {a:1}, node: \"\n        \"{ixscan: {filter: null, pattern: {b:1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {andSorted: {nodes: [\"\n        \"{ixscan: {filter: null, pattern: {a:1}}},\"\n        \"{ixscan: {filter: null, pattern: {b:1}}}]}}}}\");\n}", "target": 0}
{"code": "int kvm_get_dirty_log_protect(struct kvm *kvm,\n\t\t\tstruct kvm_dirty_log *log, bool *is_dirty)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint r, i, as_id, id;\n\tunsigned long n;\n\tunsigned long *dirty_bitmap;\n\tunsigned long *dirty_bitmap_buffer;\n\tr = -EINVAL;\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\tgoto out;\n\tslots = __kvm_memslots(kvm, as_id);\n\tmemslot = id_to_memslot(slots, id);\n\tdirty_bitmap = memslot->dirty_bitmap;\n\tr = -ENOENT;\n\tif (!dirty_bitmap)\n\t\tgoto out;\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\tdirty_bitmap_buffer = dirty_bitmap + n / sizeof(long);\n\tmemset(dirty_bitmap_buffer, 0, n);\n\tspin_lock(&kvm->mmu_lock);\n\t*is_dirty = false;\n\tfor (i = 0; i < n / sizeof(long); i++) {\n\t\tunsigned long mask;\n\t\tgfn_t offset;\n\t\tif (!dirty_bitmap[i])\n\t\t\tcontinue;\n\t\t*is_dirty = true;\n\t\tmask = xchg(&dirty_bitmap[i], 0);\n\t\tdirty_bitmap_buffer[i] = mask;\n\t\tif (mask) {\n\t\t\toffset = i * BITS_PER_LONG;\n\t\t\tkvm_arch_mmu_enable_log_dirty_pt_masked(kvm, memslot,\n\t\t\t\t\t\t\t\toffset, mask);\n\t\t}\n\t}\n\tspin_unlock(&kvm->mmu_lock);\n\tr = -EFAULT;\n\tif (copy_to_user(log->dirty_bitmap, dirty_bitmap_buffer, n))\n\t\tgoto out;\n\tr = 0;\nout:\n\treturn r;\n}", "target": 0}
{"code": "static int nfs4_xdr_dec_delegreturn(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    struct nfs4_delegreturnres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_getfattr(xdr, res->fattr, res->server);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_delegreturn(xdr);\nout:\n\treturn status;\n}", "target": 0}
{"code": "static inline struct sched_clock_data *cpu_sdc(int cpu)\n{\n\treturn &per_cpu(sched_clock_data, cpu);\n}", "target": 0}
{"code": "static const char *unquote_token_cstr(Token *t)\n{\n    if (t->type != TOK_STRING)\n\treturn tok_text(t);\n    t->type = TOK_INTERNAL_STRING;\n    if (t->len > INLINE_TEXT) {\n\tchar *p = t->text.p.ptr;\n\tt->len = nasm_unquote_cstr(p, NULL);\n\tif (t->len <= INLINE_TEXT) {\n\t    nasm_zero(t->text.a);\n\t    memcpy(t->text.a, p, t->len);\n\t    nasm_free(p);\n\t    return t->text.a;\n\t} else {\n\t    return p;\n\t}\n    } else {\n\tt->len = nasm_unquote_cstr(t->text.a, NULL);\n\treturn t->text.a;\n    }\n}", "target": 0}
{"code": "static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tssize_t n;\n\tWARN_ONCE(1, \"%s is deprecated and scheduled for removal.\", __func__);\n\tdown_write(&tty->termios_rwsem);\n\tn = chars_in_buffer(tty);\n\tup_write(&tty->termios_rwsem);\n\treturn n;\n}", "target": 0}
{"code": "apr_status_t h2_request_add_header(h2_request *req, apr_pool_t *pool, \n                                   const char *name, size_t nlen,\n                                   const char *value, size_t vlen)\n{\n    apr_status_t status = APR_SUCCESS;\n    if (nlen <= 0) {\n        return status;\n    }\n    if (name[0] == ':') {\n        if (!apr_is_empty_table(req->headers)) {\n            ap_log_perror(APLOG_MARK, APLOG_ERR, 0, pool,\n                          APLOGNO(02917) \n                          \"h2_request: pseudo header after request start\");\n            return APR_EGENERAL;\n        }\n        if (H2_HEADER_METHOD_LEN == nlen\n            && !strncmp(H2_HEADER_METHOD, name, nlen)) {\n            req->method = apr_pstrndup(pool, value, vlen);\n        }\n        else if (H2_HEADER_SCHEME_LEN == nlen\n                 && !strncmp(H2_HEADER_SCHEME, name, nlen)) {\n            req->scheme = apr_pstrndup(pool, value, vlen);\n        }\n        else if (H2_HEADER_PATH_LEN == nlen\n                 && !strncmp(H2_HEADER_PATH, name, nlen)) {\n            req->path = apr_pstrndup(pool, value, vlen);\n        }\n        else if (H2_HEADER_AUTH_LEN == nlen\n                 && !strncmp(H2_HEADER_AUTH, name, nlen)) {\n            req->authority = apr_pstrndup(pool, value, vlen);\n        }\n        else {\n            char buffer[32];\n            memset(buffer, 0, 32);\n            strncpy(buffer, name, (nlen > 31)? 31 : nlen);\n            ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, pool,\n                          APLOGNO(02954) \n                          \"h2_request: ignoring unknown pseudo header %s\",\n                          buffer);\n        }\n    }\n    else {\n        status = h2_req_add_header(req->headers, pool, name, nlen, value, vlen);\n    }\n    return status;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, NoBlockingSortsAllowedTest) {\n    params.options = QueryPlannerParams::NO_BLOCKING_SORT;\n    runQuerySortProj(BSONObj(), BSON(\"x\" << 1), BSONObj());\n    assertNumSolutions(0U);\n    addIndex(BSON(\"x\" << 1));\n    runQuerySortProj(BSONObj(), BSON(\"x\" << 1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: \"\n        \"{filter: null, pattern: {x: 1}}}}}\");\n}", "target": 0}
{"code": "void HTMLInputElement::requiredAttributeChanged()\n{\n    HTMLTextFormControlElement::requiredAttributeChanged();\n    if (CheckedRadioButtons* buttons = checkedRadioButtons())\n        buttons->requiredAttributeChanged(this);\n    m_inputTypeView->requiredAttributeChanged();\n}", "target": 0}
{"code": "ZEND_METHOD(exception, __clone)\n{\n\tzend_throw_exception(NULL, \"Cannot clone object using __clone()\", 0 TSRMLS_CC);\n}", "target": 0}
{"code": "void usbredirparser_send_free_bulk_streams(struct usbredirparser *parser,\n    uint64_t id,\n    struct usb_redir_free_bulk_streams_header *free_bulk_streams)\n{\n    usbredirparser_queue(parser, usb_redir_free_bulk_streams, id,\n                         free_bulk_streams, NULL, 0);\n}", "target": 0}
{"code": "dirserv_thinks_router_is_hs_dir(const routerinfo_t *router,\n                                const node_t *node, time_t now)\n{\n  long uptime;\n  if (stats_n_seconds_working >\n      get_options()->MinUptimeHidServDirectoryV2 * 1.1)\n    uptime = MIN(rep_hist_get_uptime(router->cache_info.identity_digest, now),\n                 real_uptime(router, now));\n  else\n    uptime = real_uptime(router, now);\n  return (router->wants_to_be_hs_dir &&\n          router->supports_tunnelled_dir_requests &&\n          node->is_stable && node->is_fast &&\n          uptime >= get_options()->MinUptimeHidServDirectoryV2 &&\n          router_is_active(router, node, now));\n}", "target": 0}
{"code": "ephy_embed_single_set_network_status (EphyEmbedSingle *single,\n                                      gboolean status)\n{\n  if (status != single->priv->online)\n    single->priv->online = status;\n}", "target": 0}
{"code": "static void bnx2x_reg_wr_ind(struct bnx2x *bp, u32 addr, u32 val)\n{\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS, addr);\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_DATA, val);\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,\n\t\t\t       PCICFG_VENDOR_ID_OFFSET);\n}", "target": 0}
{"code": "TIFFjpeg_start_decompress(JPEGState* sp)\n{\n\treturn CALLVJPEG(sp, jpeg_start_decompress(&sp->cinfo.d));\n}", "target": 0}
{"code": "void FrameLoader::didFirstLayout()\n{\n    if (m_frame->page() && isBackForwardLoadType(m_loadType))\n        history()->restoreScrollPositionAndViewState();\n}", "target": 0}
{"code": "static inline void clear_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype)\n{\n\tstruct page_ext *page_ext;\n\tif (!debug_guardpage_enabled())\n\t\treturn;\n\tpage_ext = lookup_page_ext(page);\n\tif (unlikely(!page_ext))\n\t\treturn;\n\t__clear_bit(PAGE_EXT_DEBUG_GUARD, &page_ext->flags);\n\tset_page_private(page, 0);\n\tif (!is_migrate_isolate(migratetype))\n\t\t__mod_zone_freepage_state(zone, (1 << order), migratetype);\n}", "target": 0}
{"code": "static int sig_cb(const char *elem, int len, void *arg)\n{\n    sig_cb_st *sarg = arg;\n    size_t i;\n    char etmp[20], *p;\n    int sig_alg, hash_alg;\n    if (elem == NULL)\n        return 0;\n    if (sarg->sigalgcnt == MAX_SIGALGLEN)\n        return 0;\n    if (len > (int)(sizeof(etmp) - 1))\n        return 0;\n    memcpy(etmp, elem, len);\n    etmp[len] = 0;\n    p = strchr(etmp, '+');\n    if (!p)\n        return 0;\n    *p = 0;\n    p++;\n    if (!*p)\n        return 0;\n    if (!strcmp(etmp, \"RSA\"))\n        sig_alg = EVP_PKEY_RSA;\n    else if (!strcmp(etmp, \"DSA\"))\n        sig_alg = EVP_PKEY_DSA;\n    else if (!strcmp(etmp, \"ECDSA\"))\n        sig_alg = EVP_PKEY_EC;\n    else\n        return 0;\n    hash_alg = OBJ_sn2nid(p);\n    if (hash_alg == NID_undef)\n        hash_alg = OBJ_ln2nid(p);\n    if (hash_alg == NID_undef)\n        return 0;\n    for (i = 0; i < sarg->sigalgcnt; i += 2) {\n        if (sarg->sigalgs[i] == sig_alg && sarg->sigalgs[i + 1] == hash_alg)\n            return 0;\n    }\n    sarg->sigalgs[sarg->sigalgcnt++] = hash_alg;\n    sarg->sigalgs[sarg->sigalgcnt++] = sig_alg;\n    return 1;\n}", "target": 0}
{"code": "static int cardos_check_sw(sc_card_t *card, unsigned int sw1, unsigned int sw2)\n{\n\tconst int err_count = sizeof(cardos_errors)/sizeof(cardos_errors[0]);\n\tint i;\n\tfor (i = 0; i < err_count; i++) {\n\t\tif (cardos_errors[i].SWs == ((sw1 << 8) | sw2)) {\n\t\t\tif ( cardos_errors[i].errorstr ) \n\t\t\t\tsc_log(card->ctx,  \"%s\\n\",\n\t\t\t\t \tcardos_errors[i].errorstr);\n\t\t\treturn cardos_errors[i].errorno;\n\t\t}\n\t}\n        sc_log(card->ctx,  \"Unknown SWs; SW1=%02X, SW2=%02X\\n\", sw1, sw2);\n\treturn SC_ERROR_CARD_CMD_FAILED;\n}", "target": 0}
{"code": "bool RenderWidgetHostViewAura::DeleteRange(const gfx::Range& range) {\n  NOTIMPLEMENTED();\n  return false;\n}", "target": 0}
{"code": "_asn1_get_octet_string (const unsigned char *der, asn1_node node, int *len)\n{\n  int len2, len3, counter, tot_len, indefinite;\n  counter = 0;\n  if (*(der - 1) & ASN1_CLASS_STRUCTURED)\n    {\n      tot_len = 0;\n      indefinite = asn1_get_length_der (der, *len, &len3);\n      if (indefinite < -1)\n\treturn ASN1_DER_ERROR;\n      counter += len3;\n      if (indefinite >= 0)\n\tindefinite += len3;\n      while (1)\n\t{\n\t  if (counter > (*len))\n\t    return ASN1_DER_ERROR;\n\t  if (indefinite == -1)\n\t    {\n\t      if ((der[counter] == 0) && (der[counter + 1] == 0))\n\t\t{\n\t\t  counter += 2;\n\t\t  break;\n\t\t}\n\t    }\n\t  else if (counter >= indefinite)\n\t    break;\n\t  if (der[counter] != ASN1_TAG_OCTET_STRING)\n\t    return ASN1_DER_ERROR;\n\t  counter++;\n\t  len2 = asn1_get_length_der (der + counter, *len - counter, &len3);\n\t  if (len2 <= 0)\n\t    return ASN1_DER_ERROR;\n\t  counter += len3 + len2;\n\t  tot_len += len2;\n\t}\n      if (node)\n\t{\n\t  unsigned char temp[ASN1_MAX_LENGTH_SIZE];\n\t  int ret;\n\t  len2 = sizeof (temp);\n\t  asn1_length_der (tot_len, temp, &len2);\n\t  _asn1_set_value (node, temp, len2);\n\t  ret = _asn1_extract_der_octet (node, der, *len);\n\t  if (ret != ASN1_SUCCESS)\n\t    return ret;\n\t}\n    }\n  else\n    {\t\t\t\t\n      len2 = asn1_get_length_der (der, *len, &len3);\n      if (len2 < 0)\n\treturn ASN1_DER_ERROR;\n      counter = len3 + len2;\n      if (node)\n\t_asn1_set_value (node, der, counter);\n    }\n  *len = counter;\n  return ASN1_SUCCESS;\n}", "target": 0}
{"code": "smb2_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon,\n\t      struct cifs_sb_info *cifs_sb)\n{\n\tint rc;\n\t__le16 srch_path = 0; \n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = cifs_create_options(cifs_sb, 0);\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\trc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL,\n\t\t       NULL, NULL);\n\tif (rc)\n\t\treturn;\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_ATTRIBUTE_INFORMATION);\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_DEVICE_INFORMATION);\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n}", "target": 0}
{"code": "MagickExport MagickBooleanType GetOneVirtualPixelInfo(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  PixelInfo *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  const int\n    id = GetOpenMPThreadId();\n  register const Quantum\n    *magick_restrict p;\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  GetPixelInfo(image,pixel);\n  p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,1UL,1UL,\n    cache_info->nexus_info[id],exception);\n  if (p == (const Quantum *) NULL)\n    return(MagickFalse);\n  GetPixelInfoPixel(image,p,pixel);\n  return(MagickTrue);\n}", "target": 0}
{"code": "static int hwpoison_filter_dev(struct page *p)\n{\n\tstruct address_space *mapping;\n\tdev_t dev;\n\tif (hwpoison_filter_dev_major == ~0U &&\n\t    hwpoison_filter_dev_minor == ~0U)\n\t\treturn 0;\n\tif (PageSlab(p))\n\t\treturn -EINVAL;\n\tmapping = page_mapping(p);\n\tif (mapping == NULL || mapping->host == NULL)\n\t\treturn -EINVAL;\n\tdev = mapping->host->i_sb->s_dev;\n\tif (hwpoison_filter_dev_major != ~0U &&\n\t    hwpoison_filter_dev_major != MAJOR(dev))\n\t\treturn -EINVAL;\n\tif (hwpoison_filter_dev_minor != ~0U &&\n\t    hwpoison_filter_dev_minor != MINOR(dev))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err fiin_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\ts->size+= 2;\n\tgf_isom_check_position_list(s, ptr->partition_entries, &pos);\n\treturn GF_OK;\n}", "target": 0}
{"code": "    void CrwMap::encode(CiffHeader* pHead, const Image& image)\n    {\n        for (const CrwMapping* cmi = crwMapping_; cmi->ifdId_ != ifdIdNotSet; ++cmi) {\n            if (cmi->fromExif_ != 0) {\n                cmi->fromExif_(image, cmi, pHead);\n            }\n        }\n    } ", "target": 0}
{"code": "SPL_METHOD(SplObjectStorage, key)\n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(intern->index);\n} ", "target": 0}
{"code": "debug_printf_indent(const char * format, ...)\n{\nva_list ap;\nva_start(ap, format);\ndebug_vprintf(acl_level + expand_level, format, ap);\nva_end(ap);\n}", "target": 0}
{"code": "ofpact_check_output_port(ofp_port_t port, ofp_port_t max_ports)\n{\n    switch (port) {\n    case OFPP_IN_PORT:\n    case OFPP_TABLE:\n    case OFPP_NORMAL:\n    case OFPP_FLOOD:\n    case OFPP_ALL:\n    case OFPP_CONTROLLER:\n    case OFPP_LOCAL:\n        return 0;\n    case OFPP_NONE:\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n    default:\n        if (ofp_to_u16(port) < ofp_to_u16(max_ports)) {\n            return 0;\n        }\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n    }\n}", "target": 0}
{"code": "void ParamTraits<std::vector<unsigned char> >::Log(const param_type& p,\n                                                   std::string* l) {\n  LogBytes(p, l);\n}", "target": 0}
{"code": "static inline int memcmp_P(const void *a1, const void *b1, size_t len) {\n    const uint8_t* a = (const uint8_t*)(a1);\n    uint8_t* b = (uint8_t*)(b1);\n    for (size_t i=0; i<len; i++) {\n        uint8_t d = pgm_read_byte(a) - pgm_read_byte(b);\n        if (d) return d;\n        a++;\n        b++;\n    }\n    return 0;\n}", "target": 0}
{"code": "    void XmpParser::registeredNamespaces(Exiv2::Dictionary& dict)\n    {\n        bool bInit = !initialized_;\n        try {\n            if (bInit) initialize();\n            SXMPMeta::DumpNamespaces(nsDumper,&dict);\n            if (bInit) terminate();\n        } catch (const XMP_Error& e) {\n            throw Error(kerXMPToolkitError, e.GetID(), e.GetErrMsg());\n        }\n    }", "target": 0}
{"code": "static void php_apache_request_dtor(request_rec *r TSRMLS_DC)\n{\n\tphp_request_shutdown(NULL);\n}", "target": 0}
{"code": "SCOPE_LIST* license_new_scope_list()\n{\n\tSCOPE_LIST* scopeList;\n\tscopeList = (SCOPE_LIST*) malloc(sizeof(SCOPE_LIST));\n\tscopeList->count = 0;\n\tscopeList->array = NULL;\n\treturn scopeList;\n}", "target": 0}
{"code": "static SymbolsHeader parseHeader(RBuffer *buf) {\n\tut8 b[64];\n\tSymbolsHeader sh = { 0 };\n\t(void)r_buf_read_at (buf, 0, b, sizeof (b));\n\tsh.magic = r_read_le32 (b);\n\tsh.version = r_read_le32 (b + 4);\n\tsh.valid = sh.magic == 0xff01ff02;\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t\tsh.uuid[i] = b[24 + i];\n\t}\n\tsh.unk0 = r_read_le16 (b + 0x28);\n\tsh.unk1 = r_read_le16 (b + 0x2c); \n\tsh.slotsize = r_read_le16 (b + 0x2e);\n\tsh.size = 0x40;\n\treturn sh;\n}", "target": 0}
{"code": "int __export rad_packet_add_val(struct rad_packet_t *pack, const char *vendor_name, const char *name, const char *val)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_value_t *v;\n\tstruct rad_dict_vendor_t *vendor;\n\tif (pack->len + (vendor_name ? 8 : 2) + 4 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\tif (!attr)\n\t\treturn -1;\n\tv = rad_dict_find_val_name(attr, val);\n\tif (!v)\n\t\treturn -1;\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 4;\n\tra->val = v->val;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 4;\n\treturn 0;\n}", "target": 0}
{"code": "static int bnx2x_gunzip_init(struct bnx2x *bp)\n{\n\tbp->gunzip_buf = dma_alloc_coherent(&bp->pdev->dev, FW_BUF_SIZE,\n\t\t\t\t\t    &bp->gunzip_mapping, GFP_KERNEL);\n\tif (bp->gunzip_buf  == NULL)\n\t\tgoto gunzip_nomem1;\n\tbp->strm = kmalloc(sizeof(*bp->strm), GFP_KERNEL);\n\tif (bp->strm  == NULL)\n\t\tgoto gunzip_nomem2;\n\tbp->strm->workspace = vmalloc(zlib_inflate_workspacesize());\n\tif (bp->strm->workspace == NULL)\n\t\tgoto gunzip_nomem3;\n\treturn 0;\ngunzip_nomem3:\n\tkfree(bp->strm);\n\tbp->strm = NULL;\ngunzip_nomem2:\n\tdma_free_coherent(&bp->pdev->dev, FW_BUF_SIZE, bp->gunzip_buf,\n\t\t\t  bp->gunzip_mapping);\n\tbp->gunzip_buf = NULL;\ngunzip_nomem1:\n\tBNX2X_ERR(\"Cannot allocate firmware buffer for un-compression\\n\");\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "bool RenderView::allowDatabase(\n    WebFrame* frame, const WebString& name, const WebString& display_name,\n    unsigned long estimated_size) {\n  WebSecurityOrigin origin = frame->securityOrigin();\n  if (origin.isEmpty())\n    return false;  \n  bool result;\n  if (!Send(new ViewHostMsg_AllowDatabase(routing_id_,\n      origin.toString().utf8(), name, display_name, estimated_size, &result)))\n    return false;\n  Send(new ViewHostMsg_WebDatabaseAccessed(routing_id_,\n                                           GURL(origin.toString().utf8()),\n                                           name,\n                                           display_name,\n                                           estimated_size,\n                                           !result));\n  return result;\n}", "target": 0}
{"code": "static int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\tint ret;\n\tret = x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, addr,\n\t\t\t\t    PAGE_SIZE * 3);\n\tif (ret)\n\t\treturn ret;\n\tkvm->arch.tss_addr = addr;\n\treturn init_rmode_tss(kvm);\n}", "target": 0}
{"code": "PermissionRequestType PermissionUtil::GetRequestType(ContentSettingsType type) {\n  switch (type) {\n    case CONTENT_SETTINGS_TYPE_GEOLOCATION:\n      return PermissionRequestType::PERMISSION_GEOLOCATION;\n    case CONTENT_SETTINGS_TYPE_NOTIFICATIONS:\n      return PermissionRequestType::PERMISSION_NOTIFICATIONS;\n    case CONTENT_SETTINGS_TYPE_MIDI_SYSEX:\n      return PermissionRequestType::PERMISSION_MIDI_SYSEX;\n    case CONTENT_SETTINGS_TYPE_PUSH_MESSAGING:\n      return PermissionRequestType::PERMISSION_PUSH_MESSAGING;\n    case CONTENT_SETTINGS_TYPE_PROTECTED_MEDIA_IDENTIFIER:\n      return PermissionRequestType::PERMISSION_PROTECTED_MEDIA_IDENTIFIER;\n    case CONTENT_SETTINGS_TYPE_PLUGINS:\n      return PermissionRequestType::PERMISSION_FLASH;\n    default:\n      NOTREACHED();\n      return PermissionRequestType::UNKNOWN;\n  }\n}", "target": 0}
{"code": "static void ieee80211_update_csa(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct beacon_data *beacon)\n{\n\tstruct probe_resp *resp;\n\tint counter_offset_beacon = sdata->csa_counter_offset_beacon;\n\tint counter_offset_presp = sdata->csa_counter_offset_presp;\n\tu8 *beacon_data;\n\tsize_t beacon_data_len;\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tbeacon_data = beacon->tail;\n\t\tbeacon_data_len = beacon->tail_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (WARN_ON(counter_offset_beacon >= beacon_data_len))\n\t\treturn;\n\tif (WARN_ON(beacon_data[counter_offset_beacon] == 0))\n\t\treturn;\n\tbeacon_data[counter_offset_beacon]--;\n\tif (sdata->vif.type == NL80211_IFTYPE_AP && counter_offset_presp) {\n\t\trcu_read_lock();\n\t\tresp = rcu_dereference(sdata->u.ap.probe_resp);\n\t\tif (WARN_ON(!resp)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\tresp->data[counter_offset_presp]--;\n\t\trcu_read_unlock();\n\t}\n}", "target": 0}
{"code": "create_distinct_group(THD *thd, Ref_ptr_array ref_pointer_array,\n                      ORDER *order_list, List<Item> &fields,\n                      List<Item> &all_fields,\n\t\t      bool *all_order_by_fields_used)\n{\n  List_iterator<Item> li(fields);\n  Item *item;\n  Ref_ptr_array orig_ref_pointer_array= ref_pointer_array;\n  ORDER *order,*group,**prev;\n  uint idx= 0;\n  *all_order_by_fields_used= 1;\n  while ((item=li++))\n    item->marker=0;\t\t\t\n  prev= &group;  group=0;\n  for (order=order_list ; order; order=order->next)\n  {\n    if (order->in_field_list)\n    {\n      ORDER *ord=(ORDER*) thd->memdup((char*) order,sizeof(ORDER));\n      if (!ord)\n\treturn 0;\n      *prev=ord;\n      prev= &ord->next;\n      (*ord->item)->marker=1;\n    }\n    else\n      *all_order_by_fields_used= 0;\n  }\n  li.rewind();\n  while ((item=li++))\n  {\n    if (!item->const_item() && !item->with_sum_func && !item->marker)\n    {\n      ORDER *ord_iter;\n      for (ord_iter= group; ord_iter; ord_iter= ord_iter->next)\n        if ((*ord_iter->item)->eq(item, 1))\n          goto next_item;\n      ORDER *ord=(ORDER*) thd->calloc(sizeof(ORDER));\n      if (!ord)\n\treturn 0;\n      if (item->type() == Item::FIELD_ITEM &&\n          item->field_type() == MYSQL_TYPE_BIT)\n      {\n        Item_field *new_item= new (thd->mem_root) Item_field(thd, (Item_field*)item);\n        int el= all_fields.elements;\n        orig_ref_pointer_array[el]= new_item;\n        all_fields.push_front(new_item, thd->mem_root);\n        ord->item=&orig_ref_pointer_array[el]; \n     }\n      else\n      {\n        ord->item= &ref_pointer_array[idx];\n      }\n      ord->direction= ORDER::ORDER_ASC;\n      *prev=ord;\n      prev= &ord->next;\n    }\nnext_item:\n    idx++;\n  }\n  *prev=0;\n  return group;\n}", "target": 0}
{"code": "bool mysql_explain_union(THD *thd, SELECT_LEX_UNIT *unit, select_result *result)\n{\n  DBUG_ENTER(\"mysql_explain_union\");\n  bool res= 0;\n  SELECT_LEX *first= unit->first_select();\n  for (SELECT_LEX *sl= first; sl; sl= sl->next_select())\n  {\n    sl->set_explain_type(FALSE);\n    sl->options|= SELECT_DESCRIBE;\n  }\n  if (unit->is_union() || unit->fake_select_lex)\n  {\n    if (unit->union_needs_tmp_table() && unit->fake_select_lex)\n    {\n      unit->fake_select_lex->select_number= FAKE_SELECT_LEX_ID; \n      unit->fake_select_lex->type= \"UNION RESULT\";\n      unit->fake_select_lex->options|= SELECT_DESCRIBE;\n    }\n    if (!(res= unit->prepare(thd, result, SELECT_NO_UNLOCK | SELECT_DESCRIBE)))\n      res= unit->exec();\n  }\n  else\n  {\n    thd->lex->current_select= first;\n    unit->set_limit(unit->global_parameters());\n    res= mysql_select(thd, \n                      first->table_list.first,\n                      first->with_wild, first->item_list,\n                      first->where,\n                      first->order_list.elements + first->group_list.elements,\n                      first->order_list.first,\n                      first->group_list.first,\n                      first->having,\n                      thd->lex->proc_list.first,\n                      first->options | thd->variables.option_bits | SELECT_DESCRIBE,\n                      result, unit, first);\n  }\n  DBUG_RETURN(res || thd->is_error());\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(date_diff)\n{\n\tzval         *object1, *object2;\n\tphp_date_obj *dateobj1, *dateobj2;\n\tphp_interval_obj *interval;\n\tlong          absolute = 0;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"OO|l\", &object1, date_ce_date, &object2, date_ce_date, &absolute) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tdateobj1 = (php_date_obj *) zend_object_store_get_object(object1 TSRMLS_CC);\n\tdateobj2 = (php_date_obj *) zend_object_store_get_object(object2 TSRMLS_CC);\n\tDATE_CHECK_INITIALIZED(dateobj1->time, DateTime);\n\tDATE_CHECK_INITIALIZED(dateobj2->time, DateTime);\n\ttimelib_update_ts(dateobj1->time, NULL);\n\ttimelib_update_ts(dateobj2->time, NULL);\n\tphp_date_instantiate(date_ce_interval, return_value TSRMLS_CC);\n\tinterval = zend_object_store_get_object(return_value TSRMLS_CC);\n\tinterval->diff = timelib_diff(dateobj1->time, dateobj2->time);\n\tif (absolute) {\n\t\tinterval->diff->invert = 0;\n\t}\n\tinterval->initialized = 1;", "target": 0}
{"code": "storageConnectGetStoragePoolCapabilities(virConnectPtr conn,\n                                         unsigned int flags)\n{\n    virStoragePoolCaps *caps = NULL;\n    char *ret;\n    virCheckFlags(0, NULL);\n    if (virConnectGetStoragePoolCapabilitiesEnsureACL(conn) < 0)\n        return NULL;\n    if (!(caps = virStoragePoolCapsNew(driver->caps)))\n        return NULL;\n    ret = virStoragePoolCapsFormat(caps);\n    virObjectUnref(caps);\n    return ret;\n}", "target": 0}
{"code": "join_read_system(JOIN_TAB *tab)\n{\n  TABLE *table= tab->table;\n  int error;\n  if (table->status & STATUS_GARBAGE)\t\t\n  {\n    if (unlikely((error=\n                  table->file->ha_read_first_row(table->record[0],\n                                                 table->s->primary_key))))\n    {\n      if (error != HA_ERR_END_OF_FILE)\n\treturn report_error(table, error);\n      table->const_table= 1;\n      mark_as_null_row(tab->table);\n      empty_record(table);\t\t\t\n      return -1;\n    }\n    store_record(table,record[1]);\n  }\n  else if (!table->status)\t\t\t\n    restore_record(table,record[1]);\t\t\t\n  table->null_row=0;\n  return table->status ? -1 : 0;\n}", "target": 0}
{"code": "static int vnc_display_listen(VncDisplay *vd,\n                              SocketAddress **saddr,\n                              size_t nsaddr,\n                              SocketAddress **wsaddr,\n                              size_t nwsaddr,\n                              Error **errp)\n{\n    size_t i;\n    if (nsaddr) {\n        vd->listener = qio_net_listener_new();\n        qio_net_listener_set_name(vd->listener, \"vnc-listen\");\n        for (i = 0; i < nsaddr; i++) {\n            if (qio_net_listener_open_sync(vd->listener,\n                                           saddr[i], 1,\n                                           errp) < 0)  {\n                return -1;\n            }\n        }\n        qio_net_listener_set_client_func(vd->listener,\n                                         vnc_listen_io, vd, NULL);\n    }\n    if (nwsaddr) {\n        vd->wslistener = qio_net_listener_new();\n        qio_net_listener_set_name(vd->wslistener, \"vnc-ws-listen\");\n        for (i = 0; i < nwsaddr; i++) {\n            if (qio_net_listener_open_sync(vd->wslistener,\n                                           wsaddr[i], 1,\n                                           errp) < 0)  {\n                return -1;\n            }\n        }\n        qio_net_listener_set_client_func(vd->wslistener,\n                                         vnc_listen_io, vd, NULL);\n    }\n    return 0;\n}", "target": 0}
{"code": "get_file_region_entry_from_cache(struct resv_map *resv, long from, long to)\n{\n\tstruct file_region *nrg = NULL;\n\tVM_BUG_ON(resv->region_cache_count <= 0);\n\tresv->region_cache_count--;\n\tnrg = list_first_entry(&resv->region_cache, struct file_region, link);\n\tlist_del(&nrg->link);\n\tnrg->from = from;\n\tnrg->to = to;\n\treturn nrg;\n}", "target": 0}
{"code": "    void set_value(const Vec4& value) {\n      value_ = value;\n    }", "target": 0}
{"code": "bool ShouldUseMojoChannel() {\n  return CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableRendererMojoChannel);\n}", "target": 0}
{"code": "void WebContentsImpl::ToggleFullscreenMode(bool enter_fullscreen) {\n  RenderWidgetHostView* const widget_view = GetFullscreenRenderWidgetHostView();\n  if (widget_view)\n    RenderWidgetHostImpl::From(widget_view->GetRenderWidgetHost())->Shutdown();\n  if (delegate_)\n    delegate_->ToggleFullscreenModeForTab(this, enter_fullscreen);\n}", "target": 0}
{"code": "acc_ctx_vfy_oid(OM_uint32 *minor_status,\n\t\tspnego_gss_ctx_id_t sc, gss_OID mechoid,\n\t\tOM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_mechanism mech = NULL;\n\tgss_OID_set mech_set = GSS_C_NO_OID_SET;\n\tint present = 0;\n\tif (g_OID_equal(sc->internal_mech, mechoid))\n\t\treturn GSS_S_COMPLETE;\n\tmech = gssint_get_mechanism(sc->internal_mech);\n\tif (mech == NULL || mech->gss_indicate_mechs == NULL) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\t*negState = REJECT;\n\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\treturn GSS_S_BAD_MECH;\n\t}\n\tret = mech->gss_indicate_mechs(minor_status, &mech_set);\n\tif (ret != GSS_S_COMPLETE) {\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tmap_error(minor_status, mech);\n\t\tgoto cleanup;\n\t}\n\tret = gss_test_oid_set_member(minor_status, mechoid,\n\t\t\t\t      mech_set, &present);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (!present) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\t*negState = REJECT;\n\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\tret = GSS_S_BAD_MECH;\n\t}\ncleanup:\n\tgss_release_oid_set(&tmpmin, &mech_set);\n\treturn ret;\n}", "target": 0}
{"code": "static int proc_pid_wchan(struct task_struct *task, char *buffer)\n{\n\tunsigned long wchan;\n\tchar symname[KSYM_NAME_LEN];\n\twchan = get_wchan(task);\n\tif (lookup_symbol_name(wchan, symname) < 0)\n\t\treturn sprintf(buffer, \"%lu\", wchan);\n\telse\n\t\treturn sprintf(buffer, \"%s\", symname);\n}", "target": 0}
{"code": "  virtual void ConnectToWifiNetwork(ConnectionSecurity security,\n                                    const std::string& ssid,\n                                    const std::string& password,\n                                    const std::string& identity,\n                                    const std::string& certpath,\n                                    bool auto_connect) {\n    if (!EnsureCrosLoaded())\n      return;\n    ServiceInfo* service = GetWifiService(ssid.c_str(), security);\n    if (service) {\n      SetAutoConnect(service->service_path, auto_connect);\n      ConnectToNetworkWithCertInfo(service->service_path,\n          password.empty() ? NULL : password.c_str(),\n          identity.empty() ? NULL : identity.c_str(),\n          certpath.empty() ? NULL : certpath.c_str());\n      FreeServiceInfo(service);\n    } else {\n      LOG(WARNING) << \"Cannot find hidden network: \" << ssid;\n    }\n  }", "target": 0}
{"code": "void RenderFrameHostImpl::OnFrameFocused() {\n  frame_tree_->SetFocusedFrame(frame_tree_node_);\n}", "target": 0}
{"code": "vte_sequence_handler_insert_blank_characters (VteTerminal *terminal, GValueArray *params)\n{\n\tvte_sequence_handler_IC (terminal, params);\n}", "target": 0}
{"code": "isoent_cmp_key_joliet(const struct archive_rb_node *node, const void *key)\n{\n\tconst struct isoent *isoent = (const struct isoent *)key;\n\tconst struct idrent *idrent = (const struct idrent *)node;\n\treturn (isoent_cmp_joliet_identifier(isoent, idrent->isoent));\n}", "target": 0}
{"code": "bool CreateWaitAndExitThread(base::TimeDelta duration) {\n  scoped_ptr<WaitAndExitDelegate> delegate(new WaitAndExitDelegate(duration));\n  const bool thread_created =\n      base::PlatformThread::CreateNonJoinable(0, delegate.get());\n  if (!thread_created)\n    return false;\n  WaitAndExitDelegate* leaking_delegate = delegate.release();\n  ANNOTATE_LEAKING_OBJECT_PTR(leaking_delegate);\n  ignore_result(leaking_delegate);\n  return true;\n}", "target": 0}
{"code": "static void process_timer_rebalance(struct task_struct *p,\n\t\t\t\t    unsigned int clock_idx,\n\t\t\t\t    union cpu_time_count expires,\n\t\t\t\t    union cpu_time_count val)\n{\n\tcputime_t ticks, left;\n\tunsigned long long ns, nsleft;\n \tstruct task_struct *t = p;\n\tunsigned int nthreads = atomic_read(&p->signal->live);\n\tif (!nthreads)\n\t\treturn;\n\tswitch (clock_idx) {\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\tcase CPUCLOCK_PROF:\n\t\tleft = cputime_div_non_zero(cputime_sub(expires.cpu, val.cpu),\n\t\t\t\t       nthreads);\n\t\tdo {\n\t\t\tif (likely(!(t->flags & PF_EXITING))) {\n\t\t\t\tticks = cputime_add(prof_ticks(t), left);\n\t\t\t\tif (cputime_eq(t->it_prof_expires,\n\t\t\t\t\t       cputime_zero) ||\n\t\t\t\t    cputime_gt(t->it_prof_expires, ticks)) {\n\t\t\t\t\tt->it_prof_expires = ticks;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = next_thread(t);\n\t\t} while (t != p);\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tleft = cputime_div_non_zero(cputime_sub(expires.cpu, val.cpu),\n\t\t\t\t       nthreads);\n\t\tdo {\n\t\t\tif (likely(!(t->flags & PF_EXITING))) {\n\t\t\t\tticks = cputime_add(virt_ticks(t), left);\n\t\t\t\tif (cputime_eq(t->it_virt_expires,\n\t\t\t\t\t       cputime_zero) ||\n\t\t\t\t    cputime_gt(t->it_virt_expires, ticks)) {\n\t\t\t\t\tt->it_virt_expires = ticks;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = next_thread(t);\n\t\t} while (t != p);\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\tnsleft = expires.sched - val.sched;\n\t\tdo_div(nsleft, nthreads);\n\t\tnsleft = max_t(unsigned long long, nsleft, 1);\n\t\tdo {\n\t\t\tif (likely(!(t->flags & PF_EXITING))) {\n\t\t\t\tns = t->se.sum_exec_runtime + nsleft;\n\t\t\t\tif (t->it_sched_expires == 0 ||\n\t\t\t\t    t->it_sched_expires > ns) {\n\t\t\t\t\tt->it_sched_expires = ns;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = next_thread(t);\n\t\t} while (t != p);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static int get_floppy_geometry(int drive, int type, struct floppy_struct **g)\n{\n\tif (type)\n\t\t*g = &floppy_type[type];\n\telse {\n\t\tif (lock_fdc(drive, false))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(false, 0) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\t*g = current_type[drive];\n\t}\n\tif (!*g)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 0}
{"code": "void TxnWrap::removeFromEnvWrap() {\n    if (this->ew) {\n        if (this->ew->currentWriteTxn == this) {\n            this->ew->currentWriteTxn = nullptr;\n        }\n        else {\n            auto it = std::find(ew->readTxns.begin(), ew->readTxns.end(), this);\n            if (it != ew->readTxns.end()) {\n                ew->readTxns.erase(it);\n            }\n        }\n        this->ew->Unref();\n        this->ew = nullptr;\n    }\n}", "target": 0}
{"code": "static int zstd_compress(struct transaction_t *txn,\n                         unsigned flags, const char *buf, unsigned len)\n{\n    ZSTD_EndDirective mode = (flags & COMPRESS_END) ? ZSTD_e_end : ZSTD_e_flush;\n    ZSTD_inBuffer input = { buf, len, 0 };\n    ZSTD_CCtx *cctx = txn->zstd;\n    size_t remaining;\n    if (flags & COMPRESS_START) ZSTD_CCtx_reset(cctx, ZSTD_reset_session_only);\n    buf_ensure(&txn->zbuf, ZSTD_compressBound(len));\n    buf_reset(&txn->zbuf);\n    ZSTD_outBuffer output = { txn->zbuf.s, txn->zbuf.alloc, 0 };\n    do {\n        remaining = ZSTD_compressStream2(cctx, &output, &input, mode);\n        if (ZSTD_isError(remaining)) {\n            syslog(LOG_ERR, \"Zstandard: %s\",\n                   ZSTD_getErrorString(ZSTD_getErrorCode(remaining)));\n            return -1;\n        }\n    } while (remaining || (input.pos != input.size));\n    buf_truncate(&txn->zbuf, output.pos);\n    return 0;\n}", "target": 0}
{"code": "SYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags,\n\t\tumode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\treturn do_sys_open(dfd, filename, flags, mode);\n}", "target": 0}
{"code": "static inline void nf_bridge_get(struct nf_bridge_info *nf_bridge)\n{\n\tif (nf_bridge)\n\t\tatomic_inc(&nf_bridge->use);\n}", "target": 0}
{"code": "static int sd_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmin_packet_size = 200;\n\t\tbreak;\n\tcase 176:\n\t\tmin_packet_size = 266;\n\t\tbreak;\n\tdefault:\n\t\tmin_packet_size = 400;\n\t\tbreak;\n\t}\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tpr_err(\"set alt 1 err %d\\n\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "uint_t aubio_tempo_get_delay(aubio_tempo_t * o) {\n  return o->delay;\n}", "target": 0}
{"code": "static HashTable *spl_object_storage_get_gc(zval *obj, zval ***table, int *n TSRMLS_DC) \n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(obj TSRMLS_CC);\n\tspl_SplObjectStorageElement *element;\n\tHashTable *props;\n\tHashPosition pos;\n\tzval *gcdata_arr = NULL,\n\t\t **gcdata_arr_pp;\n\tprops = std_object_handlers.get_properties(obj TSRMLS_CC);\n\t*table = NULL;\n\t*n = 0;\n\tif (zend_hash_find(props, \"\\x00gcdata\", sizeof(\"\\x00gcdata\"), (void**) &gcdata_arr_pp) == SUCCESS) {\n\t\tgcdata_arr = *gcdata_arr_pp;\n\t\tzend_hash_clean(Z_ARRVAL_P(gcdata_arr));\n\t}\n\tif (gcdata_arr == NULL) {\n\t\tMAKE_STD_ZVAL(gcdata_arr);\n\t\tarray_init(gcdata_arr);\n\t\tZ_ARRVAL_P(gcdata_arr)->pDestructor = NULL;\n\t\tzend_hash_add(props, \"\\x00gcdata\", sizeof(\"\\x00gcdata\"), &gcdata_arr, sizeof(gcdata_arr), NULL);\n\t}\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &pos);\n\twhile (zend_hash_get_current_data_ex(&intern->storage, (void **)&element, &pos) == SUCCESS) {\n\t\tadd_next_index_zval(gcdata_arr, element->obj);\n\t\tadd_next_index_zval(gcdata_arr, element->inf);\n\t\tzend_hash_move_forward_ex(&intern->storage, &pos);\n\t}\n\treturn props;\n}", "target": 0}
{"code": "    DataBuf Value::dataArea() const\n    {\n        return DataBuf(0, 0);\n    }", "target": 0}
{"code": "void LoginUtils::DoBrowserLaunch(Profile* profile) {\n  BootTimesLoader::Get()->AddLoginTimeMarker(\"BrowserLaunched\", false);\n  if (!LoginUtils::Get()->IsBrowserLaunchEnabled())\n    return;\n  CommandLine::ForCurrentProcess()->InitFromArgv(\n      CommandLine::ForCurrentProcess()->argv());\n  VLOG(1) << \"Launching browser...\";\n  BrowserInit browser_init;\n  int return_code;\n  browser_init.LaunchBrowser(*CommandLine::ForCurrentProcess(),\n                             profile,\n                             FilePath(),\n                             true,\n                             &return_code);\n}", "target": 0}
{"code": "static int mov_write_hvcc_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"hvcC\");\n    ff_isom_write_hvcc(pb, track->vos_data, track->vos_len, 0);\n    return update_size(pb, pos);\n}", "target": 0}
{"code": "GF_Err stri_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tsize_t i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->switch_group = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->sub_track_id = gf_bs_read_u32(bs);\n\tptr->attribute_count = ptr->size / 4;\n\tif ((u64)ptr->attribute_count > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in stri\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tGF_SAFE_ALLOC_N(ptr->attribute_list, (size_t)ptr->attribute_count, u32);\n\tif (!ptr->attribute_list) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->attribute_list[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicyImpl::GrantRequestURL(\n    int child_id, const GURL& url) {\n  if (!url.is_valid())\n    return;  \n  if (IsWebSafeScheme(url.scheme()))\n    return;  \n  if (IsPseudoScheme(url.scheme())) {\n    if (url.SchemeIs(chrome::kViewSourceScheme)) {\n      GrantRequestURL(child_id, GURL(url.path()));\n    }\n    return;  \n  }\n  {\n    base::AutoLock lock(lock_);\n    SecurityStateMap::iterator state = security_state_.find(child_id);\n    if (state == security_state_.end())\n      return;\n    state->second->GrantScheme(url.scheme());\n  }\n}", "target": 0}
{"code": "static void free_states(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state_list *sl, *sln;\n\tint i;\n\tsl = env->free_list;\n\twhile (sl) {\n\t\tsln = sl->next;\n\t\tfree_verifier_state(&sl->state, false);\n\t\tkfree(sl);\n\t\tsl = sln;\n\t}\n\tenv->free_list = NULL;\n\tif (!env->explored_states)\n\t\treturn;\n\tfor (i = 0; i < state_htab_size(env); i++) {\n\t\tsl = env->explored_states[i];\n\t\twhile (sl) {\n\t\t\tsln = sl->next;\n\t\t\tfree_verifier_state(&sl->state, false);\n\t\t\tkfree(sl);\n\t\t\tsl = sln;\n\t\t}\n\t\tenv->explored_states[i] = NULL;\n\t}\n}", "target": 0}
{"code": "Guint FoFiTrueType::scanLookupList(Guint listIndex, Guint orgGID)\n{\n  Guint lookupTable;\n  Guint subTableCount;\n  Guint subTable;\n  Guint i;\n  Guint gid = 0;\n  Guint pos;\n  if (gsubLookupList == 0) return 0; \n  pos = gsubLookupList+2+listIndex*2;\n  lookupTable = getU16BE(pos,&parsedOk);\n  pos = gsubLookupList+lookupTable+4;\n  subTableCount = getU16BE(pos,&parsedOk);\n  pos += 2;;\n  for (i = 0;i < subTableCount;i++) {\n    subTable = getU16BE(pos,&parsedOk);\n    pos += 2;\n    if ((gid = scanLookupSubTable(gsubLookupList+lookupTable+subTable,orgGID))\n         != 0) break;\n  }\n  return gid;\n}", "target": 0}
{"code": "static inline bool IsGlobbingPattern(const std::string& pattern) {\n  return (pattern.find_first_of(kGlobbingChars) != std::string::npos);\n}", "target": 0}
{"code": "static int hns_roce_dealloc_ucontext(struct ib_ucontext *ibcontext)\n{\n\tstruct hns_roce_ucontext *context = to_hr_ucontext(ibcontext);\n\thns_roce_uar_free(to_hr_dev(ibcontext->device), &context->uar);\n\tkfree(context);\n\treturn 0;\n}", "target": 0}
{"code": "const char *setup_git_directory(void)\n{\n\tconst char *retval = setup_git_directory_gently(NULL);\n\tif (inside_work_tree < 0) {\n\t\tstatic char buffer[PATH_MAX + 1];\n\t\tchar *rel;\n\t\tif (retval && chdir(retval))\n\t\t\tdie (\"Could not jump back into original cwd\");\n\t\trel = get_relative_cwd(buffer, PATH_MAX, get_git_work_tree());\n\t\treturn rel && *rel ? strcat(rel, \"/\") : NULL;\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "int tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\tint data_len = 0;\n\tbool fragstolen;\n\tif (size == 0)\n\t\treturn 0;\n\tif (size > PAGE_SIZE) {\n\t\tint npages = min_t(size_t, size >> PAGE_SHIFT, MAX_SKB_FRAGS);\n\t\tdata_len = npages << PAGE_SHIFT;\n\t\tsize = data_len + (size & ~PAGE_MASK);\n\t}\n\tskb = alloc_skb_with_frags(size - data_len, data_len,\n\t\t\t\t   PAGE_ALLOC_COSTLY_ORDER,\n\t\t\t\t   &err, sk->sk_allocation);\n\tif (!skb)\n\t\tgoto err;\n\tskb_put(skb, size - data_len);\n\tskb->data_len = data_len;\n\tskb->len = size;\n\tif (tcp_try_rmem_schedule(sk, skb, skb->truesize))\n\t\tgoto err_free;\n\terr = skb_copy_datagram_from_iter(skb, 0, &msg->msg_iter, size);\n\tif (err)\n\t\tgoto err_free;\n\tTCP_SKB_CB(skb)->seq = tcp_sk(sk)->rcv_nxt;\n\tTCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + size;\n\tTCP_SKB_CB(skb)->ack_seq = tcp_sk(sk)->snd_una - 1;\n\tif (tcp_queue_rcv(sk, skb, 0, &fragstolen)) {\n\t\tWARN_ON_ONCE(fragstolen); \n\t\t__kfree_skb(skb);\n\t}\n\treturn size;\nerr_free:\n\tkfree_skb(skb);\nerr:\n\treturn err;\n}", "target": 0}
{"code": "sshpam_thread_cleanup(void *ctxtp)\n{\n\tstruct pam_ctxt *ctxt = ctxtp;\n\tpthread_cancel(ctxt->pam_thread);\n\tpthread_join(ctxt->pam_thread, NULL);\n\tclose(ctxt->pam_psock);\n\tclose(ctxt->pam_csock);\n}", "target": 0}
{"code": "apr_status_t h2_request_end_headers(h2_request *req, apr_pool_t *pool, int eos, size_t raw_bytes)\n{\n    const char *s;\n    if (!req->authority) {\n        const char *host = apr_table_get(req->headers, \"Host\");\n        if (!host) {\n            return APR_BADARG;\n        }\n        req->authority = host;\n    }\n    else {\n        apr_table_setn(req->headers, \"Host\", req->authority);\n    }\n    s = apr_table_get(req->headers, \"Content-Length\");\n    if (!s) {\n        if (!eos) {\n            req->chunked = 1;\n            apr_table_mergen(req->headers, \"Transfer-Encoding\", \"chunked\");\n        }\n        else if (apr_table_get(req->headers, \"Content-Type\")) {\n            apr_table_setn(req->headers, \"Content-Length\", \"0\");\n        }\n    }\n    req->raw_bytes += raw_bytes;\n    return APR_SUCCESS;\n}", "target": 0}
{"code": "void Item::print_value(String *str)\n{\n  char buff[MAX_FIELD_WIDTH];\n  String *ptr, tmp(buff,sizeof(buff),str->charset());\n  ptr= val_str(&tmp);\n  if (!ptr)\n    str->append(\"NULL\");\n  else\n  {\n    switch (result_type()) {\n    case STRING_RESULT:\n      append_unescaped(str, ptr->ptr(), ptr->length());\n      break;\n    case DECIMAL_RESULT:\n    case REAL_RESULT:\n    case INT_RESULT:\n      str->append(*ptr);\n      break;\n    case ROW_RESULT:\n    case TIME_RESULT:\n    case IMPOSSIBLE_RESULT:\n      DBUG_ASSERT(0);\n    }\n  }\n}", "target": 0}
{"code": "static u32 *gen12_emit_preempt_busywait(struct i915_request *request, u32 *cs)\n{\n\t*cs++ = MI_SEMAPHORE_WAIT_TOKEN |\n\t\tMI_SEMAPHORE_GLOBAL_GTT |\n\t\tMI_SEMAPHORE_POLL |\n\t\tMI_SEMAPHORE_SAD_EQ_SDD;\n\t*cs++ = 0;\n\t*cs++ = intel_hws_preempt_address(request->engine);\n\t*cs++ = 0;\n\t*cs++ = 0;\n\t*cs++ = MI_NOOP;\n\treturn cs;\n}", "target": 0}
{"code": "static bool ok_inflater_zlib_header(ok_inflater *inflater) {\n    if (!ok_inflater_load_bits(inflater, 16)) {\n        return false;\n    } else {\n        uint32_t compression_method = ok_inflater_read_bits(inflater, 4);\n        uint32_t compression_info = ok_inflater_read_bits(inflater, 4);\n        uint32_t flag_check = ok_inflater_read_bits(inflater, 5);\n        uint32_t flag_dict = ok_inflater_read_bits(inflater, 1);\n        uint32_t flag_compression_level = ok_inflater_read_bits(inflater, 2);\n        uint32_t bits = ((compression_info << 12) | (compression_method << 8) |\n                         (flag_compression_level << 6) | (flag_dict << 5) | flag_check);\n        if (bits % 31 != 0) {\n            ok_inflater_error(inflater, \"Invalid zlib header\");\n            return false;\n        }\n        if (compression_method != 8) {\n            ok_inflater_error(inflater, \"Invalid inflater compression method\");\n            return false;\n        }\n        if (compression_info > 7) {\n            ok_inflater_error(inflater, \"Invalid window size\");\n            return false;\n        }\n        if (flag_dict) {\n            ok_inflater_error(inflater, \"Needs external dictionary\");\n            return false;\n        }\n        inflater->state = OK_INFLATER_STATE_READY_FOR_NEXT_BLOCK;\n        return true;\n    }\n}", "target": 0}
{"code": "SYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd)\n{\n\tif (unlikely(newfd == oldfd)) { \n\t\tstruct files_struct *files = current->files;\n\t\tint retval = oldfd;\n\t\trcu_read_lock();\n\t\tif (!files_lookup_fd_rcu(files, oldfd))\n\t\t\tretval = -EBADF;\n\t\trcu_read_unlock();\n\t\treturn retval;\n\t}\n\treturn ksys_dup3(oldfd, newfd, 0);\n}", "target": 0}
{"code": "int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t      struct kvm_io_device *dev)\n{\n\tint i, r;\n\tstruct kvm_io_bus *new_bus, *bus;\n\tbus = kvm->buses[bus_idx];\n\tr = -ENOENT;\n\tfor (i = 0; i < bus->dev_count; i++)\n\t\tif (bus->range[i].dev == dev) {\n\t\t\tr = 0;\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\treturn r;\n\tnew_bus = kmalloc(sizeof(*bus) + ((bus->dev_count - 1) *\n\t\t\t  sizeof(struct kvm_io_range)), GFP_KERNEL);\n\tif (!new_bus)\n\t\treturn -ENOMEM;\n\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));\n\tnew_bus->dev_count--;\n\tmemcpy(new_bus->range + i, bus->range + i + 1,\n\t       (new_bus->dev_count - i) * sizeof(struct kvm_io_range));\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\treturn r;\n}", "target": 0}
{"code": "ZEND_METHOD(CURLFile, getFilename)\n{\n\tcurlfile_get_property(\"name\", INTERNAL_FUNCTION_PARAM_PASSTHRU);\n}", "target": 0}
{"code": "    CImg<Tfloat> get_asin() const {\n      return CImg<Tfloat>(*this,false).asin();", "target": 0}
{"code": "PrintWebViewHelper::PrintPreviewContext::PrintPreviewContext()\n    : frame_(NULL),\n      total_page_count_(0),\n      current_page_index_(0),\n      generate_draft_pages_(true),\n      print_ready_metafile_page_count_(0),\n      error_(PREVIEW_ERROR_NONE),\n      state_(UNINITIALIZED) {\n}", "target": 0}
{"code": "Variant HHVM_FUNCTION(imageaffinematrixget,\n                      int64_t type,\n                      const Variant& options ) {\n  Array ret = Array::Create();\n  double affine[6];\n  int res = GD_FALSE, i;\n  switch((gdAffineStandardMatrix)type) {\n    case GD_AFFINE_TRANSLATE:\n    case GD_AFFINE_SCALE: {\n      double x, y;\n      Array aoptions = options.toArray();\n      if (aoptions.empty()) {\n        raise_warning(\"imageaffinematrixget(): Array expected as options\");\n        return false;\n      }\n      if (aoptions.exists(s_x)) {\n        x = aoptions[s_x].toDouble();\n      } else {\n        raise_warning(\"imageaffinematrixget(): Missing x position\");\n        return false;\n      }\n      if (aoptions.exists(s_y)) {\n        y = aoptions[s_y].toDouble();\n      } else {\n        raise_warning(\"imageaffinematrixget(): Missing x position\");\n        return false;\n      }\n      if (type == GD_AFFINE_TRANSLATE) {\n        res = gdAffineTranslate(affine, x, y);\n      } else {\n        res = gdAffineScale(affine, x, y);\n      }\n      break;\n    }\n    case GD_AFFINE_ROTATE:\n    case GD_AFFINE_SHEAR_HORIZONTAL:\n    case GD_AFFINE_SHEAR_VERTICAL: {\n      double angle;\n      double doptions = options.toDouble();\n      if (!doptions) {\n        raise_warning(\"imageaffinematrixget(): Number is expected as option\");\n        return false;\n      }\n      angle = doptions;\n      if (type == GD_AFFINE_SHEAR_HORIZONTAL) {\n        res = gdAffineShearHorizontal(affine, angle);\n      } else if (type == GD_AFFINE_SHEAR_VERTICAL) {\n        res = gdAffineShearVertical(affine, angle);\n      } else {\n        res = gdAffineRotate(affine, angle);\n      }\n      break;\n    }\n    default:\n      raise_warning(\"imageaffinematrixget():Invalid type for \"\n                    \"element %\" PRId64, type);\n      return false;\n  }\n  if (res == GD_FALSE) {\n    return false;\n  } else {\n    for (i = 0; i < 6; i++) {\n      ret.set(String(i, CopyString), affine[i]);\n    }\n  }\n  return ret;\n}", "target": 0}
{"code": "int close_fd(unsigned fd)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\tfile = pick_file(files, fd);\n\tif (IS_ERR(file))\n\t\treturn -EBADF;\n\treturn filp_close(file, files);\n}", "target": 0}
{"code": "  virtual Ref_Type ref_type() { return AGGREGATE_REF; }", "target": 0}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 0}
{"code": "  decodeResources(const Protobuf::RepeatedPtrField<ProtobufWkt::Any>& resources,\n                  const std::string& version, const std::string& name_field = \"name\") {\n    TestOpaqueResourceDecoderImpl<MessageType> resource_decoder(name_field);\n    return Config::DecodedResourcesWrapper(resource_decoder, resources, version);\n  }", "target": 0}
{"code": "flatpak_run_get_minimal_env (gboolean devel, gboolean use_ld_so_cache)\n{\n  GPtrArray *env_array;\n  static const char * const copy[] = {\n    \"PWD\",\n    \"GDMSESSION\",\n    \"XDG_CURRENT_DESKTOP\",\n    \"XDG_SESSION_DESKTOP\",\n    \"DESKTOP_SESSION\",\n    \"EMAIL_ADDRESS\",\n    \"HOME\",\n    \"HOSTNAME\",\n    \"LOGNAME\",\n    \"REAL_NAME\",\n    \"TERM\",\n    \"USER\",\n    \"USERNAME\",\n  };\n  static const char * const copy_nodevel[] = {\n    \"LANG\",\n    \"LANGUAGE\",\n    \"LC_ALL\",\n    \"LC_ADDRESS\",\n    \"LC_COLLATE\",\n    \"LC_CTYPE\",\n    \"LC_IDENTIFICATION\",\n    \"LC_MEASUREMENT\",\n    \"LC_MESSAGES\",\n    \"LC_MONETARY\",\n    \"LC_NAME\",\n    \"LC_NUMERIC\",\n    \"LC_PAPER\",\n    \"LC_TELEPHONE\",\n    \"LC_TIME\",\n  };\n  int i;\n  env_array = g_ptr_array_new_with_free_func (g_free);\n  add_exports (env_array, default_exports, G_N_ELEMENTS (default_exports));\n  if (!use_ld_so_cache)\n    add_exports (env_array, no_ld_so_cache_exports, G_N_ELEMENTS (no_ld_so_cache_exports));\n  if (devel)\n    add_exports (env_array, devel_exports, G_N_ELEMENTS (devel_exports));\n  for (i = 0; i < G_N_ELEMENTS (copy); i++)\n    {\n      const char *current = g_getenv (copy[i]);\n      if (current)\n        g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy[i], current));\n    }\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (copy_nodevel); i++)\n        {\n          const char *current = g_getenv (copy_nodevel[i]);\n          if (current)\n            g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy_nodevel[i], current));\n        }\n    }\n  g_ptr_array_add (env_array, NULL);\n  return (char **) g_ptr_array_free (env_array, FALSE);\n}", "target": 0}
{"code": "int blkid_partition_set_uuid(blkid_partition par, const unsigned char *uuid)\n{\n\tif (!par)\n\t\treturn -1;\n\tblkid_unparse_uuid(uuid, par->uuid, sizeof(par->uuid));\n\treturn 0;\n}", "target": 0}
{"code": "int svm_register_enc_region(struct kvm *kvm,\n\t\t\t    struct kvm_enc_region *range)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct enc_region *region;\n\tint ret = 0;\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\tif (is_mirroring_enc_context(kvm))\n\t\treturn -EINVAL;\n\tif (range->addr > ULONG_MAX || range->size > ULONG_MAX)\n\t\treturn -EINVAL;\n\tregion = kzalloc(sizeof(*region), GFP_KERNEL_ACCOUNT);\n\tif (!region)\n\t\treturn -ENOMEM;\n\tmutex_lock(&kvm->lock);\n\tregion->pages = sev_pin_memory(kvm, range->addr, range->size, &region->npages, 1);\n\tif (IS_ERR(region->pages)) {\n\t\tret = PTR_ERR(region->pages);\n\t\tmutex_unlock(&kvm->lock);\n\t\tgoto e_free;\n\t}\n\tregion->uaddr = range->addr;\n\tregion->size = range->size;\n\tlist_add_tail(&region->list, &sev->regions_list);\n\tmutex_unlock(&kvm->lock);\n\tsev_clflush_pages(region->pages, region->npages);\n\treturn ret;\ne_free:\n\tkfree(region);\n\treturn ret;\n}", "target": 0}
{"code": "static void apply_tns(float coef[1024], TemporalNoiseShaping *tns,\n                      IndividualChannelStream *ics, int decode)\n{\n    const int mmm = FFMIN(ics->tns_max_bands, ics->max_sfb);\n    int w, filt, m, i;\n    int bottom, top, order, start, end, size, inc;\n    float lpc[TNS_MAX_ORDER];\n    float tmp[TNS_MAX_ORDER+1];\n    for (w = 0; w < ics->num_windows; w++) {\n        bottom = ics->num_swb;\n        for (filt = 0; filt < tns->n_filt[w]; filt++) {\n            top    = bottom;\n            bottom = FFMAX(0, top - tns->length[w][filt]);\n            order  = tns->order[w][filt];\n            if (order == 0)\n                continue;\n            compute_lpc_coefs(tns->coef[w][filt], order, lpc, 0, 0, 0);\n            start = ics->swb_offset[FFMIN(bottom, mmm)];\n            end   = ics->swb_offset[FFMIN(   top, mmm)];\n            if ((size = end - start) <= 0)\n                continue;\n            if (tns->direction[w][filt]) {\n                inc = -1;\n                start = end - 1;\n            } else {\n                inc = 1;\n            }\n            start += w * 128;\n            if (decode) {\n                for (m = 0; m < size; m++, start += inc)\n                    for (i = 1; i <= FFMIN(m, order); i++)\n                        coef[start] -= coef[start - i * inc] * lpc[i - 1];\n            } else {\n                for (m = 0; m < size; m++, start += inc) {\n                    tmp[0] = coef[start];\n                    for (i = 1; i <= FFMIN(m, order); i++)\n                        coef[start] += tmp[i] * lpc[i - 1];\n                    for (i = order; i > 0; i--)\n                        tmp[i] = tmp[i - 1];\n                }\n            }\n        }\n    }\n}", "target": 0}
{"code": "    void WebPImage::writeMetadata()\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n        doWriteMetadata(*tempIo); \n        io_->close();\n        io_->transfer(*tempIo); \n    } ", "target": 0}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "uipbuf_init(void)\n{\n  memset(uipbuf_default_attrs, 0, sizeof(uipbuf_default_attrs));\n  uipbuf_set_default_attr(UIPBUF_ATTR_MAX_MAC_TRANSMISSIONS,\n                          UIP_MAX_MAC_TRANSMISSIONS_UNDEFINED);\n  uipbuf_set_default_attr(UIPBUF_ATTR_LLSEC_LEVEL,\n                          UIPBUF_ATTR_LLSEC_LEVEL_MAC_DEFAULT);\n}", "target": 0}
{"code": "static inline unsigned long read_msr(unsigned long msr)\n{\n\tu64 value;\n\trdmsrl(msr, value);\n\treturn value;\n}", "target": 0}
{"code": "handle_sign_detached_with_file_type(context *ctx, struct pollfd *pollfd, socklen_t size)\n{\n\thandle_sign_helper(ctx, pollfd, size, 0, true);\n}", "target": 0}
{"code": "static void packet_flush_mclist(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_mclist *ml;\n\tif (!po->mclist)\n\t\treturn;\n\trtnl_lock();\n\twhile ((ml = po->mclist) != NULL) {\n\t\tstruct net_device *dev;\n\t\tpo->mclist = ml->next;\n\t\tdev = __dev_get_by_index(sock_net(sk), ml->ifindex);\n\t\tif (dev != NULL)\n\t\t\tpacket_dev_mc(dev, ml, -1);\n\t\tkfree(ml);\n\t}\n\trtnl_unlock();\n}", "target": 0}
{"code": "JPEGVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tJPEGState* sp = JState(tif);\n\tconst TIFFField* fip;\n\tuint32 v32;\n\tassert(sp != NULL);\n\tswitch (tag) {\n\tcase TIFFTAG_JPEGTABLES:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0) {\n\t\t\treturn (0);\n\t\t}\n\t\t_TIFFsetByteArray(&sp->jpegtables, va_arg(ap, void*), v32);\n\t\tsp->jpegtables_length = v32;\n\t\tTIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n\t\tbreak;\n\tcase TIFFTAG_JPEGQUALITY:\n\t\tsp->jpegquality = (int) va_arg(ap, int);\n\t\treturn (1);\t\t\t\n\tcase TIFFTAG_JPEGCOLORMODE:\n\t\tsp->jpegcolormode = (int) va_arg(ap, int);\n\t\tJPEGResetUpsampled( tif );\n\t\treturn (1);\t\t\t\n\tcase TIFFTAG_PHOTOMETRIC:\n\t{\n\t\tint ret_value = (*sp->vsetparent)(tif, tag, ap);\n\t\tJPEGResetUpsampled( tif );\n\t\treturn ret_value;\n\t}\n\tcase TIFFTAG_JPEGTABLESMODE:\n\t\tsp->jpegtablesmode = (int) va_arg(ap, int);\n\t\treturn (1);\t\t\t\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\tsp->ycbcrsampling_fetched = 1;\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\tdefault:\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\t}\n\tif ((fip = TIFFFieldWithTag(tif, tag)) != NULL) {\n\t\tTIFFSetFieldBit(tif, fip->field_bit);\n\t} else {\n\t\treturn (0);\n\t}\n\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\treturn (1);\n}", "target": 0}
{"code": "    inline double rand(const double val_min, const double val_max) {\n      const double val = cimg::_rand()/16777215.;\n      return val_min + (val_max - val_min)*val;", "target": 0}
{"code": "error::Error GLES2DecoderImpl::HandleGetTranslatedShaderSourceANGLE(\n    uint32 immediate_data_size,\n    const gles2::GetTranslatedShaderSourceANGLE& c) {\n  GLuint shader = c.shader;\n  uint32 bucket_id = static_cast<uint32>(c.bucket_id);\n  Bucket* bucket = CreateBucket(bucket_id);\n  ShaderManager::ShaderInfo* info = GetShaderInfoNotProgram(\n      shader, \"glTranslatedGetShaderSourceANGLE\");\n  if (!info) {\n    bucket->SetSize(0);\n    return error::kNoError;\n  }\n  bucket->SetFromString(info->translated_source() ?\n      info->translated_source()->c_str() : NULL);\n  return error::kNoError;\n}", "target": 0}
{"code": "void InstanceKlass::assign_class_loader_type() {\n  ClassLoaderData *cld = class_loader_data();\n  if (cld->is_boot_class_loader_data()) {\n    set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n  }\n  else if (cld->is_platform_class_loader_data()) {\n    set_shared_class_loader_type(ClassLoader::PLATFORM_LOADER);\n  }\n  else if (cld->is_system_class_loader_data()) {\n    set_shared_class_loader_type(ClassLoader::APP_LOADER);\n  }\n}", "target": 0}
{"code": "bool nl80211_unexpected_frame(struct net_device *dev, const u8 *addr, gfp_t gfp)\n{\n\treturn __nl80211_unexpected_frame(dev, NL80211_CMD_UNEXPECTED_FRAME,\n\t\t\t\t\t  addr, gfp);\n}", "target": 0}
{"code": "static void nvme_irq_check(NvmeCtrl *n)\n{\n    uint32_t intms = ldl_le_p(&n->bar.intms);\n    if (msix_enabled(&(n->parent_obj))) {\n        return;\n    }\n    if (~intms & n->irq_status) {\n        pci_irq_assert(&n->parent_obj);\n    } else {\n        pci_irq_deassert(&n->parent_obj);\n    }\n}", "target": 0}
{"code": "static inline bool cpu_has_vmx_invept_global(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_GLOBAL_BIT;\n}", "target": 0}
{"code": "int user_match(const struct key *key, const struct key_match_data *match_data)", "target": 0}
{"code": "static int dsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)\n{\n    DSA *dsa;\n    int ptype;\n    unsigned char *penc = NULL;\n    int penclen;\n    ASN1_STRING *str = NULL;\n    dsa = pkey->pkey.dsa;\n    if (pkey->save_parameters && dsa->p && dsa->q && dsa->g) {\n        str = ASN1_STRING_new();\n        if (!str) {\n            DSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        str->length = i2d_DSAparams(dsa, &str->data);\n        if (str->length <= 0) {\n            DSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        ptype = V_ASN1_SEQUENCE;\n    } else\n        ptype = V_ASN1_UNDEF;\n    dsa->write_params = 0;\n    penclen = i2d_DSAPublicKey(dsa, &penc);\n    if (penclen <= 0) {\n        DSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if (X509_PUBKEY_set0_param(pk, OBJ_nid2obj(EVP_PKEY_DSA),\n                               ptype, str, penc, penclen))\n        return 1;\n err:\n    if (penc)\n        OPENSSL_free(penc);\n    if (str)\n        ASN1_STRING_free(str);\n    return 0;\n}", "target": 0}
{"code": "or_cclass(CClassNode* dest, CClassNode* cc, ScanEnv* env)\n{\n  OnigEncoding enc = env->enc;\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf = 0;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_or(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n    bsr1 = dest->bs;\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = and_code_range_buf(buf1, 0, buf2, 0, &pbuf, env);\n    }\n    else {\n      r = or_code_range_buf(enc, buf1, not1, buf2, not2, &pbuf, env);\n      if (r == 0 && not1 != 0) {\n\tBBuf *tbuf = 0;\n\tr = not_code_range_buf(enc, pbuf, &tbuf, env);\n\tbbuf_free(pbuf);\n\tpbuf = tbuf;\n      }\n    }\n    if (r != 0) {\n      bbuf_free(pbuf);\n      return r;\n    }\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  else\n    return 0;\n}", "target": 0}
{"code": "ChromotingInstance::~ChromotingInstance() {\n  DCHECK(plugin_task_runner_->BelongsToCurrentThread());\n  UnregisterLoggingInstance();\n  view_.reset();\n  if (client_.get()) {\n    client_->Stop(base::Bind(&PluginThreadTaskRunner::Quit,\n                  plugin_task_runner_));\n  } else {\n    plugin_task_runner_->Quit();\n  }\n  plugin_task_runner_->DetachAndRunShutdownLoop();\n  context_.Stop();\n}", "target": 0}
{"code": "TfLiteStatus ReportOpError(TfLiteContext* context, const TfLiteNode& node,\n                           const TfLiteRegistration& registration,\n                           int node_index, const char* message) {\n  context->ReportError(\n      context, \"Node number %d (%s) %s.\\n\", node_index,\n      registration.custom_name\n          ? registration.custom_name\n          : EnumNameBuiltinOperator(\n                static_cast<BuiltinOperator>(registration.builtin_code)),\n      message);\n  return kTfLiteError;\n}", "target": 0}
{"code": "void inet6_ifinfo_notify(int event, struct inet6_dev *idev)\n{\n\tstruct sk_buff *skb;\n\tstruct net *net = dev_net(idev->dev);\n\tint err = -ENOBUFS;\n\tskb = nlmsg_new(inet6_if_nlmsg_size(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\terr = inet6_fill_ifinfo(skb, idev, 0, 0, event, 0);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_IFINFO, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_IFINFO, err);\n}", "target": 0}
{"code": "void bvec_free(mempool_t *pool, struct bio_vec *bv, unsigned int idx)\n{\n\tif (!idx)\n\t\treturn;\n\tidx--;\n\tBIO_BUG_ON(idx >= BVEC_POOL_NR);\n\tif (idx == BVEC_POOL_MAX) {\n\t\tmempool_free(bv, pool);\n\t} else {\n\t\tstruct biovec_slab *bvs = bvec_slabs + idx;\n\t\tkmem_cache_free(bvs->slab, bv);\n\t}\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_intersect_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& key_compare_func,\n                         const Array& args ) {\n  Variant func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, true COMMA true\n                      COMMA cmp_func COMMA &func);\n}", "target": 0}
{"code": "static bool get_group_list(struct torture_context *torture,\n\t\t\t   unsigned int *num_entries,\n\t\t\t   char ***groups)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tchar **g = NULL;\n\tuint32_t count;\n\tchar name[256];\n\tconst char *extra_data;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_LIST_GROUPS, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\t*num_entries = rep.data.num_entries;\n\tif (*num_entries == 0) {\n\t\ttorture_assert(torture, extra_data == NULL,\n\t\t\t       \"extra data is null for >0 reported entries\\n\");\n\t\t*groups = NULL;\n\t\treturn true;\n\t}\n\ttorture_assert(torture, extra_data, \"NULL extra data\");\n\tfor(count = 0;\n\t    next_token(&extra_data, name, \",\", sizeof(name));\n\t    count++)\n\t{\n\t\tg = talloc_realloc(torture, g, char *, count + 2);\n\t\tg[count+1] = NULL;\n\t\tg[count] = talloc_strdup(g, name);\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\ttorture_assert_int_equal(torture, *num_entries, count,\n\t\t\t\t \"Wrong number of group entries reported.\");\n\t*groups = g;\n\treturn true;\n}", "target": 0}
{"code": "void btrfs_update_commit_device_bytes_used(struct btrfs_transaction *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_device *dev;\n\tint i;\n\tif (list_empty(&trans->pending_chunks))\n\t\treturn;\n\tmutex_lock(&fs_info->chunk_mutex);\n\tlist_for_each_entry(em, &trans->pending_chunks, list) {\n\t\tmap = em->map_lookup;\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tdev = map->stripes[i].dev;\n\t\t\tdev->commit_bytes_used = dev->bytes_used;\n\t\t}\n\t}\n\tmutex_unlock(&fs_info->chunk_mutex);\n}", "target": 0}
{"code": "get_case_fold_codes_by_str(OnigCaseFoldType flag,\n\t\t\t   const OnigUChar* p, const OnigUChar* end,\n\t\t\t   OnigCaseFoldCodeItem items[],\n\t\t\t   OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_get_case_fold_codes_by_str_with_map(\n\t     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,\n\t     flag, p, end, items);\n}", "target": 0}
{"code": "static void dup_copy_fields(struct nfsd4_copy *src, struct nfsd4_copy *dst)\n{\n\tdst->cp_src_pos = src->cp_src_pos;\n\tdst->cp_dst_pos = src->cp_dst_pos;\n\tdst->cp_count = src->cp_count;\n\tdst->cp_synchronous = src->cp_synchronous;\n\tmemcpy(&dst->cp_res, &src->cp_res, sizeof(src->cp_res));\n\tmemcpy(&dst->fh, &src->fh, sizeof(src->fh));\n\tdst->cp_clp = src->cp_clp;\n\tdst->file_dst = get_file(src->file_dst);\n\tdst->file_src = get_file(src->file_src);\n\tmemcpy(&dst->cp_stateid, &src->cp_stateid, sizeof(src->cp_stateid));\n}", "target": 0}
{"code": "void securityWarningCommand(client *c) {\n    static time_t logged_time;\n    time_t now = time(NULL);\n    if (labs(now-logged_time) > 60) {\n        serverLog(LL_WARNING,\"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.\");\n        logged_time = now;\n    }\n    freeClientAsync(c);\n}", "target": 0}
{"code": "  virtual bool cellular_connecting() const { return false; }", "target": 0}
{"code": "isdn_timer_funct(ulong dummy)\n{\n\tint tf = dev->tflags;\n\tif (tf & ISDN_TIMER_FAST) {\n\t\tif (tf & ISDN_TIMER_MODEMREAD)\n\t\t\tisdn_tty_readmodem();\n\t\tif (tf & ISDN_TIMER_MODEMPLUS)\n\t\t\tisdn_tty_modem_escape();\n\t\tif (tf & ISDN_TIMER_MODEMXMIT)\n\t\t\tisdn_tty_modem_xmit();\n\t}\n\tif (tf & ISDN_TIMER_SLOW) {\n\t\tif (++isdn_timer_cnt1 >= ISDN_TIMER_02SEC) {\n\t\t\tisdn_timer_cnt1 = 0;\n\t\t\tif (tf & ISDN_TIMER_NETDIAL)\n\t\t\t\tisdn_net_dial();\n\t\t}\n\t\tif (++isdn_timer_cnt2 >= ISDN_TIMER_1SEC) {\n\t\t\tisdn_timer_cnt2 = 0;\n\t\t\tif (tf & ISDN_TIMER_NETHANGUP)\n\t\t\t\tisdn_net_autohup();\n\t\t\tif (++isdn_timer_cnt3 >= ISDN_TIMER_RINGING) {\n\t\t\t\tisdn_timer_cnt3 = 0;\n\t\t\t\tif (tf & ISDN_TIMER_MODEMRING)\n\t\t\t\t\tisdn_tty_modem_ring();\n\t\t\t}\n\t\t\tif (tf & ISDN_TIMER_CARRIER)\n\t\t\t\tisdn_tty_carrier_timeout();\n\t\t}\n\t}\n\tif (tf)\n\t\tmod_timer(&dev->timer, jiffies + ISDN_TIMER_RES);\n}", "target": 0}
{"code": "void JOIN::set_allowed_join_cache_types()\n{\n  allowed_join_cache_types= 0;\n  if (optimizer_flag(thd, OPTIMIZER_SWITCH_JOIN_CACHE_INCREMENTAL))\n    allowed_join_cache_types|= JOIN_CACHE_INCREMENTAL_BIT;\n  if (optimizer_flag(thd, OPTIMIZER_SWITCH_JOIN_CACHE_HASHED))\n    allowed_join_cache_types|= JOIN_CACHE_HASHED_BIT;\n  if (optimizer_flag(thd, OPTIMIZER_SWITCH_JOIN_CACHE_BKA))\n    allowed_join_cache_types|= JOIN_CACHE_BKA_BIT;\n  allowed_semijoin_with_cache=\n    optimizer_flag(thd, OPTIMIZER_SWITCH_SEMIJOIN_WITH_CACHE);\n  allowed_outer_join_with_cache=\n    optimizer_flag(thd, OPTIMIZER_SWITCH_OUTER_JOIN_WITH_CACHE);\n  max_allowed_join_cache_level= thd->variables.join_cache_level;\n}", "target": 0}
{"code": "static void free_user_work(struct work_struct *work)\n{\n\tstruct ipmi_user *user = container_of(work, struct ipmi_user,\n\t\t\t\t\t      remove_work);\n\tcleanup_srcu_struct(&user->release_barrier);\n\tkfree(user);\n}", "target": 0}
{"code": "    **/\n    CImg<T>& load_dcraw_external(const char *const filename) {\n      if (!filename)\n        throw CImgArgumentException(_cimg_instance\n                                    \"load_dcraw_external(): Specified filename is (null).\",\n                                    cimg_instance);\n      std::fclose(cimg::fopen(filename,\"rb\"));            \n      CImg<charT> command(1024), filename_tmp(256);\n      std::FILE *file = 0;\n      const CImg<charT> s_filename = CImg<charT>::string(filename)._system_strescape();\n#if cimg_OS==1\n      cimg_snprintf(command,command._width,\"%s -w -4 -c \\\"%s\\\"\",\n                    cimg::dcraw_path(),s_filename.data());\n      file = popen(command,\"r\");\n      if (file) {\n        const unsigned int omode = cimg::exception_mode();\n        cimg::exception_mode(0);\n        try { load_pnm(file); } catch (...) {\n          pclose(file);\n          cimg::exception_mode(omode);\n          throw CImgIOException(_cimg_instance\n                                \"load_dcraw_external(): Failed to load file '%s' with external command 'dcraw'.\",\n                                cimg_instance,\n                                filename);\n        }\n        pclose(file);\n        return *this;\n      }\n#endif\n      do {\n        cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.ppm\",\n                      cimg::temporary_path(),cimg_file_separator,cimg::filenamerand());\n        if ((file=std_fopen(filename_tmp,\"rb\"))!=0) cimg::fclose(file);\n      } while (file);\n      cimg_snprintf(command,command._width,\"%s -w -4 -c \\\"%s\\\" > \\\"%s\\\"\",\n                    cimg::dcraw_path(),s_filename.data(),CImg<charT>::string(filename_tmp)._system_strescape().data());\n      cimg::system(command,cimg::dcraw_path());\n      if (!(file = std_fopen(filename_tmp,\"rb\"))) {\n        cimg::fclose(cimg::fopen(filename,\"r\"));\n        throw CImgIOException(_cimg_instance\n                              \"load_dcraw_external(): Failed to load file '%s' with external command 'dcraw'.\",\n                              cimg_instance,\n                              filename);\n      } else cimg::fclose(file);\n      load_pnm(filename_tmp);\n      std::remove(filename_tmp);\n      return *this;", "target": 0}
{"code": "table_map Item_field::all_used_tables() const\n{\n  return (get_depended_from() ? OUTER_REF_TABLE_BIT : field->table->map);\n}", "target": 0}
{"code": "const char* DocumentSourceGroup::getSourceName() const {\n    return kStageName.rawData();\n}", "target": 0}
{"code": "static const char *binary_strcspn(const char *s, const char *e, const char *chars) {\n\twhile (*chars) {\n\t\tconst char *p = memchr(s, *chars, e - s);\n\t\tif (p) {\n\t\t\te = p;\n\t\t}\n\t\tchars++;\n\t}\n\treturn e;\n}", "target": 0}
{"code": "dirserv_read_measured_bandwidths(const char *from_file,\n                                 smartlist_t *routerstatuses)\n{\n  char line[256];\n  FILE *fp = fopen(from_file, \"r\");\n  int applied_lines = 0;\n  time_t file_time;\n  int ok;\n  if (fp == NULL) {\n    log_warn(LD_CONFIG, \"Can't open bandwidth file at configured location: %s\",\n             from_file);\n    return -1;\n  }\n  if (!fgets(line, sizeof(line), fp)\n          || !strlen(line) || line[strlen(line)-1] != '\\n') {\n    log_warn(LD_DIRSERV, \"Long or truncated time in bandwidth file: %s\",\n             escaped(line));\n    fclose(fp);\n    return -1;\n  }\n  line[strlen(line)-1] = '\\0';\n  file_time = tor_parse_ulong(line, 10, 0, ULONG_MAX, &ok, NULL);\n  if (!ok) {\n    log_warn(LD_DIRSERV, \"Non-integer time in bandwidth file: %s\",\n             escaped(line));\n    fclose(fp);\n    return -1;\n  }\n  if ((time(NULL) - file_time) > MAX_MEASUREMENT_AGE) {\n    log_warn(LD_DIRSERV, \"Bandwidth measurement file stale. Age: %u\",\n             (unsigned)(time(NULL) - file_time));\n    fclose(fp);\n    return -1;\n  }\n  if (routerstatuses)\n    smartlist_sort(routerstatuses, compare_routerstatus_entries);\n  while (!feof(fp)) {\n    measured_bw_line_t parsed_line;\n    if (fgets(line, sizeof(line), fp) && strlen(line)) {\n      if (measured_bw_line_parse(&parsed_line, line) != -1) {\n        if (measured_bw_line_apply(&parsed_line, routerstatuses) > 0)\n          applied_lines++;\n      }\n    }\n  }\n  fclose(fp);\n  log_info(LD_DIRSERV,\n           \"Bandwidth measurement file successfully read. \"\n           \"Applied %d measurements.\", applied_lines);\n  return 0;\n}", "target": 0}
{"code": "void ScriptController::bindToWindowObject(Frame* frame, const String& key, NPObject* object)\n{\n    v8::HandleScope handleScope(m_isolate);\n    v8::Handle<v8::Context> v8Context = ScriptController::mainWorldContext(frame);\n    if (v8Context.IsEmpty())\n        return;\n    v8::Context::Scope scope(v8Context);\n    v8::Handle<v8::Object> value = createV8ObjectForNPObject(object, 0);\n    v8::Handle<v8::Object> global = v8Context->Global();\n    global->Set(v8String(key, m_isolate), value);\n}", "target": 0}
{"code": "static int handle_external_interrupt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.irq_exits;\n\treturn 1;\n}", "target": 0}
{"code": "  decodeResources(std::initializer_list<MessageType> resources,\n                  const std::string& name_field = \"name\") {\n    Config::DecodedResourcesWrapper decoded_resources;\n    for (const auto& resource : resources) {\n      auto owned_resource = std::make_unique<MessageType>(resource);\n      decoded_resources.owned_resources_.emplace_back(new Config::DecodedResourceImpl(\n          std::move(owned_resource), MessageUtil::getStringField(resource, name_field), {}, \"\"));\n      decoded_resources.refvec_.emplace_back(*decoded_resources.owned_resources_.back());\n    }\n    return decoded_resources;\n  }", "target": 0}
{"code": "str_to_dqb_num(pam_handle_t *pamh, const char *str, const char *param) {\n  char *ep = NULL;\n  errno = 0;\n  long long temp = strtoll(str, &ep, 10);\n  if (temp < 0 || str == ep || *ep != '\\0' || errno !=0) {\n    pam_syslog(pamh, LOG_ERR, \"Parameter \\\"%s=%s\\\" invalid, setting to 0\", param, str);\n    return 0;\n  }\n  else {\n    return temp;\n  }\n}", "target": 0}
{"code": "void sched_clock_init(void)\n{\n\tu64 ktime_now = ktime_to_ns(ktime_get());\n\tint cpu;\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct sched_clock_data *scd = cpu_sdc(cpu);\n\t\tscd->tick_raw = 0;\n\t\tscd->tick_gtod = ktime_now;\n\t\tscd->clock = ktime_now;\n\t}\n\tsched_clock_running = 1;\n\tsmp_mb(); \n\tif (__sched_clock_stable_early)\n\t\t__set_sched_clock_stable();\n\telse\n\t\t__clear_sched_clock_stable(NULL);\n}", "target": 0}
{"code": "string CLua::setuniqregistry()\n{\n    char name[100];\n    snprintf(name, sizeof name, \"__cru%u\", uniqindex++);\n    lua_pushstring(state(), name);\n    lua_insert(state(), -2);\n    lua_settable(state(), LUA_REGISTRYINDEX);\n    return name;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, IndexBoundsOrOfNegations) {\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{$or: [{a: {$ne: null}}, {a: {$ne: 4}}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a:1}, \"\n        \"bounds: {a: [['MinKey','MaxKey',true,true]]}}}}}\");\n}", "target": 0}
{"code": "    bool atEOF() const { return isAtEof; }", "target": 0}
{"code": "static inline int pfkey_mode_to_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase IPSEC_MODE_ANY:\t\n\tcase IPSEC_MODE_TRANSPORT:\n\t\treturn XFRM_MODE_TRANSPORT;\n\tcase IPSEC_MODE_TUNNEL:\n\t\treturn XFRM_MODE_TUNNEL;\n\tcase IPSEC_MODE_BEET:\n\t\treturn XFRM_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}", "target": 0}
{"code": "GF_Err stvi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tgf_bs_read_int(bs, 30);\n\tptr->single_view_allowed = gf_bs_read_int(bs, 2);\n\tptr->stereo_scheme = gf_bs_read_u32(bs);\n\tptr->sit_len = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, ptr->sit_len);\n\tptr->stereo_indication_type = gf_malloc(sizeof(char)*ptr->sit_len);\n\tif (!ptr->stereo_indication_type) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\treturn GF_OK;\n}", "target": 0}
{"code": "cmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    size_t\tlen = STRLEN(cmd);\n    STRCPY(bufp, cmd);\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp + len, bufsize - len, \"%ld\", Prenum);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest,\n       EmptyQueryWithProjectionUsesCoveredIxscanOnDotttedNonMultikeyIndexIfEnabled) {\n    params.options = QueryPlannerParams::GENERATE_COVERED_IXSCANS;\n    addIndex(BSON(\"a.b\" << 1));\n    runQueryAsCommand(fromjson(\"{find: 'testns', projection: {_id: 0, 'a.b': 1}}\"));\n    assertNumSolutions(1);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, 'a.b': 1}, node: \"\n        \"{ixscan: {filter: null, pattern: {'a.b': 1},\"\n        \"bounds: {'a.b': [['MinKey', 'MaxKey', true, true]]}}}}}\");\n}", "target": 0}
{"code": "static int btrfs_relocate_chunk(struct btrfs_fs_info *fs_info, u64 chunk_offset)\n{\n\tstruct btrfs_root *root = fs_info->chunk_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tlockdep_assert_held(&fs_info->delete_unused_bgs_mutex);\n\tret = btrfs_can_relocate(fs_info, chunk_offset);\n\tif (ret)\n\t\treturn -ENOSPC;\n\tbtrfs_scrub_pause(fs_info);\n\tret = btrfs_relocate_block_group(fs_info, chunk_offset);\n\tbtrfs_scrub_continue(fs_info);\n\tif (ret)\n\t\treturn ret;\n\tbtrfs_add_raid_kobjects(fs_info);\n\ttrans = btrfs_start_trans_remove_block_group(root->fs_info,\n\t\t\t\t\t\t     chunk_offset);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_handle_fs_error(root->fs_info, ret, NULL);\n\t\treturn ret;\n\t}\n\tret = btrfs_remove_chunk(trans, chunk_offset);\n\tbtrfs_end_transaction(trans);\n\treturn ret;\n}", "target": 0}
{"code": "void OmniboxViewWin::OnTemporaryTextMaybeChanged(const string16& display_text,\n                                                 bool save_original_selection) {\n  if (save_original_selection)\n    GetSelection(original_selection_);\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  SetWindowTextAndCaretPos(display_text, display_text.length());\n  TextChanged();\n}", "target": 0}
{"code": "gather_edges_for_value (ipcp_value<valtype> *val, cgraph_node *dest,\n\t\t\tint caller_count)\n{\n  ipcp_value_source<valtype> *src;\n  vec<cgraph_edge *> ret;\n  ret.create (caller_count);\n  for (src = val->sources; src; src = src->next)\n    {\n      struct cgraph_edge *cs = src->cs;\n      while (cs)\n\t{\n\t  if (cgraph_edge_brings_value_p (cs, src, dest, val))\n\t    ret.quick_push (cs);\n\t  cs = get_next_cgraph_edge_clone (cs);\n\t}\n    }\n  return ret;\n}", "target": 0}
{"code": "    BasicIo& Image::io() const\n    {\n        return *io_;\n    }", "target": 0}
{"code": "static int mxf_add_metadata_stream(MXFContext *mxf, MXFTrack *track)\n{\n    MXFStructuralComponent *component = NULL;\n    const MXFCodecUL *codec_ul = NULL;\n    MXFPackage tmp_package;\n    AVStream *st;\n    int j;\n    for (j = 0; j < track->sequence->structural_components_count; j++) {\n        component = mxf_resolve_sourceclip(mxf, &track->sequence->structural_components_refs[j]);\n        if (!component)\n            continue;\n        break;\n    }\n    if (!component)\n        return 0;\n    st = avformat_new_stream(mxf->fc, NULL);\n    if (!st) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"could not allocate metadata stream\\n\");\n        return AVERROR(ENOMEM);\n    }\n    st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n    st->codecpar->codec_id = AV_CODEC_ID_NONE;\n    st->id = track->track_id;\n    memcpy(&tmp_package.package_ul, component->source_package_ul, 16);\n    memcpy(&tmp_package.package_uid, component->source_package_uid, 16);\n    mxf_add_umid_metadata(&st->metadata, \"file_package_umid\", &tmp_package);\n    if (track->name && track->name[0])\n        av_dict_set(&st->metadata, \"track_name\", track->name, 0);\n    codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &track->sequence->data_definition_ul);\n    av_dict_set(&st->metadata, \"data_type\", av_get_media_type_string(codec_ul->id), 0);\n    return 0;\n}", "target": 0}
{"code": "static bool red_stream_write_u8(RedStream *s, uint8_t n)\n{\n    return red_stream_write_all(s, &n, sizeof(uint8_t));\n}", "target": 0}
{"code": "smpl_t aubio_tempo_get_last_s (aubio_tempo_t *o)\n{\n  return aubio_tempo_get_last (o) / (smpl_t) (o->samplerate);\n}", "target": 0}
{"code": "  void set_context(Context* context) {\n    ASSERT(context == NULL || context->IsContext());\n    thread_local_top_.context_ = context;\n  }", "target": 0}
{"code": "ebt_make_names(struct ebt_entry *e, const char *base, char __user *ubase)\n{\n\tint ret;\n\tchar __user *hlp;\n\tconst struct ebt_entry_target *t;\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\thlp = ubase + (((char *)e + e->target_offset) - base);\n\tt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\n\tret = EBT_MATCH_ITERATE(e, ebt_make_matchname, base, ubase);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = EBT_WATCHER_ITERATE(e, ebt_make_watchername, base, ubase);\n\tif (ret != 0)\n\t\treturn ret;\n\tif (copy_to_user(hlp, t->u.target->name, EBT_FUNCTION_MAXNAMELEN))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "static void __mcheck_cpu_init_vendor(struct cpuinfo_x86 *c)\n{\n\tswitch (c->x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\tmce_intel_feature_init(c);\n\t\tmce_adjust_timer = cmci_intel_adjust_timer;\n\t\tbreak;\n\tcase X86_VENDOR_AMD: {\n\t\tmce_amd_feature_init(c);\n\t\tbreak;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "void AutoFillManager::GetProfileSuggestions(FormStructure* form,\n                                            const FormField& field,\n                                            AutoFillType type,\n                                            bool include_cc_labels,\n                                            std::vector<string16>* values,\n                                            std::vector<string16>* labels,\n                                            std::vector<int>* unique_ids) {\n  const std::vector<AutoFillProfile*>& profiles = personal_data_->profiles();\n  std::vector<AutoFillProfile*> matched_profiles;\n  for (std::vector<AutoFillProfile*>::const_iterator iter = profiles.begin();\n       iter != profiles.end(); ++iter) {\n    AutoFillProfile* profile = *iter;\n    string16 profile_field_value = profile->GetFieldText(type);\n    if (!profile_field_value.empty() &&\n        StartsWith(profile_field_value, field.value(), false)) {\n      matched_profiles.push_back(profile);\n      values->push_back(profile_field_value);\n      unique_ids->push_back(profile->unique_id());\n    }\n  }\n  AutoFillProfile::CreateInferredLabels(&matched_profiles, labels, 0,\n                                        type.field_type());\n  if (!include_cc_labels || !form->HasBillingFields() || !FormIsHTTPS(form))\n    return;\n  size_t i = 0;\n  std::vector<string16> expanded_values;\n  std::vector<string16> expanded_labels;\n  for (std::vector<AutoFillProfile*>::const_iterator iter =\n       matched_profiles.begin(); iter != matched_profiles.end();\n       ++iter, ++i) {\n    AutoFillProfile* profile = *iter;\n    for (std::vector<CreditCard*>::const_iterator cc =\n         personal_data_->credit_cards().begin();\n         cc != personal_data_->credit_cards().end(); ++cc) {\n      expanded_values.push_back((*values)[i]);\n      string16 label = (*labels)[i] + kLabelSeparator +\n          (*cc)->LastFourDigits();\n      expanded_labels.push_back(label);\n      unique_ids->push_back(profile->unique_id());\n    }\n  }\n  expanded_labels.swap(*labels);\n  expanded_values.swap(*values);\n}", "target": 0}
{"code": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn 1ULL << 20;\n\tif (period == 0)\n\t\treturn 0;\n\treturn div64_u64(runtime << 20, period);\n}", "target": 0}
{"code": "int sctp_auth_ep_add_chunkid(struct sctp_endpoint *ep, __u8 chunk_id)\n{\n\tstruct sctp_chunks_param *p = ep->auth_chunk_list;\n\t__u16 nchunks;\n\t__u16 param_len;\n\tif (__sctp_auth_cid(chunk_id, p))\n\t\treturn 0;\n\tparam_len = ntohs(p->param_hdr.length);\n\tnchunks = param_len - sizeof(sctp_paramhdr_t);\n\tif (nchunks == SCTP_NUM_CHUNK_TYPES)\n\t\treturn -EINVAL;\n\tp->chunks[nchunks] = chunk_id;\n\tp->param_hdr.length = htons(param_len + 1);\n\treturn 0;\n}", "target": 0}
{"code": "static struct mountpoint *lock_mount(struct path *path)\n{\n\tstruct vfsmount *mnt;\n\tstruct dentry *dentry = path->dentry;\nretry:\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (unlikely(cant_mount(dentry))) {\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tnamespace_lock();\n\tmnt = lookup_mnt(path);\n\tif (likely(!mnt)) {\n\t\tstruct mountpoint *mp = new_mountpoint(dentry);\n\t\tif (IS_ERR(mp)) {\n\t\t\tnamespace_unlock();\n\t\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\t\treturn mp;\n\t\t}\n\t\treturn mp;\n\t}\n\tnamespace_unlock();\n\tmutex_unlock(&path->dentry->d_inode->i_mutex);\n\tpath_put(path);\n\tpath->mnt = mnt;\n\tdentry = path->dentry = dget(mnt->mnt_root);\n\tgoto retry;\n}", "target": 0}
{"code": "void __init hugetlb_cma_check(void)\n{\n\tif (!hugetlb_cma_size || cma_reserve_called)\n\t\treturn;\n\tpr_warn(\"hugetlb_cma: the option isn't supported by current arch\\n\");\n}", "target": 0}
{"code": "void vnc_display_init(const char *id)\n{\n    VncDisplay *vs;\n    if (vnc_display_find(id) != NULL) {\n        return;\n    }\n    vs = g_malloc0(sizeof(*vs));\n    vs->id = strdup(id);\n    QTAILQ_INSERT_TAIL(&vnc_displays, vs, next);\n    vs->lsock = -1;\n    vs->lwebsock = -1;\n    QTAILQ_INIT(&vs->clients);\n    vs->expires = TIME_MAX;\n    if (keyboard_layout) {\n        trace_vnc_key_map_init(keyboard_layout);\n        vs->kbd_layout = init_keyboard_layout(name2keysym, keyboard_layout);\n    } else {\n        vs->kbd_layout = init_keyboard_layout(name2keysym, \"en-us\");\n    }\n    if (!vs->kbd_layout)\n        exit(1);\n    qemu_mutex_init(&vs->mutex);\n    vnc_start_worker_thread();\n    vs->dcl.ops = &dcl_ops;\n    register_displaychangelistener(&vs->dcl);\n}", "target": 0}
{"code": "d_lite_amjd(VALUE self)\n{\n    get_d1(self);\n    return m_amjd(dat);\n}", "target": 0}
{"code": "static u32 ctrn_read_flags(GF_BitStream *bs, u32 nbbits)\n{\n\tu32 val = gf_bs_read_int(bs, nbbits);\n\tif (nbbits==16) val <<= 16;\n\telse if (nbbits==8) val <<= 24;\n\treturn val;\n}", "target": 0}
{"code": "void Item_ident_for_show::make_field(Send_field *tmp_field)\n{\n  tmp_field->table_name= tmp_field->org_table_name= table_name;\n  tmp_field->db_name= db_name;\n  tmp_field->col_name= tmp_field->org_col_name= field->field_name;\n  tmp_field->charsetnr= field->charset()->number;\n  tmp_field->length=field->field_length;\n  tmp_field->type=field->type();\n  tmp_field->flags= field->table->maybe_null ? \n    (field->flags & ~NOT_NULL_FLAG) : field->flags;\n  tmp_field->decimals= field->decimals();\n}", "target": 0}
{"code": "static int xgene_hwmon_remove(struct platform_device *pdev)\n{\n\tstruct xgene_hwmon_dev *ctx = platform_get_drvdata(pdev);\n\tcancel_work_sync(&ctx->workq);\n\thwmon_device_unregister(ctx->hwmon_dev);\n\tkfifo_free(&ctx->async_msg_fifo);\n\tif (acpi_disabled)\n\t\tmbox_free_channel(ctx->mbox_chan);\n\telse\n\t\tpcc_mbox_free_channel(ctx->pcc_chan);\n\treturn 0;\n}", "target": 0}
{"code": "impl_get_certificates (EphyCertificateManager *manager,\n                       EphyX509CertType type)\n{\n  return NULL;\n}", "target": 0}
{"code": "do_list_tubes(conn c, ms l)\n{\n    char *buf;\n    tube t;\n    size_t i, resp_z;\n    resp_z = 6; \n    for (i = 0; i < l->used; i++) {\n        t = l->items[i];\n        resp_z += 3 + strlen(t->name); \n    }\n    c->out_job = allocate_job(resp_z); \n    if (!c->out_job) return reply_serr(c, MSG_OUT_OF_MEMORY);\n    c->out_job->state = JOB_STATE_COPY;\n    buf = c->out_job->body;\n    buf += snprintf(buf, 5, \"---\\n\");\n    for (i = 0; i < l->used; i++) {\n        t = l->items[i];\n        buf += snprintf(buf, 4 + strlen(t->name), \"- %s\\n\", t->name);\n    }\n    buf[0] = '\\r';\n    buf[1] = '\\n';\n    c->out_job_sent = 0;\n    return reply_line(c, STATE_SENDJOB, \"OK %d\\r\\n\", resp_z - 2);\n}", "target": 0}
{"code": "std::unique_ptr<cql_server::response> cql_server::connection::make_read_timeout_error(int16_t stream, exceptions::exception_code err, sstring msg, db::consistency_level cl, int32_t received, int32_t blockfor, bool data_present, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_consistency(cl);\n    response->write_int(received);\n    response->write_int(blockfor);\n    response->write_byte(data_present);\n    return response;\n}", "target": 0}
{"code": "void tty_ldisc_deref(struct tty_ldisc *ld)\n{\n\tldsem_up_read(&ld->tty->ldisc_sem);\n}", "target": 0}
{"code": "u64 ring_buffer_time_stamp(struct ring_buffer *buffer, int cpu)\n{\n\tu64 time;\n\tpreempt_disable_notrace();\n\ttime = rb_time_stamp(buffer);\n\tpreempt_enable_no_resched_notrace();\n\treturn time;\n}", "target": 0}
{"code": "    const char* Iptcdatum::familyName() const\n    {\n        return key_.get() == 0 ? \"\" : key_->familyName();\n    }", "target": 0}
{"code": "static int sk_rcvbuf_lowwater(struct caifsock *cf_sk)\n{\n\treturn cf_sk->sk.sk_rcvbuf / 4;\n}", "target": 0}
{"code": "static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\trc = -ENODEV;\n\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!llc->dev)\n\t\tgoto out;\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY; \n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\treturn rc;\n}", "target": 0}
{"code": "bool PrintWebViewHelper::PreviewPageRendered(int page_number,\n                                             printing::Metafile* metafile) {\n  DCHECK_GE(page_number, printing::FIRST_PAGE_INDEX);\n  if (!print_preview_context_.IsModifiable() ||\n      !print_preview_context_.generate_draft_pages()) {\n    DCHECK(!metafile);\n    return true;\n  }\n  if (!metafile) {\n    NOTREACHED();\n    print_preview_context_.set_error(\n        PREVIEW_ERROR_PAGE_RENDERED_WITHOUT_METAFILE);\n    return false;\n  }\n  PrintHostMsg_DidPreviewPage_Params preview_page_params;\n  uint32 buf_size = metafile->GetDataSize();\n  DCHECK_GT(buf_size, 0u);\n  if (!CopyMetafileDataToSharedMem(\n      metafile, &(preview_page_params.metafile_data_handle))) {\n    LOG(ERROR) << \"CopyMetafileDataToSharedMem failed\";\n    print_preview_context_.set_error(PREVIEW_ERROR_METAFILE_COPY_FAILED);\n    return false;\n  }\n  preview_page_params.data_size = buf_size;\n  preview_page_params.page_number = page_number;\n  preview_page_params.preview_request_id =\n      print_pages_params_->params.preview_request_id;\n  Send(new PrintHostMsg_DidPreviewPage(routing_id(), preview_page_params));\n  return true;\n}", "target": 0}
{"code": "static int nft_delset(struct nft_ctx *ctx, struct nft_set *set)\n{\n\tint err;\n\terr = nft_trans_set_add(ctx, NFT_MSG_DELSET, set);\n\tif (err < 0)\n\t\treturn err;\n\tlist_del_rcu(&set->list);\n\tctx->table->use--;\n\treturn err;\n}", "target": 0}
{"code": "void cgit_summary_link(const char *name, const char *title, const char *class,\n\t\t       const char *head)\n{\n\treporevlink(NULL, name, title, class, head, NULL, NULL);\n}", "target": 0}
{"code": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\tif (!iter_is_iovec(iter))\n\t\tgoto fail;\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\nfail:\n\trq->bio = NULL;\n\treturn -EINVAL;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageDestroy (gdImagePtr im)\n{\n\tint i;\n\tif (im->pixels) {\n\t\tfor (i = 0; (i < im->sy); i++) {\n\t\t\tgdFree (im->pixels[i]);\n\t\t}\n\t\tgdFree (im->pixels);\n\t}\n\tif (im->tpixels) {\n\t\tfor (i = 0; (i < im->sy); i++) {\n\t\t\tgdFree (im->tpixels[i]);\n\t\t}\n\t\tgdFree (im->tpixels);\n\t}\n\tif (im->polyInts) {\n\t\tgdFree (im->polyInts);\n\t}\n\tif (im->style) {\n\t\tgdFree (im->style);\n\t}\n\tgdFree (im);\n}", "target": 0}
{"code": "make_available_at_least (TiffContext *context, guint needed)\n{\n        guchar *new_buffer = NULL;\n        guint need_alloc;\n        need_alloc = context->used + needed;\n        if (need_alloc > context->allocated) {\n                guint new_size = 1;\n                while (new_size < need_alloc)\n                        new_size *= 2;\n                new_buffer = g_try_realloc (context->buffer, new_size);\n                if (new_buffer) {\n                        context->buffer = new_buffer;\n                        context->allocated = new_size;\n                        return TRUE;\n                }\n                return FALSE;\n        }\n        return TRUE;\n}", "target": 0}
{"code": "bool dir_is_in_dump_location(const char *dir_name)\n{\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0)\n    {\n        log_debug(\"Bad parent directory: '%s' not in '%s'\", g_settings_dump_location, dir_name);\n        return false;\n    }\n    const char *base_name = dir_name + len;\n    while (*base_name && *base_name == '/')\n        ++base_name;\n    if (*(base_name - 1) != '/' || !str_is_correct_filename(base_name))\n    {\n        log_debug(\"Invalid dump directory name: '%s'\", base_name);\n        return false;\n    }\n    struct stat sb;\n    if (lstat(dir_name, &sb) < 0)\n    {\n        VERB2 perror_msg(\"stat('%s')\", dir_name);\n        return errno== ENOENT;\n    }\n    return S_ISDIR(sb.st_mode);\n}", "target": 0}
{"code": "PHP_METHOD(Phar, count)\n{\n\tPHAR_ARCHIVE_OBJECT();\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(zend_hash_num_elements(&phar_obj->arc.archive->manifest));\n}", "target": 0}
{"code": "utf16le_code_to_mbc(OnigCodePoint code, UChar *buf,\n\t\t    OnigEncoding enc ARG_UNUSED)\n{\n  UChar* p = buf;\n  if (code > 0xffff) {\n    unsigned int high = (code >> 10) + 0xD7C0;\n    unsigned int low = (code & 0x3FF) + 0xDC00;\n    *p++ = high & 0xFF;\n    *p++ = (high >> 8) & 0xFF;\n    *p++ = low & 0xFF;\n    *p++ = (low >> 8) & 0xFF;\n    return 4;\n  }\n  else {\n    *p++ = (UChar )(code & 0xff);\n    *p++ = (UChar )((code & 0xff00) >> 8);\n    return 2;\n  }\n}", "target": 0}
{"code": "static void skcipher_release(void *private)\n{\n\tcrypto_free_ablkcipher(private);\n}", "target": 0}
{"code": "camel_imapx_server_ensure_selected_sync (CamelIMAPXServer *is,\n\t\t\t\t\t CamelIMAPXMailbox *mailbox,\n\t\t\t\t\t GCancellable *cancellable,\n\t\t\t\t\t GError **error)\n{\n\tCamelIMAPXCommand *ic;\n\tCamelIMAPXMailbox *selected_mailbox;\n\tgboolean success;\n\tg_return_val_if_fail (CAMEL_IS_IMAPX_SERVER (is), FALSE);\n\tg_return_val_if_fail (CAMEL_IS_IMAPX_MAILBOX (mailbox), FALSE);\n\tif (g_cancellable_set_error_if_cancelled (cancellable, error))\n\t\treturn FALSE;\n\tg_mutex_lock (&is->priv->select_lock);\n\tselected_mailbox = g_weak_ref_get (&is->priv->select_mailbox);\n\tif (selected_mailbox == mailbox) {\n\t\tg_mutex_unlock (&is->priv->select_lock);\n\t\tg_clear_object (&selected_mailbox);\n\t\treturn TRUE;\n\t}\n\tg_clear_object (&selected_mailbox);\n\tic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_SELECT, \"SELECT %M\", mailbox);\n\tif (is->priv->use_qresync) {\n\t\tCamelFolder *folder;\n\t\tfolder = imapx_server_ref_folder (is, mailbox);\n\t\tcamel_imapx_command_add_qresync_parameter (ic, folder);\n\t\tg_clear_object (&folder);\n\t}\n\tg_weak_ref_set (&is->priv->select_pending, mailbox);\n\tg_mutex_unlock (&is->priv->select_lock);\n\tsuccess = camel_imapx_server_process_command_sync (is, ic, _(\"Failed to select mailbox\"), cancellable, error);\n\tcamel_imapx_command_unref (ic);\n\tg_mutex_lock (&is->priv->select_lock);\n\tg_weak_ref_set (&is->priv->select_pending, NULL);\n\tif (success) {\n\t\tis->priv->state = IMAPX_SELECTED;\n\t\tg_weak_ref_set (&is->priv->select_mailbox, mailbox);\n\t}\n\tg_mutex_unlock (&is->priv->select_lock);\n\treturn success;\n}", "target": 0}
{"code": "static int fts3CommitMethod(sqlite3_vtab *pVtab){\n  TESTONLY( Fts3Table *p = (Fts3Table*)pVtab );\n  UNUSED_PARAMETER(pVtab);\n  assert( p->nPendingData==0 );\n  assert( p->inTransaction!=0 );\n  assert( p->pSegments==0 );\n  TESTONLY( p->inTransaction = 0 );\n  TESTONLY( p->mxSavepoint = -1; );\n  return SQLITE_OK;\n}", "target": 0}
{"code": "    Image::AutoPtr newTiffInstance(BasicIo::AutoPtr io, bool create)\n    {\n        Image::AutoPtr image(new TiffImage(io, create));\n        if (!image->good()) {\n            image.reset();\n        }\n        return image;\n    }", "target": 0}
{"code": "irc_server_get_tags_to_send (const char *tags)\n{\n    int length;\n    char *buf;\n    if (!tags && !irc_server_send_default_tags)\n        return NULL;\n    if (!tags)\n        return strdup (irc_server_send_default_tags);\n    if (!irc_server_send_default_tags)\n        return strdup (tags);\n    length = strlen (tags) + 1 + strlen (irc_server_send_default_tags) + 1;\n    buf = malloc (length);\n    if (buf)\n        snprintf (buf, length, \"%s,%s\", tags, irc_server_send_default_tags);\n    return buf;\n}", "target": 0}
{"code": "bool instantiate_tmp_table(TABLE *table, KEY *keyinfo, \n                           TMP_ENGINE_COLUMNDEF *start_recinfo,\n                           TMP_ENGINE_COLUMNDEF **recinfo,\n                           ulonglong options)\n{\n  if (table->s->db_type() == TMP_ENGINE_HTON)\n  {\n    MEM_CHECK_DEFINED(table->record[0], table->s->reclength);\n    if (create_internal_tmp_table(table, keyinfo, start_recinfo, recinfo,\n                                  options))\n      return TRUE;\n    MEM_CHECK_DEFINED(table->record[0], table->s->reclength);\n  }\n  if (open_tmp_table(table))\n    return TRUE;\n  return FALSE;\n}", "target": 0}
{"code": "static struct dentry *proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\tinode->i_nlink = 4;\n#ifdef CONFIG_SECURITY\n\tinode->i_nlink += 1;\n#endif\n\tdentry->d_op = &pid_dentry_operations;\n\td_add(dentry, inode);\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}", "target": 0}
{"code": "void ParamTraits<ListValue>::Write(Message* m, const param_type& p) {\n  WriteValue(m, &p, 0);\n}", "target": 0}
{"code": "void hostap_setup_dev(struct net_device *dev, local_info_t *local,\n\t\t      int type)\n{\n\tstruct hostap_interface *iface;\n\tiface = netdev_priv(dev);\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tif (iface) {\n\t\tiface->wireless_data.spy_data = &iface->spy_data;\n\t\tdev->wireless_data = &iface->wireless_data;\n\t}\n\tdev->wireless_handlers = &hostap_iw_handler_def;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tswitch(type) {\n\tcase HOSTAP_INTERFACE_AP:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_mgmt_netdev_ops;\n\t\tdev->type = ARPHRD_IEEE80211;\n\t\tdev->header_ops = &hostap_80211_ops;\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_MASTER:\n\t\tdev->netdev_ops = &hostap_master_ops;\n\t\tbreak;\n\tdefault:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_netdev_ops;\n\t}\n\tdev->mtu = local->mtu;\n\tSET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);\n}", "target": 0}
{"code": "static bool method_matches(const Method* m,\n                           const Symbol* signature,\n                           bool skipping_overpass,\n                           bool skipping_static,\n                           bool skipping_private) {\n  return ((m->signature() == signature) &&\n    (!skipping_overpass || !m->is_overpass()) &&\n    (!skipping_static || !m->is_static()) &&\n    (!skipping_private || !m->is_private()));\n}", "target": 0}
{"code": "DLLEXPORT unsigned long DLLCALL tjBufSizeYUV(int width, int height,\n\tint subsamp)\n{\n\treturn tjBufSizeYUV2(width, 4, height, subsamp);\n}", "target": 0}
{"code": "void *alloc_pgtable_page(int node)\n{\n\tstruct page *page;\n\tvoid *vaddr = NULL;\n\tpage = alloc_pages_node(node, GFP_ATOMIC | __GFP_ZERO, 0);\n\tif (page)\n\t\tvaddr = page_address(page);\n\treturn vaddr;\n}", "target": 0}
{"code": "get_string_on_virtaddr(struct magic_set *ms,\n    int swap, int clazz, int fd, off_t ph_off, int ph_num,\n    off_t fsize, uint64_t virtaddr, char *buf, ssize_t buflen)\n{\n\tchar *bptr;\n\toff_t offset;\n\tif (buflen == 0)\n\t\treturn 0;\n\toffset = get_offset_from_virtaddr(ms, swap, clazz, fd, ph_off, ph_num,\n\t    fsize, virtaddr);\n\tif ((buflen = pread(fd, buf, buflen, offset)) <= 0) {\n\t\tfile_badread(ms);\n\t\treturn 0;\n\t}\n\tbuf[buflen - 1] = '\\0';\n\tfor (bptr = buf; *bptr && isprint((unsigned char)*bptr); bptr++)\n\t\tcontinue;\n\tif (*bptr != '\\0')\n\t\treturn 0;\n\treturn bptr - buf;\n}", "target": 0}
{"code": "static bool handle_passthrough(struct avctp *conn, uint8_t op, bool pressed,\n\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct avrcp *session = user_data;\n\tconst struct passthrough_handler *handler;\n\tfor (handler = session->passthrough_handlers; handler->func;\n\t\t\t\t\t\t\t\thandler++) {\n\t\tif (handler->op == op)\n\t\t\tbreak;\n\t}\n\tif (handler->func == NULL)\n\t\treturn false;\n\tif (!pressed)\n\t\treturn true;\n\treturn handler->func(session);\n}", "target": 0}
{"code": "static void bnx2x_prep_ops(const u8 *_source, u8 *_target, u32 n)\n{\n\tconst __be32 *source = (const __be32 *)_source;\n\tstruct raw_op *target = (struct raw_op *)_target;\n\tu32 i, j, tmp;\n\tfor (i = 0, j = 0; i < n/8; i++, j += 2) {\n\t\ttmp = be32_to_cpu(source[j]);\n\t\ttarget[i].op = (tmp >> 24) & 0xff;\n\t\ttarget[i].offset = tmp & 0xffffff;\n\t\ttarget[i].raw_data = be32_to_cpu(source[j + 1]);\n\t}\n}", "target": 0}
{"code": "    template<typename t>\n    CImg<_cimg_Ttfloat> get_correlate(const CImg<t>& kernel, const bool boundary_conditions=true,\n                                      const bool is_normalized=false) const {\n      return _correlate(kernel,boundary_conditions,is_normalized,false);", "target": 0}
{"code": "detached_get_signatures(ns_detached_signatures_t *sigs,\n                        const char *flavor_name)\n{\n  smartlist_t *sl = strmap_get(sigs->signatures, flavor_name);\n  if (!sl) {\n    sl = smartlist_new();\n    strmap_set(sigs->signatures, flavor_name, sl);\n  }\n  return sl;\n}", "target": 0}
{"code": "static int realloc_func_state(struct bpf_func_state *state, int stack_size,\n\t\t\t      int refs_size, bool copy_old)\n{\n\tint err = realloc_reference_state(state, refs_size, copy_old);\n\tif (err)\n\t\treturn err;\n\treturn realloc_stack_state(state, stack_size, copy_old);\n}", "target": 0}
{"code": "nm_vpnc_secrets_validate (NMSettingVpn *s_vpn,\n                          gboolean allow_missing,\n                          GError **error)\n{\n\tGError *validate_error = NULL;\n\tValidateInfo info = { &valid_secrets[0], &validate_error, FALSE };\n\tnm_setting_vpn_foreach_secret (s_vpn, validate_one_property, &info);\n\tif (validate_error) {\n\t\tg_propagate_error (error, validate_error);\n\t\treturn FALSE;\n\t}\n\tif (allow_missing == FALSE && !info.have_items) {\n\t\tg_set_error (error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             \"%s\",\n\t\t             _(\"No VPN secrets!\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "my_decimal *Item_ref::val_decimal_result(my_decimal *decimal_value)\n{\n  if (result_field)\n  {\n    if ((null_value= result_field->is_null()))\n      return 0;\n    return result_field->val_decimal(decimal_value);\n  }\n  return val_decimal(decimal_value);\n}", "target": 0}
{"code": "static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr* nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tstruct net_device *dev = NULL;\n\tstruct sk_buff *nskb;\n\tint err;\n\tu32 ext_filter_mask = 0;\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy);\n\tif (err < 0)\n\t\treturn err;\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\tif (tb[IFLA_EXT_MASK])\n\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME])\n\t\tdev = __dev_get_by_name(net, ifname);\n\telse\n\t\treturn -EINVAL;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\tnskb = nlmsg_new(if_nlmsg_size(dev, ext_filter_mask), GFP_KERNEL);\n\tif (nskb == NULL)\n\t\treturn -ENOBUFS;\n\terr = rtnl_fill_ifinfo(nskb, dev, RTM_NEWLINK, NETLINK_CB(skb).portid,\n\t\t\t       nlh->nlmsg_seq, 0, 0, ext_filter_mask);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(nskb);\n\t} else\n\t\terr = rtnl_unicast(nskb, net, NETLINK_CB(skb).portid);\n\treturn err;\n}", "target": 0}
{"code": "int Elf_(r_bin_elf_has_nx)(ELFOBJ *bin) {\n\tint i;\n\tif (bin && bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_GNU_STACK) {\n\t\t\t\treturn (!(bin->phdr[i].p_flags & 1))? 1: 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ProcGetGeometry(ClientPtr client)\n{\n    xGetGeometryReply rep = { .type = X_Reply };\n    int status;\n    if ((status = GetGeometry(client, &rep)) != Success)\n        return status;\n    WriteReplyToClient(client, sizeof(xGetGeometryReply), &rep);\n    return Success;\n}", "target": 0}
{"code": "GF_EXPORT\nconst char *gf_isom_get_filename(GF_ISOFile *movie)\n{\n\tif (!movie) return NULL;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (movie->finalName && !movie->fileName) return movie->finalName;\n#endif\n\treturn movie->fileName;", "target": 0}
{"code": "int ext4_issue_zeroout(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk,\n\t\t       ext4_lblk_t len)\n{\n\tint ret;\n\tif (ext4_encrypted_inode(inode))\n\t\treturn fscrypt_zeroout_range(inode, lblk, pblk, len);\n\tret = sb_issue_zeroout(inode->i_sb, pblk, len, GFP_NOFS);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}", "target": 0}
{"code": "FilePath SavePackage::EnsureMimeExtension(const FilePath& name,\n    const std::string& contents_mime_type) {\n  FilePath::StringType ext = name.Extension().length() ?\n      name.Extension().substr(1) : name.Extension();\n  FilePath::StringType suggested_extension =\n      ExtensionForMimeType(contents_mime_type);\n  std::string mime_type;\n  if (!suggested_extension.empty() &&\n      !net::GetMimeTypeFromExtension(ext, &mime_type)) {\n    return FilePath(name.value() + FILE_PATH_LITERAL(\".\") +\n                    suggested_extension);\n  }\n  return name;\n}", "target": 0}
{"code": "char *__acpi_map_table(unsigned long phys_addr, unsigned long size)\n{\n\tif (!phys_addr || !size)\n\t\treturn NULL;\n\tif (phys_addr+size <= (end_pfn_map << PAGE_SHIFT) + PAGE_SIZE)\n\t\treturn __va(phys_addr);\n\treturn NULL;\n}", "target": 0}
{"code": "static ssize_t set_cmci_disabled(struct device *s,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t size)\n{\n\tu64 new;\n\tif (kstrtou64(buf, 0, &new) < 0)\n\t\treturn -EINVAL;\n\tmutex_lock(&mce_sysfs_mutex);\n\tif (mca_cfg.cmci_disabled ^ !!new) {\n\t\tif (new) {\n\t\t\ton_each_cpu(mce_disable_cmci, NULL, 1);\n\t\t\tmca_cfg.cmci_disabled = true;\n\t\t} else {\n\t\t\tmca_cfg.cmci_disabled = false;\n\t\t\ton_each_cpu(mce_enable_ce, NULL, 1);\n\t\t}\n\t}\n\tmutex_unlock(&mce_sysfs_mutex);\n\treturn size;\n}", "target": 0}
{"code": "void usage(const char *p)\n{\n  printf(\"Options:\\n\"\n         \"-J n  - set parallel job count (default 2)\\n\"\n         \"-v    - verbose\\n\"\n         \"-w    - use camera white balance\\n\"\n         \"-T    - output TIFF instead of PPM\\n\"\n         \"-a    - average image for white balance\\n\");\n  exit(1);\n}", "target": 0}
{"code": "    static void* _events_thread(void *arg) { \n      Display *const dpy = cimg::X11_attr().display;\n      XEvent event;\n      pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED,0);\n      pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,0);\n      if (!arg) for ( ; ; ) {\n        cimg_lock_display();\n        bool event_flag = XCheckTypedEvent(dpy,ClientMessage,&event);\n        if (!event_flag) event_flag = XCheckMaskEvent(dpy,\n                                                      ExposureMask | StructureNotifyMask | ButtonPressMask |\n                                                      KeyPressMask | PointerMotionMask | EnterWindowMask |\n                                                      LeaveWindowMask | ButtonReleaseMask | KeyReleaseMask,&event);\n        if (event_flag)\n          for (unsigned int i = 0; i<cimg::X11_attr().nb_wins; ++i)\n            if (!cimg::X11_attr().wins[i]->_is_closed && event.xany.window==cimg::X11_attr().wins[i]->_window)\n              cimg::X11_attr().wins[i]->_handle_events(&event);\n        cimg_unlock_display();\n        pthread_testcancel();\n        cimg::sleep(8);\n      }\n      return 0;", "target": 0}
{"code": "static void ahci_write_fis_pio(AHCIDevice *ad, uint16_t len)\n{\n    AHCIPortRegs *pr = &ad->port_regs;\n    uint8_t *pio_fis;\n    IDEState *s = &ad->port.ifs[0];\n    if (!ad->res_fis || !(pr->cmd & PORT_CMD_FIS_RX)) {\n        return;\n    }\n    pio_fis = &ad->res_fis[RES_FIS_PSFIS];\n    pio_fis[0] = SATA_FIS_TYPE_PIO_SETUP;\n    pio_fis[1] = (ad->hba->control_regs.irqstatus ? (1 << 6) : 0);\n    pio_fis[2] = s->status;\n    pio_fis[3] = s->error;\n    pio_fis[4] = s->sector;\n    pio_fis[5] = s->lcyl;\n    pio_fis[6] = s->hcyl;\n    pio_fis[7] = s->select;\n    pio_fis[8] = s->hob_sector;\n    pio_fis[9] = s->hob_lcyl;\n    pio_fis[10] = s->hob_hcyl;\n    pio_fis[11] = 0;\n    pio_fis[12] = s->nsector & 0xFF;\n    pio_fis[13] = (s->nsector >> 8) & 0xFF;\n    pio_fis[14] = 0;\n    pio_fis[15] = s->status;\n    pio_fis[16] = len & 255;\n    pio_fis[17] = len >> 8;\n    pio_fis[18] = 0;\n    pio_fis[19] = 0;\n    pr->tfdata = (ad->port.ifs[0].error << 8) |\n        ad->port.ifs[0].status;\n    if (pio_fis[2] & ERR_STAT) {\n        ahci_trigger_irq(ad->hba, ad, PORT_IRQ_TF_ERR);\n    }\n    ahci_trigger_irq(ad->hba, ad, PORT_IRQ_PIOS_FIS);\n}", "target": 0}
{"code": "SPICE_GNUC_VISIBLE int spice_server_set_port(SpiceServer *reds, int port)\n{\n    if (port < 0 || port > 0xffff) {\n        return -1;\n    }\n    reds->config->spice_port = port;\n    return 0;\n}", "target": 0}
{"code": "theme_adium_button_press_event (GtkWidget *widget, GdkEventButton *event)\n{\n\tif (event->button == 3) {\n\t\tgboolean developer_tools_enabled;\n\t\tg_object_get (G_OBJECT (webkit_web_view_get_settings (WEBKIT_WEB_VIEW (widget))),\n\t\t\t      \"enable-developer-extras\", &developer_tools_enabled, NULL);\n\t\tif (!developer_tools_enabled) {\n\t\t\tempathy_webkit_context_menu_for_event (\n\t\t\t\tWEBKIT_WEB_VIEW (widget), event,\n\t\t\t\tEMPATHY_WEBKIT_MENU_CLEAR);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn GTK_WIDGET_CLASS (empathy_theme_adium_parent_class)->button_press_event (widget, event);\n}", "target": 0}
{"code": "int __export rad_packet_add_str(struct rad_packet_t *pack, const char *vendor_name, const char *name, const char *val)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\tint len = strlen(val);\n\tif (pack->len + (vendor_name ? 8 : 2) + len >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\tif (!attr)\n\t\treturn -1;\n\tra = mempool_alloc(attr_pool);\n\tif (!ra) {\n\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\treturn -1;\n\t}\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = len;\n\tra->alloc = 1;\n\tra->val.string = _malloc(len + 1);\n\tif (!ra->val.string) {\n\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t_free(ra);\n\t\treturn -1;\n\t}\n\tmemcpy(ra->val.string, val, len);\n\tra->val.string[len] = 0;\n\tra->raw = ra->val.string;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + len;\n\treturn 0;\n}", "target": 0}
{"code": "static int find_large_solid_color_rect(VncState *vs, int x, int y,\n                                       int w, int h, int max_rows)\n{\n    int dx, dy, dw, dh;\n    int n = 0;\n    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n        if (dy - y >= max_rows) {\n            n += send_rect_simple(vs, x, y, w, max_rows, true);\n            y += max_rows;\n            h -= max_rows;\n        }\n        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, (y + h - dy));\n        for (dx = x; dx < x + w; dx += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n            uint32_t color_value;\n            int x_best, y_best, w_best, h_best;\n            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, (x + w - dx));\n            if (!check_solid_tile(vs, dx, dy, dw, dh, &color_value, false)) {\n                continue ;\n            }\n            find_best_solid_area(vs, dx, dy, w - (dx - x), h - (dy - y),\n                                 color_value, &w_best, &h_best);\n            if (w_best * h_best != w * h &&\n                w_best * h_best < VNC_TIGHT_MIN_SOLID_SUBRECT_SIZE) {\n                continue;\n            }\n            x_best = dx; y_best = dy;\n            extend_solid_area(vs, x, y, w, h, color_value,\n                              &x_best, &y_best, &w_best, &h_best);\n            if (y_best != y) {\n                n += send_rect_simple(vs, x, y, w, y_best-y, true);\n            }\n            if (x_best != x) {\n                n += tight_send_framebuffer_update(vs, x, y_best,\n                                                   x_best-x, h_best);\n            }\n            n += send_sub_rect_solid(vs, x_best, y_best, w_best, h_best);\n            if (x_best + w_best != x + w) {\n                n += tight_send_framebuffer_update(vs, x_best+w_best,\n                                                   y_best,\n                                                   w-(x_best-x)-w_best,\n                                                   h_best);\n            }\n            if (y_best + h_best != y + h) {\n                n += tight_send_framebuffer_update(vs, x, y_best+h_best,\n                                                   w, h-(y_best-y)-h_best);\n            }\n            return n;\n        }\n    }\n    return n + send_rect_simple(vs, x, y, w, h, true);\n}", "target": 0}
{"code": "cgiClearVariables(void)\n{\n  int\t\ti, j;\t\t\t\n  _cgi_var_t\t*v;\t\t\t\n  fputs(\"DEBUG: cgiClearVariables called.\\n\", stderr);\n  for (v = form_vars, i = form_count; i > 0; v ++, i --)\n  {\n    _cupsStrFree(v->name);\n    for (j = 0; j < v->nvalues; j ++)\n      if (v->values[j])\n        _cupsStrFree(v->values[j]);\n  }\n  form_count = 0;\n  cgi_unlink_file();\n}", "target": 0}
{"code": "static const char *set_limit_req_fields(cmd_parms *cmd, void *dummy,\n                                        const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    int lim;\n    if (err != NULL) {\n        return err;\n    }\n    lim = atoi(arg);\n    if (lim < 0) {\n        return apr_pstrcat(cmd->temp_pool, \"LimitRequestFields \\\"\", arg,\n                           \"\\\" must be a non-negative integer (0 = no limit)\",\n                           NULL);\n    }\n    cmd->server->limit_req_fields = lim;\n    return NULL;\n}", "target": 0}
{"code": "    void CrwMap::decodeBasic(const CiffComponent& ciffComponent,\n                             const CrwMapping*    pCrwMapping,\n                                   Image&         image,\n                                   ByteOrder      byteOrder)\n    {\n        assert(pCrwMapping != 0);\n        ExifKey key(pCrwMapping->tag_, Internal::groupName(pCrwMapping->ifdId_));\n        Value::UniquePtr value;\n        if (ciffComponent.typeId() != directory) {\n            value = Value::create(ciffComponent.typeId());\n            uint32_t size = 0;\n            if (pCrwMapping->size_ != 0) {\n                size = pCrwMapping->size_;\n            }\n            else if (ciffComponent.typeId() == asciiString) {\n                uint32_t i = 0;\n                for (;    i < ciffComponent.size()\n                       && ciffComponent.pData()[i] != '\\0'; ++i) {\n                }\n                size = ++i;\n            }\n            else {\n                size = ciffComponent.size();\n            }\n            value->read(ciffComponent.pData(), size, byteOrder);\n        }\n        image.exifData().add(key, value.get());\n    } ", "target": 0}
{"code": "virgl_cmd_context_destroy(VuGpu *g,\n                          struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_ctx_destroy cd;\n    VUGPU_FILL_CMD(cd);\n    virgl_renderer_context_destroy(cd.hdr.ctx_id);\n}", "target": 0}
{"code": "void HTMLFormControlElement::attach(const AttachContext& context)\n{\n    HTMLElement::attach(context);\n    if (!renderer())\n        return;\n    renderer()->updateFromElement();\n    if (shouldAutofocusOnAttach(this)) {\n        setAutofocused();\n        document().setAutofocusElement(this);\n    }\n}", "target": 0}
{"code": "GF_Box *schm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SchemeTypeBox, GF_ISOM_BOX_TYPE_SCHM);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static inline int nla_padlen(int payload)\n{\n\treturn nla_total_size(payload) - nla_attr_size(payload);\n}", "target": 0}
{"code": "blink::WebFrame* PrepareFrameAndViewForPrint::createChildFrame(\n    blink::WebLocalFrame* parent,\n    blink::WebTreeScopeType scope,\n    const blink::WebString& name,\n    blink::WebSandboxFlags sandboxFlags) {\n  blink::WebFrame* frame = blink::WebLocalFrame::create(scope, this);\n  parent->appendChild(frame);\n  return frame;\n}", "target": 0}
{"code": "void __qdisc_run(struct net_device *dev)\n{\n\tunsigned long start_time = jiffies;\n\twhile (qdisc_restart(dev)) {\n\t\tif (netif_queue_stopped(dev))\n\t\t\tbreak;\n\t\tif (need_resched() || jiffies != start_time) {\n\t\t\tnetif_schedule(dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\tclear_bit(__LINK_STATE_QDISC_RUNNING, &dev->state);\n}", "target": 0}
{"code": "libarchive_read_next_header (EvArchive *archive,\n\t\t\t     GError   **error)\n{\n\twhile (1) {\n\t\tint r;\n\t\tr = archive_read_next_header (archive->libar, &archive->libar_entry);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\tg_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t\t\t\t     \"Error reading archive: %s\", archive_error_string (archive->libar));\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (archive_entry_filetype (archive->libar_entry) != AE_IFREG) {\n\t\t\tg_debug (\"Skipping '%s' as it's not a regular file\",\n\t\t\t\t archive_entry_pathname (archive->libar_entry));\n\t\t\tcontinue;\n\t\t}\n\t\tg_debug (\"At header for file '%s'\", archive_entry_pathname (archive->libar_entry));\n\t\tbreak;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "void free_pages(unsigned long addr, unsigned int order)\n{\n\tif (addr != 0) {\n\t\tVM_BUG_ON(!virt_addr_valid((void *)addr));\n\t\t__free_pages(virt_to_page((void *)addr), order);\n\t}\n}", "target": 0}
{"code": "acl_fetch_url_ip(struct proxy *px, struct session *l4, void *l7, int dir,\n\t\t struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct http_txn *txn = l7;\n\tif (!txn)\n\t\treturn 0;\n\tif (txn->req.msg_state < HTTP_MSG_BODY)\n\t\treturn 0;\n\tif (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)\n\t\treturn 0;\n\turl2sa(txn->req.sol + txn->req.sl.rq.u, txn->req.sl.rq.u_l, &l4->srv_addr);\n\ttest->ptr = (void *)&((struct sockaddr_in *)&l4->srv_addr)->sin_addr;\n\ttest->i = AF_INET;\n\tif (px->options & PR_O_HTTP_PROXY)\n\t\tl4->flags |= SN_ADDR_SET;\n\ttest->flags = ACL_TEST_F_READ_ONLY;\n\treturn 1;\n}", "target": 0}
{"code": "static int irda_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = -EOPNOTSUPP;\n\tIRDA_DEBUG(2, \"%s()\\n\", __func__);\n\tlock_sock(sk);\n\tif ((sk->sk_type != SOCK_STREAM) && (sk->sk_type != SOCK_SEQPACKET) &&\n\t    (sk->sk_type != SOCK_DGRAM))\n\t\tgoto out;\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\terr = 0;\n\t}\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static bool kvm_get_time_and_clockread(s64 *kernel_ns, cycle_t *cycle_now)\n{\n\tstruct timespec ts;\n\tif (pvclock_gtod_data.clock.vclock_mode != VCLOCK_TSC)\n\t\treturn false;\n\tif (do_monotonic(&ts, cycle_now) != VCLOCK_TSC)\n\t\treturn false;\n\tmonotonic_to_bootbased(&ts);\n\t*kernel_ns = timespec_to_ns(&ts);\n\treturn true;\n}", "target": 0}
{"code": "static int hid_debug_events_open(struct inode *inode, struct file *file)\n{\n\tint err = 0;\n\tstruct hid_debug_list *list;\n\tunsigned long flags;\n\tif (!(list = kzalloc(sizeof(struct hid_debug_list), GFP_KERNEL))) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (!(list->hid_debug_buf = kzalloc(sizeof(char) * HID_DEBUG_BUFSIZE, GFP_KERNEL))) {\n\t\terr = -ENOMEM;\n\t\tkfree(list);\n\t\tgoto out;\n\t}\n\tlist->hdev = (struct hid_device *) inode->i_private;\n\tfile->private_data = list;\n\tmutex_init(&list->read_mutex);\n\tspin_lock_irqsave(&list->hdev->debug_list_lock, flags);\n\tlist_add_tail(&list->node, &list->hdev->debug_list);\n\tspin_unlock_irqrestore(&list->hdev->debug_list_lock, flags);\nout:\n\treturn err;\n}", "target": 0}
{"code": "static void *gp_worker_main(void *pvt)\n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n    while (!t->pool->shutdown) {\n        gp_debug_set_conn_id(0);\n        pthread_mutex_lock(&t->cond_mutex);\n        while (t->query == NULL) {\n            pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n            if (t->pool->shutdown) {\n                pthread_mutex_unlock(&t->cond_mutex);\n                pthread_exit(NULL);\n            }\n        }\n        q = t->query;\n        t->query = NULL;\n        pthread_mutex_unlock(&t->cond_mutex);\n        gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n        GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        gp_handle_query(t->pool, q);\n        GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        pthread_mutex_lock(&t->pool->lock);\n        q->next = t->pool->reply_list;\n        t->pool->reply_list = q;\n        if (!t->pool->shutdown) {\n            LIST_DEL(t->pool->busy_list, t);\n            LIST_ADD(t->pool->free_list, t);\n        }\n        pthread_mutex_unlock(&t->pool->lock);\n        ret = write(t->pool->sig_pipe[1], &dummy, 1);\n        if (ret == -1) {\n            GPERROR(\"Failed to signal dispatcher!\");\n        }\n    }\n    pthread_exit(NULL);\n}", "target": 0}
{"code": "static ssize_t write_null(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn count;\n}", "target": 0}
{"code": "static const char *set_expect_strict(cmd_parms *cmd, void *dummy, int arg)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    if (arg) {\n        conf->http_expect_strict = AP_HTTP_EXPECT_STRICT_ENABLE;\n    } else {\n        conf->http_expect_strict = AP_HTTP_EXPECT_STRICT_DISABLE;\n    }\n    return NULL;\n}", "target": 0}
{"code": "isdn_ppp_write(int min, struct file *file, const char __user *buf, int count)\n{\n\tisdn_net_local *lp;\n\tstruct ippp_struct *is;\n\tint proto;\n\tunsigned char protobuf[4];\n\tis = file->private_data;\n\tif (!(is->state & IPPP_CONNECT))\n\t\treturn 0;\n\tlp = is->lp;\n\tif (!lp)\n\t\tprintk(KERN_DEBUG \"isdn_ppp_write: lp == NULL\\n\");\n\telse {\n\t\tif (copy_from_user(protobuf, buf, 4))\n\t\t\treturn -EFAULT;\n\t\tproto = PPP_PROTOCOL(protobuf);\n\t\tif (proto != PPP_LCP)\n\t\t\tlp->huptimer = 0;\n\t\tif (lp->isdn_device < 0 || lp->isdn_channel < 0)\n\t\t\treturn 0;\n\t\tif ((dev->drv[lp->isdn_device]->flags & DRV_FLAG_RUNNING) &&\n\t\t    lp->dialstate == 0 &&\n\t\t    (lp->flags & ISDN_NET_CONNECTED)) {\n\t\t\tunsigned short hl;\n\t\t\tstruct sk_buff *skb;\n\t\t\thl = dev->drv[lp->isdn_device]->interface->hl_hdrlen;\n\t\t\tskb = alloc_skb(hl + count, GFP_ATOMIC);\n\t\t\tif (!skb) {\n\t\t\t\tprintk(KERN_WARNING \"isdn_ppp_write: out of memory!\\n\");\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tskb_reserve(skb, hl);\n\t\t\tif (copy_from_user(skb_put(skb, count), buf, count))\n\t\t\t{\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tif (is->debug & 0x40) {\n\t\t\t\tprintk(KERN_DEBUG \"ppp xmit: len %d\\n\", (int) skb->len);\n\t\t\t\tisdn_ppp_frame_log(\"xmit\", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\n\t\t\t}\n\t\t\tisdn_ppp_send_ccp(lp->netdev, lp, skb); \n\t\t\tisdn_net_write_super(lp, skb);\n\t\t}\n\t}\n\treturn count;\n}", "target": 0}
{"code": "void Document::SetURL(const KURL& url) {\n  const KURL& new_url = url.IsEmpty() ? BlankURL() : url;\n  if (new_url == url_)\n    return;\n  url_ = new_url;\n  access_entry_from_url_ = nullptr;\n  UpdateBaseURL();\n  GetContextFeatures().UrlDidChange(this);\n  if (ukm_recorder_)\n    ukm_recorder_->UpdateSourceURL(ukm_source_id_, url_);\n}", "target": 0}
{"code": "static bool vmx_xsaves_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_XSAVES;\n}", "target": 0}
{"code": "CURLU *curl_url_dup(CURLU *in)\n{\n  struct Curl_URL *u = calloc(sizeof(struct Curl_URL), 1);\n  if(u) {\n    DUP(u, in, scheme);\n    DUP(u, in, user);\n    DUP(u, in, password);\n    DUP(u, in, options);\n    DUP(u, in, host);\n    DUP(u, in, port);\n    DUP(u, in, path);\n    DUP(u, in, query);\n    DUP(u, in, fragment);\n    u->portnum = in->portnum;\n  }\n  return u;\n  fail:\n  curl_url_cleanup(u);\n  return NULL;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CantExplodeOrForSort) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1 << \"c\" << 1));\n    addIndex(BSON(\"d\" << 1 << \"c\" << 1));\n    runQuerySortProj(fromjson(\"{$or: [{a: {$in: [1, 2]}}, {d: 3}]}\"), BSON(\"c\" << 1), BSONObj());\n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {c: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {dir: 1}}}}}}\");\n    assertSolutionExists(\n        \"{sort: {pattern: {c: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{fetch: {filter: null, node: {or: {nodes: [\"\n        \"{ixscan: {pattern: {a: 1, b: 1, c: 1}}},\"\n        \"{ixscan: {pattern: {d: 1, c: 1}}}]}}}}}}}}\");\n}", "target": 0}
{"code": "    Nikon2MnHeader::Nikon2MnHeader() : start_(0)\n    {\n        read(signature_, sizeOfSignature(), invalidByteOrder);\n    }", "target": 0}
{"code": "void PDFiumEngine::LoadDocument() {\n  if (!doc_ && !doc_loader_.IsDocumentComplete() &&\n      !FPDFAvail_IsDocAvail(fpdf_availability_, &download_hints_)) {\n    return;\n  }\n  if (getting_password_)\n    return;\n  ScopedUnsupportedFeature scoped_unsupported_feature(this);\n  bool needs_password = false;\n  if (TryLoadingDoc(std::string(), &needs_password)) {\n    ContinueLoadingDocument(std::string());\n    return;\n  }\n  if (needs_password)\n    GetPasswordAndLoad();\n  else\n    client_->DocumentLoadFailed();\n}", "target": 0}
{"code": "ZEND_API int ZEND_FASTCALL zend_binary_zval_strcmp(zval *s1, zval *s2) \n{\n\treturn zend_binary_strcmp(Z_STRVAL_P(s1), Z_STRLEN_P(s1), Z_STRVAL_P(s2), Z_STRLEN_P(s2));\n}", "target": 0}
{"code": "static int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qual;\n\tif (kvm_event_needs_reinjection(vcpu))\n\t\treturn -EBUSY;\n\tif (vcpu->arch.exception.pending &&\n\t\tnested_vmx_check_exception(vcpu, &exit_qual)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_inject_exception_vmexit(vcpu, exit_qual);\n\t\tvcpu->arch.exception.pending = false;\n\t\treturn 0;\n\t}\n\tif (nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&\n\t    vmx->nested.preemption_timer_expired) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);\n\t\treturn 0;\n\t}\n\tif (vcpu->arch.nmi_pending && nested_exit_on_nmi(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,\n\t\t\t\t  NMI_VECTOR | INTR_TYPE_NMI_INTR |\n\t\t\t\t  INTR_INFO_VALID_MASK, 0);\n\t\tvcpu->arch.nmi_pending = 0;\n\t\tvmx_set_nmi_mask(vcpu, true);\n\t\treturn 0;\n\t}\n\tif ((kvm_cpu_has_interrupt(vcpu) || external_intr) &&\n\t    nested_exit_on_intr(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXTERNAL_INTERRUPT, 0, 0);\n\t\treturn 0;\n\t}\n\tvmx_complete_nested_posted_interrupt(vcpu);\n\treturn 0;\n}", "target": 0}
{"code": "static OFF_T parse_size_arg(char **size_arg, char def_suf)\n{\n\tint reps, mult, make_compatible = 0;\n\tconst char *arg;\n\tOFF_T size = 1;\n\tfor (arg = *size_arg; isDigit(arg); arg++) {}\n\tif (*arg == '.')\n\t\tfor (arg++; isDigit(arg); arg++) {}\n\tswitch (*arg && *arg != '+' && *arg != '-' ? *arg++ : def_suf) {\n\tcase 'b': case 'B':\n\t\treps = 0;\n\t\tbreak;\n\tcase 'k': case 'K':\n\t\treps = 1;\n\t\tbreak;\n\tcase 'm': case 'M':\n\t\treps = 2;\n\t\tbreak;\n\tcase 'g': case 'G':\n\t\treps = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\tif (*arg == 'b' || *arg == 'B')\n\t\tmult = 1000, make_compatible = 1, arg++;\n\telse if (!*arg || *arg == '+' || *arg == '-')\n\t\tmult = 1024;\n\telse if (strncasecmp(arg, \"ib\", 2) == 0)\n\t\tmult = 1024, arg += 2;\n\telse\n\t\treturn -1;\n\twhile (reps--)\n\t\tsize *= mult;\n\tsize *= atof(*size_arg);\n\tif ((*arg == '+' || *arg == '-') && arg[1] == '1')\n\t\tsize += atoi(arg), make_compatible = 1, arg += 2;\n\tif (*arg)\n\t\treturn -1;\n\tif (size > 0 && make_compatible && def_suf == 'b') {\n\t\tchar buf[128], *s = buf + sizeof buf - 1;\n\t\tOFF_T num = size;\n\t\t*s = '\\0';\n\t\twhile (num) {\n\t\t\t*--s = (char)(num % 10) + '0';\n\t\t\tnum /= 10;\n\t\t}\n\t\tif (!(*size_arg = strdup(s)))\n\t\t\tout_of_memory(\"parse_size_arg\");\n\t}\n\treturn size;\n}", "target": 0}
{"code": "void PPB_URLLoader_Impl::SetDefersLoading(bool defers_loading) {\n  if (loader_.get()) {\n    loader_->setDefersLoading(defers_loading);\n    is_asynchronous_load_suspended_ = defers_loading;\n  }\n}", "target": 0}
{"code": "static int nl80211_disconnect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 reason;\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treason = WLAN_REASON_DEAUTH_LEAVING;\n\telse\n\t\treason = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason == 0)\n\t\treturn -EINVAL;\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\treturn cfg80211_disconnect(rdev, dev, reason, true);\n}", "target": 0}
{"code": "static int rm_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n    AVStream *st = NULL; \n    int i, len, res, seq = 1;\n    int64_t timestamp, pos;\n    int flags;\n    for (;;) {\n        if (rm->audio_pkt_cnt) {\n            st = s->streams[rm->audio_stream_num];\n            res = ff_rm_retrieve_cache(s, s->pb, st, st->priv_data, pkt);\n            if(res < 0)\n                return res;\n            flags = 0;\n        } else {\n            if (rm->old_format) {\n                RMStream *ast;\n                st = s->streams[0];\n                ast = st->priv_data;\n                timestamp = AV_NOPTS_VALUE;\n                len = !ast->audio_framesize ? RAW_PACKET_SIZE :\n                    ast->coded_framesize * ast->sub_packet_h / 2;\n                flags = (seq++ == 1) ? 2 : 0;\n                pos = avio_tell(s->pb);\n            } else {\n                len = rm_sync(s, &timestamp, &flags, &i, &pos);\n                if (len > 0)\n                    st = s->streams[i];\n            }\n            if (avio_feof(s->pb))\n                return AVERROR_EOF;\n            if (len <= 0)\n                return AVERROR(EIO);\n            res = ff_rm_parse_packet (s, s->pb, st, st->priv_data, len, pkt,\n                                      &seq, flags, timestamp);\n            if (res < -1)\n                return res;\n            if((flags&2) && (seq&0x7F) == 1)\n                av_add_index_entry(st, pos, timestamp, 0, 0, AVINDEX_KEYFRAME);\n            if (res)\n                continue;\n        }\n        if(  (st->discard >= AVDISCARD_NONKEY && !(flags&2))\n           || st->discard >= AVDISCARD_ALL){\n            av_packet_unref(pkt);\n        } else\n            break;\n    }\n    return 0;\n}", "target": 0}
{"code": "asmlinkage long compat_sys_fstatfs(unsigned int fd, struct compat_statfs __user *buf)\n{\n\tstruct file * file;\n\tstruct kstatfs tmp;\n\tint error;\n\terror = -EBADF;\n\tfile = fget(fd);\n\tif (!file)\n\t\tgoto out;\n\terror = vfs_statfs(file->f_path.dentry, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs(buf, &tmp);\n\tfput(file);\nout:\n\treturn error;\n}", "target": 0}
{"code": "void OmniboxViewWin::OnPossibleDrag(const CPoint& point) {\n  if (possible_drag_)\n    return;\n  click_point_[kLeft] = point;\n  initiated_drag_ = false;\n  CHARRANGE selection;\n  GetSel(selection);\n  if (selection.cpMin != selection.cpMax) {\n    const POINT min_sel_location(PosFromChar(selection.cpMin));\n    const POINT max_sel_location(PosFromChar(selection.cpMax));\n    possible_drag_ = (point.x >= min_sel_location.x) &&\n                     (point.x < max_sel_location.x);\n  }\n}", "target": 0}
{"code": "bool lua_datum::is_function() const\n{\n    LUA_CHECK_TYPE(lua_isfunction);\n}", "target": 0}
{"code": "static int fake_panic_set(void *data, u64 val)\n{\n\tmce_reset();\n\tfake_panic = val;\n\treturn 0;\n}", "target": 0}
{"code": "static jboolean Region_isRect(JNIEnv* env, jobject region) {\n bool result = GetSkRegion(env, region)->isRect();\n return boolTojboolean(result);\n}", "target": 0}
{"code": "static int alloc_apic_access_page(struct kvm *kvm)\n{\n\tstruct page *page;\n\tint r = 0;\n\tmutex_lock(&kvm->slots_lock);\n\tif (kvm->arch.apic_access_page_done)\n\t\tgoto out;\n\tr = __x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t    APIC_DEFAULT_PHYS_BASE, PAGE_SIZE);\n\tif (r)\n\t\tgoto out;\n\tpage = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\tput_page(page);\n\tkvm->arch.apic_access_page_done = true;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}", "target": 0}
{"code": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\tif (!res)\n\t\tgoto out;\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n}", "target": 0}
{"code": "int create_history_entry(krb5_context context,\n                         krb5_keyblock *hist_key, int n_key_data,\n                         krb5_key_data *key_data, osa_pw_hist_ent *hist)\n{\n    int i, ret;\n    krb5_keyblock key;\n    krb5_keysalt salt;\n    hist->key_data = (krb5_key_data*)malloc(n_key_data*sizeof(krb5_key_data));\n    if (hist->key_data == NULL)\n        return ENOMEM;\n    memset(hist->key_data, 0, n_key_data*sizeof(krb5_key_data));\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &key,\n                                        &salt);\n        if (ret)\n            return ret;\n        ret = krb5_dbe_encrypt_key_data(context, hist_key, &key, &salt,\n                                        key_data[i].key_data_kvno,\n                                        &hist->key_data[i]);\n        if (ret)\n            return ret;\n        krb5_free_keyblock_contents(context, &key);\n    }\n    hist->n_key_data = n_key_data;\n    return 0;\n}", "target": 0}
{"code": "static struct dmar_atsr_unit *dmar_find_atsr(struct acpi_dmar_atsr *atsr)\n{\n\tstruct dmar_atsr_unit *atsru;\n\tstruct acpi_dmar_atsr *tmp;\n\tlist_for_each_entry_rcu(atsru, &dmar_atsr_units, list) {\n\t\ttmp = (struct acpi_dmar_atsr *)atsru->hdr;\n\t\tif (atsr->segment != tmp->segment)\n\t\t\tcontinue;\n\t\tif (atsr->header.length != tmp->header.length)\n\t\t\tcontinue;\n\t\tif (memcmp(atsr, tmp, atsr->header.length) == 0)\n\t\t\treturn atsru;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void VideoRendererBase::AttemptFlush_Locked() {\n  lock_.AssertAcquired();\n  DCHECK_EQ(kFlushing, state_);\n  ready_frames_.clear();\n  if (!pending_paint_ && !pending_read_) {\n    state_ = kFlushed;\n    current_frame_ = NULL;\n    base::ResetAndReturn(&flush_cb_).Run();\n  }\n}", "target": 0}
{"code": "static void destroy_surface(struct swaylock_surface *surface) {\n\twl_list_remove(&surface->link);\n\tif (surface->layer_surface != NULL) {\n\t\tzwlr_layer_surface_v1_destroy(surface->layer_surface);\n\t}\n\tif (surface->ext_session_lock_surface_v1 != NULL) {\n\t\text_session_lock_surface_v1_destroy(surface->ext_session_lock_surface_v1);\n\t}\n\tif (surface->surface != NULL) {\n\t\twl_surface_destroy(surface->surface);\n\t}\n\tdestroy_buffer(&surface->buffers[0]);\n\tdestroy_buffer(&surface->buffers[1]);\n\tdestroy_buffer(&surface->indicator_buffers[0]);\n\tdestroy_buffer(&surface->indicator_buffers[1]);\n\twl_output_destroy(surface->output);\n\tfree(surface);\n}", "target": 0}
{"code": "static inline void ConvertXYZToDisplayP3(const double X,const double Y,\n  const double Z,double *red,double *green,double *blue)\n{\n  double\n    b,\n    g,\n    r;\n  assert(red != (double *) NULL);\n  assert(green != (double *) NULL);\n  assert(blue != (double *) NULL);\n  r=2.49349691194142500*X-0.93138361791912390*Y-0.402710784450716840*Z;\n  g=(-0.82948896956157470)*X+1.76266406031834630*Y+0.023624685841943577*Z;\n  b=0.03584583024378447*X-0.07617238926804182*Y+0.956884524007687200*Z;\n  *red=EncodePixelGamma(QuantumRange*r);\n  *green=EncodePixelGamma(QuantumRange*g);\n  *blue=EncodePixelGamma(QuantumRange*b);\n}", "target": 0}
{"code": "static void perf_event_enable_on_exec(struct perf_event_context *ctx)\n{\n\tstruct perf_event *event;\n\tunsigned long flags;\n\tint enabled = 0;\n\tint ret;\n\tlocal_irq_save(flags);\n\tif (!ctx || !ctx->nr_events)\n\t\tgoto out;\n\tperf_cgroup_sched_out(current, NULL);\n\traw_spin_lock(&ctx->lock);\n\ttask_ctx_sched_out(ctx);\n\tlist_for_each_entry(event, &ctx->event_list, event_entry) {\n\t\tret = event_enable_on_exec(event, ctx);\n\t\tif (ret)\n\t\t\tenabled = 1;\n\t}\n\tif (enabled)\n\t\tunclone_ctx(ctx);\n\traw_spin_unlock(&ctx->lock);\n\tperf_event_context_sched_in(ctx, ctx->task);\nout:\n\tlocal_irq_restore(flags);\n}", "target": 0}
{"code": "njs_string_prototype_to_string(njs_vm_t *vm, njs_value_t *args,\n    njs_uint_t nargs, njs_index_t unused)\n{\n    njs_int_t          ret;\n    njs_str_t          enc, str;\n    njs_value_t        value;\n    njs_string_prop_t  string;\n    ret = njs_string_prototype_value_of(vm, args, nargs, unused);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    if (nargs < 2) {\n        return NJS_OK;\n    }\n    if (njs_slow_path(!njs_is_string(&args[1]))) {\n        njs_type_error(vm, \"encoding must be a string\");\n        return NJS_ERROR;\n    }\n    value = vm->retval;\n    (void) njs_string_prop(&string, &value);\n    njs_string_get(&args[1], &enc);\n    str.length = string.size;\n    str.start = string.start;\n    if (enc.length == 3 && memcmp(enc.start, \"hex\", 3) == 0) {\n        return njs_string_hex(vm, &vm->retval, &str);\n    } else if (enc.length == 6 && memcmp(enc.start, \"base64\", 6) == 0) {\n        return njs_string_base64(vm, &vm->retval, &str);\n    } else if (enc.length == 9 && memcmp(enc.start, \"base64url\", 9) == 0) {\n        return njs_string_base64url(vm, &vm->retval, &str);\n    }\n    njs_type_error(vm, \"Unknown encoding: \\\"%V\\\"\", &enc);\n    return NJS_ERROR;\n}", "target": 0}
{"code": "static int create_srq(PVRDMADev *dev, union pvrdma_cmd_req *req,\n                      union pvrdma_cmd_resp *rsp)\n{\n    struct pvrdma_cmd_create_srq *cmd = &req->create_srq;\n    struct pvrdma_cmd_create_srq_resp *resp = &rsp->create_srq_resp;\n    PvrdmaRing *ring = NULL;\n    int rc;\n    memset(resp, 0, sizeof(*resp));\n    rc = create_srq_ring(PCI_DEVICE(dev), &ring, cmd->pdir_dma,\n                         cmd->attrs.max_wr, cmd->attrs.max_sge,\n                         cmd->nchunks);\n    if (rc) {\n        return rc;\n    }\n    rc = rdma_rm_alloc_srq(&dev->rdma_dev_res, cmd->pd_handle,\n                           cmd->attrs.max_wr, cmd->attrs.max_sge,\n                           cmd->attrs.srq_limit, &resp->srqn, ring);\n    if (rc) {\n        destroy_srq_ring(ring);\n        return rc;\n    }\n    return 0;\n}", "target": 0}
{"code": "static __always_inline void slab_unlock(struct page *page)\n{\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}", "target": 0}
{"code": "    ThreadId thread_id() const { return thread_id_; }", "target": 0}
{"code": "static void scrub_parity_put(struct scrub_parity *sparity)\n{\n\tif (!refcount_dec_and_test(&sparity->refs))\n\t\treturn;\n\tscrub_parity_check_and_repair(sparity);\n}", "target": 0}
{"code": "void free_pages_exact(void *virt, size_t size)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\twhile (addr < end) {\n\t\tfree_page(addr);\n\t\taddr += PAGE_SIZE;\n\t}\n}", "target": 0}
{"code": "void test_refs_revparse__parses_at_head(void)\n{\n\ttest_id(\"HEAD\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n}", "target": 0}
{"code": "status_icon_popup_menu_cb (GtkStatusIcon *status_icon, guint button, guint32 timestamp, gpointer data)\n{\n        GsdXrandrManager *manager = GSD_XRANDR_MANAGER (data);\n        status_icon_popup_menu (manager, button, timestamp);\n}", "target": 0}
{"code": "static void kvm_init_msr_list(void)\n{\n\tu32 dummy[2];\n\tunsigned i, j;\n\tfor (i = j = KVM_SAVE_MSRS_BEGIN; i < ARRAY_SIZE(msrs_to_save); i++) {\n\t\tif (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\t\tswitch (msrs_to_save[i]) {\n\t\tcase MSR_IA32_BNDCFGS:\n\t\t\tif (!kvm_x86_ops->mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (j < i)\n\t\t\tmsrs_to_save[j] = msrs_to_save[i];\n\t\tj++;\n\t}\n\tnum_msrs_to_save = j;\n}", "target": 0}
{"code": "PERL_STATIC_INLINE SV*\nS_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp) {\n    return _add_range_to_invlist(invlist, cp, cp);", "target": 0}
{"code": "void PrepareFrameAndViewForPrint::FinishPrinting() {\n  if (!finished_) {\n    finished_ = true;\n    frame_->printEnd();\n    web_view_->resize(prev_view_size_);\n    if (WebFrame* web_frame = web_view_->mainFrame())\n      web_frame->setScrollOffset(prev_scroll_offset_);\n  }\n}", "target": 0}
{"code": "DEFINE_TEST(test_read_format_zip_bzip2_multi)\n{\n\tconst char *refname = \"test_read_format_zip_bzip2_multi.zipx\";\n\tstruct archive *a;\n\tstruct archive_entry *ae;\n\textract_reference_file(refname);\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n\tassertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));\n\tassertEqualString(\"smartd.conf\", archive_entry_pathname(ae));\n\tassertEqualIntA(a, 0, extract_one(a, ae, 0x8DD7379E));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n\tassertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));\n\tassertEqualString(\"ts.conf\", archive_entry_pathname(ae));\n\tassertEqualIntA(a, 0, extract_one(a, ae, 0x7AE59B31));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n\tassertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));\n\tassertEqualString(\"vimrc\", archive_entry_pathname(ae));\n\tassertEqualIntA(a, 0, extract_one(a, ae, 0xBA8E3BAA));\n\tassertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));\n}", "target": 0}
{"code": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}", "target": 0}
{"code": "Eina_Bool ewk_view_pre_render_region(Evas_Object* ewkView, Evas_Coord x, Evas_Coord y, Evas_Coord width, Evas_Coord height, float zoom)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api->pre_render_region, false);\n    float cur_zoom;\n    Evas_Coord contentsWidth, contentsHeight;\n    if (priv->animatedZoom.animator)\n        return false;\n    cur_zoom = ewk_frame_page_zoom_get(smartData->main_frame);\n    if (cur_zoom < 0.00001)\n        return false;\n    if (!ewk_frame_contents_size_get(smartData->main_frame, &contentsWidth, &contentsHeight))\n        return false;\n    contentsWidth *= zoom / cur_zoom;\n    contentsHeight *= zoom / cur_zoom;\n    DBG(\"region %d,%d+%dx%d @ %f contents=%dx%d\", x, y, width, height, zoom, contentsWidth, contentsHeight);\n    if (x + width > contentsWidth)\n        width = contentsWidth - x;\n    if (y + height > contentsHeight)\n        height = contentsHeight - y;\n    if (x < 0) {\n        width += x;\n        x = 0;\n    }\n    if (y < 0) {\n        height += y;\n        y = 0;\n    }\n    return smartData->api->pre_render_region(smartData, x, y, width, height, zoom);\n}", "target": 0}
{"code": "GF_Err dvvC_box_size(GF_Box *s)\n{\n\treturn dvcC_box_size(s);\n}", "target": 0}
{"code": "unsigned lodepng_deflate(unsigned char** out, size_t* outsize,\n                         const unsigned char* in, size_t insize,\n                         const LodePNGCompressSettings* settings)\n{\n  unsigned error;\n  ucvector v;\n  ucvector_init_buffer(&v, *out, *outsize);\n  error = lodepng_deflatev(&v, in, insize, settings);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}", "target": 0}
{"code": "static int change_gro_flush_timeout(struct net_device *dev, unsigned long val)\n{\n\tdev->gro_flush_timeout = val;\n\treturn 0;", "target": 0}
{"code": "check_PUSH_VLAN(const struct ofpact_push_vlan *a OVS_UNUSED,\n                struct ofpact_check_params *cp)\n{\n    struct flow *flow = &cp->match->flow;\n    if (flow->vlans[FLOW_MAX_VLAN_HEADERS - 1].tci & htons(VLAN_CFI)) {\n        return OFPERR_OFPBAC_BAD_TAG;\n    }\n    flow_push_vlan_uninit(flow, NULL);\n    flow->vlans[0].tci |= htons(VLAN_CFI);\n    return 0;\n}", "target": 0}
{"code": "void* JSArray::subclassData() const\n{\n    return m_storage->subclassData;\n}", "target": 0}
{"code": "do_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl, u32 *bmval)\n{\n\t__be32 status;\n\tstatus = nfsd4_set_nfs4_acl(rqstp, fhp, acl);\n\tif (status)\n\t\tbmval[0] &= ~FATTR4_WORD0_ACL;\n}", "target": 0}
{"code": "fmt_job_stats(char *buf, size_t size, job j)\n{\n    usec t;\n    uint64_t time_left;\n    t = now_usec();\n    if (j->state == JOB_STATE_RESERVED || j->state == JOB_STATE_DELAYED) {\n        time_left = (j->deadline_at - t) / 1000000;\n    } else {\n        time_left = 0;\n    }\n    return snprintf(buf, size, STATS_JOB_FMT,\n            j->id,\n            j->tube->name,\n            job_state(j),\n            j->pri,\n            (t - j->created_at) / 1000000,\n            j->delay / 1000000,\n            j->ttr / 1000000,\n            time_left,\n            j->reserve_ct,\n            j->timeout_ct,\n            j->release_ct,\n            j->bury_ct,\n            j->kick_ct);\n}", "target": 0}
{"code": "static void remove_option_value(gpointer data)\n{\n\tGList *option_value = data;\n\tg_list_foreach(option_value, remove_value, NULL);\n\tg_list_free(option_value);\n}", "target": 0}
{"code": "Variant HHVM_FUNCTION(each,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::each,\n    s___each,\n    Variant::NullInit()\n  );\n}", "target": 0}
{"code": "GF_EXPORT\nBool gf_isom_is_single_av(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_a, nb_v, nb_auxv, nb_pict, nb_scene, nb_od, nb_text;\n\tnb_auxv = nb_pict = nb_a = nb_v = nb_any = nb_scene = nb_od = nb_text = 0;\n\tif (!file->moov) return GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_scene++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_od++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tnb_text++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tnb_a++;\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_auxv++;\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_pict++;\n            break;\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n\t\t\telse nb_v++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnb_any++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nb_any) return GF_FALSE;\n\tif ((nb_scene<=1) && (nb_od<=1) && (nb_a<=1) && (nb_v+nb_pict+nb_auxv<=1) && (nb_text<=1) ) return GF_TRUE;\n\treturn GF_FALSE;", "target": 0}
{"code": "void ciEnv::dump_compile_data(outputStream* out) {\n  CompileTask* task = this->task();\n  Method* method = task->method();\n  int entry_bci = task->osr_bci();\n  int comp_level = task->comp_level();\n  out->print(\"compile %s %s %s %d %d\",\n                method->klass_name()->as_quoted_ascii(),\n                method->name()->as_quoted_ascii(),\n                method->signature()->as_quoted_ascii(),\n                entry_bci, comp_level);\n  if (compiler_data() != NULL) {\n    if (is_c2_compile(comp_level)) { \n#ifdef COMPILER2\n      ((Compile*)compiler_data())->dump_inline_data(out);\n#endif\n    } else if (is_c1_compile(comp_level)) { \n#ifdef COMPILER1\n      ((Compilation*)compiler_data())->dump_inline_data(out);\n#endif\n    }\n  }\n  out->cr();\n}", "target": 0}
{"code": "static inline void ModulateLCHuv(const double percent_luma,\n  const double percent_chroma,const double percent_hue,double *red,\n  double *green,double *blue)\n{\n  double\n    hue,\n    luma,\n    chroma;\n  ConvertRGBToLCHuv(*red,*green,*blue,&luma,&chroma,&hue);\n  luma*=0.01*percent_luma;\n  chroma*=0.01*percent_chroma;\n  hue+=fmod((percent_hue-100.0),200.0)/200.0;\n  ConvertLCHuvToRGB(luma,chroma,hue,red,green,blue);\n}", "target": 0}
{"code": "int is_crl_issuer(gnutls_x509_crl_t crl, gnutls_x509_crt_t issuer_cert)\n{\n    gnutls_datum_t dn1 = { NULL, 0 }, dn2 = {\n    NULL, 0};\n    int ret;\n    ret = _gnutls_x509_crl_get_raw_issuer_dn(crl, &dn1);\n    if (ret < 0) {\n\tgnutls_assert();\n\tgoto cleanup;\n    }\n    ret = _gnutls_x509_crt_get_raw_dn(issuer_cert, &dn2);\n    if (ret < 0) {\n\tgnutls_assert();\n\treturn ret;\n    }\n    ret = _gnutls_x509_compare_raw_dn(&dn1, &dn2);\n  cleanup:\n    _gnutls_free_datum(&dn1);\n    _gnutls_free_datum(&dn2);\n    return ret;\n}", "target": 0}
{"code": "void register_page_bootmem_info_node(struct pglist_data *pgdat)\n{\n\tunsigned long i, pfn, end_pfn, nr_pages;\n\tint node = pgdat->node_id;\n\tstruct page *page;\n\tstruct zone *zone;\n\tnr_pages = PAGE_ALIGN(sizeof(struct pglist_data)) >> PAGE_SHIFT;\n\tpage = virt_to_page(pgdat);\n\tfor (i = 0; i < nr_pages; i++, page++)\n\t\tget_page_bootmem(node, page, NODE_INFO);\n\tzone = &pgdat->node_zones[0];\n\tfor (; zone < pgdat->node_zones + MAX_NR_ZONES - 1; zone++) {\n\t\tif (zone->wait_table) {\n\t\t\tnr_pages = zone->wait_table_hash_nr_entries\n\t\t\t\t* sizeof(wait_queue_head_t);\n\t\t\tnr_pages = PAGE_ALIGN(nr_pages) >> PAGE_SHIFT;\n\t\t\tpage = virt_to_page(zone->wait_table);\n\t\t\tfor (i = 0; i < nr_pages; i++, page++)\n\t\t\t\tget_page_bootmem(node, page, NODE_INFO);\n\t\t}\n\t}\n\tpfn = pgdat->node_start_pfn;\n\tend_pfn = pfn + pgdat->node_spanned_pages;\n\tfor (; pfn < end_pfn; pfn += PAGES_PER_SECTION)\n\t\tregister_page_bootmem_info_section(pfn);\n}", "target": 0}
{"code": "ut64 Elf_(r_bin_elf_p2v) (ELFOBJ *bin, ut64 paddr) {\n\tint i;\n\tif (!bin) return 0;\n\tif (!bin->phdr) {\n\t\tif (bin->ehdr.e_type == ET_REL) {\n\t\t\treturn bin->baddr + paddr;\n\t\t}\n\t\treturn paddr;\n\t}\n\tfor (i = 0; i < bin->ehdr.e_phnum; ++i) {\n\t\tElf_(Phdr) *p = &bin->phdr[i];\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\tif (p->p_type == PT_LOAD && is_in_pphdr (p, paddr)) {\n\t\t\tif (!p->p_vaddr && !p->p_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn p->p_vaddr + paddr - p->p_offset;\n\t\t}\n\t}\n\treturn paddr;\n}", "target": 0}
{"code": "    return dt;\n  }\n  inline const char *strbuffersize(const cimg_ulong size) {\n    static CImg<char> res(256);\n    cimg::mutex(5);\n    if (size<1024LU) cimg_snprintf(res,res._width,\"%lu byte%s\",(unsigned long)size,size>1?\"s\":\"\");\n    else if (size<1024*1024LU) { const float nsize = size/1024.0f; cimg_snprintf(res,res._width,\"%.1f Kio\",nsize); }\n    else if (size<1024*1024*1024LU) {\n      const float nsize = size/(1024*1024.0f); cimg_snprintf(res,res._width,\"%.1f Mio\",nsize);", "target": 0}
{"code": "static int lxcfs_flush(const char *path, struct fuse_file_info *fi)\n{\n\treturn 0;\n}", "target": 0}
{"code": "static bool check_raw_mode_ok(const struct bpf_func_proto *fn)\n{\n\tint count = 0;\n\tif (fn->arg1_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg2_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg3_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg4_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg5_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\treturn count <= 1;\n}", "target": 0}
{"code": "int PDFiumEngine::GetRenderingFlags() const {\n  int flags = FPDF_LCD_TEXT | FPDF_NO_CATCH;\n  if (render_grayscale_)\n    flags |= FPDF_GRAYSCALE;\n  if (client_->IsPrintPreview())\n    flags |= FPDF_PRINTING;\n  if (render_annots_)\n    flags |= FPDF_ANNOT;\n  return flags;\n}", "target": 0}
{"code": "GF_ISOTrackID gf_isom_get_track_original_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->originalID;\n}", "target": 0}
{"code": "static JOIN_TAB *next_breadth_first_tab(JOIN_TAB *first_top_tab,\n                                        uint n_top_tabs_count, JOIN_TAB *tab)\n{\n  n_top_tabs_count += tab->join->aggr_tables;\n  if (!tab->bush_root_tab)\n  {\n    tab++;\n    if (tab < first_top_tab + n_top_tabs_count)\n      return tab;\n    tab= first_top_tab;\n  }\n  else\n  {\n    if (!tab->last_leaf_in_bush)\n    {\n      return ++tab;\n    }\n    else\n    {\n      tab= tab->bush_root_tab + 1;\n    }\n  }\n  for (; tab < first_top_tab + n_top_tabs_count; tab++)\n  {\n    if (tab->bush_children)\n      return tab->bush_children->start;\n  }\n  return NULL;\n}", "target": 0}
{"code": "flatpak_remote_state_lookup_sparse_cache (FlatpakRemoteState *self,\n                                          const char         *ref,\n                                          VarMetadataRef     *out_metadata,\n                                          GError            **error)\n{\n  VarSummaryRef summary;\n  VarMetadataRef meta;\n  VarVariantRef sparse_cache_v;\n  guint32 summary_version;\n  GVariant *summary_v;\n  if (!flatpak_remote_state_ensure_summary (self, error))\n    return FALSE;\n  summary_v = get_summary_for_ref (self, ref);\n  if (summary_v == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                             _(\"No entry for %s in remote summary flatpak sparse cache \"), ref);\n  summary = var_summary_from_gvariant (summary_v);\n  meta = var_summary_get_metadata (summary);\n  summary_version = GUINT32_FROM_LE (var_metadata_lookup_uint32 (meta, \"xa.summary-version\", 0));\n  if (summary_version == 0)\n    {\n      if (var_metadata_lookup (meta, \"xa.sparse-cache\", NULL, &sparse_cache_v))\n        {\n          VarSparseCacheRef sparse_cache = var_sparse_cache_from_variant (sparse_cache_v);\n          if (var_sparse_cache_lookup (sparse_cache, ref, NULL, out_metadata))\n            return TRUE;\n        }\n    }\n  else if (summary_version == 1)\n    {\n      VarRefMapRef ref_map = var_summary_get_ref_map (summary);\n      VarRefInfoRef info;\n      if (flatpak_var_ref_map_lookup_ref (ref_map, ref, &info))\n        {\n          *out_metadata = var_ref_info_get_metadata (info);\n          return TRUE;\n        }\n    }\n  else\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Unsupported summary version %d for remote %s\"),\n                          summary_version, self->remote_name);\n      return FALSE;\n    }\n  return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                             _(\"No entry for %s in remote summary flatpak sparse cache \"), ref);\n}", "target": 0}
{"code": "static bool __nl80211_unexpected_frame(struct net_device *dev, u8 cmd,\n\t\t\t\t       const u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\tu32 nlportid = ACCESS_ONCE(wdev->ap_unexpected_nlportid);\n\tif (!nlportid)\n\t\treturn false;\n\tmsg = nlmsg_new(100, gfp);\n\tif (!msg)\n\t\treturn true;\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn true;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\terr = genlmsg_end(msg, hdr);\n\tif (err < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn true;\n\t}\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\treturn true;\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n\treturn true;\n}", "target": 0}
{"code": "GF_EXPORT\nGF_Err gf_isom_get_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *colour_type, u16 *colour_primaries, u16 *transfer_characteristics, u16 *matrix_coefficients, Bool *full_range_flag)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return GF_OK;\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\tGF_ColourInformationBox *clr = (GF_ColourInformationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\tif (!clr) return GF_NOT_FOUND;\n\tif (colour_type) *colour_type = clr->colour_type;\n\tif (colour_primaries) *colour_primaries = clr->colour_primaries;\n\tif (transfer_characteristics) *transfer_characteristics = clr->transfer_characteristics;\n\tif (matrix_coefficients) *matrix_coefficients = clr->matrix_coefficients;\n\tif (full_range_flag) *full_range_flag = clr->full_range_flag;\n\treturn GF_OK;", "target": 0}
{"code": "  void libraw_set_dataerror_handler(libraw_data_t *lr, data_callback func,\n                                    void *data)\n  {\n    if (!lr)\n      return;\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    ip->set_dataerror_handler(func, data);\n  }", "target": 0}
{"code": "void GfxSeparationColorSpace::getRGB(const GfxColor *color, GfxRGB *rgb) const\n{\n    double x;\n    double c[gfxColorMaxComps];\n    GfxColor color2;\n    int i;\n    if (alt->getMode() == csDeviceGray && name->cmp(\"Black\") == 0) {\n        rgb->r = clip01(gfxColorComp1 - color->c[0]);\n        rgb->g = clip01(gfxColorComp1 - color->c[0]);\n        rgb->b = clip01(gfxColorComp1 - color->c[0]);\n    } else {\n        x = colToDbl(color->c[0]);\n        func->transform(&x, c);\n        const int altNComps = alt->getNComps();\n        for (i = 0; i < altNComps; ++i) {\n            color2.c[i] = dblToCol(c[i]);\n        }\n        if (unlikely(altNComps > func->getOutputSize())) {\n            for (i = func->getOutputSize(); i < altNComps; ++i) {\n                color2.c[i] = 0;\n            }\n        }\n        alt->getRGB(&color2, rgb);\n    }\n}", "target": 0}
{"code": "static int reset_saslconn(sasl_conn_t **conn)\n{\n    int ret;\n    sasl_security_properties_t *secprops = NULL;\n    sasl_dispose(conn);\n    ret = sasl_server_new(\"HTTP\", config_servername, NULL,\n                          buf_cstringnull_ifempty(&saslprops.iplocalport),\n                          buf_cstringnull_ifempty(&saslprops.ipremoteport),\n                          NULL, SASL_USAGE_FLAGS, conn);\n    if(ret != SASL_OK) return ret;\n    secprops = mysasl_secprops(0);\n    secprops->max_ssf = 0;                              \n    secprops->maxbufsize = 0;                           \n    ret = sasl_setprop(*conn, SASL_SEC_PROPS, secprops);\n    if(ret != SASL_OK) return ret;\n    if(saslprops.ssf) {\n        ret = saslprops_set_tls(&saslprops, *conn);\n    } else {\n        ret = sasl_setprop(*conn, SASL_SSF_EXTERNAL, &extprops_ssf);\n    }\n    if(ret != SASL_OK) return ret;\n    return SASL_OK;\n}", "target": 0}
{"code": "loc_offsets_compar (const void *ap, const void *bp)\n{\n  dwarf_vma a = loc_offsets[*(const unsigned int *) ap];\n  dwarf_vma b = loc_offsets[*(const unsigned int *) bp];\n  int ret = (a > b) - (b > a);\n  if (ret)\n    return ret;\n  a = loc_views[*(const unsigned int *) ap];\n  b = loc_views[*(const unsigned int *) bp];\n  ret = (a > b) - (b > a);\n  return ret;\n}", "target": 0}
{"code": "decode_NXAST_RAW_DEC_TTL_CNT_IDS(const struct nx_action_cnt_ids *nac_ids,\n                                 enum ofp_version ofp_version OVS_UNUSED,\n                                 struct ofpbuf *out)\n{\n    struct ofpact_cnt_ids *ids;\n    size_t ids_size;\n    int i;\n    ids = ofpact_put_DEC_TTL(out);\n    ids->ofpact.raw = NXAST_RAW_DEC_TTL_CNT_IDS;\n    ids->n_controllers = ntohs(nac_ids->n_controllers);\n    ids_size = ntohs(nac_ids->len) - sizeof *nac_ids;\n    if (!is_all_zeros(nac_ids->zeros, sizeof nac_ids->zeros)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n    if (ids_size < ids->n_controllers * sizeof(ovs_be16)) {\n        VLOG_WARN_RL(&rl, \"Nicira action dec_ttl_cnt_ids only has %\"PRIuSIZE\" \"\n                     \"bytes allocated for controller ids.  %\"PRIuSIZE\" bytes \"\n                     \"are required for %u controllers.\",\n                     ids_size, ids->n_controllers * sizeof(ovs_be16),\n                     ids->n_controllers);\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n    for (i = 0; i < ids->n_controllers; i++) {\n        uint16_t id = ntohs(((ovs_be16 *)(nac_ids + 1))[i]);\n        ofpbuf_put(out, &id, sizeof id);\n        ids = out->header;\n    }\n    ofpact_finish_DEC_TTL(out, &ids);\n    return 0;\n}", "target": 0}
{"code": "static int select_item(sc_card_t *card, const sc_path_t *path_in, sc_file_t ** file_out, int requiredType)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmscfs_file_t *file_data = NULL;\n\tint pathlen = path_in->len;\n\tint r = 0;\n\tint objectIndex;\n\tu8* oid;\n\tmscfs_check_cache(fs);\n\tr = mscfs_loadFileInfo(fs, path_in->value, path_in->len, &file_data, &objectIndex);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\tif(requiredType >= 0 && requiredType != file_data->ef) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\toid = file_data->objectId.id;\n\tif(file_data->ef) {\n\t\tfs->currentPath[0] = oid[0];\n\t\tfs->currentPath[1] = oid[1];\n\t\tfs->currentFile[0] = oid[2];\n\t\tfs->currentFile[1] = oid[3];\n\t} else {\n\t\tfs->currentPath[0] = oid[pathlen - 2];\n\t\tfs->currentPath[1] = oid[pathlen - 1];\n\t\tfs->currentFile[0] = 0;\n\t\tfs->currentFile[1] = 0;\n\t}\n\tfs->currentFileIndex = objectIndex;\n\tif(file_out) {\n\t\tsc_file_t *file;\n\t\tfile = sc_file_new();\n\t\tfile->path = *path_in;\n\t\tfile->size = file_data->size;\n\t\tfile->id = (oid[2] << 8) | oid[3];\n\t\tif(!file_data->ef) {\n\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t} else {\n\t\t\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\t\t\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\t\t}\n\t\tif(file_data->ef) {\n\t\t\tmuscle_load_file_acls(file, file_data);\n\t\t} else {\n\t\t\tmuscle_load_dir_acls(file, file_data);\n\t\t}\n\t\tfile->magic = SC_FILE_MAGIC;\n\t\t*file_out = file;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "WTF::PassRefPtr<WebCore::Frame> ewk_view_frame_create(Evas_Object* ewkView, Evas_Object* frame, const WTF::String& name, WebCore::HTMLFrameOwnerElement* ownerElement, const WebCore::KURL& url, const WTF::String& referrer)\n{\n    DBG(\"ewkView=%p, frame=%p, name=%s, ownerElement=%p, url=%s, referrer=%s\",\n        ewkView, frame, name.utf8().data(), ownerElement,\n        url.string().utf8().data(), referrer.utf8().data());\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, 0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, 0);\n    WTF::RefPtr<WebCore::Frame> coreFrame = _ewk_view_core_frame_new\n                                         (smartData, priv, ownerElement);\n    if (!coreFrame) {\n        ERR(\"Could not create child core frame '%s'\", name.utf8().data());\n        return 0;\n    }\n    if (!ewk_frame_child_add(frame, coreFrame, name, url, referrer)) {\n        ERR(\"Could not create child frame object '%s'\", name.utf8().data());\n        return 0;\n    }\n    if (!coreFrame->page() || !coreFrame->tree() || !coreFrame->tree()->parent())\n        return 0;\n    smartData->changed.frame_rect = true;\n    _ewk_view_smart_changed(smartData);\n    return coreFrame.release();\n}", "target": 0}
{"code": "static inline int hardware_largepage_caps(struct dmar_domain *domain,\n\t\t\t\t\t  unsigned long iov_pfn,\n\t\t\t\t\t  unsigned long phy_pfn,\n\t\t\t\t\t  unsigned long pages)\n{\n\tint support, level = 1;\n\tunsigned long pfnmerge;\n\tsupport = domain->iommu_superpage;\n\tpfnmerge = iov_pfn | phy_pfn;\n\twhile (support && !(pfnmerge & ~VTD_STRIDE_MASK)) {\n\t\tpages >>= VTD_STRIDE_SHIFT;\n\t\tif (!pages)\n\t\t\tbreak;\n\t\tpfnmerge >>= VTD_STRIDE_SHIFT;\n\t\tlevel++;\n\t\tsupport--;\n\t}\n\treturn level;\n}", "target": 0}
{"code": "static bool io_queue_worker_create(struct io_worker *worker,\n\t\t\t\t   struct io_wqe_acct *acct,\n\t\t\t\t   task_work_func_t func)\n{\n\tstruct io_wqe *wqe = worker->wqe;\n\tstruct io_wq *wq = wqe->wq;\n\tif (test_bit(IO_WQ_BIT_EXIT, &wq->state))\n\t\tgoto fail;\n\tif (!io_worker_get(worker))\n\t\tgoto fail;\n\tif (test_bit(0, &worker->create_state) ||\n\t    test_and_set_bit_lock(0, &worker->create_state))\n\t\tgoto fail_release;\n\tinit_task_work(&worker->create_work, func);\n\tworker->create_index = acct->index;\n\tif (!task_work_add(wq->task, &worker->create_work, TWA_SIGNAL))\n\t\treturn true;\n\tclear_bit_unlock(0, &worker->create_state);\nfail_release:\n\tio_worker_release(worker);\nfail:\n\tatomic_dec(&acct->nr_running);\n\tio_worker_ref_put(wq);\n\treturn false;\n}", "target": 0}
{"code": "ExecutionContext* AudioContext::executionContext() const\n{\n    return m_isStopScheduled ? 0 : ActiveDOMObject::executionContext();\n}", "target": 0}
{"code": "int intel_execlists_submission_setup(struct intel_engine_cs *engine)\n{\n\ttasklet_init(&engine->execlists.tasklet,\n\t\t     execlists_submission_tasklet, (unsigned long)engine);\n\ttimer_setup(&engine->execlists.timer, execlists_timeslice, 0);\n\ttimer_setup(&engine->execlists.preempt, execlists_preempt, 0);\n\tlogical_ring_default_vfuncs(engine);\n\tlogical_ring_default_irqs(engine);\n\tif (engine->class == RENDER_CLASS)\n\t\trcs_submission_override(engine);\n\treturn 0;\n}", "target": 0}
{"code": "void validateCapacity(uint64_t new_capacity) {\n  RELEASE_ASSERT(new_capacity <= std::numeric_limits<uint32_t>::max(),\n                 \"Trying to allocate overly large headers.\");\n}", "target": 0}
{"code": "bool read(AFvirtualfile *vf, T *value)\n{\n\treturn vf->read(value, sizeof (*value)) == sizeof (*value);\n}", "target": 0}
{"code": "int epo_copy_alpha_hl_color(gx_device *dev, const byte *data, int data_x,\n    int raster, gx_bitmap_id id, int x, int y, int width, int height,\n    const gx_drawing_color *pdcolor, int depth)\n{\n    int code = epo_handle_erase_page(dev);\n    if (code != 0)\n        return code;\n    return dev_proc(dev, copy_alpha_hl_color)(dev, data, data_x, raster, id, x, y, width, height, pdcolor, depth);\n}", "target": 0}
{"code": "static int route4_dump(struct net *net, struct tcf_proto *tp, void *fh,\n\t\t       struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)\n{\n\tstruct route4_filter *f = fh;\n\tstruct nlattr *nest;\n\tu32 id;\n\tif (f == NULL)\n\t\treturn skb->len;\n\tt->tcm_handle = f->handle;\n\tnest = nla_nest_start_noflag(skb, TCA_OPTIONS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\tif (!(f->handle & 0x8000)) {\n\t\tid = f->id & 0xFF;\n\t\tif (nla_put_u32(skb, TCA_ROUTE4_TO, id))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (f->handle & 0x80000000) {\n\t\tif ((f->handle >> 16) != 0xFFFF &&\n\t\t    nla_put_u32(skb, TCA_ROUTE4_IIF, f->iif))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tid = f->id >> 16;\n\t\tif (nla_put_u32(skb, TCA_ROUTE4_FROM, id))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (f->res.classid &&\n\t    nla_put_u32(skb, TCA_ROUTE4_CLASSID, f->res.classid))\n\t\tgoto nla_put_failure;\n\tif (tcf_exts_dump(skb, &f->exts) < 0)\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\tif (tcf_exts_dump_stats(skb, &f->exts) < 0)\n\t\tgoto nla_put_failure;\n\treturn skb->len;\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -1;\n}", "target": 0}
{"code": "uint64_t Parcel::readUint64() const\n{\n return readAligned<uint64_t>();\n}", "target": 0}
{"code": "static void set_curr_task_fair(struct rq *rq)\n{\n\tstruct sched_entity *se = &rq->curr->se;\n\tfor_each_sched_entity(se)\n\t\tset_next_entity(cfs_rq_of(se), se);\n}", "target": 0}
{"code": "static ssize_t xps_rxqs_store(struct netdev_queue *queue, const char *buf,\n\t\t\t      size_t len)\n{\n\tstruct net_device *dev = queue->dev;\n\tstruct net *net = dev_net(dev);\n\tunsigned long *mask, index;\n\tint err;\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tmask = bitmap_zalloc(dev->num_rx_queues, GFP_KERNEL);\n\tif (!mask)\n\t\treturn -ENOMEM;\n\tindex = get_netdev_queue_index(queue);\n\terr = bitmap_parse(buf, len, mask, dev->num_rx_queues);\n\tif (err) {\n\t\tbitmap_free(mask);\n\t\treturn err;\n\t}\n\tcpus_read_lock();\n\terr = __netif_set_xps_queue(dev, mask, index, true);\n\tcpus_read_unlock();\n\tbitmap_free(mask);\n\treturn err ? : len;", "target": 0}
{"code": "utf32le_is_mbc_newline(const UChar* p, const UChar* end,\n\t\t       OnigEncoding enc ARG_UNUSED)\n{\n  if (p + 3 < end) {\n    if (*p == 0x0a && *(p+1) == 0 && *(p+2) == 0 && *(p+3) == 0)\n      return 1;\n#ifdef USE_UNICODE_ALL_LINE_TERMINATORS\n    if ((\n#ifndef USE_CRNL_AS_LINE_TERMINATOR\n\t *p == 0x0d ||\n#endif\n\t *p == 0x85)\n\t&& *(p+1) == 0x00 && (p+2) == 0x00 && *(p+3) == 0x00)\n      return 1;\n    if (*(p+1) == 0x20 && (*p == 0x29 || *p == 0x28)\n\t&& *(p+2) == 0x00 && *(p+3) == 0x00)\n      return 1;\n#endif\n  }\n  return 0;\n}", "target": 0}
{"code": "msg_to_pipe (const char *cmd, mu_message_t msg)\n{\n  mu_stream_t progstream, msgstream;\n  int status, rc;\n  char *argv[4];\n  argv[0] = getenv (\"SHELL\");\n  if (!argv[0])\n    argv[0] = \"/bin/sh\";\n  argv[1] = \"-c\";\n  argv[2] = (char*) cmd;\n  argv[3] = NULL;\n  status = mu_prog_stream_create (&progstream,\n\t\t\t\t  argv[0],\n\t\t\t\t  3, argv,\n\t\t\t\t  0, NULL, MU_STREAM_WRITE);\n  if (status)\n    {\n      mu_error (_(\"Cannot pipe to %s: %s\"), cmd, mu_strerror (status));\n      return status;\n    }\n  mu_message_get_streamref (msg, &msgstream);\n  status = mu_stream_copy (progstream, msgstream, 0, NULL);\n  rc = mu_stream_close (progstream);\n  if (status == 0 && rc)\n    status = rc;\n  mu_stream_destroy (&progstream);\n  mu_stream_destroy (&msgstream);\n  if (status)\n    {\n      mu_error (_(\"Sending data to %s failed: %s\"), cmd,\n\t\t  mu_strerror (status));\n    }\n  return status;\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_last_oid)\n{\n\tzval *result;\n\tPGresult *pgsql_result;\n\tpgsql_result_handle *pg_result;\n#ifdef HAVE_PQOIDVALUE\n\tOid oid;\n#endif\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &result) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, \"PostgreSQL result\", le_result);\n\tpgsql_result = pg_result->result;\n#ifdef HAVE_PQOIDVALUE\n\toid = PQoidValue(pgsql_result);\n\tif (oid == InvalidOid) {\n\t\tRETURN_FALSE;\n\t}\n\tPGSQL_RETURN_OID(oid);\n#else\n\tZ_STRVAL_P(return_value) = (char *) PQoidStatus(pgsql_result);\n\tif (Z_STRVAL_P(return_value)) {\n\t\tRETURN_STRING(Z_STRVAL_P(return_value), 1);\n\t}\n\tRETURN_STRING(\"\", 1);\n#endif\n}", "target": 0}
{"code": "static char *get_path(struct fuse *f, fuse_ino_t nodeid)\n{\n    return get_path_name(f, nodeid, NULL);\n}", "target": 0}
{"code": "Status FunctionLibraryDefinition::LookUp(\n    const string& op, const OpRegistrationData** op_reg_data) const {\n  tf_shared_lock l(mu_);\n  auto iter = function_defs_.find(op);\n  if (iter != function_defs_.end()) {\n    *op_reg_data = &iter->second->op_registration_data;\n    return Status::OK();\n  }\n  return default_registry_->LookUp(op, op_reg_data);\n}", "target": 0}
{"code": "static ssize_t xenbus_file_write(struct file *filp,\n\t\t\t\tconst char __user *ubuf,\n\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tstruct xenbus_file_priv *u = filp->private_data;\n\tuint32_t msg_type;\n\tint rc = len;\n\tint ret;\n\tLIST_HEAD(staging_q);\n\tmutex_lock(&u->msgbuffer_mutex);\n\tif (len == 0)\n\t\tgoto out;\n\tif (len > sizeof(u->u.buffer) - u->len) {\n\t\tu->len = 0;\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = copy_from_user(u->u.buffer + u->len, ubuf, len);\n\tif (ret != 0) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\tlen -= ret;\n\trc = len;\n\tu->len += len;\n\tif (u->len < sizeof(u->u.msg))\n\t\tgoto out;\t\n\tif ((sizeof(u->u.msg) + u->u.msg.len) > sizeof(u->u.buffer)) {\n\t\trc = -E2BIG;\n\t\tu->len = 0;\n\t\tgoto out;\n\t}\n\tif (u->len < (sizeof(u->u.msg) + u->u.msg.len))\n\t\tgoto out;\t\n\tmsg_type = u->u.msg.type;\n\tswitch (msg_type) {\n\tcase XS_WATCH:\n\tcase XS_UNWATCH:\n\t\tret = xenbus_write_watch(msg_type, u);\n\t\tbreak;\n\tdefault:\n\t\tret = xenbus_write_transaction(msg_type, u);\n\t\tbreak;\n\t}\n\tif (ret != 0)\n\t\trc = ret;\n\tu->len = 0;\n out:\n\tmutex_unlock(&u->msgbuffer_mutex);\n\treturn rc;\n}", "target": 0}
{"code": "connection_handle_read_post_chunked_crlf (chunkqueue * const cq)\n{\n    chunk *c;\n    buffer *b;\n    char *p;\n    size_t len;\n    if (chunkqueue_is_empty(cq)) return 0;\n    c = cq->first;\n    b = c->mem;\n    p = b->ptr+c->offset;\n    if (p[0] != '\\r') return -1; \n    if (p[1] == '\\n') return 1;\n    len = buffer_string_length(b) - (size_t)c->offset;\n    if (1 != len) return -1; \n    while (NULL != (c = c->next)) {\n        b = c->mem;\n        len = buffer_string_length(b) - (size_t)c->offset;\n        if (0 == len) continue;\n        p = b->ptr+c->offset;\n        return (p[0] == '\\n') ? 1 : -1; \n    }\n    return 0;\n}", "target": 0}
{"code": "  RequestHeaderMapImpl() { clearInline(); }", "target": 0}
{"code": "static int write_chunk(struct mctp_serial *dev, unsigned char *buf, int len)\n{\n\treturn dev->tty->ops->write(dev->tty, buf, len);\n}", "target": 0}
{"code": "format_UNROLL_XLATE(const struct ofpact_unroll_xlate *a,\n                    const struct ofpact_format_params *fp)\n{\n    ds_put_format(fp->s, \"%sunroll_xlate(%s%stable=%s\",\n                  colors.paren,   colors.end,\n                  colors.special, colors.end);\n    ofputil_format_table(a->rule_table_id, fp->table_map, fp->s);\n    ds_put_format(fp->s, \", %scookie=%s%\"PRIu64\"%s)%s\",\n                  colors.param,   colors.end, ntohll(a->rule_cookie),\n                  colors.paren,   colors.end);\n}", "target": 0}
{"code": "static inline void __clear_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\tif (test_bit(fd, fdt->close_on_exec))\n\t\t__clear_bit(fd, fdt->close_on_exec);\n}", "target": 0}
{"code": "get_delayed_job_ct()\n{\n    tube t;\n    size_t i;\n    unsigned int count = 0;\n    for (i = 0; i < tubes.used; i++) {\n        t = tubes.items[i];\n        count += t->delay.used;\n    }\n    return count;\n}", "target": 0}
{"code": "static int device_notifier(struct notifier_block *nb,\n\t\t\t\t  unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct dmar_domain *domain;\n\tif (iommu_dummy(dev))\n\t\treturn 0;\n\tif (action != BUS_NOTIFY_REMOVED_DEVICE)\n\t\treturn 0;\n\tdomain = find_domain(dev);\n\tif (!domain)\n\t\treturn 0;\n\tdmar_remove_one_dev_info(domain, dev);\n\tif (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))\n\t\tdomain_exit(domain);\n\treturn 0;\n}", "target": 0}
{"code": "int lxc_set_death_signal(int signal)\n{\n\tint ret;\n\tpid_t ppid;\n\tret = prctl(PR_SET_PDEATHSIG, prctl_arg(signal), prctl_arg(0),\n\t\t    prctl_arg(0), prctl_arg(0));\n\tppid = (pid_t)syscall(SYS_getppid);\n\tif (ppid == 1) {\n\t\tpid_t self;\n\t\tself = lxc_raw_getpid();\n\t\tret = kill(self, SIGKILL);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\tif (ret < 0) {\n\t\tSYSERROR(\"Failed to set PR_SET_PDEATHSIG to %d\", signal);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "CachePolicy FrameLoader::subresourceCachePolicy() const\n{\n    if (m_frame->document()->loadEventFinished())\n        return CachePolicyVerify;\n    if (m_loadType == FrameLoadTypeReloadFromOrigin)\n        return CachePolicyReload;\n    if (Frame* parentFrame = m_frame->tree()->parent()) {\n        CachePolicy parentCachePolicy = parentFrame->loader()->subresourceCachePolicy();\n        if (parentCachePolicy != CachePolicyVerify)\n            return parentCachePolicy;\n    }\n    if (m_loadType == FrameLoadTypeReload)\n        return CachePolicyRevalidate;\n    const ResourceRequest& request(documentLoader()->request());\n    if (request.cachePolicy() == ReturnCacheDataElseLoad)\n        return CachePolicyHistoryBuffer;\n    return CachePolicyVerify;\n}", "target": 0}
{"code": "_gnutls_x509_get_signature(ASN1_TYPE src, const char *src_name,\n\t\t\t   gnutls_datum_t * signature)\n{\n\tint result, len;\n\tint bits;\n\tsignature->data = NULL;\n\tsignature->size = 0;\n\tlen = 0;\n\tresult = asn1_read_value(src, src_name, NULL, &len);\n\tif (result != ASN1_MEM_ERROR) {\n\t\tresult = _gnutls_asn2err(result);\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tbits = len;\n\tif (bits % 8 != 0 || bits < 8) {\n\t\tgnutls_assert();\n\t\tresult = GNUTLS_E_CERTIFICATE_ERROR;\n\t\tgoto cleanup;\n\t}\n\tlen = bits / 8;\n\tsignature->data = gnutls_malloc(len);\n\tif (signature->data == NULL) {\n\t\tgnutls_assert();\n\t\tresult = GNUTLS_E_MEMORY_ERROR;\n\t\treturn result;\n\t}\n\tbits = len;\n\tresult =\n\t    asn1_read_value(src, src_name, signature->data, &bits);\n\tif (result != ASN1_SUCCESS) {\n\t\tresult = _gnutls_asn2err(result);\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tsignature->size = len;\n\treturn 0;\n      cleanup:\n\treturn result;\n}", "target": 0}
{"code": "ia32_install_gate_page (struct vm_area_struct *vma, unsigned long address, int *type)\n{\n\tstruct page *pg = ia32_gate_page;\n\tget_page(pg);\n\tif (type)\n\t\t*type = VM_FAULT_MINOR;\n\treturn pg;\n}", "target": 0}
{"code": "String *Item_copy_string::val_str(String *str)\n{\n  if (null_value)\n    return (String*) 0;\n  return &str_value;\n}", "target": 0}
{"code": "bool nfsd4_cache_this_op(struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn false;\n\treturn OPDESC(op)->op_flags & OP_CACHEME;\n}", "target": 0}
{"code": "static int decode_attr_time(struct xdr_stream *xdr, struct timespec *time)\n{\n\t__be32 *p;\n\tuint64_t sec;\n\tuint32_t nsec;\n\tp = xdr_inline_decode(xdr, 12);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tp = xdr_decode_hyper(p, &sec);\n\tnsec = be32_to_cpup(p);\n\ttime->tv_sec = (time_t)sec;\n\ttime->tv_nsec = (long)nsec;\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "void infra_wait_limit_inc(struct infra_cache* infra, struct comm_reply* rep,\n\ttime_t timenow, struct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 1);\n\tif(entry) {\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\td->mesh_wait++;\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn;\n\t}\n\tinfra_ip_create_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, timenow, 1);\n}", "target": 0}
{"code": "static int make_bbox(gx_path       * path,\n               const gs_fixed_rect * clip,\n                     gs_fixed_rect * ibox,\n                     fixed           adjust)\n{\n    gs_fixed_rect bbox;\n    int           code;\n    code = gx_path_bbox(path, &bbox);\n    if (code < 0)\n        return code;\n    if (clip) {\n        if (bbox.p.y < clip->p.y)\n            bbox.p.y = clip->p.y;\n        if (bbox.q.y > clip->q.y)\n            bbox.q.y = clip->q.y;\n    }\n    ibox->p.x = fixed2int(bbox.p.x-adjust);\n    ibox->p.y = fixed2int(bbox.p.y-adjust);\n    ibox->q.x = fixed2int(bbox.q.x-adjust+fixed_1);\n    ibox->q.y = fixed2int(bbox.q.y-adjust+fixed_1);\n    return 0;\n}", "target": 0}
{"code": "gx_filter_edgebuffer_app(gx_device       * pdev,\n                         gx_edgebuffer   * edgebuffer,\n                         int               rule)\n{\n    int i;\n#ifdef DEBUG_SCAN_CONVERTER\n    gx_edgebuffer_print_app(edgebuffer);\n#endif\n    for (i=0; i < edgebuffer->height; i++) {\n        int *row      = &edgebuffer->table[edgebuffer->index[i]];\n        int  rowlen   = *row++;\n        int *rowstart = row;\n        int *rowout   = row;\n        int  ll, lr, rl, rr, wind, marked_to;\n        marked_to = 0;\n        while (rowlen > 0) {\n            if (rule == gx_rule_even_odd) {\n                ll = (*row++)&~1;\n                lr = (*row++);\n                rowlen--;\n                wind = 1;\n                assert(rowlen > 0);\n                do {\n                    rl = (*row++)&~1;\n                    rr = (*row++);\n                    rowlen--;\n                    if (rr > lr)\n                        lr = rr;\n                    wind ^= 1;\n                    if (wind == 0)\n                        break;\n                } while (rowlen > 0);\n            } else {\n                int w;\n                ll = *row++;\n                lr = *row++;\n                wind = -(ll&1) | 1;\n                ll &= ~1;\n                rowlen--;\n                assert(rowlen > 0);\n                do {\n                    rl = (*row++);\n                    rr = (*row++);\n                    w = -(rl&1) | 1;\n                    rl &= ~1;\n                    rowlen--;\n                    if (rr > lr)\n                        lr = rr;\n                    wind += w;\n                    if (wind == 0)\n                        break;\n                } while (rowlen > 0);\n            }\n            if (marked_to > ll) {\n                if (rowout == rowstart)\n                    ll = marked_to;\n                else {\n                    rowout -= 2;\n                    ll = *rowout;\n                }\n            }\n            if (lr > ll) {\n                *rowout++ = ll;\n                *rowout++ = lr;\n                marked_to = ll;\n            }\n        }\n        rowstart[-1] = rowout - rowstart;\n    }\n    return 0;\n}", "target": 0}
{"code": "void ExpressionReplaceBase::_doAddDependencies(DepsTracker* deps) const {\n    _input->addDependencies(deps);\n    _find->addDependencies(deps);\n    _replacement->addDependencies(deps);\n}", "target": 0}
{"code": "  ProgramManager::ProgramInfo* GetProgramInfo(GLuint client_id) {\n    ProgramManager::ProgramInfo* info =\n        program_manager()->GetProgramInfo(client_id);\n    return (info && !info->IsDeleted()) ? info : NULL;\n  }", "target": 0}
{"code": "bool red_stream_is_ssl(RedStream *stream)\n{\n    return (stream->priv->ssl != NULL);\n}", "target": 0}
{"code": "im_vips2dz( IMAGE *in, const char *filename )\n{\n\tchar *p, *q;\n\tchar name[FILENAME_MAX];\n\tchar mode[FILENAME_MAX];\n\tchar buf[FILENAME_MAX];\n\tint i;\n\tVipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; \n\tchar *suffix = \".jpeg\";\n\tint overlap = 0;\n\tint tile_size = 256;\n\tVipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; \n\tgboolean centre = FALSE;\n\tVipsAngle angle = VIPS_ANGLE_D0; \n\tim_strncpy( name, filename, FILENAME_MAX ); \n\tif( (p = strchr( name, ':' )) ) {\n\t\t*p = '\\0';\n\t\tim_strncpy( mode, p + 1, FILENAME_MAX ); \n\t}\n\telse \n\t\tstrcpy( mode, \"\" ); \n\tstrcpy( buf, mode ); \n\tp = &buf[0];\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 ) \n\t\t\treturn( -1 );\n\t\tlayout = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) \n\t\tsuffix = g_strdup( q );\n\tif( (q = im_getnextoption( &p )) ) \n\t\toverlap = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) \n\t\ttile_size = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tdepth = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( im_isprefix( \"cen\", q ) ) \n\t\t\tcentre = TRUE;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_ANGLE, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tangle = i;\n\t}\n\tif( vips_dzsave( in, name,\n\t\t\"layout\", layout,\n\t\t\"suffix\", suffix,\n\t\t\"overlap\", overlap,\n\t\t\"tile_size\", tile_size,\n\t\t\"depth\", depth,\n\t\t\"centre\", centre,\n\t\t\"angle\", angle,\n\t\tNULL ) )\n\t\treturn( -1 );\n\treturn( 0 );\n}", "target": 0}
{"code": "static inline void vm_exit_controls_clearbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_exit_controls_set(vmx, vm_exit_controls_get(vmx) & ~val);\n}", "target": 0}
{"code": "static void _print_parity(struct bnx2x *bp, u32 reg)\n{\n\tpr_cont(\" [0x%08x] \", REG_RD(bp, reg));\n}", "target": 0}
{"code": "Field *create_tmp_field_from_field(THD *thd, Field *org_field,\n                                   LEX_CSTRING *name, TABLE *table,\n                                   Item_field *item)\n{\n  Field *new_field;\n  new_field= org_field->make_new_field(thd->mem_root, table,\n                                       table == org_field->table);\n  if (new_field)\n  {\n    new_field->init(table);\n    new_field->orig_table= org_field->orig_table;\n    if (item)\n      item->result_field= new_field;\n    else\n      new_field->field_name= *name;\n    new_field->flags|= org_field->flags & NO_DEFAULT_VALUE_FLAG;\n    if (org_field->maybe_null() || (item && item->maybe_null))\n      new_field->flags&= ~NOT_NULL_FLAG;\t\n    if (org_field->type() == MYSQL_TYPE_VAR_STRING ||\n        org_field->type() == MYSQL_TYPE_VARCHAR)\n      table->s->db_create_options|= HA_OPTION_PACK_RECORD;\n    else if (org_field->type() == FIELD_TYPE_DOUBLE)\n      ((Field_double *) new_field)->not_fixed= TRUE;\n    new_field->vcol_info= 0;\n    new_field->cond_selectivity= 1.0;\n    new_field->next_equal_field= NULL;\n    new_field->option_list= NULL;\n    new_field->option_struct= NULL;\n  }\n  return new_field;\n}", "target": 0}
{"code": "static Eina_Bool _ewk_view_smart_pre_render_relative_radius(Ewk_View_Smart_Data* smartData, unsigned int number, float zoom)\n{\n    WRN(\"not supported by engine. smartData=%p, n=%u zoom=%f\",\n        smartData, number, zoom);\n    return false;\n}", "target": 0}
{"code": "static int midi_setup_portprefix(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_portprefix;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "int vmci_transport_send_waiting_write(struct sock *sk,\n\t\t\t\t      struct vmci_transport_waiting_info *wait)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\tsk, VMCI_TRANSPORT_PACKET_TYPE_WAITING_WRITE,\n\t\t\t\t0, 0, wait, VSOCK_PROTO_INVALID,\n\t\t\t\tVMCI_INVALID_HANDLE);\n}", "target": 0}
{"code": "static void GTextFieldSave(GTextField *gt,int utf8) {\n    unichar_t *ret;\n    char *cret;\n    FILE *file;\n    unichar_t *pt;\n    if ( _ggadget_use_gettext ) {\n\tchar *temp = GWidgetOpenFile8(_(\"Save\"),NULL,\"*.{txt,py}\",NULL,NULL);\n\tret = utf82u_copy(temp);\n\tfree(temp);\n    } else\n\tret = GWidgetSaveAsFile(GStringGetResource(_STR_Save,NULL),NULL,\n\t\ttxt,NULL,NULL);\n    if ( ret==NULL )\nreturn;\n    cret = u2def_copy(ret);\n    free(ret);\n    file = fopen(cret,\"w\");\n    if ( file==NULL ) {\n\tif ( _ggadget_use_gettext )\n\t    GWidgetError8(_(\"Could not open file\"), _(\"Could not open %.100s\"),cret);\n\telse\n\t    GWidgetError(errort,error,cret);\n\tfree(cret);\nreturn;\n    }\n    free(cret);\n    if ( utf8 ) {\n\tputc(0xef,file);\t\t\n\tputc(0xbb,file);\n\tputc(0xbf,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    if ( *pt<0x80 )\n\t\tputc(*pt,file);\n\t    else if ( *pt<0x800 ) {\n\t\tputc(0xc0 | (*pt>>6), file);\n\t\tputc(0x80 | (*pt&0x3f), file);\n\t    } else if ( *pt>=0xd800 && *pt<0xdc00 && pt[1]>=0xdc00 && pt[1]<0xe000 ) {\n\t\tint u = ((*pt>>6)&0xf)+1, y = ((*pt&3)<<4) | ((pt[1]>>6)&0xf);\n\t\tputc( 0xf0 | (u>>2),file );\n\t\tputc( 0x80 | ((u&3)<<4) | ((*pt>>2)&0xf),file );\n\t\tputc( 0x80 | y,file );\n\t\tputc( 0x80 | (pt[1]&0x3f),file );\n\t    } else {\n\t\tputc( 0xe0 | (*pt>>12),file );\n\t\tputc( 0x80 | ((*pt>>6)&0x3f),file );\n\t\tputc( 0x80 | (*pt&0x3f),file );\n\t    }\n\t}\n    } else {\n\tputc(0xfeff>>8,file);\t\t\n\tputc(0xfeff&0xff,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    putc(*pt>>8,file);\n\t    putc(*pt&0xff,file);\n\t}\n    }\n    fclose(file);\n    GTextFieldSaved(gt);\n}", "target": 0}
{"code": "int snd_card_file_remove(struct snd_card *card, struct file *file)\n{\n\tstruct snd_monitor_file *mfile, *found = NULL;\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\tif (mfile->file == file) {\n\t\t\tlist_del(&mfile->list);\n\t\t\tspin_lock(&shutdown_lock);\n\t\t\tlist_del(&mfile->shutdown_list);\n\t\t\tspin_unlock(&shutdown_lock);\n\t\t\tif (mfile->disconnected_f_op)\n\t\t\t\tfops_put(mfile->disconnected_f_op);\n\t\t\tfound = mfile;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&card->files_lock);\n\tif (!found) {\n\t\tdev_err(card->dev, \"card file remove problem (%p)\\n\", file);\n\t\treturn -ENOENT;\n\t}\n\tkfree(found);\n\tput_device(&card->card_dev);\n\treturn 0;\n}", "target": 0}
{"code": "int dccp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\tconst int flags = msg->msg_flags;\n\tconst int noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb;\n\tint rc, size;\n\tlong timeo;\n\tif (len > dp->dccps_mss_cache)\n\t\treturn -EMSGSIZE;\n\tlock_sock(sk);\n\tif (dccp_qpolicy_full(sk)) {\n\t\trc = -EAGAIN;\n\t\tgoto out_release;\n\t}\n\ttimeo = sock_sndtimeo(sk, noblock);\n\tif ((1 << sk->sk_state) & ~(DCCPF_OPEN | DCCPF_PARTOPEN))\n\t\tif ((rc = sk_stream_wait_connect(sk, &timeo)) != 0)\n\t\t\tgoto out_release;\n\tsize = sk->sk_prot->max_header + len;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (skb == NULL)\n\t\tgoto out_release;\n\tskb_reserve(skb, sk->sk_prot->max_header);\n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\trc = dccp_msghdr_parse(msg, skb);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\tdccp_qpolicy_push(sk, skb);\n\tif (!timer_pending(&dp->dccps_xmit_timer))\n\t\tdccp_write_xmit(sk);\nout_release:\n\trelease_sock(sk);\n\treturn rc ? : len;\nout_discard:\n\tkfree_skb(skb);\n\tgoto out_release;\n}", "target": 0}
{"code": "int RGWHandler_REST_S3Website::serve_errordoc(int http_ret, const string& errordoc_key) {\n  int ret = 0;\n  s->formatter->reset(); \n  std::shared_ptr<RGWGetObj_ObjStore_S3Website> getop( static_cast<RGWGetObj_ObjStore_S3Website*>(op_get()));\n  if (getop.get() == NULL) {\n    return -1; \n  }\n  getop->init(store, s, this);\n  getop->range_str = NULL;\n  getop->if_mod = NULL;\n  getop->if_unmod = NULL;\n  getop->if_match = NULL;\n  getop->if_nomatch = NULL;\n  s->object = errordoc_key;\n  ret = init_permissions(getop.get());\n  if (ret < 0) {\n    ldpp_dout(s, 20) << \"serve_errordoc failed, init_permissions ret=\" << ret << dendl;\n    return -1; \n  }\n  ret = read_permissions(getop.get());\n  if (ret < 0) {\n    ldpp_dout(s, 20) << \"serve_errordoc failed, read_permissions ret=\" << ret << dendl;\n    return -1; \n  }\n  if (http_ret) {\n     getop->set_custom_http_response(http_ret);\n  }\n  ret = getop->init_processing();\n  if (ret < 0) {\n    ldpp_dout(s, 20) << \"serve_errordoc failed, init_processing ret=\" << ret << dendl;\n    return -1; \n  }\n  ret = getop->verify_op_mask();\n  if (ret < 0) {\n    ldpp_dout(s, 20) << \"serve_errordoc failed, verify_op_mask ret=\" << ret << dendl;\n    return -1; \n  }\n  ret = getop->verify_permission();\n  if (ret < 0) {\n    ldpp_dout(s, 20) << \"serve_errordoc failed, verify_permission ret=\" << ret << dendl;\n    return -1; \n  }\n  ret = getop->verify_params();\n  if (ret < 0) {\n    ldpp_dout(s, 20) << \"serve_errordoc failed, verify_params ret=\" << ret << dendl;\n    return -1; \n  }\n  getop->pre_exec();\n  getop->execute();\n  getop->complete();\n  return 0;\n}", "target": 0}
{"code": "struct kvm_memory_slot *gfn_to_memslot(struct kvm *kvm, gfn_t gfn)\n{\n\treturn __gfn_to_memslot(kvm_memslots(kvm), gfn);\n}", "target": 0}
{"code": "display_augmentation_data (const unsigned char * data, const bfd_size_type len)\n{\n  bfd_size_type i;\n  i = printf (_(\"  Augmentation data:    \"));\n  display_data (i, data, len);\n}", "target": 0}
{"code": "onig_get_callout_in_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->in;\n}", "target": 0}
{"code": "smb2_select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (requested) {\n\tcase Kerberos:\n\tcase RawNTLMSSP:\n\t\treturn requested;\n\tcase NTLMv2:\n\t\treturn RawNTLMSSP;\n\tcase Unspecified:\n\t\tif (server->sec_ntlmssp &&\n\t\t\t(global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn RawNTLMSSP;\n\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t(global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\treturn Kerberos;\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}", "target": 0}
{"code": "static inline bool skb_warn_if_lro(const struct sk_buff *skb)\n{\n\tconst struct skb_shared_info *shinfo = skb_shinfo(skb);\n\tif (skb_is_nonlinear(skb) && shinfo->gso_size != 0 &&\n\t    unlikely(shinfo->gso_type == 0)) {\n\t\t__skb_warn_lro_forwarding(skb);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static unsigned int userns_inum(void *ns)\n{\n\tstruct user_namespace *user_ns = ns;\n\treturn user_ns->proc_inum;\n}", "target": 0}
{"code": "static int f2fs_drop_inode(struct inode *inode)\n{\n\tint ret;\n\tif ((!inode_unhashed(inode) && inode->i_state & I_SYNC)) {\n\t\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tif (f2fs_is_atomic_file(inode))\n\t\t\t\tdrop_inmem_pages(inode);\n\t\t\tf2fs_destroy_extent_node(inode);\n\t\t\tsb_start_intwrite(inode->i_sb);\n\t\t\tf2fs_i_size_write(inode, 0);\n\t\t\tif (F2FS_HAS_BLOCKS(inode))\n\t\t\t\tf2fs_truncate(inode);\n\t\t\tsb_end_intwrite(inode->i_sb);\n\t\t\tfscrypt_put_encryption_info(inode, NULL);\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tatomic_dec(&inode->i_count);\n\t\t}\n\t\ttrace_f2fs_drop_inode(inode, 0);\n\t\treturn 0;\n\t}\n\tret = generic_drop_inode(inode);\n\ttrace_f2fs_drop_inode(inode, ret);\n\treturn ret;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(4, context->num_inputs());\n    const Tensor& gradient = context->input(0);\n    const Tensor& input = context->input(1);\n    OP_REQUIRES(context, input.IsSameSize(gradient),\n                InvalidArgument(\"gradient and input must be the same size\"));\n    const Tensor& min = context->input(2);\n    const Tensor& max = context->input(3);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(min.shape()),\n        InvalidArgument(\"`min` must be rank 0 but is rank \", min.dims()));\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(max.shape()),\n        InvalidArgument(\"`max` must be rank 0 but is rank \", max.dims()));\n    Tensor* grad_wrt_input;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &grad_wrt_input));\n    TensorShape scalar_shape;\n    Tensor* grad_wrt_min;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, scalar_shape, &grad_wrt_min));\n    Tensor* grad_wrt_max;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, scalar_shape, &grad_wrt_max));\n    FakeQuantWithMinMaxVarsGradientFunctor<Device> functor;\n    functor(context->eigen_device<Device>(), gradient.flat<float>(),\n            input.flat<float>(), min.scalar<float>(), max.scalar<float>(),\n            quant_min_, quant_max_, grad_wrt_input->flat<float>(),\n            grad_wrt_min->scalar<float>(), grad_wrt_max->scalar<float>());\n  }", "target": 0}
{"code": "int addattr64(struct nlmsghdr *n, int maxlen, int type, __u64 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u64));\n}", "target": 0}
{"code": "void *_af_realloc (void *p, size_t size)\n{\n\tif (size <= 0)\n\t{\n\t\t_af_error(AF_BAD_MALLOC, \"bad memory allocation size request %d\", size);\n\t\treturn NULL;\n\t}\n\tp = realloc(p, size);\n\tif (p == NULL)\n\t{\n\t\t_af_error(AF_BAD_MALLOC, \"allocation of %d bytes failed\", size);\n\t\treturn NULL;\n\t}\n\treturn p;\n}", "target": 0}
{"code": "linux_md_start_data_unref (LinuxMdStartData *data)\n{\n  data->refcount--;\n  if (data->refcount == 0)\n    {\n      g_object_unref (data->daemon);\n      g_free (data->uuid);\n      g_free (data);\n    }\n}", "target": 0}
{"code": "  Selector_Schema_Obj Parser::parse_selector_schema(const char* end_of_selector, bool chroot)\n  {\n    NESTING_GUARD(nestings);\n    lex< optional_spaces >();\n    const char* i = position;\n    String_Schema_Ptr schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    Selector_Schema_Obj selector_schema = SASS_MEMORY_NEW(Selector_Schema, pstate, schema);\n    selector_schema->connect_parent(chroot == false);\n    selector_schema->media_block(last_media_block);\n    while (i < end_of_selector) {\n      if (const char* p = find_first_in_interval< exactly<hash_lbrace>, block_comment >(i, end_of_selector)) {\n        if (i < p) {\n          std::string parsed(i, p);\n          String_Constant_Obj str = SASS_MEMORY_NEW(String_Constant, pstate, parsed);\n          pstate += Offset(parsed);\n          str->update_pstate(pstate);\n          schema->append(str);\n        }\n        const char* j = skip_over_scopes< exactly<hash_lbrace>, exactly<rbrace> >(p + 2, end_of_selector);\n        if (!j || peek < sequence < optional_spaces, exactly<rbrace> > >(p+2)) {\n          position = p+2;\n          css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");\n        }\n        pstate.add(p, p+2);\n        Expression_Obj interpolant = Parser::from_c_str(p+2, j, ctx, traces, pstate).parse_list();\n        interpolant->is_interpolant(true);\n        schema->append(interpolant);\n        pstate.add(p+2, j);\n        i = j;\n      }\n      else {\n        if (i < end_of_selector) {\n          std::string parsed(i, end_of_selector);\n          String_Constant_Obj str = SASS_MEMORY_NEW(String_Constant, pstate, parsed);\n          pstate += Offset(parsed);\n          str->update_pstate(pstate);\n          i = end_of_selector;\n          schema->append(str);\n        }\n      }\n    }\n    position = i;\n    selector_schema->update_pstate(pstate);\n    schema->update_pstate(pstate);\n    after_token = before_token = pstate;\n    return selector_schema.detach();\n  }", "target": 0}
{"code": "static int fsmRemove(int dirfd, const char *path, mode_t mode)\n{\n    return S_ISDIR(mode) ? fsmRmdir(dirfd, path) : fsmUnlink(dirfd, path);\n}", "target": 0}
{"code": "bgp_attr_community (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;  \n  const bgp_size_t length = args->length;\n  if (length == 0)\n    {\n      attr->community = NULL;\n      return BGP_ATTR_PARSE_PROCEED;\n    }\n  attr->community =\n    community_parse ((u_int32_t *)stream_pnt (peer->ibuf), length);\n  stream_forward_getp (peer->ibuf, length);\n  if (!attr->community)\n    return bgp_attr_malformed (args,\n                               BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n                               args->total);\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);\n  return BGP_ATTR_PARSE_PROCEED;\n}", "target": 0}
{"code": "static bool may_access_direct_pkt_data(struct bpf_verifier_env *env,\n\t\t\t\t       const struct bpf_call_arg_meta *meta,\n\t\t\t\t       enum bpf_access_type t)\n{\n\tswitch (env->prog->type) {\n\tcase BPF_PROG_TYPE_LWT_IN:\n\tcase BPF_PROG_TYPE_LWT_OUT:\n\tcase BPF_PROG_TYPE_LWT_SEG6LOCAL:\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tif (t == BPF_WRITE)\n\t\t\treturn false;\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\tcase BPF_PROG_TYPE_XDP:\n\tcase BPF_PROG_TYPE_LWT_XMIT:\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\t\tif (meta)\n\t\t\treturn meta->pkt_access;\n\t\tenv->seen_direct_write = true;\n\t\treturn true;\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\tif (t == BPF_WRITE)\n\t\t\tenv->seen_direct_write = true;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}", "target": 0}
{"code": "ref_stack_enum_begin(ref_stack_enum_t *prse, const ref_stack_t *pstack)\n{\n    prse->block = (ref_stack_block *)pstack->current.value.refs;\n    prse->ptr = pstack->bot;\n    prse->size = pstack->p + 1 - pstack->bot;\n}", "target": 0}
{"code": "DLLIMPORT const char *cfg_opt_name(cfg_opt_t *opt)\n{\n\tif (opt)\n\t\treturn opt->name;\n\treturn NULL;\n}", "target": 0}
{"code": "    template<typename t, typename tc>\n    CImg<T>& draw_gaussian(const float xc, const float yc, const CImg<t>& tensor,\n                           const tc *const color, const float opacity=1) {\n      if (is_empty()) return *this;\n      if (tensor._width!=2 || tensor._height!=2 || tensor._depth!=1 || tensor._spectrum!=1)\n        throw CImgArgumentException(_cimg_instance\n                                    \"draw_gaussian(): Specified tensor (%u,%u,%u,%u,%p) is not a 2x2 matrix.\",\n                                    cimg_instance,\n                                    tensor._width,tensor._height,tensor._depth,tensor._spectrum,tensor._data);\n      if (!color)\n        throw CImgArgumentException(_cimg_instance\n                                    \"draw_gaussian(): Specified color is (null).\",\n                                    cimg_instance);\n      typedef typename CImg<t>::Tfloat tfloat;\n      const CImg<tfloat> invT = tensor.get_invert(), invT2 = (invT*invT)/(-2.0);\n      const tfloat a = invT2(0,0), b = 2*invT2(1,0), c = invT2(1,1);\n      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.0f);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      const tc *col = color;\n      float dy = -yc;\n      cimg_forY(*this,y) {\n        float dx = -xc;\n        cimg_forX(*this,x) {\n          const float val = (float)std::exp(a*dx*dx + b*dx*dy + c*dy*dy);\n          T *ptrd = data(x,y,0,0);\n          if (opacity>=1) cimg_forC(*this,c) { *ptrd = (T)(val*(*col++)); ptrd+=whd; }\n          else cimg_forC(*this,c) { *ptrd = (T)(nopacity*val*(*col++) + *ptrd*copacity); ptrd+=whd; }\n          col-=_spectrum;\n          ++dx;\n        }\n        ++dy;\n      }\n      return *this;", "target": 0}
{"code": "table_map Item_ref::used_tables() const\t\t\n{\n  return get_depended_from() ? OUTER_REF_TABLE_BIT : (*ref)->used_tables(); \n}", "target": 0}
{"code": "LayerTilerChromium::Tile* LayerTilerChromium::createTile(int i, int j)\n{\n    const int index = tileIndex(i, j);\n    ASSERT(!m_tiles[index]);\n    if (m_unusedTiles.size() > 0) {\n        m_tiles[index] = m_unusedTiles.last().release();\n        m_unusedTiles.removeLast();\n    } else {\n        GraphicsContext3D* context = layerRendererContext();\n        TextureManager* manager = layerRenderer()->textureManager();\n        OwnPtr<Tile> tile = adoptPtr(new Tile(LayerTexture::create(context, manager)));\n        m_tiles[index] = tile.release();\n    }\n    m_tiles[index]->m_dirtyLayerRect = tileLayerRect(i, j);\n    return m_tiles[index].get();\n}", "target": 0}
{"code": "int nfs_wb_all(struct inode *inode)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\treturn sync_inode(inode, &wbc);\n}", "target": 0}
{"code": "static char *find_line(char *buf_start, char *buf_end, char *name,\n\t\t       char *net_type, char *net_link, char *net_dev,\n\t\t       bool *owner, bool *found, bool *keep)\n{\n\tchar *end_of_line, *end_of_word, *line;\n\twhile (buf_start < buf_end) {\n\t\tsize_t len;\n\t\tchar netdev_name[IFNAMSIZ];\n\t\t*found = false;\n\t\t*keep = true;\n\t\t*owner = false;\n\t\tend_of_line = get_eol(buf_start, buf_end);\n\t\tif (end_of_line >= buf_end)\n\t\t\treturn NULL;\n\t\tline = buf_start;\n\t\tif (*buf_start == '#')\n\t\t\tgoto next;\n\t\twhile ((buf_start < buf_end) && isblank(*buf_start))\n\t\t\tbuf_start++;\n\t\tend_of_word = get_eow(buf_start, buf_end);\n\t\tif (!end_of_word)\n\t\t\treturn NULL;\n\t\tif (strncmp(buf_start, name, strlen(name)))\n\t\t\t*found = false;\n\t\t*owner = true;\n\t\tbuf_start = end_of_word + 1;\n\t\twhile ((buf_start < buf_end) && isblank(*buf_start))\n\t\t\tbuf_start++;\n\t\tend_of_word = get_eow(buf_start, buf_end);\n\t\tif (!end_of_word)\n\t\t\treturn NULL;\n\t\tif (strncmp(buf_start, net_type, strlen(net_type)))\n\t\t\t*found = false;\n\t\tbuf_start = end_of_word + 1;\n\t\twhile ((buf_start < buf_end) && isblank(*buf_start))\n\t\t\tbuf_start++;\n\t\tend_of_word = get_eow(buf_start, buf_end);\n\t\tif (!end_of_word)\n\t\t\treturn NULL;\n\t\tif (strncmp(buf_start, net_link, strlen(net_link)))\n\t\t\t*found = false;\n\t\tbuf_start = end_of_word + 1;\n\t\twhile ((buf_start < buf_end) && isblank(*buf_start))\n\t\t\tbuf_start++;\n\t\tend_of_word = get_eow(buf_start, buf_end);\n\t\tif (!end_of_word)\n\t\t\treturn NULL;\n\t\tlen = end_of_word - buf_start;\n\t\tif (len >= IFNAMSIZ)\n\t\t\treturn NULL;\n\t\tmemcpy(netdev_name, buf_start, len);\n\t\tnetdev_name[len] = '\\0';\n\t\t*keep = lxc_nic_exists(netdev_name);\n\t\tif (net_dev && !strcmp(netdev_name, net_dev))\n\t\t\t*found = true;\n\t\treturn line;\n\tnext:\n\t\tbuf_start = end_of_line + 1;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static void udhcp_run_script(struct dhcp_packet *packet, const char *name)\n{\n\tchar **envp, **curr;\n\tchar *argv[3];\n\tenvp = fill_envp(packet);\n\tlog1(\"Executing %s %s\", client_config.script, name);\n\targv[0] = (char*) client_config.script;\n\targv[1] = (char*) name;\n\targv[2] = NULL;\n\tspawn_and_wait(argv);\n\tfor (curr = envp; *curr; curr++) {\n\t\tlog2(\" %s\", *curr);\n\t\tbb_unsetenv_and_free(*curr);\n\t}\n\tfree(envp);\n}", "target": 0}
{"code": "static PixelList **DestroyPixelListThreadSet(PixelList **pixel_list)\n{\n  ssize_t\n    i;\n  assert(pixel_list != (PixelList **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixel_list[i] != (PixelList *) NULL)\n      pixel_list[i]=DestroyPixelList(pixel_list[i]);\n  pixel_list=(PixelList **) RelinquishMagickMemory(pixel_list);\n  return(pixel_list);\n}", "target": 0}
{"code": "static void _ewk_view_on_focus_out(void* data, Evas* eventType, Evas_Object* callback, void* eventInfo)\n{\n    Ewk_View_Smart_Data* smartData = static_cast<Ewk_View_Smart_Data*>(data);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api->focus_out);\n    smartData->api->focus_out(smartData);\n}", "target": 0}
{"code": "bool AccessibilityUIElement::isFocusable() const\n{\n    return checkElementState(m_element, ATK_STATE_FOCUSABLE);\n}", "target": 0}
{"code": "static void alloc_curl_handle(php_curl **ch)\n{\n\t*ch                           = emalloc(sizeof(php_curl));\n\t(*ch)->to_free                = ecalloc(1, sizeof(struct _php_curl_free));\n\t(*ch)->handlers               = ecalloc(1, sizeof(php_curl_handlers));\n\t(*ch)->handlers->write        = ecalloc(1, sizeof(php_curl_write));\n\t(*ch)->handlers->write_header = ecalloc(1, sizeof(php_curl_write));\n\t(*ch)->handlers->read         = ecalloc(1, sizeof(php_curl_read));\n\t(*ch)->handlers->progress     = NULL;\n#if LIBCURL_VERSION_NUM >= 0x071500 \n\t(*ch)->handlers->fnmatch      = NULL;\n#endif\n\t(*ch)->in_callback = 0;\n\t(*ch)->header.str_len = 0;\n\tmemset(&(*ch)->err, 0, sizeof((*ch)->err));\n\t(*ch)->handlers->write->stream = NULL;\n\t(*ch)->handlers->write_header->stream = NULL;\n\t(*ch)->handlers->read->stream = NULL;\n\tzend_llist_init(&(*ch)->to_free->str,   sizeof(char *),            (llist_dtor_func_t) curl_free_string, 0);\n\tzend_llist_init(&(*ch)->to_free->post,  sizeof(struct HttpPost),   (llist_dtor_func_t) curl_free_post,   0);\n\t(*ch)->safe_upload = 1; \n\t(*ch)->to_free->slist = emalloc(sizeof(HashTable));\n\tzend_hash_init((*ch)->to_free->slist, 4, NULL, curl_free_slist, 0);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, OrOfAnd5) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    runQuery(\n        fromjson(\"{$or: [{a:{$gt:1,$lt:5}, c:6}, \"\n                 \"{a:3, b:{$gt:1,$lt:2}, c:{$gt:0,$lt:10}}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{or: {nodes: [\"\n        \"{fetch: {filter: {c:6}, node: {ixscan: {pattern: {a:1,b:1}, \"\n        \"bounds: {a: [[1,5,false,false]], \"\n        \"b: [['MinKey','MaxKey',true,true]]}}}}}, \"\n        \"{fetch: {filter: {$and:[{c:{$lt:10}},{c:{$gt:0}}]}, node: \"\n        \"{ixscan: {pattern: {a:1,b:1}, \"\n        \" bounds: {a:[[3,3,true,true]], b:[[1,2,false,false]]}}}}}]}}\");\n}", "target": 0}
{"code": "int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->arch.mtrr_state.have_fixed = 1;\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tr = kvm_vcpu_reset(vcpu);\n\tif (r == 0)\n\t\tr = kvm_mmu_setup(vcpu);\n\tvcpu_put(vcpu);\n\treturn r;\n}", "target": 0}
{"code": "static tjhandle _tjInitDecompress(tjinstance *this)\n{\n\tstatic unsigned char buffer[1];\n\tthis->dinfo.err=jpeg_std_error(&this->jerr.pub);\n\tthis->jerr.pub.error_exit=my_error_exit;\n\tthis->jerr.pub.output_message=my_output_message;\n\tthis->jerr.emit_message=this->jerr.pub.emit_message;\n\tthis->jerr.pub.emit_message=my_emit_message;\n\tif(setjmp(this->jerr.setjmp_buffer))\n\t{\n\t\tif(this) free(this);\n\t\treturn NULL;\n\t}\n\tjpeg_create_decompress(&this->dinfo);\n\tjpeg_mem_src_tj(&this->dinfo, buffer, 1);\n\tthis->init|=DECOMPRESS;\n\treturn (tjhandle)this;\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_shutdown_ack_sent_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\treturn sctp_sf_shutdown_sent_abort(net, ep, asoc, type, arg, commands);\n}", "target": 0}
{"code": "static int process_ref_v2(const char *line, struct ref ***list)\n{\n\tint ret = 1;\n\tint i = 0;\n\tstruct object_id old_oid;\n\tstruct ref *ref;\n\tstruct string_list line_sections = STRING_LIST_INIT_DUP;\n\tconst char *end;\n\tif (string_list_split(&line_sections, line, ' ', -1) < 2) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tif (parse_oid_hex(line_sections.items[i++].string, &old_oid, &end) ||\n\t    *end) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tref = alloc_ref(line_sections.items[i++].string);\n\toidcpy(&ref->old_oid, &old_oid);\n\t**list = ref;\n\t*list = &ref->next;\n\tfor (; i < line_sections.nr; i++) {\n\t\tconst char *arg = line_sections.items[i].string;\n\t\tif (skip_prefix(arg, \"symref-target:\", &arg))\n\t\t\tref->symref = xstrdup(arg);\n\t\tif (skip_prefix(arg, \"peeled:\", &arg)) {\n\t\t\tstruct object_id peeled_oid;\n\t\t\tchar *peeled_name;\n\t\t\tstruct ref *peeled;\n\t\t\tif (parse_oid_hex(arg, &peeled_oid, &end) || *end) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpeeled_name = xstrfmt(\"%s^{}\", ref->name);\n\t\t\tpeeled = alloc_ref(peeled_name);\n\t\t\toidcpy(&peeled->old_oid, &peeled_oid);\n\t\t\t**list = peeled;\n\t\t\t*list = &peeled->next;\n\t\t\tfree(peeled_name);\n\t\t}\n\t}\nout:\n\tstring_list_clear(&line_sections, 0);\n\treturn ret;\n}", "target": 0}
{"code": "  Handle<String> ToString() const {\n    if (str_)\n      return String::New(str_, size_);\n    else\n      return String::Empty();\n  }", "target": 0}
{"code": "  void write(DYNAMIC_STRING* ds)\n  {\n    DBUG_ENTER(\"LogFile::write\");\n    DBUG_ASSERT(m_file);\n    if (ds->length == 0)\n      DBUG_VOID_RETURN;\n    DBUG_ASSERT(ds->str);\n#ifdef EXTRA_DEBUG\n    DBUG_PRINT(\"QQ\", (\"str: %*s\", (int) ds->length, ds->str));\n#endif\n    if (fwrite(ds->str, 1, ds->length, m_file) != ds->length)\n      die(\"Failed to write %lu bytes to '%s', errno: %d\",\n          (unsigned long)ds->length, m_file_name, errno);\n    m_bytes_written+= ds->length;\n    DBUG_VOID_RETURN;\n  }", "target": 0}
{"code": "get_text_gray_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE gray = read_pbm_integer(cinfo, infile, maxval);\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE gray = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "TEST_F(HeaderUtilityTest, RemovePortsFromHost) {\n  const std::vector<std::pair<std::string, std::string>> host_headers{\n      {\"localhost\", \"localhost\"},           \n      {\"localhost:443\", \"localhost\"},       \n      {\"\", \"\"},                             \n      {\":443\", \"\"},                         \n      {\"192.168.1.1\", \"192.168.1.1\"},       \n      {\"192.168.1.1:443\", \"192.168.1.1\"},   \n      {\"[fc00::1]:443\", \"[fc00::1]\"},       \n      {\"[fc00::1]\", \"[fc00::1]\"},           \n      {\":\", \":\"},                           \n      {\"]:\", \"]:\"},                         \n      {\":abc\", \":abc\"},                     \n      {\"localhost:80\", \"localhost:80\"},     \n      {\"192.168.1.1:80\", \"192.168.1.1:80\"}, \n      {\"[fc00::1]:80\", \"[fc00::1]:80\"}      \n  };\n  for (const auto& host_pair : host_headers) {\n    auto& host_header = hostHeaderEntry(host_pair.first);\n    HeaderUtility::stripPortFromHost(headers_, 443);\n    EXPECT_EQ(host_header.value().getStringView(), host_pair.second);\n  }\n}", "target": 0}
{"code": "dhcpv6_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint16_t type, optlen;\n    i = 0;\n    while (i < length) {\n        if (i + 4 > length)\n            return -1;\n        tlv = cp + i;\n        type = EXTRACT_16BITS(tlv);\n        optlen = EXTRACT_16BITS(tlv + 2);\n        value = tlv + 4;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n        ND_PRINT((ndo, \"%s\", tok2str(dh6opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 4 ));\n        if (i + 4 + optlen > length)\n            return -1;\n        switch (type) {\n            case DH6OPT_DNS_SERVERS:\n            case DH6OPT_SNTP_SERVERS: {\n                if (optlen % 16 != 0) {\n                    ND_PRINT((ndo, \" %s\", istr));\n                    return -1;\n                }\n                for (t = 0; t < optlen; t += 16)\n                    ND_PRINT((ndo, \" %s\", ip6addr_string(ndo, value + t)));\n            }\n                break;\n            case DH6OPT_DOMAIN_LIST: {\n                const u_char *tp = value;\n                while (tp < value + optlen) {\n                    ND_PRINT((ndo, \" \"));\n                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                        return -1;\n                }\n            }\n                break;\n        }\n        i += 4 + optlen;\n    }\n    return 0;\n}", "target": 0}
{"code": "int copy_page_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tstruct vm_area_struct *vma)\n{\n\tpgd_t *src_pgd, *dst_pgd;\n\tunsigned long next;\n\tunsigned long addr = vma->vm_start;\n\tunsigned long end = vma->vm_end;\n\tif (!(vma->vm_flags & (VM_HUGETLB|VM_NONLINEAR|VM_PFNMAP|VM_INSERTPAGE))) {\n\t\tif (!vma->anon_vma)\n\t\t\treturn 0;\n\t}\n\tif (is_vm_hugetlb_page(vma))\n\t\treturn copy_hugetlb_page_range(dst_mm, src_mm, vma);\n\tdst_pgd = pgd_offset(dst_mm, addr);\n\tsrc_pgd = pgd_offset(src_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(src_pgd))\n\t\t\tcontinue;\n\t\tif (copy_pud_range(dst_mm, src_mm, dst_pgd, src_pgd,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pgd++, src_pgd++, addr = next, addr != end);\n\treturn 0;\n}", "target": 0}
{"code": "static inline int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & ((1 << 16) - 1);\n}", "target": 0}
{"code": "static inline void GetStandardDeviationPixelList(PixelList *pixel_list,\n  Quantum *pixel)\n{\n  double\n    sum,\n    sum_squared;\n  register SkipList\n    *p;\n  size_t\n    color;\n  ssize_t\n    count;\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  sum_squared=0.0;\n  do\n  {\n    register ssize_t\n      i;\n    color=p->nodes[color].next[0];\n    sum+=(double) p->nodes[color].count*color;\n    for (i=0; i < (ssize_t) p->nodes[color].count; i++)\n      sum_squared+=((double) color)*((double) color);\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  sum_squared/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sqrt(sum_squared-(sum*sum)));\n}", "target": 0}
{"code": "void Splash::pipeRunAARGB8(SplashPipe *pipe) {\n  Guchar aSrc, aDest, alpha2, aResult;\n  SplashColor cDest;\n  Guchar cResult0, cResult1, cResult2;\n  cDest[0] = pipe->destColorPtr[0];\n  cDest[1] = pipe->destColorPtr[1];\n  cDest[2] = pipe->destColorPtr[2];\n  aDest = *pipe->destAlphaPtr;\n  aSrc = div255(pipe->aInput * pipe->shape);\n  aResult = aSrc + aDest - div255(aSrc * aDest);\n  alpha2 = aResult;\n  if (alpha2 == 0) {\n    cResult0 = 0;\n    cResult1 = 0;\n    cResult2 = 0;\n  } else {\n    cResult0 = state->rgbTransferR[(Guchar)(((alpha2 - aSrc) * cDest[0] +\n\t\t\t\t\t     aSrc * pipe->cSrc[0]) / alpha2)];\n    cResult1 = state->rgbTransferG[(Guchar)(((alpha2 - aSrc) * cDest[1] +\n\t\t\t\t\t     aSrc * pipe->cSrc[1]) / alpha2)];\n    cResult2 = state->rgbTransferB[(Guchar)(((alpha2 - aSrc) * cDest[2] +\n\t\t\t\t\t     aSrc * pipe->cSrc[2]) / alpha2)];\n  }\n  *pipe->destColorPtr++ = cResult0;\n  *pipe->destColorPtr++ = cResult1;\n  *pipe->destColorPtr++ = cResult2;\n  *pipe->destAlphaPtr++ = aResult;\n  ++pipe->x;\n}", "target": 0}
{"code": "static inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}", "target": 0}
{"code": "update_string_node_case_fold(regex_t* reg, Node *node)\n{\n  UChar *p, *end, buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar *sbuf, *ebuf, *sp;\n  int r, i, len;\n  OnigDistance sbuf_size;\n  StrNode* sn = NSTR(node);\n  end = sn->end;\n  sbuf_size = (end - sn->s) * 2;\n  sbuf = (UChar* )xmalloc(sbuf_size);\n  CHECK_NULL_RETURN_MEMERR(sbuf);\n  ebuf = sbuf + sbuf_size;\n  sp = sbuf;\n  p = sn->s;\n  while (p < end) {\n    len = ONIGENC_MBC_CASE_FOLD(reg->enc, reg->case_fold_flag, &p, end, buf);\n    for (i = 0; i < len; i++) {\n      if (sp >= ebuf) {\n\tUChar* p = (UChar* )xrealloc(sbuf, sbuf_size * 2);\n\tif (IS_NULL(p)) {\n\t  xfree(sbuf);\n\t  return ONIGERR_MEMORY;\n\t}\n\tsbuf = p;\n\tsp = sbuf + sbuf_size;\n\tsbuf_size *= 2;\n\tebuf = sbuf + sbuf_size;\n      }\n      *sp++ = buf[i];\n    }\n  }\n  r = onig_node_str_set(node, sbuf, sp);\n  xfree(sbuf);\n  return r;\n}", "target": 0}
{"code": "ModuleExport size_t RegisterPDFImage(void)\n{\n  MagickInfo\n    *entry;\n  entry=AcquireMagickInfo(\"PDF\",\"AI\",\"Adobe Illustrator CS2\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"EPDF\",\n    \"Encapsulated Portable Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"PDF\",\"Portable Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->magick=(IsImageFormatHandler *) IsPDF;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"PDFA\",\"Portable Document Archive Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->magick=(IsImageFormatHandler *) IsPDF;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "getRuleCharsText (FileInfo * nested, CharsString * ruleChars)\n{\n  CharsString token;\n  if (getToken (nested, &token, \"Characters operand\"))\n    if (parseChars (nested, ruleChars, &token))\n      return 1;\n  return 0;\n}", "target": 0}
{"code": "int in_gate_area_no_task(unsigned long addr)\n{\n#ifdef AT_SYSINFO_EHDR\n\tif ((addr >= FIXADDR_USER_START) && (addr < FIXADDR_USER_END))\n\t\treturn 1;\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "storagePoolGetAutostart(virStoragePoolPtr pool,\n                        int *autostart)\n{\n    virStoragePoolObj *obj;\n    int ret = -1;\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return -1;\n    if (virStoragePoolGetAutostartEnsureACL(pool->conn,\n                                            virStoragePoolObjGetDef(obj)) < 0)\n        goto cleanup;\n    *autostart = virStoragePoolObjIsAutostart(obj) ? 1 : 0;\n    ret = 0;\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}", "target": 0}
{"code": "static long add_reservation_in_range(struct resv_map *resv, long f, long t,\n\t\t\t\t     struct hugetlb_cgroup *h_cg,\n\t\t\t\t     struct hstate *h, long *regions_needed)\n{\n\tlong add = 0;\n\tstruct list_head *head = &resv->regions;\n\tlong last_accounted_offset = f;\n\tstruct file_region *rg = NULL, *trg = NULL;\n\tif (regions_needed)\n\t\t*regions_needed = 0;\n\tlist_for_each_entry_safe(rg, trg, head, link) {\n\t\tif (rg->from < f) {\n\t\t\tif (rg->to > last_accounted_offset)\n\t\t\t\tlast_accounted_offset = rg->to;\n\t\t\tcontinue;\n\t\t}\n\t\tif (rg->from >= t)\n\t\t\tbreak;\n\t\tif (rg->from > last_accounted_offset)\n\t\t\tadd += hugetlb_resv_map_add(resv, rg,\n\t\t\t\t\t\t    last_accounted_offset,\n\t\t\t\t\t\t    rg->from, h, h_cg,\n\t\t\t\t\t\t    regions_needed);\n\t\tlast_accounted_offset = rg->to;\n\t}\n\tif (last_accounted_offset < t)\n\t\tadd += hugetlb_resv_map_add(resv, rg, last_accounted_offset,\n\t\t\t\t\t    t, h, h_cg, regions_needed);\n\treturn add;\n}", "target": 0}
{"code": "get_external_key_retries(struct sc_card *card, unsigned char kid, unsigned char *retries)\n{\n\tint r;\n\tstruct sc_apdu apdu;\n\tunsigned char random[16] = { 0 };\n\tr = sc_get_challenge(card, random, 8);\n\tLOG_TEST_RET(card->ctx, r, \"get challenge get_external_key_retries failed\");\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x82, 0x01, 0x80 | kid);\n\tapdu.resp = NULL;\n\tapdu.resplen = 0;\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU get_external_key_retries failed\");\n\tif (retries && ((0x63 == (apdu.sw1 & 0xff)) && (0xC0 == (apdu.sw2 & 0xf0)))) {\n\t\t*retries = (apdu.sw2 & 0x0f);\n\t\tr = SC_SUCCESS;\n\t}\n\telse {\n\t\tLOG_TEST_RET(card->ctx, r, \"get_external_key_retries failed\");\n\t\tr = SC_ERROR_CARD_CMD_FAILED;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "int kvm_read_guest_atomic(struct kvm *kvm, gpa_t gpa, void *data,\n\t\t\t  unsigned long len)\n{\n\tint r;\n\tunsigned long addr;\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint offset = offset_in_page(gpa);\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tpagefault_disable();\n\tr = __copy_from_user_inatomic(data, (void __user *)addr + offset, len);\n\tpagefault_enable();\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "static gchar *convert_to_hex(unsigned char *buf, int len)\n{\n\tgchar *ret = g_try_malloc(len * 2 + 1);\n\tint i;\n\tfor (i = 0; ret && i < len; i++)\n\t\tg_snprintf(ret + i * 2, 3, \"%02x\", buf[i]);\n\treturn ret;\n}", "target": 0}
{"code": "void GLSurfaceOzoneSurfaceless::SubmitFrame() {\n  DCHECK(!unsubmitted_frames_.empty());\n  if (unsubmitted_frames_.front()->ready && !swap_buffers_pending_) {\n    std::unique_ptr<PendingFrame> frame(unsubmitted_frames_.front());\n    unsubmitted_frames_.weak_erase(unsubmitted_frames_.begin());\n    swap_buffers_pending_ = true;\n    if (!frame->ScheduleOverlayPlanes(widget_)) {\n      frame->callback.Run(gfx::SwapResult::SWAP_FAILED);\n      return;\n    }\n    if (ozone_surface_->IsUniversalDisplayLinkDevice())\n      glFinish();\n    ozone_surface_->OnSwapBuffersAsync(frame->callback);\n  }\n}", "target": 0}
{"code": "sg_read_oxfer(Sg_request * srp, char __user *outp, int num_read_xfer)\n{\n\tSg_scatter_hold *schp = &srp->data;\n\tint k, num;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, srp->parentfp->parentdp,\n\t\t\t \"sg_read_oxfer: num_read_xfer=%d\\n\",\n\t\t\t num_read_xfer));\n\tif ((!outp) || (num_read_xfer <= 0))\n\t\treturn 0;\n\tnum = 1 << (PAGE_SHIFT + schp->page_order);\n\tfor (k = 0; k < schp->k_use_sg && schp->pages[k]; k++) {\n\t\tif (num > num_read_xfer) {\n\t\t\tif (__copy_to_user(outp, page_address(schp->pages[k]),\n\t\t\t\t\t   num_read_xfer))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (__copy_to_user(outp, page_address(schp->pages[k]),\n\t\t\t\t\t   num))\n\t\t\t\treturn -EFAULT;\n\t\t\tnum_read_xfer -= num;\n\t\t\tif (num_read_xfer <= 0)\n\t\t\t\tbreak;\n\t\t\toutp += num;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static double screen_units(double d)\n{\n\tswitch (screen.unit) {\n\tcase GERBV_INS:\n\t\treturn COORD2INS(d);\n\t\tbreak;\n\tcase GERBV_MILS:\n\t\treturn COORD2MILS(d);\n\t\tbreak;\n\tcase GERBV_MMS:\n\t\treturn COORD2MMS(d);\n\t\tbreak;\n\t}\n\treturn d;\n}", "target": 0}
{"code": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}", "target": 0}
{"code": "bool GLSurfaceOzoneSurfaceless::Resize(const gfx::Size& size,\n                                       float scale_factor,\n                                       bool has_alpha) {\n  if (!ozone_surface_->ResizeNativeWindow(size))\n    return false;\n  return SurfacelessEGL::Resize(size, scale_factor, has_alpha);\n}", "target": 0}
{"code": "void RenderView::runModal() {\n  DCHECK(did_show_) << \"should already have shown the view\";\n  if (RenderThread::current())  \n    RenderThread::current()->DoNotSuspendWebKitSharedTimer();\n  SendAndRunNestedMessageLoop(new ViewHostMsg_RunModal(routing_id_));\n}", "target": 0}
{"code": "int blkid_partlist_numof_partitions(blkid_partlist ls)\n{\n\treturn ls->nparts;\n}", "target": 0}
{"code": "void kvm_arch_hardware_disable(void)\n{\n\tkvm_x86_ops->hardware_disable();\n\tdrop_user_return_notifiers();\n}", "target": 0}
{"code": "static ssize_t vnc_client_read_plain(VncState *vs)\n{\n    ssize_t ret;\n    VNC_DEBUG(\"Read plain %p size %zd offset %zd\\n\",\n              vs->input.buffer, vs->input.capacity, vs->input.offset);\n    buffer_reserve(&vs->input, 4096);\n    ret = vnc_client_read_buf(vs, buffer_end(&vs->input), 4096);\n    if (!ret)\n        return 0;\n    vs->input.offset += ret;\n    return ret;\n}", "target": 0}
{"code": "_dupv8 (const char *s)\n{\n  const char *end_valid;\n  if (!g_utf8_validate (s, -1, &end_valid))\n    {\n      g_print (\"**** NOTE: The string '%s' is not valid UTF-8. Invalid characters begins at '%s'\\n\", s, end_valid);\n      return g_strndup (s, end_valid - s);\n    }\n  else\n    {\n      return g_strdup (s);\n    }\n}", "target": 0}
{"code": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t   u16 selector, int seg)\n {\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (seg == VCPU_SREG_SS && selector == 3 &&\n\t    ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn emulate_exception(ctxt, GP_VECTOR, 0, true);\n \treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n \t\t\t\t\t X86_TRANSFER_NONE, NULL);\n }", "target": 0}
{"code": "static void spl_heap_object_free_storage(void *object TSRMLS_DC) \n{\n\tint i;\n\tspl_heap_object *intern = (spl_heap_object *)object;\n\tzend_object_std_dtor(&intern->std TSRMLS_CC);\n\tfor (i = 0; i < intern->heap->count; ++i) {\n\t\tif (intern->heap->elements[i]) {\n\t\t\tzval_ptr_dtor((zval **)&intern->heap->elements[i]);\n\t\t}\n\t}\n\tspl_ptr_heap_destroy(intern->heap TSRMLS_CC);\n\tzval_ptr_dtor(&intern->retval);\n\tif (intern->debug_info != NULL) {\n\t\tzend_hash_destroy(intern->debug_info);\n\t\tefree(intern->debug_info);\n\t}\n\tefree(object);\n}", "target": 0}
{"code": "Item* Item::set_expr_cache(THD *thd)\n{\n  DBUG_ENTER(\"Item::set_expr_cache\");\n  Item_cache_wrapper *wrapper;\n  if ((wrapper= new Item_cache_wrapper(this)) &&\n      !wrapper->fix_fields(thd, (Item**)&wrapper))\n  {\n    if (wrapper->set_cache(thd))\n      DBUG_RETURN(NULL);\n    DBUG_RETURN(wrapper);\n  }\n  DBUG_RETURN(NULL);\n}", "target": 0}
{"code": "PS_READ_FUNC(files)\n{\n\tlong n;\n\tstruct stat sbuf;\n\tPS_FILES_DATA;\n\tif (PS(use_strict_mode) &&\n\t\tps_files_key_exists(data, key TSRMLS_CC) == FAILURE) {\n\t\tif (key) {\n\t\t\tefree(PS(id));\n\t\t\tPS(id) = NULL;\n\t\t}\n\t\tPS(id) = PS(mod)->s_create_sid((void **)&data, NULL TSRMLS_CC);\n\t\tif (!PS(id)) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (PS(use_cookies)) {\n\t\t\tPS(send_cookie) = 1;\n\t\t}\n\t\tphp_session_reset_id(TSRMLS_C);\n\t\tPS(session_status) = php_session_active;\n\t}\n\tif (!PS(id)) {\n\t\treturn FAILURE;\n\t}\n\tps_files_open(data, PS(id) TSRMLS_CC);\n\tif (data->fd < 0) {\n\t\treturn FAILURE;\n\t}\n\tif (fstat(data->fd, &sbuf)) {\n\t\treturn FAILURE;\n\t}\n\tdata->st_size = *vallen = sbuf.st_size;\n\tif (sbuf.st_size == 0) {\n\t\t*val = STR_EMPTY_ALLOC();\n\t\treturn SUCCESS;\n\t}\n\t*val = emalloc(sbuf.st_size);\n#if defined(HAVE_PREAD)\n\tn = pread(data->fd, *val, sbuf.st_size, 0);\n#else\n\tlseek(data->fd, 0, SEEK_SET);\n\tn = read(data->fd, *val, sbuf.st_size);\n#endif\n\tif (n != sbuf.st_size) {\n\t\tif (n == -1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"read failed: %s (%d)\", strerror(errno), errno);\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"read returned less bytes than requested\");\n\t\t}\n\t\tefree(*val);\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}", "target": 0}
{"code": "    const char* Xmpdatum::typeName() const\n    {\n        return TypeInfo::typeName(typeId());\n    }", "target": 0}
{"code": "void FrameLoader::setProvisionalDocumentLoader(DocumentLoader* loader)\n{\n    ASSERT(!loader || !m_provisionalDocumentLoader);\n    ASSERT(!loader || loader->frameLoader() == this);\n    if (m_provisionalDocumentLoader && m_provisionalDocumentLoader != m_documentLoader)\n        m_provisionalDocumentLoader->detachFromFrame();\n    m_provisionalDocumentLoader = loader;\n}", "target": 0}
{"code": "bgr2rgb (guchar       *dest,\n         const guchar *src,\n         guint         width,\n         guint         bytes,\n         guint         alpha)\n{\n  guint x;\n  if (alpha)\n    {\n      for (x = 0; x < width; x++)\n        {\n          *(dest++) = src[2];\n          *(dest++) = src[1];\n          *(dest++) = src[0];\n          *(dest++) = src[3];\n          src += bytes;\n        }\n    }\n  else\n    {\n      for (x = 0; x < width; x++)\n        {\n          *(dest++) = src[2];\n          *(dest++) = src[1];\n          *(dest++) = src[0];\n          src += bytes;\n        }\n    }\n}", "target": 0}
{"code": "void Item_param::print(String *str, enum_query_type query_type)\n{\n  if (state == NO_VALUE || query_type & QT_NO_DATA_EXPANSION)\n  {\n    str->append('?');\n  }\n  else\n  {\n    char buffer[STRING_BUFFER_USUAL_SIZE];\n    String tmp(buffer, sizeof(buffer), &my_charset_bin);\n    const String *res;\n    res= query_val_str(current_thd, &tmp);\n    str->append(*res);\n  }\n}", "target": 0}
{"code": "gen_retval(codegen_scope *s, node *tree)\n{\n  if (nint(tree->car) == NODE_SPLAT) {\n    codegen(s, tree, VAL);\n    pop();\n    genop_1(s, OP_ARYDUP, cursp());\n  }\n  else {\n    codegen(s, tree, VAL);\n    pop();\n  }\n}", "target": 0}
{"code": "static int compareByStringPairForQSort(const void* a, const void* b)\n{\n    const ValueStringPair* va = static_cast<const ValueStringPair*>(a);\n    const ValueStringPair* vb = static_cast<const ValueStringPair*>(b);\n    return codePointCompare(va->second, vb->second);\n}", "target": 0}
{"code": "static gg_action_t gg_handle_connecting(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)\n{\n\tint res;\n\tsess->soft_timeout = 0;\n\tif (gg_async_connect_failed(sess, &res)) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\tclose(sess->fd);\n\t\tsess->fd = -1;\n\t\tsess->resolver_index++;\n\t\tsess->state = alt_state;\n\t} else {\n\t\tif (sess->state != GG_STATE_CONNECTING_PROXY_HUB) {\n\t\t\tfree(sess->resolver_result);\n\t\t\tsess->resolver_result = NULL;\n\t\t}\n\t\tsess->state = next_state;\n\t}\n\treturn GG_ACTION_NEXT;\n}", "target": 0}
{"code": "passIsComma ()\n{\n  pass_Codes passCode = passGetScriptToken ();\n  if (passCode != pass_comma)\n    {\n      compileError (passNested, \"',' expected\");\n      return 0;\n    }\n  return 1;\n}", "target": 0}
{"code": "static void HEAD_fn(struct cgit_context *ctx)\n{\n\tcgit_clone_head(ctx);\n}", "target": 0}
{"code": "void ImageLoader::updatedHasPendingEvent() {\n  bool wasProtected = m_elementIsProtected;\n  m_elementIsProtected = m_hasPendingLoadEvent || m_hasPendingErrorEvent;\n  if (wasProtected == m_elementIsProtected)\n    return;\n  if (m_elementIsProtected) {\n    if (m_derefElementTimer.isActive())\n      m_derefElementTimer.stop();\n    else\n      m_keepAlive = m_element;\n  } else {\n    DCHECK(!m_derefElementTimer.isActive());\n    m_derefElementTimer.startOneShot(0, BLINK_FROM_HERE);\n  }\n}", "target": 0}
{"code": "smb2_query_dir_next(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    struct cifs_fid *fid, __u16 search_flags,\n\t\t    struct cifs_search_info *srch_inf)\n{\n\treturn SMB2_query_directory(xid, tcon, fid->persistent_fid,\n\t\t\t\t    fid->volatile_fid, 0, srch_inf);\n}", "target": 0}
{"code": "ignore_edge_p (cgraph_edge *e)\n{\n  enum availability avail;\n  cgraph_node *ultimate_target\n    = e->callee->function_or_virtual_thunk_symbol (&avail, e->caller);\n  return (avail <= AVAIL_INTERPOSABLE\n\t  || !opt_for_fn (ultimate_target->decl, optimize)\n\t  || !opt_for_fn (ultimate_target->decl, flag_ipa_cp));\n}", "target": 0}
{"code": "GF_Err stbl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\te = gf_isom_box_array_read(s, bs, stbl_on_child_box);\n\tif (e) return e;\n\tif (!ptr->SyncSample)\n\t\tptr->no_sync_found = 1;\n\tptr->nb_sgpd_in_stbl = gf_list_count(ptr->sampleGroupsDescription);\n\tptr->nb_stbl_boxes = gf_list_count(ptr->child_boxes);\n\tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_CLONE_TRACK)\n\t\treturn GF_OK;\n\tif (!ptr->SampleToChunk || !ptr->SampleSize || !ptr->ChunkOffset || !ptr->TimeToSample)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tif (ptr->SampleSize->sampleCount) {\n\t\tif (!ptr->TimeToSample->nb_entries || !ptr->SampleToChunk->nb_entries)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "PHP_FUNCTION(exif_imagetype)\n{\n\tchar *imagefile;\n\tsize_t imagefile_len;\n\tphp_stream * stream;\n \tint itype = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &imagefile, &imagefile_len) == FAILURE) {\n\t\treturn;\n\t}\n\tstream = php_stream_open_wrapper(imagefile, \"rb\", IGNORE_PATH|REPORT_ERRORS, NULL);\n\tif (stream == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\titype = php_getimagetype(stream, NULL);\n\tphp_stream_close(stream);\n\tif (itype == IMAGE_FILETYPE_UNKNOWN) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZVAL_LONG(return_value, itype);\n\t}\n}", "target": 0}
{"code": "int64 ClientUsageTracker::GetCachedGlobalUnlimitedUsage() {\n  if (!global_unlimited_usage_is_valid_) {\n    global_unlimited_usage_ = 0;\n    for (HostUsageMap::const_iterator host_iter = cached_usage_.begin();\n         host_iter != cached_usage_.end(); host_iter++) {\n      const UsageMap& origin_map = host_iter->second;\n      for (UsageMap::const_iterator origin_iter = origin_map.begin();\n           origin_iter != origin_map.end(); origin_iter++) {\n        if (IsStorageUnlimited(origin_iter->first))\n          global_unlimited_usage_ += origin_iter->second;\n      }\n    }\n    global_unlimited_usage_is_valid_ = true;\n  }\n  return global_unlimited_usage_;\n}", "target": 0}
{"code": "static const SSL_METHOD *ssl23_get_server_method(int ver)\n\t{\n#ifndef OPENSSL_NO_SSL2\n\tif (ver == SSL2_VERSION)\n\t\treturn(SSLv2_server_method());\n#endif\n#ifndef OPENSSL_NO_SSL3\n\tif (ver == SSL3_VERSION)\n\t\treturn(SSLv3_server_method());\n#endif\n\tif (ver == TLS1_VERSION)\n\t\treturn(TLSv1_server_method());\n\telse if (ver == TLS1_1_VERSION)\n\t\treturn(TLSv1_1_server_method());\n\telse if (ver == TLS1_2_VERSION)\n\t\treturn(TLSv1_2_server_method());\n\telse\n\t\treturn(NULL);\n\t}", "target": 0}
{"code": "usage (const char *prog)\n{\n\tg_print (\"- Lists file in a supported archive format\\n\");\n\tg_print (\"Usage: %s archive-type filename\\n\", prog);\n\tg_print (\"Where archive-type is one of rar, zip, 7z or tar\\n\");\n}", "target": 0}
{"code": "static void php_array_replace_recursive(PointerSet &seen, bool check,\n                                        Array &arr1, const Array& arr2) {\n  if (arr1.get() == arr2.get()) {\n    return;\n  }\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_replace_recursive(): recursion detected\");\n    return;\n  }\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key = iter.first();\n    const Variant& value = iter.secondRef();\n    if (arr1.exists(key, true) && value.isArray()) {\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      if (v.isArray()) {\n        Array subarr1 = v.toArray();\n        const ArrNR& arr_value = value.toArrNR();\n        php_array_replace_recursive(seen, couldRecur(v, subarr1.get()),\n                                    subarr1, arr_value);\n        v = subarr1;\n      } else {\n        arr1.set(key, value, true);\n      }\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}", "target": 0}
{"code": "protocol::ClipboardStub* ChromotingInstance::GetClipboardStub() {\n  return this;\n}", "target": 0}
{"code": "vg_ctrl_response(VuGpu *g,\n                 struct virtio_gpu_ctrl_command *cmd,\n                 struct virtio_gpu_ctrl_hdr *resp,\n                 size_t resp_len)\n{\n    size_t s;\n    if (cmd->cmd_hdr.flags & VIRTIO_GPU_FLAG_FENCE) {\n        resp->flags |= VIRTIO_GPU_FLAG_FENCE;\n        resp->fence_id = cmd->cmd_hdr.fence_id;\n        resp->ctx_id = cmd->cmd_hdr.ctx_id;\n    }\n    virtio_gpu_ctrl_hdr_bswap(resp);\n    s = iov_from_buf(cmd->elem.in_sg, cmd->elem.in_num, 0, resp, resp_len);\n    if (s != resp_len) {\n        g_critical(\"%s: response size incorrect %zu vs %zu\",\n                   __func__, s, resp_len);\n    }\n    vu_queue_push(&g->dev.parent, cmd->vq, &cmd->elem, s);\n    vu_queue_notify(&g->dev.parent, cmd->vq);\n    cmd->state = VG_CMD_STATE_FINISHED;\n}", "target": 0}
{"code": "static char *allocate_tempopt_if_needed(\n\t\tconst struct dhcp_optflag *optflag,\n\t\tchar *buffer,\n\t\tint *length_p)\n{\n\tchar *allocated = NULL;\n\tif ((optflag->flags & OPTION_TYPE_MASK) == OPTION_BIN) {\n\t\tconst char *end;\n\t\tallocated = xstrdup(buffer); \n\t\tend = hex2bin(allocated, buffer, 255);\n\t\tif (errno)\n\t\t\tbb_error_msg_and_die(\"malformed hex string '%s'\", buffer);\n\t\t*length_p = end - allocated;\n\t}\n\treturn allocated;\n}", "target": 0}
{"code": "static bool nested_vmx_exit_handled_msr(struct kvm_vcpu *vcpu,\n\tstruct vmcs12 *vmcs12, u32 exit_reason)\n{\n\tu32 msr_index = vcpu->arch.regs[VCPU_REGS_RCX];\n\tgpa_t bitmap;\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn 1;\n\tbitmap = vmcs12->msr_bitmap;\n\tif (exit_reason == EXIT_REASON_MSR_WRITE)\n\t\tbitmap += 2048;\n\tif (msr_index >= 0xc0000000) {\n\t\tmsr_index -= 0xc0000000;\n\t\tbitmap += 1024;\n\t}\n\tif (msr_index < 1024*8) {\n\t\tunsigned char b;\n\t\tif (kvm_read_guest(vcpu->kvm, bitmap + msr_index/8, &b, 1))\n\t\t\treturn 1;\n\t\treturn 1 & (b >> (msr_index & 7));\n\t} else\n\t\treturn 1; \n}", "target": 0}
{"code": "last_status(\n    int\t\tmorewin)\t\n{\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}", "target": 0}
{"code": "enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)\n{\n    while (*fmt != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt(*fmt))\n        ++fmt;\n    return fmt[0];\n}", "target": 0}
{"code": "void RGWGetBucketWebsite_ObjStore_S3::send_response()\n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n  if (op_ret < 0) {\n    return;\n  }\n  RGWBucketWebsiteConf& conf = s->bucket_info.website_conf;\n  s->formatter->open_object_section_in_ns(\"WebsiteConfiguration\", XMLNS_AWS_S3);\n  conf.dump_xml(s->formatter);\n  s->formatter->close_section(); \n  rgw_flush_formatter_and_reset(s, s->formatter);\n}", "target": 0}
{"code": "void ompl::geometric::VFRRT::updateExplorationEfficiency(Motion *m)\n{\n    Motion *near = nn_->nearest(m);\n    if (distanceFunction(m, near) < si_->getStateValidityCheckingResolution())\n        inefficientCount_++;\n    else\n        efficientCount_++;\n    explorationInefficiency_ = inefficientCount_ / (double)(efficientCount_ + inefficientCount_);\n}", "target": 0}
{"code": "fz_default_output_intent(fz_context *ctx, const fz_default_colorspaces *default_cs)\n{\n\tif (default_cs)\n\t\treturn default_cs->oi;\n\telse\n\t\treturn NULL;\n}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::HandleBeginQueryEXT(\n    uint32 immediate_data_size, const gles2::BeginQueryEXT& c) {\n  GLenum target = static_cast<GLenum>(c.target);\n  GLuint client_id = static_cast<GLuint>(c.id);\n  int32 sync_shm_id = static_cast<int32>(c.sync_data_shm_id);\n  uint32 sync_shm_offset = static_cast<uint32>(c.sync_data_shm_offset);\n  switch (target) {\n    case GL_COMMANDS_ISSUED_CHROMIUM:\n      break;\n    default:\n      if (!feature_info_->feature_flags().occlusion_query_boolean) {\n        SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT: not enabled\");\n        return error::kNoError;\n      }\n      break;\n  }\n  if (current_query_) {\n    SetGLError(\n        GL_INVALID_OPERATION, \"glBeginQueryEXT: query already in progress\");\n    return error::kNoError;\n  }\n  if (client_id == 0) {\n    SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT: id is 0\");\n    return error::kNoError;\n  }\n  QueryManager::Query* query = query_manager_->GetQuery(client_id);\n  if (!query) {\n    query = query_manager_->CreateQuery(\n        target, client_id, sync_shm_id, sync_shm_offset);\n  }\n  if (query->target() != target) {\n    SetGLError(GL_INVALID_OPERATION, \"glBeginQueryEXT: target does not match\");\n    return error::kNoError;\n  } else if (query->shm_id() != sync_shm_id ||\n             query->shm_offset() != sync_shm_offset) {\n    DLOG(ERROR) << \"Shared memory used by query not the same as before\";\n    return error::kInvalidArguments;\n  }\n  if (!query_manager_->BeginQuery(query)) {\n    return error::kOutOfBounds;\n  }\n  current_query_ = query;\n  return error::kNoError;\n}", "target": 0}
{"code": "Expression* WasmBinaryBuilder::popNonVoidExpression() {\n  auto* ret = popExpression();\n  if (ret->type != Type::none) {\n    return ret;\n  }\n  Builder builder(wasm);\n  std::vector<Expression*> expressions;\n  expressions.push_back(ret);\n  while (1) {\n    auto* curr = popExpression();\n    expressions.push_back(curr);\n    if (curr->type != Type::none) {\n      break;\n    }\n  }\n  auto* block = builder.makeBlock();\n  while (!expressions.empty()) {\n    block->list.push_back(expressions.back());\n    expressions.pop_back();\n  }\n  requireFunctionContext(\"popping void where we need a new local\");\n  auto type = block->list[0]->type;\n  if (type.isConcrete()) {\n    auto local = builder.addVar(currFunction, type);\n    block->list[0] = builder.makeLocalSet(local, block->list[0]);\n    block->list.push_back(builder.makeLocalGet(local, type));\n  } else {\n    assert(type == Type::unreachable);\n  }\n  block->finalize();\n  return block;\n}", "target": 0}
{"code": "void cpu_bugs_smt_update(void)\n{\n\tmutex_lock(&spec_ctrl_mutex);\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\tbreak;\n\tcase SPECTRE_V2_USER_STRICT:\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\tupdate_stibp_strict();\n\t\tbreak;\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tupdate_indir_branch_cond();\n\t\tbreak;\n\t}\n\tswitch (mds_mitigation) {\n\tcase MDS_MITIGATION_FULL:\n\tcase MDS_MITIGATION_VMWERV:\n\t\tif (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))\n\t\t\tpr_warn_once(MDS_MSG_SMT);\n\t\tupdate_mds_branch_idle();\n\t\tbreak;\n\tcase MDS_MITIGATION_OFF:\n\t\tbreak;\n\t}\n\tswitch (taa_mitigation) {\n\tcase TAA_MITIGATION_VERW:\n\tcase TAA_MITIGATION_UCODE_NEEDED:\n\t\tif (sched_smt_active())\n\t\t\tpr_warn_once(TAA_MSG_SMT);\n\t\tbreak;\n\tcase TAA_MITIGATION_TSX_DISABLED:\n\tcase TAA_MITIGATION_OFF:\n\t\tbreak;\n\t}\n\tmutex_unlock(&spec_ctrl_mutex);\n}", "target": 0}
{"code": "static int xenbus_file_release(struct inode *inode, struct file *filp)\n{\n\tstruct xenbus_file_priv *u = filp->private_data;\n\tstruct xenbus_transaction_holder *trans, *tmp;\n\tstruct watch_adapter *watch, *tmp_watch;\n\tstruct read_buffer *rb, *tmp_rb;\n\tlist_for_each_entry_safe(trans, tmp, &u->transactions, list) {\n\t\txenbus_transaction_end(trans->handle, 1);\n\t\tlist_del(&trans->list);\n\t\tkfree(trans);\n\t}\n\tlist_for_each_entry_safe(watch, tmp_watch, &u->watches, list) {\n\t\tunregister_xenbus_watch(&watch->watch);\n\t\tlist_del(&watch->list);\n\t\tfree_watch_adapter(watch);\n\t}\n\tlist_for_each_entry_safe(rb, tmp_rb, &u->read_buffers, list) {\n\t\tlist_del(&rb->list);\n\t\tkfree(rb);\n\t}\n\tkfree(u);\n\treturn 0;\n}", "target": 0}
{"code": "static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\tlsa->l2tp_family = AF_INET6;\n\tlsa->l2tp_flowinfo = 0;\n\tlsa->l2tp_scope_id = 0;\n\tlsa->l2tp_unused = 0;\n\tif (peer) {\n\t\tif (!lsk->peer_conn_id)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = np->daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&np->rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = np->rcv_saddr;\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}", "target": 0}
{"code": "static int sg_proc_seq_show_dev(struct seq_file *s, void *v)\n{\n\tstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\n\tSg_device *sdp;\n\tstruct scsi_device *scsidp;\n\tunsigned long iflags;\n\tread_lock_irqsave(&sg_index_lock, iflags);\n\tsdp = it ? sg_lookup_dev(it->index) : NULL;\n\tif ((NULL == sdp) || (NULL == sdp->device) ||\n\t    (atomic_read(&sdp->detaching)))\n\t\tseq_puts(s, \"-1\\t-1\\t-1\\t-1\\t-1\\t-1\\t-1\\t-1\\t-1\\n\");\n\telse {\n\t\tscsidp = sdp->device;\n\t\tseq_printf(s, \"%d\\t%d\\t%d\\t%llu\\t%d\\t%d\\t%d\\t%d\\t%d\\n\",\n\t\t\t      scsidp->host->host_no, scsidp->channel,\n\t\t\t      scsidp->id, scsidp->lun, (int) scsidp->type,\n\t\t\t      1,\n\t\t\t      (int) scsidp->queue_depth,\n\t\t\t      (int) atomic_read(&scsidp->device_busy),\n\t\t\t      (int) scsi_device_online(scsidp));\n\t}\n\tread_unlock_irqrestore(&sg_index_lock, iflags);\n\treturn 0;\n}", "target": 0}
{"code": "static int nfs41_check_expired_locks(struct nfs4_state *state)\n{\n\tint status, ret = -NFS4ERR_BAD_STATEID;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tlist_for_each_entry(lsp, &state->lock_states, ls_locks) {\n\t\tif (lsp->ls_flags & NFS_LOCK_INITIALIZED) {\n\t\t\tstatus = nfs41_test_stateid(server, &lsp->ls_stateid);\n\t\t\tif (status != NFS_OK) {\n\t\t\t\tif (status != -NFS4ERR_BAD_STATEID)\n\t\t\t\t\tnfs41_free_stateid(server,\n\t\t\t\t\t\t\t&lsp->ls_stateid);\n\t\t\t\tlsp->ls_flags &= ~NFS_LOCK_INITIALIZED;\n\t\t\t\tret = status;\n\t\t\t}\n\t\t}\n\t};\n\treturn ret;\n}", "target": 0}
{"code": "video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,", "target": 0}
{"code": "blink::WebView* FrameReference::view() {\n  return view_;\n}", "target": 0}
{"code": "void rw_curr_act_stats(int ifd, int *curr, long *cnt, int *eosaf,\n\t\t       unsigned int act_id, int *reset, struct file_activity *file_actlst,\n\t\t       struct tm *rectime, char *file,\n\t\t       struct file_magic *file_magic)\n{\n\tint rtype;\n\tint next, reset_cd;\n\tseek_file_position(ifd, DO_RESTORE);\n\tif (DISPLAY_FIELD_LIST(fmt[f_position]->options)) {\n\t\tlist_fields(act_id);\n\t}\n\tcopy_structures(act, id_seq, record_hdr, !*curr, 2);\n\t*cnt  = count;\n\treset_cd = 1;\n\tdo {\n\t\t*eosaf = read_next_sample(ifd, IGNORE_RESTART | DONT_READ_CPU_NR,\n\t\t\t\t\t  *curr, file, &rtype, 0, file_magic,\n\t\t\t\t\t  file_actlst, rectime, UEOF_STOP);\n\t\tif (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {\n\t\t\tnext = generic_write_stats(*curr, tm_start.use, tm_end.use, *reset, cnt,\n\t\t\t\t\t\t   NULL, rectime, reset_cd, act_id);\n\t\t\treset_cd = 0;\n\t\t\tif (next) {\n\t\t\t\t*curr ^= 1;\n\t\t\t\tif (*cnt > 0) {\n\t\t\t\t\t(*cnt)--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*reset = FALSE;\n\t\t}\n\t}\n\twhile (*cnt && !*eosaf && (rtype != R_RESTART));\n\t*reset = TRUE;\n}", "target": 0}
{"code": "static const tls12_hash_info *tls12_get_hash_info(unsigned char hash_alg)\n\t{\n\tif (hash_alg == 0)\n\t\treturn NULL;\n\tif (hash_alg > sizeof(tls12_md_info)/sizeof(tls12_md_info[0]))\n\t\treturn NULL;\n\treturn tls12_md_info + hash_alg - 1;\n\t}", "target": 0}
{"code": "  StringPtr() {\n    on_heap_ = false;\n    Reset();\n  }", "target": 0}
{"code": "static int em_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 pmc;\n\tif (ctxt->ops->read_pmc(ctxt, ctxt->regs[VCPU_REGS_RCX], &pmc))\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->regs[VCPU_REGS_RAX] = (u32)pmc;\n\tctxt->regs[VCPU_REGS_RDX] = pmc >> 32;\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static inline bool skb_pfmemalloc(const struct sk_buff *skb)\n{\n\treturn unlikely(skb->pfmemalloc);\n}", "target": 0}
{"code": "int main(void)\n{\n\tSuite *suite;\n\tSRunner *runner;\n\tint tests_failed;\n\tlog_setup(true);\n\tsuite = xml_load_suite();\n\trunner = srunner_create(suite);\n\tsrunner_run_all(runner, CK_NORMAL);\n\ttests_failed = srunner_ntests_failed(runner);\n\tsrunner_free(runner);\n\treturn (tests_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}", "target": 0}
{"code": "main (void)\n{\n  FILE *f;\n  char *line;\n  size_t len;\n  ssize_t result;\n  f = fopen (\"test-getline.txt\", \"wb\");\n  if (!f || fwrite (\"a\\nA\\nbc\\nd\\0f\", 1, 10, f) != 10 || fclose (f) != 0)\n    {\n      fputs (\"Failed to create sample file.\\n\", stderr);\n      remove (\"test-getline.txt\");\n      return 1;\n    }\n  f = fopen (\"test-getline.txt\", \"rb\");\n  if (!f)\n    {\n      fputs (\"Failed to reopen sample file.\\n\", stderr);\n      remove (\"test-getline.txt\");\n      return 1;\n    }\n  line = NULL;\n  len = 0;\n  result = getline (&line, &len, f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"a\\n\") == 0);\n  ASSERT (2 < len);\n  free (line);\n  line = NULL;\n  len = (size_t)(~0) / 4;\n  result = getline (&line, &len, f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"A\\n\") == 0);\n  ASSERT (2 < len);\n  free (line);\n  line = malloc (1);\n  len = 0;\n  result = getline (&line, &len, f);\n  ASSERT (result == 3);\n  ASSERT (strcmp (line, \"bc\\n\") == 0);\n  ASSERT (3 < len);\n  result = getline (&line, &len, f);\n  ASSERT (result == 3);\n  ASSERT (memcmp (line, \"d\\0f\", 4) == 0);\n  ASSERT (3 < len);\n  result = getline (&line, &len, f);\n  ASSERT (result == -1);\n  free (line);\n  fclose (f);\n  remove (\"test-getline.txt\");\n  return 0;\n}", "target": 0}
{"code": "string16 WindowCaptionFromPageTitle(const string16& page_title) {\n#if defined(OS_MACOSX) || defined(OS_CHROMEOS)\n  if (page_title.empty())\n    return l10n_util::GetStringUTF16(IDS_BROWSER_WINDOW_MAC_TAB_UNTITLED);\n  return page_title;\n#else\n  if (page_title.empty())\n    return l10n_util::GetStringUTF16(IDS_PRODUCT_NAME);\n  return l10n_util::GetStringFUTF16(IDS_BROWSER_WINDOW_TITLE_FORMAT,\n                                    page_title);\n#endif\n}", "target": 0}
{"code": "static inline int is_zero_pfn(unsigned long pfn)\n{\n\textern unsigned long zero_pfn;\n\tunsigned long offset_from_zero_pfn = pfn - zero_pfn;\n\treturn offset_from_zero_pfn <= (zero_page_mask >> PAGE_SHIFT);\n}", "target": 0}
{"code": "void rfbClientSetClientData(rfbClient* client, void* tag, void* data)\n{\n\trfbClientData* clientData = client->clientData;\n\twhile(clientData && clientData->tag != tag)\n\t\tclientData = clientData->next;\n\tif(clientData == NULL) {\n\t\tclientData = calloc(sizeof(rfbClientData), 1);\n\t\tclientData->next = client->clientData;\n\t\tclient->clientData = clientData;\n\t\tclientData->tag = tag;\n\t}\n\tclientData->data = data;\n}", "target": 0}
{"code": "void snd_usb_set_format_quirk(struct snd_usb_substream *subs,\n\t\t\t      struct audioformat *fmt)\n{\n\tswitch (subs->stream->chip->usb_id) {\n\tcase USB_ID(0x041e, 0x3f02): \n\tcase USB_ID(0x041e, 0x3f04): \n\tcase USB_ID(0x041e, 0x3f0a): \n\tcase USB_ID(0x041e, 0x3f19): \n\t\tset_format_emu_quirk(subs, fmt);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tnew_ns->mounts++;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}", "target": 0}
{"code": "static request_rec *make_sub_request(const request_rec *r,\n                                     ap_filter_t *next_filter)\n{\n    apr_pool_t *rrp;\n    request_rec *rnew;\n    apr_pool_create(&rrp, r->pool);\n    apr_pool_tag(rrp, \"subrequest\");\n    rnew = apr_pcalloc(rrp, sizeof(request_rec));\n    rnew->pool = rrp;\n    rnew->hostname       = r->hostname;\n    rnew->request_time   = r->request_time;\n    rnew->connection     = r->connection;\n    rnew->server         = r->server;\n    rnew->log            = r->log;\n    rnew->request_config = ap_create_request_config(rnew->pool);\n    rnew->per_dir_config = r->server->lookup_defaults;\n    rnew->htaccess = r->htaccess;\n    rnew->allowed_methods = ap_make_method_list(rnew->pool, 2);\n    ap_copy_method_list(rnew->allowed_methods, r->allowed_methods);\n    if (next_filter) {\n        ap_filter_t *scan = next_filter;\n        rnew->input_filters = r->input_filters;\n        rnew->proto_input_filters = r->proto_input_filters;\n        rnew->output_filters = next_filter;\n        rnew->proto_output_filters = r->proto_output_filters;\n        while (scan && (scan != r->proto_output_filters)) {\n            if (scan->frec == ap_subreq_core_filter_handle) {\n                break;\n            }\n            scan = scan->next;\n        }\n        if (!scan || scan == r->proto_output_filters) {\n            ap_add_output_filter_handle(ap_subreq_core_filter_handle,\n                    NULL, rnew, rnew->connection);\n        }\n    }\n    else {\n        rnew->proto_input_filters = r->proto_input_filters;\n        rnew->proto_output_filters = r->proto_output_filters;\n        rnew->input_filters = r->proto_input_filters;\n        rnew->output_filters = r->proto_output_filters;\n    }\n    rnew->useragent_addr = r->useragent_addr;\n    rnew->useragent_ip = r->useragent_ip;\n    ap_set_sub_req_protocol(rnew, r);\n    ap_run_create_request(rnew);\n    rnew->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n    rnew->kept_body = r->kept_body;\n    return rnew;\n}", "target": 0}
{"code": "cmdline_toggle_langmap(long *b_im_ptr)\n{\n    if (map_to_exists_mode((char_u *)\"\", LANGMAP, FALSE))\n    {\n\tState ^= LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(FALSE);\t\n#endif\n\tif (b_im_ptr != NULL)\n\t{\n\t    if (State & LANGMAP)\n\t\t*b_im_ptr = B_IMODE_LMAP;\n\t    else\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\tif ((p_imdisable && b_im_ptr != NULL)\n\t\t? *b_im_ptr == B_IMODE_IM : im_get_status())\n\t{\n\t    im_set_active(FALSE);\t\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n\telse\n\t{\n\t    im_set_active(TRUE);\t\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_IM;\n\t}\n    }\n#endif\n    if (b_im_ptr != NULL)\n    {\n\tif (b_im_ptr == &curbuf->b_p_iminsert)\n\t    set_iminsert_global();\n\telse\n\t    set_imsearch_global();\n    }\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\n#endif\n#if defined(FEAT_KEYMAP)\n    status_redraw_curbuf();\n#endif\n}", "target": 0}
{"code": "u8 bnx2x_is_pcie_pending(struct pci_dev *dev)\n{\n\tu16 status;\n\tpcie_capability_read_word(dev, PCI_EXP_DEVSTA, &status);\n\treturn status & PCI_EXP_DEVSTA_TRPND;\n}", "target": 0}
{"code": "int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest)\n{\n\tnest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;\n\treturn n->nlmsg_len;\n}", "target": 0}
{"code": "void mbedtls_ssl_send_flight_completed( mbedtls_ssl_context *ssl )\n{\n    ssl_reset_retransmit_timeout( ssl );\n    mbedtls_ssl_set_timer( ssl, ssl->handshake->retransmit_timeout );\n    if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&\n        ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED )\n    {\n        ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;\n    }\n    else\n        ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_WAITING;\n}", "target": 0}
{"code": "should_compact_retry(struct alloc_context *ac, unsigned int order, int alloc_flags,\n\t\t     enum compact_result compact_result,\n\t\t     enum compact_priority *compact_priority,\n\t\t     int *compaction_retries)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tif (!order || order > PAGE_ALLOC_COSTLY_ORDER)\n\t\treturn false;\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tif (zone_watermark_ok(zone, 0, min_wmark_pages(zone),\n\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "TEST(FloatPoolingOpTest, L2PoolPaddingSame) {\n  FloatPoolingOpModel m(BuiltinOperator_L2_POOL_2D,\n                        {TensorType_FLOAT32, {1, 2, 4, 1}},\n                        2, 2,\n                        {TensorType_FLOAT32, {}}, Padding_SAME);\n  m.SetInput({\n      0, 6, 2, 4,   \n      3, 2, 10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({3.5, 6.5}));\n}", "target": 0}
{"code": "void WebContentsImpl::DidDisownOpener(RenderViewHost* rvh) {\n  if (opener_) {\n    RemoveDestructionObserver(opener_);\n    opener_ = NULL;\n  }\n  render_manager_.DidDisownOpener(rvh);\n}", "target": 0}
{"code": "static void tls1_get_curvelist(SSL *s, int sess,\n\t\t\t\t\tconst unsigned char **pcurves,\n\t\t\t\t\tsize_t *pcurveslen)\n\t{\n\tif (sess)\n\t\t{\n\t\t*pcurves = s->session->tlsext_ellipticcurvelist;\n\t\t*pcurveslen = s->session->tlsext_ellipticcurvelist_length;\n\t\treturn;\n\t\t}\n\tswitch (tls1_suiteb(s))\n\t\t{\n\tcase SSL_CERT_FLAG_SUITEB_128_LOS:\n\t\t*pcurves = suiteb_curves;\n\t\t*pcurveslen = sizeof(suiteb_curves);\n\t\tbreak;\n\tcase SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:\n\t\t*pcurves = suiteb_curves;\n\t\t*pcurveslen = 2;\n\t\tbreak;\n\tcase SSL_CERT_FLAG_SUITEB_192_LOS:\n\t\t*pcurves = suiteb_curves + 2;\n\t\t*pcurveslen = 2;\n\t\tbreak;\n\tdefault:\n\t\t*pcurves = s->tlsext_ellipticcurvelist;\n\t\t*pcurveslen = s->tlsext_ellipticcurvelist_length;\n\t\t}\n\tif (!*pcurves)\n\t\t{\n\t\t*pcurves = eccurves_default;\n\t\t*pcurveslen = sizeof(eccurves_default);\n\t\t}\n\t}", "target": 0}
{"code": "int parse_rtattr_flags(struct rtattr *tb[], int max, struct rtattr *rta,\n\t\t       int len, unsigned short flags)\n{\n\tunsigned short type;\n\tmemset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\twhile (RTA_OK(rta, len)) {\n\t\ttype = rta->rta_type & ~flags;\n\t\tif ((type <= max) && (!tb[type]))\n\t\t\ttb[type] = rta;\n\t\trta = RTA_NEXT(rta, len);\n\t}\n\tif (len)\n\t\tfprintf(stderr, \"!!!Deficit %d, rta_len=%d\\n\",\n\t\t\tlen, rta->rta_len);\n\treturn 0;\n}", "target": 0}
{"code": "static BOOL update_gdi_memblt(rdpContext* context, MEMBLT_ORDER* memblt)\n{\n\trdpBitmap* bitmap;\n\trdpCache* cache = context->cache;\n\tif (memblt->cacheId == 0xFF)\n\t\tbitmap = offscreen_cache_get(cache->offscreen, memblt->cacheIndex);\n\telse\n\t\tbitmap = bitmap_cache_get(cache->bitmap, (BYTE)memblt->cacheId, memblt->cacheIndex);\n\tif (bitmap == NULL)\n\t\treturn TRUE;\n\tmemblt->bitmap = bitmap;\n\treturn IFCALLRESULT(TRUE, cache->bitmap->MemBlt, context, memblt);\n}", "target": 0}
{"code": "void InlineFlowBox::extractLineBoxFromRenderObject()\n{\n    toRenderInline(renderer())->lineBoxes()->extractLineBox(this);\n}", "target": 0}
{"code": "static void bnx2x_handle_rx_mode_eqe(struct bnx2x *bp)\n{\n\tnetif_addr_lock_bh(bp->dev);\n\tclear_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state);\n\tif (test_and_clear_bit(BNX2X_FILTER_RX_MODE_SCHED, &bp->sp_state))\n\t\tbnx2x_set_storm_rx_mode(bp);\n\telse if (test_and_clear_bit(BNX2X_FILTER_ISCSI_ETH_START_SCHED,\n\t\t\t\t    &bp->sp_state))\n\t\tbnx2x_set_iscsi_eth_rx_mode(bp, true);\n\telse if (test_and_clear_bit(BNX2X_FILTER_ISCSI_ETH_STOP_SCHED,\n\t\t\t\t    &bp->sp_state))\n\t\tbnx2x_set_iscsi_eth_rx_mode(bp, false);\n\tnetif_addr_unlock_bh(bp->dev);\n}", "target": 0}
{"code": "static bool ieee80211_tx(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sk_buff *skb, bool txpending,\n\t\t\t enum ieee80211_band band)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result res_prepare;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tbool result = true;\n\tint led_len;\n\tif (unlikely(skb->len < 10)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn true;\n\t}\n\tled_len = skb->len;\n\tres_prepare = ieee80211_tx_prepare(sdata, &tx, skb);\n\tif (unlikely(res_prepare == TX_DROP)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn true;\n\t} else if (unlikely(res_prepare == TX_QUEUED)) {\n\t\treturn true;\n\t}\n\tinfo->band = band;\n\tif (!(info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) ||\n\t    !(local->hw.flags & IEEE80211_HW_QUEUE_CONTROL))\n\t\tinfo->hw_queue =\n\t\t\tsdata->vif.hw_queue[skb_get_queue_mapping(skb)];\n\tif (!invoke_tx_handlers(&tx))\n\t\tresult = __ieee80211_tx(local, &tx.skbs, led_len,\n\t\t\t\t\ttx.sta, txpending);\n\treturn result;\n}", "target": 0}
{"code": "void gf_fs_push_arg(GF_FilterSession *session, const char *szArg, u32 was_found, u32 type)\n{\n\tif (session->flags & GF_FS_FLAG_NO_ARG_CHECK)\n\t\treturn;\n\tif (!was_found) {\n\t\tBool afound = GF_FALSE;\n\t\tu32 k, acount;\n\t\tif (!session->parsed_args) session->parsed_args = gf_list_new();\n\t\tacount = gf_list_count(session->parsed_args);\n\t\tfor (k=0; k<acount; k++) {\n\t\t\tGF_FSArgItem *ai = gf_list_get(session->parsed_args, k);\n\t\t\tif (!strcmp(ai->argname, szArg)) {\n\t\t\t\tafound = GF_TRUE;\n\t\t\t\tif ((ai->type==2) && (type==2) && (ai->found_type==1))\n\t\t\t\t\tai->found_type = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!afound) {\n\t\t\tGF_FSArgItem *ai;\n\t\t\tGF_SAFEALLOC(ai, GF_FSArgItem);\n\t\t\tif (ai) {\n\t\t\t\tai->argname = gf_strdup(szArg);\n\t\t\t\tai->type = type;\n\t\t\t\tgf_list_add(session->parsed_args, ai );\n\t\t\t}\n\t\t}\n\t} else {\n\t\tu32 k, acount;\n\t\tBool found = GF_FALSE;\n\t\tif (!session->parsed_args) session->parsed_args = gf_list_new();\n\t\tacount = gf_list_count(session->parsed_args);\n\t\tfor (k=0; k<acount; k++) {\n\t\t\tGF_FSArgItem *ai = gf_list_get(session->parsed_args, k);\n\t\t\tif (!strcmp(ai->argname, szArg)) {\n\t\t\t\tai->found_type = was_found;\n\t\t\t\tfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tGF_FSArgItem *ai;\n\t\t\tGF_SAFEALLOC(ai, GF_FSArgItem);\n\t\t\tif (ai) {\n\t\t\t\tai->argname = gf_strdup(szArg);\n\t\t\t\tai->type = type;\n\t\t\t\tai->found_type = was_found;\n\t\t\t\tgf_list_add(session->parsed_args, ai );\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "tag_strnicmp(char_u *s1, char_u *s2, size_t len)\n{\n    int\t\ti;\n    while (len > 0)\n    {\n\ti = (int)TOUPPER_ASC(*s1) - (int)TOUPPER_ASC(*s2);\n\tif (i != 0)\n\t    return i;\t\t\t\n\tif (*s1 == NUL)\n\t    break;\t\t\t\n\t++s1;\n\t++s2;\n\t--len;\n    }\n    return 0;\t\t\t\t\n}", "target": 0}
{"code": "write_v3_votes_to_disk(const smartlist_t *pending_votes)\n{\n  smartlist_t *votestrings = smartlist_new();\n  char *votefile = NULL;\n  SMARTLIST_FOREACH(pending_votes, pending_vote_t *, v,\n    {\n      sized_chunk_t *c = tor_malloc(sizeof(sized_chunk_t));\n      c->bytes = v->vote_body->dir;\n      c->len = v->vote_body->dir_len;\n      smartlist_add(votestrings, c); \n    });\n  votefile = get_datadir_fname(\"v3-status-votes\");\n  write_chunks_to_file(votefile, votestrings, 0, 0);\n  log_debug(LD_DIR, \"Wrote votes to disk (%s)!\", votefile);\n  tor_free(votefile);\n  SMARTLIST_FOREACH(votestrings, sized_chunk_t *, c, tor_free(c));\n  smartlist_free(votestrings);\n}", "target": 0}
{"code": "parse_truncate_subfield(const char *arg_,\n                        const struct ofpact_parse_params *pp,\n                        struct ofpact_output_trunc *output_trunc)\n{\n    char *key, *value;\n    char *arg = CONST_CAST(char *, arg_);\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        if (!strcmp(key, \"port\")) {\n            if (!ofputil_port_from_string(value, pp->port_map,\n                                          &output_trunc->port)) {\n                return xasprintf(\"output to unknown truncate port: %s\",\n                                  value);\n            }\n            if (ofp_to_u16(output_trunc->port) > ofp_to_u16(OFPP_MAX)) {\n                if (output_trunc->port != OFPP_LOCAL &&\n                    output_trunc->port != OFPP_IN_PORT)\n                return xasprintf(\"output to unsupported truncate port: %s\",\n                                 value);\n            }\n        } else if (!strcmp(key, \"max_len\")) {\n            char *err;\n            err = str_to_u32(value, &output_trunc->max_len);\n            if (err) {\n                return err;\n            }\n        } else {\n            return xasprintf(\"invalid key '%s' in output_trunc argument\",\n                                key);\n        }\n    }\n    return NULL;\n}", "target": 0}
{"code": "void Browser::ActivateContents(WebContents* contents) {\n  tab_strip_model_->ActivateTabAt(\n      tab_strip_model_->GetIndexOfWebContents(contents), false);\n  window_->Activate();\n}", "target": 0}
{"code": "onig_regset_number_of_regex(OnigRegSet* set)\n{\n  return set->n;\n}", "target": 0}
{"code": "dump_profile_updates (struct cgraph_node *orig_node,\n\t\t      struct cgraph_node *new_node)\n{\n  struct cgraph_edge *cs;\n  fprintf (dump_file, \"    setting count of the specialized node to \");\n  new_node->count.dump (dump_file);\n  fprintf (dump_file, \"\\n\");\n  for (cs = new_node->callees; cs; cs = cs->next_callee)\n    {\n      fprintf (dump_file, \"      edge to %s has count \",\n\t       cs->callee->name ());\n      cs->count.dump (dump_file);\n      fprintf (dump_file, \"\\n\");\n    }\n  fprintf (dump_file, \"    setting count of the original node to \");\n  orig_node->count.dump (dump_file);\n  fprintf (dump_file, \"\\n\");\n  for (cs = orig_node->callees; cs; cs = cs->next_callee)\n    {\n      fprintf (dump_file, \"      edge to %s is left with \",\n\t       cs->callee->name ());\n      cs->count.dump (dump_file);\n      fprintf (dump_file, \"\\n\");\n    }\n}", "target": 0}
{"code": "bool ShouldTabShowAlertIndicator(int capacity,\n                                 bool is_pinned_tab,\n                                 bool is_active_tab,\n                                 bool has_favicon,\n                                 TabAlertState alert_state) {\n  if (alert_state == TabAlertState::NONE)\n    return false;\n  if (ShouldTabShowCloseButton(capacity, is_pinned_tab, is_active_tab))\n    return capacity >= 2;\n  return capacity >= 1;\n}", "target": 0}
{"code": "static int copy_counters_to_user(struct ebt_table *t,\n\t\t\t\t  const struct ebt_counter *oldcounters,\n\t\t\t\t  void __user *user, unsigned int num_counters,\n\t\t\t\t  unsigned int nentries)\n{\n\tstruct ebt_counter *counterstmp;\n\tint ret = 0;\n\tif (num_counters == 0)\n\t\treturn 0;\n\tif (num_counters != nentries) {\n\t\tBUGPRINT(\"Num_counters wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcounterstmp = vmalloc(nentries * sizeof(*counterstmp));\n\tif (!counterstmp)\n\t\treturn -ENOMEM;\n\twrite_lock_bh(&t->lock);\n\tget_counters(oldcounters, counterstmp, nentries);\n\twrite_unlock_bh(&t->lock);\n\tif (copy_to_user(user, counterstmp,\n\t   nentries * sizeof(struct ebt_counter)))\n\t\tret = -EFAULT;\n\tvfree(counterstmp);\n\treturn ret;\n}", "target": 0}
{"code": "  void DidDumpQuotaTable(const QuotaTableEntries& entries) {\n    quota_entries_ = entries;\n  }", "target": 0}
{"code": "  DeltaFeedFetcher(JobScheduler* scheduler, int64 start_change_id)\n      : scheduler_(scheduler),\n        start_change_id_(start_change_id),\n        weak_ptr_factory_(this) {\n  }", "target": 0}
{"code": "ipcp_bits_lattice::meet_with (widest_int value, widest_int mask,\n\t\t\t      unsigned precision)\n{\n  if (bottom_p ())\n    return false;\n  if (top_p ())\n    {\n      if (wi::sext (mask, precision) == -1)\n\treturn set_to_bottom ();\n      return set_to_constant (value, mask);\n    }\n  return meet_with_1 (value, mask, precision);\n}", "target": 0}
{"code": "static inline uint16_t ok_inflater_can_write(const ok_inflater *inflater) {\n    if (inflater->buffer_start_pos == 0) {\n        return -inflater->buffer_end_pos - 1;\n    } else if (inflater->buffer_start_pos > inflater->buffer_end_pos) {\n        return inflater->buffer_start_pos - inflater->buffer_end_pos - 1;\n    } else {\n        return -inflater->buffer_end_pos;\n    }\n}", "target": 0}
{"code": "rb_add_time_stamp(struct ring_buffer_event *event, u64 delta)\n{\n\tevent->type_len = RINGBUF_TYPE_TIME_EXTEND;\n\tif (rb_event_index(event)) {\n\t\tevent->time_delta = delta & TS_MASK;\n\t\tevent->array[0] = delta >> TS_SHIFT;\n\t} else {\n\t\tevent->time_delta = 0;\n\t\tevent->array[0] = 0;\n\t}\n\treturn skip_time_extend(event);\n}", "target": 0}
{"code": "TEST_F(HeaderToMetadataTest, BadProtobufValueTypeInBase64UrlTest) {\n  const std::string response_config_yaml = R\"EOF(\nresponse_rules:\n  - header: x-authenticated\n    on_header_present:\n      key: auth\n      type: PROTOBUF_VALUE\n      encode: BASE64\n)EOF\";\n  initializeFilter(response_config_yaml);\n  std::string data = \"invalid\";\n  const auto encoded = Base64::encode(data.c_str(), data.size());\n  Http::TestResponseHeaderMapImpl incoming_headers{{\"x-authenticated\", encoded}};\n  EXPECT_CALL(encoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_, setDynamicMetadata(_, _)).Times(0);\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(incoming_headers, false));\n}", "target": 0}
{"code": "TEST(LteOp, MatchesScalar) {\n    BSONObj operand = BSON(\"$lte\" << 5);\n    LTEMatchExpression lte(\"a\", operand[\"$lte\"]);\n    ASSERT(lte.matchesBSON(BSON(\"a\" << 4.5), NULL));\n    ASSERT(!lte.matchesBSON(BSON(\"a\" << 6), NULL));\n}", "target": 0}
{"code": "static void ieee80211_tx_latency_start_msrmnt(struct ieee80211_local *local,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct timespec skb_arv;\n\tstruct ieee80211_tx_latency_bin_ranges *tx_latency;\n\ttx_latency = rcu_dereference(local->tx_latency);\n\tif (!tx_latency)\n\t\treturn;\n\tktime_get_ts(&skb_arv);\n\tskb->tstamp = ktime_set(skb_arv.tv_sec, skb_arv.tv_nsec);\n}", "target": 0}
{"code": "    void TiffFinder::visitBinaryElement(TiffBinaryElement* object)\n    {\n        findObject(object);\n    }", "target": 0}
{"code": "   Returns info about the current mailbox */\nPHP_FUNCTION(imap_mailboxmsginfo)\n{\n\tzval *streamind;\n\tpils *imap_le_struct;\n\tchar date[100];\n\tunsigned long msgno;\n\tzend_ulong unreadmsg = 0, deletedmsg = 0, msize = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &streamind) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tobject_init(return_value);\n\tfor (msgno = 1; msgno <= imap_le_struct->imap_stream->nmsgs; msgno++) {\n\t\tMESSAGECACHE * cache = mail_elt (imap_le_struct->imap_stream, msgno);\n\t\tmail_fetchstructure (imap_le_struct->imap_stream, msgno, NIL);\n\t\tif (!cache->seen || cache->recent) {\n\t\t\tunreadmsg++;\n\t\t}\n\t\tif (cache->deleted) {\n\t\t\tdeletedmsg++;\n\t\t}\n\t\tmsize = msize + cache->rfc822_size;\n\t}\n\tadd_property_long(return_value, \"Unread\", unreadmsg);\n\tadd_property_long(return_value, \"Deleted\", deletedmsg);\n\tadd_property_long(return_value, \"Nmsgs\", imap_le_struct->imap_stream->nmsgs);\n\tadd_property_long(return_value, \"Size\", msize);\n\trfc822_date(date);\n\tadd_property_string(return_value, \"Date\", date);\n\tadd_property_string(return_value, \"Driver\", imap_le_struct->imap_stream->dtb->name);\n\tadd_property_string(return_value, \"Mailbox\", imap_le_struct->imap_stream->mailbox);\n\tadd_property_long(return_value, \"Recent\", imap_le_struct->imap_stream->recent);", "target": 0}
{"code": "int git_pkt_buffer_flush(git_buf *buf)\n{\n\treturn git_buf_put(buf, pkt_flush_str, strlen(pkt_flush_str));\n}", "target": 0}
{"code": "static inline void write_s3row_data(\n\tconst entity_stage3_row *r,\n\tunsigned orig_cp,\n\tenum entity_charset charset,\n\tzval *arr)\n{\n\tchar key[9] = \"\"; \n\tchar entity[LONGEST_ENTITY_LENGTH + 2] = {'&'};\n\tsize_t written_k1;\n\twritten_k1 = write_octet_sequence(key, charset, orig_cp);\n\tif (!r->ambiguous) {\n\t\tsize_t l = r->data.ent.entity_len;\n\t\tmemcpy(&entity[1], r->data.ent.entity, l);\n\t\tentity[l + 1] = ';';\n\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t} else {\n\t\tunsigned i,\n\t\t\t     num_entries;\n\t\tconst entity_multicodepoint_row *mcpr = r->data.multicodepoint_table;\n\t\tif (mcpr[0].leading_entry.default_entity != NULL) {\n\t\t\tsize_t l = mcpr[0].leading_entry.default_entity_len;\n\t\t\tmemcpy(&entity[1], mcpr[0].leading_entry.default_entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t\t}\n\t\tnum_entries = mcpr[0].leading_entry.size;\n\t\tfor (i = 1; i <= num_entries; i++) {\n\t\t\tsize_t   l,\n\t\t\t\t     written_k2;\n\t\t\tunsigned uni_cp,\n\t\t\t\t\t spe_cp;\n\t\t\tuni_cp = mcpr[i].normal_entry.second_cp;\n\t\t\tl = mcpr[i].normal_entry.entity_len;\n\t\t\tif (!CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\tif (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE)\n\t\t\t\t\tcontinue; \n\t\t\t} else {\n\t\t\t\tspe_cp = uni_cp;\n\t\t\t}\n\t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n\t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tentity[l + 1] = '\\0';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + written_k2 + 1, entity, l + 1, 1);\n\t\t}\n\t}\n}", "target": 0}
{"code": "void* V8DOMWrapper::convertToSVGPODTypeImpl(V8ClassIndex::V8WrapperType type, v8::Handle<v8::Value> object)\n{\n    return isWrapperOfType(object, type) ? convertDOMWrapperToNative<void>(v8::Handle<v8::Object>::Cast(object)) : 0;\n}", "target": 0}
{"code": "DECLAREContigPutFunc(put1bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n    (void) x; (void) y;\n    fromskew /= 8;\n    while (h-- > 0) {\n\tuint32* bw;\n\tUNROLL8(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 0}
{"code": "get_use_pkg(Token *t, const char *dname, const char **name)\n{\n    const char *id;\n    t = skip_white(t);\n    t = expand_smacro(t);\n    *name = NULL;\n    if (!t) {\n        nasm_nonfatal(\"`%s' expects a package name, got end of line\", dname);\n        return NULL;\n    } else if (t->type != TOK_ID && t->type != TOK_STRING) {\n        nasm_nonfatal(\"`%s' expects a package name, got `%s'\",\n                      dname, tok_text(t));\n        return NULL;\n    }\n    *name = id = unquote_token(t);\n    t = t->next;\n    t = skip_white(t);\n    if (t)\n        nasm_warn(WARN_OTHER, \"trailing garbage after `%s' ignored\", dname);\n    return nasm_find_use_package(id);\n}", "target": 0}
{"code": "TEST(RegexMatchExpression, MatchesNull) {\n    RegexMatchExpression regex(\"a\", \"b\", \"\");\n    ASSERT(!regex.matchesBSON(BSONObj(), NULL));\n    ASSERT(!regex.matchesBSON(BSON(\"a\" << BSONNULL), NULL));\n}", "target": 0}
{"code": "dirserv_dump_directory_to_string(char **dir_out,\n                                 crypto_pk_env_t *private_key)\n{\n  char *cp;\n  char *identity_pkey; \n  char *recommended_versions;\n  char digest[DIGEST_LEN];\n  char published[ISO_TIME_LEN+1];\n  char *buf = NULL;\n  size_t buf_len;\n  size_t identity_pkey_len;\n  time_t now = time(NULL);\n  tor_assert(dir_out);\n  *dir_out = NULL;\n  if (crypto_pk_write_public_key_to_string(private_key,&identity_pkey,\n                                           &identity_pkey_len)<0) {\n    log_warn(LD_BUG,\"write identity_pkey to string failed!\");\n    return -1;\n  }\n  recommended_versions =\n    format_versions_list(get_options()->RecommendedVersions);\n  format_iso_time(published, now);\n  buf_len = 2048+strlen(recommended_versions);\n  buf = tor_malloc(buf_len);\n  tor_snprintf(buf, buf_len,\n               \"signed-directory\\n\"\n               \"published %s\\n\"\n               \"recommended-software %s\\n\"\n               \"router-status %s\\n\"\n               \"dir-signing-key\\n%s\\n\",\n               published, recommended_versions, \"\",\n               identity_pkey);\n  tor_free(recommended_versions);\n  tor_free(identity_pkey);\n  cp = buf + strlen(buf);\n  *cp = '\\0';\n  if (strlcat(buf, \"directory-signature \", buf_len) >= buf_len)\n    goto truncated;\n  if (strlcat(buf, get_options()->Nickname, buf_len) >= buf_len)\n    goto truncated;\n  if (strlcat(buf, \"\\n\", buf_len) >= buf_len)\n    goto truncated;\n  if (router_get_dir_hash(buf,digest)) {\n    log_warn(LD_BUG,\"couldn't compute digest\");\n    tor_free(buf);\n    return -1;\n  }\n  note_crypto_pk_op(SIGN_DIR);\n  if (router_append_dirobj_signature(buf,buf_len,digest,DIGEST_LEN,\n                                     private_key)<0) {\n    tor_free(buf);\n    return -1;\n  }\n  *dir_out = buf;\n  return 0;\n truncated:\n  log_warn(LD_BUG,\"tried to exceed string length.\");\n  tor_free(buf);\n  return -1;\n}", "target": 0}
{"code": "xsltValueOfComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemValueOfPtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n    const xmlChar *prop;\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemValueOfPtr) xsltNewStylePreComp(style, XSLT_FUNC_VALUEOF);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_VALUEOF);\n#endif\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n    prop = xsltGetCNsProp(style, inst,\n\t    (const xmlChar *)\"disable-output-escaping\",\n\t\t\tXSLT_NAMESPACE);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *)\"yes\")) {\n\t    comp->noescape = 1;\n\t} else if (!xmlStrEqual(prop,\n\t\t\t\t(const xmlChar *)\"no\")){\n\t    xsltTransformError(NULL, style, inst,\n\"xsl:value-of : disable-output-escaping allows only yes or no\\n\");\n\t    if (style != NULL) style->warnings++;\n\t}\n    }\n    comp->select = xsltGetCNsProp(style, inst, (const xmlChar *)\"select\",\n\t                        XSLT_NAMESPACE);\n    if (comp->select == NULL) {\n\txsltTransformError(NULL, style, inst,\n\t     \"xsl:value-of : select is missing\\n\");\n\tif (style != NULL) style->errors++;\n\treturn;\n    }\n    comp->comp = xsltXPathCompile(style, comp->select);\n    if (comp->comp == NULL) {\n\txsltTransformError(NULL, style, inst,\n\t     \"xsl:value-of : could not compile select expression '%s'\\n\",\n\t                 comp->select);\n\tif (style != NULL) style->errors++;\n    }\n}", "target": 0}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if ((EncISO_8859_1_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      code += 0x20;\n    }\n    else if (code == 0xAA || code == 0xBA || code == 0xB5 || code == 0xFF)\n      ;\n    else if ((EncISO_8859_1_CtypeTable[code] & BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      code -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "void proto_unregister(struct proto *prot)\n{\n\twrite_lock(&proto_list_lock);\n\trelease_proto_idx(prot);\n\tlist_del(&prot->node);\n\twrite_unlock(&proto_list_lock);\n\tif (prot->slab != NULL) {\n\t\tkmem_cache_destroy(prot->slab);\n\t\tprot->slab = NULL;\n\t}\n\tif (prot->rsk_prot != NULL && prot->rsk_prot->slab != NULL) {\n\t\tkmem_cache_destroy(prot->rsk_prot->slab);\n\t\tkfree(prot->rsk_prot->slab_name);\n\t\tprot->rsk_prot->slab = NULL;\n\t}\n\tif (prot->twsk_prot != NULL && prot->twsk_prot->twsk_slab != NULL) {\n\t\tkmem_cache_destroy(prot->twsk_prot->twsk_slab);\n\t\tkfree(prot->twsk_prot->twsk_slab_name);\n\t\tprot->twsk_prot->twsk_slab = NULL;\n\t}\n}", "target": 0}
{"code": "sldns_is_last_of_string(const char* str)\n{\n\tif(*str == 0) return 1;\n\twhile(isspace((unsigned char)*str))\n\t\tstr++;\n\tif(*str == 0) return 1;\n\treturn 0;\n}", "target": 0}
{"code": "static int tipc_nl_compat_bearer_enable(struct tipc_nl_compat_cmd_doit *cmd,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tstruct tipc_nl_compat_msg *msg)\n{\n\tstruct nlattr *prop;\n\tstruct nlattr *bearer;\n\tstruct tipc_bearer_config *b;\n\tb = (struct tipc_bearer_config *)TLV_DATA(msg->req);\n\tbearer = nla_nest_start(skb, TIPC_NLA_BEARER);\n\tif (!bearer)\n\t\treturn -EMSGSIZE;\n\tif (nla_put_string(skb, TIPC_NLA_BEARER_NAME, b->name))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u32(skb, TIPC_NLA_BEARER_DOMAIN, ntohl(b->disc_domain)))\n\t\treturn -EMSGSIZE;\n\tif (ntohl(b->priority) <= TIPC_MAX_LINK_PRI) {\n\t\tprop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);\n\t\tif (!prop)\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_u32(skb, TIPC_NLA_PROP_PRIO, ntohl(b->priority)))\n\t\t\treturn -EMSGSIZE;\n\t\tnla_nest_end(skb, prop);\n\t}\n\tnla_nest_end(skb, bearer);\n\treturn 0;\n}", "target": 0}
{"code": "ExpressionDateFromParts::ExpressionDateFromParts(ExpressionContext* const expCtx,\n                                                 intrusive_ptr<Expression> year,\n                                                 intrusive_ptr<Expression> month,\n                                                 intrusive_ptr<Expression> day,\n                                                 intrusive_ptr<Expression> hour,\n                                                 intrusive_ptr<Expression> minute,\n                                                 intrusive_ptr<Expression> second,\n                                                 intrusive_ptr<Expression> millisecond,\n                                                 intrusive_ptr<Expression> isoWeekYear,\n                                                 intrusive_ptr<Expression> isoWeek,\n                                                 intrusive_ptr<Expression> isoDayOfWeek,\n                                                 intrusive_ptr<Expression> timeZone)\n    : Expression(expCtx,\n                 {std::move(year),\n                  std::move(month),\n                  std::move(day),\n                  std::move(hour),\n                  std::move(minute),\n                  std::move(second),\n                  std::move(millisecond),\n                  std::move(isoWeekYear),\n                  std::move(isoWeek),\n                  std::move(isoDayOfWeek),\n                  std::move(timeZone)}),\n      _year(_children[0]),\n      _month(_children[1]),\n      _day(_children[2]),\n      _hour(_children[3]),\n      _minute(_children[4]),\n      _second(_children[5]),\n      _millisecond(_children[6]),\n      _isoWeekYear(_children[7]),\n      _isoWeek(_children[8]),\n      _isoDayOfWeek(_children[9]),\n      _timeZone(_children[10]) {}", "target": 0}
{"code": "void WebContentsImpl::DidStopLoading(RenderViewHost* render_view_host) {\n  scoped_ptr<LoadNotificationDetails> details;\n  NavigationEntry* entry = controller_.GetLastCommittedEntry();\n  if (entry) {\n    base::TimeDelta elapsed = base::TimeTicks::Now() - current_load_start_;\n    details.reset(new LoadNotificationDetails(\n        entry->GetVirtualURL(),\n        entry->GetTransitionType(),\n        elapsed,\n        &controller_,\n        controller_.GetCurrentEntryIndex()));\n  }\n  SetIsLoading(false, details.get());\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DidStopLoading(render_view_host));\n}", "target": 0}
{"code": "static void request_key_auth_destroy(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data;\n\tkenter(\"{%d}\", key->serial);\n\tif (rka->cred) {\n\t\tput_cred(rka->cred);\n\t\trka->cred = NULL;\n\t}\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}", "target": 0}
{"code": "void WebProcessProxy::didUpdateHistoryTitle(uint64_t pageID, const String& title, const String& url, uint64_t frameID)\n{\n    WebPageProxy* page = webPage(pageID);\n    if (!page)\n        return;\n    WebFrameProxy* frame = webFrame(frameID);\n    MESSAGE_CHECK(frame);\n    MESSAGE_CHECK(frame->page() == page);\n    MESSAGE_CHECK_URL(url);\n    m_context->historyClient().didUpdateHistoryTitle(m_context.get(), page, title, url, frame);\n}", "target": 0}
{"code": "  Token Parser::lex_variable()\n  {\n    if (!peek< exactly <'$'> >()) {\n      css_error(\"Invalid CSS\", \" after \", \": expected \\\"$\\\", was \");\n    }\n    if (!lex< sequence < exactly <'$'>, identifier > >()) {\n      lex< exactly <'$'> >(); \n      css_error(\"Invalid CSS\", \" after \", \": expected identifier, was \");\n    }\n    return token;\n  }", "target": 0}
{"code": "void vhost_discard_vq_desc(struct vhost_virtqueue *vq, int n)\n{\n\tvq->last_avail_idx -= n;\n}", "target": 0}
{"code": "JSValue JSArray::pop()\n{\n    checkConsistency();\n    ArrayStorage* storage = m_storage;\n    unsigned length = storage->m_length;\n    if (!length)\n        return jsUndefined();\n    --length;\n    JSValue result;\n    if (length < m_vectorLength) {\n        WriteBarrier<Unknown>& valueSlot = storage->m_vector[length];\n        if (valueSlot) {\n            --storage->m_numValuesInVector;\n            result = valueSlot.get();\n            valueSlot.clear();\n        } else\n            result = jsUndefined();\n    } else {\n        result = jsUndefined();\n        if (SparseArrayValueMap* map = storage->m_sparseValueMap) {\n            SparseArrayValueMap::iterator it = map->find(length);\n            if (it != map->end()) {\n                result = it->second.get();\n                map->remove(it);\n                if (map->isEmpty()) {\n                    delete map;\n                    storage->m_sparseValueMap = 0;\n                }\n            }\n        }\n    }\n    storage->m_length = length;\n    checkConsistency();\n    return result;\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_allow_overrides(request_rec *r)\n{\n    core_dir_config *conf;\n    conf = (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n    return conf->override;\n}", "target": 0}
{"code": "zgethardwareparams(i_ctx_t *i_ctx_p)\n{\n    return zget_device_params(i_ctx_p, true);\n}", "target": 0}
{"code": "void blk_mq_unfreeze_queue(struct request_queue *q)\n{\n\tint freeze_depth;\n\tfreeze_depth = atomic_dec_return(&q->mq_freeze_depth);\n\tWARN_ON_ONCE(freeze_depth < 0);\n\tif (!freeze_depth) {\n\t\tpercpu_ref_reinit(&q->mq_usage_counter);\n\t\twake_up_all(&q->mq_freeze_wq);\n\t}\n}", "target": 0}
{"code": "inline bool FOR_EACH_MODULE_CanContinue(FOR_EACH_MODULE_Type& state, CModules::iterator& i) {\n\tif (state.where == FOR_EACH_MODULE_Type::AtGlobal && i == CZNC::Get().GetModules().end()) {\n\t\ti = state.CMuser.begin();\n\t\tstate.where = FOR_EACH_MODULE_Type::AtUser;\n\t}\n\tif (state.where == FOR_EACH_MODULE_Type::AtUser && i == state.CMuser.end()) {\n\t\ti = state.CMnet.begin();\n\t\tstate.where = FOR_EACH_MODULE_Type::AtNetwork;\n\t}\n\treturn !(state.where == FOR_EACH_MODULE_Type::AtNetwork && i == state.CMnet.end());\n}", "target": 0}
{"code": "PHP_RINIT_FUNCTION(pgsql)\n{\n\tPGG(default_link) = NULL;\n\tPGG(num_links) = PGG(num_persistent);\n\treturn SUCCESS;\n}", "target": 0}
{"code": "void *mempool_getbuffer(MemoryPoolHandle handle, size_t expected_buffer_size) {\n  int rc;\n  int bufs_to_allocate;\n  int bufs_that_can_be_allocated = 0;\n  struct memory_pool_element *pool_item = NULL;\n  struct mempool *pool = (struct mempool *)handle;\n  char *log_msg_fmt =\n      \"mempool(%p): mempool_getbuffer called for invalid \"\n      \"expected_buffer_size(%zu), current pool manages only \"\n      \"mempool_item_size(%zu)\";\n  char log_msg[300];\n  if (pool == NULL) {\n    return NULL;\n  }\n  if (pool->mempool_item_size != expected_buffer_size) {\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               expected_buffer_size, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_FATAL, log_msg);\n      return NULL;\n    }\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n  if (pool->free_bufs_in_pool == 0) {\n    bufs_to_allocate = pool->expandable_size / pool->mempool_item_size;\n    bufs_that_can_be_allocated = pool_can_expand_by(pool);\n    if (bufs_that_can_be_allocated > 0) {\n      bufs_to_allocate = ((bufs_to_allocate > bufs_that_can_be_allocated)\n                              ? bufs_that_can_be_allocated\n                              : bufs_to_allocate);\n      rc = freelist_allocate(pool, bufs_to_allocate);\n      if (rc != 0) {\n        if ((pool->flags & ENABLE_LOCKING) != 0) {\n          pthread_mutex_unlock(&pool->lock);\n        }\n        return NULL;\n      }\n    } else {\n      if ((pool->flags & ENABLE_LOCKING) != 0) {\n        pthread_mutex_unlock(&pool->lock);\n      }\n      return NULL;\n    }\n  }\n  if (pool->free_list != NULL) {\n    pool_item = pool->free_list;\n    pool->free_list = pool_item->next;\n    pool_item->next = (struct memory_pool_element *)NULL;\n    pool->free_bufs_in_pool--;\n  }\n  if (pool_item) {\n    pool->number_of_bufs_shared++;\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n  }\n  return (void *)pool_item;\n}", "target": 0}
{"code": "static void udp6_hwcsum_outgoing(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t const struct in6_addr *saddr,\n\t\t\t\t const struct in6_addr *daddr, int len)\n{\n\tunsigned int offset;\n\tstruct udphdr *uh = udp_hdr(skb);\n\tstruct sk_buff *frags = skb_shinfo(skb)->frag_list;\n\t__wsum csum = 0;\n\tif (!frags) {\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct udphdr, check);\n\t\tuh->check = ~csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP, 0);\n\t} else {\n\t\toffset = skb_transport_offset(skb);\n\t\tskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tdo {\n\t\t\tcsum = csum_add(csum, frags->csum);\n\t\t} while ((frags = frags->next));\n\t\tuh->check = csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP,\n\t\t\t\t\t    csum);\n\t\tif (uh->check == 0)\n\t\t\tuh->check = CSUM_MANGLED_0;\n\t}\n}", "target": 0}
{"code": "int snd_dma_alloc_pages(int type, struct device *device, size_t size,\n\t\t\tstruct snd_dma_buffer *dmab)\n{\n\tsnd_assert(size > 0, return -ENXIO);\n\tsnd_assert(dmab != NULL, return -ENXIO);\n\tdmab->dev.type = type;\n\tdmab->dev.dev = device;\n\tdmab->bytes = 0;\n\tswitch (type) {\n\tcase SNDRV_DMA_TYPE_CONTINUOUS:\n\t\tdmab->area = snd_malloc_pages(size, (unsigned long)device);\n\t\tdmab->addr = 0;\n\t\tbreak;\n#ifdef CONFIG_SBUS\n\tcase SNDRV_DMA_TYPE_SBUS:\n\t\tdmab->area = snd_malloc_sbus_pages(device, size, &dmab->addr);\n\t\tbreak;\n#endif\n\tcase SNDRV_DMA_TYPE_DEV:\n\t\tdmab->area = snd_malloc_dev_pages(device, size, &dmab->addr);\n\t\tbreak;\n\tcase SNDRV_DMA_TYPE_DEV_SG:\n\t\tsnd_malloc_sgbuf_pages(device, size, dmab, NULL);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"snd-malloc: invalid device type %d\\n\", type);\n\t\tdmab->area = NULL;\n\t\tdmab->addr = 0;\n\t\treturn -ENXIO;\n\t}\n\tif (! dmab->area)\n\t\treturn -ENOMEM;\n\tdmab->bytes = size;\n\treturn 0;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CantUseCompound) {\n    addIndex(BSON(\"x\" << 1 << \"y\" << 1));\n    runQuery(fromjson(\"{ y: 10}\"));\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\"{cscan: {dir: 1, filter: {y: 10}}}\");\n}", "target": 0}
{"code": "static unsigned long move_vma(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, unsigned long old_len,\n\t\tunsigned long new_len, unsigned long new_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma;\n\tunsigned long vm_flags = vma->vm_flags;\n\tunsigned long new_pgoff;\n\tunsigned long moved_len;\n\tunsigned long excess = 0;\n\tunsigned long hiwater_vm;\n\tint split = 0;\n\tif (mm->map_count >= sysctl_max_map_count - 3)\n\t\treturn -ENOMEM;\n\tnew_pgoff = vma->vm_pgoff + ((old_addr - vma->vm_start) >> PAGE_SHIFT);\n\tnew_vma = copy_vma(&vma, new_addr, new_len, new_pgoff);\n\tif (!new_vma)\n\t\treturn -ENOMEM;\n\tmoved_len = move_page_tables(vma, old_addr, new_vma, new_addr, old_len);\n\tif (moved_len < old_len) {\n\t\tmove_page_tables(new_vma, new_addr, vma, old_addr, moved_len);\n\t\tvma = new_vma;\n\t\told_len = new_len;\n\t\told_addr = new_addr;\n\t\tnew_addr = -ENOMEM;\n\t}\n\tif (vm_flags & VM_ACCOUNT) {\n\t\tvma->vm_flags &= ~VM_ACCOUNT;\n\t\texcess = vma->vm_end - vma->vm_start - old_len;\n\t\tif (old_addr > vma->vm_start &&\n\t\t    old_addr + old_len < vma->vm_end)\n\t\t\tsplit = 1;\n\t}\n\thiwater_vm = mm->hiwater_vm;\n\tmm->total_vm += new_len >> PAGE_SHIFT;\n\tvm_stat_account(mm, vma->vm_flags, vma->vm_file, new_len>>PAGE_SHIFT);\n\tif (do_munmap(mm, old_addr, old_len) < 0) {\n\t\tvm_unacct_memory(excess >> PAGE_SHIFT);\n\t\texcess = 0;\n\t}\n\tmm->hiwater_vm = hiwater_vm;\n\tif (excess) {\n\t\tvma->vm_flags |= VM_ACCOUNT;\n\t\tif (split)\n\t\t\tvma->vm_next->vm_flags |= VM_ACCOUNT;\n\t}\n\tif (vm_flags & VM_LOCKED) {\n\t\tmm->locked_vm += new_len >> PAGE_SHIFT;\n\t\tif (new_len > old_len)\n\t\t\tmake_pages_present(new_addr + old_len,\n\t\t\t\t\t   new_addr + new_len);\n\t}\n\treturn new_addr;\n}", "target": 0}
{"code": "Item::Type Item_name_const::type() const\n{\n  if (!valid_args)\n    return NULL_ITEM;\n  Item::Type value_type= value_item->type();\n  if (value_type == FUNC_ITEM)\n  {\n    DBUG_ASSERT(((Item_func *) value_item)->functype() == \n                Item_func::NEG_FUNC ||\n                ((Item_func *) value_item)->functype() == \n                Item_func::COLLATE_FUNC);\n    return ((Item_func *) value_item)->key_item()->type();            \n  }\n  return value_type;\n}", "target": 0}
{"code": "void ImageLoader::dispatchPendingEvent(ImageEventSender* eventSender) {\n  RESOURCE_LOADING_DVLOG(1) << \"ImageLoader::dispatchPendingEvent \" << this;\n  DCHECK(eventSender == &loadEventSender() ||\n         eventSender == &errorEventSender());\n  const AtomicString& eventType = eventSender->eventType();\n  if (eventType == EventTypeNames::load)\n    dispatchPendingLoadEvent();\n  if (eventType == EventTypeNames::error)\n    dispatchPendingErrorEvent();\n}", "target": 0}
{"code": "static void ldapsrv_call_writev_start(struct ldapsrv_call *call)\n{\n\tstruct ldapsrv_connection *conn = call->conn;\n\tstruct ldapsrv_reply *reply = NULL;\n\tstruct tevent_req *subreq = NULL;\n\tsize_t length = 0;\n\tsize_t i;\n\tcall->iov_count = 0;\n\tfor (reply = call->replies;\n\t     reply != NULL;\n\t     reply = reply->next) {\n\t\tif (length > length + reply->blob.length\n\t\t    || length + reply->blob.length > LDAP_SERVER_MAX_CHUNK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tlength += reply->blob.length;\n\t\tcall->iov_count++;\n\t}\n\tif (length == 0) {\n\t\tif (!call->notification.busy) {\n\t\t\tTALLOC_FREE(call);\n\t\t}\n\t\tldapsrv_call_read_next(conn);\n\t\treturn;\n\t}\n\tcall->iov_count = MIN(call->iov_count, IOV_MAX);\n\tcall->out_iov = talloc_array(call,\n\t\t\t\t     struct iovec,\n\t\t\t\t     call->iov_count);\n\tif (!call->out_iov) {\n\t\tldapsrv_terminate_connection(conn,\n\t\t\t\t\t     \"failed to allocate \"\n\t\t\t\t\t     \"iovec array\");\n\t\treturn;\n\t}\n\tfor (i = 0;\n\t     i < call->iov_count && call->replies != NULL;\n\t     i++) {\n\t\treply = call->replies;\n\t\tcall->out_iov[i].iov_base = reply->blob.data;\n\t\tcall->out_iov[i].iov_len = reply->blob.length;\n\t\ttalloc_steal(call->out_iov, reply->blob.data);\n\t\tDLIST_REMOVE(call->replies, reply);\n\t\tTALLOC_FREE(reply);\n\t}\n\tif (i > call->iov_count) {\n\t\tldapsrv_terminate_connection(conn,\n\t\t\t\t\t     \"call list ended\"\n\t\t\t\t\t     \"before iov_count\");\n\t\treturn;\n\t}\n\tsubreq = tstream_writev_queue_send(call,\n\t\t\t\t\t   conn->connection->event.ctx,\n\t\t\t\t\t   conn->sockets.active,\n\t\t\t\t\t   conn->sockets.send_queue,\n\t\t\t\t\t   call->out_iov, call->iov_count);\n\tif (subreq == NULL) {\n\t\tldapsrv_terminate_connection(conn, \"stream_writev_queue_send failed\");\n\t\treturn;\n\t}\n\ttevent_req_set_callback(subreq, ldapsrv_call_writev_done, call);\n}", "target": 0}
{"code": "static noinline struct kmem_cache *dma_kmalloc_cache(int index, gfp_t flags)\n{\n\tstruct kmem_cache *s;\n\tchar *text;\n\tsize_t realsize;\n\ts = kmalloc_caches_dma[index];\n\tif (s)\n\t\treturn s;\n\tif (flags & __GFP_WAIT)\n\t\tdown_write(&slub_lock);\n\telse {\n\t\tif (!down_write_trylock(&slub_lock))\n\t\t\tgoto out;\n\t}\n\tif (kmalloc_caches_dma[index])\n\t\tgoto unlock_out;\n\trealsize = kmalloc_caches[index].objsize;\n\ttext = kasprintf(flags & ~SLUB_DMA, \"kmalloc_dma-%d\",\n\t\t\t (unsigned int)realsize);\n\ts = kmalloc(kmem_size, flags & ~SLUB_DMA);\n\tif (!s || !text || !kmem_cache_open(s, flags, text,\n\t\t\trealsize, ARCH_KMALLOC_MINALIGN,\n\t\t\tSLAB_CACHE_DMA|__SYSFS_ADD_DEFERRED, NULL)) {\n\t\tkfree(s);\n\t\tkfree(text);\n\t\tgoto unlock_out;\n\t}\n\tlist_add(&s->list, &slab_caches);\n\tkmalloc_caches_dma[index] = s;\n\tschedule_work(&sysfs_add_work);\nunlock_out:\n\tup_write(&slub_lock);\nout:\n\treturn kmalloc_caches_dma[index];\n}", "target": 0}
{"code": "    int Print::printMetadata(const Exiv2::Image* image)\n    {\n        bool ret = false;\n        bool noExif = false;\n        if (Params::instance().printTags_ & Exiv2::mdExif) {\n            const Exiv2::ExifData& exifData = image->exifData();\n            for (auto md = exifData.begin(); md != exifData.end(); ++md) {\n                ret |= printMetadatum(*md, image);\n            }\n            if (exifData.empty())\n                noExif = true;\n        }\n        bool noIptc = false;\n        if (Params::instance().printTags_ & Exiv2::mdIptc) {\n            const Exiv2::IptcData& iptcData = image->iptcData();\n            for (auto md = iptcData.begin(); md != iptcData.end(); ++md) {\n                ret |= printMetadatum(*md, image);\n            }\n            if (iptcData.empty())\n                noIptc = true;\n        }\n        bool noXmp = false;\n        if (Params::instance().printTags_ & Exiv2::mdXmp) {\n            const Exiv2::XmpData& xmpData = image->xmpData();\n            for (auto md = xmpData.begin(); md != xmpData.end(); ++md) {\n                ret |= printMetadatum(*md, image);\n            }\n            if (xmpData.empty())\n                noXmp = true;\n        }\n        if (Params::instance().verbose_) {\n            if (noExif)\n                std::cerr << path_ << \": \" << _(\"No Exif data found in the file\\n\");\n            if (noIptc)\n                std::cerr << path_ << \": \" << _(\"No IPTC data found in the file\\n\");\n            if (noXmp)\n                std::cerr << path_ << \": \" << _(\"No XMP data found in the file\\n\");\n        }\n        int rc = 0;\n        if ((!Params::instance().greps_.empty() || !Params::instance().keys_.empty()) && !ret)\n            rc = 1;\n        return rc;\n    }", "target": 0}
{"code": "  void Save() {\n    url_.Save();\n    for (int i = 0; i < num_fields_; i++) {\n      fields_[i].Save();\n    }\n    for (int i = 0; i < num_values_; i++) {\n      values_[i].Save();\n    }\n  }", "target": 0}
{"code": "static int sr9700_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\treturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\n}", "target": 0}
{"code": "static bool ok_inflater_stored_block(ok_inflater *inflater) {\n    const intptr_t can_read = inflater->input_end - inflater->input;\n    if (can_read == 0) {\n        return false;\n    } else {\n        int len = ok_inflater_write_bytes(inflater, inflater->input,\n                                          min((int)can_read, inflater->state_count));\n        if (len == 0) {\n            return false;\n        }\n        inflater->input += len;\n        inflater->state_count -= len;\n        if (inflater->state_count == 0) {\n            inflater->state = OK_INFLATER_STATE_READY_FOR_NEXT_BLOCK;\n        }\n        return true;\n    }\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::ForwardWheelEvent(\n    const WebMouseWheelEvent& wheel_event) {\n  ForwardWheelEventWithLatencyInfo(wheel_event, ui::LatencyInfo());\n}", "target": 0}
{"code": "iasecc_pin_change(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data pin_cmd;\n\tstruct iasecc_pin_policy policy;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Change PIN(ref:%i,type:0x%X,lengths:%i/%i)\",\n\t       data->pin_reference, data->pin_type, data->pin1.len, data->pin2.len);\n\tif (data->pin_type != SC_AC_CHV)   {\n\t\tsc_log(ctx, \"Can not change non-CHV PINs\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\tpin_cmd = *data;\n\tpin_cmd.cmd = SC_PIN_CMD_VERIFY;\n\trv = iasecc_pin_merge_policy(card, &pin_cmd, &pin_cmd.pin1, &policy);\n\tLOG_TEST_RET(ctx, rv, \"Failed to update PIN1 info\");\n\tif (!(pin_cmd.flags & SC_PIN_CMD_USE_PINPAD)) {\n\t\trv = iasecc_chv_verify(card, &pin_cmd, policy.scbs, tries_left);\n\t\tLOG_TEST_RET(ctx, rv, \"PIN CHV verification error\");\n\t}\n\tpin_cmd.cmd = SC_PIN_CMD_CHANGE;\n\tpin_cmd.pin2 = pin_cmd.pin1;\n\tpin_cmd.pin2.prompt = data->pin2.prompt;\n\tif (pin_cmd.flags & SC_PIN_CMD_USE_PINPAD) {\n\t\tpin_cmd.pin2.data = NULL;\n\t\tpin_cmd.pin2.len = 0;\n\t} else {\n\t\tpin_cmd.pin2.data = data->pin2.data;\n\t\tpin_cmd.pin2.len = data->pin2.len;\n\t}\n\trv = iasecc_check_update_pin(&pin_cmd, &pin_cmd.pin2);\n\tLOG_TEST_RET(ctx, rv, \"Invalid PIN2\");\n\trv = iso_ops->pin_cmd(card, &pin_cmd, tries_left);\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "  virtual void Trace(blink::Visitor* visitor) {\n    ContextLifecycleObserver::Trace(visitor);\n  }", "target": 0}
{"code": "void ewk_view_statusbar_visible_get(Evas_Object* ewkView, bool* visible)\n{\n    DBG(\"%s, o=%p\", __func__, ewkView);\n    *visible = false;\n    evas_object_smart_callback_call(ewkView, \"statusbar,visible,get\", visible);\n}", "target": 0}
{"code": "  virtual const CellularNetworkVector& cellular_networks() const {\n    return cellular_networks_;\n  }", "target": 0}
{"code": "static int vmx_set_hv_timer(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 tscl = rdtsc();\n\tu64 guest_tscl = kvm_read_l1_tsc(vcpu, tscl);\n\tu64 delta_tsc = max(guest_deadline_tsc, guest_tscl) - guest_tscl;\n\tif (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio &&\n\t\t\tu64_shl_div_u64(delta_tsc,\n\t\t\t\tkvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tvcpu->arch.tsc_scaling_ratio,\n\t\t\t\t&delta_tsc))\n\t\treturn -ERANGE;\n\tif (delta_tsc >> (cpu_preemption_timer_multi + 32))\n\t\treturn -ERANGE;\n\tvmx->hv_deadline_tsc = tscl + delta_tsc;\n\tvmcs_set_bits(PIN_BASED_VM_EXEC_CONTROL,\n\t\t\tPIN_BASED_VMX_PREEMPTION_TIMER);\n\treturn delta_tsc == 0;\n}", "target": 0}
{"code": "BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \"client authentication failure\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "static int execute_decode_slices(H264Context *h, int context_count)\n{\n    AVCodecContext *const avctx = h->avctx;\n    H264Context *hx;\n    int i;\n    av_assert0(h->mb_y < h->mb_height);\n    if (h->avctx->hwaccel ||\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        return 0;\n    if (context_count == 1) {\n        return decode_slice(avctx, &h);\n    } else {\n        av_assert0(context_count > 0);\n        for (i = 1; i < context_count; i++) {\n            hx                 = h->thread_context[i];\n            if (CONFIG_ERROR_RESILIENCE) {\n                hx->er.error_count = 0;\n            }\n            hx->x264_build     = h->x264_build;\n        }\n        avctx->execute(avctx, decode_slice, h->thread_context,\n                       NULL, context_count, sizeof(void *));\n        hx                   = h->thread_context[context_count - 1];\n        h->mb_x              = hx->mb_x;\n        h->mb_y              = hx->mb_y;\n        h->droppable         = hx->droppable;\n        h->picture_structure = hx->picture_structure;\n        if (CONFIG_ERROR_RESILIENCE) {\n            for (i = 1; i < context_count; i++)\n                h->er.error_count += h->thread_context[i]->er.error_count;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static int lxcfs_fsync(const char *path, int datasync, struct fuse_file_info *fi)\n{\n\treturn 0;\n}", "target": 0}
{"code": "static int oidc_authorization_request_set_cookie(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, oidc_proto_state_t *proto_state) {\n\tchar *cookieValue = oidc_proto_state_to_cookie(r, c, proto_state);\n\tif (cookieValue == NULL)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\tint number_of_cookies = oidc_clean_expired_state_cookies(r, c, NULL,\n\t\t\toidc_cfg_delete_oldest_state_cookies(c));\n\tint max_number_of_cookies = oidc_cfg_max_number_of_state_cookies(c);\n\tif ((max_number_of_cookies > 0)\n\t\t\t&& (number_of_cookies >= max_number_of_cookies)) {\n\t\toidc_warn(r,\n\t\t\t\t\"the number of existing, valid state cookies (%d) has exceeded the limit (%d), no additional authorization request + state cookie can be generated, aborting the request\",\n\t\t\t\tnumber_of_cookies, max_number_of_cookies);\n\t\treturn HTTP_SERVICE_UNAVAILABLE;\n\t}\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\toidc_util_set_cookie(r, cookieName, cookieValue, -1,\n\t\t\tOIDC_COOKIE_SAMESITE_LAX(c, r));\n\treturn OK;\n}", "target": 0}
{"code": "GF_Err gf_isom_vvc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool keep_xps)\n{\n\treturn gf_isom_vvc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_VVCC_SET_INBAND, keep_xps);\n}", "target": 0}
{"code": "acl_fetch_meth(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n               const struct arg *args, struct sample *smp)\n{\n\tint meth;\n\tstruct http_txn *txn = l7;\n\tCHECK_HTTP_MESSAGE_FIRST_PERM();\n\tmeth = txn->meth;\n\tsmp->type = SMP_T_UINT;\n\tsmp->data.uint = meth;\n\tif (meth == HTTP_METH_OTHER) {\n\t\tif (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)\n\t\t\treturn 0;\n\t\tsmp->type = SMP_T_CSTR;\n\t\tsmp->data.str.len = txn->req.sl.rq.m_l;\n\t\tsmp->data.str.str = txn->req.chn->buf->p;\n\t}\n\tsmp->flags = SMP_F_VOL_1ST;\n\treturn 1;\n}", "target": 0}
{"code": "    bool Print::grepTag(const std::string& key)\n    {\n        bool result = Params::instance().greps_.empty();\n        for (auto g = Params::instance().greps_.begin(); !result && g != Params::instance().greps_.end(); ++g)\n        {\n            std::smatch m;\n            result = std::regex_search(key, m, *g);\n        }\n        return result;\n    }", "target": 0}
{"code": "Item_func_isnull::remove_eq_conds(THD *thd, Item::cond_result *cond_value,\n                                  bool top_level_arg)\n{\n  Item *real_item= args[0]->real_item();\n  if (real_item->type() == Item::FIELD_ITEM)\n  {\n    Field *field= ((Item_field*) real_item)->field;\n    if (((field->type() == MYSQL_TYPE_DATE) ||\n         (field->type() == MYSQL_TYPE_DATETIME)) &&\n         (field->flags & NOT_NULL_FLAG))\n    {\n      Item *item0= new(thd->mem_root) Item_int(thd, (longlong) 0, 1);\n      Item *eq_cond= new(thd->mem_root) Item_func_eq(thd, args[0], item0);\n      if (!eq_cond)\n        return this;\n      COND *cond= this;\n      if (field->table->pos_in_table_list->is_inner_table_of_outer_join())\n      {\n        Item *or_cond= new(thd->mem_root) Item_cond_or(thd, eq_cond, this);\n        if (!or_cond)\n          return this;\n        cond= or_cond;\n      }\n      else\n      {\n        cond= eq_cond;\n      }\n      cond->fix_fields(thd, &cond);\n      return cond->Item::remove_eq_conds(thd, cond_value, false);\n    }\n    if (top_level_arg) \n    {\n      if (field->flags & AUTO_INCREMENT_FLAG && !field->table->maybe_null &&\n          (thd->variables.option_bits & OPTION_AUTO_IS_NULL) &&\n          (thd->first_successful_insert_id_in_prev_stmt > 0 &&\n           thd->substitute_null_with_insert_id))\n      {\n  #ifdef HAVE_QUERY_CACHE\n        query_cache_abort(thd, &thd->query_cache_tls);\n  #endif\n        COND *new_cond, *cond= this;\n        if ((new_cond= new (thd->mem_root) Item_func_eq(thd, args[0],\n                                        new (thd->mem_root) Item_int(thd, \"last_insert_id()\",\n                                                     thd->read_first_successful_insert_id_in_prev_stmt(),\n                                                     MY_INT64_NUM_DECIMAL_DIGITS))))\n        {\n          cond= new_cond;\n          cond->fix_fields(thd, &cond);\n        }\n        thd->substitute_null_with_insert_id= FALSE;\n        *cond_value= Item::COND_OK;\n        return cond;\n      }\n    }\n  }\n  return Item::remove_eq_conds(thd, cond_value, top_level_arg);\n}", "target": 0}
{"code": "running_long_enough_to_decide_unreachable(void)\n{\n  return time_of_process_start\n    + get_options()->TestingAuthDirTimeToLearnReachability < approx_time();\n}", "target": 0}
{"code": "static ssize_t f2fs_sbi_show(struct f2fs_attr *a,\n\t\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tunsigned char *ptr = NULL;\n\tunsigned int *ui;\n\tptr = __struct_ptr(sbi, a->struct_type);\n\tif (!ptr)\n\t\treturn -EINVAL;\n\tui = (unsigned int *)(ptr + a->offset);\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", *ui);\n}", "target": 0}
{"code": "static USBDevice *usb_net_init(USBBus *bus, const char *cmdline)\n{\n    Error *local_err = NULL;\n    USBDevice *dev;\n    QemuOpts *opts;\n    int idx;\n    opts = qemu_opts_parse_noisily(qemu_find_opts(\"net\"), cmdline, false);\n    if (!opts) {\n        return NULL;\n    }\n    qemu_opt_set(opts, \"type\", \"nic\", &error_abort);\n    qemu_opt_set(opts, \"model\", \"usb\", &error_abort);\n    idx = net_client_init(opts, 0, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n        return NULL;\n    }\n    dev = usb_create(bus, \"usb-net\");\n    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);\n    return dev;\n}", "target": 0}
{"code": "    int Erase::eraseThumbnail(Exiv2::Image* image) const\n    {\n        Exiv2::ExifThumb exifThumb(image->exifData());\n        std::string thumbExt = exifThumb.extension();\n        if (thumbExt.empty()) {\n            return 0;\n        }\n        exifThumb.erase();\n        if (Params::instance().verbose_) {\n            std::cout << _(\"Erasing thumbnail data\") << std::endl;\n        }\n        return 0;\n    }", "target": 0}
{"code": "monotime(void)\n{\n\tstruct timespec ts;\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec;\n}", "target": 0}
{"code": "void AudioContext::removeChangedChannelCountMode(AudioNode* node)\n{\n    ASSERT(isGraphOwner());\n    m_deferredCountModeChange.remove(node);\n}", "target": 0}
{"code": "ThreadWatcher::~ThreadWatcher() {}", "target": 0}
{"code": "static void fib6_gc_timer_cb(unsigned long arg)\n{\n\tfib6_run_gc(0, (struct net *)arg);\n}", "target": 0}
{"code": "int main()\n{\n    gdImagePtr im;\n    im = gdImageCreate(64970, 65111);\n    gdTestAssert(im == NULL);\n    return gdNumFailures();\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, BasicSoftLimitNoIndex) {\n    addIndex(BSON(\"a\" << 1));\n    runQuerySkipNToReturn(BSON(\"x\" << 5), 0, 3);\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\"{cscan: {dir: 1, filter: {x: 5}}}\");\n}", "target": 0}
{"code": "smp_fetch_url_param(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                    const struct arg *args, struct sample *smp)\n{\n\tchar delim = '?';\n\tstruct http_txn *txn = l7;\n\tstruct http_msg *msg = &txn->req;\n\tif (!args || args[0].type != ARGT_STR ||\n\t    (args[1].type && args[1].type != ARGT_STR))\n\t\treturn 0;\n\tCHECK_HTTP_MESSAGE_FIRST();\n\tif (args[1].type)\n\t\tdelim = *args[1].data.str.str;\n\tif (!find_url_param_value(msg->chn->buf->p + msg->sl.rq.u, msg->sl.rq.u_l,\n                                 args->data.str.str, args->data.str.len,\n                                 &smp->data.str.str, &smp->data.str.len,\n                                 delim))\n\t\treturn 0;\n\tsmp->type = SMP_T_CSTR;\n\tsmp->flags = SMP_F_VOL_1ST;\n\treturn 1;\n}", "target": 0}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    xmlValidNormalizeString(ID);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "void tcp_fin(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tinet_csk_schedule_ack(sk);\n\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\tsock_set_flag(sk, SOCK_DONE);\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_RECV:\n\tcase TCP_ESTABLISHED:\n\t\ttcp_set_state(sk, TCP_CLOSE_WAIT);\n\t\tinet_csk(sk)->icsk_ack.pingpong = 1;\n\t\tbreak;\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\t\tbreak;\n\tcase TCP_LAST_ACK:\n\t\tbreak;\n\tcase TCP_FIN_WAIT1:\n\t\ttcp_send_ack(sk);\n\t\ttcp_set_state(sk, TCP_CLOSING);\n\t\tbreak;\n\tcase TCP_FIN_WAIT2:\n\t\ttcp_send_ack(sk);\n\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: Impossible, sk->sk_state=%d\\n\",\n\t\t       __func__, sk->sk_state);\n\t\tbreak;\n\t}\n\t__skb_queue_purge(&tp->out_of_order_queue);\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_reset(&tp->rx_opt);\n\tsk_mem_reclaim(sk);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tif (sk->sk_shutdown == SHUTDOWN_MASK ||\n\t\t    sk->sk_state == TCP_CLOSE)\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t\telse\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\t}\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CompoundMultikeyBoundsNoIntersect) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1), true);\n    runQuery(fromjson(\"{a: 1, b: {$gt: 3, $lte: 5}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {b:{$gt:3}}, node: {ixscan: {filter: null, \"\n        \"pattern: {a:1,b:1}, bounds: \"\n        \"{a: [[1,1,true,true]], b: [[-Infinity,5,true,true]]}}}}}\");\n}", "target": 0}
{"code": "c_valid_julian_p(int y, int m, int d, int *rm, int *rd)\n{\n    int last;\n    if (m < 0)\n\tm += 13;\n    if (m < 1 || m > 12)\n\treturn 0;\n    last = c_julian_last_day_of_month(y, m);\n    if (d < 0)\n\td = last + d + 1;\n    if (d < 1 || d > last)\n\treturn 0;\n    *rm = m;\n    *rd = d;\n    return 1;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, HintOnNonUniqueIndex) {\n    params.options = QueryPlannerParams::INDEX_INTERSECTION;\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1),\n             false,  \n             false,  \n             true);  \n    runQueryHint(fromjson(\"{a: 1, b: 1}\"), BSON(\"a\" << 1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{fetch: {filter: {b: 1}, node: \"\n        \"{ixscan: {filter: null, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "static void store_param_tinyint(NET *net, MYSQL_BIND *param)\n{\n  *(net->write_pos++)= *(uchar *) param->buffer;\n}", "target": 0}
{"code": "  size_t size() const override { return header_map_->size(); }", "target": 0}
{"code": "size_t __ksize(const void *object)\n{\n\tstruct page *page;\n\tif (unlikely(object == ZERO_SIZE_PTR))\n\t\treturn 0;\n\tpage = virt_to_head_page(object);\n\tif (unlikely(!PageSlab(page))) {\n\t\tWARN_ON(!PageCompound(page));\n\t\treturn page_size(page);\n\t}\n\treturn slab_ksize(page->slab_cache);\n}", "target": 0}
{"code": "void print_szfun(FILE* outfile, LibRaw& MyCoolRawProcessor, std::string& fn)\n{\n\tid2hr_t *Aspect;\n\tfprintf(outfile, \"%s\\t%s\\t%s\\t%d\\t%d\\n\", fn.c_str(), P1.make, P1.model, S.width,\n\t\tS.height);\n}", "target": 0}
{"code": "cdataSectionProcessor(XML_Parser parser, const char *start, const char *end,\n                      const char **endPtr) {\n  enum XML_Error result = doCdataSection(\n      parser, parser->m_encoding, &start, end, endPtr,\n      (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_ACCOUNT_DIRECT);\n  if (result != XML_ERROR_NONE)\n    return result;\n  if (start) {\n    if (parser->m_parentParser) { \n      parser->m_processor = externalEntityContentProcessor;\n      return externalEntityContentProcessor(parser, start, end, endPtr);\n    } else {\n      parser->m_processor = contentProcessor;\n      return contentProcessor(parser, start, end, endPtr);\n    }\n  }\n  return result;\n}", "target": 0}
{"code": "ospf_ls_upd_send_queue_event (struct thread *thread)\n{\n  struct ospf_interface *oi = THREAD_ARG(thread);\n  struct route_node *rn;\n  struct route_node *rnext;\n  struct list *update;\n  char again = 0;\n  oi->t_ls_upd_event = NULL;\n  if (IS_DEBUG_OSPF_EVENT)\n    zlog_debug (\"ospf_ls_upd_send_queue start\");\n  for (rn = route_top (oi->ls_upd_queue); rn; rn = rnext)\n    {\n      rnext = route_next (rn);\n      if (rn->info == NULL)\n        continue;\n      update = (struct list *)rn->info;\n      ospf_ls_upd_queue_send (oi, update, rn->p.u.prefix4);\n      if (listcount(update) == 0)\n        {\n          list_delete (rn->info);\n          rn->info = NULL;\n          route_unlock_node (rn);\n        }\n      else\n        again = 1;\n    }\n  if (again != 0)\n    {\n      if (IS_DEBUG_OSPF_EVENT)\n        zlog_debug (\"ospf_ls_upd_send_queue: update lists not cleared,\"\n                   \" %d nodes to try again, raising new event\", again);\n      oi->t_ls_upd_event = \n        thread_add_event (master, ospf_ls_upd_send_queue_event, oi, 0);\n    }\n  if (IS_DEBUG_OSPF_EVENT)\n    zlog_debug (\"ospf_ls_upd_send_queue stop\");\n  return 0;\n}", "target": 0}
{"code": "void vpcc_box_del(GF_Box *s)\n{\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox*)s;\n\tif (ptr->config) gf_odf_vp_cfg_del(ptr->config);\n\tptr->config = NULL;\n\tgf_free(ptr);\n}", "target": 0}
{"code": "do_stat(int fd, size_t baselen, const char *path, struct stat *pst, int flags, rb_encoding *enc)\n{\n#if USE_OPENDIR_AT\n    int ret = fstatat(fd, at_subpath(fd, baselen, path), pst, 0);\n#else\n    int ret = STAT(path, pst);\n#endif\n    if (ret < 0 && !to_be_ignored(errno))\n\tsys_warning(path, enc);\n    return ret;\n}", "target": 0}
{"code": "static int ida_checks(void)\n{\n\tIDA_BUG_ON(&ida, !ida_is_empty(&ida));\n\tida_check_alloc(&ida);\n\tida_check_destroy(&ida);\n\tida_check_leaf(&ida, 0);\n\tida_check_leaf(&ida, 1024);\n\tida_check_leaf(&ida, 1024 * 64);\n\tida_check_max(&ida);\n\tida_check_conv(&ida);\n\tida_check_bad_free(&ida);\n\tprintk(\"IDA: %u of %u tests passed\\n\", tests_passed, tests_run);\n\treturn (tests_run != tests_passed) ? 0 : -EINVAL;\n}", "target": 0}
{"code": "int tls1_new(SSL *s)\n{\n    if (!ssl3_new(s))\n        return (0);\n    s->method->ssl_clear(s);\n    return (1);\n}", "target": 0}
{"code": "  void CycleRunLoops() {\n    content::RunAllPendingInMessageLoop();\n#if defined(OS_MACOSX)\n    chrome::testing::NSRunLoopRunAllPending();\n    AutoreleasePool()->Recycle();\n#endif\n  }", "target": 0}
{"code": "void WebGraphicsContext3DDefaultImpl::getFramebufferAttachmentParameteriv(unsigned long target, unsigned long attachment,\n                                                                          unsigned long pname, int* value)\n{\n    makeContextCurrent();\n    if (attachment == GL_DEPTH_STENCIL_ATTACHMENT)\n        attachment = GL_DEPTH_ATTACHMENT; \n    glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, value);\n}", "target": 0}
{"code": "int git_pkt_buffer_have(git_oid *oid, git_buf *buf)\n{\n\tchar oidhex[GIT_OID_HEXSZ + 1];\n\tmemset(oidhex, 0x0, sizeof(oidhex));\n\tgit_oid_fmt(oidhex, oid);\n\treturn git_buf_printf(buf, \"%s%s\\n\", pkt_have_prefix, oidhex);\n}", "target": 0}
{"code": "static Eina_Bool _ewk_view_smart_enable_render(Ewk_View_Smart_Data* smartData)\n{\n    WRN(\"not supported by engine. smartData=%p\", smartData);\n    return false;\n}", "target": 0}
{"code": "static int getnpasses(Jpeg2000DecoderContext *s)\n{\n    int num;\n    if (!get_bits(s, 1))\n        return 1;\n    if (!get_bits(s, 1))\n        return 2;\n    if ((num = get_bits(s, 2)) != 3)\n        return num < 0 ? num : 3 + num;\n    if ((num = get_bits(s, 5)) != 31)\n        return num < 0 ? num : 6 + num;\n    num = get_bits(s, 7);\n    return num < 0 ? num : 37 + num;\n}", "target": 0}
{"code": "void d_invalidate(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\tfor (;;) {\n\t\tstruct detach_data data;\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n}", "target": 0}
{"code": "void usbredirparser_send_start_bulk_receiving(struct usbredirparser *parser,\n    uint64_t id,\n    struct usb_redir_start_bulk_receiving_header *start_bulk_receiving)\n{\n    usbredirparser_queue(parser, usb_redir_start_bulk_receiving, id,\n                         start_bulk_receiving, NULL, 0);\n}", "target": 0}
{"code": "static MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n  MagickBooleanType\n    status;\n  ssize_t\n    y;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    PixelPacket\n      *magick_restrict q;\n    ssize_t\n      x;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n      a=QuantumScale*GetPixela(q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(q,QuantumRange*a);\n      SetPixelb(q,QuantumRange*b);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}", "target": 0}
{"code": "win_alloc(win_T *after UNUSED, int hidden UNUSED)\n{\n    win_T\t*new_wp;\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    new_wp->w_id = ++last_win_id;\n#ifdef FEAT_EVAL\n    new_wp->w_vars = dict_alloc();\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n    block_autocmds();\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_match_head = NULL;\n    new_wp->w_next_match_id = 4;\n#endif\n    return new_wp;\n}", "target": 0}
{"code": "userauth_kbdint(Authctxt *authctxt)\n{\n\tint authenticated = 0;\n\tchar *lang, *devs;\n\tlang = packet_get_string(NULL);\n\tdevs = packet_get_string(NULL);\n\tpacket_check_eom();\n\tdebug(\"keyboard-interactive devs %s\", devs);\n\tif (options.challenge_response_authentication)\n\t\tauthenticated = auth2_challenge(authctxt, devs);\n\txfree(devs);\n\txfree(lang);\n#ifdef HAVE_CYGWIN\n\tif (check_nt_auth(0, authctxt->pw) == 0)\n\t\treturn(0);\n#endif\n\treturn authenticated;\n}", "target": 0}
{"code": "lowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}", "target": 0}
{"code": "static int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\tif (efer & efer_reserved_bits)\n\t\treturn 1;\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\tif (efer & EFER_FFXSR) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n\t\t\treturn 1;\n\t}\n\tif (efer & EFER_SVME) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n\t\t\treturn 1;\n\t}\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}", "target": 0}
{"code": "fbFetchPixel_a1r5g5b5 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32  pixel = READ((CARD16 *) bits + offset);\n    CARD32  a,r,g,b;\n    a = (CARD32) ((CARD8) (0 - ((pixel & 0x8000) >> 15))) << 24;\n    r = ((pixel & 0x7c00) | ((pixel & 0x7000) >> 5)) << 9;\n    g = ((pixel & 0x03e0) | ((pixel & 0x0380) >> 5)) << 6;\n    b = ((pixel & 0x001c) | ((pixel & 0x001f) << 5)) >> 2;\n    return (a | r | g | b);\n}", "target": 0}
{"code": "hncp_print(netdissect_options *ndo,\n           const u_char *cp, u_int length)\n{\n    ND_PRINT((ndo, \"hncp (%d)\", length));\n    hncp_print_rec(ndo, cp, length, 1);\n}", "target": 0}
{"code": "passIsLeftParen ()\n{\n  pass_Codes passCode = passGetScriptToken ();\n  if (passCode != pass_leftParen)\n    {\n      compileError (passNested, \"'(' expected\");\n      return 0;\n    }\n  return 1;\n}", "target": 0}
{"code": "bool OverscrollControllerAndroid::WillHandleGestureEvent(\n    const blink::WebGestureEvent& event) {\n  if (!enabled_)\n    return false;\n  if (!refresh_effect_)\n    return false;\n  if (is_fullscreen_)\n    return false;\n  if (glow_effect_ && glow_effect_->IsActive()) {\n    if (glow_effect_->GetVisibleAlpha() > MinGlowAlphaToDisableRefresh())\n      return false;\n  }\n  bool handled = false;\n  switch (event.type) {\n    case blink::WebInputEvent::GestureScrollBegin:\n      refresh_effect_->OnScrollBegin();\n      break;\n    case blink::WebInputEvent::GestureScrollUpdate: {\n      gfx::Vector2dF scroll_delta(event.data.scrollUpdate.deltaX,\n                                  event.data.scrollUpdate.deltaY);\n      scroll_delta.Scale(dpi_scale_);\n      handled = refresh_effect_->WillHandleScrollUpdate(scroll_delta);\n    } break;\n    case blink::WebInputEvent::GestureScrollEnd:\n      refresh_effect_->OnScrollEnd(gfx::Vector2dF());\n      break;\n    case blink::WebInputEvent::GestureFlingStart: {\n      if (refresh_effect_->IsActive()) {\n        gfx::Vector2dF scroll_velocity(event.data.flingStart.velocityX,\n                                       event.data.flingStart.velocityY);\n        scroll_velocity.Scale(dpi_scale_);\n        refresh_effect_->OnScrollEnd(scroll_velocity);\n        blink::WebGestureEvent& modified_event =\n            const_cast<blink::WebGestureEvent&>(event);\n        modified_event.data.flingStart.velocityX = .01f;\n        modified_event.data.flingStart.velocityY = .01f;\n      }\n    } break;\n    case blink::WebInputEvent::GesturePinchBegin:\n      refresh_effect_->ReleaseWithoutActivation();\n      break;\n    default:\n      break;\n  }\n  return handled;\n}", "target": 0}
{"code": "void EmbeddedWorkerContextClient::SendWorkerStarted() {\n  DCHECK(worker_task_runner_->RunsTasksOnCurrentThread());\n  sender_->Send(new EmbeddedWorkerHostMsg_WorkerStarted(\n      WorkerTaskRunner::Instance()->CurrentWorkerId(),\n      embedded_worker_id_));\n}", "target": 0}
{"code": "__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t   __be16 sport, __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + daddr[i];\n\tsecret[4] = net_secret[4] +\n\t\t(((__force u16)sport << 16) + (__force u16)dport);\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\treturn seq_scale(hash[0]);\n}", "target": 0}
{"code": "    TiffComponent::TiffComponent(uint16_t tag, IfdId group)\n        : tag_(tag), group_(group), pStart_(0)\n    {\n    }", "target": 0}
{"code": "static void __exit llc2_exit(void)\n{\n\tllc_station_exit();\n\tllc_remove_pack(LLC_DEST_SAP);\n\tllc_remove_pack(LLC_DEST_CONN);\n\tsock_unregister(PF_LLC);\n\tllc_proc_exit();\n\tllc_sysctl_exit();\n\tproto_unregister(&llc_proto);\n}", "target": 0}
{"code": "static void perpendicular_mode(void)\n{\n\tunsigned char perp_mode;\n\tif (raw_cmd->rate & 0x40) {\n\t\tswitch (raw_cmd->rate & 3) {\n\t\tcase 0:\n\t\t\tperp_mode = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tperp_mode = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINT(\"Invalid data rate for perpendicular mode!\\n\");\n\t\t\tcont->done(0);\n\t\t\tFDCS->reset = 1;\n\t\t\treturn;\n\t\t}\n\t} else\n\t\tperp_mode = 0;\n\tif (FDCS->perp_mode == perp_mode)\n\t\treturn;\n\tif (FDCS->version >= FDC_82077_ORIG) {\n\t\toutput_byte(FD_PERPENDICULAR);\n\t\toutput_byte(perp_mode);\n\t\tFDCS->perp_mode = perp_mode;\n\t} else if (perp_mode) {\n\t\tDPRINT(\"perpendicular mode not supported by this FDC.\\n\");\n\t}\n}\t\t\t\t", "target": 0}
{"code": "static ssize_t show_rps_dev_flow_table_cnt(struct netdev_rx_queue *queue,\n\t\t\t\t\t   char *buf)\n{\n\tstruct rps_dev_flow_table *flow_table;\n\tunsigned long val = 0;\n\trcu_read_lock();\n\tflow_table = rcu_dereference(queue->rps_flow_table);\n\tif (flow_table)\n\t\tval = (unsigned long)flow_table->mask + 1;\n\trcu_read_unlock();\n\treturn sprintf(buf, \"%lu\\n\", val);", "target": 0}
{"code": "static int nested_ept_init_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON(mmu_is_nested(vcpu));\n\tif (!valid_ept_address(vcpu, nested_ept_get_cr3(vcpu)))\n\t\treturn 1;\n\tkvm_mmu_unload(vcpu);\n\tkvm_init_shadow_ept_mmu(vcpu,\n\t\t\tto_vmx(vcpu)->nested.nested_vmx_ept_caps &\n\t\t\tVMX_EPT_EXECUTE_ONLY_BIT,\n\t\t\tnested_ept_ad_enabled(vcpu));\n\tvcpu->arch.mmu.set_cr3           = vmx_set_cr3;\n\tvcpu->arch.mmu.get_cr3           = nested_ept_get_cr3;\n\tvcpu->arch.mmu.inject_page_fault = nested_ept_inject_page_fault;\n\tvcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;\n\treturn 0;\n}", "target": 0}
{"code": "assemble_neg_contexts(struct smb2_negotiate_req *req,\n\t\t      unsigned int *total_len)\n{\n\tchar *pneg_ctxt = (char *)req;\n\tunsigned int ctxt_len;\n\tif (*total_len > 200) {\n\t\tcifs_dbg(VFS, \"Bad frame length assembling neg contexts\\n\");\n\t\treturn;\n\t}\n\t*total_len = roundup(*total_len, 8);\n\tpneg_ctxt = (*total_len) + (char *)req;\n\treq->NegotiateContextOffset = cpu_to_le32(*total_len);\n\tbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt);\n\tctxt_len = DIV_ROUND_UP(sizeof(struct smb2_preauth_neg_context), 8) * 8;\n\t*total_len += ctxt_len;\n\tpneg_ctxt += ctxt_len;\n\tbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt);\n\tctxt_len = DIV_ROUND_UP(sizeof(struct smb2_encryption_neg_context), 8) * 8;\n\t*total_len += ctxt_len;\n\tpneg_ctxt += ctxt_len;\n\tbuild_posix_ctxt((struct smb2_posix_neg_context *)pneg_ctxt);\n\t*total_len += sizeof(struct smb2_posix_neg_context);\n\treq->NegotiateContextCount = cpu_to_le16(3);\n}", "target": 0}
{"code": "rb_reg_init_str_enc(VALUE re, VALUE s, rb_encoding *enc, int options)\n{\n    onig_errmsg_buffer err = \"\";\n    if (rb_reg_initialize(re, RSTRING_PTR(s), RSTRING_LEN(s),\n\t\t\t  enc, options, err, NULL, 0) != 0) {\n\trb_reg_raise_str(s, options, err);\n    }\n    reg_set_source(re, s, enc);\n    return re;\n}", "target": 0}
{"code": "struct rose_neigh *rose_get_neigh(rose_address *addr, unsigned char *cause,\n\tunsigned char *diagnostic, int route_frame)\n{\n\tstruct rose_neigh *res = NULL;\n\tstruct rose_node *node;\n\tint failed = 0;\n\tint i;\n\tif (!route_frame) spin_lock_bh(&rose_node_list_lock);\n\tfor (node = rose_node_list; node != NULL; node = node->next) {\n\t\tif (rosecmpm(addr, &node->address, node->mask) == 0) {\n\t\t\tfor (i = 0; i < node->count; i++) {\n\t\t\t\tif (node->neighbour[i]->restarted) {\n\t\t\t\t\tres = node->neighbour[i];\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!route_frame) { \n\t\tfor (node = rose_node_list; node != NULL; node = node->next) {\n\t\t\tif (rosecmpm(addr, &node->address, node->mask) == 0) {\n\t\t\t\tfor (i = 0; i < node->count; i++) {\n\t\t\t\t\tif (!rose_ftimer_running(node->neighbour[i])) {\n\t\t\t\t\t\tres = node->neighbour[i];\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tfailed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (failed) {\n\t\t*cause      = ROSE_OUT_OF_ORDER;\n\t\t*diagnostic = 0;\n\t} else {\n\t\t*cause      = ROSE_NOT_OBTAINABLE;\n\t\t*diagnostic = 0;\n\t}\nout:\n\tif (!route_frame) spin_unlock_bh(&rose_node_list_lock);\n\treturn res;\n}", "target": 0}
{"code": "bool HTMLTextAreaElement::valueMissing() const\n{\n    return willValidate() && valueMissing(value());\n}", "target": 0}
{"code": "acpi_map_vaddr_lookup(acpi_physical_address phys, unsigned int size)\n{\n\tstruct acpi_ioremap *map;\n\tmap = acpi_map_lookup(phys, size);\n\tif (map)\n\t\treturn map->virt + (phys - map->phys);\n\treturn NULL;\n}", "target": 0}
{"code": "void HTMLMediaElement::LoadNextSourceChild() {\n  String content_type;\n  KURL media_url = SelectNextSourceChild(&content_type, kComplain);\n  if (!media_url.IsValid()) {\n    WaitForSourceChange();\n    return;\n  }\n  ResetMediaPlayerAndMediaSource();\n  load_state_ = kLoadingFromSourceElement;\n  LoadResource(WebMediaPlayerSource(WebURL(media_url)), content_type);\n}", "target": 0}
{"code": "static void prep_write_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle = 0;\n\tuint16_t offset;\n\tstruct gatt_db_attribute *attr;\n\tstruct prep_write_complete_data *pwcd;\n\tuint8_t ecode, status;\n\tif (length < 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\tif (queue_length(server->prep_queue) >= server->max_prep_queue_len) {\n\t\tecode = BT_ATT_ERROR_PREPARE_QUEUE_FULL;\n\t\tgoto error;\n\t}\n\thandle = get_le16(pdu);\n\toffset = get_le16(pdu + 2);\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Prep Write Req - handle: 0x%04x\", handle);\n\tecode = check_length(length, offset);\n\tif (ecode)\n\t\tgoto error;\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\tpwcd = new0(struct prep_write_complete_data, 1);\n\tpwcd->chan = chan;\n\tpwcd->pdu = malloc(length);\n\tmemcpy(pwcd->pdu, pdu, length);\n\tpwcd->length = length;\n\tpwcd->server = server;\n\tstatus = gatt_db_attribute_write(attr, offset, NULL, 0,\n\t\t\t\t\t\tBT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\tprep_write_complete_cb, pwcd);\n\tif (status)\n\t\treturn;\n\tecode = BT_ATT_ERROR_UNLIKELY;\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}", "target": 0}
{"code": "node_new_ctype(int type, int not, int ascii_range)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n  SET_NTYPE(node, NT_CTYPE);\n  NCTYPE(node)->ctype = type;\n  NCTYPE(node)->not   = not;\n  NCTYPE(node)->ascii_range = ascii_range;\n  return node;\n}", "target": 0}
{"code": "static void vnc_init_basic_info_from_server_addr(int fd, VncBasicInfo *info,\n                                                 Error **errp)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen;\n    salen = sizeof(sa);\n    if (getsockname(fd, (struct sockaddr*)&sa, &salen) < 0) {\n        error_setg_errno(errp, errno, \"getsockname failed\");\n        return;\n    }\n    vnc_init_basic_info(&sa, salen, info, errp);\n}", "target": 0}
{"code": "send_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, u8 info_class,\n\t       u8 info_type, u32 additional_info, unsigned int num,\n\t\tvoid **data, unsigned int *size)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = 0;\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\tif (!num)\n\t\treturn -EINVAL;\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\tiov = kmalloc_array(num, sizeof(struct kvec), GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = num;\n\trc = SMB2_set_info_init(tcon, &rqst, persistent_fid, volatile_fid, pid,\n\t\t\t\tinfo_class, info_type, additional_info,\n\t\t\t\tdata, size);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags,\n\t\t\t    &rsp_iov);\n\tSMB2_set_info_free(&rqst);\n\trsp = (struct smb2_set_info_rsp *)rsp_iov.iov_base;\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\t\ttrace_smb3_set_info_err(xid, persistent_fid, tcon->tid,\n\t\t\t\tses->Suid, info_class, (__u32)info_type, rc);\n\t}\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}", "target": 0}
{"code": "SYSCALL_DEFINE1(uselib, const char __user *, library)\n{\n\tstruct linux_binfmt *fmt;\n\tstruct file *file;\n\tstruct filename *tmp = getname(library);\n\tint error = PTR_ERR(tmp);\n\tstatic const struct open_flags uselib_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_READ | MAY_EXEC,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\tif (IS_ERR(tmp))\n\t\tgoto out;\n\tfile = do_filp_open(AT_FDCWD, tmp, &uselib_flags);\n\tputname(tmp);\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\terror = -EINVAL;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\terror = -EACCES;\n\tif (path_noexec(&file->f_path))\n\t\tgoto exit;\n\tfsnotify_open(file);\n\terror = -ENOEXEC;\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!fmt->load_shlib)\n\t\t\tcontinue;\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\terror = fmt->load_shlib(file);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tif (error != -ENOEXEC)\n\t\t\tbreak;\n\t}\n\tread_unlock(&binfmt_lock);\nexit:\n\tfput(file);\nout:\n  \treturn error;\n}", "target": 0}
{"code": "const char *server_feature_value(const char *feature, int *len)\n{\n\treturn parse_feature_value(server_capabilities_v1, feature, len);\n}", "target": 0}
{"code": "  virtual void UpdateSystemInfo() {}", "target": 0}
{"code": "static void tipc_node_free(struct rcu_head *rp)\n{\n\tstruct tipc_node *n = container_of(rp, struct tipc_node, rcu);\n#ifdef CONFIG_TIPC_CRYPTO\n\ttipc_crypto_stop(&n->crypto_rx);\n#endif\n\tkfree(n);\n}", "target": 0}
{"code": "  virtual void RemoveObserverForAllNetworks(NetworkObserver* observer) {\n    DCHECK(observer);\n    NetworkObserverMap::iterator map_iter = network_observers_.begin();\n    while (map_iter != network_observers_.end()) {\n      map_iter->second->RemoveObserver(observer);\n      if (!map_iter->second->size()) {\n        delete map_iter->second;\n        network_observers_.erase(map_iter++);\n      } else {\n        ++map_iter;\n      }\n    }\n  }", "target": 0}
{"code": "update_specialized_profile (struct cgraph_node *new_node,\n\t\t\t    struct cgraph_node *orig_node,\n\t\t\t    profile_count redirected_sum)\n{\n  struct cgraph_edge *cs;\n  profile_count new_node_count, orig_node_count = orig_node->count;\n  if (dump_file)\n    {\n      fprintf (dump_file, \"    the sum of counts of redirected  edges is \");\n      redirected_sum.dump (dump_file);\n      fprintf (dump_file, \"\\n\");\n    }\n  if (!(orig_node_count > profile_count::zero ()))\n    return;\n  gcc_assert (orig_node_count >= redirected_sum);\n  new_node_count = new_node->count;\n  new_node->count += redirected_sum;\n  orig_node->count -= redirected_sum;\n  for (cs = new_node->callees; cs; cs = cs->next_callee)\n    cs->count += cs->count.apply_scale (redirected_sum, new_node_count);\n  for (cs = orig_node->callees; cs; cs = cs->next_callee)\n    {\n      profile_count dec = cs->count.apply_scale (redirected_sum,\n\t\t\t\t\t\t orig_node_count);\n      cs->count -= dec;\n    }\n  if (dump_file)\n    dump_profile_updates (orig_node, new_node);\n}", "target": 0}
{"code": "static void target_destroy(struct avrcp *session)\n{\n\tstruct avrcp_data *target = session->target;\n\tstruct avrcp_player *player = target->player;\n\tDBG(\"%p\", target);\n\tif (player != NULL)\n\t\tplayer->sessions = g_slist_remove(player->sessions, session);\n\tg_free(target);\n}", "target": 0}
{"code": "void QuantizeMultiplier(double double_multiplier, int32_t* quantized_multiplier,\n                        int* left_shift) {\n  if (double_multiplier < 1.0) {\n    QuantizeMultiplierSmallerThanOneExp(double_multiplier, quantized_multiplier,\n                                        left_shift);\n  } else {\n    QuantizeMultiplierGreaterThanOne(double_multiplier, quantized_multiplier,\n                                     left_shift);\n  }\n}", "target": 0}
{"code": "  static void launch(OpKernelContext* context, bool cudnn_use_autotune,\n                     const Tensor& input, const Tensor& filter,\n                     const std::array<int64, 3>& dilations,\n                     const std::array<int64, 3>& strides, const Padding padding,\n                     TensorFormat data_format, Tensor* output) {\n    OP_REQUIRES(context, data_format == FORMAT_NHWC,\n                errors::InvalidArgument(\"CPU implementation of Conv3D \"\n                                        \"currently only supports the NHWC \"\n                                        \"tensor format.\"));\n    OP_REQUIRES(context,\n                dilations[0] == 1 && dilations[1] == 1 && dilations[2] == 1,\n                errors::InvalidArgument(\"CPU implementation of Conv3D \"\n                                        \"currently only supports dilated rates \"\n                                        \"of 1.\"));\n    OP_REQUIRES(context, filter.dim_size(3) == input.dim_size(input.dims() - 1),\n                errors::InvalidArgument(\n                    \"Number of channels in filter (\", filter.dim_size(3),\n                    \") must match last dimension of input (\",\n                    input.dim_size(input.dims() - 1), \")\"));\n    functor::CuboidConvolution<CPUDevice, T>()(\n        context->eigen_device<CPUDevice>(), output->tensor<T, 5>(),\n        input.tensor<T, 5>(), filter.tensor<T, 5>(), strides[2], strides[1],\n        strides[0], BrainPadding2EigenPadding(padding));\n  }", "target": 0}
{"code": "void sas_deform_port(struct asd_sas_phy *phy, int gone)\n{\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(sas_ha->core.shost->transportt);\n\tstruct domain_device *dev;\n\tunsigned long flags;\n\tif (!port)\n\t\treturn;\t\t  \n\tdev = port->port_dev;\n\tif (dev)\n\t\tdev->pathways--;\n\tif (port->num_phys == 1) {\n\t\tsas_unregister_domain_devices(port, gone);\n\t\tsas_destruct_devices(port);\n\t\tsas_port_delete(port->port);\n\t\tport->port = NULL;\n\t} else {\n\t\tsas_port_delete_phy(port->port, phy->phy);\n\t\tsas_device_set_phy(dev, port->port);\n\t}\n\tif (si->dft->lldd_port_deformed)\n\t\tsi->dft->lldd_port_deformed(phy);\n\tspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\n\tspin_lock(&port->phy_list_lock);\n\tlist_del_init(&phy->port_phy_el);\n\tsas_phy_set_target(phy, NULL);\n\tphy->port = NULL;\n\tport->num_phys--;\n\tport->phy_mask &= ~(1U << phy->id);\n\tif (port->num_phys == 0) {\n\t\tINIT_LIST_HEAD(&port->phy_list);\n\t\tmemset(port->sas_addr, 0, SAS_ADDR_SIZE);\n\t\tmemset(port->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tport->class = 0;\n\t\tport->iproto = 0;\n\t\tport->tproto = 0;\n\t\tport->oob_mode = 0;\n\t\tport->phy_mask = 0;\n\t}\n\tspin_unlock(&port->phy_list_lock);\n\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\treturn;\n}", "target": 0}
{"code": "SoftVPXEncoder::~SoftVPXEncoder() {\n    releaseEncoder();\n}", "target": 0}
{"code": "ospf_packet_max (struct ospf_interface *oi)\n{\n  int max;\n  max = oi->ifp->mtu - ospf_packet_authspace(oi);\n  max -= (OSPF_HEADER_SIZE + sizeof (struct ip));\n  return max;\n}", "target": 0}
{"code": "kvm_pfn_t gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\treturn __gfn_to_pfn_memslot(slot, gfn, false, NULL, true, NULL);\n}", "target": 0}
{"code": "const_expression_in_where(COND *cond, Item *comp_item, Field *comp_field,\n                          Item **const_item)\n{\n  DBUG_ASSERT((comp_item == NULL) ^ (comp_field == NULL));\n  Item *intermediate= NULL;\n  if (const_item == NULL)\n    const_item= &intermediate;\n  if (cond->type() == Item::COND_ITEM)\n  {\n    bool and_level= (((Item_cond*) cond)->functype()\n\t\t     == Item_func::COND_AND_FUNC);\n    List_iterator_fast<Item> li(*((Item_cond*) cond)->argument_list());\n    Item *item;\n    while ((item=li++))\n    {\n      bool res=const_expression_in_where(item, comp_item, comp_field,\n                                         const_item);\n      if (res)\t\t\t\t\t\n      {\n\tif (and_level)\n\t  return 1;\n      }\n      else if (!and_level)\n\treturn 0;\n    }\n    return and_level ? 0 : 1;\n  }\n  else if (cond->eq_cmp_result() != Item::COND_OK)\n  {\t\t\t\t\t\t\n    Item_func* func= (Item_func*) cond;\n    if (func->functype() != Item_func::EQUAL_FUNC &&\n\tfunc->functype() != Item_func::EQ_FUNC)\n      return 0;\n    Item *left_item=\t((Item_func*) cond)->arguments()[0];\n    Item *right_item= ((Item_func*) cond)->arguments()[1];\n    if (equal(left_item, comp_item, comp_field))\n    {\n      if (test_if_equality_guarantees_uniqueness (left_item, right_item))\n      {\n\tif (*const_item)\n\t  return right_item->eq(*const_item, 1);\n\t*const_item=right_item;\n\treturn 1;\n      }\n    }\n    else if (equal(right_item, comp_item, comp_field))\n    {\n      if (test_if_equality_guarantees_uniqueness (right_item, left_item))\n      {\n\tif (*const_item)\n\t  return left_item->eq(*const_item, 1);\n\t*const_item=left_item;\n\treturn 1;\n      }\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "showDots (widechar const *dots, int length)\n{\n  int bufPos = 0;\n  int dotsPos;\n  for (dotsPos = 0; bufPos < sizeof (scratchBuf) && dotsPos < length;\n       dotsPos++)\n    {\n      if ((dots[dotsPos] & B1))\n\tscratchBuf[bufPos++] = '1';\n      if ((dots[dotsPos] & B2))\n\tscratchBuf[bufPos++] = '2';\n      if ((dots[dotsPos] & B3))\n\tscratchBuf[bufPos++] = '3';\n      if ((dots[dotsPos] & B4))\n\tscratchBuf[bufPos++] = '4';\n      if ((dots[dotsPos] & B5))\n\tscratchBuf[bufPos++] = '5';\n      if ((dots[dotsPos] & B6))\n\tscratchBuf[bufPos++] = '6';\n      if ((dots[dotsPos] & B7))\n\tscratchBuf[bufPos++] = '7';\n      if ((dots[dotsPos] & B8))\n\tscratchBuf[bufPos++] = '8';\n      if ((dots[dotsPos] & B9))\n\tscratchBuf[bufPos++] = '9';\n      if ((dots[dotsPos] & B10))\n\tscratchBuf[bufPos++] = 'A';\n      if ((dots[dotsPos] & B11))\n\tscratchBuf[bufPos++] = 'B';\n      if ((dots[dotsPos] & B12))\n\tscratchBuf[bufPos++] = 'C';\n      if ((dots[dotsPos] & B13))\n\tscratchBuf[bufPos++] = 'D';\n      if ((dots[dotsPos] & B14))\n\tscratchBuf[bufPos++] = 'E';\n      if ((dots[dotsPos] & B15))\n\tscratchBuf[bufPos++] = 'F';\n      if ((dots[dotsPos] == B16))\n\tscratchBuf[bufPos++] = '0';\n      if (dotsPos != length - 1)\n\tscratchBuf[bufPos++] = '-';\n    }\n  scratchBuf[bufPos] = 0;\n  return &scratchBuf[0];\n}", "target": 0}
{"code": "tun_open(int tun, int mode, char **ifname)\n{\n#if defined(CUSTOM_SYS_TUN_OPEN)\n\treturn (sys_tun_open(tun, mode, ifname));\n#elif defined(SSH_TUN_OPENBSD)\n\tstruct ifreq ifr;\n\tchar name[100];\n\tint fd = -1, sock;\n\tconst char *tunbase = \"tun\";\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\tif (mode == SSH_TUNMODE_ETHERNET)\n\t\ttunbase = \"tap\";\n\tif (tun <= SSH_TUNID_MAX) {\n\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\", tunbase, tun);\n\t\tfd = open(name, O_RDWR);\n\t} else if (tun == SSH_TUNID_ANY) {\n\t\tfor (tun = 100; tun >= 0; tun--) {\n\t\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\",\n\t\t\t    tunbase, tun);\n\t\t\tif ((fd = open(name, O_RDWR)) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdebug_f(\"invalid tunnel %u\", tun);\n\t\treturn -1;\n\t}\n\tif (fd == -1) {\n\t\tdebug_f(\"%s open: %s\", name, strerror(errno));\n\t\treturn -1;\n\t}\n\tdebug_f(\"%s mode %d fd %d\", name, mode, fd);\n\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), \"%s%d\", tunbase, tun);\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\tgoto failed;\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {\n\t\tdebug_f(\"get interface %s flags: %s\", ifr.ifr_name,\n\t\t    strerror(errno));\n\t\tgoto failed;\n\t}\n\tif (!(ifr.ifr_flags & IFF_UP)) {\n\t\tifr.ifr_flags |= IFF_UP;\n\t\tif (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {\n\t\t\tdebug_f(\"activate interface %s: %s\", ifr.ifr_name,\n\t\t\t    strerror(errno));\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tif (ifname != NULL)\n\t\t*ifname = xstrdup(ifr.ifr_name);\n\tclose(sock);\n\treturn fd;\n failed:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (sock >= 0)\n\t\tclose(sock);\n\treturn -1;\n#else\n\terror(\"Tunnel interfaces are not supported on this platform\");\n\treturn (-1);\n#endif\n}", "target": 0}
{"code": "static int rename_node(struct fuse *f, fuse_ino_t olddir, const char *oldname,\n                        fuse_ino_t newdir, const char *newname, int hide)\n{\n    struct node *node;\n    struct node *newnode;\n    int err = 0;\n    pthread_mutex_lock(&f->lock);\n    node  = lookup_node(f, olddir, oldname);\n    newnode  = lookup_node(f, newdir, newname);\n    if (node == NULL)\n        goto out;\n    if (newnode != NULL) {\n        if (hide) {\n            fprintf(stderr, \"fuse: hidden file got created during hiding\\n\");\n            err = -EBUSY;\n            goto out;\n        }\n        unhash_name(f, newnode);\n    }\n    unhash_name(f, node);\n    if (hash_name(f, node, newdir, newname) == -1) {\n        err = -ENOMEM;\n        goto out;\n    }\n    if (hide)\n        node->is_hidden = 1;\n out:\n    pthread_mutex_unlock(&f->lock);\n    return err;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::Focus() {\n  is_focused_ = true;\n  Send(new InputMsg_SetFocus(routing_id_, true));\n  if (RenderViewHost::From(this) && delegate_)\n    delegate_->ReplicatePageFocus(true);\n}", "target": 0}
{"code": "set_error (GMarkupParseContext  *context,\n           GError              **error,\n           GMarkupError          code,\n           const gchar          *format,\n           ...)\n{\n  gchar *s;\n  gchar *s_valid;\n  va_list args;\n  va_start (args, format);\n  s = g_strdup_vprintf (format, args);\n  va_end (args);\n  s_valid = g_utf8_make_valid (s, -1);\n  set_error_literal (context, error, code, s);\n  g_free (s);\n  g_free (s_valid);\n}", "target": 0}
{"code": "dirvote_compute_params(smartlist_t *votes, int method, int total_authorities)\n{\n  int i;\n  int32_t *vals;\n  int cur_param_len;\n  const char *cur_param;\n  const char *eq;\n  const int n_votes = smartlist_len(votes);\n  smartlist_t *output;\n  smartlist_t *param_list = smartlist_new();\n  (void) method;\n  vals = tor_calloc(n_votes, sizeof(int));\n  SMARTLIST_FOREACH_BEGIN(votes, networkstatus_t *, v) {\n    if (!v->net_params)\n      continue;\n    smartlist_add_all(param_list, v->net_params);\n  } SMARTLIST_FOREACH_END(v);\n  if (smartlist_len(param_list) == 0) {\n    tor_free(vals);\n    return param_list;\n  }\n  smartlist_sort_strings(param_list);\n  i = 0;\n  cur_param = smartlist_get(param_list, 0);\n  eq = strchr(cur_param, '=');\n  tor_assert(eq);\n  cur_param_len = (int)(eq+1 - cur_param);\n  output = smartlist_new();\n  SMARTLIST_FOREACH_BEGIN(param_list, const char *, param) {\n    const char *next_param;\n    int ok=0;\n    eq = strchr(param, '=');\n    tor_assert(i<n_votes); \n    vals[i++] = (int32_t)\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n    tor_assert(ok); \n    if (param_sl_idx+1 == smartlist_len(param_list))\n      next_param = NULL;\n    else\n      next_param = smartlist_get(param_list, param_sl_idx+1);\n    tor_assert(param);\n    if (!next_param || strncmp(next_param, param, cur_param_len)) {\n      if (i > total_authorities/2 ||\n          i >= MIN_VOTES_FOR_PARAM) {\n        int32_t median = median_int32(vals, i);\n        char *out_string = tor_malloc(64+cur_param_len);\n        memcpy(out_string, param, cur_param_len);\n        tor_snprintf(out_string+cur_param_len,64, \"%ld\", (long)median);\n        smartlist_add(output, out_string);\n      }\n      i = 0;\n      if (next_param) {\n        eq = strchr(next_param, '=');\n        cur_param_len = (int)(eq+1 - next_param);\n      }\n    }\n  } SMARTLIST_FOREACH_END(param);\n  smartlist_free(param_list);\n  tor_free(vals);\n  return output;\n}", "target": 0}
{"code": "uint get_errcode_from_name(const char *error_name, const char *error_end,\n                            st_error *e)\n{\n  DBUG_ENTER(\"get_errcode_from_name\");\n  DBUG_PRINT(\"enter\", (\"error_name: %s\", error_name));\n  for (; e->name; e++)\n  {\n    if (!strncmp(error_name, e->name, (int) (error_end - error_name)) &&\n        (uint) strlen(e->name) == (uint) (error_end - error_name))\n    {\n      DBUG_RETURN(e->code);\n    }\n  }\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "Method* LinkResolver::linktime_resolve_static_method(const LinkInfo& link_info, TRAPS) {\n  Klass* resolved_klass = link_info.resolved_klass();\n  Method* resolved_method;\n  if (!resolved_klass->is_interface()) {\n    resolved_method = resolve_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);\n  } else {\n    resolved_method = resolve_interface_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);\n  }\n  assert(resolved_method->name() != vmSymbols::class_initializer_name(), \"should have been checked in verifier\");\n  if (!resolved_method->is_static()) {\n    ResourceMark rm(THREAD);\n    stringStream ss;\n    ss.print(\"Expected static method '\");\n    resolved_method->print_external_name(&ss);\n    ss.print(\"'\");\n    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());\n  }\n  return resolved_method;\n}", "target": 0}
{"code": "int gnutls_x509_ext_import_name_constraints(const gnutls_datum_t * ext,\n\t\t\t\t\t gnutls_x509_name_constraints_t nc,\n\t\t\t\t\t unsigned int flags)\n{\n\tint result, ret;\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tresult = asn1_create_element\n\t    (_gnutls_get_pkix(), \"PKIX1.NameConstraints\", &c2);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_der_decoding(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (!(flags & GNUTLS_NAME_CONSTRAINTS_FLAG_APPEND)\n\t    || (nc->permitted == NULL && nc->excluded == NULL)) {\n\t\tret =\n\t\t    _gnutls_extract_name_constraints(c2, \"permittedSubtrees\",\n\t\t\t\t\t\t     &nc->permitted);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tret =\n\t    _gnutls_extract_name_constraints(c2, \"excludedSubtrees\",\n\t\t\t\t\t     &nc->excluded);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tret = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "zval *php_snmp_read_property(zval *object, zval *member, int type, void **cache_slot, zval *rv)\n{\n\tzval tmp_member;\n\tzval *retval;\n\tphp_snmp_object *obj;\n\tphp_snmp_prop_handler *hnd;\n\tint ret;\n\tobj = Z_SNMP_P(object);\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\tZVAL_COPY(&tmp_member, member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t}\n\thnd = zend_hash_find_ptr(&php_snmp_properties, Z_STR_P(member));\n\tif (hnd && hnd->read_func) {\n\t\tret = hnd->read_func(obj, rv);\n\t\tif (ret == SUCCESS) {\n\t\t\tretval = rv;\n\t\t} else {\n\t\t\tretval = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tzend_object_handlers * std_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->read_property(object, member, type, cache_slot, rv);\n\t}\n\tif (member == &tmp_member) {\n\t\tzval_ptr_dtor(member);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "double WebContentsImpl::GetZoomLevel() const {\n  HostZoomMapImpl* zoom_map = static_cast<HostZoomMapImpl*>(\n      HostZoomMap::GetForBrowserContext(GetBrowserContext()));\n  if (!zoom_map)\n    return 0;\n  double zoom_level;\n  if (temporary_zoom_settings_) {\n    zoom_level = zoom_map->GetTemporaryZoomLevel(\n        GetRenderProcessHost()->GetID(), GetRenderViewHost()->GetRoutingID());\n  } else {\n    GURL url;\n    NavigationEntry* active_entry = GetController().GetActiveEntry();\n    url = active_entry ? active_entry->GetURL() : GURL::EmptyGURL();\n    zoom_level = zoom_map->GetZoomLevelForHostAndScheme(url.scheme(),\n        net::GetHostOrSpecFromURL(url));\n  }\n  return zoom_level;\n}", "target": 0}
{"code": "static inline bool skb_head_is_locked(const struct sk_buff *skb)\n{\n\treturn !skb->head_frag || skb_cloned(skb);\n}", "target": 0}
{"code": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n  if (strcasecmp(key.c_str(), \"HTTP_PROXY\") == 0) return;\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n  m_requestParams[key] = value;\n}", "target": 0}
{"code": "static void fixup_transceive_length(const struct sc_card *card,\n\t\tstruct sc_apdu *apdu)\n{\n\tif (card == NULL || apdu == NULL) {\n\t\treturn;\n\t}\n\tif (apdu->lc > sc_get_max_send_size(card)) {\n\t\tapdu->flags |= SC_APDU_FLAGS_CHAINING;\n\t}\n\tif (apdu->le > sc_get_max_recv_size(card)) {\n\t\tapdu->le = sc_get_max_recv_size(card);\n\t}\n}", "target": 0}
{"code": "static int get_mnt_opts(int flags, char *opts, char **mnt_optsp)\n{\n\tint i;\n\tint l;\n\tif (!(flags & MS_RDONLY) && add_option(mnt_optsp, \"rw\", 0) == -1)\n\t\treturn -1;\n\tfor (i = 0; mount_flags[i].opt != NULL; i++) {\n\t\tif (mount_flags[i].on && (flags & mount_flags[i].flag) &&\n\t\t    add_option(mnt_optsp, mount_flags[i].opt, 0) == -1)\n\t\t\treturn -1;\n\t}\n\tif (add_option(mnt_optsp, opts, 0) == -1)\n\t\treturn -1;\n\tl = strlen(*mnt_optsp);\n\tif ((*mnt_optsp)[l-1] == ',')\n\t\t(*mnt_optsp)[l-1] = '\\0';\n\tif (getuid() != 0) {\n\t\tconst char *user = get_user_name();\n\t\tif (user == NULL)\n\t\t\treturn -1;\n\t\tif (add_option(mnt_optsp, \"user=\", strlen(user)) == -1)\n\t\t\treturn -1;\n\t\tstrcat(*mnt_optsp, user);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static tag_table_type exif_get_tag_table(int section)\n{\n\tswitch(section) {\n\t\tcase SECTION_FILE:      return &tag_table_IFD[0];\n\t\tcase SECTION_COMPUTED:  return &tag_table_IFD[0];\n\t\tcase SECTION_ANY_TAG:   return &tag_table_IFD[0];\n\t\tcase SECTION_IFD0:      return &tag_table_IFD[0];\n\t\tcase SECTION_THUMBNAIL: return &tag_table_IFD[0];\n\t\tcase SECTION_COMMENT:   return &tag_table_IFD[0];\n\t\tcase SECTION_APP0:      return &tag_table_IFD[0];\n\t\tcase SECTION_EXIF:      return &tag_table_IFD[0];\n\t\tcase SECTION_FPIX:      return &tag_table_IFD[0];\n\t\tcase SECTION_GPS:       return &tag_table_GPS[0];\n\t\tcase SECTION_INTEROP:   return &tag_table_IOP[0];\n\t\tcase SECTION_APP12:     return &tag_table_IFD[0];\n\t\tcase SECTION_WINXP:     return &tag_table_IFD[0];\n\t}\n\treturn &tag_table_IFD[0];\n}", "target": 0}
{"code": "static void set_own_dir(const char *argv0) {\n\tsize_t l = strlen(argv0);\n\twhile(l && argv0[l - 1] != '/')\n\t\tl--;\n\tif(l == 0)\n#ifdef SUPER_SECURE\n\t\tmemcpy(own_dir, \"/dev/null/\", 2);\n#else\n\t\tmemcpy(own_dir, \".\", 2);\n#endif\n\telse {\n\t\tmemcpy(own_dir, argv0, l - 1);\n\t\town_dir[l] = 0;\n\t}\n}", "target": 0}
{"code": "static void ahci_unmap_clb_address(AHCIDevice *ad)\n{\n    dma_memory_unmap(ad->hba->as, ad->lst, 1024,\n                     DMA_DIRECTION_FROM_DEVICE, 1024);\n    ad->lst = NULL;\n}", "target": 0}
{"code": "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info)\n{\n\tscrub_pause_on(fs_info);\n\tscrub_pause_off(fs_info);\n}", "target": 0}
{"code": "parse_ed_props(const uint16_t prop_class, char **arg, int *n_props, struct ofpbuf *out)\n{\n    char *key, *value, *err;\n    uint8_t prop_type;\n    while (ofputil_parse_key_value(arg, &key, &value)) {\n        if (!parse_ed_prop_type(prop_class, key, &prop_type)) {\n            return xasprintf(\"Invalid property: %s\", key);\n        }\n        if (value == NULL) {\n            return xasprintf(\"Missing the value for property: %s\", key);\n        }\n        err = parse_ed_prop_value(prop_class, prop_type, value, out);\n        if (err != NULL) {\n            return err;\n        }\n        (*n_props)++;\n    }\n    return NULL;\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_udiff_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Variant& key_compare_func,\n                         const Array& args ) {\n  Variant data_func = data_compare_func;\n  Variant key_func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(key_func);\n    extra.prepend(data_func);\n    key_func = extra.pop();\n    data_func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, true\n                      COMMA true COMMA cmp_func COMMA &key_func\n                      COMMA cmp_func COMMA &data_func);\n}", "target": 0}
{"code": "static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn (!irqchip_in_kernel(vcpu->kvm) && !kvm_cpu_has_interrupt(vcpu) &&\n\t\tvcpu->run->request_interrupt_window &&\n\t\tkvm_arch_interrupt_allowed(vcpu));\n}", "target": 0}
{"code": "void GfxDeviceRGBColorSpace::getRGBXLine(unsigned char *in, unsigned char *out, int length)\n{\n    for (int i = 0; i < length; i++) {\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = 255;\n    }\n}", "target": 0}
{"code": "ref_stack_store(const ref_stack_t *pstack, ref *parray, uint count,\n                uint skip, int age, bool check, gs_dual_memory_t *idmemory,\n                client_name_t cname)\n{\n    uint left, pass;\n    ref *to;\n    ref_stack_enum_t rsenum;\n    if (count > ref_stack_count(pstack) || count > r_size(parray))\n        return_error(gs_error_rangecheck);\n    if (check) {\n        int code = ref_stack_store_check(pstack, parray, count, skip);\n        if (code < 0)\n            return code;\n    }\n    to = parray->value.refs + count;\n    left = count, pass = skip;\n    ref_stack_enum_begin(&rsenum, pstack);\n    do {\n        ref *from = rsenum.ptr;\n        uint size = rsenum.size;\n        if (size <= pass)\n            pass -= size;\n        else {\n            if (pass != 0)\n                size -= pass, pass = 0;\n            from += size;\n            if (size > left)\n                size = left;\n            left -= size;\n            switch (age) {\n            case -1:\t\t\n                while (size--) {\n                    from--, to--;\n                    ref_assign(to, from);\n                }\n                break;\n            case 0:\t\t\n                while (size--) {\n                    from--, to--;\n                    ref_assign_old(parray, to, from, cname);\n                }\n                break;\n            case 1:\t\t\n                while (size--) {\n                    from--, to--;\n                    ref_assign_new(to, from);\n                }\n                break;\n            }\n            if (left == 0)\n                break;\n        }\n    } while (ref_stack_enum_next(&rsenum));\n    r_set_size(parray, count);\n    return 0;\n}", "target": 0}
{"code": "c_civil_to_jd(int y, int m, int d, double sg, int *rjd, int *ns)\n{\n    double a, b, jd;\n    if (m <= 2) {\n\ty -= 1;\n\tm += 12;\n    }\n    a = floor(y / 100.0);\n    b = 2 - a + floor(a / 4.0);\n    jd = floor(365.25 * (y + 4716)) +\n\tfloor(30.6001 * (m + 1)) +\n\td + b - 1524;\n    if (jd < sg) {\n\tjd -= b;\n\t*ns = 0;\n    }\n    else\n\t*ns = 1;\n    *rjd = (int)jd;\n}", "target": 0}
{"code": "void gdImageSetAntiAliased (gdImagePtr im, int c)\n{\n\tim->AA = 1;\n\tim->AA_color = c;\n\tim->AA_dont_blend = -1;\n}", "target": 0}
{"code": "static inline void ModulateHSL(const double percent_hue,\n  const double percent_saturation,const double percent_lightness,double *red,\n  double *green,double *blue)\n{\n  double\n    hue,\n    lightness,\n    saturation;\n  ConvertRGBToHSL(*red,*green,*blue,&hue,&saturation,&lightness);\n  hue+=0.5*(0.01*percent_hue-1.0);\n  saturation*=0.01*percent_saturation;\n  lightness*=0.01*percent_lightness;\n  ConvertHSLToRGB(hue,saturation,lightness,red,green,blue);\n}", "target": 0}
{"code": "tor_version_same_series(tor_version_t *a, tor_version_t *b)\n{\n  tor_assert(a);\n  tor_assert(b);\n  return ((a->major == b->major) &&\n          (a->minor == b->minor) &&\n          (a->micro == b->micro));\n}", "target": 0}
{"code": "ZEND_API void zend_clear_exception(TSRMLS_D) \n{\n\tif (EG(prev_exception)) {\n\t\tzval_ptr_dtor(&EG(prev_exception));\n\t\tEG(prev_exception) = NULL;\n\t}\n\tif (!EG(exception)) {\n\t\treturn;\n\t}\n\tzval_ptr_dtor(&EG(exception));\n\tEG(exception) = NULL;\n\tEG(current_execute_data)->opline = EG(opline_before_exception);\n#if ZEND_DEBUG\n\tEG(opline_before_exception) = NULL;\n#endif\n}", "target": 0}
{"code": "void doTest(int w, int h, const int *formats, int nformats, int subsamp,\n\tchar *basename)\n{\n\ttjhandle chandle=NULL, dhandle=NULL;\n\tunsigned char *dstBuf=NULL;\n\tunsigned long size=0;  int pfi, pf, i;\n\tif(!alloc)\n\t\tsize=tjBufSize(w, h, subsamp);\n\tif(size!=0)\n\t\tif((dstBuf=(unsigned char *)tjAlloc(size))==NULL)\n\t\t\t_throw(\"Memory allocation failure.\");\n\tif((chandle=tjInitCompress())==NULL || (dhandle=tjInitDecompress())==NULL)\n\t\t_throwtj();\n\tfor(pfi=0; pfi<nformats; pfi++)\n\t{\n\t\tfor(i=0; i<2; i++)\n\t\t{\n\t\t\tint flags=0;\n\t\t\tif(subsamp==TJSAMP_422 || subsamp==TJSAMP_420 || subsamp==TJSAMP_440 ||\n\t\t\t\tsubsamp==TJSAMP_411)\n\t\t\t\tflags|=TJFLAG_FASTUPSAMPLE;\n\t\t\tif(i==1) flags|=TJFLAG_BOTTOMUP;\n\t\t\tpf=formats[pfi];\n\t\t\tcompTest(chandle, &dstBuf, &size, w, h, pf, basename, subsamp, 100,\n\t\t\t\tflags);\n\t\t\tdecompTest(dhandle, dstBuf, size, w, h, pf, basename, subsamp,\n\t\t\t\tflags);\n\t\t\tif(pf>=TJPF_RGBX && pf<=TJPF_XRGB)\n\t\t\t{\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tdecompTest(dhandle, dstBuf, size, w, h, pf+(TJPF_RGBA-TJPF_RGBX),\n\t\t\t\t\tbasename, subsamp, flags);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\tprintf(\"--------------------\\n\\n\");\n\tbailout:\n\tif(chandle) tjDestroy(chandle);\n\tif(dhandle) tjDestroy(dhandle);\n\tif(dstBuf) tjFree(dstBuf);\n}", "target": 0}
{"code": "void nl80211_send_sched_scan(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev, u32 cmd)\n{\n\tstruct sk_buff *msg;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\tif (nl80211_send_sched_scan_msg(msg, rdev, netdev, 0, 0, 0, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}", "target": 0}
{"code": "void DefaultAudioDestinationHandler::Uninitialize() {\n  DCHECK(IsMainThread());\n  if (!IsInitialized()) {\n    return;\n  }\n  StopPlatformDestination();\n  AudioHandler::Uninitialize();\n}", "target": 0}
{"code": "void Clipboard::InsertMapping(const char* key,\n                              char* data,\n                              size_t data_len) {\n  DCHECK(clipboard_data_->find(key) == clipboard_data_->end());\n  (*clipboard_data_)[key] = std::make_pair(data, data_len);\n}", "target": 0}
{"code": "void ZeroSuggestProvider::RecordDeletionResult(bool success) {\n  if (success) {\n    base::RecordAction(\n        base::UserMetricsAction(\"Omnibox.ZeroSuggestDelete.Success\"));\n  } else {\n    base::RecordAction(\n        base::UserMetricsAction(\"Omnibox.ZeroSuggestDelete.Failure\"));\n  }\n}", "target": 0}
{"code": "uint8_t PacketReader::get8BitInt()\n{\n  return d_content.at(d_pos++);\n}", "target": 0}
{"code": "storagePoolSetAutostart(virStoragePoolPtr pool,\n                        int autostart)\n{\n    virStoragePoolObj *obj;\n    const char *configFile;\n    const char *autostartLink;\n    bool new_autostart;\n    bool cur_autostart;\n    int ret = -1;\n    if (!(obj = storagePoolObjFindByUUID(pool->uuid, pool->name)))\n        goto cleanup;\n    if (virStoragePoolSetAutostartEnsureACL(pool->conn,\n                                            virStoragePoolObjGetDef(obj)) < 0)\n        goto cleanup;\n    if (!(configFile = virStoragePoolObjGetConfigFile(obj))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"pool has no config file\"));\n        goto cleanup;\n    }\n    autostartLink = virStoragePoolObjGetAutostartLink(obj);\n    new_autostart = (autostart != 0);\n    cur_autostart = virStoragePoolObjIsAutostart(obj);\n    if (cur_autostart != new_autostart) {\n        if (new_autostart) {\n            if (g_mkdir_with_parents(driver->autostartDir, 0777) < 0) {\n                virReportSystemError(errno,\n                                     _(\"cannot create autostart directory %s\"),\n                                     driver->autostartDir);\n                goto cleanup;\n            }\n            if (symlink(configFile, autostartLink) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Failed to create symlink '%s' to '%s'\"),\n                                     autostartLink, configFile);\n                goto cleanup;\n            }\n        } else {\n            if (autostartLink && unlink(autostartLink) < 0 &&\n                errno != ENOENT && errno != ENOTDIR) {\n                virReportSystemError(errno,\n                                     _(\"Failed to delete symlink '%s'\"),\n                                     autostartLink);\n                goto cleanup;\n            }\n        }\n        virStoragePoolObjSetAutostart(obj, new_autostart);\n    }\n    ret = 0;\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}", "target": 0}
{"code": "static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong datalen;\n\tdatalen = parse_iv2((*p) + 2, p);\n\t(*p) += 2;\n\tif (datalen < 0 || (max - (*p)) <= datalen) {\n\t\tzend_error(E_WARNING, \"Insufficient data for unserializing - %ld required, %ld present\", datalen, (long)(max - (*p)));\n\t\treturn 0;\n\t}\n\tif (ce->unserialize == NULL) {\n\t\tzend_error(E_WARNING, \"Class %s has no unserializer\", ce->name);\n\t\tobject_init_ex(*rval, ce);\n\t} else if (ce->unserialize(rval, ce, (const unsigned char*)*p, datalen, (zend_unserialize_data *)var_hash TSRMLS_CC) != SUCCESS) {\n\t\treturn 0;\n\t}\n\t(*p) += datalen;\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}", "target": 0}
{"code": "Ewk_View_Mode ewk_view_mode_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, EWK_VIEW_MODE_WINDOWED);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, EWK_VIEW_MODE_WINDOWED);\n    return static_cast<Ewk_View_Mode>(priv->page->viewMode());\n}", "target": 0}
{"code": "device_drive_detach_authorized_cb (Daemon *daemon,\n                                   Device *device,\n                                   DBusGMethodInvocation *context,\n                                   const gchar *action_id,\n                                   guint num_user_data,\n                                   gpointer *user_data_elements)\n{\n  gchar **options = user_data_elements[0];\n  int n;\n  char *argv[16];\n  GError *error;\n  char *mount_path;\n  error = NULL;\n  mount_path = NULL;\n  if (!device->priv->device_is_drive)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not a drive\");\n      goto out;\n    }\n  if (!device->priv->drive_can_detach)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not detachable\");\n      goto out;\n    }\n  if (device_local_is_busy (device, TRUE, &error))\n    {\n      dbus_g_method_return_error (context, error);\n      g_error_free (error);\n      goto out;\n    }\n  for (n = 0; options[n] != NULL; n++)\n    {\n      const char *option = options[n];\n      throw_error (context, ERROR_INVALID_OPTION, \"Unknown option %s\", option);\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"udisks-helper-drive-detach\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = NULL;\n  if (!job_new (context, \"DriveDetach\", FALSE, device, argv, NULL, drive_detach_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "STATIC unsigned  int\nS_regex_set_precedence(const U8 my_operator) {\n    switch (my_operator) {\n        case '!':\n            return 5;\n        case '&':\n            return 4;\n        case '^':\n        case '|':\n        case '+':\n        case '-':\n            return 3;\n        case ')':\n            return 2;\n        case ']':\n            return 1;\n    }\n    NOT_REACHED; \n    return 0;   ", "target": 0}
{"code": "tight_detect_smooth_image24(VncState *vs, int w, int h)\n{\n    int off;\n    int x, y, d, dx;\n    unsigned int c;\n    unsigned int stats[256];\n    int pixels = 0;\n    int pix, left[3];\n    unsigned int errors;\n    unsigned char *buf = vs->tight->tight.buffer;\n    off = vs->client_be;\n    memset(stats, 0, sizeof (stats));\n    for (y = 0, x = 0; y < h && x < w;) {\n        for (d = 0; d < h - y && d < w - x - VNC_TIGHT_DETECT_SUBROW_WIDTH;\n             d++) {\n            for (c = 0; c < 3; c++) {\n                left[c] = buf[((y+d)*w+x+d)*4+off+c] & 0xFF;\n            }\n            for (dx = 1; dx <= VNC_TIGHT_DETECT_SUBROW_WIDTH; dx++) {\n                for (c = 0; c < 3; c++) {\n                    pix = buf[((y+d)*w+x+d+dx)*4+off+c] & 0xFF;\n                    stats[abs(pix - left[c])]++;\n                    left[c] = pix;\n                }\n                pixels++;\n            }\n        }\n        if (w > h) {\n            x += h;\n            y = 0;\n        } else {\n            x = 0;\n            y += w;\n        }\n    }\n    if (pixels == 0) {\n        return 0;\n    }\n    if (stats[0] * 33 / pixels >= 95) {\n        return 0;\n    }\n    errors = 0;\n    for (c = 1; c < 8; c++) {\n        errors += stats[c] * (c * c);\n        if (stats[c] == 0 || stats[c] > stats[c-1] * 2) {\n            return 0;\n        }\n    }\n    for (; c < 256; c++) {\n        errors += stats[c] * (c * c);\n    }\n    errors /= (pixels * 3 - stats[0]);\n    return errors;\n}", "target": 0}
{"code": "scan_env_set_mem_node(ScanEnv* env, int num, Node* node)\n{\n  if (env->num_mem >= num)\n    SCANENV_MEMENV(env)[num].node = node;\n  else\n    return ONIGERR_PARSER_BUG;\n  return 0;\n}", "target": 0}
{"code": "static void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); \n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}", "target": 0}
{"code": "int acpi_map_lsapic(acpi_handle handle, int *pcpu)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tstruct acpi_table_lapic *lapic;\n\tcpumask_t tmp_map, new_map;\n\tu8 physid;\n\tint cpu;\n\tif (ACPI_FAILURE(acpi_evaluate_object(handle, \"_MAT\", NULL, &buffer)))\n\t\treturn -EINVAL;\n\tif (!buffer.length || !buffer.pointer)\n\t\treturn -EINVAL;\n\tobj = buffer.pointer;\n\tif (obj->type != ACPI_TYPE_BUFFER ||\n\t    obj->buffer.length < sizeof(*lapic)) {\n\t\tkfree(buffer.pointer);\n\t\treturn -EINVAL;\n\t}\n\tlapic = (struct acpi_table_lapic *)obj->buffer.pointer;\n\tif ((lapic->header.type != ACPI_MADT_LAPIC) ||\n\t    (!lapic->flags.enabled)) {\n\t\tkfree(buffer.pointer);\n\t\treturn -EINVAL;\n\t}\n\tphysid = lapic->id;\n\tkfree(buffer.pointer);\n\tbuffer.length = ACPI_ALLOCATE_BUFFER;\n\tbuffer.pointer = NULL;\n\ttmp_map = cpu_present_map;\n\tmp_register_lapic(physid, lapic->flags.enabled);\n\tcpus_andnot(new_map, cpu_present_map, tmp_map);\n\tif (cpus_empty(new_map)) {\n\t\tprintk (\"Unable to map lapic to logical cpu number\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcpu = first_cpu(new_map);\n\t*pcpu = cpu;\n\treturn 0;\n}", "target": 0}
{"code": "static void vmx_adjust_tsc_offset(struct kvm_vcpu *vcpu, s64 adjustment, bool host)\n{\n\tu64 offset = vmcs_read64(TSC_OFFSET);\n\tvmcs_write64(TSC_OFFSET, offset + adjustment);\n\tif (is_guest_mode(vcpu)) {\n\t\tto_vmx(vcpu)->nested.vmcs01_tsc_offset += adjustment;\n\t} else\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id, offset,\n\t\t\t\t\t   offset + adjustment);\n}", "target": 0}
{"code": "static int fsmChown(int fd, int dirfd, const char *path, mode_t mode, uid_t uid, gid_t gid)\n{\n    int rc;\n    struct stat st;\n    if (fd >= 0) {\n\trc = fchown(fd, uid, gid);\n\tif (rc < 0) {\n\t    if (fstat(fd, &st) == 0 && (st.st_uid == uid && st.st_gid == gid)) {\n\t\trc = 0;\n\t    }\n\t}\n    } else {\n\tint flags = S_ISLNK(mode) ? AT_SYMLINK_NOFOLLOW : 0;\n\trc = fchownat(dirfd, path, uid, gid, flags);\n\tif (rc < 0) {\n\t    struct stat st;\n\t    if (fstatat(dirfd, path, &st, flags) == 0 &&\n\t\t    (st.st_uid == uid && st.st_gid == gid)) {\n\t\trc = 0;\n\t    }\n\t}\n    }\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, %d, %d) %s\\n\", __func__,\n\t       fd, dirfd, path, (int)uid, (int)gid,\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n    if (rc < 0)\trc = RPMERR_CHOWN_FAILED;\n    return rc;\n}", "target": 0}
{"code": "newSWFShapeFromBitmap(SWFBitmap bitmap, int flag)\n{\n\tSWFShape shape = newSWFShape();\n\tSWFFillStyle fill;\n\tint width, height;\n\tif ( flag != SWFFILL_TILED_BITMAP &&\n\t     flag != SWFFILL_CLIPPED_BITMAP &&\n\t     flag != SWFFILL_NONSMOOTHED_TILED_BITMAP &&\n\t     flag != SWFFILL_NONSMOOTHED_CLIPPED_BITMAP)\n\t{\n\t\tSWF_error(\"Invalid bitmap fill flag\");\n\t}\n\tfill = SWFShape_addBitmapFillStyle(shape, bitmap, flag);\n\twidth = SWFBitmap_getWidth(bitmap);\n\theight = SWFBitmap_getHeight(bitmap);\n\tSWFShape_setRightFillStyle(shape, fill);\n\tSWFShape_drawScaledLine(shape, width * 20, 0);\n\tSWFShape_drawScaledLine(shape, 0, height * 20);\n\tSWFShape_drawScaledLine(shape, -width * 20, 0);\n\tSWFShape_drawScaledLine(shape, 0, -height * 20);\n\treturn shape;\n}", "target": 0}
{"code": "static ssize_t itlb_multihit_show_state(char *buf)\n{\n\treturn sprintf(buf, \"Processor vulnerable\\n\");\n}", "target": 0}
{"code": "static int sub_alloc(struct idr *idp, int *starting_id, struct idr_layer **pa)\n{\n\tint n, m, sh;\n\tstruct idr_layer *p, *new;\n\tint l, id, oid;\n\tunsigned long bm;\n\tid = *starting_id;\n restart:\n\tp = idp->top;\n\tl = idp->layers;\n\tpa[l--] = NULL;\n\twhile (1) {\n\t\tn = (id >> (IDR_BITS*l)) & IDR_MASK;\n\t\tbm = ~p->bitmap;\n\t\tm = find_next_bit(&bm, IDR_SIZE, n);\n\t\tif (m == IDR_SIZE) {\n\t\t\tl++;\n\t\t\toid = id;\n\t\t\tid = (id | ((1 << (IDR_BITS * l)) - 1)) + 1;\n\t\t\tif (id >= 1 << (idp->layers * IDR_BITS)) {\n\t\t\t\t*starting_id = id;\n\t\t\t\treturn IDR_NEED_TO_GROW;\n\t\t\t}\n\t\t\tp = pa[l];\n\t\t\tBUG_ON(!p);\n\t\t\tsh = IDR_BITS * (l + 1);\n\t\t\tif (oid >> sh == id >> sh)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tgoto restart;\n\t\t}\n\t\tif (m != n) {\n\t\t\tsh = IDR_BITS*l;\n\t\t\tid = ((id >> sh) ^ n ^ m) << sh;\n\t\t}\n\t\tif ((id >= MAX_ID_BIT) || (id < 0))\n\t\t\treturn IDR_NOMORE_SPACE;\n\t\tif (l == 0)\n\t\t\tbreak;\n\t\tif (!p->ary[m]) {\n\t\t\tnew = get_from_free_list(idp);\n\t\t\tif (!new)\n\t\t\t\treturn -1;\n\t\t\tnew->layer = l-1;\n\t\t\trcu_assign_pointer(p->ary[m], new);\n\t\t\tp->count++;\n\t\t}\n\t\tpa[l--] = p;\n\t\tp = p->ary[m];\n\t}\n\tpa[l] = p;\n\treturn id;\n}", "target": 0}
{"code": "start_output_ppm (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;\n  switch (cinfo->out_color_space) {\n  case JCS_GRAYSCALE:\n    fprintf(dest->pub.output_file, \"P5\\n%ld %ld\\n%d\\n\",\n            (long) cinfo->output_width, (long) cinfo->output_height,\n            PPM_MAXVAL);\n    break;\n  case JCS_RGB:\n  case JCS_EXT_RGB:\n  case JCS_EXT_RGBX:\n  case JCS_EXT_BGR:\n  case JCS_EXT_BGRX:\n  case JCS_EXT_XBGR:\n  case JCS_EXT_XRGB:\n  case JCS_EXT_RGBA:\n  case JCS_EXT_BGRA:\n  case JCS_EXT_ABGR:\n  case JCS_EXT_ARGB:\n  case JCS_CMYK:\n    fprintf(dest->pub.output_file, \"P6\\n%ld %ld\\n%d\\n\",\n            (long) cinfo->output_width, (long) cinfo->output_height,\n            PPM_MAXVAL);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_PPM_COLORSPACE);\n  }\n}", "target": 0}
{"code": "gdouble callbacks_calculate_actual_distance (gdouble inputDimension) {\n\treturn screen_units(inputDimension);\n}", "target": 0}
{"code": "void report_or_die(const char *fmt, ...)\n{\n  va_list args;\n  DBUG_ENTER(\"report_or_die\");\n  char buff[DIE_BUFF_SIZE];\n  va_start(args, fmt);\n  make_error_message(buff, sizeof(buff), fmt, args);\n  va_end(args);\n  if (opt_continue_on_error)\n  {\n    replace_dynstr_append(&ds_res, buff);\n    error_count++;\n    DBUG_VOID_RETURN;\n  }\n  really_die(buff);\n}", "target": 0}
{"code": "add_menu_items_for_outputs (GsdXrandrManager *manager)\n{\n        struct GsdXrandrManagerPrivate *priv = manager->priv;\n        int i;\n        for (i = 0; priv->configuration->outputs[i] != NULL; i++) {\n                if (priv->configuration->outputs[i]->connected)\n                        add_menu_items_for_output (manager, priv->configuration->outputs[i]);\n        }\n}", "target": 0}
{"code": "ReadSample(SampleReader&   reader, \n           AP4_Track&      track,\n           AP4_Sample&     sample,\n           AP4_DataBuffer& sample_data, \n           double&         ts,\n           double&         duration,\n           bool&           eos)\n{\n    AP4_Result result = reader.ReadSample(sample, sample_data);\n    if (AP4_FAILED(result)) {\n        if (result == AP4_ERROR_EOS) {\n            ts += duration;\n            eos = true;\n            return AP4_SUCCESS;\n        } else {\n            return result;\n        }\n    }\n    ts = (double)sample.GetDts()/(double)track.GetMediaTimeScale();\n    duration = sample.GetDuration()/(double)track.GetMediaTimeScale();\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "static int check_pe32_bytes(const ut8 *buf, ut64 length) {\n\tunsigned int idx;\n\tif (!buf || length <= 0x3d) {\n\t\treturn false;\n\t}\n\tidx = (buf[0x3c] | (buf[0x3d]<<8));\n\tif (length > idx + 0x18 + 2) {\n\t\tif (!memcmp (buf, \"MZ\", 2) && !memcmp (buf+idx, \"PE\", 2) && !memcmp (buf+idx+0x18, \"\\x0b\\x01\", 2)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static int compare_columns(MARIA_COLUMNDEF **a_ptr, MARIA_COLUMNDEF **b_ptr)\n{\n  MARIA_COLUMNDEF *a= *a_ptr, *b= *b_ptr;\n  enum en_fieldtype a_type, b_type;\n  a_type= (a->type == FIELD_CHECK) ? FIELD_NORMAL : a->type;\n  b_type= (b->type == FIELD_CHECK) ? FIELD_NORMAL : b->type;\n  if (a_type == FIELD_NORMAL && !a->null_bit)\n  {\n    if (b_type != FIELD_NORMAL || b->null_bit)\n      return -1;\n    return sign((long) a->offset - (long) b->offset);\n  }\n  if (b_type == FIELD_NORMAL && !b->null_bit)\n    return 1;\n  if (a_type == b_type)\n    return sign((long) a->offset - (long) b->offset);\n  if (a_type == FIELD_NORMAL)\n    return -1;\n  if (b_type == FIELD_NORMAL)\n    return 1;\n  if (a_type == FIELD_SKIP_ZERO)\n    return -1;\n  if (b_type == FIELD_SKIP_ZERO)\n    return 1;\n  if (a->type != FIELD_BLOB && b->type != FIELD_BLOB)\n    if (a->length != b->length)\n      return sign((long) a->length - (long) b->length);\n  if (a_type == FIELD_BLOB)\n    return 1;\n  if (b_type == FIELD_BLOB)\n    return -1;\n  return sign((long) a->offset - (long) b->offset);\n}", "target": 0}
{"code": "static Token *dup_tlist_reverse(const Token *list, Token *tail)\n{\n    const Token *t;\n    list_for_each(t, list)\n        tail = dup_Token(tail, t);\n    return tail;\n}", "target": 0}
{"code": "static long kvm_dev_ioctl(struct file *filp,\n\t\t\t  unsigned int ioctl, unsigned long arg)\n{\n\tlong r = -EINVAL;\n\tswitch (ioctl) {\n\tcase KVM_GET_API_VERSION:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = KVM_API_VERSION;\n\t\tbreak;\n\tcase KVM_CREATE_VM:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = kvm_dev_ioctl_create_vm();\n\t\tbreak;\n\tcase KVM_CHECK_EXTENSION:\n\t\tr = kvm_dev_ioctl_check_extension_generic(arg);\n\t\tbreak;\n\tcase KVM_GET_VCPU_MMAP_SIZE:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = PAGE_SIZE;     \n#ifdef CONFIG_X86\n\t\tr += PAGE_SIZE;    \n#endif\n#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET\n\t\tr += PAGE_SIZE;    \n#endif\n\t\tbreak;\n\tcase KVM_TRACE_ENABLE:\n\tcase KVM_TRACE_PAUSE:\n\tcase KVM_TRACE_DISABLE:\n\t\tr = -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_arch_dev_ioctl(filp, ioctl, arg);\n\t}\nout:\n\treturn r;\n}", "target": 0}
{"code": "  void SetInput(std::initializer_list<float> data) {\n    PopulateTensor(input_, data);\n  }", "target": 0}
{"code": "MagickPrivate MagickSizeType GetPixelCacheNexusExtent(const Cache cache,\n  NexusInfo *magick_restrict nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  MagickSizeType\n    extent;\n  assert(cache != NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  extent=(MagickSizeType) nexus_info->region.width*nexus_info->region.height;\n  if (extent == 0)\n    return((MagickSizeType) cache_info->columns*cache_info->rows);\n  return(extent);\n}", "target": 0}
{"code": "static void free_func_state(struct bpf_func_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tkfree(state->stack);\n\tkfree(state);\n}", "target": 0}
{"code": "rb_reg_check(VALUE re)\n{\n    if (!RREGEXP_PTR(re) || !RREGEXP_SRC(re) || !RREGEXP_SRC_PTR(re)) {\n\trb_raise(rb_eTypeError, \"uninitialized Regexp\");\n    }\n}", "target": 0}
{"code": "bgp_attr_local_pref (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  if (length != 4)\n  {\n    zlog (peer->log, LOG_ERR, \"LOCAL_PREF attribute length isn't 4 [%u]\",\n          length);\n    return bgp_attr_malformed (args,\n                               BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                               args->total);\n  }\n  if (peer_sort (peer) == BGP_PEER_EBGP)\n    {\n      stream_forward_getp (peer->ibuf, length);\n      return BGP_ATTR_PARSE_PROCEED;\n    }\n  attr->local_pref = stream_getl (peer->ibuf);\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF);\n  return BGP_ATTR_PARSE_PROCEED;\n}", "target": 0}
{"code": "xfs_bmap_split_indlen(\n\txfs_filblks_t\t\t\tores,\t\t\n\txfs_filblks_t\t\t\t*indlen1,\t\n\txfs_filblks_t\t\t\t*indlen2,\t\n\txfs_filblks_t\t\t\tavail)\t\t\n{\n\txfs_filblks_t\t\t\tlen1 = *indlen1;\n\txfs_filblks_t\t\t\tlen2 = *indlen2;\n\txfs_filblks_t\t\t\tnres = len1 + len2; \n\txfs_filblks_t\t\t\tstolen = 0;\n\txfs_filblks_t\t\t\tresfactor;\n\tif (ores < nres && avail)\n\t\tstolen = XFS_FILBLKS_MIN(nres - ores, avail);\n\tores += stolen;\n\tif (ores >= nres)\n\t\treturn stolen;\n\tresfactor = (ores * 100);\n\tdo_div(resfactor, nres);\n\tlen1 *= resfactor;\n\tdo_div(len1, 100);\n\tlen2 *= resfactor;\n\tdo_div(len2, 100);\n\tASSERT(len1 + len2 <= ores);\n\tASSERT(len1 < *indlen1 && len2 < *indlen2);\n\tores -= (len1 + len2);\n\tASSERT((*indlen1 - len1) + (*indlen2 - len2) >= ores);\n\tif (ores && !len2 && *indlen2) {\n\t\tlen2++;\n\t\tores--;\n\t}\n\twhile (ores) {\n\t\tif (len1 < *indlen1) {\n\t\t\tlen1++;\n\t\t\tores--;\n\t\t}\n\t\tif (!ores)\n\t\t\tbreak;\n\t\tif (len2 < *indlen2) {\n\t\t\tlen2++;\n\t\t\tores--;\n\t\t}\n\t}\n\t*indlen1 = len1;\n\t*indlen2 = len2;\n\treturn stolen;\n}", "target": 0}
{"code": "static u32 *set_offsets(u32 *regs,\n\t\t\tconst u8 *data,\n\t\t\tconst struct intel_engine_cs *engine)\n#define NOP(x) (BIT(7) | (x))\n#define LRI(count, flags) ((flags) << 6 | (count))\n#define POSTED BIT(0)\n#define REG(x) (((x) >> 2) | BUILD_BUG_ON_ZERO(x >= 0x200))\n#define REG16(x) \\\n\t(((x) >> 9) | BIT(7) | BUILD_BUG_ON_ZERO(x >= 0x10000)), \\\n\t(((x) >> 2) & 0x7f)\n#define END() 0\n{\n\tconst u32 base = engine->mmio_base;\n\twhile (*data) {\n\t\tu8 count, flags;\n\t\tif (*data & BIT(7)) { \n\t\t\tregs += *data++ & ~BIT(7);\n\t\t\tcontinue;\n\t\t}\n\t\tcount = *data & 0x3f;\n\t\tflags = *data >> 6;\n\t\tdata++;\n\t\t*regs = MI_LOAD_REGISTER_IMM(count);\n\t\tif (flags & POSTED)\n\t\t\t*regs |= MI_LRI_FORCE_POSTED;\n\t\tif (INTEL_GEN(engine->i915) >= 11)\n\t\t\t*regs |= MI_LRI_CS_MMIO;\n\t\tregs++;\n\t\tGEM_BUG_ON(!count);\n\t\tdo {\n\t\t\tu32 offset = 0;\n\t\t\tu8 v;\n\t\t\tdo {\n\t\t\t\tv = *data++;\n\t\t\t\toffset <<= 7;\n\t\t\t\toffset |= v & ~BIT(7);\n\t\t\t} while (v & BIT(7));\n\t\t\t*regs = base + (offset << 2);\n\t\t\tregs += 2;\n\t\t} while (--count);\n\t}\n\treturn regs;\n}", "target": 0}
{"code": "pop_tag (GMarkupParseContext *context)\n{\n  GSList *nodea, *nodeb;\n  nodea = context->tag_stack;\n  nodeb = context->tag_stack_gstr;\n  release_chunk (context, nodeb->data);\n  context->tag_stack = g_slist_remove_link (context->tag_stack, nodea);\n  context->tag_stack_gstr = g_slist_remove_link (context->tag_stack_gstr, nodeb);\n  free_list_node (context, nodea);\n  free_list_node (context, nodeb);\n}", "target": 0}
{"code": "PHP_FUNCTION(curl_escape)\n{\n\tchar       *str = NULL, *res = NULL;\n\tint        str_len = 0;\n\tzval       *zid;\n\tphp_curl   *ch;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &zid, &str, &str_len) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(ch, php_curl *, &zid, -1, le_curl_name, le_curl);\n\tif ((res = curl_easy_escape(ch->cp, str, str_len))) {\n\t\tRETVAL_STRING(res, 1);\n\t\tcurl_free(res);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0}
{"code": "bool PrintWebViewHelper::InitPrintSettings(bool fit_to_paper_size) {\n  PrintMsg_PrintPages_Params settings;\n  Send(new PrintHostMsg_GetDefaultPrintSettings(routing_id(),\n                                                &settings.params));\n  bool result = true;\n  if (!PrintMsg_Print_Params_IsValid(settings.params))\n    result = false;\n  ignore_css_margins_ = false;\n  settings.pages.clear();\n  settings.params.print_scaling_option = blink::WebPrintScalingOptionSourceSize;\n  if (fit_to_paper_size) {\n    settings.params.print_scaling_option =\n        blink::WebPrintScalingOptionFitToPrintableArea;\n  }\n  SetPrintPagesParams(settings);\n  return result;\n}", "target": 0}
{"code": "GLSurfaceOzoneEGL::~GLSurfaceOzoneEGL() {\n  Destroy();  \n}", "target": 0}
{"code": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (!IsSupportedType(input->type)) {\n    TF_LITE_KERNEL_LOG(context, \"Input data type %s (%d) is not supported.\",\n                       TfLiteTypeGetName(input->type), input->type);\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void set_frag_stream(MOVFragmentIndex *frag_index, int id)\n{\n    int i;\n    MOVFragmentIndexItem * item;\n    if (frag_index->current < 0 ||\n        frag_index->current >= frag_index->nb_items)\n        return;\n    item = &frag_index->item[frag_index->current];\n    for (i = 0; i < item->nb_stream_info; i++)\n        if (item->stream_info[i].id == id) {\n            item->current = i;\n            return;\n        }\n    item->current = -1;\n}", "target": 0}
{"code": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}", "target": 0}
{"code": "theme_adium_inspector_close_window_cb (WebKitWebInspector *inspector,\n\t\t\t\t       EmpathyThemeAdium  *theme)\n{\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (theme);\n\tif (priv->inspector_window) {\n\t\tgtk_widget_hide (priv->inspector_window);\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "int vc_allocate(unsigned int currcons)\t\n{\n\tstruct vt_notifier_param param;\n\tstruct vc_data *vc;\n\tWARN_CONSOLE_UNLOCKED();\n\tif (currcons >= MAX_NR_CONSOLES)\n\t\treturn -ENXIO;\n\tif (vc_cons[currcons].d)\n\t\treturn 0;\n\tparam.vc = vc = kzalloc(sizeof(struct vc_data), GFP_KERNEL);\n\tif (!vc)\n\t\treturn -ENOMEM;\n\tvc_cons[currcons].d = vc;\n\ttty_port_init(&vc->port);\n\tvc->port.ops = &vc_port_ops;\n\tINIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);\n\tvisual_init(vc, currcons, 1);\n\tif (!*vc->vc_uni_pagedir_loc)\n\t\tcon_set_default_unimap(vc);\n\tvc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_KERNEL);\n\tif (!vc->vc_screenbuf)\n\t\tgoto err_free;\n\tif (global_cursor_default == -1)\n\t\tglobal_cursor_default = 1;\n\tvc_init(vc, vc->vc_rows, vc->vc_cols, 1);\n\tvcs_make_sysfs(currcons);\n\tatomic_notifier_call_chain(&vt_notifier_list, VT_ALLOCATE, &param);\n\treturn 0;\nerr_free:\n\tvisual_deinit(vc);\n\tkfree(vc);\n\tvc_cons[currcons].d = NULL;\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "    void CrwMap::decode0x1810(const CiffComponent& ciffComponent,\n                              const CrwMapping*    pCrwMapping,\n                                    Image&         image,\n                                    ByteOrder      byteOrder)\n    {\n        if (ciffComponent.typeId() != unsignedLong || ciffComponent.size() < 28) {\n            return decodeBasic(ciffComponent, pCrwMapping, image, byteOrder);\n        }\n        ExifKey key1(\"Exif.Photo.PixelXDimension\");\n        ULongValue value1;\n        value1.read(ciffComponent.pData(), 4, byteOrder);\n        image.exifData().add(key1, &value1);\n        ExifKey key2(\"Exif.Photo.PixelYDimension\");\n        ULongValue value2;\n        value2.read(ciffComponent.pData() + 4, 4, byteOrder);\n        image.exifData().add(key2, &value2);\n        int32_t r = getLong(ciffComponent.pData() + 12, byteOrder);\n        uint16_t o = RotationMap::orientation(r);\n        image.exifData()[\"Exif.Image.Orientation\"] = o;\n    } ", "target": 0}
{"code": "static int fts3MatchinfoLcsCb(\n  Fts3Expr *pExpr,                \n  int iPhrase,                    \n  void *pCtx                      \n){\n  LcsIterator *aIter = (LcsIterator *)pCtx;\n  aIter[iPhrase].pExpr = pExpr;\n  return SQLITE_OK;\n}", "target": 0}
{"code": "static int timezone_initialize(timelib_tzinfo **tzi,  char *tz TSRMLS_DC)\n{\n\tchar *tzid;\n\t*tzi = NULL;\n\tif ((tzid = timelib_timezone_id_from_abbr(tz, -1, 0))) {\n\t\t*tzi = php_date_parse_tzfile(tzid, DATE_TIMEZONEDB TSRMLS_CC);\n\t} else {\n\t\t*tzi = php_date_parse_tzfile(tz, DATE_TIMEZONEDB TSRMLS_CC);\n\t}\n\tif (*tzi) {\n\t\treturn SUCCESS;\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown or bad timezone (%s)\", tz);\n\t\treturn FAILURE;\n\t}", "target": 0}
{"code": "static ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,\n\t\t\t    size_t bufsiz)\n{\n\tssize_t rc;\n\tu32 count, ordinal;\n\tunsigned long stop;\n\tif (bufsiz > TPM_BUFSIZE)\n\t\tbufsiz = TPM_BUFSIZE;\n\tcount = be32_to_cpu(*((__be32 *) (buf + 2)));\n\tordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\n\tif (count == 0)\n\t\treturn -ENODATA;\n\tif (count > bufsiz) {\n\t\tdev_err(chip->dev,\n\t\t\t\"invalid count value %x %zx \\n\", count, bufsiz);\n\t\treturn -E2BIG;\n\t}\n\tmutex_lock(&chip->tpm_mutex);\n\tif ((rc = chip->vendor.send(chip, (u8 *) buf, count)) < 0) {\n\t\tdev_err(chip->dev,\n\t\t\t\"tpm_transmit: tpm_send: error %zd\\n\", rc);\n\t\tgoto out;\n\t}\n\tif (chip->vendor.irq)\n\t\tgoto out_recv;\n\tstop = jiffies + tpm_calc_ordinal_duration(chip, ordinal);\n\tdo {\n\t\tu8 status = chip->vendor.status(chip);\n\t\tif ((status & chip->vendor.req_complete_mask) ==\n\t\t    chip->vendor.req_complete_val)\n\t\t\tgoto out_recv;\n\t\tif ((status == chip->vendor.req_canceled)) {\n\t\t\tdev_err(chip->dev, \"Operation Canceled\\n\");\n\t\t\trc = -ECANCELED;\n\t\t\tgoto out;\n\t\t}\n\t\tmsleep(TPM_TIMEOUT);\t\n\t\trmb();\n\t} while (time_before(jiffies, stop));\n\tchip->vendor.cancel(chip);\n\tdev_err(chip->dev, \"Operation Timed out\\n\");\n\trc = -ETIME;\n\tgoto out;\nout_recv:\n\trc = chip->vendor.recv(chip, (u8 *) buf, bufsiz);\n\tif (rc < 0)\n\t\tdev_err(chip->dev,\n\t\t\t\"tpm_transmit: tpm_recv: error %zd\\n\", rc);\nout:\n\tmutex_unlock(&chip->tpm_mutex);\n\treturn rc;\n}", "target": 0}
{"code": "_tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)\n{\n\tuint64 size64 = _tiffSizeProc(fd);\n\ttmsize_t sizem = (tmsize_t)size64;\n\tif ((uint64)sizem==size64) {\n\t\tfd_as_handle_union_t fdh;\n\t\tfdh.h = fd;\n\t\t*pbase = (void*)\n\t\t    mmap(0, (size_t)sizem, PROT_READ, MAP_SHARED, fdh.fd, 0);\n\t\tif (*pbase != (void*) -1) {\n\t\t\t*psize = (tmsize_t)sizem;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "int PDFiumEngine::GetNamedDestinationPage(const std::string& destination) {\n  FPDF_DEST dest = FPDF_GetNamedDestByName(doc_, destination.c_str());\n  if (!dest) {\n    base::string16 destination_wide = base::UTF8ToUTF16(destination);\n    FPDF_WIDESTRING destination_pdf_wide =\n        reinterpret_cast<FPDF_WIDESTRING>(destination_wide.c_str());\n    FPDF_BOOKMARK bookmark = FPDFBookmark_Find(doc_, destination_pdf_wide);\n    if (!bookmark)\n      return -1;\n    dest = FPDFBookmark_GetDest(doc_, bookmark);\n  }\n  return dest ? FPDFDest_GetPageIndex(doc_, dest) : -1;\n}", "target": 0}
{"code": "    **/\n    CImg<T>& sign() {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=32768))\n      cimg_rof(*this,ptrd,T) *ptrd = cimg::sign(*ptrd);\n      return *this;", "target": 0}
{"code": "static inline int rq_prio(const struct i915_request *rq)\n{\n\treturn rq->sched.attr.priority;\n}", "target": 0}
{"code": "void LibRaw::init_fuji_compr(struct fuji_compressed_params *info)\n{\n  int cur_val, i;\n  int8_t *qt;\n  if ((libraw_internal_data.unpacker_data.fuji_block_width % 3 &&\n       libraw_internal_data.unpacker_data.fuji_raw_type == 16) ||\n      (libraw_internal_data.unpacker_data.fuji_block_width & 1 &&\n       libraw_internal_data.unpacker_data.fuji_raw_type == 0))\n    derror();\n  info->q_table =\n      (int8_t *)malloc(2 << libraw_internal_data.unpacker_data.fuji_bits);\n  merror(info->q_table, \"init_fuji_compr()\");\n  if (libraw_internal_data.unpacker_data.fuji_raw_type == 16)\n    info->line_width =\n        (libraw_internal_data.unpacker_data.fuji_block_width * 2) / 3;\n  else\n    info->line_width = libraw_internal_data.unpacker_data.fuji_block_width >> 1;\n  info->q_point[0] = 0;\n  info->q_point[1] = 0x12;\n  info->q_point[2] = 0x43;\n  info->q_point[3] = 0x114;\n  info->q_point[4] = (1 << libraw_internal_data.unpacker_data.fuji_bits) - 1;\n  info->min_value = 0x40;\n  cur_val = -info->q_point[4];\n  for (qt = info->q_table; cur_val <= info->q_point[4]; ++qt, ++cur_val)\n  {\n    if (cur_val <= -info->q_point[3])\n      *qt = -4;\n    else if (cur_val <= -info->q_point[2])\n      *qt = -3;\n    else if (cur_val <= -info->q_point[1])\n      *qt = -2;\n    else if (cur_val < 0)\n      *qt = -1;\n    else if (cur_val == 0)\n      *qt = 0;\n    else if (cur_val < info->q_point[1])\n      *qt = 1;\n    else if (cur_val < info->q_point[2])\n      *qt = 2;\n    else if (cur_val < info->q_point[3])\n      *qt = 3;\n    else\n      *qt = 4;\n  }\n  info->total_values = (1 << libraw_internal_data.unpacker_data.fuji_bits);\n  info->raw_bits = libraw_internal_data.unpacker_data.fuji_bits;\n  info->max_bits = 4 * info->raw_bits;\n  info->maxDiff = info->total_values >> 6;\n}", "target": 0}
{"code": "int htp_tx_get_is_config_shared(const htp_tx_t *tx) {\n    if (tx == NULL) return -1;\n    return tx->is_config_shared;\n}", "target": 0}
{"code": "SYSCALL_DEFINE1(sched_get_priority_max, int, policy)\n{\n\tint ret = -EINVAL;\n\tswitch (policy) {\n\tcase SCHED_FIFO:\n\tcase SCHED_RR:\n\t\tret = MAX_USER_RT_PRIO-1;\n\t\tbreak;\n\tcase SCHED_DEADLINE:\n\tcase SCHED_NORMAL:\n\tcase SCHED_BATCH:\n\tcase SCHED_IDLE:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static inline MagickBooleanType IsPixelCacheAuthentic(\n  const CacheInfo *magick_restrict cache_info,\n  const NexusInfo *magick_restrict nexus_info)\n{\n  MagickBooleanType\n    status;\n  MagickOffsetType\n    offset;\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  status=nexus_info->pixels == (cache_info->pixels+offset*\n    cache_info->number_channels) ? MagickTrue : MagickFalse;\n  return(status);\n}", "target": 0}
{"code": "void RenderView::didNotAllowPlugins(WebKit::WebFrame* frame) {\n  DidBlockContentType(CONTENT_SETTINGS_TYPE_PLUGINS);\n}", "target": 0}
{"code": "isoent_find_out_boot_file(struct archive_write *a, struct isoent *rootent)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tiso9660->el_torito.boot = isoent_find_entry(rootent,\n\t    iso9660->el_torito.boot_filename.s);\n\tif (iso9660->el_torito.boot == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Can't find the boot image file ``%s''\",\n\t\t    iso9660->el_torito.boot_filename.s);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tiso9660->el_torito.boot->file->boot = BOOT_IMAGE;\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static int __init kvm_spinlock_debugfs(void)\n{\n\tstruct dentry *d_kvm;\n\td_kvm = kvm_init_debugfs();\n\tif (d_kvm == NULL)\n\t\treturn -ENOMEM;\n\td_spin_debug = debugfs_create_dir(\"spinlocks\", d_kvm);\n\tdebugfs_create_u8(\"zero_stats\", 0644, d_spin_debug, &zero_stats);\n\tdebugfs_create_u32(\"taken_slow\", 0444, d_spin_debug,\n\t\t   &spinlock_stats.contention_stats[TAKEN_SLOW]);\n\tdebugfs_create_u32(\"taken_slow_pickup\", 0444, d_spin_debug,\n\t\t   &spinlock_stats.contention_stats[TAKEN_SLOW_PICKUP]);\n\tdebugfs_create_u32(\"released_slow\", 0444, d_spin_debug,\n\t\t   &spinlock_stats.contention_stats[RELEASED_SLOW]);\n\tdebugfs_create_u32(\"released_slow_kicked\", 0444, d_spin_debug,\n\t\t   &spinlock_stats.contention_stats[RELEASED_SLOW_KICKED]);\n\tdebugfs_create_u64(\"time_blocked\", 0444, d_spin_debug,\n\t\t\t   &spinlock_stats.time_blocked);\n\tdebugfs_create_u32_array(\"histo_blocked\", 0444, d_spin_debug,\n\t\t     spinlock_stats.histo_spin_blocked, HISTO_BUCKETS + 1);\n\treturn 0;\n}", "target": 0}
{"code": "    Task::~Task()\n    {\n    }", "target": 0}
{"code": "trace_recursive_lock(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tunsigned int val = cpu_buffer->current_context;\n\tint bit;\n\tif (in_interrupt()) {\n\t\tif (in_nmi())\n\t\t\tbit = RB_CTX_NMI;\n\t\telse if (in_irq())\n\t\t\tbit = RB_CTX_IRQ;\n\t\telse\n\t\t\tbit = RB_CTX_SOFTIRQ;\n\t} else\n\t\tbit = RB_CTX_NORMAL;\n\tif (unlikely(val & (1 << bit)))\n\t\treturn 1;\n\tval |= (1 << bit);\n\tcpu_buffer->current_context = val;\n\treturn 0;\n}", "target": 0}
{"code": "static int fsck_commit(struct commit *commit, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tconst char *buffer = data ?  data : get_commit_buffer(commit, &size);\n\tint ret = fsck_commit_buffer(commit, buffer, size, options);\n\tif (!data)\n\t\tunuse_commit_buffer(commit, buffer);\n\treturn ret;\n}", "target": 0}
{"code": "static void rds_recv_incoming_exthdrs(struct rds_incoming *inc, struct rds_sock *rs)\n{\n\tstruct rds_header *hdr = &inc->i_hdr;\n\tunsigned int pos = 0, type, len;\n\tunion {\n\t\tstruct rds_ext_header_version version;\n\t\tstruct rds_ext_header_rdma rdma;\n\t\tstruct rds_ext_header_rdma_dest rdma_dest;\n\t} buffer;\n\twhile (1) {\n\t\tlen = sizeof(buffer);\n\t\ttype = rds_message_next_extension(hdr, &pos, &buffer, &len);\n\t\tif (type == RDS_EXTHDR_NONE)\n\t\t\tbreak;\n\t\tswitch (type) {\n\t\tcase RDS_EXTHDR_RDMA:\n\t\t\trds_rdma_unuse(rs, be32_to_cpu(buffer.rdma.h_rdma_rkey), 0);\n\t\t\tbreak;\n\t\tcase RDS_EXTHDR_RDMA_DEST:\n\t\t\tinc->i_rdma_cookie = rds_rdma_make_cookie(\n\t\t\t\t\tbe32_to_cpu(buffer.rdma_dest.h_rdma_rkey),\n\t\t\t\t\tbe32_to_cpu(buffer.rdma_dest.h_rdma_offset));\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 0}
{"code": "int HttpStreamParser::DoReadBody() {\n  io_state_ = STATE_READ_BODY_COMPLETE;\n  if (read_buf_->offset()) {\n    int available = read_buf_->offset() - read_buf_unused_offset_;\n    if (available) {\n      CHECK_GT(available, 0);\n      int bytes_from_buffer = std::min(available, user_read_buf_len_);\n      memcpy(user_read_buf_->data(),\n             read_buf_->StartOfBuffer() + read_buf_unused_offset_,\n             bytes_from_buffer);\n      read_buf_unused_offset_ += bytes_from_buffer;\n      if (bytes_from_buffer == available) {\n        read_buf_->SetCapacity(0);\n        read_buf_unused_offset_ = 0;\n      }\n      return bytes_from_buffer;\n    } else {\n      read_buf_->SetCapacity(0);\n      read_buf_unused_offset_ = 0;\n    }\n  }\n  if (IsResponseBodyComplete())\n    return 0;\n  DCHECK_EQ(0, read_buf_->offset());\n  return connection_->socket()->Read(user_read_buf_, user_read_buf_len_,\n                                     io_callback_);\n}", "target": 0}
{"code": "void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tkvm_x86_ops->adjust_tsc_offset(vcpu, -tsc_delta);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t}\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n}", "target": 0}
{"code": "void ContentSettingsStore::NotifyOfContentSettingChanged(\n    const std::string& extension_id,\n    bool incognito) {\n  FOR_EACH_OBSERVER(\n      ContentSettingsStore::Observer,\n      observers_,\n      OnContentSettingChanged(extension_id, incognito));\n}", "target": 0}
{"code": "static int cbc1_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret;\n    int num_of_encrypted_blocks;\n    uint8_t iv[16];\n    if (!sc->cenc.aes_ctx) {\n        sc->cenc.aes_ctx = av_aes_alloc();\n        if (!sc->cenc.aes_ctx) {\n            return AVERROR(ENOMEM);\n        }\n        ret = av_aes_init(sc->cenc.aes_ctx, c->decryption_key, 16 * 8, 1);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    memcpy(iv, sample->iv, 16);\n    if (!sample->subsample_count) {\n        av_aes_crypt(sc->cenc.aes_ctx, input, input, size/16, iv, 1);\n        return 0;\n    }\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (sample->subsamples[i].bytes_of_protected_data % 16) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample BytesOfProtectedData is not a multiple of 16\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n        num_of_encrypted_blocks = sample->subsamples[i].bytes_of_protected_data/16;\n        if (num_of_encrypted_blocks > 0) {\n            av_aes_crypt(sc->cenc.aes_ctx, input, input, num_of_encrypted_blocks, iv, 1);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"code": "PHP_MINFO_FUNCTION(pgsql)\n{\n\tchar buf[256];\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"PostgreSQL Support\", \"enabled\");\n#if HAVE_PG_CONFIG_H\n\tphp_info_print_table_row(2, \"PostgreSQL(libpq) Version\", PG_VERSION);\n\tphp_info_print_table_row(2, \"PostgreSQL(libpq) \", PG_VERSION_STR);\n#ifdef HAVE_PGSQL_WITH_MULTIBYTE_SUPPORT\n\tphp_info_print_table_row(2, \"Multibyte character support\", \"enabled\");\n#else\n\tphp_info_print_table_row(2, \"Multibyte character support\", \"disabled\");\n#endif\n#ifdef USE_SSL\n\tphp_info_print_table_row(2, \"SSL support\", \"enabled\");\n#else\n\tphp_info_print_table_row(2, \"SSL support\", \"disabled\");\n#endif\n#endif \n\tsnprintf(buf, sizeof(buf), ZEND_LONG_FMT, PGG(num_persistent));\n\tphp_info_print_table_row(2, \"Active Persistent Links\", buf);\n\tsnprintf(buf, sizeof(buf), ZEND_LONG_FMT, PGG(num_links));\n\tphp_info_print_table_row(2, \"Active Links\", buf);\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();\n}", "target": 0}
{"code": "header_odc(struct archive_read *a, struct cpio *cpio,\n    struct archive_entry *entry, size_t *namelength, size_t *name_pad)\n{\n\tconst void *h;\n\tint r;\n\tconst char *header;\n\ta->archive.archive_format = ARCHIVE_FORMAT_CPIO_POSIX;\n\ta->archive.archive_format_name = \"POSIX octet-oriented cpio\";\n\tr = find_odc_header(a);\n\tif (r < ARCHIVE_WARN)\n\t\treturn (r);\n\tif (a->archive.archive_format == ARCHIVE_FORMAT_CPIO_AFIO_LARGE) {\n\t\tint r2 = (header_afiol(a, cpio, entry, namelength, name_pad));\n\t\tif (r2 == ARCHIVE_OK)\n\t\t\treturn (r);\n\t\telse\n\t\t\treturn (r2);\n\t}\n\th = __archive_read_ahead(a, odc_header_size, NULL);\n\tif (h == NULL)\n\t    return (ARCHIVE_FATAL);\n\theader = (const char *)h;\n\tarchive_entry_set_dev(entry, \n\t\t(dev_t)atol8(header + odc_dev_offset, odc_dev_size));\n\tarchive_entry_set_ino(entry, atol8(header + odc_ino_offset, odc_ino_size));\n\tarchive_entry_set_mode(entry, \n\t\t(mode_t)atol8(header + odc_mode_offset, odc_mode_size));\n\tarchive_entry_set_uid(entry, atol8(header + odc_uid_offset, odc_uid_size));\n\tarchive_entry_set_gid(entry, atol8(header + odc_gid_offset, odc_gid_size));\n\tarchive_entry_set_nlink(entry, \n\t\t(unsigned int)atol8(header + odc_nlink_offset, odc_nlink_size));\n\tarchive_entry_set_rdev(entry,\n\t\t(dev_t)atol8(header + odc_rdev_offset, odc_rdev_size));\n\tarchive_entry_set_mtime(entry, atol8(header + odc_mtime_offset, odc_mtime_size), 0);\n\t*namelength = (size_t)atol8(header + odc_namesize_offset, odc_namesize_size);\n\t*name_pad = 0; \n\tcpio->entry_bytes_remaining =\n\t    atol8(header + odc_filesize_offset, odc_filesize_size);\n\tarchive_entry_set_size(entry, cpio->entry_bytes_remaining);\n\tcpio->entry_padding = 0;\n\t__archive_read_consume(a, odc_header_size);\n\treturn (r);\n}", "target": 0}
{"code": "static int copy_strings(int argc, char __user * __user * argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tstruct page *kmapped_page = NULL;\n\tchar *kaddr = NULL;\n\tunsigned long kpos = 0;\n\tint ret;\n\twhile (argc-- > 0) {\n\t\tchar __user *str;\n\t\tint len;\n\t\tunsigned long pos;\n\t\tif (get_user(str, argv+argc) ||\n\t\t\t\t!(len = strnlen_user(str, MAX_ARG_STRLEN))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!valid_arg_len(bprm, len)) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t\tpos = bprm->p;\n\t\tstr += len;\n\t\tbprm->p -= len;\n\t\twhile (len > 0) {\n\t\t\tint offset, bytes_to_copy;\n\t\t\toffset = pos % PAGE_SIZE;\n\t\t\tif (offset == 0)\n\t\t\t\toffset = PAGE_SIZE;\n\t\t\tbytes_to_copy = offset;\n\t\t\tif (bytes_to_copy > len)\n\t\t\t\tbytes_to_copy = len;\n\t\t\toffset -= bytes_to_copy;\n\t\t\tpos -= bytes_to_copy;\n\t\t\tstr -= bytes_to_copy;\n\t\t\tlen -= bytes_to_copy;\n\t\t\tif (!kmapped_page || kpos != (pos & PAGE_MASK)) {\n\t\t\t\tstruct page *page;\n\t\t\t\tpage = get_arg_page(bprm, pos, 1);\n\t\t\t\tif (!page) {\n\t\t\t\t\tret = -E2BIG;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (kmapped_page) {\n\t\t\t\t\tflush_kernel_dcache_page(kmapped_page);\n\t\t\t\t\tkunmap(kmapped_page);\n\t\t\t\t\tput_arg_page(kmapped_page);\n\t\t\t\t}\n\t\t\t\tkmapped_page = page;\n\t\t\t\tkaddr = kmap(kmapped_page);\n\t\t\t\tkpos = pos & PAGE_MASK;\n\t\t\t\tflush_arg_page(bprm, kpos, kmapped_page);\n\t\t\t}\n\t\t\tif (copy_from_user(kaddr+offset, str, bytes_to_copy)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\nout:\n\tif (kmapped_page) {\n\t\tflush_kernel_dcache_page(kmapped_page);\n\t\tkunmap(kmapped_page);\n\t\tput_arg_page(kmapped_page);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "    template<typename tc>\n    CImg<T>& draw_circle(const int x0, const int y0, int radius,\n                         const tc *const color, const float opacity,\n                         const unsigned int pattern) {\n      cimg::unused(pattern);\n      if (is_empty()) return *this;\n      if (!color)\n        throw CImgArgumentException(_cimg_instance\n                                    \"draw_circle(): Specified color is (null).\",\n                                    cimg_instance);\n      if (radius<0 || x0 - radius>=width() || y0 + radius<0 || y0 - radius>=height()) return *this;\n      if (!radius) return draw_point(x0,y0,color,opacity);\n      draw_point(x0 - radius,y0,color,opacity).draw_point(x0 + radius,y0,color,opacity).\n        draw_point(x0,y0 - radius,color,opacity).draw_point(x0,y0 + radius,color,opacity);\n      if (radius==1) return *this;\n      for (int f = 1 - radius, ddFx = 0, ddFy = -(radius<<1), x = 0, y = radius; x<y; ) {\n        if (f>=0) { f+=(ddFy+=2); --y; }\n        ++x; ++(f+=(ddFx+=2));\n        if (x!=y + 1) {\n          const int x1 = x0 - y, x2 = x0 + y, y1 = y0 - x, y2 = y0 + x,\n            x3 = x0 - x, x4 = x0 + x, y3 = y0 - y, y4 = y0 + y;\n          draw_point(x1,y1,color,opacity).draw_point(x1,y2,color,opacity).\n            draw_point(x2,y1,color,opacity).draw_point(x2,y2,color,opacity);\n          if (x!=y)\n            draw_point(x3,y3,color,opacity).draw_point(x4,y4,color,opacity).\n              draw_point(x4,y3,color,opacity).draw_point(x3,y4,color,opacity);\n        }\n      }\n      return *this;", "target": 0}
{"code": "void opj_j2k_copy_tile_quantization_parameters( opj_j2k_t *p_j2k )\n{\n        OPJ_UINT32 i;\n        opj_cp_t *l_cp = NULL;\n        opj_tcp_t *l_tcp = NULL;\n        opj_tccp_t *l_ref_tccp = NULL;\n        opj_tccp_t *l_copied_tccp = NULL;\n        OPJ_UINT32 l_size;\n        assert(p_j2k != 00);\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n                        &l_cp->tcps[p_j2k->m_current_tile_number] :\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp;\n        l_ref_tccp = &l_tcp->tccps[0];\n        l_copied_tccp = l_ref_tccp + 1;\n        l_size = OPJ_J2K_MAXBANDS * sizeof(opj_stepsize_t);\n        for     (i=1;i<p_j2k->m_private_image->numcomps;++i) {\n                l_copied_tccp->qntsty = l_ref_tccp->qntsty;\n                l_copied_tccp->numgbits = l_ref_tccp->numgbits;\n                memcpy(l_copied_tccp->stepsizes,l_ref_tccp->stepsizes,l_size);\n                ++l_copied_tccp;\n        }\n}", "target": 0}
{"code": "void nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t      struct nft_set_binding *binding,\n\t\t\t      enum nft_trans_phase phase)\n{\n\tswitch (phase) {\n\tcase NFT_TRANS_PREPARE:\n\t\tif (nft_set_is_anonymous(set))\n\t\t\tnft_deactivate_next(ctx->net, set);\n\t\tset->use--;\n\t\treturn;\n\tcase NFT_TRANS_ABORT:\n\tcase NFT_TRANS_RELEASE:\n\t\tset->use--;\n\t\tfallthrough;\n\tdefault:\n\t\tnf_tables_unbind_set(ctx, set, binding,\n\t\t\t\t     phase == NFT_TRANS_COMMIT);\n\t}\n}", "target": 0}
{"code": "void dtls1_double_timeout(SSL *s)\n{\n    s->d1->timeout_duration *= 2;\n    if (s->d1->timeout_duration > 60)\n        s->d1->timeout_duration = 60;\n    dtls1_start_timer(s);\n}", "target": 0}
{"code": "static void nvme_sg_split(NvmeSg *sg, NvmeNamespace *ns, NvmeSg *data,\n                          NvmeSg *mdata)\n{\n    NvmeSg *dst = data;\n    uint32_t trans_len, count = ns->lbasz;\n    uint64_t offset = 0;\n    bool dma = sg->flags & NVME_SG_DMA;\n    size_t sge_len;\n    size_t sg_len = dma ? sg->qsg.size : sg->iov.size;\n    int sg_idx = 0;\n    assert(sg->flags & NVME_SG_ALLOC);\n    while (sg_len) {\n        sge_len = dma ? sg->qsg.sg[sg_idx].len : sg->iov.iov[sg_idx].iov_len;\n        trans_len = MIN(sg_len, count);\n        trans_len = MIN(trans_len, sge_len - offset);\n        if (dst) {\n            if (dma) {\n                qemu_sglist_add(&dst->qsg, sg->qsg.sg[sg_idx].base + offset,\n                                trans_len);\n            } else {\n                qemu_iovec_add(&dst->iov,\n                               sg->iov.iov[sg_idx].iov_base + offset,\n                               trans_len);\n            }\n        }\n        sg_len -= trans_len;\n        count -= trans_len;\n        offset += trans_len;\n        if (count == 0) {\n            dst = (dst == data) ? mdata : data;\n            count = (dst == data) ? ns->lbasz : ns->lbaf.ms;\n        }\n        if (sge_len == offset) {\n            offset = 0;\n            sg_idx++;\n        }\n    }\n}", "target": 0}
{"code": "static inline int tcp_try_rmem_schedule(struct sock *sk, unsigned int size)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf ||\n\t    !sk_rmem_schedule(sk, size)) {\n\t\tif (tcp_prune_queue(sk) < 0)\n\t\t\treturn -1;\n\t\tif (!sk_rmem_schedule(sk, size)) {\n\t\t\tif (!tcp_prune_ofo_queue(sk))\n\t\t\t\treturn -1;\n\t\t\tif (!sk_rmem_schedule(sk, size))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void queue_cleanup(struct list_head *list)\n{\n\tstruct read_buffer *rb;\n\twhile (!list_empty(list)) {\n\t\trb = list_entry(list->next, struct read_buffer, list);\n\t\tlist_del(list->next);\n\t\tkfree(rb);\n\t}\n}", "target": 0}
{"code": "    template<typename t>\n    CImg<T>& operator/=(const t value) {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=32768))\n      cimg_rof(*this,ptrd,T) *ptrd = (T)(*ptrd / value);\n      return *this;", "target": 0}
{"code": "generate_string(cms_context *cms, SECItem *der, char *str)\n{\n\tSECItem input;\n\tinput.data = (void *)str;\n\tinput.len = strlen(str);\n\tinput.type = siBMPString;\n\tvoid *ret;\n\tret = SEC_ASN1EncodeItem(cms->arena, der, &input,\n\t\t\t\t\t\tSEC_PrintableStringTemplate);\n\tif (ret == NULL)\n\t\tcnreterr(-1, cms, \"could not encode string\");\n\treturn 0;\n}", "target": 0}
{"code": "write_uint64_le(ds_file_t *file, ulonglong n)\n{\n\tchar tmp[8];\n\tint8store(tmp, n);\n\treturn ds_write(file, tmp, sizeof(tmp));\n}", "target": 0}
{"code": "int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info)\n{\n\tint ret = 0;\n\tstruct dmar_rmrr_unit *rmrru;\n\tstruct dmar_atsr_unit *atsru;\n\tstruct acpi_dmar_atsr *atsr;\n\tstruct acpi_dmar_reserved_memory *rmrr;\n\tif (!intel_iommu_enabled && system_state >= SYSTEM_RUNNING)\n\t\treturn 0;\n\tlist_for_each_entry(rmrru, &dmar_rmrr_units, list) {\n\t\trmrr = container_of(rmrru->hdr,\n\t\t\t\t    struct acpi_dmar_reserved_memory, header);\n\t\tif (info->event == BUS_NOTIFY_ADD_DEVICE) {\n\t\t\tret = dmar_insert_dev_scope(info, (void *)(rmrr + 1),\n\t\t\t\t((void *)rmrr) + rmrr->header.length,\n\t\t\t\trmrr->segment, rmrru->devices,\n\t\t\t\trmrru->devices_cnt);\n\t\t\tif(ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (info->event == BUS_NOTIFY_REMOVED_DEVICE) {\n\t\t\tdmar_remove_dev_scope(info, rmrr->segment,\n\t\t\t\trmrru->devices, rmrru->devices_cnt);\n\t\t}\n\t}\n\tlist_for_each_entry(atsru, &dmar_atsr_units, list) {\n\t\tif (atsru->include_all)\n\t\t\tcontinue;\n\t\tatsr = container_of(atsru->hdr, struct acpi_dmar_atsr, header);\n\t\tif (info->event == BUS_NOTIFY_ADD_DEVICE) {\n\t\t\tret = dmar_insert_dev_scope(info, (void *)(atsr + 1),\n\t\t\t\t\t(void *)atsr + atsr->header.length,\n\t\t\t\t\tatsr->segment, atsru->devices,\n\t\t\t\t\tatsru->devices_cnt);\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\telse if(ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (info->event == BUS_NOTIFY_REMOVED_DEVICE) {\n\t\t\tif (dmar_remove_dev_scope(info, atsr->segment,\n\t\t\t\t\tatsru->devices, atsru->devices_cnt))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void nfs4_proc_unlink_setup(struct rpc_message *msg, struct inode *dir)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs *args = msg->rpc_argp;\n\tstruct nfs_removeres *res = msg->rpc_resp;\n\tres->server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE];\n\tnfs41_init_sequence(&args->seq_args, &res->seq_res, 1);\n}", "target": 0}
{"code": "void Clipboard::ReadFile(FilePath* file) const {\n  *file = FilePath();\n}", "target": 0}
{"code": "tiff_document_file_exporter_end (EvFileExporter *exporter)\n{\n\tTiffDocument *document = TIFF_DOCUMENT (exporter);\n\tif (document->ps_export_ctx == NULL)\n\t\treturn;\n\ttiff2ps_context_finalize(document->ps_export_ctx);\n}", "target": 0}
{"code": "void ContainerNode::updateTreeAfterInsertion(Node& child)\n{\n#if !ENABLE(OILPAN)\n    ASSERT(refCount());\n    ASSERT(child.refCount());\n#endif\n    ChildListMutationScope(*this).childAdded(child);\n    notifyNodeInserted(child);\n    dispatchChildInsertionEvents(child);\n}", "target": 0}
{"code": "static int check_attach_modify_return(unsigned long addr, const char *func_name)\n{\n\tif (within_error_injection_list(addr) ||\n\t    !strncmp(SECURITY_PREFIX, func_name, sizeof(SECURITY_PREFIX) - 1))\n\t\treturn 0;\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static int __soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\tlock_page(page);\n\twait_on_page_writeback(page);\n\tif (PageHWPoison(page)) {\n\t\tunlock_page(page);\n\t\tput_hwpoison_page(page);\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\tret = invalidate_inode_page(page);\n\tunlock_page(page);\n\tif (ret == 1) {\n\t\tput_hwpoison_page(page);\n\t\tpr_info(\"soft_offline: %#lx: invalidated\\n\", pfn);\n\t\tSetPageHWPoison(page);\n\t\tnum_poisoned_pages_inc();\n\t\treturn 0;\n\t}\n\tif (PageLRU(page))\n\t\tret = isolate_lru_page(page);\n\telse\n\t\tret = isolate_movable_page(page, ISOLATE_UNEVICTABLE);\n\tput_hwpoison_page(page);\n\tif (!ret) {\n\t\tLIST_HEAD(pagelist);\n\t\tif (!__PageMovable(page))\n\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t\tpage_is_file_cache(page));\n\t\tlist_add(&page->lru, &pagelist);\n\t\tret = migrate_pages(&pagelist, new_page, NULL, MPOL_MF_MOVE_ALL,\n\t\t\t\t\tMIGRATE_SYNC, MR_MEMORY_FAILURE);\n\t\tif (ret) {\n\t\t\tif (!list_empty(&pagelist))\n\t\t\t\tputback_movable_pages(&pagelist);\n\t\t\tpr_info(\"soft offline: %#lx: migration failed %d, type %lx (%pGp)\\n\",\n\t\t\t\tpfn, ret, page->flags, &page->flags);\n\t\t\tif (ret > 0)\n\t\t\t\tret = -EIO;\n\t\t}\n\t} else {\n\t\tpr_info(\"soft offline: %#lx: isolation failed: %d, page count %d, type %lx (%pGp)\\n\",\n\t\t\tpfn, ret, page_count(page), page->flags, &page->flags);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "I16L_I(UINT8 *out_, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 2, out_ += 4) {\n        INT32 v = in[0] + ((int)in[1] << 8);\n        memcpy(out_, &v, sizeof(v));\n    }\n}", "target": 0}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tut64 offset = 0;\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->file_offset = buf_offset;\n\tse->tag = buffer[offset];\n\toffset += 1;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t}\n\tif (R_BIN_JAVA_STACKMAP_UNINIT < se->tag) {\n\t\tr_bin_java_verification_info_free (se);\n\t\treturn NULL;\n\t}\n\tse->size = offset;\n\treturn se;\n}", "target": 0}
{"code": "static int stream_thunk(void *buf, size_t size, void *data)\n{\n\tint error = 0;\n\tstruct push_packbuilder_payload *payload = data;\n\tif ((error = payload->stream->write(payload->stream, (const char *)buf, size)) < 0)\n\t\treturn error;\n\tif (payload->cb) {\n\t\tdouble current_time = git__timer();\n\t\tpayload->last_bytes += size;\n\t\tif ((current_time - payload->last_progress_report_time) >= MIN_PROGRESS_UPDATE_INTERVAL) {\n\t\t\tpayload->last_progress_report_time = current_time;\n\t\t\terror = payload->cb(payload->pb->nr_written, payload->pb->nr_objects, payload->last_bytes, payload->cb_payload);\n\t\t}\n\t}\n\treturn error;\n}", "target": 0}
{"code": "gs_interpret(i_ctx_t **pi_ctx_p, ref * pref, int user_errors, int *pexit_code,\n             ref * perror_object)\n{\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    gs_gc_root_t error_root;\n    int code;\n    gs_register_ref_root(imemory_system, &error_root,\n                         (void **)&perror_object, \"gs_interpret\");\n    code = gs_call_interp(pi_ctx_p, pref, user_errors, pexit_code,\n                          perror_object);\n    i_ctx_p = *pi_ctx_p;\n    gs_unregister_root(imemory_system, &error_root, \"gs_interpret\");\n    set_gc_signal(i_ctx_p, 0);\n    return code;\n}", "target": 0}
{"code": "static void avrcp_add_to_nowplaying(struct avrcp *session, uint64_t uid)\n{\n\tuint8_t buf[AVRCP_HEADER_LENGTH + 11];\n\tstruct avrcp_player *player = session->controller->player;\n\tstruct avrcp_header *pdu = (void *) buf;\n\tuint16_t length;\n\tmemset(buf, 0, sizeof(buf));\n\tset_company_id(pdu->company_id, IEEEID_BTSIG);\n\tpdu->pdu_id = AVRCP_ADD_TO_NOW_PLAYING;\n\tpdu->params_len = htons(11);\n\tpdu->packet_type = AVRCP_PACKET_TYPE_SINGLE;\n\tpdu->params[0] = player->scope;\n\tput_be64(uid, &pdu->params[1]);\n\tput_be16(player->uid_counter, &pdu->params[9]);\n\tlength = AVRCP_HEADER_LENGTH + ntohs(pdu->params_len);\n\tavctp_send_vendordep_req(session->conn, AVC_CTYPE_CONTROL,\n\t\t\t\t\tAVC_SUBUNIT_PANEL, buf, length,\n\t\t\t\t\tNULL, session);\n}", "target": 0}
{"code": "parse_SET_ETH_SRC(char *arg, const struct ofpact_parse_params *pp)\n{\n    return str_to_mac(arg, &ofpact_put_SET_ETH_SRC(pp->ofpacts)->mac);\n}", "target": 0}
{"code": "    DataBuf::DataBuf(const byte* pData, size_t size)\n        : pData_(0), size_(0)\n    {\n        if (size > 0) {\n            pData_ = new byte[size];\n            std::memcpy(pData_, pData, size);\n            size_ = size;\n        }\n    }", "target": 0}
{"code": "static int virtio_net_set_vnet_endian_one(VirtIODevice *vdev,\n                                          NetClientState *peer,\n                                          bool enable)\n{\n    if (virtio_is_big_endian(vdev)) {\n        return qemu_set_vnet_be(peer, enable);\n    } else {\n        return qemu_set_vnet_le(peer, enable);\n    }\n}", "target": 0}
{"code": "static timelib_ull timelib_get_unsigned_nr(char **ptr, int max_length)\n{\n\ttimelib_ull dir = 1;\n\twhile (((**ptr < '0') || (**ptr > '9')) && (**ptr != '+') && (**ptr != '-')) {\n\t\tif (**ptr == '\\0') {\n\t\t\treturn TIMELIB_UNSET;\n\t\t}\n\t\t++*ptr;\n\t}\n\twhile (**ptr == '+' || **ptr == '-')\n\t{\n\t\tif (**ptr == '-') {\n\t\t\tdir *= -1;\n\t\t}\n\t\t++*ptr;\n\t}\n\treturn dir * timelib_get_nr(ptr, max_length);\n}", "target": 0}
{"code": "aspath_empty (void)\n{\n  return aspath_parse (NULL, 0, 1); \n}", "target": 0}
{"code": "static int rtnl_phys_switch_id_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tint err;\n\tstruct switchdev_attr attr = {\n\t\t.orig_dev = dev,\n\t\t.id = SWITCHDEV_ATTR_ID_PORT_PARENT_ID,\n\t\t.flags = SWITCHDEV_F_NO_RECURSE,\n\t};\n\terr = switchdev_port_attr_get(dev, &attr);\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tif (nla_put(skb, IFLA_PHYS_SWITCH_ID, attr.u.ppid.id_len,\n\t\t    attr.u.ppid.id))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}", "target": 0}
{"code": "static inline void rb_inc_page(struct buffer_page **bpage)\n{\n\tstruct list_head *p = rb_list_head((*bpage)->list.next);\n\t*bpage = list_entry(p, struct buffer_page, list);\n}", "target": 0}
{"code": "static void vmx_vcpu_pi_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP))\n\t\treturn;\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\t\tif (pi_desc->nv != POSTED_INTR_WAKEUP_VECTOR) {\n\t\t\tif (vcpu->cpu != cpu) {\n\t\t\t\tdest = cpu_physical_id(cpu);\n\t\t\t\tif (x2apic_enabled())\n\t\t\t\t\tnew.ndst = dest;\n\t\t\t\telse\n\t\t\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\t\t\t}\n\t\t\tnew.nv = POSTED_INTR_VECTOR;\n\t\t}\n\t\tnew.sn = 0;\n\t} while (cmpxchg(&pi_desc->control, old.control,\n\t\t\tnew.control) != old.control);\n}", "target": 0}
{"code": "TEST_F(HeaderToMetadataTest, NoMissingWhenHeaderIsPresent) {\n  const std::string config = R\"EOF(\nrequest_rules:\n  - header: x-version\n    on_header_missing:\n      metadata_namespace: envoy.lb\n      key: version\n      value: some_value\n      type: STRING\n)EOF\";\n  initializeFilter(config);\n  Http::TestRequestHeaderMapImpl headers{{\"x-version\", \"19\"}};\n  EXPECT_CALL(decoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_, setDynamicMetadata(_, _)).Times(0);\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(headers, false));\n}", "target": 0}
{"code": "static void vnc_png_free(png_structp png_ptr, png_voidp ptr)\n{\n    g_free(ptr);\n}", "target": 0}
{"code": "static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t     unsigned long nr_pages)\n{\n\tLIST_HEAD(pages);\n\tWARN_ON(!nr_pages);\n\tif (__rb_allocate_pages(cpu_buffer, nr_pages, &pages))\n\t\treturn -ENOMEM;\n\tcpu_buffer->pages = pages.next;\n\tlist_del(&pages);\n\tcpu_buffer->nr_pages = nr_pages;\n\trb_check_pages(cpu_buffer);\n\treturn 0;\n}", "target": 0}
{"code": "String HTMLInputElement::resultForDialogSubmit()\n{\n    return m_inputType->resultForDialogSubmit();\n}", "target": 0}
{"code": "bm_search_ic(regex_t* reg, const UChar* target, const UChar* target_end,\n\t     const UChar* text, const UChar* text_end, const UChar* text_range)\n{\n  const UChar *s, *p, *end;\n  const UChar *tail;\n  ptrdiff_t tlen1;\n  OnigEncoding enc = reg->enc;\n  int case_fold_flag = reg->case_fold_flag;\n# ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"bm_search_ic: text: %\"PRIdPTR\" (%p), text_end: %\"PRIdPTR\" (%p), text_range: %\"PRIdPTR\" (%p)\\n\",\n\t  (intptr_t )text, text, (intptr_t )text_end, text_end, (intptr_t )text_range, text_range);\n# endif\n  tail = target_end - 1;\n  tlen1 = tail - target;\n  end = text_range + tlen1;\n  if (end > text_end)\n    end = text_end;\n  s = text + tlen1;\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = s - tlen1;\n      if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n\t\t\t       p, s + 1))\n\treturn (UChar* )p;\n      if (s + 1 >= end) break;\n      s += reg->map[s[1]];\n    }\n  }\n  else { \n# if OPT_EXACT_MAXLEN >= ONIG_CHAR_TABLE_SIZE\n    while (s < end) {\n      p = s - tlen1;\n      if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n\t\t\t       p, s + 1))\n\treturn (UChar* )p;\n      if (s + 1 >= end) break;\n      s += reg->int_map[s[1]];\n    }\n# endif\n  }\n  return (UChar* )NULL;\n}", "target": 0}
{"code": "int sc_pkcs15emu_sc_hsm_init_ex(sc_pkcs15_card_t *p15card,\n\t\t\t\tstruct sc_aid *aid,\n\t\t\t\tsc_pkcs15emu_opt_t *opts)\n{\n\tif (opts && (opts->flags & SC_PKCS15EMU_FLAGS_NO_CHECK)) {\n\t\treturn sc_pkcs15emu_sc_hsm_init(p15card);\n\t} else {\n\t\tif (p15card->card->type != SC_CARD_TYPE_SC_HSM\n\t\t\t\t&& p15card->card->type != SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t\t&& p15card->card->type != SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t\treturn SC_ERROR_WRONG_CARD;\n\t\t}\n\t\treturn sc_pkcs15emu_sc_hsm_init(p15card);\n\t}\n}", "target": 0}
{"code": "static inline bool skb_transport_header_was_set(const struct sk_buff *skb)\n{\n\treturn skb->transport_header != ~0U;\n}", "target": 0}
{"code": "vte_sequence_handler_erase_in_display (VteTerminal *terminal, GValueArray *params)\n{\n\tGValue *value;\n\tlong param;\n\tguint i;\n\tparam = 0;\n\tfor (i = 0; (params != NULL) && (i < params->n_values); i++) {\n\t\tvalue = g_value_array_get_nth(params, i);\n\t\tif (!G_VALUE_HOLDS_LONG(value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tparam = g_value_get_long(value);\n\t}\n\tswitch (param) {\n\tcase 0:\n\t\tvte_sequence_handler_cd (terminal, NULL);\n\t\tbreak;\n\tcase 1:\n\t\t_vte_terminal_clear_above_current (terminal);\n\t\tvte_sequence_handler_cb (terminal, NULL);\n\t\tbreak;\n\tcase 2:\n\t\t_vte_terminal_clear_screen (terminal);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tterminal->pvt->text_deleted_flag = TRUE;\n}", "target": 0}
{"code": "longlong Item_field::val_int_endpoint(bool left_endp, bool *incl_endp)\n{\n  longlong res= val_int();\n  return null_value? LONGLONG_MIN : res;\n}", "target": 0}
{"code": "GF_Err gf_isom_last_error(GF_ISOFile *the_file)\n{\n\tif (!the_file) return MP4_API_IO_Err;\n\treturn the_file->LastError;\n}", "target": 0}
{"code": "Qt::DropActions ServerView::supportedDropActions() const {\n\treturn Qt::CopyAction | Qt::LinkAction;\n}", "target": 0}
{"code": "static void record_and_restart(struct perf_event *event, unsigned long val,\n\t\t\t       struct pt_regs *regs, int nmi)\n{\n\tu64 period = event->hw.sample_period;\n\ts64 prev, delta, left;\n\tint record = 0;\n\tif (event->hw.state & PERF_HES_STOPPED) {\n\t\twrite_pmc(event->hw.idx, 0);\n\t\treturn;\n\t}\n\tprev = local64_read(&event->hw.prev_count);\n\tdelta = (val - prev) & 0xfffffffful;\n\tlocal64_add(delta, &event->count);\n\tval = 0;\n\tleft = local64_read(&event->hw.period_left) - delta;\n\tif (period) {\n\t\tif (left <= 0) {\n\t\t\tleft += period;\n\t\t\tif (left <= 0)\n\t\t\t\tleft = period;\n\t\t\trecord = 1;\n\t\t\tevent->hw.last_period = event->hw.sample_period;\n\t\t}\n\t\tif (left < 0x80000000LL)\n\t\t\tval = 0x80000000LL - left;\n\t}\n\twrite_pmc(event->hw.idx, val);\n\tlocal64_set(&event->hw.prev_count, val);\n\tlocal64_set(&event->hw.period_left, left);\n\tperf_event_update_userpage(event);\n\tif (record) {\n\t\tstruct perf_sample_data data;\n\t\tperf_sample_data_init(&data, ~0ULL);\n\t\tdata.period = event->hw.last_period;\n\t\tif (event->attr.sample_type & PERF_SAMPLE_ADDR)\n\t\t\tperf_get_data_addr(regs, &data.addr);\n\t\tif (perf_event_overflow(event, nmi, &data, regs))\n\t\t\tpower_pmu_stop(event, 0);\n\t}\n}", "target": 0}
{"code": "gimp_channel_new_from_alpha (GimpImage     *image,\n                             GimpDrawable  *drawable,\n                             const gchar   *name,\n                             const GimpRGB *color)\n{\n  GimpChannel *channel;\n  GeglBuffer  *dest_buffer;\n  gint         width;\n  gint         height;\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n  g_return_val_if_fail (GIMP_IS_DRAWABLE (drawable), NULL);\n  g_return_val_if_fail (gimp_drawable_has_alpha (drawable), NULL);\n  width  = gimp_item_get_width  (GIMP_ITEM (drawable));\n  height = gimp_item_get_height (GIMP_ITEM (drawable));\n  channel = gimp_channel_new (image, width, height, name, color);\n  gimp_channel_clear (channel, NULL, FALSE);\n  dest_buffer = gimp_drawable_get_buffer (GIMP_DRAWABLE (channel));\n  gegl_buffer_set_format (dest_buffer,\n                          gimp_drawable_get_component_format (drawable,\n                                                              GIMP_CHANNEL_ALPHA));\n  gimp_gegl_buffer_copy (gimp_drawable_get_buffer (drawable), NULL,\n                         GEGL_ABYSS_NONE,\n                         dest_buffer, NULL);\n  gegl_buffer_set_format (dest_buffer, NULL);\n  return channel;\n}", "target": 0}
{"code": "rdp_out_bmpcache_caps(STREAM s)\n{\n\tint Bpp;\n\tout_uint16_le(s, RDP_CAPSET_BMPCACHE);\n\tout_uint16_le(s, RDP_CAPLEN_BMPCACHE);\n\tBpp = (g_server_depth + 7) / 8;\t\n\tout_uint8s(s, 24);\t\n\tout_uint16_le(s, 0x258);\t\n\tout_uint16_le(s, 0x100 * Bpp);\t\n\tout_uint16_le(s, 0x12c);\t\n\tout_uint16_le(s, 0x400 * Bpp);\t\n\tout_uint16_le(s, 0x106);\t\n\tout_uint16_le(s, 0x1000 * Bpp);\t\n}", "target": 0}
{"code": "static int hash_accept_parent(void *private, struct sock *sk)\n{\n\tstruct hash_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);\n\tunsigned ds = crypto_ahash_digestsize(private);\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);\n\tif (!ctx->result) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ctx->result, 0, ds);\n\tctx->len = len;\n\tctx->more = 0;\n\taf_alg_init_completion(&ctx->completion);\n\task->private = ctx;\n\tahash_request_set_tfm(&ctx->req, private);\n\tahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t   af_alg_complete, &ctx->completion);\n\tsk->sk_destruct = hash_sock_destruct;\n\treturn 0;\n}", "target": 0}
{"code": "static void vhost_net_stop(struct vhost_net *n, struct socket **tx_sock,\n\t\t\t   struct socket **rx_sock)\n{\n\t*tx_sock = vhost_net_stop_vq(n, n->vqs + VHOST_NET_VQ_TX);\n\t*rx_sock = vhost_net_stop_vq(n, n->vqs + VHOST_NET_VQ_RX);\n}", "target": 0}
{"code": "nfsd4_allocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_fallocate *fallocate)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, fallocate, 0);\n}", "target": 0}
{"code": "int ipmi_set_gets_events(struct ipmi_user *user, bool val)\n{\n\tunsigned long        flags;\n\tstruct ipmi_smi      *intf = user->intf;\n\tstruct ipmi_recv_msg *msg, *msg2;\n\tstruct list_head     msgs;\n\tint index;\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\tINIT_LIST_HEAD(&msgs);\n\tspin_lock_irqsave(&intf->events_lock, flags);\n\tif (user->gets_events == val)\n\t\tgoto out;\n\tuser->gets_events = val;\n\tif (val) {\n\t\tif (atomic_inc_return(&intf->event_waiters) == 1)\n\t\t\tneed_waiter(intf);\n\t} else {\n\t\tatomic_dec(&intf->event_waiters);\n\t}\n\tif (intf->delivering_events)\n\t\tgoto out;\n\twhile (user->gets_events && !list_empty(&intf->waiting_events)) {\n\t\tlist_for_each_entry_safe(msg, msg2, &intf->waiting_events, link)\n\t\t\tlist_move_tail(&msg->link, &msgs);\n\t\tintf->waiting_events_count = 0;\n\t\tif (intf->event_msg_printed) {\n\t\t\tdev_warn(intf->si_dev, \"Event queue no longer full\\n\");\n\t\t\tintf->event_msg_printed = 0;\n\t\t}\n\t\tintf->delivering_events = 1;\n\t\tspin_unlock_irqrestore(&intf->events_lock, flags);\n\t\tlist_for_each_entry_safe(msg, msg2, &msgs, link) {\n\t\t\tmsg->user = user;\n\t\t\tkref_get(&user->refcount);\n\t\t\tdeliver_local_response(intf, msg);\n\t\t}\n\t\tspin_lock_irqsave(&intf->events_lock, flags);\n\t\tintf->delivering_events = 0;\n\t}\n out:\n\tspin_unlock_irqrestore(&intf->events_lock, flags);\n\trelease_ipmi_user(user, index);\n\treturn 0;\n}", "target": 0}
{"code": "    const char* ExifThumbC::mimeType() const\n    {\n        Thumbnail::UniquePtr thumbnail = Thumbnail::create(exifData_);\n        if (thumbnail.get() == 0) return \"\";\n        return thumbnail->mimeType();\n    }", "target": 0}
{"code": "yang_free_inout(struct ly_ctx *ctx, struct lys_node_inout *inout)\n{\n    uint8_t i;\n    yang_tpdf_free(ctx, inout->tpdf, 0, inout->tpdf_size);\n    free(inout->tpdf);\n    for (i = 0; i < inout->must_size; ++i) {\n        lys_restr_free(ctx, &inout->must[i], NULL);\n    }\n    free(inout->must);\n}", "target": 0}
{"code": "    std::string Iptcdatum::key() const\n    {\n        return key_.get() == 0 ? \"\" : key_->key();\n    }", "target": 0}
{"code": "  static void DataPlanUpdateHandler(void* object,\n                                    const char* modem_service_path,\n                                    const CellularDataPlanList* dataplan) {\n    NetworkLibraryImpl* networklib = static_cast<NetworkLibraryImpl*>(object);\n    if (!networklib || !networklib->cellular_network()) {\n      return;\n    }\n    if (networklib->cellular_network()->service_path()\n        .compare(modem_service_path) == 0) {\n      if (dataplan != NULL) {\n        networklib->UpdateCellularDataPlan(dataplan);\n      }\n    }\n  }", "target": 0}
{"code": "FunctionLibraryDefinition::FindHelper(const string& func) const {\n  auto iter = function_defs_.find(func);\n  if (iter == function_defs_.end()) {\n    return nullptr;\n  } else {\n    return iter->second;\n  }\n}", "target": 0}
{"code": "check_breakpoint(struct readbuffer *obuf, int pre_mode, char *ch)\n{\n    int tlen, len = obuf->line->length;\n    append_tags(obuf);\n    if (pre_mode)\n\treturn;\n    tlen = obuf->line->length - len;\n    if (tlen > 0\n\t|| is_boundary((unsigned char *)obuf->prevchar->ptr,\n\t\t       (unsigned char *)ch))\n\tset_breakpoint(obuf, tlen);\n}", "target": 0}
{"code": "rb_decrement_entry(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t   struct ring_buffer_event *event)\n{\n\tunsigned long addr = (unsigned long)event;\n\tstruct buffer_page *bpage = cpu_buffer->commit_page;\n\tstruct buffer_page *start;\n\taddr &= PAGE_MASK;\n\tif (likely(bpage->page == (void *)addr)) {\n\t\tlocal_dec(&bpage->entries);\n\t\treturn;\n\t}\n\trb_inc_page(cpu_buffer, &bpage);\n\tstart = bpage;\n\tdo {\n\t\tif (bpage->page == (void *)addr) {\n\t\t\tlocal_dec(&bpage->entries);\n\t\t\treturn;\n\t\t}\n\t\trb_inc_page(cpu_buffer, &bpage);\n\t} while (bpage != start);\n\tRB_WARN_ON(cpu_buffer, 1);\n}", "target": 0}
{"code": "static int pptp_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pppox_sock *po;\n\tstruct pptp_opt *opt;\n\tint error = 0;\n\tif (!sk)\n\t\treturn 0;\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_DEAD)) {\n\t\trelease_sock(sk);\n\t\treturn -EBADF;\n\t}\n\tpo = pppox_sk(sk);\n\topt = &po->proto.pptp;\n\tdel_chan(po);\n\tpppox_unbind_sock(sk);\n\tsk->sk_state = PPPOX_DEAD;\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn error;\n}", "target": 0}
{"code": "void __init __weak efi_arch_mem_reserve(phys_addr_t addr, u64 size) {}", "target": 0}
{"code": "void HTMLInputElement::setRangeText(const String& replacement, ExceptionState& exceptionState)\n{\n    if (!m_inputType->supportsSelectionAPI()) {\n        exceptionState.throwDOMException(InvalidStateError, \"The input element's type ('\" + m_inputType->formControlType() + \"') does not support selection.\");\n        return;\n    }\n    HTMLTextFormControlElement::setRangeText(replacement, exceptionState);\n}", "target": 0}
{"code": "const char *STDCALL mysql_sqlstate(MYSQL *mysql)\n{\n  return mysql ? mysql->net.sqlstate : cant_connect_sqlstate;\n}", "target": 0}
{"code": "void Splash::scaleMaskYdXd(SplashImageMaskSource src, void *srcData,\n\t\t\t   int srcWidth, int srcHeight,\n\t\t\t   int scaledWidth, int scaledHeight,\n\t\t\t   SplashBitmap *dest) {\n  Guchar *lineBuf;\n  Guint *pixBuf;\n  Guint pix;\n  Guchar *destPtr;\n  int yp, yq, xp, xq, yt, y, yStep, xt, x, xStep, xx, d, d0, d1;\n  int i, j;\n  yp = srcHeight / scaledHeight;\n  yq = srcHeight % scaledHeight;\n  xp = srcWidth / scaledWidth;\n  xq = srcWidth % scaledWidth;\n  lineBuf = (Guchar *)gmalloc(srcWidth);\n  pixBuf = (Guint *)gmallocn(srcWidth, sizeof(int));\n  yt = 0;\n  destPtr = dest->data;\n  for (y = 0; y < scaledHeight; ++y) {\n    if ((yt += yq) >= scaledHeight) {\n      yt -= scaledHeight;\n      yStep = yp + 1;\n    } else {\n      yStep = yp;\n    }\n    memset(pixBuf, 0, srcWidth * sizeof(int));\n    for (i = 0; i < yStep; ++i) {\n      (*src)(srcData, lineBuf);\n      for (j = 0; j < srcWidth; ++j) {\n\tpixBuf[j] += lineBuf[j];\n      }\n    }\n    xt = 0;\n    d0 = (255 << 23) / (yStep * xp);\n    d1 = (255 << 23) / (yStep * (xp + 1));\n    xx = 0;\n    for (x = 0; x < scaledWidth; ++x) {\n      if ((xt += xq) >= scaledWidth) {\n\txt -= scaledWidth;\n\txStep = xp + 1;\n\td = d1;\n      } else {\n\txStep = xp;\n\td = d0;\n      }\n      pix = 0;\n      for (i = 0; i < xStep; ++i) {\n\tpix += pixBuf[xx++];\n      }\n      pix = (pix * d) >> 23;\n      *destPtr++ = (Guchar)pix;\n    }\n  }\n  gfree(pixBuf);\n  gfree(lineBuf);\n}", "target": 0}
{"code": "_iasecc_sm_update_binary(struct sc_card *card, unsigned int offs,\n\t\tconst unsigned char *buff, size_t count)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tconst struct sc_acl_entry *entry = NULL;\n\tint rv;\n\tif (count == 0)\n\t\treturn SC_SUCCESS;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_sm_read_binary() card:%p offs:%i count:%\"SC_FORMAT_LEN_SIZE_T\"u \",\n\t       card, offs, count);\n\tsc_print_cache(card);\n\tif (card->cache.valid && card->cache.current_ef)   {\n\t\tentry = sc_file_get_acl_entry(card->cache.current_ef, SC_AC_OP_UPDATE);\n\t\tif (!entry)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"iasecc_sm_update() 'UPDATE' ACL not present\");\n\t\tsc_log(ctx, \"UPDATE method/reference %X/%X\", entry->method, entry->key_ref);\n\t\tif (entry->method == SC_AC_SCB && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n\t\t\tunsigned char se_num = entry->method == SC_AC_SCB ? entry->key_ref & IASECC_SCB_METHOD_MASK_REF : 0;\n\t\t\trv = iasecc_sm_update_binary(card, se_num, offs, buff, count);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\t}\n\tLOG_FUNC_RETURN(ctx, 0);\n}", "target": 0}
{"code": "XML_SetStartNamespaceDeclHandler(XML_Parser parser,\n                                 XML_StartNamespaceDeclHandler start) {\n  if (parser != NULL)\n    parser->m_startNamespaceDeclHandler = start;\n}", "target": 0}
{"code": "ospf_make_hello (struct ospf_interface *oi, struct stream *s)\n{\n  struct ospf_neighbor *nbr;\n  struct route_node *rn;\n  u_int16_t length = OSPF_HELLO_MIN_SIZE;\n  struct in_addr mask;\n  unsigned long p;\n  int flag = 0;\n  if (oi->type != OSPF_IFTYPE_POINTOPOINT &&\n      oi->type != OSPF_IFTYPE_VIRTUALLINK)\n    masklen2ip (oi->address->prefixlen, &mask);\n  else\n    memset ((char *) &mask, 0, sizeof (struct in_addr));\n  stream_put_ipv4 (s, mask.s_addr);\n  if (OSPF_IF_PARAM (oi, fast_hello) == 0)\n    stream_putw (s, OSPF_IF_PARAM (oi, v_hello));\n  else\n    stream_putw (s, 0); \n  if (IS_DEBUG_OSPF_EVENT)\n    zlog_debug (\"make_hello: options: %x, int: %s\",\n\t       OPTIONS(oi), IF_NAME (oi));\n  stream_putc (s, OPTIONS (oi));\n  stream_putc (s, PRIORITY (oi));\n  stream_putl (s, OSPF_IF_PARAM (oi, v_wait));\n  stream_put_ipv4 (s, DR (oi).s_addr);\n  p = stream_get_endp (s);\n  stream_put_ipv4 (s, BDR (oi).s_addr);\n  for (rn = route_top (oi->nbrs); rn; rn = route_next (rn))\n    if ((nbr = rn->info))\n      if (nbr->router_id.s_addr != 0)\t\n\tif (nbr->state != NSM_Attempt)  \n\tif (nbr->state != NSM_Down)     \n\t  if (!IPV4_ADDR_SAME (&nbr->router_id, &oi->ospf->router_id))\n\t    {\n\t      if (nbr->d_router.s_addr != 0\n\t\t  && IPV4_ADDR_SAME (&nbr->d_router, &oi->address->u.prefix4)\n\t\t  && IPV4_ADDR_SAME (&nbr->bd_router, &oi->address->u.prefix4))\n\t\tflag = 1;\n\t      stream_put_ipv4 (s, nbr->router_id.s_addr);\n\t      length += 4;\n\t    }\n  if (flag == 1)\n    stream_putl_at (s, p, 0); \n  return length;\n}", "target": 0}
{"code": "xfs_droplink(\n\txfs_trans_t *tp,\n\txfs_inode_t *ip)\n{\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\tdrop_nlink(VFS_I(ip));\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tif (VFS_I(ip)->i_nlink)\n\t\treturn 0;\n\treturn xfs_iunlink(tp, ip);\n}", "target": 0}
{"code": "gimp_channel_get_tree (GimpItem *item)\n{\n  if (gimp_item_is_attached (item))\n    {\n      GimpImage *image = gimp_item_get_image (item);\n      return gimp_image_get_channel_tree (image);\n    }\n  return NULL;\n}", "target": 0}
{"code": "void ContentSettingsStore::UnregisterExtension(\n    const std::string& ext_id) {\n  bool notify = false;\n  bool notify_incognito = false;\n  {\n    base::AutoLock lock(lock_);\n    ExtensionEntryMap::iterator i = FindEntry(ext_id);\n    if (i == entries_.end())\n      return;\n    notify = !i->second->settings.empty();\n    notify_incognito = !i->second->incognito_persistent_settings.empty() ||\n                       !i->second->incognito_session_only_settings.empty();\n    delete i->second;\n    entries_.erase(i);\n  }\n  if (notify)\n    NotifyOfContentSettingChanged(ext_id, false);\n  if (notify_incognito)\n    NotifyOfContentSettingChanged(ext_id, true);\n}", "target": 0}
{"code": "static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\tev->type   = LLC_SAP_EV_TYPE_PDU;\n\tev->reason = 0;\n\tskb_orphan(skb);\n\tsock_hold(sk);\n\tskb->sk = sk;\n\tskb->destructor = sock_efree;\n\tllc_sap_state_process(sap, skb);\n}", "target": 0}
{"code": "sstring to_string(const event::topology_change::change_type t) {\n    using type = event::topology_change::change_type;\n    switch (t) {\n    case type::NEW_NODE:     return \"NEW_NODE\";\n    case type::REMOVED_NODE: return \"REMOVED_NODE\";\n    case type::MOVED_NODE:   return \"MOVED_NODE\";\n    }\n    throw std::invalid_argument(\"unknown change type\");\n}", "target": 0}
{"code": "void ParamTraits<unsigned int>::Log(const param_type& p, std::string* l) {\n  l->append(base::UintToString(p));\n}", "target": 0}
{"code": "static int trimDynamic(dynamicPtr *dp)\n{\n\tif(!dp->freeOK) {\n\t\treturn TRUE;\n\t}\n\treturn gdReallocDynamic(dp, dp->logicalSize);\n}", "target": 0}
{"code": "Item_equal *Item_direct_view_ref::find_item_equal(COND_EQUAL *cond_equal)\n{\n  Item* field_item= real_item();\n  if (field_item->type() != FIELD_ITEM)\n    return NULL;\n  return ((Item_field *) field_item)->find_item_equal(cond_equal);  \n}", "target": 0}
{"code": "xfs_dinode_verify_fork(\n\tstruct xfs_dinode\t*dip,\n\tstruct xfs_mount\t*mp,\n\tint\t\t\twhichfork)\n{\n\tuint32_t\t\tdi_nextents = XFS_DFORK_NEXTENTS(dip, whichfork);\n\tswitch (XFS_DFORK_FORMAT(dip, whichfork)) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif (whichfork == XFS_DATA_FORK) {\n\t\t\tif (S_ISREG(be16_to_cpu(dip->di_mode)))\n\t\t\t\treturn __this_address;\n\t\t\tif (be64_to_cpu(dip->di_size) >\n\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork))\n\t\t\t\treturn __this_address;\n\t\t}\n\t\tif (di_nextents)\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif (di_nextents > XFS_DFORK_MAXEXT(dip, mp, whichfork))\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif (whichfork == XFS_ATTR_FORK) {\n\t\t\tif (di_nextents > MAXAEXTNUM)\n\t\t\t\treturn __this_address;\n\t\t} else if (di_nextents > MAXEXTNUM) {\n\t\t\treturn __this_address;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn __this_address;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static void reds_migrate_channels_seamless(RedsState *reds)\n{\n    RedClient *client;\n    client = reds_get_client(reds);\n    client->migrate();\n}", "target": 0}
{"code": "cdf_swap_header(cdf_header_t *h)\n{\n\tsize_t i;\n\th->h_magic = CDF_TOLE8(h->h_magic);\n\th->h_uuid[0] = CDF_TOLE8(h->h_uuid[0]);\n\th->h_uuid[1] = CDF_TOLE8(h->h_uuid[1]);\n\th->h_revision = CDF_TOLE2(h->h_revision);\n\th->h_version = CDF_TOLE2(h->h_version);\n\th->h_byte_order = CDF_TOLE2(h->h_byte_order);\n\th->h_sec_size_p2 = CDF_TOLE2(h->h_sec_size_p2);\n\th->h_short_sec_size_p2 = CDF_TOLE2(h->h_short_sec_size_p2);\n\th->h_num_sectors_in_sat = CDF_TOLE4(h->h_num_sectors_in_sat);\n\th->h_secid_first_directory = CDF_TOLE4(h->h_secid_first_directory);\n\th->h_min_size_standard_stream =\n\t    CDF_TOLE4(h->h_min_size_standard_stream);\n\th->h_secid_first_sector_in_short_sat =\n\t    CDF_TOLE4((uint32_t)h->h_secid_first_sector_in_short_sat);\n\th->h_num_sectors_in_short_sat =\n\t    CDF_TOLE4(h->h_num_sectors_in_short_sat);\n\th->h_secid_first_sector_in_master_sat =\n\t    CDF_TOLE4((uint32_t)h->h_secid_first_sector_in_master_sat);\n\th->h_num_sectors_in_master_sat =\n\t    CDF_TOLE4(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\th->h_master_sat[i] = CDF_TOLE4((uint32_t)h->h_master_sat[i]);\n}", "target": 0}
{"code": "static int ssl_security_cert_sig(SSL *s, SSL_CTX *ctx, X509 *x, int op)\n\t{\n\tint secbits = -1, md_nid = NID_undef, sig_nid;\n\tsig_nid = X509_get_signature_nid(x);\n\tif (sig_nid && OBJ_find_sigid_algs(sig_nid, &md_nid, NULL))\n\t\t{\n\t\tconst EVP_MD *md;\n\t\tif (md_nid && (md = EVP_get_digestbynid(md_nid)))\n\t\t\t\tsecbits = EVP_MD_size(md) * 4;\n\t\t}\n\tif (s)\n\t\treturn ssl_security(s, op, secbits, md_nid, x);\n\telse\n\t\treturn ssl_ctx_security(ctx, op, secbits, md_nid, x);\n\t}", "target": 0}
{"code": "static int snd_ctl_dev_register(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tint err, cardnum;\n\tchar name[16];\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tcardnum = card->number;\n\tif (snd_BUG_ON(cardnum < 0 || cardnum >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\tsprintf(name, \"controlC%i\", cardnum);\n\tif ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, -1,\n\t\t\t\t       &snd_ctl_f_ops, card, name)) < 0)\n\t\treturn err;\n\treturn 0;\n}", "target": 0}
{"code": "void PrintWebViewHelper::OnPrintPreview(const DictionaryValue& settings) {\n  DCHECK(is_preview_enabled_);\n  print_preview_context_.OnPrintPreview();\n  if (!UpdatePrintSettings(print_preview_context_.frame(),\n                           print_preview_context_.node(), settings, false)) {\n    if (print_preview_context_.last_error() != PREVIEW_ERROR_BAD_SETTING) {\n      Send(new PrintHostMsg_PrintPreviewInvalidPrinterSettings(\n          routing_id(), print_pages_params_->params.document_cookie));\n      notify_browser_of_print_failure_ = false;  \n    }\n    DidFinishPrinting(FAIL_PREVIEW);\n    return;\n  }\n  if (!print_pages_params_->params.is_first_request &&\n      old_print_pages_params_.get() &&\n      PrintMsg_Print_Params_IsEqual(*old_print_pages_params_,\n                                    *print_pages_params_)) {\n    PrintHostMsg_DidPreviewDocument_Params preview_params;\n    preview_params.reuse_existing_data = true;\n    preview_params.data_size = 0;\n    preview_params.document_cookie =\n        print_pages_params_->params.document_cookie;\n    preview_params.expected_pages_count =\n        print_preview_context_.total_page_count();\n    preview_params.modifiable = print_preview_context_.IsModifiable();\n    preview_params.preview_request_id =\n        print_pages_params_->params.preview_request_id;\n    Send(new PrintHostMsg_MetafileReadyForPrinting(routing_id(),\n                                                   preview_params));\n    return;\n  }\n  old_print_pages_params_.reset();\n  is_print_ready_metafile_sent_ = false;\n  print_pages_params_->params.supports_alpha_blend = true;\n  bool generate_draft_pages = false;\n  if (!settings.GetBoolean(printing::kSettingGenerateDraftData,\n                           &generate_draft_pages)) {\n    NOTREACHED();\n  }\n  print_preview_context_.set_generate_draft_pages(generate_draft_pages);\n  if (CreatePreviewDocument()) {\n    DidFinishPrinting(OK);\n  } else {\n    if (notify_browser_of_print_failure_)\n      LOG(ERROR) << \"CreatePreviewDocument failed\";\n    DidFinishPrinting(FAIL_PREVIEW);\n  }\n}", "target": 0}
{"code": "void address_space_stq_be(AddressSpace *as, hwaddr addr, uint64_t val,\n                       MemTxAttrs attrs, MemTxResult *result)\n{\n    MemTxResult r;\n    val = cpu_to_be64(val);\n    r = address_space_rw(as, addr, attrs, (void *) &val, 8, 1);\n    if (result) {\n        *result = r;\n    }\n}", "target": 0}
{"code": "static void _php_curl_close(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tphp_curl *ch = (php_curl *) rsrc->ptr;\n\t_php_curl_close_ex(ch TSRMLS_CC);\n}", "target": 0}
{"code": "bool WebContentsImpl::FocusLocationBarByDefault() {\n  NavigationEntry* entry = controller_.GetActiveEntry();\n  if (entry && entry->GetURL() == GURL(kAboutBlankURL))\n    return true;\n  return delegate_ && delegate_->ShouldFocusLocationBarByDefault(this);\n}", "target": 0}
{"code": "static int mov_write_vpcc_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"vpcC\");\n    avio_wb32(pb, 0); \n    ff_isom_write_vpcc(s, pb, track->par);\n    return update_size(pb, pos);\n}", "target": 0}
{"code": "filesystem_create_wait_for_luks_device_not_seen_cb (gpointer user_data)\n{\n  MkfsLuksData *data = user_data;\n  throw_error (data->context,\n               ERROR_FAILED,\n               \"Error creating luks encrypted file system: timeout (10s) waiting for luks device to show up\");\n  g_signal_handler_disconnect (data->device->priv->daemon, data->device_changed_signal_handler_id);\n  mkfse_data_unref (data);\n  return FALSE;\n}", "target": 0}
{"code": "void ScrollAnchor::SetScroller(ScrollableArea* scroller) {\n  DCHECK_NE(scroller_, scroller);\n  DCHECK(scroller);\n  DCHECK(scroller->IsRootFrameViewport() ||\n         scroller->IsPaintLayerScrollableArea());\n  scroller_ = scroller;\n  ClearSelf();\n}", "target": 0}
{"code": "static void reset_intr(void)\n{\n\tpr_info(\"weird, reset interrupt called\\n\");\n}", "target": 0}
{"code": "callbacks_add_layer_button_clicked (GtkButton *button, gpointer user_data)\n{\n\tcallbacks_open_activate (NULL, NULL);\n}", "target": 0}
{"code": "  static float libraw_powf64l(float a, float b) { return powf_lim(a, b, 64.f); }", "target": 0}
{"code": "    SorterComparator(ValueComparator valueComparator) : _valueComparator(valueComparator) {}", "target": 0}
{"code": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, NOBH))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "static void reds_handle_new_link(RedLinkInfo *link)\n{\n    red_stream_set_async_error_handler(link->stream, reds_handle_link_error);\n    red_stream_async_read(link->stream,\n                          (uint8_t *)&link->link_header,\n                          sizeof(link->link_header.magic),\n                          reds_handle_read_magic_done,\n                          link);\n}", "target": 0}
{"code": "xfs_bmap_first_unused(\n\tstruct xfs_trans\t*tp,\t\t\n\tstruct xfs_inode\t*ip,\t\t\n\txfs_extlen_t\t\tlen,\t\t\n\txfs_fileoff_t\t\t*first_unused,\t\n\tint\t\t\twhichfork)\t\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_iext_cursor\ticur;\n\txfs_fileoff_t\t\tlastaddr = 0;\n\txfs_fileoff_t\t\tlowest, max;\n\tint\t\t\terror;\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*first_unused = 0;\n\t\treturn 0;\n\t}\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tlowest = max = *first_unused;\n\tfor_each_xfs_iext(ifp, &icur, &got) {\n\t\tif (got.br_startoff >= lowest + len &&\n\t\t    got.br_startoff - max >= len)\n\t\t\tbreak;\n\t\tlastaddr = got.br_startoff + got.br_blockcount;\n\t\tmax = XFS_FILEOFF_MAX(lastaddr, lowest);\n\t}\n\t*first_unused = max;\n\treturn 0;\n}", "target": 0}
{"code": "void set_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 1;\n\tsmp_mb(); \n\tif (!sched_clock_running)\n\t\treturn;\n\t__set_sched_clock_stable();\n}", "target": 0}
{"code": "static void read_dir(GDataInputStream* f, MenuCacheDir* dir, MenuCache* cache,\n                     MenuCacheFileDir** all_used_files, int n_all_used_files)\n{\n    MenuCacheItem* item;\n    char *line;\n    gsize len;\n    if (cache->version >= 2)\n    {\n        line = g_data_input_stream_read_line(f, &len, cache->cancellable, NULL);\n        if (G_UNLIKELY(line == NULL))\n            return;\n        dir->flags = (guint32)atoi(line);\n        g_free(line);\n    }\n    while( (item = read_item( f, cache, all_used_files, n_all_used_files )) )\n    {\n        item->parent = dir;\n        dir->children = g_slist_prepend( dir->children, item );\n    }\n    dir->children = g_slist_reverse( dir->children );\n    if (cache->version == 1)\n    {\n        if (dir->children == NULL)\n            dir->flags = FLAG_IS_NODISPLAY;\n        else if ((line = menu_cache_item_get_file_path(MENU_CACHE_ITEM(dir))) != NULL)\n        {\n            GKeyFile *kf = g_key_file_new();\n            if (g_key_file_load_from_file(kf, line, G_KEY_FILE_NONE, NULL) &&\n                g_key_file_get_boolean(kf, G_KEY_FILE_DESKTOP_GROUP,\n                                       G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY, NULL))\n                dir->flags = FLAG_IS_NODISPLAY;\n            g_key_file_free(kf);\n            g_free(line);\n        }\n    }\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ThreeRegexSameFieldCovering) {\n    addIndex(BSON(\"a\" << 1));\n    runQuerySortProj(\n        fromjson(\"{$and: [{a: /0/}, {a: /1/}, {a: /2/}]}\"), BSONObj(), fromjson(\"{_id: 0, a: 1}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{cscan: {dir: 1, filter: {$and:[{a:/0/},{a:/1/},{a:/2/}]}}}}}\");\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{ixscan: {filter: {$and:[{a:/0/},{a:/1/},{a:/2/}]}, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "static int firm_report_tx_done(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple close_command;\n\tclose_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,\n\t\t\t(__u8 *)&close_command, sizeof(close_command));\n}", "target": 0}
{"code": "void Item::init_make_field(Send_field *tmp_field,\n\t\t\t   enum enum_field_types field_type_arg)\n{\n  char *empty_name= (char*) \"\";\n  tmp_field->db_name=\t\tempty_name;\n  tmp_field->org_table_name=\tempty_name;\n  tmp_field->org_col_name=\tempty_name;\n  tmp_field->table_name=\tempty_name;\n  tmp_field->col_name=\t\tname;\n  tmp_field->charsetnr=         collation.collation->number;\n  tmp_field->flags=             (maybe_null ? 0 : NOT_NULL_FLAG) | \n                                (my_binary_compare(charset_for_protocol()) ?\n                                 BINARY_FLAG : 0);\n  tmp_field->type=              field_type_arg;\n  tmp_field->length=max_length;\n  tmp_field->decimals=decimals;\n  if (unsigned_flag)\n    tmp_field->flags |= UNSIGNED_FLAG;\n}", "target": 0}
{"code": "static int nfs4_xdr_dec_close(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      struct nfs_closeres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_close(xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server);\nout:\n\treturn status;\n}", "target": 0}
{"code": "  bool safely_trapped_errors()\n  {\n    return (m_handled_errors && (! m_unhandled_errors));\n  }", "target": 0}
{"code": "cmsToneCurve* ExtractGray2Y(cmsContext ContextID, cmsHPROFILE hProfile, cmsUInt32Number Intent)\n{\n    cmsToneCurve* Out = cmsBuildTabulatedToneCurve16(ContextID, 256, NULL);\n    cmsHPROFILE hXYZ  = cmsCreateXYZProfile();\n    cmsHTRANSFORM xform = cmsCreateTransformTHR(ContextID, hProfile, TYPE_GRAY_8, hXYZ, TYPE_XYZ_DBL, Intent, cmsFLAGS_NOOPTIMIZE);\n    int i;\n    if (Out != NULL && xform != NULL) {\n        for (i=0; i < 256; i++) {\n            cmsUInt8Number Gray = (cmsUInt8Number) i;\n            cmsCIEXYZ XYZ;\n            cmsDoTransform(xform, &Gray, &XYZ, 1);\n            Out ->Table16[i] =_cmsQuickSaturateWord(XYZ.Y * 65535.0);\n        }\n    }\n    if (xform) cmsDeleteTransform(xform);\n    if (hXYZ) cmsCloseProfile(hXYZ);\n    return Out;\n}", "target": 0}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       struct iovec *iovec)\n{\n\tsize_t len = kiocb->ki_nbytes;\n\tif (len > MAX_RW_COUNT)\n\t\tlen = MAX_RW_COUNT;\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\treturn 0;\n}", "target": 0}
{"code": "static void ssl_build_record_nonce( unsigned char *dst_iv,\n                                    size_t dst_iv_len,\n                                    unsigned char const *fixed_iv,\n                                    size_t fixed_iv_len,\n                                    unsigned char const *dynamic_iv,\n                                    size_t dynamic_iv_len )\n{\n    size_t i;\n    memset( dst_iv, 0, dst_iv_len );\n    memcpy( dst_iv, fixed_iv, fixed_iv_len );\n    dst_iv += dst_iv_len - dynamic_iv_len;\n    for( i = 0; i < dynamic_iv_len; i++ )\n        dst_iv[i] ^= dynamic_iv[i];\n}", "target": 0}
{"code": "void ewk_view_frame_main_cleared(Evas_Object* ewkView)\n{\n    DBG(\"ewkView=%p\", ewkView);\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api->flush);\n    smartData->api->flush(smartData);\n    ewk_view_mixed_content_displayed_set(ewkView, false);\n    ewk_view_mixed_content_run_set(ewkView, false);\n}", "target": 0}
{"code": "static Image *DrawClippingMask(Image *image,const DrawInfo *draw_info,\n  const char *id,const char *clip_path,ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n  Image\n    *clip_mask;\n  MagickStatusType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  clip_mask=AcquireImage((const ImageInfo *) NULL);\n  status=SetImageExtent(clip_mask,image->columns,image->rows);\n  if (status == MagickFalse)\n    return(DestroyImage(clip_mask));\n  status=SetImageClipMask(image,(Image *) NULL);\n  status=QueryColorCompliance(\"#0000\",AllCompliance,\n    &clip_mask->background_color,exception);\n  clip_mask->background_color.opacity=(Quantum) TransparentOpacity;\n  status=SetImageBackgroundColor(clip_mask);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin clip-path %s\",\n      id);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,clip_path);\n  status=QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  if (clone_info->clip_mask != (char *) NULL)\n    clone_info->clip_mask=DestroyString(clone_info->clip_mask);\n  (void) QueryColorCompliance(\"#00000000\",AllCompliance,&clone_info->stroke,\n    exception);\n  clone_info->stroke_width=0.0;\n  clone_info->opacity=OpaqueOpacity;\n  clone_info->clip_path=MagickTrue;\n  status=RenderMVGContent(clip_mask,clone_info,0);\n  clone_info=DestroyDrawInfo(clone_info);\n  status&=SeparateImageChannel(clip_mask,TrueAlphaChannel);\n  if (draw_info->compliance != SVGCompliance)\n    status&=NegateImage(clip_mask,MagickFalse);\n  if (status == MagickFalse)\n    clip_mask=DestroyImage(clip_mask);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end clip-path\");\n  return(clip_mask);\n}", "target": 0}
{"code": "  size_t remove(const LowerCaseString& key) override {\n    size_t headers_removed = header_map_->remove(key);\n    header_map_->verifyByteSizeInternalForTest();\n    return headers_removed;\n  }", "target": 0}
{"code": "static int tree_key_search(\n\tsize_t *at_pos, git_vector *entries, const char *filename, size_t filename_len)\n{\n\tstruct tree_key_search ksearch;\n\tconst git_tree_entry *entry;\n\tsize_t homing, i;\n\tksearch.filename = filename;\n\tksearch.filename_len = filename_len;\n\tif (git_vector_bsearch2(&homing, entries, &homing_search_cmp, &ksearch) < 0)\n\t\treturn GIT_ENOTFOUND; \n\tfor (i = homing; i < entries->length; ++i) {\n\t\tentry = entries->contents[i];\n\t\tif (homing_search_cmp(&ksearch, entry) < 0)\n\t\t\tbreak;\n\t\tif (entry->filename_len == filename_len &&\n\t\t\tmemcmp(filename, entry->filename, filename_len) == 0) {\n\t\t\tif (at_pos)\n\t\t\t\t*at_pos = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (homing > 0) {\n\t\ti = homing - 1;\n\t\tdo {\n\t\t\tentry = entries->contents[i];\n\t\t\tif (homing_search_cmp(&ksearch, entry) > 0)\n\t\t\t\tbreak;\n\t\t\tif (entry->filename_len == filename_len &&\n\t\t\t\tmemcmp(filename, entry->filename, filename_len) == 0) {\n\t\t\t\tif (at_pos)\n\t\t\t\t\t*at_pos = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} while (i-- > 0);\n\t}\n\treturn GIT_ENOTFOUND;\n}", "target": 0}
{"code": "GF_Err aeib_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeEncryptionInfoBox *ptr = (GF_AdobeEncryptionInfoBox*)s;\n\tu32 len;\n\tlen = (u32) ptr->size - 1;\n\tif (len) {\n\t\tptr->enc_algo = (char *)gf_malloc(len*sizeof(char));\n\t\tif (!ptr->enc_algo) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->enc_algo, len);\n\t}\n\tptr->key_length = gf_bs_read_u8(bs);\n\tptr->size = 0;\n\treturn GF_OK;\n}", "target": 0}
{"code": "void WebContentsImpl::SetEncoding(const std::string& encoding) {\n  encoding_ = GetContentClient()->browser()->\n      GetCanonicalEncodingNameByAliasName(encoding);\n}", "target": 0}
{"code": "static int unix_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tif (protocol && protocol != PF_UNIX)\n\t\treturn -EPROTONOSUPPORT;\n\tsock->state = SS_UNCONNECTED;\n\tswitch (sock->type) {\n\tcase SOCK_STREAM:\n\t\tsock->ops = &unix_stream_ops;\n\t\tbreak;\n\tcase SOCK_RAW:\n\t\tsock->type = SOCK_DGRAM;\n\tcase SOCK_DGRAM:\n\t\tsock->ops = &unix_dgram_ops;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tsock->ops = &unix_seqpacket_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\treturn unix_create1(net, sock, kern) ? 0 : -ENOMEM;\n}", "target": 0}
{"code": "offset_to_sec(VALUE vof, int *rof)\n{\n    int try_rational = 1;\n  again:\n    switch (TYPE(vof)) {\n      case T_FIXNUM:\n\t{\n\t    long n;\n\t    n = FIX2LONG(vof);\n\t    if (n != -1 && n != 0 && n != 1)\n\t\treturn 0;\n\t    *rof = (int)n * DAY_IN_SECONDS;\n\t    return 1;\n\t}\n      case T_FLOAT:\n\t{\n\t    double n;\n\t    n = RFLOAT_VALUE(vof) * DAY_IN_SECONDS;\n\t    if (n < -DAY_IN_SECONDS || n > DAY_IN_SECONDS)\n\t\treturn 0;\n\t    *rof = (int)round(n);\n\t    if (*rof != n)\n\t\trb_warning(\"fraction of offset is ignored\");\n\t    return 1;\n\t}\n      default:\n\texpect_numeric(vof);\n\tvof = f_to_r(vof);\n\tif (!k_rational_p(vof)) {\n\t    if (!try_rational) Check_Type(vof, T_RATIONAL);\n\t    try_rational = 0;\n\t    goto again;\n\t}\n      case T_RATIONAL:\n\t{\n\t    VALUE vs, vn, vd;\n\t    long n;\n\t    vs = day_to_sec(vof);\n\t    if (!k_rational_p(vs)) {\n\t\tvn = vs;\n\t\tgoto rounded;\n\t    }\n\t    vn = rb_rational_num(vs);\n\t    vd = rb_rational_den(vs);\n\t    if (FIXNUM_P(vn) && FIXNUM_P(vd) && (FIX2LONG(vd) == 1))\n\t\tn = FIX2LONG(vn);\n\t    else {\n\t\tvn = f_round(vs);\n\t\tif (!f_eqeq_p(vn, vs))\n\t\t    rb_warning(\"fraction of offset is ignored\");\n\t      rounded:\n\t\tif (!FIXNUM_P(vn))\n\t\t    return 0;\n\t\tn = FIX2LONG(vn);\n\t\tif (n < -DAY_IN_SECONDS || n > DAY_IN_SECONDS)\n\t\t    return 0;\n\t    }\n\t    *rof = (int)n;\n\t    return 1;\n\t}\n      case T_STRING:\n\t{\n\t    VALUE vs = date_zone_to_diff(vof);\n\t    long n;\n\t    if (!FIXNUM_P(vs))\n\t\treturn 0;\n\t    n = FIX2LONG(vs);\n\t    if (n < -DAY_IN_SECONDS || n > DAY_IN_SECONDS)\n\t\treturn 0;\n\t    *rof = (int)n;\n\t    return 1;\n\t}\n    }\n    return 0;\n}", "target": 0}
{"code": "    bool operator()(const GroupsMap::value_type* lhs, const GroupsMap::value_type* rhs) const {\n        return _valueComparator.evaluate(lhs->first < rhs->first);\n    }", "target": 0}
{"code": "u64 nsecs_to_jiffies64(u64 n)\n{\n#if (NSEC_PER_SEC % HZ) == 0\n\treturn div_u64(n, NSEC_PER_SEC / HZ);\n#elif (HZ % 512) == 0\n\treturn div_u64(n * HZ / 512, NSEC_PER_SEC / 512);\n#else\n\treturn div_u64(n * 9, (9ull * NSEC_PER_SEC + HZ / 2) / HZ);\n#endif\n}", "target": 0}
{"code": "decompileEXTENDS(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *baseclass;\n\tbaseclass=pop();\n#if 0\n\tprintf(\"class \");\n\tputs(getName(pop()));\n\tprintf(\" extends \");\n\tputs(getName(baseclass));\n\tprintln(\" {\" );\n#else\n\tprintln(\"asm {\");\n\tprintln(\" push '%s'\", getName(pop()));\n\tprintln(\" getvariable\");\n\tprintln(\" push '%s'\", getName(baseclass));\n\tprintln(\" getvariable\");\n\tprintln(\" extends\");\n\tprintln(\"};\");\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "    CImg<T>& YUVtoRGB() {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"YUVtoRGB(): Instance is not a YUV image.\",\n                                    cimg_instance);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=16384))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          Y = (Tfloat)p1[N],\n          U = (Tfloat)p2[N],\n          V = (Tfloat)p3[N],\n          R = (Y + 1.140f*V)*255,\n          G = (Y - 0.395f*U - 0.581f*V)*255,\n          B = (Y + 2.032f*U)*255;\n        p1[N] = (T)cimg::cut(R,0,255),\n        p2[N] = (T)cimg::cut(G,0,255),\n        p3[N] = (T)cimg::cut(B,0,255);\n      }\n      return *this;", "target": 0}
{"code": "xmlXPathNodeSetAdd(xmlNodeSetPtr cur, xmlNodePtr val) {\n    int i;\n    if ((cur == NULL) || (val == NULL)) return(-1);\n    for (i = 0;i < cur->nodeNr;i++)\n        if (cur->nodeTab[i] == val) return(0);\n    if (cur->nodeMax == 0) {\n        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\tif (cur->nodeTab == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return(-1);\n\t}\n\tmemset(cur->nodeTab, 0 ,\n\t       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n        cur->nodeMax = XML_NODESET_DEFAULT;\n    } else if (cur->nodeNr == cur->nodeMax) {\n        xmlNodePtr *temp;\n        if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH) {\n            xmlXPathErrMemory(NULL, \"growing nodeset hit limit\\n\");\n            return(-1);\n        }\n\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n\t\t\t\t      sizeof(xmlNodePtr));\n\tif (temp == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return(-1);\n\t}\n        cur->nodeMax *= 2;\n\tcur->nodeTab = temp;\n    }\n    if (val->type == XML_NAMESPACE_DECL) {\n\txmlNsPtr ns = (xmlNsPtr) val;\n\tcur->nodeTab[cur->nodeNr++] =\n\t    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n    } else\n\tcur->nodeTab[cur->nodeNr++] = val;\n    return(0);\n}", "target": 0}
{"code": "Hybrid_type_traits::val_str(Hybrid_type *val, String *to, uint8 decimals) const\n{\n  to->set_real(val->real, decimals, &my_charset_bin);\n  return to;\n}", "target": 0}
{"code": "int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,\n\t\t\t    int len, struct kvm_io_device *dev)\n{\n\tstruct kvm_io_bus *new_bus, *bus;\n\tbus = kvm->buses[bus_idx];\n\tif (bus->dev_count - bus->ioeventfd_count > NR_IOBUS_DEVS - 1)\n\t\treturn -ENOSPC;\n\tnew_bus = kmalloc(sizeof(*bus) + ((bus->dev_count + 1) *\n\t\t\t  sizeof(struct kvm_io_range)), GFP_KERNEL);\n\tif (!new_bus)\n\t\treturn -ENOMEM;\n\tmemcpy(new_bus, bus, sizeof(*bus) + (bus->dev_count *\n\t       sizeof(struct kvm_io_range)));\n\tkvm_io_bus_insert_dev(new_bus, dev, addr, len);\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\treturn 0;\n}", "target": 0}
{"code": "void AutoFillManager::OnInfoBarClosed(bool should_save) {\n  if (should_save)\n    personal_data_->SaveImportedCreditCard();\n  UploadFormData();\n}", "target": 0}
{"code": "static void *if6_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct inet6_ifaddr *ifa;\n\tifa = if6_get_next(seq, v);\n\t++*pos;\n\treturn ifa;\n}", "target": 0}
{"code": "  void SetInput(const std::vector<float>& data) {\n    QuantizeAndPopulate<uint8_t>(input_, data);\n  }", "target": 0}
{"code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\treturn 0;\n}", "target": 0}
{"code": "static void dump_usage_categories_info(Formatter *formatter, const rgw_usage_log_entry& entry, map<string, bool> *categories)\n{\n  formatter->open_array_section(\"categories\");\n  map<string, rgw_usage_data>::const_iterator uiter;\n  for (uiter = entry.usage_map.begin(); uiter != entry.usage_map.end(); ++uiter) {\n    if (categories && !categories->empty() && !categories->count(uiter->first))\n      continue;\n    const rgw_usage_data& usage = uiter->second;\n    formatter->open_object_section(\"Entry\");\n    encode_json(\"Category\", uiter->first, formatter);\n    encode_json(\"BytesSent\", usage.bytes_sent, formatter);\n    encode_json(\"BytesReceived\", usage.bytes_received, formatter);\n    encode_json(\"Ops\", usage.ops, formatter);\n    encode_json(\"SuccessfulOps\", usage.successful_ops, formatter);\n    formatter->close_section(); \n  }\n  formatter->close_section(); \n}", "target": 0}
{"code": "static void print_rel_date(time_t t, double value,\n\tconst char *class, const char *suffix)\n{\n\thtmlf(\"<span class='%s' title='\", class);\n\thtml_attr(fmt_date(t, FMT_LONGDATE, ctx.cfg.local_time));\n\thtmlf(\"'>%.0f %s</span>\", value, suffix);\n}", "target": 0}
{"code": "date_s_valid_nth_kday_p(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE vy, vm, vn, vk, vsg;\n    VALUE argv2[5];\n    rb_scan_args(argc, argv, \"41\", &vy, &vm, &vn, &vk, &vsg);\n    argv2[0] = vy;\n    argv2[1] = vm;\n    argv2[2] = vn;\n    argv2[3] = vk;\n    if (argc < 5)\n\targv2[4] = INT2FIX(DEFAULT_SG);\n    else\n\targv2[4] = vsg;\n    if (NIL_P(valid_nth_kday_sub(5, argv2, klass, 0)))\n\treturn Qfalse;\n    return Qtrue;\n}", "target": 0}
{"code": "xsltNumberFormatInsertNumbers(xsltNumberDataPtr data,\n\t\t\t      double *numbers,\n\t\t\t      int numbers_max,\n\t\t\t      xsltFormatPtr tokens,\n\t\t\t      xmlBufferPtr buffer)\n{\n    int i = 0;\n    double number;\n    xsltFormatTokenPtr token;\n    if (tokens->start != NULL)\n\t xmlBufferCat(buffer, tokens->start);\n    for (i = 0; i < numbers_max; i++) {\n\tnumber = numbers[(numbers_max - 1) - i];\n        number = floor(number + 0.5);\n        if (number < 0.0) {\n            xsltTransformError(NULL, NULL, NULL,\n                    \"xsl-number : negative value\\n\");\n            number = 0.0;\n        }\n\tif (i < tokens->nTokens) {\n\t  token = &(tokens->tokens[i]);\n\t} else if (tokens->nTokens > 0) {\n\t  token = &(tokens->tokens[tokens->nTokens - 1]);\n\t} else {\n\t  token = &default_token;\n\t}\n\tif (i > 0) {\n\t    if (token->separator != NULL)\n\t\txmlBufferCat(buffer, token->separator);\n\t    else\n\t\txmlBufferCCat(buffer, DEFAULT_SEPARATOR);\n\t}\n\tswitch (xmlXPathIsInf(number)) {\n\tcase -1:\n\t    xmlBufferCCat(buffer, \"-Infinity\");\n\t    break;\n\tcase 1:\n\t    xmlBufferCCat(buffer, \"Infinity\");\n\t    break;\n\tdefault:\n\t    if (xmlXPathIsNaN(number)) {\n\t\txmlBufferCCat(buffer, \"NaN\");\n\t    } else {\n\t\tswitch (token->token) {\n\t\tcase 'A':\n\t\t    xsltNumberFormatAlpha(data, buffer, number, TRUE);\n\t\t    break;\n\t\tcase 'a':\n\t\t    xsltNumberFormatAlpha(data, buffer, number, FALSE);\n\t\t    break;\n\t\tcase 'I':\n\t\t    xsltNumberFormatRoman(data, buffer, number, TRUE);\n\t\t    break;\n\t\tcase 'i':\n\t\t    xsltNumberFormatRoman(data, buffer, number, FALSE);\n\t\t    break;\n\t\tdefault:\n\t\t    if (IS_DIGIT_ZERO(token->token)) {\n\t\t\txsltNumberFormatDecimal(buffer,\n\t\t\t\t\t\tnumber,\n\t\t\t\t\t\ttoken->token,\n\t\t\t\t\t\ttoken->width,\n\t\t\t\t\t\tdata->digitsPerGroup,\n\t\t\t\t\t\tdata->groupingCharacter,\n\t\t\t\t\t\tdata->groupingCharacterLen);\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    if (tokens->end != NULL)\n\t xmlBufferCat(buffer, tokens->end);\n}", "target": 0}
{"code": "static int usbredirparser_verify_bulk_recv_cap(\n    struct usbredirparser *parser_pub, int send)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    if ((send && !usbredirparser_peer_has_cap(parser_pub,\n                                              usb_redir_cap_bulk_receiving)) ||\n        (!send && !usbredirparser_have_cap(parser_pub,\n                                           usb_redir_cap_bulk_receiving))) {\n        ERROR(\"error bulk_receiving without cap_bulk_receiving\");\n        return 0;\n    }\n    return 1; \n}", "target": 0}
{"code": "no_peephole(codegen_scope *s)\n{\n  return no_optimize(s) || s->lastlabel == s->pc || s->pc == 0 || s->pc == s->lastpc;\n}", "target": 0}
{"code": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data;\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}", "target": 0}
{"code": "VariationalRefinementImpl::ParallelOp_ParBody::ParallelOp_ParBody(VariationalRefinementImpl &_var, vector<Op> _ops,\n                                                                  vector<void *> &_op1s, vector<void *> &_op2s,\n                                                                  vector<void *> &_op3s)\n    : var(&_var), ops(_ops), op1s(_op1s), op2s(_op2s), op3s(_op3s)\n{\n}", "target": 0}
{"code": "SMB2_ioctl_init(struct cifs_tcon *tcon, struct smb_rqst *rqst,\n\t\tu64 persistent_fid, u64 volatile_fid, u32 opcode,\n\t\tbool is_fsctl, char *in_data, u32 indatalen,\n\t\t__u32 max_response_size)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tint rc;\n\trc = smb2_plain_req_init(SMB2_IOCTL, tcon, (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\tiov[0].iov_base = (char *)req;\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer));\n\t\trqst->rq_nvec = 2;\n\t\tiov[0].iov_len = total_len - 1;\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t} else {\n\t\trqst->rq_nvec = 1;\n\t\tiov[0].iov_len = total_len;\n\t}\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; \n\treq->MaxOutputResponse = cpu_to_le32(max_response_size);\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\tif (opcode == FSCTL_VALIDATE_NEGOTIATE_INFO)\n\t\treq->sync_hdr.Flags |= SMB2_FLAGS_SIGNED;\n\treturn 0;\n}", "target": 0}
{"code": "void SerializedFlashMenu::WriteToMessage(IPC::Message* m) const {\n  WriteMenu(m, pp_menu_);\n}", "target": 0}
{"code": "int ReadStrip(TIFF* tiff, UINT32 row, UINT32* buffer) {\n    uint16 photometric;\n    TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric);\n    if (photometric == PHOTOMETRIC_YCBCR) {\n        TIFFRGBAImage img;\n        char emsg[1024] = \"\";\n        UINT32 rows_per_strip, rows_to_read;\n        int ok;\n        TIFFGetFieldDefaulted(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n        if ((row % rows_per_strip) != 0) {\n            TRACE((\"Row passed to ReadStrip() must be first in a strip.\"));\n            return -1;\n        }\n        if (TIFFRGBAImageOK(tiff, emsg) && TIFFRGBAImageBegin(&img, tiff, 0, emsg)) {\n            TRACE((\"Initialized RGBAImage\\n\"));\n            img.req_orientation = ORIENTATION_TOPLEFT;\n            img.row_offset = row;\n            img.col_offset = 0;\n            rows_to_read = min(rows_per_strip, img.height - row);\n            TRACE((\"rows to read: %d\\n\", rows_to_read));\n            ok = TIFFRGBAImageGet(&img, buffer, img.width, rows_to_read);\n            TIFFRGBAImageEnd(&img);\n        } else {\n            ok = 0;\n        }\n        if (ok == 0) {\n            TRACE((\"Decode Error, row %d; msg: %s\\n\", row, emsg));\n            return -1;\n        }\n        return 0;\n    }\n    if (TIFFReadEncodedStrip(tiff, TIFFComputeStrip(tiff, row, 0), (tdata_t)buffer, -1) == -1) {\n        TRACE((\"Decode Error, strip %d\\n\", TIFFComputeStrip(tiff, row, 0)));\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static inline void skb_reset_inner_network_header(struct sk_buff *skb)\n{\n\tskb->inner_network_header = skb->data - skb->head;\n}", "target": 0}
{"code": "DEFINE_TEST(test_read_format_zip_lzma_one_file)\n{\n\tconst char *refname = \"test_read_format_zip_lzma.zipx\";\n\tstruct archive *a;\n\tstruct archive_entry *ae;\n\textract_reference_file(refname);\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n\tassertEqualString(\"ZIP 6.3 (lzma)\", archive_format_name(a));\n\tassertEqualString(\"vimrc\", archive_entry_pathname(ae));\n\tassertEqualIntA(a, 0, extract_one(a, ae, 0xBA8E3BAA));\n\tassertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\tSCTP_DEBUG_PRINTK(\"Timer T5 expired.\\n\");\n\tSCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);\n\treply = sctp_make_abort(asoc, NULL, 0);\n\tif (!reply)\n\t\tgoto nomem;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ETIMEDOUT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\treturn SCTP_DISPOSITION_DELETE_TCB;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}", "target": 0}
{"code": "Opal::Call::OnEstablished (OpalConnection & connection)\n{\n  RTP_Session *session = NULL;\n  OpalMediaStreamPtr stream;\n  NoAnswerTimer.Stop (false);\n  if (!PIsDescendant(&connection, OpalPCSSConnection)) {\n    parse_info (connection);\n    Ekiga::Runtime::run_in_main (boost::bind (&Opal::Call::emit_established_in_main, this));\n  }\n  if (PIsDescendant(&connection, OpalRTPConnection)) {\n    stream = connection.GetMediaStream (OpalMediaType::Audio (), false);\n    if (stream != NULL) {\n      session = PDownCast (OpalRTPConnection, &connection)->GetSession (stream->GetSessionID ());\n      if (session) {\n        session->SetIgnorePayloadTypeChanges (TRUE);\n        session->SetRxStatisticsInterval(50);\n        session->SetTxStatisticsInterval(50);\n      }\n    }\n    stream = connection.GetMediaStream (OpalMediaType::Video (), false);\n    if (stream != NULL) {\n      session = PDownCast (OpalRTPConnection, &connection)->GetSession (stream->GetSessionID ());\n      if (session) {\n        session->SetIgnorePayloadTypeChanges (TRUE);\n        session->SetRxStatisticsInterval(50);\n        session->SetTxStatisticsInterval(50);\n      }\n    }\n  }\n  return OpalCall::OnEstablished (connection);\n}", "target": 0}
{"code": "do_curl_pause(CurlObject *self, PyObject *args)\n{\n    int bitmask;\n    CURLcode res;\n#ifdef WITH_THREAD\n    PyThreadState *saved_state;\n#endif\n    if (!PyArg_ParseTuple(args, \"i:pause\", &bitmask)) {\n        return NULL;\n    }\n    if (check_curl_state(self, 1, \"pause\") != 0) {\n        return NULL;\n    }\n#ifdef WITH_THREAD\n    saved_state = self->state;\n    PYCURL_BEGIN_ALLOW_THREADS\n#endif\n    res = curl_easy_pause(self->handle, bitmask);\n#ifdef WITH_THREAD\n    PYCURL_END_ALLOW_THREADS\n    self->state = saved_state;\n#endif\n    if (res != CURLE_OK) {\n        CURLERROR_MSG(\"pause/unpause failed\");\n    } else {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n}", "target": 0}
{"code": "debug_print_ids(uschar *s)\n{\ndebug_printf(\"%s uid=%ld gid=%ld euid=%ld egid=%ld\\n\", s,\n  (long int)getuid(), (long int)getgid(), (long int)geteuid(),\n  (long int)getegid());\n}", "target": 0}
{"code": "static uint16_t nvme_identify_cmd_set(NvmeCtrl *n, NvmeRequest *req)\n{\n    uint8_t list[NVME_IDENTIFY_DATA_SIZE] = {};\n    static const int data_len = sizeof(list);\n    trace_pci_nvme_identify_cmd_set();\n    NVME_SET_CSI(*list, NVME_CSI_NVM);\n    NVME_SET_CSI(*list, NVME_CSI_ZONED);\n    return nvme_c2h(n, list, data_len, req);\n}", "target": 0}
{"code": "gxps_images_get_image (GXPSArchive *zip,\n\t\t       const gchar *image_uri,\n\t\t       GError     **error)\n{\n\tGXPSImage *image = NULL;\n\tgchar *image_uri_lower;\n\timage_uri_lower = g_utf8_strdown (image_uri, -1);\n\tif (g_str_has_suffix (image_uri_lower, \".png\")) {\n\t\timage = gxps_images_create_from_png (zip, image_uri, error);\n\t} else if (g_str_has_suffix (image_uri_lower, \".jpg\")) {\n\t\timage = gxps_images_create_from_jpeg (zip, image_uri, error);\n\t} else if (g_str_has_suffix (image_uri_lower, \".tif\")) {\n\t\timage = gxps_images_create_from_tiff (zip, image_uri, error);\n\t} else if (g_str_has_suffix (image_uri_lower, \"wdp\")) {\n\t\tGXPS_DEBUG (g_message (\"Unsupported image format windows media photo\"));\n\t\tg_free (image_uri_lower);\n\t\treturn NULL;\n\t}\n\tg_free (image_uri_lower);\n\tif (!image) {\n\t\tgchar *mime_type;\n                g_clear_error(error);\n\t\tmime_type = gxps_images_guess_content_type (zip, image_uri);\n\t\tif (g_strcmp0 (mime_type, \"image/png\") == 0) {\n\t\t\timage = gxps_images_create_from_png (zip, image_uri, error);\n\t\t} else if (g_strcmp0 (mime_type, \"image/jpeg\") == 0) {\n\t\t\timage = gxps_images_create_from_jpeg (zip, image_uri, error);\n\t\t} else if (g_strcmp0 (mime_type, \"image/tiff\") == 0) {\n\t\t\timage = gxps_images_create_from_tiff (zip, image_uri, error);\n\t\t} else {\n\t\t\tGXPS_DEBUG (g_message (\"Unsupported image format: %s\", mime_type));\n\t\t}\n\t\tg_free (mime_type);\n\t}\n\treturn image;\n}", "target": 0}
{"code": "static void substExprList(\n  SubstContext *pSubst, \n  ExprList *pList       \n){\n  int i;\n  if( pList==0 ) return;\n  for(i=0; i<pList->nExpr; i++){\n    pList->a[i].pExpr = substExpr(pSubst, pList->a[i].pExpr);\n  }\n}", "target": 0}
{"code": "static int isdn_ppp_mp_init(isdn_net_local *lp, ippp_bundle *add_to)\n{\n\tstruct ippp_struct *is;\n\tif (lp->ppp_slot < 0) {\n\t\tprintk(KERN_ERR \"%s: lp->ppp_slot(%d) out of range\\n\",\n\t\t       __func__, lp->ppp_slot);\n\t\treturn (-EINVAL);\n\t}\n\tis = ippp_table[lp->ppp_slot];\n\tif (add_to) {\n\t\tif (lp->netdev->pb)\n\t\t\tlp->netdev->pb->ref_ct--;\n\t\tlp->netdev->pb = add_to;\n\t} else {\t\t\n\t\tis->mp_seqno = 0;\n\t\tif ((lp->netdev->pb = isdn_ppp_mp_bundle_alloc()) == NULL)\n\t\t\treturn -ENOMEM;\n\t\tlp->next = lp->last = lp;\t\n\t\tlp->netdev->pb->frags = NULL;\n\t\tlp->netdev->pb->frames = 0;\n\t\tlp->netdev->pb->seq = UINT_MAX;\n\t}\n\tlp->netdev->pb->ref_ct++;\n\tis->last_link_seqno = 0;\n\treturn 0;\n}", "target": 0}
{"code": "bool AccessibilityUIElement::isEqual(AccessibilityUIElement* otherElement)\n{\n    return m_element == otherElement->platformUIElement();\n}", "target": 0}
{"code": "u64 cpu_clock(int cpu)\n{\n\treturn sched_clock();\n}", "target": 0}
{"code": "bool FrameLoader::representationExistsForURLScheme(const String& URLScheme)\n{\n    return m_client->representationExistsForURLScheme(URLScheme);\n}", "target": 0}
{"code": "get_indent_lnum(linenr_T lnum)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get(lnum), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);\n#endif\n}", "target": 0}
{"code": "void perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\tperf_sample_data_init(&sample, bp->attr.bp_addr, 0);\n\tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, &sample, regs);\n}", "target": 0}
{"code": "ServerApp::openClientListener(const NetworkAddress& address)\n{\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (args().m_enableCrypto) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n        if (args().check_client_certificates) {\n            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n        }\n    }\n    ClientListener* listen = new ClientListener(\n        address,\n        new TCPSocketFactory(m_events, getSocketMultiplexer()),\n        m_events, security_level);\n    m_events->adoptHandler(\n        m_events->forClientListener().connected(), listen,\n        new TMethodEventJob<ServerApp>(\n            this, &ServerApp::handleClientConnected, listen));\n    return listen;\n}", "target": 0}
{"code": "static void shm_get_stat(struct ipc_namespace *ns, unsigned long *rss,\n\t\tunsigned long *swp)\n{\n\tint next_id;\n\tint total, in_use;\n\t*rss = 0;\n\t*swp = 0;\n\tin_use = shm_ids(ns).in_use;\n\tfor (total = 0, next_id = 0; total < in_use; next_id++) {\n\t\tstruct kern_ipc_perm *ipc;\n\t\tstruct shmid_kernel *shp;\n\t\tipc = idr_find(&shm_ids(ns).ipcs_idr, next_id);\n\t\tif (ipc == NULL)\n\t\t\tcontinue;\n\t\tshp = container_of(ipc, struct shmid_kernel, shm_perm);\n\t\tshm_add_rss_swap(shp, rss, swp);\n\t\ttotal++;\n\t}\n}", "target": 0}
{"code": "void kmem_cache_destroy(struct kmem_cache *s)\n{\n\tdown_write(&slub_lock);\n\ts->refcount--;\n\tif (!s->refcount) {\n\t\tlist_del(&s->list);\n\t\tup_write(&slub_lock);\n\t\tif (kmem_cache_close(s)) {\n\t\t\tprintk(KERN_ERR \"SLUB %s: %s called for cache that \"\n\t\t\t\t\"still has objects.\\n\", s->name, __func__);\n\t\t\tdump_stack();\n\t\t}\n\t\tsysfs_slab_remove(s);\n\t} else\n\t\tup_write(&slub_lock);\n}", "target": 0}
{"code": "void WebContentsImpl::ShowCreatedWindow(int route_id,\n                                        WindowOpenDisposition disposition,\n                                        const gfx::Rect& initial_pos,\n                                        bool user_gesture) {\n  WebContentsImpl* contents = GetCreatedWindow(route_id);\n  if (contents) {\n    WebContentsDelegate* delegate = GetDelegate();\n    if (delegate) {\n      delegate->AddNewContents(\n          this, contents, disposition, initial_pos, user_gesture, NULL);\n    }\n  }\n}", "target": 0}
{"code": "calc_buffer_dimensions_ppm (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;\n  if (cinfo->out_color_space == JCS_GRAYSCALE)\n    dest->samples_per_row = cinfo->output_width * cinfo->out_color_components;\n  else\n    dest->samples_per_row = cinfo->output_width * 3;\n  dest->buffer_width = dest->samples_per_row * (BYTESPERSAMPLE * sizeof(char));\n}", "target": 0}
{"code": "script_get(exarg_T *eap UNUSED, char_u *cmd UNUSED)\n{\n#ifdef FEAT_EVAL\n    list_T\t*l;\n    listitem_T\t*li;\n    char_u\t*s;\n    garray_T\tga;\n    if (cmd[0] != '<' || cmd[1] != '<' || eap->getline == NULL)\n\treturn NULL;\n    cmd += 2;\n    l = heredoc_get(eap, cmd, TRUE);\n    if (l == NULL)\n\treturn NULL;\n    ga_init2(&ga, 1, 0x400);\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\ts = tv_get_string(&li->li_tv);\n\tga_concat(&ga, s);\n\tga_append(&ga, '\\n');\n    }\n    ga_append(&ga, NUL);\n    list_free(l);\n    return (char_u *)ga.ga_data;\n#else\n    return NULL;\n#endif\n}", "target": 0}
{"code": "TEST(FloatPoolingOpTest, MaxPoolPaddingSameStride1) {\n  FloatPoolingOpModel m(BuiltinOperator_MAX_POOL_2D,\n                        {TensorType_FLOAT32, {1, 2, 4, 1}},\n                        2, 2,\n                        {TensorType_FLOAT32, {}}, Padding_SAME, 1,\n                        1);\n  m.SetInput({\n      0, 6, 2, 4,   \n      3, 2, 10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({6, 10, 10, 7, 3, 10, 10, 7}));\n}", "target": 0}
{"code": "SYSCALL_DEFINE2(truncate64, const char __user *, path, loff_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}", "target": 0}
{"code": "TEST(HeaderMapImplTest, ClearHeaderMap) {\n  TestRequestHeaderMapImpl headers;\n  LowerCaseString static_key(\"hello\");\n  std::string ref_value(\"value\");\n  headers.addReference(static_key, ref_value);\n  EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());\n  EXPECT_TRUE(headers.get(static_key)->value().isReference());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.clear();\n  EXPECT_EQ(nullptr, headers.get(static_key));\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_EQ(headers.byteSize(), 0);\n  EXPECT_TRUE(headers.empty());\n  headers.setContentLength(5);\n  EXPECT_EQ(\"5\", headers.getContentLengthValue());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.clear();\n  EXPECT_EQ(nullptr, headers.ContentLength());\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_EQ(headers.byteSize(), 0);\n  EXPECT_TRUE(headers.empty());\n  headers.addReference(static_key, ref_value);\n  headers.setContentLength(5);\n  headers.addCopy(static_key, \"new_value\");\n  EXPECT_EQ(3UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.clear();\n  EXPECT_EQ(nullptr, headers.ContentLength());\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_EQ(headers.byteSize(), 0);\n  EXPECT_TRUE(headers.empty());\n}", "target": 0}
{"code": "void HTMLTextAreaElement::parseAttribute(const QualifiedName& name, const AtomicString& value)\n{\n    if (name == rowsAttr) {\n        int rows = value.toInt();\n        if (rows <= 0)\n            rows = defaultRows;\n        if (m_rows != rows) {\n            m_rows = rows;\n            if (renderer())\n                renderer()->setNeedsLayoutAndPrefWidthsRecalc();\n        }\n    } else if (name == colsAttr) {\n        int cols = value.toInt();\n        if (cols <= 0)\n            cols = defaultCols;\n        if (m_cols != cols) {\n            m_cols = cols;\n            if (renderer())\n                renderer()->setNeedsLayoutAndPrefWidthsRecalc();\n        }\n    } else if (name == wrapAttr) {\n        WrapMethod wrap;\n        if (equalIgnoringCase(value, \"physical\") || equalIgnoringCase(value, \"hard\") || equalIgnoringCase(value, \"on\"))\n            wrap = HardWrap;\n        else if (equalIgnoringCase(value, \"off\"))\n            wrap = NoWrap;\n        else\n            wrap = SoftWrap;\n        if (wrap != m_wrap) {\n            m_wrap = wrap;\n            if (renderer())\n                renderer()->setNeedsLayoutAndPrefWidthsRecalc();\n        }\n    } else if (name == accesskeyAttr) {\n    } else if (name == maxlengthAttr)\n        setNeedsValidityCheck();\n    else\n        HTMLTextFormControlElement::parseAttribute(name, value);\n}", "target": 0}
{"code": "irc_server_fingerprint_str_sizes ()\n{\n    char str_sizes[1024], str_one_size[128];\n    int i;\n    str_sizes[0] = '\\0';\n    for (i = IRC_FINGERPRINT_NUM_ALGOS - 1; i >= 0; i--)\n    {\n        snprintf (str_one_size, sizeof (str_one_size),\n                  \"%d=%s%s\",\n                  irc_fingerprint_digest_algos_size[i] / 4,\n                  irc_fingerprint_digest_algos_name[i],\n                  (i > 0) ? \", \" : \"\");\n        strcat (str_sizes, str_one_size);\n    }\n    return strdup (str_sizes);\n}", "target": 0}
{"code": "    uint32_t PreviewImage::width() const\n    {\n        return properties_.width_;\n    }", "target": 0}
{"code": "DLLIMPORT int cfg_free_value(cfg_opt_t *opt)\n{\n\tif (!opt) {\n\t\terrno = EINVAL;\n\t\treturn CFG_FAIL;\n\t}\n\tif (opt->comment && !is_set(CFGF_RESET, opt->flags)) {\n\t\tfree(opt->comment);\n\t\topt->comment = NULL;\n\t}\n\tif (opt->values) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < opt->nvalues; i++) {\n\t\t\tif (opt->type == CFGT_STR) {\n\t\t\t\tfree((void *)opt->values[i]->string);\n\t\t\t} else if (opt->type == CFGT_SEC) {\n\t\t\t\topt->values[i]->section->path = NULL; \n\t\t\t\tcfg_free(opt->values[i]->section);\n\t\t\t} else if (opt->type == CFGT_PTR && opt->freecb && opt->values[i]->ptr) {\n\t\t\t\t(opt->freecb) (opt->values[i]->ptr);\n\t\t\t}\n\t\t\tfree(opt->values[i]);\n\t\t}\n\t\tfree(opt->values);\n\t}\n\topt->values  = NULL;\n\topt->nvalues = 0;\n\treturn CFG_SUCCESS;\n}", "target": 0}
{"code": "inline bool canReadNElements(\n    Protocol_& prot,\n    uint32_t n,\n    std::initializer_list<\n        typename detail::ProtocolReaderWireTypeInfo<Protocol_>::WireType>\n        types) {\n  return prot.getCursor().canAdvance(n * types.size());\n}", "target": 0}
{"code": "void propagate_new_equalities(THD *thd, Item *cond,\n                              List<Item_equal> *new_equalities,\n                              COND_EQUAL *inherited,\n                              bool *is_simplifiable_cond)\n{\n  if (cond->type() == Item::COND_ITEM)\n  {\n    bool and_level= ((Item_cond*) cond)->functype() == Item_func::COND_AND_FUNC;\n    if (and_level)\n    {\n      Item_cond_and *cond_and= (Item_cond_and *) cond; \n      List<Item_equal> *cond_equalities= &cond_and->m_cond_equal.current_level;\n      cond_and->m_cond_equal.upper_levels= inherited;\n      if (!cond_equalities->is_empty() && cond_equalities != new_equalities)\n      {\n        Item_equal *equal_item;\n        List_iterator<Item_equal> it(*new_equalities);\n\twhile ((equal_item= it++))\n\t{\n          equal_item->merge_into_list(thd, cond_equalities, true, true);\n        }\n        List_iterator<Item_equal> ei(*cond_equalities);\n        while ((equal_item= ei++))\n\t{\n          if (equal_item->const_item() && !equal_item->val_int())\n\t  {\n            *is_simplifiable_cond= true;\n            return;\n          }\n        }\n      }\n    }\n    Item *item;\n    List_iterator<Item> li(*((Item_cond*) cond)->argument_list());\n    while ((item= li++))\n    {\n      COND_EQUAL *new_inherited= and_level && item->type() == Item::COND_ITEM ?\n                                   &((Item_cond_and *) cond)->m_cond_equal :\n                                   inherited;\n      propagate_new_equalities(thd, item, new_equalities, new_inherited,\n                               is_simplifiable_cond);\n    }\n  }\n  else if (cond->type() == Item::FUNC_ITEM && \n           ((Item_func*) cond)->functype() == Item_func::MULT_EQUAL_FUNC)\n  {\n    Item_equal *equal_item;\n    List_iterator<Item_equal> it(*new_equalities);\n    Item_equal *equality= (Item_equal *) cond;\n    equality->upper_levels= inherited;\n    while ((equal_item= it++))\n    {\n      equality->merge_with_check(thd, equal_item, true);\n    }\n    if (equality->const_item() && !equality->val_int())\n      *is_simplifiable_cond= true;\n  }\n  else\n  {\n    cond= cond->propagate_equal_fields(thd,\n                                       Item::Context_boolean(), inherited);\n    cond->update_used_tables();\n  }          \n} ", "target": 0}
{"code": "static inline void notifyTargetAboutAnimValChange(SVGElement* targetElement, const QualifiedName& attributeName)\n{\n    ASSERT_WITH_SECURITY_IMPLICATION(!targetElement->m_deletionHasBegun);\n    targetElement->svgAttributeChanged(attributeName);\n}", "target": 0}
{"code": "HTMLLinkElement* Document::LinkManifest() const {\n  HTMLHeadElement* head = this->head();\n  if (!head)\n    return nullptr;\n  for (HTMLLinkElement* link_element =\n           Traversal<HTMLLinkElement>::FirstChild(*head);\n       link_element;\n       link_element = Traversal<HTMLLinkElement>::NextSibling(*link_element)) {\n    if (!link_element->RelAttribute().IsManifest())\n      continue;\n    return link_element;\n  }\n  return nullptr;\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::EndFrameSubscription() {\n  idle_frame_subscriber_textures_.clear();\n  frame_subscriber_.reset();\n}", "target": 0}
{"code": "  static bool decodedResourceEq(const Config::DecodedResource& lhs,\n                                const Config::DecodedResource& rhs) {\n    return lhs.name() == rhs.name() && lhs.aliases() == rhs.aliases() &&\n           lhs.version() == rhs.version() && lhs.hasResource() == rhs.hasResource() &&\n           (!lhs.hasResource() || protoEqual(lhs.resource(), rhs.resource()));\n  }", "target": 0}
{"code": "void exit_robust_list(struct task_struct *curr)\n{\n\tstruct robust_list_head __user *head = curr->robust_list;\n\tstruct robust_list __user *entry, *next_entry, *pending;\n\tunsigned int limit = ROBUST_LIST_LIMIT, pi, next_pi, pip;\n\tunsigned long futex_offset;\n\tint rc;\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\tif (fetch_robust_entry(&entry, &head->list.next, &pi))\n\t\treturn;\n\tif (get_user(futex_offset, &head->futex_offset))\n\t\treturn;\n\tif (fetch_robust_entry(&pending, &head->list_op_pending, &pip))\n\t\treturn;\n\tnext_entry = NULL;\t\n\twhile (entry != &head->list) {\n\t\trc = fetch_robust_entry(&next_entry, &entry->next, &next_pi);\n\t\tif (entry != pending)\n\t\t\tif (handle_futex_death((void __user *)entry + futex_offset,\n\t\t\t\t\t\tcurr, pi))\n\t\t\t\treturn;\n\t\tif (rc)\n\t\t\treturn;\n\t\tentry = next_entry;\n\t\tpi = next_pi;\n\t\tif (!--limit)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (pending)\n\t\thandle_futex_death((void __user *)pending + futex_offset,\n\t\t\t\t   curr, pip);\n}", "target": 0}
{"code": "aspath_init (void)\n{\n  ashash = hash_create_size (32768, aspath_key_make, aspath_cmp);\n}", "target": 0}
{"code": "    **/\n    inline cimg_long wait(const unsigned int milliseconds) {\n      cimg::mutex(3);\n      static cimg_ulong timer = 0;\n      if (!timer) timer = cimg::time();\n      cimg::mutex(3,0);\n      return _wait(milliseconds,timer);", "target": 0}
{"code": "bool TrustedPrimitives::IsOutsideEnclave(const void *addr, size_t size) {\n  return sgx_is_outside_enclave(addr, size) == 1;\n}", "target": 0}
{"code": "util_curl_close(CurlObject *self)\n{\n    CURL *handle;\n    assert(self != NULL);\n    assert(Py_TYPE(self) == p_Curl_Type);\n    handle = self->handle;\n    self->handle = NULL;\n    if (handle == NULL) {\n#ifdef WITH_THREAD\n        assert(self->state == NULL);\n#endif\n        assert(self->multi_stack == NULL);\n        assert(self->share == NULL);\n        return;             \n    }\n#ifdef WITH_THREAD\n    self->state = NULL;\n#endif\n    util_curl_xdecref(self, PYCURL_MEMGROUP_MULTI, handle);\n    util_curl_xdecref(self, PYCURL_MEMGROUP_SHARE, handle);\n    Py_BEGIN_ALLOW_THREADS\n    curl_easy_cleanup(handle);\n    Py_END_ALLOW_THREADS\n    handle = NULL;\n    util_curl_xdecref(self, PYCURL_MEMGROUP_EASY, handle);\n#undef SFREE\n#define SFREE(v)   if ((v) != NULL) (curl_formfree(v), (v) = NULL)\n    SFREE(self->httppost);\n#undef SFREE\n#define SFREE(v)   if ((v) != NULL) (curl_slist_free_all(v), (v) = NULL)\n    SFREE(self->httpheader);\n    SFREE(self->http200aliases);\n    SFREE(self->quote);\n    SFREE(self->postquote);\n    SFREE(self->prequote);\n#ifdef HAVE_CURLOPT_RESOLVE\n    SFREE(self->resolve);\n#endif\n#ifdef HAVE_CURL_7_20_0_OPTS\n    SFREE(self->mail_rcpt);\n#endif\n#undef SFREE\n}", "target": 0}
{"code": "void RtmpProtocol::sendAcknowledgement(uint32_t size) {\n    size = htonl(size);\n    std::string acknowledgement((char *) &size, 4);\n    sendRequest(MSG_ACK, acknowledgement);\n}", "target": 0}
{"code": "int nfs4_proc_setclientid(struct nfs_client *clp, u32 program,\n\t\tunsigned short port, struct rpc_cred *cred,\n\t\tstruct nfs4_setclientid_res *res)\n{\n\tnfs4_verifier sc_verifier;\n\tstruct nfs4_setclientid setclientid = {\n\t\t.sc_verifier = &sc_verifier,\n\t\t.sc_prog = program,\n\t\t.sc_cb_ident = clp->cl_cb_ident,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID],\n\t\t.rpc_argp = &setclientid,\n\t\t.rpc_resp = res,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\tnfs4_init_boot_verifier(clp, &sc_verifier);\n\trcu_read_lock();\n\tsetclientid.sc_name_len = scnprintf(setclientid.sc_name,\n\t\t\tsizeof(setclientid.sc_name), \"%s/%s %s\",\n\t\t\tclp->cl_ipaddr,\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\tRPC_DISPLAY_ADDR),\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\tRPC_DISPLAY_PROTO));\n\tsetclientid.sc_netid_len = scnprintf(setclientid.sc_netid,\n\t\t\t\tsizeof(setclientid.sc_netid),\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_NETID));\n\trcu_read_unlock();\n\tsetclientid.sc_uaddr_len = scnprintf(setclientid.sc_uaddr,\n\t\t\t\tsizeof(setclientid.sc_uaddr), \"%s.%u.%u\",\n\t\t\t\tclp->cl_ipaddr, port >> 8, port & 255);\n\tdprintk(\"NFS call  setclientid auth=%s, '%.*s'\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tsetclientid.sc_name_len, setclientid.sc_name);\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tdprintk(\"NFS reply setclientid: %d\\n\", status);\n\treturn status;\n}", "target": 0}
{"code": "    void TiffEncoder::visitDirectory(TiffDirectory* )\n    {\n    }", "target": 0}
{"code": "get_caller_uid (GDBusMethodInvocation *context, gint *uid)\nget_caller_uid (GDBusMethodInvocation *context,\n                gint                  *uid)\n {\n        GVariant      *reply;\n        GError        *error;\n        error = NULL;\n        reply = g_dbus_connection_call_sync (g_dbus_method_invocation_get_connection (context),\n                                             \"org.freedesktop.DBus\",\n                                             \"/org/freedesktop/DBus\",\n                                             \"org.freedesktop.DBus\",\n                                             \"GetConnectionUnixUser\",\n                                             g_variant_new (\"(s)\",\n                                                            g_dbus_method_invocation_get_sender (context)),\n                                             G_VARIANT_TYPE (\"(u)\"),\n                                             G_DBUS_CALL_FLAGS_NONE,\n                                             -1,\n                                             NULL,\n                                             &error);\n        if (reply == NULL) {\n                g_warning (\"Could not talk to message bus to find uid of sender %s: %s\",\n                           g_dbus_method_invocation_get_sender (context),\n                           error->message);\n                g_error_free (error);\n                 return FALSE;\n         }\n        g_variant_get (reply, \"(u)\", uid);\n        g_variant_unref (reply);\n         return TRUE;\n }", "target": 0}
{"code": "static void __inject_pit_timer_intr(struct kvm *kvm)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1);\n\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0);\n\tif (kvm->arch.vapics_in_nmi_mode > 0)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tkvm_apic_nmi_wd_deliver(vcpu);\n}", "target": 0}
{"code": "static int muscle_check_sw(sc_card_t * card, unsigned int sw1, unsigned int sw2) {\n\tif(sw1 == 0x9C) {\n\t\tswitch(sw2) {\n\t\t\tcase 0x01: \n\t\t\t\treturn SC_ERROR_NOT_ENOUGH_MEMORY;\n\t\t\tcase 0x02: \n\t\t\t\treturn SC_ERROR_PIN_CODE_INCORRECT;\n\t\t\tcase 0x03: \n\t\t\t\treturn SC_ERROR_NOT_ALLOWED;\n\t\t\tcase 0x05: \n\t\t\t\treturn SC_ERROR_NO_CARD_SUPPORT;\n\t\t\tcase 0x06: \n\t\t\t\treturn SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t\tcase 0x07: \n\t\t\t\treturn SC_ERROR_FILE_NOT_FOUND;\n\t\t\tcase 0x08: \n\t\t\t\treturn SC_ERROR_FILE_ALREADY_EXISTS;\n\t\t\tcase 0x09: \n\t\t\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\t\t\tcase 0x0B: \n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t\tcase 0x0C: \n\t\t\t\treturn SC_ERROR_AUTH_METHOD_BLOCKED;\n\t\t\tcase 0x0F: \n\t\t\tcase 0x10: \n\t\t\tcase 0x11: \n\t\t\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\t\t}\n\t}\n\treturn iso_ops->check_sw(card, sw1, sw2);\n}", "target": 0}
{"code": "void HTMLMediaElement::PlayInternal() {\n  BLINK_MEDIA_LOG << \"playInternal(\" << (void*)this << \")\";\n  if (lazy_load_visibility_observer_) {\n    lazy_load_visibility_observer_->Stop();\n    lazy_load_visibility_observer_ = nullptr;\n  }\n  if (network_state_ == kNetworkEmpty)\n    InvokeResourceSelectionAlgorithm();\n  if (EndedPlayback(LoopCondition::kIgnored))\n    Seek(0);\n  if (paused_) {\n    paused_ = false;\n    ScheduleEvent(event_type_names::kPlay);\n    if (ready_state_ <= kHaveCurrentData)\n      ScheduleEvent(event_type_names::kWaiting);\n    else if (ready_state_ >= kHaveFutureData)\n      ScheduleNotifyPlaying();\n  } else if (ready_state_ >= kHaveFutureData) {\n    ScheduleResolvePlayPromises();\n  }\n  can_autoplay_ = false;\n  SetIgnorePreloadNone();\n  UpdatePlayState();\n}", "target": 0}
{"code": "static int do_linear_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tint write_access, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tunsigned int flags = (write_access ? FAULT_FLAG_WRITE : 0);\n\tpte_unmap(page_table);\n\treturn __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 0}
{"code": "next_segment(svn_stringbuf_t *segment,\n             const char *path)\n{\n  apr_size_t len;\n  char c;\n  for (len = 0, c = *path; c; c = path[++len])\n    if (c == '/')\n      {\n        segment->data[len] = 0;\n        segment->len = len;\n        while (path[++len] == '/')\n          ;\n        return path + len;\n      }\n    else\n      {\n        segment->data[len] = c;\n      }\n  segment->data[len] = 0;\n  segment->len = len;\n  return NULL;\n}", "target": 0}
{"code": "make_group_fields(JOIN *main_join, JOIN *curr_join)\n{\n  if (main_join->group_fields_cache.elements)\n  {\n    curr_join->group_fields= main_join->group_fields_cache;\n    curr_join->sort_and_group= 1;\n  }\n  else\n  {\n    if (alloc_group_fields(curr_join, curr_join->group_list))\n      return (1);\n    main_join->group_fields_cache= curr_join->group_fields;\n  }\n  return (0);\n}", "target": 0}
{"code": "InputMethodBase::~InputMethodBase() {\n}", "target": 0}
{"code": "  void set_fp_stubs_generated(bool value) {\n    fp_stubs_generated_ = value;\n  }", "target": 0}
{"code": "static int vmx_pre_block(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tunsigned int dest;\n\tstruct pi_desc old, new;\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP))\n\t\treturn 0;\n\tvcpu->pre_pcpu = vcpu->cpu;\n\tspin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t  vcpu->pre_pcpu), flags);\n\tlist_add_tail(&vcpu->blocked_vcpu_list,\n\t\t      &per_cpu(blocked_vcpu_on_cpu,\n\t\t      vcpu->pre_pcpu));\n\tspin_unlock_irqrestore(&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t       vcpu->pre_pcpu), flags);\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\t\tif (pi_test_on(pi_desc) == 1) {\n\t\t\tspin_lock_irqsave(&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t\t\t  vcpu->pre_pcpu), flags);\n\t\t\tlist_del(&vcpu->blocked_vcpu_list);\n\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t&per_cpu(blocked_vcpu_on_cpu_lock,\n\t\t\t\t\tvcpu->pre_pcpu), flags);\n\t\t\tvcpu->pre_pcpu = -1;\n\t\t\treturn 1;\n\t\t}\n\t\tWARN((pi_desc->sn == 1),\n\t\t     \"Warning: SN field of posted-interrupts \"\n\t\t     \"is set before blocking\\n\");\n\t\tdest = cpu_physical_id(vcpu->pre_pcpu);\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\t\tnew.nv = POSTED_INTR_WAKEUP_VECTOR;\n\t} while (cmpxchg(&pi_desc->control, old.control,\n\t\t\tnew.control) != old.control);\n\treturn 0;\n}", "target": 0}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "TEST(InMatchExpression, InMatchExpressionsWithDifferentNumbersOfElementsAreUnequal) {\n    BSONObj obj = BSON(\"\"\n                       << \"string\");\n    InMatchExpression eq1(\"\");\n    InMatchExpression eq2(\"\");\n    std::vector<BSONElement> equalities{obj.firstElement()};\n    ASSERT_OK(eq1.setEqualities(std::move(equalities)));\n    ASSERT(!eq1.equivalent(&eq2));\n}", "target": 0}
{"code": "static inline int unserialize_allowed_class(zend_string *class_name, HashTable *classes)\n{\n\tzend_string *lcname;\n\tint res;\n\tALLOCA_FLAG(use_heap)\n\tif(classes == NULL) {\n\t\treturn 1;\n\t}\n\tif(!zend_hash_num_elements(classes)) {\n\t\treturn 0;\n\t}\n\tZSTR_ALLOCA_ALLOC(lcname, ZSTR_LEN(class_name), use_heap);\n\tzend_str_tolower_copy(ZSTR_VAL(lcname), ZSTR_VAL(class_name), ZSTR_LEN(class_name));\n\tres = zend_hash_exists(classes, lcname);\n\tZSTR_ALLOCA_FREE(lcname, use_heap);\n\treturn res;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, NegatedRangeStrGT) {\n    addIndex(BSON(\"i\" << 1));\n    runQuery(fromjson(\"{i: {$not: {$gt: 'a'}}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {i:1}, \"\n        \"bounds: {i: [['MinKey','a',true,true], \"\n        \"[{},'MaxKey',true,true]]}}}}}\");\n}", "target": 0}
{"code": "Item_equal *Item_field::find_item_equal(COND_EQUAL *cond_equal)\n{\n  Item_equal *item= 0;\n  while (cond_equal)\n  {\n    List_iterator_fast<Item_equal> li(cond_equal->current_level);\n    while ((item= li++))\n    {\n      if (item->contains(field))\n        return item;\n    }\n    cond_equal= cond_equal->upper_levels;\n  }\n  return 0;\n}", "target": 0}
{"code": "static ssize_t ipmi_version_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\treturn snprintf(buf, 20, \"%u.%u\\n\",\n\t\t\tipmi_version_major(&id),\n\t\t\tipmi_version_minor(&id));\n}", "target": 0}
{"code": "static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n\tint newly_acked_sacked = prior_unsacked -\n\t\t\t\t (tp->packets_out - tp->sacked_out);\n\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\n\t\treturn;\n\ttp->prr_delivered += newly_acked_sacked;\n\tif (delta < 0) {\n\t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}", "target": 0}
{"code": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n    }\n    if (oldcode == -1) {\n        if (code >= clear) {\n            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n            return 0;\n        }\n\t*(*fill)++ = suffix[code];\n\tfirstchar = oldcode = code;\n\treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n    incode = code;\n    if (code == avail) {      \n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}", "target": 0}
{"code": "static int blk_mq_queue_enter(struct request_queue *q, gfp_t gfp)\n{\n\twhile (true) {\n\t\tint ret;\n\t\tif (percpu_ref_tryget_live(&q->mq_usage_counter))\n\t\t\treturn 0;\n\t\tif (!(gfp & __GFP_WAIT))\n\t\t\treturn -EBUSY;\n\t\tret = wait_event_interruptible(q->mq_freeze_wq,\n\t\t\t\t!atomic_read(&q->mq_freeze_depth) ||\n\t\t\t\tblk_queue_dying(q));\n\t\tif (blk_queue_dying(q))\n\t\t\treturn -ENODEV;\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n}", "target": 0}
{"code": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}", "target": 0}
{"code": "static void to_words52(BN_ULONG *out, int out_len,\n                       const BN_ULONG *in, int in_bitsize)\n{\n    uint8_t *in_str = NULL;\n    assert(out != NULL);\n    assert(in != NULL);\n    assert(out_len >= number_of_digits(in_bitsize, DIGIT_SIZE));\n    in_str = (uint8_t *)in;\n    for (; in_bitsize >= (2 * DIGIT_SIZE); in_bitsize -= (2 * DIGIT_SIZE), out += 2) {\n        out[0] = (*(uint64_t *)in_str) & DIGIT_MASK;\n        in_str += 6;\n        out[1] = ((*(uint64_t *)in_str) >> 4) & DIGIT_MASK;\n        in_str += 7;\n        out_len -= 2;\n    }\n    if (in_bitsize > DIGIT_SIZE) {\n        uint64_t digit = get_digit52(in_str, 7);\n        out[0] = digit & DIGIT_MASK;\n        in_str += 6;\n        in_bitsize -= DIGIT_SIZE;\n        digit = get_digit52(in_str, BITS2WORD8_SIZE(in_bitsize));\n        out[1] = digit >> 4;\n        out += 2;\n        out_len -= 2;\n    } else if (in_bitsize > 0) {\n        out[0] = get_digit52(in_str, BITS2WORD8_SIZE(in_bitsize));\n        out++;\n        out_len--;\n    }\n    while (out_len > 0) {\n        *out = 0;\n        out_len--;\n        out++;\n    }\n}", "target": 0}
{"code": "Eina_Bool ewk_view_paint(Ewk_View_Private_Data* priv, cairo_t* cr, const Eina_Rectangle* area)\n{\n    EINA_SAFETY_ON_NULL_RETURN_VAL(priv, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(cr, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(area, false);\n    WebCore::FrameView* view = priv->mainFrame->view();\n    EINA_SAFETY_ON_NULL_RETURN_VAL(view, false);\n    if (view->needsLayout())\n        view->forceLayout();\n    WebCore::GraphicsContext graphicsContext(cr);\n    WebCore::IntRect rect(area->x, area->y, area->w, area->h);\n    cairo_save(cr);\n    graphicsContext.save();\n    graphicsContext.clip(rect);\n    if (view->isTransparent())\n        graphicsContext.clearRect(rect);\n    view->paint(&graphicsContext, rect);\n    graphicsContext.restore();\n    cairo_restore(cr);\n    return true;\n}", "target": 0}
{"code": "template<> const SVGEnumerationStringEntries& getStaticStringEntries<ColorMatrixType>()\n{\n    DEFINE_STATIC_LOCAL(SVGEnumerationStringEntries, entries, ());\n    if (entries.isEmpty()) {\n        entries.append(std::make_pair(FECOLORMATRIX_TYPE_MATRIX, \"matrix\"));\n        entries.append(std::make_pair(FECOLORMATRIX_TYPE_SATURATE, \"saturate\"));\n        entries.append(std::make_pair(FECOLORMATRIX_TYPE_HUEROTATE, \"hueRotate\"));\n        entries.append(std::make_pair(FECOLORMATRIX_TYPE_LUMINANCETOALPHA, \"luminanceToAlpha\"));\n    }\n    return entries;\n}", "target": 0}
{"code": "void RenderView::OnScriptEvalRequest(const std::wstring& frame_xpath,\n                                     const std::wstring& jscript) {\n  EvaluateScript(frame_xpath, jscript);\n}", "target": 0}
{"code": "void LibRaw::lin_interpolate_loop(int code[16][16][32], int size)\n{\n  int row;\n  for (row = 1; row < height - 1; row++)\n  {\n    int col, *ip;\n    ushort *pix;\n    for (col = 1; col < width - 1; col++)\n    {\n      int i;\n      int sum[4];\n      pix = image[row * width + col];\n      ip = code[row % size][col % size];\n      memset(sum, 0, sizeof sum);\n      for (i = *ip++; i--; ip += 3)\n        sum[ip[2]] += pix[ip[0]] << ip[1];\n      for (i = colors; --i; ip += 2)\n        pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n    }\n  }\n}", "target": 0}
{"code": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\tif (!sg)\n\t\treturn;\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}", "target": 0}
{"code": "smb2_downgrade_oplock(struct TCP_Server_Info *server,\n\t\t      struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t      unsigned int epoch, bool *purge_cache)\n{\n\tserver->ops->set_oplock_level(cinode, oplock, 0, NULL);\n}", "target": 0}
{"code": "int http_forward_trailers(struct buffer *buf, struct http_msg *msg)\n{\n\twhile (1) {\n\t\tchar *p1 = NULL, *p2 = NULL;\n\t\tchar *ptr = buf->lr;\n\t\tint bytes;\n\t\twhile (1) {\n\t\t\tif (ptr == buf->r)\n\t\t\t\treturn 0;\n\t\t\tif (*ptr == '\\n') {\n\t\t\t\tif (!p1)\n\t\t\t\t\tp1 = ptr;\n\t\t\t\tp2 = ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*ptr == '\\r') {\n\t\t\t\tif (p1) {\n\t\t\t\t\tmsg->err_pos = ptr - buf->data;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tp1 = ptr;\n\t\t\t}\n\t\t\tptr++;\n\t\t\tif (ptr >= buf->data + buf->size)\n\t\t\t\tptr = buf->data;\n\t\t}\n\t\tp2++;\n\t\tif (p2 >= buf->data + buf->size)\n\t\t\tp2 = buf->data;\n\t\tbytes = p2 - buf->lr;\n\t\tif (bytes < 0)\n\t\t\tbytes += buf->size;\n\t\tmsg->sov += bytes;\n\t\tif (msg->sov >= buf->size)\n\t\t\tmsg->sov -= buf->size;\n\t\tif (p1 == buf->lr) {\n\t\t\tbuf->lr = p2;\n\t\t\tmsg->msg_state = HTTP_MSG_DONE;\n\t\t\treturn 1;\n\t\t}\n\t\tbuf->lr = p2;\n\t}\n}", "target": 0}
{"code": "fbFetchPixel_x1r5g5b5 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32  pixel = READ((CARD16 *) bits + offset);\n    CARD32  r,g,b;\n    r = ((pixel & 0x7c00) | ((pixel & 0x7000) >> 5)) << 9;\n    g = ((pixel & 0x03e0) | ((pixel & 0x0380) >> 5)) << 6;\n    b = ((pixel & 0x001c) | ((pixel & 0x001f) << 5)) >> 2;\n    return (0xff000000 | r | g | b);\n}", "target": 0}
{"code": "static void vmx_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_IDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_IDTR_BASE);\n}", "target": 0}
{"code": "bool SandboxedExtensionUnpacker::RewriteImageFiles() {\n  ExtensionUnpacker::DecodedImages images;\n  if (!ExtensionUnpacker::ReadImagesFromFile(temp_dir_.path(), &images)) {\n    ReportFailure(\"Couldn't read image data from disk.\");\n    return false;\n  }\n  std::set<FilePath> image_paths = extension_->GetBrowserImages();\n  if (image_paths.size() != images.size()) {\n    ReportFailure(\"Decoded images don't match what's in the manifest.\");\n    return false;\n  }\n  for (std::set<FilePath>::iterator it = image_paths.begin();\n       it != image_paths.end(); ++it) {\n    FilePath path = *it;\n    if (path.IsAbsolute() || path.ReferencesParent()) {\n      ReportFailure(\"Invalid path for browser image.\");\n      return false;\n    }\n    if (!file_util::Delete(extension_root_.Append(path), false)) {\n      ReportFailure(\"Error removing old image file.\");\n      return false;\n    }\n  }\n  for (size_t i = 0; i < images.size(); ++i) {\n    const SkBitmap& image = images[i].a;\n    FilePath path_suffix = images[i].b;\n    if (path_suffix.IsAbsolute() || path_suffix.ReferencesParent()) {\n      ReportFailure(\"Invalid path for bitmap image.\");\n      return false;\n    }\n    FilePath path = extension_root_.Append(path_suffix);\n    std::vector<unsigned char> image_data;\n    if (!gfx::PNGCodec::EncodeBGRASkBitmap(image, false, &image_data)) {\n      ReportFailure(\"Error re-encoding theme image.\");\n      return false;\n    }\n    const char* image_data_ptr = reinterpret_cast<const char*>(&image_data[0]);\n    if (!file_util::WriteFile(path, image_data_ptr, image_data.size())) {\n      ReportFailure(\"Error saving theme image.\");\n      return false;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "void m4ds_box_del(GF_Box *s)\n{\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\tgf_odf_desc_list_del(ptr->descriptors);\n\tgf_list_del(ptr->descriptors);\n\tgf_free(ptr);\n}", "target": 0}
{"code": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n}", "target": 0}
{"code": "static const void *GetVirtualMetacontentFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  const int\n    id = GetOpenMPThreadId();\n  const void\n    *magick_restrict metacontent;\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  metacontent=GetVirtualMetacontentFromNexus(cache_info,\n    cache_info->nexus_info[id]);\n  return(metacontent);\n}", "target": 0}
{"code": "smb2_is_status_io_timeout(char *buf)\n{\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tif (shdr->Status == STATUS_IO_TIMEOUT)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "target": 0}
{"code": "static bool ieee80211_frame_allowed(struct ieee80211_rx_data *rx, __le16 fc)\n{\n\tstatic const u8 pae_group_addr[ETH_ALEN] __aligned(2)\n\t\t= { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x03 };\n\tstruct ethhdr *ehdr = (struct ethhdr *) rx->skb->data;\n\tif (ehdr->h_proto == rx->sdata->control_port_protocol &&\n\t    (ether_addr_equal(ehdr->h_dest, rx->sdata->vif.addr) ||\n\t     ether_addr_equal(ehdr->h_dest, pae_group_addr)))\n\t\treturn true;\n\tif (ieee80211_802_1x_port_control(rx) ||\n\t    ieee80211_drop_unencrypted(rx, fc))\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "router_is_active(routerinfo_t *ri, time_t now)\n{\n  time_t cutoff = now - ROUTER_MAX_AGE_TO_PUBLISH;\n  if (ri->cache_info.published_on < cutoff)\n    return 0;\n  if (!ri->is_running || !ri->is_valid || ri->is_hibernating)\n    return 0;\n  return 1;\n}", "target": 0}
{"code": "gfx::NativeView OmniboxViewWin::GetRelativeWindowForPopup() const {\n  return GetRelativeWindowForNativeView(GetNativeView());\n}", "target": 0}
{"code": "gfx::GLSurfaceHandle RenderWidgetHostViewAura::GetCompositingSurface() {\n  return ImageTransportFactory::GetInstance()->GetSharedSurfaceHandle();\n}", "target": 0}
{"code": "find_ref_for_refs_set (GHashTable   *refs,\n                       const char   *name,\n                       const char   *opt_branch,\n                       const char   *opt_default_branch,\n                       const char   *opt_arch,\n                       FlatpakKinds  kinds,\n                       GError      **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) ref = find_matching_ref (refs,\n                                                        name,\n                                                        opt_branch,\n                                                        opt_default_branch,\n                                                        opt_arch,\n                                                        kinds,\n                                                        &my_error);\n  if (ref == NULL)\n    {\n      if (g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        g_clear_error (&my_error);\n      else\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return NULL;\n        }\n    }\n  else\n    {\n      return g_steal_pointer (&ref);\n    }\n  g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n               _(\"Can't find ref %s%s%s%s%s\"), name,\n               (opt_arch != NULL || opt_branch != NULL) ? \"/\" : \"\",\n               opt_arch ? opt_arch : \"\",\n               opt_branch ? \"/\" : \"\",\n               opt_branch ? opt_branch : \"\");\n  return NULL;\n}", "target": 0}
{"code": "static int nf_tables_newsetelem(struct sk_buff *skb,\n\t\t\t\tconst struct nfnl_info *info,\n\t\t\t\tconst struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\tint rem, err;\n\tif (nla[NFTA_SET_ELEM_LIST_ELEMENTS] == NULL)\n\t\treturn -EINVAL;\n\ttable = nft_table_lookup(net, nla[NFTA_SET_ELEM_LIST_TABLE], family,\n\t\t\t\t genmask, NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_ELEM_LIST_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\tset = nft_set_lookup_global(net, table, nla[NFTA_SET_ELEM_LIST_SET],\n\t\t\t\t    nla[NFTA_SET_ELEM_LIST_SET_ID], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\tif (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\tnla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {\n\t\terr = nft_add_set_elem(&ctx, set, attr, info->nlh->nlmsg_flags);\n\t\tif (err < 0) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (nft_net->validate_state == NFT_VALIDATE_DO)\n\t\treturn nft_table_validate(net, table);\n\treturn 0;\n}", "target": 0}
{"code": "static void csi_K(struct vc_data *vc, int vpar)\n{\n\tunsigned int count;\n\tunsigned short *start = (unsigned short *)vc->vc_pos;\n\tint offset;\n\tswitch (vpar) {\n\t\tcase 0:\t\n\t\t\toffset = 0;\n\t\t\tcount = vc->vc_cols - vc->vc_x;\n\t\t\tbreak;\n\t\tcase 1:\t\n\t\t\toffset = -vc->vc_x;\n\t\t\tcount = vc->vc_x + 1;\n\t\t\tbreak;\n\t\tcase 2: \n\t\t\toffset = -vc->vc_x;\n\t\t\tcount = vc->vc_cols;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\tvc_uniscr_clear_line(vc, vc->vc_x + offset, count);\n\tscr_memsetw(start + offset, vc->vc_video_erase_char, 2 * count);\n\tvc->vc_need_wrap = 0;\n\tif (con_should_update(vc))\n\t\tdo_update_region(vc, (unsigned long)(start + offset), count);\n}", "target": 0}
{"code": "static struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)\n{\n\tunsigned int block_nr = req->tp_block_nr;\n\tstruct pgv *pg_vec;\n\tint i;\n\tpg_vec = kcalloc(block_nr, sizeof(struct pgv), GFP_KERNEL);\n\tif (unlikely(!pg_vec))\n\t\tgoto out;\n\tfor (i = 0; i < block_nr; i++) {\n\t\tpg_vec[i].buffer = alloc_one_pg_vec_page(order);\n\t\tif (unlikely(!pg_vec[i].buffer))\n\t\t\tgoto out_free_pgvec;\n\t}\nout:\n\treturn pg_vec;\nout_free_pgvec:\n\tfree_pg_vec(pg_vec, order, block_nr);\n\tpg_vec = NULL;\n\tgoto out;\n}", "target": 0}
{"code": "void rds_rdma_unuse(struct rds_sock *rs, u32 r_key, int force)\n{\n\tstruct rds_mr *mr;\n\tunsigned long flags;\n\tint zot_me = 0;\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tmr = rds_mr_tree_walk(&rs->rs_rdma_keys, r_key, NULL);\n\tif (!mr) {\n\t\tpr_debug(\"rds: trying to unuse MR with unknown r_key %u!\\n\",\n\t\t\t r_key);\n\t\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\t\treturn;\n\t}\n\tif (mr->r_use_once || force) {\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tzot_me = 1;\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\tif (mr->r_trans->sync_mr)\n\t\tmr->r_trans->sync_mr(mr->r_trans_private, DMA_FROM_DEVICE);\n\tif (zot_me) {\n\t\trds_destroy_mr(mr);\n\t\trds_mr_put(mr);\n\t}\n}", "target": 0}
{"code": "void ContainerNode::recalcChildStyle(StyleRecalcChange change)\n{\n    ASSERT(document().inStyleRecalc());\n    ASSERT(change >= UpdatePseudoElements || childNeedsStyleRecalc());\n    ASSERT(!needsStyleRecalc());\n    if (change < Force && hasRareData() && childNeedsStyleRecalc())\n        checkForChildrenAdjacentRuleChanges();\n    StyleResolver& styleResolver = document().ensureStyleResolver();\n    Text* lastTextNode = nullptr;\n    for (Node* child = lastChild(); child; child = child->previousSibling()) {\n        if (child->isTextNode()) {\n            toText(child)->recalcTextStyle(change, lastTextNode);\n            lastTextNode = toText(child);\n        } else if (child->isElementNode()) {\n            Element* element = toElement(child);\n            if (element->shouldCallRecalcStyle(change))\n                element->recalcStyle(change, lastTextNode);\n            else if (element->supportsStyleSharing())\n                styleResolver.addToStyleSharingList(*element);\n            if (element->layoutObject())\n                lastTextNode = nullptr;\n        }\n    }\n}", "target": 0}
{"code": "static MagickBooleanType ClonePixelCacheOnDisk(\n  CacheInfo *magick_restrict cache_info,CacheInfo *magick_restrict clone_info)\n{\n  MagickSizeType\n    extent;\n  size_t\n    quantum;\n  ssize_t\n    count;\n  struct stat\n    file_stats;\n  unsigned char\n    *buffer;\n  if ((OpenPixelCacheOnDisk(cache_info,ReadMode) == MagickFalse) ||\n      (OpenPixelCacheOnDisk(clone_info,IOMode) == MagickFalse))\n    return(MagickFalse);\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(cache_info->file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  buffer=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  extent=0;\n  while ((count=read(cache_info->file,buffer,quantum)) > 0)\n  {\n    ssize_t\n      number_bytes;\n    number_bytes=write(clone_info->file,buffer,(size_t) count);\n    if (number_bytes != count)\n      break;\n    extent+=number_bytes;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  if (extent != cache_info->length)\n    return(MagickFalse);\n  return(MagickTrue);\n}", "target": 0}
{"code": "void SVGDocumentExtensions::clearHasPendingResourcesIfPossible(Element* element)\n{\n    if (!isElementPendingResources(element))\n        element->clearHasPendingResources();\n}", "target": 0}
{"code": "static inline zend_object_value date_object_new_date_ex(zend_class_entry *class_type, php_date_obj **ptr TSRMLS_DC)\n{\n\tphp_date_obj *intern;\n\tzend_object_value retval;\n\tintern = emalloc(sizeof(php_date_obj));\n\tmemset(intern, 0, sizeof(php_date_obj));\n\tif (ptr) {\n\t\t*ptr = intern;\n\t}\n\tzend_object_std_init(&intern->std, class_type TSRMLS_CC);\n\tobject_properties_init(&intern->std, class_type);\n\tretval.handle = zend_objects_store_put(intern, (zend_objects_store_dtor_t)zend_objects_destroy_object, (zend_objects_free_object_storage_t) date_object_free_storage_date, NULL TSRMLS_CC);\n\tretval.handlers = &date_object_handlers_date;\n\treturn retval;", "target": 0}
{"code": "GF_Err gf_swf_read_header(SWFReader *read)\n{\n\tSWFRec rc;\n\tu8 sig[3];\n\tsig[0] = gf_bs_read_u8(read->bs);\n\tsig[1] = gf_bs_read_u8(read->bs);\n\tsig[2] = gf_bs_read_u8(read->bs);\n\tif ( ((sig[0] != 'F') && (sig[0] != 'C')) || (sig[1] != 'W') || (sig[2] != 'S') ) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tgf_bs_read_u8(read->bs);\n\tread->length = swf_get_32(read);\n\tif (sig[0] == 'C') {\n\t\tswf_init_decompress(read);\n\t\tif (!read->bs) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tswf_get_rec(read, &rc);\n\tread->width = rc.w;\n\tread->height = rc.h;\n\tswf_align(read);\n\tread->frame_rate = swf_get_16(read)>>8;\n\tread->frame_count = swf_get_16(read);\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"SWF Import - Scene Size %gx%g - %d frames @ %d FPS\\n\", read->width, read->height, read->frame_count, read->frame_rate));\n\tif (!read->frame_rate) read->frame_rate = 1;\n\treturn GF_OK;\n}", "target": 0}
{"code": "Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {\n  if (array_klasses_acquire() == NULL) {\n    if (or_null) return NULL;\n    ResourceMark rm;\n    JavaThread *jt = (JavaThread *)THREAD;\n    {\n      MutexLocker mc(Compile_lock, THREAD);   \n      MutexLocker ma(MultiArray_lock, THREAD);\n      if (array_klasses() == NULL) {\n        Klass*    k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n        release_set_array_klasses(k);\n      }\n    }\n  }\n  ObjArrayKlass* oak = (ObjArrayKlass*)array_klasses();\n  if (or_null) {\n    return oak->array_klass_or_null(n);\n  }\n  return oak->array_klass(n, THREAD);\n}", "target": 0}
{"code": "static int asymmetric_key_match(const struct key *key,\nstatic int asymmetric_key_cmp(const struct key *key,\n\t\t\t      const struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "void calc_group_buffer(TMP_TABLE_PARAM *param, ORDER *group)\n{\n  uint key_length=0, parts=0, null_parts=0;\n  for (; group ; group=group->next)\n  {\n    Item *group_item= *group->item;\n    Field *field= group_item->get_tmp_table_field();\n    if (field)\n    {\n      enum_field_types type;\n      if ((type= field->type()) == MYSQL_TYPE_BLOB)\n\tkey_length+=MAX_BLOB_WIDTH;\t\t\n      else if (type == MYSQL_TYPE_VARCHAR || type == MYSQL_TYPE_VAR_STRING)\n        key_length+= field->field_length + HA_KEY_BLOB_LENGTH;\n      else if (type == MYSQL_TYPE_BIT)\n      {\n        key_length+= 8;                         \n      }\n      else\n\tkey_length+= field->pack_length();\n    }\n    else\n    { \n      switch (group_item->cmp_type()) {\n      case REAL_RESULT:\n        key_length+= sizeof(double);\n        break;\n      case INT_RESULT:\n        key_length+= sizeof(longlong);\n        break;\n      case DECIMAL_RESULT:\n        key_length+= my_decimal_get_binary_size(group_item->max_length - \n                                                (group_item->decimals ? 1 : 0),\n                                                group_item->decimals);\n        break;\n      case TIME_RESULT:\n      {\n        key_length+= 8;\n        break;\n      }\n      case STRING_RESULT:\n      {\n        enum enum_field_types type= group_item->field_type();\n        if (type == MYSQL_TYPE_BLOB)\n          key_length+= MAX_BLOB_WIDTH;\t\t\n        else\n        {\n          key_length+= group_item->max_length + HA_KEY_BLOB_LENGTH;\n        }\n        break;\n      }\n      default:\n        DBUG_ASSERT(0);\n        my_error(ER_OUT_OF_RESOURCES, MYF(ME_FATALERROR));\n      }\n    }\n    parts++;\n    if (group_item->maybe_null)\n      null_parts++;\n  }\n  param->group_length= key_length + null_parts;\n  param->group_parts= parts;\n  param->group_null_parts= null_parts;\n}", "target": 0}
{"code": "  String_Obj Parser::parse_string()\n  {\n    return parse_interpolated_chunk(Token(lexed));\n  }", "target": 0}
{"code": "static int spl_array_has_property(zval *object, zval *member, int has_set_exists, const zend_literal *key TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tif ((intern->ar_flags & SPL_ARRAY_ARRAY_AS_PROPS) != 0\n\t&& !std_object_handlers.has_property(object, member, 2, key TSRMLS_CC)) {\n\t\treturn spl_array_has_dimension(object, member, has_set_exists TSRMLS_CC);\n\t}\n\treturn std_object_handlers.has_property(object, member, has_set_exists, key TSRMLS_CC);\n} ", "target": 0}
{"code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n        methnum = ap_method_number_of(method);\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            if (cmd->pool == cmd->temp_pool) {\n                return apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n                                   \"for %s from .htaccess configuration\",\n                                    method, cmd->cmd->name);\n            }\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n    limited = tog ? ~limited : limited;\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n    cmd->limited &= limited;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n    cmd->limited = old_limited;\n    return errmsg;\n}", "target": 0}
{"code": "int64_t Document::UkmSourceID() const {\n  DCHECK(ukm_recorder_);\n  return ukm_source_id_;\n}", "target": 0}
{"code": "  HeaderMap::GetResult getAll(const LowerCaseString& key) const override {\n    return header_map_->getAll(key);\n  }", "target": 0}
{"code": "void ciEnv::cache_jvmti_state() {\n  VM_ENTRY_MARK;\n  MutexLocker mu(JvmtiThreadState_lock);\n  _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint();\n  _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables();\n  _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions();\n  _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame();\n  _jvmti_can_get_owned_monitor_info     = JvmtiExport::can_get_owned_monitor_info();\n}", "target": 0}
{"code": "connect_to_upstream (struct conn_s *connptr, struct request_s *request)\n{\n#ifndef UPSTREAM_SUPPORT\n        return -1;\n#else\n        char *combined_string;\n        int len;\n        struct upstream *cur_upstream = connptr->upstream_proxy;\n        if (!cur_upstream) {\n                log_message (LOG_WARNING,\n                             \"No upstream proxy defined for %s.\",\n                             request->host);\n                indicate_http_error (connptr, 502,\n                                     \"Unable to connect to upstream proxy.\");\n                return -1;\n        }\n        connptr->server_fd =\n            opensock (cur_upstream->host, cur_upstream->port,\n                      connptr->server_ip_addr);\n        if (connptr->server_fd < 0) {\n                log_message (LOG_WARNING,\n                             \"Could not connect to upstream proxy.\");\n                indicate_http_error (connptr, 502,\n                                     \"Unable to connect to upstream proxy\",\n                                     \"detail\",\n                                     \"A network error occurred while trying to \"\n                                     \"connect to the upstream web proxy.\",\n                                     NULL);\n                return -1;\n        }\n\tif (cur_upstream->type != PT_HTTP)\n\t\treturn connect_to_upstream_proxy(connptr, request);\n        log_message (LOG_CONN,\n                     \"Established connection to upstream proxy \\\"%s\\\" \"\n                     \"using file descriptor %d.\",\n                     cur_upstream->host, connptr->server_fd);\n        if (connptr->connect_method) {\n                len = strlen (request->host) + 7;\n                combined_string = (char *) safemalloc (len);\n                if (!combined_string) {\n                        return -1;\n                }\n                snprintf (combined_string, len, \"%s:%d\", request->host,\n                          request->port);\n        } else {\n                len = strlen (request->host) + strlen (request->path) + 14;\n                combined_string = (char *) safemalloc (len);\n                if (!combined_string) {\n                        return -1;\n                }\n                snprintf (combined_string, len, \"http:\n                          request->port, request->path);\n        }\n        if (request->path)\n                safefree (request->path);\n        request->path = combined_string;\n        return establish_http_connection (connptr, request);\n#endif\n}", "target": 0}
{"code": "    void printNode(const std::string& schemaNs,\n                   const std::string& propPath,\n                   const std::string& propValue,\n                   const XMP_OptionBits& opt)\n    {\n        static bool first = true;\n        if (first) {\n            first = false;\n            std::cout << \"ashisabsals\\n\"\n                      << \"lcqqtrgqlai\\n\";\n        }\n        enum { alia=0, sche, hasq, isqu, stru, arra,\n               abag, aseq, aalt, lang, simp, len };\n        std::string opts(len, '.');\n        if (XMP_PropIsAlias(opt))       opts[alia] = 'X';\n        if (XMP_NodeIsSchema(opt))      opts[sche] = 'X';\n        if (XMP_PropHasQualifiers(opt)) opts[hasq] = 'X';\n        if (XMP_PropIsQualifier(opt))   opts[isqu] = 'X';\n        if (XMP_PropIsStruct(opt))      opts[stru] = 'X';\n        if (XMP_PropIsArray(opt))       opts[arra] = 'X';\n        if (XMP_ArrayIsUnordered(opt))  opts[abag] = 'X';\n        if (XMP_ArrayIsOrdered(opt))    opts[aseq] = 'X';\n        if (XMP_ArrayIsAlternate(opt))  opts[aalt] = 'X';\n        if (XMP_ArrayIsAltText(opt))    opts[lang] = 'X';\n        if (XMP_PropIsSimple(opt))      opts[simp] = 'X';\n        std::cout << opts << \" \";\n        if (opts[sche] == 'X') {\n            std::cout << \"ns=\" << schemaNs;\n        }\n        else {\n            std::cout << propPath << \" = \" << propValue;\n        }\n        std::cout << std::endl;\n    }", "target": 0}
{"code": "ProcGrabServer(ClientPtr client)\n{\n    int rc;\n    REQUEST_SIZE_MATCH(xReq);\n    if (grabState != GrabNone && client != grabClient) {\n        ResetCurrentRequest(client);\n        client->sequence--;\n        BITSET(grabWaiters, client->index);\n        IgnoreClient(client);\n        return Success;\n    }\n    rc = OnlyListenToOneClient(client);\n    if (rc != Success)\n        return rc;\n    grabState = GrabKickout;\n    grabClient = client;\n    if (ServerGrabCallback) {\n        ServerGrabInfoRec grabinfo;\n        grabinfo.client = client;\n        grabinfo.grabstate = SERVER_GRABBED;\n        CallCallbacks(&ServerGrabCallback, (void *) &grabinfo);\n    }\n    return Success;\n}", "target": 0}
{"code": "gather_context_independent_values (class ipa_node_params *info,\n\t\t\t\t   vec<tree> *known_csts,\n\t\t\t\t   vec<ipa_polymorphic_call_context>\n\t\t\t\t   *known_contexts,\n\t\t\t\t   vec<ipa_agg_value_set> *known_aggs,\n\t\t\t\t   int *removable_params_cost)\n{\n  int i, count = ipa_get_param_count (info);\n  bool ret = false;\n  known_csts->create (0);\n  known_contexts->create (0);\n  known_csts->safe_grow_cleared (count);\n  known_contexts->safe_grow_cleared (count);\n  if (known_aggs)\n    {\n      known_aggs->create (0);\n      known_aggs->safe_grow_cleared (count);\n    }\n  if (removable_params_cost)\n    *removable_params_cost = 0;\n  for (i = 0; i < count; i++)\n    {\n      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n      ipcp_lattice<tree> *lat = &plats->itself;\n      if (lat->is_single_const ())\n\t{\n\t  ipcp_value<tree> *val = lat->values;\n\t  gcc_checking_assert (TREE_CODE (val->value) != TREE_BINFO);\n\t  (*known_csts)[i] = val->value;\n\t  if (removable_params_cost)\n\t    *removable_params_cost\n\t      += estimate_move_cost (TREE_TYPE (val->value), false);\n\t  ret = true;\n\t}\n      else if (removable_params_cost\n\t       && !ipa_is_param_used (info, i))\n\t*removable_params_cost\n\t  += ipa_get_param_move_cost (info, i);\n      if (!ipa_is_param_used (info, i))\n\tcontinue;\n      ipcp_lattice<ipa_polymorphic_call_context> *ctxlat = &plats->ctxlat;\n      if (ctxlat->is_single_const ())\n\t(*known_contexts)[i] = ctxlat->values->value;\n      if (known_aggs)\n\t{\n\t  vec<ipa_agg_value> agg_items;\n\t  struct ipa_agg_value_set *agg;\n\t  agg_items = context_independent_aggregate_values (plats);\n\t  agg = &(*known_aggs)[i];\n\t  agg->items = agg_items;\n\t  agg->by_ref = plats->aggs_by_ref;\n\t  ret |= !agg_items.is_empty ();\n\t}\n    }\n  return ret;\n}", "target": 0}
{"code": "void JSArray::checkConsistency(ConsistencyCheckType type)\n{\n    ArrayStorage* storage = m_storage;\n    ASSERT(storage);\n    if (type == SortConsistencyCheck)\n        ASSERT(!storage->m_sparseValueMap);\n    unsigned numValuesInVector = 0;\n    for (unsigned i = 0; i < m_vectorLength; ++i) {\n        if (JSValue value = storage->m_vector[i]) {\n            ASSERT(i < storage->m_length);\n            if (type != DestructorConsistencyCheck)\n                value.isUndefined(); \n            ++numValuesInVector;\n        } else {\n            if (type == SortConsistencyCheck)\n                ASSERT(i >= storage->m_numValuesInVector);\n        }\n    }\n    ASSERT(numValuesInVector == storage->m_numValuesInVector);\n    ASSERT(numValuesInVector <= storage->m_length);\n    if (storage->m_sparseValueMap) {\n        SparseArrayValueMap::iterator end = storage->m_sparseValueMap->end();\n        for (SparseArrayValueMap::iterator it = storage->m_sparseValueMap->begin(); it != end; ++it) {\n            unsigned index = it->first;\n            ASSERT(index < storage->m_length);\n            ASSERT(index >= storage->m_vectorLength);\n            ASSERT(index <= MAX_ARRAY_INDEX);\n            ASSERT(it->second);\n            if (type != DestructorConsistencyCheck)\n                it->second.isUndefined(); \n        }\n    }\n}", "target": 0}
{"code": "void do_system(struct st_command *command)\n{\n  DYNAMIC_STRING ds_cmd;\n  DBUG_ENTER(\"do_system\");\n  if (strlen(command->first_argument) == 0)\n  {\n    report_or_die(\"Missing arguments to system, nothing to do!\");\n    return;\n  }\n  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);\n  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);\n#ifdef __WIN__\n#ifndef USE_CYGWIN\n   while(replace(&ds_cmd, \"/dev/null\", 9, \"NUL\", 3) == 0)\n     ;\n#endif\n#endif\n  DBUG_PRINT(\"info\", (\"running system command '%s' as '%s'\",\n                      command->first_argument, ds_cmd.str));\n  if (my_system(&ds_cmd))\n  {\n    if (command->abort_on_error)\n      report_or_die(\"system command '%s' failed\", command->first_argument);\n    else\n    {\n      dynstr_append(&ds_res, \"system command '\");\n      replace_dynstr_append(&ds_res, command->first_argument);\n      dynstr_append(&ds_res, \"' failed\\n\");\n    }\n  }\n  command->last_argument= command->end;\n  dynstr_free(&ds_cmd);\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "static void whitelist (global_State *g, GCObject *p) {\n  int white = luaC_white(g);\n  for (; p != NULL; p = p->next)\n    p->marked = cast_byte((p->marked & maskcolors) | white);\n}", "target": 0}
{"code": "static void imdct_and_windowing_eld(AACContext *ac, SingleChannelElement *sce)\n{\n    float *in    = sce->coeffs;\n    float *out   = sce->ret;\n    float *saved = sce->saved;\n    const float *const window = ff_aac_eld_window;\n    float *buf  = ac->buf_mdct;\n    int i;\n    const int n  = 512;\n    const int n2 = n >> 1;\n    const int n4 = n >> 2;\n    for (i = 0; i < n2; i+=2) {\n        float temp;\n        temp =  in[i    ]; in[i    ] = -in[n - 1 - i]; in[n - 1 - i] = temp;\n        temp = -in[i + 1]; in[i + 1] =  in[n - 2 - i]; in[n - 2 - i] = temp;\n    }\n    ac->mdct.imdct_half(&ac->mdct_ld, buf, in);\n    for (i = 0; i < n; i+=2) {\n        buf[i] = -buf[i];\n    }\n    for (i = n4; i < n2; i ++) {\n        out[i - n4] =    buf[n2 - 1 - i]       * window[i       - n4] +\n                       saved[      i + n2]     * window[i +   n - n4] +\n                      -saved[  n + n2 - 1 - i] * window[i + 2*n - n4] +\n                      -saved[2*n + n2 + i]     * window[i + 3*n - n4];\n    }\n    for (i = 0; i < n2; i ++) {\n        out[n4 + i] =    buf[i]               * window[i + n2       - n4] +\n                      -saved[      n - 1 - i] * window[i + n2 +   n - n4] +\n                      -saved[  n + i]         * window[i + n2 + 2*n - n4] +\n                       saved[2*n + n - 1 - i] * window[i + n2 + 3*n - n4];\n    }\n    for (i = 0; i < n4; i ++) {\n        out[n2 + n4 + i] =    buf[      i + n2]     * window[i +   n - n4] +\n                           -saved[      n2 - 1 - i] * window[i + 2*n - n4] +\n                           -saved[  n + n2 + i]     * window[i + 3*n - n4];\n    }\n    memmove(saved + n, saved, 2 * n * sizeof(float));\n    memcpy( saved,       buf,     n * sizeof(float));\n}", "target": 0}
{"code": "str_end_hash(st_data_t xp)\n{\n  const st_str_end_key *x = (const st_str_end_key *)xp;\n  const UChar *p;\n  st_index_t val = 0;\n  p = x->s;\n  while (p < x->end) {\n    val = val * 997 + (int )*p++;\n  }\n  return val + (val >> 5);\n}", "target": 0}
{"code": "irc_server_fingerprint_search_algo_with_size (int size)\n{\n    int i;\n    for (i = 0; i < IRC_FINGERPRINT_NUM_ALGOS; i++)\n    {\n        if (irc_fingerprint_digest_algos_size[i] == size)\n            return i;\n    }\n    return -1;\n}", "target": 0}
{"code": "void WebContentsImpl::DocumentAvailableInMainFrame(\n    RenderViewHost* render_view_host) {\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DocumentAvailableInMainFrame());\n}", "target": 0}
{"code": "RenderObject* HTMLInputElement::createRenderer(RenderStyle* style)\n{\n    return m_inputTypeView->createRenderer(style);\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, MatchAgainstArrayIsCorrect) {\n    createMatcher(fromjson(\"{$expr: {$gt: ['$x', 4]}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << BSON_ARRAY(1.0 << 2.0 << 3.0))));\n    createMatcher(fromjson(\"{$expr: {$eq: ['$x', [4]]}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << BSON_ARRAY(4))));\n    ASSERT_FALSE(matches(BSON(\"x\" << 4)));\n}", "target": 0}
{"code": "static void con_flush(struct vc_data *vc, unsigned long draw_from,\n\t\tunsigned long draw_to, int *draw_x)\n{\n\tif (*draw_x < 0)\n\t\treturn;\n\tvc->vc_sw->con_putcs(vc, (u16 *)draw_from,\n\t\t\t(u16 *)draw_to - (u16 *)draw_from, vc->vc_y, *draw_x);\n\t*draw_x = -1;\n}", "target": 0}
{"code": "bool CellularNetwork::is_gsm() const {\n  return network_technology_ != NETWORK_TECHNOLOGY_EVDO &&\n      network_technology_ != NETWORK_TECHNOLOGY_1XRTT &&\n      network_technology_ != NETWORK_TECHNOLOGY_UNKNOWN;\n}", "target": 0}
{"code": "void ciEnv::validate_compile_task_dependencies(ciMethod* target) {\n  if (failing())  return;  \n  Dependencies::DepType result = dependencies()->validate_dependencies(_task);\n  if (result != Dependencies::end_marker) {\n    if (result == Dependencies::call_site_target_value) {\n      _inc_decompile_count_on_failure = false;\n      record_failure(\"call site target change\");\n    } else if (Dependencies::is_klass_type(result)) {\n      record_failure(\"concurrent class loading\");\n    } else {\n      record_failure(\"invalid non-klass dependency\");\n    }\n  }\n}", "target": 0}
{"code": "static int generate_key(void)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[4];\n\tu8 p2;\n\tint r;\n\tswitch (opt_mod_length) {\n\tcase 512:\n\t\tp2 = 0x40;\n\t\tbreak;\n\tcase 768:\n\t\tp2 = 0x60;\n\t\tbreak;\n\tcase 1024:\n\t\tp2 = 0x80;\n\t\tbreak;\n\tcase 2048:\n\t\tp2 = 0x00;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"Invalid modulus length.\\n\");\n\t\treturn 2;\n\t}\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, (u8) opt_key_num-1, p2);\n\tapdu.cla = 0xF0;\n\tapdu.lc = 4;\n\tapdu.datalen = 4;\n\tapdu.data = sbuf;\n\tsbuf[0] = opt_exponent & 0xFF;\n\tsbuf[1] = (opt_exponent >> 8) & 0xFF;\n\tsbuf[2] = (opt_exponent >> 16) & 0xFF;\n\tsbuf[3] = (opt_exponent >> 24) & 0xFF;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tif (verbose)\n\t\tprintf(\"Generating key...\\n\");\n\tr = sc_transmit_apdu(card, &apdu);\n\tif (r) {\n\t\tfprintf(stderr, \"APDU transmit failed: %s\\n\", sc_strerror(r));\n\t\tif (r == SC_ERROR_TRANSMIT_FAILED)\n\t\t\tfprintf(stderr, \"Reader has timed out. It is still possible that the key generation has\\n\"\n\t\t\t\t\t\"succeeded.\\n\");\n\t\treturn 1;\n\t}\n\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\tprintf(\"Key generation successful.\\n\");\n\t\treturn 0;\n\t}\n\tif (apdu.sw1 == 0x69 && apdu.sw2 == 0x82)\n\t\tfprintf(stderr, \"CHV1 not verified or invalid exponent value.\\n\");\n\telse\n\t\tfprintf(stderr, \"Card returned SW1=%02X, SW2=%02X.\\n\", apdu.sw1, apdu.sw2);\n\treturn 1;\n}", "target": 0}
{"code": "static int __init af_unix_init(void)\n{\n\tint rc = -1;\n\tBUILD_BUG_ON(sizeof(struct unix_skb_parms) > FIELD_SIZEOF(struct sk_buff, cb));\n\trc = proto_register(&unix_proto, 1);\n\tif (rc != 0) {\n\t\tpr_crit(\"%s: Cannot create unix_sock SLAB cache!\\n\", __func__);\n\t\tgoto out;\n\t}\n\tsock_register(&unix_family_ops);\n\tregister_pernet_subsys(&unix_net_ops);\nout:\n\treturn rc;\n}", "target": 0}
{"code": "static int req_crit(lua_State *L)\n{\n    return req_log_at(L, APLOG_CRIT);\n}", "target": 0}
{"code": "PERL_STATIC_INLINE void\nS_ssc_cp_and(pTHX_ regnode_ssc *ssc, const UV cp)\n{\n    SV* cp_list = _new_invlist(2);\n    PERL_ARGS_ASSERT_SSC_CP_AND;\n    assert(is_ANYOF_SYNTHETIC(ssc));\n    cp_list = add_cp_to_invlist(cp_list, cp);\n    ssc_intersection(ssc, cp_list,\n                     FALSE \n                     );\n    SvREFCNT_dec_NN(cp_list);", "target": 0}
{"code": "  virtual int lock() { return 1; } ", "target": 0}
{"code": "static int nl80211_dump_survey(struct sk_buff *skb,\n\t\t\tstruct netlink_callback *cb)\n{\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tint survey_idx = cb->args[1];\n\tint res;\n\tres = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (res)\n\t\treturn res;\n\tif (!dev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\twhile (1) {\n\t\tstruct ieee80211_channel *chan;\n\t\tres = rdev_dump_survey(dev, netdev, survey_idx, &survey);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\t\tif (!survey.channel) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tchan = ieee80211_get_channel(&dev->wiphy,\n\t\t\t\t\t     survey.channel->center_freq);\n\t\tif (!chan || chan->flags & IEEE80211_CHAN_DISABLED) {\n\t\t\tsurvey_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\tnetdev,\n\t\t\t\t&survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n out:\n\tcb->args[1] = survey_idx;\n\tres = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\treturn res;\n}", "target": 0}
{"code": "TEST(ArrayOpsTest, QuantizeAndDequantizeV2_ShapeFn) {\n  ShapeInferenceTestOp op(\"QuantizeAndDequantizeV2\");\n  op.input_tensors.resize(3);\n  TF_ASSERT_OK(NodeDefBuilder(\"test\", \"QuantizeAndDequantizeV2\")\n                   .Input(\"input\", 0, DT_FLOAT)\n                   .Input(\"input_min\", 1, DT_FLOAT)\n                   .Input(\"input_max\", 2, DT_FLOAT)\n                   .Attr(\"signed_input\", true)\n                   .Attr(\"num_bits\", 8)\n                   .Attr(\"range_given\", false)\n                   .Attr(\"narrow_range\", false)\n                   .Attr(\"axis\", -1)\n                   .Finalize(&op.node_def));\n  INFER_OK(op, \"?;?;?\", \"in0\");\n  INFER_OK(op, \"[];?;?\", \"in0\");\n  INFER_OK(op, \"[1,2,?,4,5];?;?\", \"in0\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[]\");\n  INFER_ERROR(\"Shapes must be equal rank, but are 1 and 0\", op,\n              \"[1,2,?,4,5];[];[1]\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[1]\");\n  (*op.node_def.mutable_attr())[\"axis\"].set_i(-2);\n  INFER_ERROR(\"axis should be at least -1, got -2\", op, \"?;?;?\");\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, FloatingPointInKeyPattern) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n    addIndex(BSON(\"a\" << -0.1));\n    runQuerySortProj(fromjson(\"{a: {$gte: 3, $lte: 5}}\"), fromjson(\"{a: 1}\"), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a: -0.1}, \"\n        \"bounds: {a: [[3, 5, true, true]]}}}}}\");\n}", "target": 0}
{"code": "static bool shm_may_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\treturn (shp->shm_nattch == 0) &&\n\t       (ns->shm_rmid_forced ||\n\t\t(shp->shm_perm.mode & SHM_DEST));\n}", "target": 0}
{"code": "SPICE_GNUC_VISIBLE int spice_server_set_ticket(SpiceServer *reds,\n                                               const char *passwd, int lifetime,\n                                               int fail_if_connected,\n                                               int disconnect_if_connected)\n{\n    if (reds_main_channel_connected(reds)) {\n        if (fail_if_connected) {\n            return -1;\n        }\n        if (disconnect_if_connected) {\n            reds_disconnect(reds);\n        }\n    }\n    on_activating_ticketing(reds);\n    reds->config->ticketing_enabled = TRUE;\n    if (lifetime == 0) {\n        reds->config->taTicket.expiration_time = INT_MAX;\n    } else {\n        time_t now = spice_get_monotonic_time_ns() / NSEC_PER_SEC;\n        reds->config->taTicket.expiration_time = now + lifetime;\n    }\n    if (passwd != NULL) {\n        if (strlen(passwd) > SPICE_MAX_PASSWORD_LENGTH)\n            return -1;\n        g_strlcpy(reds->config->taTicket.password, passwd, sizeof(reds->config->taTicket.password));\n    } else {\n        memset(reds->config->taTicket.password, 0, sizeof(reds->config->taTicket.password));\n        reds->config->taTicket.expiration_time = 0;\n    }\n    return 0;\n}", "target": 0}
{"code": "    void TiffCreator::getPath(TiffPath& tiffPath,\n                              uint32_t  extendedTag,\n                              IfdId     group,\n                              uint32_t  root)\n    {\n        const TiffTreeStruct* ts = 0;\n        do {\n            tiffPath.push(TiffPathItem(extendedTag, group));\n            ts = find(tiffTreeStruct_, TiffTreeStruct::Key(root, group));\n            assert(ts != 0);\n            extendedTag = ts->parentExtTag_;\n            group = ts->parentGroup_;\n        } while (!(ts->root_ == root && ts->group_ == ifdIdNotSet));\n    } ", "target": 0}
{"code": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint err;\n\tstruct sock_diag_req *req = nlmsg_data(nlh);\n\tconst struct sock_diag_handler *hndl;\n\tif (nlmsg_len(nlh) < sizeof(*req))\n\t\treturn -EINVAL;\n\tif (req->sdiag_family >= AF_MAX)\n\t\treturn -EINVAL;\n\thndl = sock_diag_lock_handler(req->sdiag_family);\n\tif (hndl == NULL)\n\t\terr = -ENOENT;\n\telse\n\t\terr = hndl->dump(skb, nlh);\n\tsock_diag_unlock_handler(hndl);\n\treturn err;\n}", "target": 0}
{"code": "void ParamTraits<unsigned short>::Log(const param_type& p, std::string* l) {\n  l->append(base::UintToString(p));\n}", "target": 0}
{"code": "static void coroutine_fn virtfs_reset(V9fsPDU *pdu)\n{\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp = NULL;\n    while (s->fid_list) {\n        fidp = s->fid_list;\n        s->fid_list = fidp->next;\n        if (fidp->ref) {\n            fidp->clunked = 1;\n        } else {\n            free_fid(pdu, fidp);\n        }\n    }\n    if (fidp) {\n        error_report(\"9pfs:%s: One or more uncluncked fids \"\n                     \"found during reset\", __func__);\n    }\n}", "target": 0}
{"code": "void HTMLFormControlElement::setNeedsValidityCheck()\n{\n    bool newIsValid = valid();\n    if (willValidate() && newIsValid != m_isValid) {\n        setNeedsStyleRecalc();\n    }\n    m_isValid = newIsValid;\n    if (m_validationMessage && m_validationMessage->isVisible()) {\n        updateVisibleValidationMessage();\n    }\n}", "target": 0}
{"code": "void intel_execlists_set_default_submission(struct intel_engine_cs *engine)\n{\n\tengine->submit_request = execlists_submit_request;\n\tengine->cancel_requests = execlists_cancel_requests;\n\tengine->schedule = i915_schedule;\n\tengine->execlists.tasklet.func = execlists_submission_tasklet;\n\tengine->reset.prepare = execlists_reset_prepare;\n\tengine->reset.reset = execlists_reset;\n\tengine->reset.finish = execlists_reset_finish;\n\tengine->park = execlists_park;\n\tengine->unpark = NULL;\n\tengine->flags |= I915_ENGINE_SUPPORTS_STATS;\n\tif (!intel_vgpu_active(engine->i915)) {\n\t\tengine->flags |= I915_ENGINE_HAS_SEMAPHORES;\n\t\tif (HAS_LOGICAL_RING_PREEMPTION(engine->i915))\n\t\t\tengine->flags |= I915_ENGINE_HAS_PREEMPTION;\n\t}\n\tif (INTEL_GEN(engine->i915) >= 12)\n\t\tengine->flags |= I915_ENGINE_HAS_RELATIVE_MMIO;\n}", "target": 0}
{"code": "int LibRaw_file_datastream::valid() { return f.get() ? 1 : 0; }", "target": 0}
{"code": "finish_output_bmp (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  bmp_dest_ptr dest = (bmp_dest_ptr) dinfo;\n  register FILE *outfile = dest->pub.output_file;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW data_ptr;\n  JDIMENSION row;\n  register JDIMENSION col;\n  cd_progress_ptr progress = (cd_progress_ptr) cinfo->progress;\n  if (dest->use_inversion_array) {\n    if (dest->is_os2)\n      write_os2_header(cinfo, dest);\n    else\n      write_bmp_header(cinfo, dest);\n    for (row = cinfo->output_height; row > 0; row--) {\n      if (progress != NULL) {\n        progress->pub.pass_counter = (long) (cinfo->output_height - row);\n        progress->pub.pass_limit = (long) cinfo->output_height;\n        (*progress->pub.progress_monitor) ((j_common_ptr) cinfo);\n      }\n      image_ptr = (*cinfo->mem->access_virt_sarray)\n        ((j_common_ptr) cinfo, dest->whole_image, row-1, (JDIMENSION) 1, FALSE);\n      data_ptr = image_ptr[0];\n      for (col = dest->row_width; col > 0; col--) {\n        putc(GETJSAMPLE(*data_ptr), outfile);\n        data_ptr++;\n      }\n    }\n    if (progress != NULL)\n      progress->completed_extra_passes++;\n  }\n  fflush(outfile);\n  if (ferror(outfile))\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n}", "target": 0}
{"code": "njs_typed_array_writable(njs_vm_t *vm, njs_typed_array_t *array)\n{\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    buffer = array->buffer;\n    if (njs_slow_path(njs_is_detached_buffer(buffer))) {\n        njs_type_error(vm, \"detached buffer\");\n        return NULL;\n    }\n    ret = njs_array_buffer_writable(vm, buffer);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n    return buffer;\n}", "target": 0}
{"code": "ospf_ls_req_event (struct ospf_neighbor *nbr)\n{\n  if (nbr->t_ls_req)\n    {\n      thread_cancel (nbr->t_ls_req);\n      nbr->t_ls_req = NULL;\n    }\n  nbr->t_ls_req = thread_add_event (master, ospf_ls_req_timer, nbr, 0);\n}", "target": 0}
{"code": "assegment_count_asns (struct assegment *seg, int from)\n{\n  int count = 0;\n  while (seg)\n    {\n      if (!from)\n        count += seg->length;\n      else\n        {\n          count += (seg->length - from);\n          from = 0;\n        }\n      seg = seg->next;\n    }\n  return count;\n}", "target": 0}
{"code": "static struct ipmi_recv_msg *ipmi_alloc_recv_msg(void)\n{\n\tstruct ipmi_recv_msg *rv;\n\trv = kmalloc(sizeof(struct ipmi_recv_msg), GFP_ATOMIC);\n\tif (rv) {\n\t\trv->user = NULL;\n\t\trv->done = free_recv_msg;\n\t\tatomic_inc(&recv_msg_inuse_count);\n\t}\n\treturn rv;\n}", "target": 0}
{"code": "vte_sequence_handler_dl (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tlong start, end, param, i;\n\tGValue *value;\n\tscreen = terminal->pvt->screen;\n\tstart = screen->cursor_current.row;\n\tif (screen->scrolling_restricted) {\n\t\tend = screen->insert_delta + screen->scrolling_region.end;\n\t} else {\n\t\tend = screen->insert_delta + terminal->row_count - 1;\n\t}\n\tparam = 1;\n\tif ((params != NULL) && (params->n_values > 0)) {\n\t\tvalue = g_value_array_get_nth(params, 0);\n\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\tparam = g_value_get_long(value);\n\t\t}\n\t}\n\tfor (i = 0; i < param; i++) {\n\t\t_vte_terminal_ring_remove (terminal, start);\n\t\t_vte_terminal_ring_insert (terminal, end, TRUE);\n\t\t_vte_terminal_adjust_adjustments(terminal);\n\t}\n\t_vte_terminal_scroll_region(terminal, start, end - start + 1, -param);\n\tterminal->pvt->text_deleted_flag = TRUE;\n}", "target": 0}
{"code": "static int l2cap_mode_supported(__u8 mode, __u32 feat_mask)\n{\n\tu32 local_feat_mask = l2cap_feat_mask;\n\tif (enable_ertm)\n\t\tlocal_feat_mask |= L2CAP_FEAT_ERTM;\n\tswitch (mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\treturn L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}", "target": 0}
{"code": "bool EditorClientBlackBerry::canPaste(Frame*, bool defaultValue) const\n{\n    return defaultValue;\n}", "target": 0}
{"code": "static int sc_pkcs15emu_sc_hsm_get_rsa_public_key(struct sc_context *ctx, sc_cvc_t *cvc, struct sc_pkcs15_pubkey *pubkey)\n{\n\tpubkey->algorithm = SC_ALGORITHM_RSA;\n\tpubkey->alg_id = (struct sc_algorithm_id *)calloc(1, sizeof(struct sc_algorithm_id));\n\tif (!pubkey->alg_id)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\tpubkey->alg_id->algorithm = SC_ALGORITHM_RSA;\n\tpubkey->u.rsa.modulus.len\t= cvc->primeOrModuluslen;\n\tpubkey->u.rsa.modulus.data\t= malloc(pubkey->u.rsa.modulus.len);\n\tpubkey->u.rsa.exponent.len\t= cvc->coefficientAorExponentlen;\n\tpubkey->u.rsa.exponent.data\t= malloc(pubkey->u.rsa.exponent.len);\n\tif (!pubkey->u.rsa.modulus.data || !pubkey->u.rsa.exponent.data)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\tmemcpy(pubkey->u.rsa.exponent.data, cvc->coefficientAorExponent, pubkey->u.rsa.exponent.len);\n\tmemcpy(pubkey->u.rsa.modulus.data, cvc->primeOrModulus, pubkey->u.rsa.modulus.len);\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "  template<typename T>\n  inline CImg<_cimg_Tfloat> sqr(const CImg<T>& instance) {\n    return instance.get_sqr();", "target": 0}
{"code": "int InlineTextBox::selectionTop()\n{\n    return root()->selectionTop();\n}", "target": 0}
{"code": "ofpact_hdrs_hash(const struct ofpact_hdrs *hdrs)\n{\n    return hash_2words(hdrs->vendor,\n                       ((uint32_t) hdrs->type << 16) | hdrs->ofp_version);\n}", "target": 0}
{"code": "static ssize_t ctor_show(struct kmem_cache *s, char *buf)\n{\n\tif (!s->ctor)\n\t\treturn 0;\n\treturn sprintf(buf, \"%pS\\n\", s->ctor);\n}", "target": 0}
{"code": "    StringValueBase& StringValueBase::operator=(const StringValueBase& rhs)\n    {\n        if (this == &rhs) return *this;\n        Value::operator=(rhs);\n        value_ = rhs.value_;\n        return *this;\n    }", "target": 0}
{"code": "PHP_MSHUTDOWN_FUNCTION(date)\n{\n\tUNREGISTER_INI_ENTRIES();\n\tif (DATEG(last_errors)) {\n\t\ttimelib_error_container_dtor(DATEG(last_errors));\n\t}\n\treturn SUCCESS;", "target": 0}
{"code": "void FrameLoader::load(const ResourceRequest& request, bool lockHistory)\n{\n    load(request, SubstituteData(), lockHistory);\n}", "target": 0}
{"code": "archive_read_format_rar_has_encrypted_entries(struct archive_read *_a)\n{\n\tif (_a && _a->format) {\n\t\tstruct rar * rar = (struct rar *)_a->format->data;\n\t\tif (rar) {\n\t\t\treturn rar->has_encrypted_entries;\n\t\t}\n\t}\n\treturn ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n}", "target": 0}
{"code": "XML_GetFeatureList(void) {\n  static const XML_Feature features[] = {\n      {XML_FEATURE_SIZEOF_XML_CHAR, XML_L(\"sizeof(XML_Char)\"),\n       sizeof(XML_Char)},\n      {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L(\"sizeof(XML_LChar)\"),\n       sizeof(XML_LChar)},\n#ifdef XML_UNICODE\n      {XML_FEATURE_UNICODE, XML_L(\"XML_UNICODE\"), 0},\n#endif\n#ifdef XML_UNICODE_WCHAR_T\n      {XML_FEATURE_UNICODE_WCHAR_T, XML_L(\"XML_UNICODE_WCHAR_T\"), 0},\n#endif\n#ifdef XML_DTD\n      {XML_FEATURE_DTD, XML_L(\"XML_DTD\"), 0},\n#endif\n#ifdef XML_CONTEXT_BYTES\n      {XML_FEATURE_CONTEXT_BYTES, XML_L(\"XML_CONTEXT_BYTES\"),\n       XML_CONTEXT_BYTES},\n#endif\n#ifdef XML_MIN_SIZE\n      {XML_FEATURE_MIN_SIZE, XML_L(\"XML_MIN_SIZE\"), 0},\n#endif\n#ifdef XML_NS\n      {XML_FEATURE_NS, XML_L(\"XML_NS\"), 0},\n#endif\n#ifdef XML_LARGE_SIZE\n      {XML_FEATURE_LARGE_SIZE, XML_L(\"XML_LARGE_SIZE\"), 0},\n#endif\n#ifdef XML_ATTR_INFO\n      {XML_FEATURE_ATTR_INFO, XML_L(\"XML_ATTR_INFO\"), 0},\n#endif\n#ifdef XML_DTD\n      {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n       XML_L(\"XML_BLAP_MAX_AMP\"),\n       (long int)\n           EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT},\n      {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT,\n       XML_L(\"XML_BLAP_ACT_THRES\"),\n       EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT},\n#endif\n      {XML_FEATURE_END, NULL, 0}};\n  return features;\n}", "target": 0}
{"code": "void PDFiumEngine::OnGetPasswordComplete(int32_t result,\n                                         const pp::Var& password) {\n  getting_password_ = false;\n  std::string password_text;\n  if (result == PP_OK && password.is_string())\n    password_text = password.AsString();\n  ContinueLoadingDocument(password_text);\n}", "target": 0}
{"code": "static int nfs4_xdr_dec_fsinfo(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       struct nfs4_fsinfo_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (!status)\n\t\tstatus = decode_putfh(xdr);\n\tif (!status)\n\t\tstatus = decode_fsinfo(xdr, res->fsinfo);\n\treturn status;\n}", "target": 0}
{"code": "android::SoftOMXComponent *createSoftOMXComponent(\n const char *name, const OMX_CALLBACKTYPE *callbacks,\n        OMX_PTR appData, OMX_COMPONENTTYPE **component) {\n return new android::SoftVPXEncoder(name, callbacks, appData, component);\n}", "target": 0}
{"code": "    constexpr uint32_t SigmaMnHeader::sizeOfSignature()\n    {\n        static_assert(sizeof(signature1_) == sizeof(signature2_), \"Signatures must be of same size\");\n        return sizeof(signature1_);\n    }", "target": 0}
{"code": "  void Init(const std::string& mime_type) {\n    BrowserThread::PostTask(\n        BrowserThread::IO,\n        FROM_HERE,\n        base::Bind(&Context::InitOnIOThread, this, mime_type));\n    BrowserThread::PostDelayedTask(\n        BrowserThread::IO,\n        FROM_HERE,\n        base::Bind(&Context::OnTimeout, this),\n        base::TimeDelta::FromMilliseconds(kRemovalTimeoutMs));\n  }", "target": 0}
{"code": "size_t IOBuf::goodExtBufferSize(std::size_t minCapacity) {\n  if (minCapacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t minSize = static_cast<size_t>(minCapacity) + sizeof(SharedInfo);\n  minSize = (minSize + 7) & ~7;\n  return goodMallocSize(minSize);\n}", "target": 0}
{"code": "gs_errorname(i_ctx_t *i_ctx_p, int code, ref * perror_name)\n{\n    ref *perrordict, *pErrorNames;\n    if (dict_find_string(systemdict, \"errordict\", &perrordict) <= 0 ||\n        dict_find_string(systemdict, \"ErrorNames\", &pErrorNames) <= 0\n        )\n        return_error(gs_error_undefined);      \n    return array_get(imemory, pErrorNames, (long)(-code - 1), perror_name);\n}", "target": 0}
{"code": "        virtual void call(XMLTokenizer* tokenizer) \n        {\n            tokenizer->processingInstruction(target, data);\n        }", "target": 0}
{"code": "static ssize_t tx_timeout_show(struct netdev_queue *queue, char *buf)\n{\n\tunsigned long trans_timeout;\n\tspin_lock_irq(&queue->_xmit_lock);\n\ttrans_timeout = queue->trans_timeout;\n\tspin_unlock_irq(&queue->_xmit_lock);\n\treturn sprintf(buf, \"%lu\", trans_timeout);", "target": 0}
{"code": "static u32 __ipv6_select_ident(struct net *net,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 id;\n\tdo {\n\t\tid = prandom_u32();\n\t} while (!id);\n\treturn id;\n}", "target": 0}
{"code": "static ssize_t oom_score_adj_write(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tunsigned long flags;\n\tint oom_score_adj;\n\tint err;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\terr = kstrtoint(strstrip(buffer), 0, &oom_score_adj);\n\tif (err)\n\t\tgoto out;\n\tif (oom_score_adj < OOM_SCORE_ADJ_MIN ||\n\t\t\toom_score_adj > OOM_SCORE_ADJ_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\ttask = get_proc_task(file->f_path.dentry->d_inode);\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\tif (oom_score_adj < task->signal->oom_score_adj_min &&\n\t\t\t!capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\ttask->signal->oom_score_adj = oom_score_adj;\n\tif (has_capability_noaudit(current, CAP_SYS_RESOURCE))\n\t\ttask->signal->oom_score_adj_min = oom_score_adj;\n\ttrace_oom_score_adj_update(task);\n\tif (task->signal->oom_score_adj == OOM_SCORE_ADJ_MIN)\n\t\ttask->signal->oom_adj = OOM_DISABLE;\n\telse\n\t\ttask->signal->oom_adj = (oom_score_adj * OOM_ADJUST_MAX) /\n\t\t\t\t\t\t\tOOM_SCORE_ADJ_MAX;\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}", "target": 0}
{"code": "escape_remove_attachment (int argc, char **argv, compose_env_t *env)\n{\n  size_t count;\n  unsigned long n;\n  char *p;\n  if (escape_check_args (argc, argv, 2, 2))\n    return 1;\n  n = strtoul (argv[1], &p, 10);\n  if (*p)\n    {\n      mu_error (_(\"not a valid number: %s\"), argv[1]);\n      return 1;\n    }\n  mu_list_count (env->attlist, &count);\n  if (n == 0 || n > count)\n    {\n      mu_error (_(\"index out of range\"));\n      return 1;\n    }\n  return mu_list_remove_nth (env->attlist, n - 1);\n}", "target": 0}
{"code": "void SimpleModule::runPush()\n{\n\tm_outChunk->frameCount = m_inChunk->frameCount;\n\trun(*m_inChunk, *m_outChunk);\n\tpush(m_outChunk->frameCount);\n}", "target": 0}
{"code": "  void DidGetHostQuota(QuotaStatusCode status,\n                       const std::string& host,\n                       StorageType type,\n                       int64 quota) {\n    quota_status_ = status;\n    host_ = host;\n    type_ = type;\n    quota_ = quota;\n  }", "target": 0}
{"code": "    const Value& Exifdatum::value() const\n    {\n        if (value_.get() == 0) throw Error(kerValueNotSet);\n        return *value_;\n    }", "target": 0}
{"code": "gnutls_x509_subject_alt_name_t _gnutls_x509_san_find_type(char *str_type)\n{\n\tif (strcmp(str_type, \"dNSName\") == 0)\n\t\treturn GNUTLS_SAN_DNSNAME;\n\tif (strcmp(str_type, \"rfc822Name\") == 0)\n\t\treturn GNUTLS_SAN_RFC822NAME;\n\tif (strcmp(str_type, \"uniformResourceIdentifier\") == 0)\n\t\treturn GNUTLS_SAN_URI;\n\tif (strcmp(str_type, \"iPAddress\") == 0)\n\t\treturn GNUTLS_SAN_IPADDRESS;\n\tif (strcmp(str_type, \"otherName\") == 0)\n\t\treturn GNUTLS_SAN_OTHERNAME;\n\tif (strcmp(str_type, \"directoryName\") == 0)\n\t\treturn GNUTLS_SAN_DN;\n\treturn (gnutls_x509_subject_alt_name_t) - 1;\n}", "target": 0}
{"code": "static void s_stop(struct seq_file *m, void *p)\n{\n\tup_read(&slub_lock);\n}", "target": 0}
{"code": "static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\tif (!vcpu->fpu_active)\n\t\tcr0 |= X86_CR0_TS;\n\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}", "target": 0}
{"code": "static gboolean session_write_msg_cb(SockInfo *source, GIOCondition condition,\n\t\t\t\t     gpointer data)\n{\n\tSession *session = SESSION(data);\n\tgint ret;\n\tcm_return_val_if_fail(condition == G_IO_OUT, FALSE);\n\tcm_return_val_if_fail(session->write_buf != NULL, FALSE);\n\tcm_return_val_if_fail(session->write_buf_p != NULL, FALSE);\n\tcm_return_val_if_fail(session->write_buf_len > 0, FALSE);\n\tret = session_write_buf(session);\n\tif (ret < 0) {\n\t\tsession->state = SESSION_ERROR;\n\t\treturn FALSE;\n\t} else if (ret > 0)\n\t\treturn TRUE;\n\tif (session->io_tag > 0) {\n\t\tg_source_remove(session->io_tag);\n\t\tsession->io_tag = 0;\n\t}\n\tsession_recv_msg(session);\n\treturn FALSE;\n}", "target": 0}
{"code": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n  const MagicInfo\n    *magic_info;    \n  FILE\n    *ps_file;\n  int\n    c;\n  ImageInfo\n    *clone_info;\n  Image\n    *image2;\n  unsigned char\n    magick[2*MagickPathExtent];    \n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while (PS_Size-- > 0)\n  {\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n    (void) fputc(c,ps_file);\n  }\n  (void) fclose(ps_file);\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n  (void) strncpy(clone_info->magick,magic_info->name,MagickPathExtent-1);\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n  if (!image2)\n    goto FINISH_UNL;\n  (void) CopyMagickString(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickString(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickString(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n  AppendImageToList(&image,image2);\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 0}
{"code": "static int bnx2x_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t    struct ptp_clock_request *rq, int on)\n{\n\tstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\n\tBNX2X_ERR(\"PHC ancillary features are not supported\\n\");\n\treturn -ENOTSUPP;\n}", "target": 0}
{"code": "int ssl_check_clienthello_tlsext_late(SSL *s)\n\t{\n\tint ret = SSL_TLSEXT_ERR_OK;\n\tint al;\n\tif ((s->tlsext_status_type != -1) && s->ctx && s->ctx->tlsext_status_cb)\n\t\t{\n\t\tint r;\n\t\tCERT_PKEY *certpkey;\n\t\tcertpkey = ssl_get_server_send_pkey(s);\n\t\tif (certpkey == NULL)\n\t\t\t{\n\t\t\ts->tlsext_status_expected = 0;\n\t\t\treturn 1;\n\t\t\t}\n\t\ts->cert->key = certpkey;\n\t\tr = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);\n\t\tswitch (r)\n\t\t\t{\n\t\t\tcase SSL_TLSEXT_ERR_NOACK:\n\t\t\t\ts->tlsext_status_expected = 0;\n\t\t\t\tbreak;\n\t\t\tcase SSL_TLSEXT_ERR_OK:\n\t\t\t\tif (s->tlsext_ocsp_resp)\n\t\t\t\t\ts->tlsext_status_expected = 1;\n\t\t\t\telse\n\t\t\t\t\ts->tlsext_status_expected = 0;\n\t\t\t\tbreak;\n\t\t\tcase SSL_TLSEXT_ERR_ALERT_FATAL:\n\t\t\t\tret = SSL_TLSEXT_ERR_ALERT_FATAL;\n\t\t\t\tal = SSL_AD_INTERNAL_ERROR;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\ts->tlsext_status_expected = 0;\n err:\n\tswitch (ret)\n\t\t{\n\t\tcase SSL_TLSEXT_ERR_ALERT_FATAL:\n\t\t\tssl3_send_alert(s, SSL3_AL_FATAL, al);\n\t\t\treturn -1;\n\t\tcase SSL_TLSEXT_ERR_ALERT_WARNING:\n\t\t\tssl3_send_alert(s, SSL3_AL_WARNING, al);\n\t\t\treturn 1; \n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}", "target": 0}
{"code": "void OmniboxViewWin::EmphasizeURLComponents() {\n  ITextDocument* const text_object_model = GetTextObjectModel();\n  ScopedFreeze freeze(this, text_object_model);\n  ScopedSuspendUndo suspend_undo(text_object_model);\n  CHARRANGE saved_sel;\n  GetSelection(saved_sel);\n  url_parse::Component scheme, host;\n  AutocompleteInput::ParseForEmphasizeComponents(\n      GetText(), model_->GetDesiredTLD(), &scheme, &host);\n  const bool emphasize = model_->CurrentTextIsURL() && (host.len > 0);\n  CHARFORMAT cf = {0};\n  cf.dwMask = CFM_COLOR;\n  cf.crTextColor = skia::SkColorToCOLORREF(LocationBarView::GetColor(\n      security_level_,\n      emphasize ? LocationBarView::DEEMPHASIZED_TEXT : LocationBarView::TEXT));\n  SelectAll(false);\n  SetSelectionCharFormat(cf);\n  if (emphasize) {\n    cf.crTextColor = skia::SkColorToCOLORREF(LocationBarView::GetColor(\n        security_level_, LocationBarView::TEXT));\n    SetSelection(host.begin, host.end());\n    SetSelectionCharFormat(cf);\n  }\n  insecure_scheme_component_.reset();\n  if (!model_->user_input_in_progress() && scheme.is_nonempty() &&\n      (security_level_ != ToolbarModel::NONE)) {\n    if (security_level_ == ToolbarModel::SECURITY_ERROR) {\n      insecure_scheme_component_.begin = scheme.begin;\n      insecure_scheme_component_.len = scheme.len;\n    }\n    cf.crTextColor = skia::SkColorToCOLORREF(LocationBarView::GetColor(\n        security_level_, LocationBarView::SECURITY_TEXT));\n    SetSelection(scheme.begin, scheme.end());\n    SetSelectionCharFormat(cf);\n  }\n  SetSelectionRange(saved_sel);\n}", "target": 0}
{"code": "void RenderView::OnSelectAll() {\n  if (!webview())\n    return;\n  webview()->focusedFrame()->executeCommand(\n      WebString::fromUTF8(\"SelectAll\"));\n  UserMetricsRecordAction(\"SelectAll\");\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, NoTableScanBasic) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n    runQuery(BSONObj());\n    assertNumSolutions(0U);\n    addIndex(BSON(\"x\" << 1));\n    runQuery(BSONObj());\n    assertNumSolutions(0U);\n    runQuery(fromjson(\"{x: {$gte: 0}}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: \"\n        \"{filter: null, pattern: {x: 1}}}}}\");\n}", "target": 0}
{"code": "mojom::WidgetInputHandler* RenderWidgetHostImpl::GetWidgetInputHandler() {\n  if (associated_widget_input_handler_)\n    return associated_widget_input_handler_.get();\n  if (widget_input_handler_)\n    return widget_input_handler_.get();\n  return legacy_widget_input_handler_.get();\n}", "target": 0}
{"code": "ProcAllocColorPlanes(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xAllocColorPlanesReq);\n    REQUEST_SIZE_MATCH(xAllocColorPlanesReq);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,\n                                 client, DixAddAccess);\n    if (rc == Success) {\n        xAllocColorPlanesReply acpr;\n        int npixels;\n        long length;\n        Pixel *ppixels;\n        npixels = stuff->colors;\n        if (!npixels) {\n            client->errorValue = npixels;\n            return BadValue;\n        }\n        if (stuff->contiguous != xTrue && stuff->contiguous != xFalse) {\n            client->errorValue = stuff->contiguous;\n            return BadValue;\n        }\n        acpr = (xAllocColorPlanesReply) {\n            .type = X_Reply,\n            .sequenceNumber = client->sequence,\n            .nPixels = npixels\n        };\n        length = (long) npixels *sizeof(Pixel);\n        ppixels = malloc(length);\n        if (!ppixels)\n            return BadAlloc;\n        if ((rc = AllocColorPlanes(client->index, pcmp, npixels,\n                                   (int) stuff->red, (int) stuff->green,\n                                   (int) stuff->blue, (Bool) stuff->contiguous,\n                                   ppixels, &acpr.redMask, &acpr.greenMask,\n                                   &acpr.blueMask))) {\n            free(ppixels);\n            return rc;\n        }\n        acpr.length = bytes_to_int32(length);\n#ifdef PANORAMIX\n        if (noPanoramiXExtension || !pcmp->pScreen->myNum)\n#endif\n        {\n            WriteReplyToClient(client, sizeof(xAllocColorPlanesReply), &acpr);\n            client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;\n            WriteSwappedDataToClient(client, length, ppixels);\n        }\n        free(ppixels);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "Item *Item_field::update_value_transformer(uchar *select_arg)\n{\n  SELECT_LEX *select= (SELECT_LEX*)select_arg;\n  DBUG_ASSERT(fixed);\n  if (field->table != select->context.table_list->table &&\n      type() != Item::TRIGGER_FIELD_ITEM)\n  {\n    List<Item> *all_fields= &select->join->all_fields;\n    Item **ref_pointer_array= select->ref_pointer_array;\n    DBUG_ASSERT(all_fields->elements <= select->ref_pointer_array_size);\n    int el= all_fields->elements;\n    Item_ref *ref;\n    ref_pointer_array[el]= (Item*)this;\n    all_fields->push_front((Item*)this);\n    ref= new Item_ref(&select->context, ref_pointer_array + el,\n                      table_name, field_name);\n    return ref;\n  }\n  return this;\n}", "target": 0}
{"code": "\tvirtual bool OnLoad(const CString& sArgStr, CString& sMessage) {\n\t\tif (sArgStr.empty() || CModInfo::GlobalModule != GetType())\n\t\t\treturn true;\n\t\tsMessage = \"Arguments converted to new syntax\";\n\t\tbool bSSL = false;\n\t\tbool bIPv6 = false;\n\t\tbool bShareIRCPorts = true;\n\t\tunsigned short uPort = 8080;\n\t\tCString sArgs(sArgStr);\n\t\tCString sPort;\n\t\tCString sListenHost;\n\t\twhile (sArgs.Left(1) == \"-\") {\n\t\t\tCString sOpt = sArgs.Token(0);\n\t\t\tsArgs = sArgs.Token(1, true);\n\t\t\tif (sOpt.Equals(\"-IPV6\")) {\n\t\t\t\tbIPv6 = true;\n\t\t\t} else if (sOpt.Equals(\"-IPV4\")) {\n\t\t\t\tbIPv6 = false;\n\t\t\t} else if (sOpt.Equals(\"-noircport\")) {\n\t\t\t\tbShareIRCPorts = false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (sArgs.empty() && bShareIRCPorts)\n\t\t\treturn true;\n\t\tif (sArgs.find(\" \") != CString::npos) {\n\t\t\tsListenHost = sArgs.Token(0);\n\t\t\tsPort = sArgs.Token(1, true);\n\t\t} else {\n\t\t\tsPort = sArgs;\n\t\t}\n\t\tif (sPort.Left(1) == \"+\") {\n\t\t\tsPort.TrimLeft(\"+\");\n\t\t\tbSSL = true;\n\t\t}\n\t\tif (!sPort.empty()) {\n\t\t\tuPort = sPort.ToUShort();\n\t\t}\n\t\tif (!bShareIRCPorts) {\n\t\t\tconst vector<CListener*>& vListeners = CZNC::Get().GetListeners();\n\t\t\tvector<CListener*>::const_iterator it;\n\t\t\tfor (it = vListeners.begin(); it != vListeners.end(); ++it) {\n\t\t\t\t(*it)->SetAcceptType(CListener::ACCEPT_IRC);\n\t\t\t}\n\t\t}\n\t\tCListener *pListener = new CListener(uPort, sListenHost, bSSL,\n\t\t\t\t(!bIPv6 ? ADDR_IPV4ONLY : ADDR_ALL), CListener::ACCEPT_HTTP);\n\t\tif (!pListener->Listen()) {\n\t\t\tsMessage = \"Failed to add backwards-compatible listener\";\n\t\t\treturn false;\n\t\t}\n\t\tCZNC::Get().AddListener(pListener);\n\t\tSetArgs(\"\");\n\t\treturn true;\n\t}", "target": 0}
{"code": "static unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                                size_t insize, const LodePNGDecompressSettings* settings)\n{\n  if (!settings->custom_zlib) return 87; \n  return settings->custom_zlib(out, outsize, in, insize, settings);\n}", "target": 0}
{"code": "fbCombineConjointOutC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    fbCombineConjointGeneralC (dest, src, mask, width, CombineAOut);\n}", "target": 0}
{"code": "void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)\n{\n\treturn slab_alloc(s, gfpflags, -1, __builtin_return_address(0));\n}", "target": 0}
{"code": "static struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)\n{\n\tint i;\n\tfor (i = 0; i < HUGE_MAX_HSTATE; i++)\n\t\tif (hstate_kobjs[i] == kobj) {\n\t\t\tif (nidp)\n\t\t\t\t*nidp = NUMA_NO_NODE;\n\t\t\treturn &hstates[i];\n\t\t}\n\treturn kobj_to_node_hstate(kobj, nidp);\n}", "target": 0}
{"code": "void Statement::Work_Bind(napi_env e, void* data) {\n    STATEMENT_INIT(Baton);\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n    stmt->Bind(baton->parameters);\n    sqlite3_mutex_leave(mtx);\n}", "target": 0}
{"code": "GF_Box *clap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CleanApertureBox, GF_ISOM_BOX_TYPE_CLAP);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static int hva_to_pfn_remapped(struct vm_area_struct *vma,\n\t\t\t       unsigned long addr, bool *async,\n\t\t\t       bool write_fault, kvm_pfn_t *p_pfn)\n{\n\tunsigned long pfn;\n\tint r;\n\tr = follow_pfn(vma, addr, &pfn);\n\tif (r) {\n\t\tbool unlocked = false;\n\t\tr = fixup_user_fault(current, current->mm, addr,\n\t\t\t\t     (write_fault ? FAULT_FLAG_WRITE : 0),\n\t\t\t\t     &unlocked);\n\t\tif (unlocked)\n\t\t\treturn -EAGAIN;\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = follow_pfn(vma, addr, &pfn);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tkvm_get_pfn(pfn);\n\t*p_pfn = pfn;\n\treturn 0;\n}", "target": 0}
{"code": "static int __meminit __add_section(int nid, struct zone *zone,\n\t\t\t\t\tunsigned long phys_start_pfn)\n{\n\tint nr_pages = PAGES_PER_SECTION;\n\tint ret;\n\tif (pfn_valid(phys_start_pfn))\n\t\treturn -EEXIST;\n\tret = sparse_add_one_section(zone, phys_start_pfn, nr_pages);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = __add_zone(zone, phys_start_pfn);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn register_new_memory(nid, __pfn_to_section(phys_start_pfn));\n}", "target": 0}
{"code": "shell_gtk_embed_on_window_destroy (GtkWidget     *object,\n                                   ShellGtkEmbed *embed)\n{\n  shell_gtk_embed_set_window (embed, NULL);\n}", "target": 0}
{"code": "color_utils::HSL GdkColorToHSL(const GdkColor* color) {\n  color_utils::HSL hsl;\n  color_utils::SkColorToHSL(SkColorSetRGB(color->red >> 8,\n                                          color->green >> 8,\n                                          color->blue >> 8), &hsl);\n  return hsl;\n}", "target": 0}
{"code": "ipcp_vr_lattice::meet_with_1 (const value_range *other_vr)\n{\n  if (bottom_p ())\n    return false;\n  if (other_vr->varying_p ())\n    return set_to_bottom ();\n  value_range save (m_vr);\n  m_vr.union_ (other_vr);\n  return !m_vr.equal_p (save);\n}", "target": 0}
{"code": "void option_error(void)\n{\n\tif (!err_buf[0]) {\n\t\tstrlcpy(err_buf, \"Error parsing options: option may \"\n\t\t\t\"be supported on client but not on server?\\n\",\n\t\t\tsizeof err_buf);\n\t}\n\trprintf(FERROR, RSYNC_NAME \": %s\", err_buf);\n\tmsleep(20);\n}", "target": 0}
{"code": "void AudioOutputController::DoFlush() {\n  DCHECK_EQ(message_loop_, MessageLoop::current());\n   if (!sync_reader_) {\n     if (state_ != kPaused)\n       return;\n    AutoLock auto_lock(lock_);\n     buffer_.Clear();\n   }\n }", "target": 0}
{"code": "epass2003_finish(sc_card_t *card)\n{\n\tepass2003_exdata *exdata = (epass2003_exdata *)card->drv_data;\n\tif (exdata)\n\t\tfree(exdata);\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "bool PrintWebViewHelper::PrintPages(const PrintMsg_PrintPages_Params& params,\n                                    WebFrame* frame,\n                                    const WebNode& node,\n                                    PrepareFrameAndViewForPrint* prepare) {\n  PrintMsg_Print_Params print_params = params.params;\n  scoped_ptr<PrepareFrameAndViewForPrint> prep_frame_view;\n  if (!prepare) {\n    prep_frame_view.reset(new PrepareFrameAndViewForPrint(print_params, frame,\n                                                          node));\n    prepare = prep_frame_view.get();\n  }\n  UpdatePrintableSizeInPrintParameters(frame, node, prepare, &print_params);\n  int page_count = prepare->GetExpectedPageCount();\n  if (!page_count)\n    return false;\n  Send(new PrintHostMsg_DidGetPrintedPagesCount(routing_id(),\n                                                print_params.document_cookie,\n                                                page_count));\n  const gfx::Size& canvas_size = prepare->GetPrintCanvasSize();\n  PrintMsg_PrintPage_Params page_params;\n  page_params.params = print_params;\n  if (params.pages.empty()) {\n    for (int i = 0; i < page_count; ++i) {\n      page_params.page_number = i;\n      PrintPageInternal(page_params, canvas_size, frame);\n    }\n  } else {\n    for (size_t i = 0; i < params.pages.size(); ++i) {\n      if (params.pages[i] >= page_count)\n        break;\n      page_params.page_number = params.pages[i];\n      PrintPageInternal(page_params, canvas_size, frame);\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static inline uint16_t ok_inflater_can_write_total(const ok_inflater *inflater) {\n    return inflater->buffer_start_pos - inflater->buffer_end_pos - 1;\n}", "target": 0}
{"code": "static int perf_event_idx_default(struct perf_event *event)\n{\n\treturn event->hw.idx + 1;\n}", "target": 0}
{"code": "static long madvise_pageout(struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct **prev,\n\t\t\tunsigned long start_addr, unsigned long end_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\t*prev = vma;\n\tif (!can_madv_lru_vma(vma))\n\t\treturn -EINVAL;\n\tif (!can_do_pageout(vma))\n\t\treturn 0;\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start_addr, end_addr);\n\tmadvise_pageout_page_range(&tlb, vma, start_addr, end_addr);\n\ttlb_finish_mmu(&tlb, start_addr, end_addr);\n\treturn 0;\n}", "target": 0}
{"code": "static int decode_layoutcommit(struct xdr_stream *xdr,\n\t\t\t       struct rpc_rqst *req,\n\t\t\t       struct nfs4_layoutcommit_res *res)\n{\n\t__be32 *p;\n\t__u32 sizechanged;\n\tint status;\n\tstatus = decode_op_hdr(xdr, OP_LAYOUTCOMMIT);\n\tres->status = status;\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tsizechanged = be32_to_cpup(p);\n\tif (sizechanged) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t}\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n\trefcount_set(&net->count, 1);\n\trefcount_set(&net->passive, 1);\n\tget_random_bytes(&net->hash_mix, sizeof(u32));\n\tnet->dev_base_seq = 1;\n\tnet->user_ns = user_ns;\n\tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\nout_undo:\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\trcu_barrier();\n\tgoto out;\n}", "target": 0}
{"code": "Proto_ConcatXMLStrings(gchar *str1,\n                       gchar *str2)\n{\n   gchar *newStr;\n   if (NULL == str2) {\n      return str1;\n   }\n   newStr = g_strdup_printf(\"%s%s\", str1, str2);\n   g_free(str1);\n   g_free(str2);\n   return newStr;\n}", "target": 0}
{"code": "nfs4_proc_lock(struct file *filp, int cmd, struct file_lock *request)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tunsigned long timeout = NFS4_LOCK_MINTIMEOUT;\n\tint status;\n\tctx = nfs_file_open_context(filp);\n\tstate = ctx->state;\n\tif (request->fl_start < 0 || request->fl_end < 0)\n\t\treturn -EINVAL;\n\tif (IS_GETLK(cmd)) {\n\t\tif (state != NULL)\n\t\t\treturn nfs4_proc_getlk(state, F_GETLK, request);\n\t\treturn 0;\n\t}\n\tif (!(IS_SETLK(cmd) || IS_SETLKW(cmd)))\n\t\treturn -EINVAL;\n\tif (request->fl_type == F_UNLCK) {\n\t\tif (state != NULL)\n\t\t\treturn nfs4_proc_unlck(state, cmd, request);\n\t\treturn 0;\n\t}\n\tif (state == NULL)\n\t\treturn -ENOLCK;\n\tswitch (request->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(filp->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\tdo {\n\t\tstatus = nfs4_proc_setlk(state, cmd, request);\n\t\tif ((status != -EAGAIN) || IS_SETLK(cmd))\n\t\t\tbreak;\n\t\ttimeout = nfs4_set_lock_task_retry(timeout);\n\t\tstatus = -ERESTARTSYS;\n\t\tif (signalled())\n\t\t\tbreak;\n\t} while(status < 0);\n\treturn status;\n}", "target": 0}
{"code": "void HTMLMediaElement::AudioClientImpl::SetFormat(uint32_t number_of_channels,\n                                                  float sample_rate) {\n  if (client_)\n    client_->SetFormat(number_of_channels, sample_rate);\n}", "target": 0}
{"code": "void InterstitialPage::InterstitialPageRVHViewDelegate::StartDragging(\n    const WebDropData& drop_data,\n    WebDragOperationsMask allowed_operations,\n    const SkBitmap& image,\n    const gfx::Point& image_offset) {\n  NOTREACHED() << \"InterstitialPage does not support dragging yet.\";\n}", "target": 0}
{"code": "static bool mark_as_dependent(THD *thd, SELECT_LEX *last, SELECT_LEX *current,\n                              Item_ident *resolved_item,\n                              Item_ident *mark_item)\n{\n  DBUG_ENTER(\"mark_as_dependent\");\n  if (mark_item && mark_item->can_be_depended)\n  {\n    DBUG_PRINT(\"info\", (\"mark_item: %p  lex: %p\", mark_item, last));\n    mark_item->depended_from= last;\n  }\n  if (current->mark_as_dependent(thd, last,\n                                  mark_item))\n    DBUG_RETURN(TRUE);\n  if (thd->lex->describe & DESCRIBE_EXTENDED)\n  {\n    const char *db_name= (resolved_item->db_name ?\n                          resolved_item->db_name : \"\");\n    const char *table_name= (resolved_item->table_name ?\n                             resolved_item->table_name : \"\");\n    push_warning_printf(thd, MYSQL_ERROR::WARN_LEVEL_NOTE,\n\t\t ER_WARN_FIELD_RESOLVED, ER(ER_WARN_FIELD_RESOLVED),\n                 db_name, (db_name[0] ? \".\" : \"\"),\n                 table_name, (table_name [0] ? \".\" : \"\"),\n                 resolved_item->field_name,\n                 current->select_number, last->select_number);\n  }\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MaxMinReverseIndexDir) {\n    addIndex(BSON(\"a\" << -1));\n    runQueryFull(BSONObj(),\n                 fromjson(\"{a: -1}\"),\n                 BSONObj(),\n                 0,\n                 0,\n                 BSONObj(),\n                 fromjson(\"{a: 8}\"),\n                 fromjson(\"{a: 2}\"),\n                 false);\n    assertNumSolutions(1);\n    assertSolutionExists(\"{fetch: {node: {ixscan: {filter: null, dir: 1, pattern: {a: -1}}}}}\");\n}", "target": 0}
{"code": "    CImg<T>& xyYtoXYZ() {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"xyYtoXYZ(): Instance is not a xyY image.\",\n                                    cimg_instance);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=4096))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n         px = (Tfloat)p1[N],\n         py = (Tfloat)p2[N],\n         Y = (Tfloat)p3[N],\n         ny = py>0?py:1;\n        p1[N] = (T)(px*Y/ny);\n        p2[N] = (T)Y;\n        p3[N] = (T)((1 - px - py)*Y/ny);\n      }\n      return *this;", "target": 0}
{"code": "static void nvme_free_cq(NvmeCQueue *cq, NvmeCtrl *n)\n{\n    n->cq[cq->cqid] = NULL;\n    timer_free(cq->timer);\n    if (msix_enabled(&n->parent_obj)) {\n        msix_vector_unuse(&n->parent_obj, cq->vector);\n    }\n    if (cq->cqid) {\n        g_free(cq);\n    }\n}", "target": 0}
{"code": "static void migrate_timeout(RedsState *reds)\n{\n    spice_debug(\"trace\");\n    spice_assert(reds->mig_wait_connect || reds->mig_wait_disconnect);\n    if (reds->mig_wait_connect) {\n        reds->main_channel->migrate_cancel_wait();\n        reds_mig_target_client_disconnect_all(reds);\n        reds_mig_cleanup(reds);\n    } else {\n        reds_mig_disconnect(reds);\n    }\n}", "target": 0}
{"code": "mm_record_login(Session *s, struct passwd *pw)\n{\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (packet_connection_is_on_socket()) {\n\t\tif (getpeername(packet_get_connection_in(),\n\t\t\t(struct sockaddr *) & from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tfatal_cleanup();\n\t\t}\n\t}\n\trecord_login(s->pid, s->tty, pw->pw_name, pw->pw_uid,\n\t    get_remote_name_or_ip(utmp_len, options.verify_reverse_mapping),\n\t    (struct sockaddr *)&from, fromlen);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, SplitLimitedSort) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n    params.options |= QueryPlannerParams::SPLIT_LIMITED_SORT;\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    runQuerySortProjSkipNToReturn(fromjson(\"{a: 1}\"), fromjson(\"{b: 1}\"), BSONObj(), 0, 3);\n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{fetch: {filter: {a:1}, node: \"\n        \"{ixscan: {filter: null, pattern: {b: 1}}}}}\");\n    assertSolutionExists(\n        \"{ensureSorted: {pattern: {b: 1}, node: \"\n        \"{or: {nodes: [\"\n        \"{sort: {pattern: {b: 1}, limit: 3, node: {sortKeyGen: {node: \"\n        \"{fetch: {node: {ixscan: {pattern: {a: 1}}}}}}}}}, \"\n        \"{sort: {pattern: {b: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{fetch: {node: {ixscan: {pattern: {a: 1}}}}}}}}}]}}}}\");\n}", "target": 0}
{"code": "static int handle_invvpid(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}", "target": 0}
{"code": "void __sk_mem_reclaim(struct sock *sk)\n{\n\tsk_memory_allocated_sub(sk,\n\t\t\t\tsk->sk_forward_alloc >> SK_MEM_QUANTUM_SHIFT);\n\tsk->sk_forward_alloc &= SK_MEM_QUANTUM - 1;\n\tif (sk_under_memory_pressure(sk) &&\n\t    (sk_memory_allocated(sk) < sk_prot_mem_limits(sk, 0)))\n\t\tsk_leave_memory_pressure(sk);\n}", "target": 0}
{"code": "static sector_t udf_scan_anchors(struct super_block *sb, sector_t lastblock,\n\t\t\t\t struct kernel_lb_addr *fileset)\n{\n\tsector_t last[6];\n\tint i;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint last_count = 0;\n\tif (sbi->s_anchor) {\n\t\tif (udf_check_anchor_block(sb, sbi->s_anchor, fileset))\n\t\t\treturn lastblock;\n\t}\n\tif (udf_check_anchor_block(sb, sbi->s_session + 256, fileset))\n\t\treturn lastblock;\n\tlast[last_count++] = lastblock;\n\tif (lastblock >= 1)\n\t\tlast[last_count++] = lastblock - 1;\n\tlast[last_count++] = lastblock + 1;\n\tif (lastblock >= 2)\n\t\tlast[last_count++] = lastblock - 2;\n\tif (lastblock >= 150)\n\t\tlast[last_count++] = lastblock - 150;\n\tif (lastblock >= 152)\n\t\tlast[last_count++] = lastblock - 152;\n\tfor (i = 0; i < last_count; i++) {\n\t\tif (last[i] >= sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits)\n\t\t\tcontinue;\n\t\tif (udf_check_anchor_block(sb, last[i], fileset))\n\t\t\treturn last[i];\n\t\tif (last[i] < 256)\n\t\t\tcontinue;\n\t\tif (udf_check_anchor_block(sb, last[i] - 256, fileset))\n\t\t\treturn last[i];\n\t}\n\tif (udf_check_anchor_block(sb, sbi->s_session + 512, fileset))\n\t\treturn last[0];\n\treturn 0;\n}", "target": 0}
{"code": "handle_assoc_response(netdissect_options *ndo,\n                      const u_char *p, u_int length)\n{\n\tstruct mgmt_body_t pbody;\n\tint offset = 0;\n\tint ret;\n\tmemset(&pbody, 0, sizeof(pbody));\n\tif (!ND_TTEST2(*p, IEEE802_11_CAPINFO_LEN + IEEE802_11_STATUS_LEN +\n\t    IEEE802_11_AID_LEN))\n\t\treturn 0;\n\tif (length < IEEE802_11_CAPINFO_LEN + IEEE802_11_STATUS_LEN +\n\t    IEEE802_11_AID_LEN)\n\t\treturn 0;\n\tpbody.capability_info = EXTRACT_LE_16BITS(p);\n\toffset += IEEE802_11_CAPINFO_LEN;\n\tlength -= IEEE802_11_CAPINFO_LEN;\n\tpbody.status_code = EXTRACT_LE_16BITS(p+offset);\n\toffset += IEEE802_11_STATUS_LEN;\n\tlength -= IEEE802_11_STATUS_LEN;\n\tpbody.aid = EXTRACT_LE_16BITS(p+offset);\n\toffset += IEEE802_11_AID_LEN;\n\tlength -= IEEE802_11_AID_LEN;\n\tret = parse_elements(ndo, &pbody, p, offset, length);\n\tND_PRINT((ndo, \" AID(%x) :%s: %s\", ((uint16_t)(pbody.aid << 2 )) >> 2 ,\n\t    CAPABILITY_PRIVACY(pbody.capability_info) ? \" PRIVACY \" : \"\",\n\t    (pbody.status_code < NUM_STATUSES\n\t\t? status_text[pbody.status_code]\n\t\t: \"n/a\")));\n\treturn ret;\n}", "target": 0}
{"code": "static void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)\n{\n\tlong sv = 0, mask;\n\tif (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {\n\t\tmask = ~(ctxt->dst.bytes * 8 - 1);\n\t\tif (ctxt->src.bytes == 2)\n\t\t\tsv = (s16)ctxt->src.val & (s16)mask;\n\t\telse if (ctxt->src.bytes == 4)\n\t\t\tsv = (s32)ctxt->src.val & (s32)mask;\n\t\tctxt->dst.addr.mem.ea += (sv >> 3);\n\t}\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n}", "target": 0}
{"code": "rb_reg_hash(VALUE re)\n{\n    st_index_t hashval = reg_hash(re);\n    return ST2FIX(hashval);\n}", "target": 0}
{"code": "onig_parse_make_tree(Node** root, const UChar* pattern, const UChar* end,\n\t\t     regex_t* reg, ScanEnv* env)\n{\n  int r;\n  UChar* p;\n#ifdef USE_NAMED_GROUP\n  names_clear(reg);\n#endif\n  scan_env_clear(env);\n  env->option         = reg->options;\n  env->case_fold_flag = reg->case_fold_flag;\n  env->enc            = reg->enc;\n  env->syntax         = reg->syntax;\n  env->pattern        = (UChar* )pattern;\n  env->pattern_end    = (UChar* )end;\n  env->reg            = reg;\n  *root = NULL;\n  p = (UChar* )pattern;\n  r = parse_regexp(root, &p, (UChar* )end, env);\n  reg->num_mem = env->num_mem;\n  return r;\n}", "target": 0}
{"code": "int oz_usb_control_req(void *hpd, u8 req_id, struct usb_ctrlrequest *setup,\n\t\t\tconst u8 *data, int data_len)\n{\n\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\tunsigned windex = le16_to_cpu(setup->wIndex);\n\tunsigned wlength = le16_to_cpu(setup->wLength);\n\tint rc = 0;\n\tif ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (setup->bRequest) {\n\t\tcase USB_REQ_GET_DESCRIPTOR:\n\t\t\trc = oz_usb_get_desc_req(hpd, req_id,\n\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t(u8)wvalue, setup->wIndex, 0, wlength);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_CONFIGURATION:\n\t\t\trc = oz_usb_set_config_req(hpd, req_id, (u8)wvalue);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_INTERFACE: {\n\t\t\t\tu8 if_num = (u8)windex;\n\t\t\t\tu8 alt = (u8)wvalue;\n\t\t\t\trc = oz_usb_set_interface_req(hpd, req_id,\n\t\t\t\t\tif_num, alt);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\trc = oz_usb_set_clear_feature_req(hpd, req_id,\n\t\t\t\tOZ_SET_FEATURE_REQ,\n\t\t\t\tsetup->bRequestType & 0xf, (u8)windex,\n\t\t\t\tsetup->wValue);\n\t\t\tbreak;\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\trc = oz_usb_set_clear_feature_req(hpd, req_id,\n\t\t\t\tOZ_CLEAR_FEATURE_REQ,\n\t\t\t\tsetup->bRequestType & 0xf,\n\t\t\t\t(u8)windex, setup->wValue);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trc = oz_usb_vendor_class_req(hpd, req_id, setup->bRequestType,\n\t\t\tsetup->bRequest, setup->wValue, setup->wIndex,\n\t\t\tdata, data_len);\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "rb_reg_match_m(int argc, VALUE *argv, VALUE re)\n{\n    VALUE result, str, initpos;\n    long pos;\n    if (rb_scan_args(argc, argv, \"11\", &str, &initpos) == 2) {\n\tpos = NUM2LONG(initpos);\n    }\n    else {\n\tpos = 0;\n    }\n    pos = reg_match_pos(re, &str, pos);\n    if (pos < 0) {\n\trb_backref_set(Qnil);\n\treturn Qnil;\n    }\n    result = rb_backref_get();\n    rb_match_busy(result);\n    if (!NIL_P(result) && rb_block_given_p()) {\n\treturn rb_yield(result);\n    }\n    return result;\n}", "target": 0}
{"code": "spnego_gss_inquire_saslname_for_mech(OM_uint32 *minor_status,\n                                     const gss_OID desired_mech,\n                                     gss_buffer_t sasl_mech_name,\n                                     gss_buffer_t mech_name,\n                                     gss_buffer_t mech_description)\n{\n\t*minor_status = 0;\n\tif (!g_OID_equal(desired_mech, gss_mech_spnego))\n\t\treturn (GSS_S_BAD_MECH);\n\tif (!g_make_string_buffer(SPNEGO_SASL_NAME, sasl_mech_name) ||\n\t    !g_make_string_buffer(\"spnego\", mech_name) ||\n\t    !g_make_string_buffer(\"Simple and Protected GSS-API \"\n\t\t\t\t  \"Negotiation Mechanism\", mech_description))\n\t\tgoto fail;\n\treturn (GSS_S_COMPLETE);\nfail:\n\t*minor_status = ENOMEM;\n\treturn (GSS_S_FAILURE);\n}", "target": 0}
{"code": "OPJ_FLOAT32 opj_j2k_get_tp_stride (opj_tcp_t * p_tcp)\n{\n        return (OPJ_FLOAT32) ((p_tcp->m_nb_tile_parts - 1) * 14);\n}", "target": 0}
{"code": "_XimSetInnerIMAttributes(\n    Xim\t\t\t im,\n    XPointer\t\t top,\n    XIMArg\t\t*arg,\n    unsigned long\t mode)\n{\n    XIMResourceList\t res;\n    int\t\t\t check;\n    if (!(res = _XimGetResourceListRec(im->private.proto.im_inner_resources,\n\t\t\tim->private.proto.im_num_inner_resources, arg->name)))\n\treturn False;\n    check = _XimCheckIMMode(res, mode);\n    if(check == XIM_CHECK_INVALID)\n\treturn True;\n    else if(check == XIM_CHECK_ERROR)\n\treturn False;\n    return _XimEncodeLocalIMAttr(res, top, arg->value);\n}", "target": 0}
{"code": "void RGWDeleteBucketTags_ObjStore_S3::send_response() \n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n}", "target": 0}
{"code": "sign_pe(context *ctx, int infd, int outfd, int attached)\n{\n\tPe *inpe = NULL;\n\tint rc = set_up_inpe(ctx, infd, &inpe);\n\tif (rc < 0)\n\t\tgoto finish;\n\tif (attached) {\n\t\tPe *outpe = NULL;\n\t\trc = set_up_outpe(ctx, outfd, inpe, &outpe);\n\t\tif (rc < 0)\n\t\t\tgoto finish;\n\t\trc = generate_digest(ctx->cms, outpe, 1);\n\t\tif (rc < 0) {\nerr_attached:\n\t\t\tpe_end(outpe);\n\t\t\tftruncate(outfd, 0);\n\t\t\tgoto finish;\n\t\t}\n\t\tssize_t sigspace = calculate_signature_space(ctx->cms, outpe);\n\t\tif (sigspace < 0)\n\t\t\tgoto err_attached;\n\t\tallocate_signature_space(outpe, sigspace);\n\t\trc = generate_digest(ctx->cms, outpe, 1);\n\t\tif (rc < 0)\n\t\t\tgoto err_attached;\n\t\trc = generate_signature(ctx->cms);\n\t\tif (rc < 0)\n\t\t\tgoto err_attached;\n\t\tinsert_signature(ctx->cms, ctx->cms->num_signatures);\n\t\tfinalize_signatures(ctx->cms->signatures,\n\t\t\t\tctx->cms->num_signatures, outpe);\n\t\tpe_end(outpe);\n\t} else {\n\t\tftruncate(outfd, 0);\n\t\trc = generate_digest(ctx->cms, inpe, 1);\n\t\tif (rc < 0) {\nerr_detached:\n\t\t\tftruncate(outfd, 0);\n\t\t\tgoto finish;\n\t\t}\n\t\trc = generate_signature(ctx->cms);\n\t\tif (rc < 0)\n\t\t\tgoto err_detached;\n\t\trc = export_signature(ctx->cms, outfd, 0);\n\t\tif (rc >= 0)\n\t\t\tftruncate(outfd, rc);\n\t\telse if (rc < 0)\n\t\t\tgoto err_detached;\n\t}\nfinish:\n\tif (inpe)\n\t\tpe_end(inpe);\n\treturn rc;\n}", "target": 0}
{"code": "static int sr_read(struct usbnet *dev, u8 reg, u16 length, void *data)\n{\n\tint err;\n\terr = usbnet_read_cmd(dev, SR_RD_REGS, SR_REQ_RD_REG, 0, reg, data,\n\t\t\t      length);\n\tif ((err != length) && (err >= 0))\n\t\terr = -EINVAL;\n\treturn err;\n}", "target": 0}
{"code": "int rdma_accept(struct rdma_cm_id *id, struct rdma_conn_param *conn_param)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(id, struct rdma_id_private, id);\n\tint ret;\n\tlockdep_assert_held(&id_priv->handler_mutex);\n\tif (READ_ONCE(id_priv->state) != RDMA_CM_CONNECT)\n\t\treturn -EINVAL;\n\tif (!id->qp && conn_param) {\n\t\tid_priv->qp_num = conn_param->qp_num;\n\t\tid_priv->srq = conn_param->srq;\n\t}\n\tif (rdma_cap_ib_cm(id->device, id->port_num)) {\n\t\tif (id->qp_type == IB_QPT_UD) {\n\t\t\tif (conn_param)\n\t\t\t\tret = cma_send_sidr_rep(id_priv, IB_SIDR_SUCCESS,\n\t\t\t\t\t\t\tconn_param->qkey,\n\t\t\t\t\t\t\tconn_param->private_data,\n\t\t\t\t\t\t\tconn_param->private_data_len);\n\t\t\telse\n\t\t\t\tret = cma_send_sidr_rep(id_priv, IB_SIDR_SUCCESS,\n\t\t\t\t\t\t\t0, NULL, 0);\n\t\t} else {\n\t\t\tif (conn_param)\n\t\t\t\tret = cma_accept_ib(id_priv, conn_param);\n\t\t\telse\n\t\t\t\tret = cma_rep_recv(id_priv);\n\t\t}\n\t} else if (rdma_cap_iw_cm(id->device, id->port_num)) {\n\t\tret = cma_accept_iw(id_priv, conn_param);\n\t} else {\n\t\tret = -ENOSYS;\n\t}\n\tif (ret)\n\t\tgoto reject;\n\treturn 0;\nreject:\n\tcma_modify_qp_err(id_priv);\n\trdma_reject(id, NULL, 0, IB_CM_REJ_CONSUMER_DEFINED);\n\treturn ret;\n}", "target": 0}
{"code": "  void cleanup(void)\n  {\n    for (int i = 0; i < LIBRAW_MSIZE; i++)\n      if (mems[i])\n      {\n        ::free(mems[i]);\n        mems[i] = NULL;\n      }\n  }", "target": 0}
{"code": "smtp_getbuf(unsigned * len)\n{\nunsigned size;\nuschar * buf;\nif (smtp_inptr >= smtp_inend)\n  if (!smtp_refill(*len))\n    { *len = 0; return NULL; }\nif ((size = smtp_inend - smtp_inptr) > *len) size = *len;\nbuf = smtp_inptr;\nsmtp_inptr += size;\n*len = size;\nreturn buf;\n}", "target": 0}
{"code": "void smp_link_encrypted(const RawAddress& bda, uint8_t encr_enable) {\n  tSMP_CB* p_cb = &smp_cb;\n  SMP_TRACE_DEBUG(\"%s: encr_enable=%d\", __func__, encr_enable);\n if (smp_cb.pairing_bda == bda) {\n if (p_cb->loc_enc_size != 0 && encr_enable) {\n      btm_ble_update_sec_key_size(bda, p_cb->loc_enc_size);\n }\n    tSMP_INT_DATA smp_int_data;\n    smp_int_data.status = encr_enable;\n    smp_sm_event(&smp_cb, SMP_ENCRYPTED_EVT, &smp_int_data);\n }\n}", "target": 0}
{"code": "encode_jd(VALUE nth, int jd, VALUE *rjd)\n{\n    if (f_zero_p(nth)) {\n\t*rjd = INT2FIX(jd);\n\treturn;\n    }\n    *rjd = f_add(f_mul(INT2FIX(CM_PERIOD), nth), INT2FIX(jd));\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(date_timestamp_get)\n{\n\tzval         *object;\n\tphp_date_obj *dateobj;\n\tlong          timestamp;\n\tint           error;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"O\", &object, date_ce_interface) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tdateobj = (php_date_obj *) zend_object_store_get_object(object TSRMLS_CC);\n\tDATE_CHECK_INITIALIZED(dateobj->time, DateTime);\n\ttimelib_update_ts(dateobj->time, NULL);\n\ttimestamp = timelib_date_to_int(dateobj->time, &error);\n\tif (error) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETVAL_LONG(timestamp);\n\t}", "target": 0}
{"code": "check_POP_MPLS(const struct ofpact_pop_mpls *a, struct ofpact_check_params *cp)\n{\n    struct flow *flow = &cp->match->flow;\n    ovs_be16 dl_type = get_dl_type(flow);\n    if (flow->packet_type != htonl(PT_ETH) || !eth_type_mpls(dl_type)) {\n        inconsistent_match(&cp->usable_protocols);\n    }\n    flow->dl_type = a->ethertype;\n    return 0;\n}", "target": 0}
{"code": "size_t HeaderMapImpl::removeIf(const HeaderMap::HeaderMatchPredicate& predicate) {\n  const size_t old_size = headers_.size();\n  headers_.remove_if([&predicate, this](const HeaderEntryImpl& entry) {\n    const bool to_remove = predicate(entry);\n    if (to_remove) {\n      auto lookup = staticLookup(entry.key().getStringView());\n      if (lookup.has_value()) {\n        if (lookup.value().entry_) {\n          const uint32_t key_value_size =\n              (*lookup.value().entry_)->key().size() + (*lookup.value().entry_)->value().size();\n          subtractSize(key_value_size);\n          *lookup.value().entry_ = nullptr;\n        }\n      } else {\n        subtractSize(entry.key().size() + entry.value().size());\n      }\n    }\n    return to_remove;\n  });\n  return old_size - headers_.size();\n}", "target": 0}
{"code": "parse_ENCAP(char *arg, const struct ofpact_parse_params *pp)\n{\n    struct ofpact_encap *encap;\n    char *key, *value, *str;\n    char *error = NULL;\n    uint16_t prop_class;\n    int n_props = 0;\n    encap = ofpact_put_ENCAP(pp->ofpacts);\n    encap->hdr_size = 0;\n    str = arg;\n    if (!ofputil_parse_key_value(&arg, &key, &value)) {\n        return xasprintf(\"Missing encap hdr: %s\", str);\n    }\n    if (!parse_encap_header(key, &encap->new_pkt_type)) {\n        return xasprintf(\"Encap hdr not supported: %s\", value);\n    }\n    if (!parse_ed_prop_class(key, &prop_class)) {\n        return xasprintf(\"Invalid encap prop class: %s\", key);\n    }\n    error = parse_ed_props(prop_class, &value, &n_props, pp->ofpacts);\n    if (error != NULL) {\n        return error;\n    }\n    encap = pp->ofpacts->header;\n    encap->n_props = n_props;\n    ofpact_finish_ENCAP(pp->ofpacts, &encap);\n    return NULL;\n}", "target": 0}
{"code": "\tstd::pair<char const*, int> lazy_entry::data_section() const\n\t{\n\t\ttypedef std::pair<char const*, int> return_t;\n\t\treturn return_t(m_begin, m_len);\n\t}", "target": 0}
{"code": "parsecolorchar(zattr arg, int is_fg)\n{\n    if (bv->fm[1] == '{') {\n\tchar *ep;\n\tbv->fm += 2; \n\tif ((ep = strchr(bv->fm, '}'))) {\n\t    char oc = *ep, *col, *coll;\n\t    int ops = opts[PROMPTSUBST], opb = opts[PROMPTBANG];\n\t    int opp = opts[PROMPTPERCENT];\n\t    opts[PROMPTPERCENT] = 1;\n\t    opts[PROMPTSUBST] = opts[PROMPTBANG] = 0;\n\t    *ep = '\\0';\n\t    coll = col = promptexpand(bv->fm, 0, NULL, NULL, NULL);\n\t    *ep = oc;\n\t    arg = match_colour((const char **)&coll, is_fg, 0);\n\t    free(col);\n\t    bv->fm = ep;\n\t    opts[PROMPTSUBST] = ops;\n\t    opts[PROMPTBANG] = opb;\n\t    opts[PROMPTPERCENT] = opp;\n\t} else {\n\t    arg = match_colour((const char **)&bv->fm, is_fg, 0);\n\t    if (*bv->fm != '}')\n\t\tbv->fm--;\n\t}\n    } else\n\targ = match_colour(NULL, 1, arg);\n    return arg;\n}", "target": 0}
{"code": "static int cma_resolve_ib_udp(struct rdma_id_private *id_priv,\n\t\t\t      struct rdma_conn_param *conn_param)\n{\n\tstruct ib_cm_sidr_req_param req;\n\tstruct ib_cm_id\t*id;\n\tvoid *private_data;\n\tu8 offset;\n\tint ret;\n\tmemset(&req, 0, sizeof req);\n\toffset = cma_user_data_offset(id_priv);\n\treq.private_data_len = offset + conn_param->private_data_len;\n\tif (req.private_data_len < conn_param->private_data_len)\n\t\treturn -EINVAL;\n\tif (req.private_data_len) {\n\t\tprivate_data = kzalloc(req.private_data_len, GFP_ATOMIC);\n\t\tif (!private_data)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tprivate_data = NULL;\n\t}\n\tif (conn_param->private_data && conn_param->private_data_len)\n\t\tmemcpy(private_data + offset, conn_param->private_data,\n\t\t       conn_param->private_data_len);\n\tif (private_data) {\n\t\tret = cma_format_hdr(private_data, id_priv);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\treq.private_data = private_data;\n\t}\n\tid = ib_create_cm_id(id_priv->id.device, cma_sidr_rep_handler,\n\t\t\t     id_priv);\n\tif (IS_ERR(id)) {\n\t\tret = PTR_ERR(id);\n\t\tgoto out;\n\t}\n\tid_priv->cm_id.ib = id;\n\treq.path = id_priv->id.route.path_rec;\n\treq.sgid_attr = id_priv->id.route.addr.dev_addr.sgid_attr;\n\treq.service_id = rdma_get_service_id(&id_priv->id, cma_dst_addr(id_priv));\n\treq.timeout_ms = 1 << (CMA_CM_RESPONSE_TIMEOUT - 8);\n\treq.max_cm_retries = CMA_MAX_CM_RETRIES;\n\ttrace_cm_send_sidr_req(id_priv);\n\tret = ib_send_cm_sidr_req(id_priv->cm_id.ib, &req);\n\tif (ret) {\n\t\tib_destroy_cm_id(id_priv->cm_id.ib);\n\t\tid_priv->cm_id.ib = NULL;\n\t}\nout:\n\tkfree(private_data);\n\treturn ret;\n}", "target": 0}
{"code": "static void bnx2x_set_endianity(struct bnx2x *bp)\n{\n#ifdef __BIG_ENDIAN\n\tbnx2x_config_endianity(bp, 1);\n#else\n\tbnx2x_config_endianity(bp, 0);\n#endif\n}", "target": 0}
{"code": "static unsigned long pfn_max_align_down(unsigned long pfn)\n{\n\treturn pfn & ~(max_t(unsigned long, MAX_ORDER_NR_PAGES,\n\t\t\t     pageblock_nr_pages) - 1);\n}", "target": 0}
{"code": "void RenderView::OnNavigate(const ViewMsg_Navigate_Params& params) {\n  if (!webview())\n    return;\n  history_list_offset_ = params.current_history_list_offset;\n  history_list_length_ = params.current_history_list_length;\n  if (devtools_agent_.get())\n    devtools_agent_->OnNavigate();\n  if (notification_provider_.get())\n    notification_provider_->OnNavigate();\n  child_process_logging::SetActiveURL(params.url);\n  AboutHandler::MaybeHandle(params.url);\n  bool is_reload =\n      params.navigation_type == ViewMsg_Navigate_Params::RELOAD ||\n      params.navigation_type == ViewMsg_Navigate_Params::RELOAD_IGNORING_CACHE;\n  WebFrame* main_frame = webview()->mainFrame();\n  if (is_reload && main_frame->currentHistoryItem().isNull()) {\n    is_reload = false;\n  }\n  if (!params.url.SchemeIs(chrome::kJavaScriptScheme)) {\n    NavigationState* state = NavigationState::CreateBrowserInitiated(\n        params.page_id,\n        params.pending_history_list_offset,\n        params.transition,\n        params.request_time);\n    if (params.navigation_type == ViewMsg_Navigate_Params::RESTORE) {\n      state->set_cache_policy_override(WebURLRequest::UseProtocolCachePolicy);\n    }\n    pending_navigation_state_.reset(state);\n  }\n  NavigationState* navigation_state = pending_navigation_state_.get();\n  if (is_reload) {\n    if (navigation_state)\n      navigation_state->set_load_type(NavigationState::RELOAD);\n    bool ignore_cache = (params.navigation_type ==\n                             ViewMsg_Navigate_Params::RELOAD_IGNORING_CACHE);\n    main_frame->reload(ignore_cache);\n  } else if (!params.state.empty()) {\n    DCHECK_NE(params.page_id, -1);\n    if (navigation_state)\n      navigation_state->set_load_type(NavigationState::HISTORY_LOAD);\n    main_frame->loadHistoryItem(\n        webkit_glue::HistoryItemFromString(params.state));\n  } else {\n    WebURLRequest request(params.url);\n    DCHECK_EQ(params.page_id, -1);\n    if (main_frame->isViewSourceModeEnabled())\n      request.setCachePolicy(WebURLRequest::ReturnCacheDataElseLoad);\n    if (params.referrer.is_valid()) {\n      request.setHTTPHeaderField(WebString::fromUTF8(\"Referer\"),\n                                 WebString::fromUTF8(params.referrer.spec()));\n    }\n    if (navigation_state)\n      navigation_state->set_load_type(NavigationState::NORMAL_LOAD);\n    main_frame->loadRequest(request);\n  }\n  pending_navigation_state_.reset();\n}", "target": 0}
{"code": "posix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}", "target": 0}
{"code": "Eina_Bool ewk_view_mixed_content_run_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    return priv->flags.hasRunMixedContent;\n}", "target": 0}
{"code": "static int zone_batchsize(struct zone *zone)\n{\n#ifdef CONFIG_MMU\n\tint batch;\n\tbatch = zone->managed_pages / 1024;\n\tif (batch * PAGE_SIZE > 512 * 1024)\n\t\tbatch = (512 * 1024) / PAGE_SIZE;\n\tbatch /= 4;\t\t\n\tif (batch < 1)\n\t\tbatch = 1;\n\tbatch = rounddown_pow_of_two(batch + batch/2) - 1;\n\treturn batch;\n#else\n\treturn 0;\n#endif\n}", "target": 0}
{"code": "MagickExport MagickBooleanType DrawPatternPath(Image *image,\n  const DrawInfo *draw_info,const char *name,Image **pattern)\n{\n  char\n    property[MaxTextExtent];\n  const char\n    *geometry,\n    *path,\n    *type;\n  DrawInfo\n    *clone_info;\n  ImageInfo\n    *image_info;\n  MagickBooleanType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  assert(name != (const char *) NULL);\n  (void) FormatLocaleString(property,MaxTextExtent,\"%s\",name);\n  path=GetImageArtifact(image,property);\n  if (path == (const char *) NULL)\n    return(MagickFalse);\n  (void) FormatLocaleString(property,MaxTextExtent,\"%s-geometry\",name);\n  geometry=GetImageArtifact(image,property);\n  if (geometry == (const char *) NULL)\n    return(MagickFalse);\n  if ((*pattern) != (Image *) NULL)\n    *pattern=DestroyImage(*pattern);\n  image_info=AcquireImageInfo();\n  image_info->size=AcquireString(geometry);\n  *pattern=AcquireImage(image_info);\n  image_info=DestroyImageInfo(image_info);\n  (void) QueryColorDatabase(\"#00000000\",&(*pattern)->background_color,\n    &image->exception);\n  (void) SetImageBackgroundColor(*pattern);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"begin pattern-path %s %s\",name,geometry);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=DestroyImage(clone_info->stroke_pattern);\n  (void) FormatLocaleString(property,MaxTextExtent,\"%s-type\",name);\n  type=GetImageArtifact(image,property);\n  if (type != (const char *) NULL)\n    clone_info->gradient.type=(GradientType) ParseCommandOption(\n      MagickGradientOptions,MagickFalse,type);\n  (void) CloneString(&clone_info->primitive,path);\n  status=RenderMVGContent(*pattern,clone_info,0);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end pattern-path\");\n  return(status);\n}", "target": 0}
{"code": "void ChildThread::OnGetTcmallocStats() {\n  std::string result;\n  char buffer[1024 * 32];\n  base::allocator::GetStats(buffer, sizeof(buffer));\n  result.append(buffer);\n  Send(new ChildProcessHostMsg_TcmallocStats(result));\n}", "target": 0}
{"code": "process_ellipse2(STREAM s, ELLIPSE2_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tBRUSH brush;\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->left, delta);\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->top, delta);\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->right, delta);\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->bottom, delta);\n\tif (present & 0x0010)\n\t\tin_uint8(s, os->opcode);\n\tif (present & 0x0020)\n\t\tin_uint8(s, os->fillmode);\n\tif (present & 0x0040)\n\t\trdp_in_colour(s, &os->bgcolour);\n\tif (present & 0x0080)\n\t\trdp_in_colour(s, &os->fgcolour);\n\trdp_parse_brush(s, &os->brush, present >> 8);\n\tDEBUG((\"ELLIPSE2(l=%d,t=%d,r=%d,b=%d,op=0x%x,fm=%d,bs=%d,bg=0x%x,fg=0x%x)\\n\",\n\t       os->left, os->top, os->right, os->bottom, os->opcode, os->fillmode, os->brush.style,\n\t       os->bgcolour, os->fgcolour));\n\tsetup_brush(&brush, &os->brush);\n\tui_ellipse(os->opcode - 1, os->fillmode, os->left, os->top, os->right - os->left,\n\t\t   os->bottom - os->top, &brush, os->bgcolour, os->fgcolour);\n}", "target": 0}
{"code": "TEST(HeaderMapImplTest, HostHeader) {\n  TestRequestHeaderMapImpl request_headers{{\"host\", \"foo\"}};\n  EXPECT_EQ(request_headers.size(), 1);\n  EXPECT_EQ(request_headers.get_(\":authority\"), \"foo\");\n  TestRequestTrailerMapImpl request_trailers{{\"host\", \"foo\"}};\n  EXPECT_EQ(request_trailers.size(), 1);\n  EXPECT_EQ(request_trailers.get_(\"host\"), \"foo\");\n  TestResponseHeaderMapImpl response_headers{{\"host\", \"foo\"}};\n  EXPECT_EQ(response_headers.size(), 1);\n  EXPECT_EQ(response_headers.get_(\"host\"), \"foo\");\n  TestResponseTrailerMapImpl response_trailers{{\"host\", \"foo\"}};\n  EXPECT_EQ(response_trailers.size(), 1);\n  EXPECT_EQ(response_trailers.get_(\"host\"), \"foo\");\n}", "target": 0}
{"code": "void InlineFlowBox::paintFillLayer(const PaintInfo& paintInfo, const Color& c, const FillLayer* fillLayer, int tx, int ty, int w, int h, CompositeOperator op)\n{\n    StyleImage* img = fillLayer->image();\n    bool hasFillImage = img && img->canRender(renderer()->style()->effectiveZoom());\n    if ((!hasFillImage && !renderer()->style()->hasBorderRadius()) || (!prevLineBox() && !nextLineBox()) || !parent())\n        boxModelObject()->paintFillLayerExtended(paintInfo, c, fillLayer, tx, ty, w, h, this, op);\n    else {\n        int logicalOffsetOnLine = 0;\n        int totalLogicalWidth;\n        if (renderer()->style()->direction() == LTR) {\n            for (InlineFlowBox* curr = prevLineBox(); curr; curr = curr->prevLineBox())\n                logicalOffsetOnLine += curr->logicalWidth();\n            totalLogicalWidth = logicalOffsetOnLine;\n            for (InlineFlowBox* curr = this; curr; curr = curr->nextLineBox())\n                totalLogicalWidth += curr->logicalWidth();\n        } else {\n            for (InlineFlowBox* curr = nextLineBox(); curr; curr = curr->nextLineBox())\n                logicalOffsetOnLine += curr->logicalWidth();\n            totalLogicalWidth = logicalOffsetOnLine;\n            for (InlineFlowBox* curr = this; curr; curr = curr->prevLineBox())\n                totalLogicalWidth += curr->logicalWidth();\n        }\n        int stripX = tx - (isHorizontal() ? logicalOffsetOnLine : 0);\n        int stripY = ty - (isHorizontal() ? 0 : logicalOffsetOnLine);\n        int stripWidth = isHorizontal() ? totalLogicalWidth : width();\n        int stripHeight = isHorizontal() ? height() : totalLogicalWidth;\n        paintInfo.context->save();\n        paintInfo.context->clip(IntRect(tx, ty, width(), height()));\n        boxModelObject()->paintFillLayerExtended(paintInfo, c, fillLayer, stripX, stripY, stripWidth, stripHeight, this, op);\n        paintInfo.context->restore();\n    }\n}", "target": 0}
{"code": "static void bnx2x_shutdown(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2x *bp;\n\tif (!dev)\n\t\treturn;\n\tbp = netdev_priv(dev);\n\tif (!bp)\n\t\treturn;\n\trtnl_lock();\n\tnetif_device_detach(dev);\n\trtnl_unlock();\n\t__bnx2x_remove(pdev, dev, bp, false);\n}", "target": 0}
{"code": "static void ff_layout_commit_prepare_common(struct rpc_task *task,\n\t\tstruct nfs_commit_data *cdata)\n{\n\tff_layout_commit_record_layoutstats_start(task, cdata);\n}", "target": 0}
{"code": "static inline struct audit_context *audit_get_context(struct task_struct *tsk,\n\t\t\t\t\t\t      int return_valid,\n\t\t\t\t\t\t      int return_code)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\tif (likely(!context))\n\t\treturn NULL;\n\tcontext->return_valid = return_valid;\n\tcontext->return_code  = return_code;\n\tif (context->in_syscall && !context->dummy && !context->auditable) {\n\t\tenum audit_state state;\n\t\tstate = audit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_EXIT]);\n\t\tif (state == AUDIT_RECORD_CONTEXT) {\n\t\t\tcontext->auditable = 1;\n\t\t\tgoto get_context;\n\t\t}\n\t\tstate = audit_filter_inodes(tsk, context);\n\t\tif (state == AUDIT_RECORD_CONTEXT)\n\t\t\tcontext->auditable = 1;\n\t}\nget_context:\n\ttsk->audit_context = NULL;\n\treturn context;\n}", "target": 0}
{"code": "static int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,\n\t\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_skcipher_blocksize(crypto_skcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint err = -EAGAIN;\n\tint used;\n\tlong copied = 0;\n\tlock_sock(sk);\n\twhile (msg_data_left(msg)) {\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\t\tif (!ctx->used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\t\tused = min_t(unsigned long, ctx->used, msg_data_left(msg));\n\t\tused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t\tif (ctx->more || used < ctx->used)\n\t\t\tused -= used % bs;\n\t\terr = -EINVAL;\n\t\tif (!used)\n\t\t\tgoto free;\n\t\tskcipher_request_set_crypt(&ctx->req, sg, ctx->rsgl.sg, used,\n\t\t\t\t\t   ctx->iv);\n\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_skcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_skcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\nfree:\n\t\taf_alg_free_sg(&ctx->rsgl);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\tcopied += used;\n\t\tskcipher_pull_sgl(sk, used, 1);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\terr = 0;\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\treturn copied ?: err;\n}", "target": 0}
{"code": "static void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\tdrive = 0;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!UDP->cmos && FLOPPY1_TYPE)\n\t\tUDP->cmos = FLOPPY1_TYPE;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = UDP->cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tstatic char temparea[32];\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsprintf(temparea, \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\t*UDP = *params;\n\t}\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}", "target": 0}
{"code": "void HTMLMediaElement::SourceWasAdded(HTMLSourceElement* source) {\n  BLINK_MEDIA_LOG << \"sourceWasAdded(\" << (void*)this << \", \" << source << \")\";\n  KURL url = source->GetNonEmptyURLAttribute(kSrcAttr);\n  BLINK_MEDIA_LOG << \"sourceWasAdded(\" << (void*)this << \") - 'src' is \"\n                  << UrlForLoggingMedia(url);\n  if (FastHasAttribute(kSrcAttr))\n    return;\n  if (getNetworkState() == HTMLMediaElement::kNetworkEmpty) {\n    InvokeResourceSelectionAlgorithm();\n    next_child_node_to_consider_ = source;\n    return;\n  }\n  if (current_source_node_ && source == current_source_node_->nextSibling()) {\n    BLINK_MEDIA_LOG << \"sourceWasAdded(\" << (void*)this\n                    << \") - <source> inserted immediately after current source\";\n    next_child_node_to_consider_ = source;\n    return;\n  }\n  if (next_child_node_to_consider_)\n    return;\n  if (load_state_ != kWaitingForSource)\n    return;\n  SetShouldDelayLoadEvent(true);\n  SetNetworkState(kNetworkLoading);\n  next_child_node_to_consider_ = source;\n  ScheduleNextSourceChild();\n}", "target": 0}
{"code": "DECLAREcpFunc(cpSeparateTiles2ContigTiles)\n{\n\treturn cpImage(in, out,\n\t    readSeparateTilesIntoBuffer,\n\t    writeBufferToContigTiles,\n\t    imagelength, imagewidth, spp);\n}", "target": 0}
{"code": "nth_kday_to_jd(VALUE y, int m, int n, int k, double sg,\n\t       VALUE *nth, int *ry,\n\t       int *rjd,\n\t       int *ns)\n{\n    double style = guess_style(y, sg);\n    if (style == 0) {\n\tint jd;\n\tc_nth_kday_to_jd(FIX2INT(y), m, n, k, sg, &jd, ns);\n\tdecode_jd(INT2FIX(jd), nth, rjd);\n\tif (f_zero_p(*nth))\n\t    *ry = FIX2INT(y);\n\telse {\n\t    VALUE nth2;\n\t    decode_year(y, *ns ? -1 : +1, &nth2, ry);\n\t}\n    }\n    else {\n\tdecode_year(y, style, nth, ry);\n\tc_nth_kday_to_jd(*ry, m, n, k, style, rjd, ns);\n    }\n}", "target": 0}
{"code": "TabMutedReason GetTabAudioMutedReason(content::WebContents* contents) {\n  LastMuteMetadata::CreateForWebContents(contents);  \n  LastMuteMetadata* const metadata =\n      LastMuteMetadata::FromWebContents(contents);\n  if (GetTabAlertStateForContents(contents) == TabAlertState::TAB_CAPTURING) {\n    metadata->reason = TabMutedReason::MEDIA_CAPTURE;\n    metadata->extension_id.clear();\n  }\n  return metadata->reason;\n}", "target": 0}
{"code": "int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,\n\t\t     int len, const void *val)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\tint r;\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\tbus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);\n\tr = __kvm_io_bus_write(vcpu, bus, &range, val);\n\treturn r < 0 ? r : 0;\n}", "target": 0}
{"code": "static void packet_free_pending(struct packet_sock *po)\n{\n\tfree_percpu(po->tx_ring.pending_refcnt);\n}", "target": 0}
{"code": "COND *Item_func_eq::build_equal_items(THD *thd,\n                                      COND_EQUAL *inherited,\n                                      bool link_item_fields,\n                                      COND_EQUAL **cond_equal_ref)\n{\n  COND_EQUAL cond_equal;\n  cond_equal.upper_levels= inherited;\n  List<Item> eq_list;\n  DBUG_ASSERT(!cond_equal_ref || !cond_equal_ref[0]);\n  if (Item_func_eq::check_equality(thd, &cond_equal, &eq_list))\n  {\n    Item_equal *item_equal;\n    int n= cond_equal.current_level.elements + eq_list.elements;\n    if (n == 0)\n      return new (thd->mem_root) Item_int(thd, (longlong) 1, 1);\n    else if (n == 1)\n    {\n      if ((item_equal= cond_equal.current_level.pop()))\n      {\n        item_equal->fix_fields(thd, NULL);\n        item_equal->update_used_tables();\n        set_if_bigger(thd->lex->current_select->max_equal_elems,\n                      item_equal->n_field_items());  \n        item_equal->upper_levels= inherited;\n        if (cond_equal_ref)\n          *cond_equal_ref= new (thd->mem_root) COND_EQUAL(item_equal,\n                                                          thd->mem_root);\n        return item_equal;\n      }\n      Item *res= eq_list.pop();\n      res->update_used_tables();\n      DBUG_ASSERT(res->type() == FUNC_ITEM);\n      return res;\n    }\n    else\n    {\n      Item_cond_and *and_cond= new (thd->mem_root) Item_cond_and(thd, eq_list);\n      and_cond->quick_fix_field();\n      List<Item> *cond_args= and_cond->argument_list();\n      List_iterator_fast<Item_equal> it(cond_equal.current_level);\n      while ((item_equal= it++))\n      {\n        if (item_equal->fix_length_and_dec())\n          return NULL;\n        item_equal->update_used_tables();\n        set_if_bigger(thd->lex->current_select->max_equal_elems,\n                      item_equal->n_field_items());  \n      }\n      and_cond->m_cond_equal.copy(cond_equal);\n      cond_equal.current_level= and_cond->m_cond_equal.current_level;\n      cond_args->append((List<Item> *)&cond_equal.current_level);\n      and_cond->update_used_tables();\n      if (cond_equal_ref)\n        *cond_equal_ref= &and_cond->m_cond_equal;\n      return and_cond;\n    }\n  }\n  return Item_func::build_equal_items(thd, inherited, link_item_fields,\n                                      cond_equal_ref);\n}", "target": 0}
{"code": "static int __packet_rcv_vnet(const struct sk_buff *skb,\n\t\t\t     struct virtio_net_hdr *vnet_hdr)\n{\n\t*vnet_hdr = (const struct virtio_net_hdr) { 0 };\n\tif (virtio_net_hdr_from_skb(skb, vnet_hdr, vio_le()))\n\t\tBUG();\n\treturn 0;\n}", "target": 0}
{"code": "gen_uniop(codegen_scope *s, mrb_sym sym, uint16_t dst)\n{\n  if (no_peephole(s)) return FALSE;\n  struct mrb_insn_data data = mrb_last_insn(s);\n  mrb_int n;\n  if (!get_int_operand(s, &data, &n)) return FALSE;\n  if (sym == MRB_OPSYM_2(s->mrb, plus)) {\n  }\n  else if (sym == MRB_OPSYM_2(s->mrb, minus)) {\n    if (n == MRB_INT_MIN) return FALSE;\n    n = -n;\n  }\n  else if (sym == MRB_OPSYM_2(s->mrb, neg)) {\n    n = ~n;\n  }\n  else {\n    return FALSE;\n  }\n  s->pc = addr_pc(s, data.addr);\n  gen_int(s, dst, n);\n  return TRUE;\n}", "target": 0}
{"code": "static inline unsigned int run_filter(const struct sk_buff *skb,\n\t\t\t\t      const struct sock *sk,\n\t\t\t\t      unsigned int res)\n{\n\tstruct sk_filter *filter;\n\trcu_read_lock();\n\tfilter = rcu_dereference(sk->sk_filter);\n\tif (filter != NULL)\n\t\tres = SK_RUN_FILTER(filter, skb);\n\trcu_read_unlock();\n\treturn res;\n}", "target": 0}
{"code": "SendSetupMessage(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutMessage>%s</OutMessage>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[1024];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * ProtocolType;\t\n\tconst char * InMessage;\t\t\n\tconst char * OutMessage = \"\";\t\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tProtocolType = GetValueFromNameValueList(&data, \"ProtocolType\");\t\n\tInMessage = GetValueFromNameValueList(&data, \"InMessage\");\t\n\tif(ProtocolType == NULL || InMessage == NULL)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\tif(strcmp(ProtocolType, \"WPS\") != 0)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 600, \"Argument Value Invalid\"); \n\t\treturn;\n\t}\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns,\n\t                   OutMessage, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\tClearNameValueList(&data);\n}", "target": 0}
{"code": "    Value::Value(TypeId typeId)\n        : ok_(true), type_(typeId)\n    {\n    }", "target": 0}
{"code": "Message *ProtocolV1::_get_next_outgoing(bufferlist *bl) {\n  Message *m = 0;\n  if (!out_q.empty()) {\n    map<int, list<pair<bufferlist, Message *> > >::reverse_iterator it =\n        out_q.rbegin();\n    ceph_assert(!it->second.empty());\n    list<pair<bufferlist, Message *> >::iterator p = it->second.begin();\n    m = p->second;\n    if (p->first.length() && bl) {\n      assert(bl->length() == 0);\n      bl->swap(p->first);\n    }\n    it->second.erase(p);\n    if (it->second.empty()) out_q.erase(it->first);\n  }\n  return m;\n}", "target": 0}
{"code": "DefaultAudioDestinationHandler::DefaultAudioDestinationHandler(\n    AudioNode& node,\n    const WebAudioLatencyHint& latency_hint)\n    : AudioDestinationHandler(node),\n      latency_hint_(latency_hint) {\n  channel_count_ = 2;\n  SetInternalChannelCountMode(kExplicit);\n  SetInternalChannelInterpretation(AudioBus::kSpeakers);\n}", "target": 0}
{"code": "is_mbc_ambiguous(OnigCaseFoldType flag,\n\t\t const UChar** pp, const UChar* end)\n{\n  int v;\n  const UChar* p = *pp;\n  if (*p == SHARP_s && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    (*pp)++;\n    return TRUE;\n  }\n  (*pp)++;\n  v = (EncISO_8859_14_CtypeTable[*p] & (BIT_CTYPE_UPPER | BIT_CTYPE_LOWER));\n  if ((v | BIT_CTYPE_LOWER) != 0) {\n    return TRUE;\n  }\n  return (v != 0 ? TRUE : FALSE);\n}", "target": 0}
{"code": "                BigTiffImage(BasicIo::UniquePtr io):\n                    Image(ImageType::bigtiff, mdExif, std::move(io)),\n                    header_(readHeader(Image::io())),\n                    dataSize_(0),\n                    doSwap_(false)\n                {\n                    assert(header_.isValid());\n                    doSwap_ =  (isLittleEndianPlatform() && header_.byteOrder() == bigEndian)\n                          ||   (isBigEndianPlatform()    && header_.byteOrder() == littleEndian);\n                    dataSize_ = header_.format() == Header::StandardTiff? 4 : 8;\n                }", "target": 0}
{"code": "void PrintWebViewHelper::PrintPreviewContext::InitWithNode(\n    const WebKit::WebNode& web_node) {\n  DCHECK(!web_node.isNull());\n  DCHECK(!IsRendering());\n  state_ = INITIALIZED;\n  frame_ = web_node.document().frame();\n  node_ = web_node;\n}", "target": 0}
{"code": "HeaderUtility::HeaderData::HeaderData(const envoy::config::route::v3::HeaderMatcher& config)\n    : name_(config.name()), invert_match_(config.invert_match()) {\n  switch (config.header_match_specifier_case()) {\n  case envoy::config::route::v3::HeaderMatcher::HeaderMatchSpecifierCase::kExactMatch:\n    header_match_type_ = HeaderMatchType::Value;\n    value_ = config.exact_match();\n    break;\n  case envoy::config::route::v3::HeaderMatcher::HeaderMatchSpecifierCase::\n      kHiddenEnvoyDeprecatedRegexMatch:\n    header_match_type_ = HeaderMatchType::Regex;\n    regex_ = Regex::Utility::parseStdRegexAsCompiledMatcher(\n        config.hidden_envoy_deprecated_regex_match());\n    break;\n  case envoy::config::route::v3::HeaderMatcher::HeaderMatchSpecifierCase::kSafeRegexMatch:\n    header_match_type_ = HeaderMatchType::Regex;\n    regex_ = Regex::Utility::parseRegex(config.safe_regex_match());\n    break;\n  case envoy::config::route::v3::HeaderMatcher::HeaderMatchSpecifierCase::kRangeMatch:\n    header_match_type_ = HeaderMatchType::Range;\n    range_.set_start(config.range_match().start());\n    range_.set_end(config.range_match().end());\n    break;\n  case envoy::config::route::v3::HeaderMatcher::HeaderMatchSpecifierCase::kPresentMatch:\n    header_match_type_ = HeaderMatchType::Present;\n    break;\n  case envoy::config::route::v3::HeaderMatcher::HeaderMatchSpecifierCase::kPrefixMatch:\n    header_match_type_ = HeaderMatchType::Prefix;\n    value_ = config.prefix_match();\n    break;\n  case envoy::config::route::v3::HeaderMatcher::HeaderMatchSpecifierCase::kSuffixMatch:\n    header_match_type_ = HeaderMatchType::Suffix;\n    value_ = config.suffix_match();\n    break;\n  case envoy::config::route::v3::HeaderMatcher::HeaderMatchSpecifierCase::kContainsMatch:\n    header_match_type_ = HeaderMatchType::Contains;\n    value_ = config.contains_match();\n    break;\n  case envoy::config::route::v3::HeaderMatcher::HeaderMatchSpecifierCase::\n      HEADER_MATCH_SPECIFIER_NOT_SET:\n    FALLTHRU;\n  default:\n    header_match_type_ = HeaderMatchType::Present;\n    break;\n  }\n}", "target": 0}
{"code": "static int gdImageTileGet (gdImagePtr im, int x, int y)\n{\n\tint srcx, srcy;\n\tint tileColor,p;\n\tif (!im->tile) {\n\t\treturn -1;\n\t}\n\tsrcx = x % gdImageSX(im->tile);\n\tsrcy = y % gdImageSY(im->tile);\n\tp = gdImageGetPixel(im->tile, srcx, srcy);\n\tif (p == im->tile->transparent) {\n\t\ttileColor = im->transparent;\n\t} else if (im->trueColor) {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = p;\n\t\t} else {\n\t\t\ttileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t} else {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));\n\t\t} else {\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t}\n\treturn tileColor;\n}", "target": 0}
{"code": "static void release_reg_references(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_func_state *state,\n\t\t\t\t   int ref_obj_id)\n{\n\tstruct bpf_reg_state *regs = state->regs, *reg;\n\tint i;\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tif (regs[i].ref_obj_id == ref_obj_id)\n\t\t\tmark_reg_unknown(env, regs, i);\n\tbpf_for_each_spilled_reg(i, state, reg) {\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tif (reg->ref_obj_id == ref_obj_id)\n\t\t\t__mark_reg_unknown(env, reg);\n\t}\n}", "target": 0}
{"code": "list_pe_resources (WinLibrary *fi, Win32ImageResourceDirectory *pe_res, int level, int *count)\n{\n    WinResource *wr;\n    unsigned int out_c;\n    int dirent_c, rescnt;\n    Win32ImageResourceDirectoryEntry *dirent\n      = (Win32ImageResourceDirectoryEntry *) (pe_res + 1);\n    RETURN_IF_BAD_POINTER(NULL, *dirent);\n    rescnt = pe_res->number_of_named_entries + pe_res->number_of_id_entries;\n    *count = 0;\n    if (rescnt == 0) return NULL;\n    wr = xmalloc(sizeof(WinResource) * rescnt);\n    out_c = 0;\n    for (dirent_c = 0 ; dirent_c < rescnt ; dirent_c++) {\n        RETURN_IF_BAD_POINTER(NULL, dirent[dirent_c]);\n        wr[out_c].this = pe_res;\n        wr[out_c].level = level;\n        wr[out_c].is_directory = (dirent[dirent_c].u2.s.data_is_directory);\n        if (dirent[dirent_c].u2.s.offset_to_directory < sizeof(Win32ImageResourceDirectory))\n            continue;\n        wr[out_c].children = fi->first_resource + dirent[dirent_c].u2.s.offset_to_directory;\n        if (!decode_pe_resource_id (fi, wr + out_c, dirent[dirent_c].u1.name))\n            continue;\n        ++out_c;\n        ++(*count);\n    }\n    if (out_c == 0) {\n        free(wr);\n        return NULL;\n    }\n    return wr;\n}", "target": 0}
{"code": "static inline void ok_jpg_dequantize(ok_jpg_decoder *decoder, ok_jpg_component *c,\n                                     int16_t *in_block, int16_t *out_block) {\n    const uint8_t *q_table = decoder->q_table[c->Tq];\n    for (int k = 0; k < 64; k++) {\n        out_block[ok_jpg_zig_zag[k]] = in_block[k] * q_table[k];\n    }\n}", "target": 0}
{"code": "LIR_Opr LIRGenerator::divInOpr()        { return FrameMap::rax_opr; }", "target": 0}
{"code": "onig_error_code_to_str(UChar* s, OnigPosition code, ...)\n{\n  UChar *p, *q;\n  OnigErrorInfo* einfo;\n  size_t len;\n  int is_over;\n  UChar parbuf[MAX_ERROR_PAR_LEN];\n  va_list vargs;\n  va_start(vargs, code);\n  switch (code) {\n  case ONIGERR_UNDEFINED_NAME_REFERENCE:\n  case ONIGERR_UNDEFINED_GROUP_REFERENCE:\n  case ONIGERR_MULTIPLEX_DEFINED_NAME:\n  case ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL:\n  case ONIGERR_INVALID_GROUP_NAME:\n  case ONIGERR_INVALID_CHAR_IN_GROUP_NAME:\n  case ONIGERR_INVALID_CHAR_PROPERTY_NAME:\n    einfo = va_arg(vargs, OnigErrorInfo*);\n    len = to_ascii(einfo->enc, einfo->par, einfo->par_end,\n\t\t   parbuf, MAX_ERROR_PAR_LEN - 3, &is_over);\n    q = onig_error_code_to_format(code);\n    p = s;\n    while (*q != '\\0') {\n      if (*q == '%') {\n\tq++;\n\tif (*q == 'n') { \n\t  xmemcpy(p, parbuf, len);\n\t  p += len;\n\t  if (is_over != 0) {\n\t    xmemcpy(p, \"...\", 3);\n\t    p += 3;\n\t  }\n\t  q++;\n\t}\n\telse\n\t  goto normal_char;\n      }\n      else {\n      normal_char:\n\t*p++ = *q++;\n      }\n    }\n    *p = '\\0';\n    len = p - s;\n    break;\n  default:\n    q = onig_error_code_to_format(code);\n    if (q) {\n      len = onigenc_str_bytelen_null(ONIG_ENCODING_ASCII, q);\n      xmemcpy(s, q, len);\n    } else {\n      len = 0;\n    }\n    s[len] = '\\0';\n    break;\n  }\n  va_end(vargs);\n  return (int )len;\n}", "target": 0}
{"code": "static void do_pragma_preproc(Token *tline)\n{\n    const char *txt;\n    tline = tline->next;\n    tline = skip_white(tline);\n    if (!tok_type(tline, TOK_ID))\n        return;\n    txt = tok_text(tline);\n    if (!nasm_stricmp(txt, \"sane_empty_expansion\")) {\n        tline = skip_white(tline->next);\n        ppopt.sane_empty_expansion =\n            pp_get_boolean_option(tline, ppopt.sane_empty_expansion);\n    } else {\n    }\n}", "target": 0}
{"code": "static void *seq_buf_alloc(unsigned long size)\n{\n\tif (unlikely(size > MAX_RW_COUNT))\n\t\treturn NULL;\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}", "target": 0}
{"code": "unicode_log2vis (PyUnicodeObject* string,\n                 FriBidiParType base_direction, int clean, int reordernsm)\n{\n    int i;\n    int length = string->length;\n    FriBidiChar *logical = NULL; \n    FriBidiChar *visual = NULL;      \n    FriBidiStrIndex new_len = 0; \n    PyUnicodeObject *result = NULL;\n    logical = PyMem_New (FriBidiChar, length + 1);\n    if (logical == NULL) {\n        PyErr_NoMemory();\n        goto cleanup;\n    }\n    visual = PyMem_New (FriBidiChar, length + 1);\n    if (visual == NULL) {\n        PyErr_NoMemory();\n        goto cleanup;\n    }\n    for (i=0; i<length; ++i) {\n        logical[i] = string->str[i];\n    }\n    fribidi_set_reorder_nsm(reordernsm);\n    if (!fribidi_log2vis (logical, length, &base_direction, visual,\n                          NULL, NULL, NULL)) {\n        PyErr_SetString (PyExc_RuntimeError,\n                         \"fribidi failed to order string\");\n        goto cleanup;\n    }\n    if (clean) {\n        length = fribidi_remove_bidi_marks (visual, length, NULL, NULL, NULL);\n    }\n    result = (PyUnicodeObject*) PyUnicode_FromUnicode(NULL, length);\n    if (result == NULL) {\n        goto cleanup;\n    }\n    for (i=0; i<length; ++i) {\n        result->str[i] = visual[i];\n    }\n  cleanup:\n    PyMem_Del (logical);\n    PyMem_Del (visual);\n    return (PyObject *)result;\n}", "target": 0}
{"code": "static inline bool validHeaderString(absl::string_view s) {\n  for (const char c : s) {\n    switch (c) {\n    case '\\0':\n      FALLTHRU;\n    case '\\r':\n      FALLTHRU;\n    case '\\n':\n      return false;\n    default:\n      continue;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "exec_end_call_list(void)\n{\n  OnigEndCallListItemType* prev;\n  void (*func)(void);\n  while (EndCallTop != 0) {\n    func = EndCallTop->func;\n    (*func)();\n    prev = EndCallTop;\n    EndCallTop = EndCallTop->next;\n    xfree(prev);\n  }\n}", "target": 0}
{"code": "static int fts3ExprIterate(\n  Fts3Expr *pExpr,                \n  int (*x)(Fts3Expr*,int,void*),  \n  void *pCtx                      \n){\n  int iPhrase = 0;                \n  return fts3ExprIterate2(pExpr, &iPhrase, x, pCtx);\n}", "target": 0}
{"code": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t\treturn 0;\n\t}\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}", "target": 0}
{"code": "void PrintWebViewHelper::OnFramePreparedForPrintPages() {\n  PrintPages();\n  FinishFramePrinting();\n}", "target": 0}
{"code": "static inline unsigned long level_size(int level)\n{\n\treturn 1UL << level_to_offset_bits(level);\n}", "target": 0}
{"code": "static void *setup_object(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *object)\n{\n\tsetup_object_debug(s, page, object);\n\tobject = kasan_init_slab_obj(s, object);\n\tif (unlikely(s->ctor)) {\n\t\tkasan_unpoison_object_data(s, object);\n\t\ts->ctor(object);\n\t\tkasan_poison_object_data(s, object);\n\t}\n\treturn object;\n}", "target": 0}
{"code": "_dbus_daemon_publish_session_bus_address (const char* addr,\n                                          const char *scope)\n{\n  return TRUE;\n}", "target": 0}
{"code": "static void vhost_attach_cgroups_work(struct vhost_work *work)\n{\n\tstruct vhost_attach_cgroups_struct *s;\n\ts = container_of(work, struct vhost_attach_cgroups_struct, work);\n\ts->ret = cgroup_attach_task_all(s->owner, current);\n}", "target": 0}
{"code": "TEST(GtOp, ElemMatchKey) {\n    BSONObj operand = BSON(\"$gt\" << 5);\n    GTMatchExpression gt(\"a\", operand[\"$gt\"]);\n    MatchDetails details;\n    details.requestElemMatchKey();\n    ASSERT(!gt.matchesBSON(BSON(\"a\" << 4), &details));\n    ASSERT(!details.hasElemMatchKey());\n    ASSERT(gt.matchesBSON(BSON(\"a\" << 6), &details));\n    ASSERT(!details.hasElemMatchKey());\n    ASSERT(gt.matchesBSON(BSON(\"a\" << BSON_ARRAY(2 << 6 << 5)), &details));\n    ASSERT(details.hasElemMatchKey());\n    ASSERT_EQUALS(\"1\", details.elemMatchKey());\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoTexParameterfv(\n    GLenum target, GLenum pname, const GLfloat* params) {\n  TextureManager::TextureInfo* info = GetTextureInfoForTarget(target);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glTexParameterfv: unknown texture\");\n  } else {\n    texture_manager()->SetParameter(\n        info, pname, *reinterpret_cast<const GLint*>(params));\n    glTexParameterfv(target, pname, params);\n  }\n}", "target": 0}
{"code": "static void evdev_event(struct input_handle *handle,\n\t\t\tunsigned int type, unsigned int code, int value)\n{\n\tstruct input_value vals[] = { { type, code, value } };\n\tevdev_events(handle, vals, 1);\n}", "target": 0}
{"code": "    int Modify::addMetadatum(Exiv2::Image* pImage, const ModifyCmd& modifyCmd)\n    {\n        if (Params::instance().verbose_) {\n            std::cout << _(\"Add\") << \" \" << modifyCmd.key_ << \" \\\"\" << modifyCmd.value_ << \"\\\" (\"\n                      << Exiv2::TypeInfo::typeName(modifyCmd.typeId_) << \")\" << std::endl;\n        }\n        Exiv2::ExifData& exifData = pImage->exifData();\n        Exiv2::IptcData& iptcData = pImage->iptcData();\n        Exiv2::XmpData& xmpData = pImage->xmpData();\n        Exiv2::Value::UniquePtr value = Exiv2::Value::create(modifyCmd.typeId_);\n        int rc = value->read(modifyCmd.value_);\n        if (0 == rc) {\n            if (modifyCmd.metadataId_ == exif) {\n                exifData.add(Exiv2::ExifKey(modifyCmd.key_), value.get());\n            }\n            if (modifyCmd.metadataId_ == iptc) {\n                iptcData.add(Exiv2::IptcKey(modifyCmd.key_), value.get());\n            }\n            if (modifyCmd.metadataId_ == xmp) {\n                xmpData.add(Exiv2::XmpKey(modifyCmd.key_), value.get());\n            }\n        } else {\n            std::cerr << _(\"Warning\") << \": \" << modifyCmd.key_ << \": \" << _(\"Failed to read\") << \" \"\n                      << Exiv2::TypeInfo::typeName(value->typeId()) << \" \" << _(\"value\") << \" \\\"\" << modifyCmd.value_\n                      << \"\\\"\\n\";\n        }\n        return rc;\n    }", "target": 0}
{"code": "TEST_F(QueryPlannerTest, SortLimit) {\n    runQuerySortProjSkipNToReturn(BSONObj(), fromjson(\"{a: 1}\"), BSONObj(), 0, -3);\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{sort: {pattern: {a: 1}, limit: 3, node: {sortKeyGen: \"\n        \"{node: {cscan: {dir: 1}}}}}}\");\n}", "target": 0}
{"code": "void __check_heap_object(const void *ptr, unsigned long n, struct page *page,\n\t\t\t bool to_user)\n{\n\tstruct kmem_cache *s;\n\tunsigned int offset;\n\tsize_t object_size;\n\tptr = kasan_reset_tag(ptr);\n\ts = page->slab_cache;\n\tif (ptr < page_address(page))\n\t\tusercopy_abort(\"SLUB object not in SLUB page?!\", NULL,\n\t\t\t       to_user, 0, n);\n\toffset = (ptr - page_address(page)) % s->size;\n\tif (kmem_cache_debug(s) && s->flags & SLAB_RED_ZONE) {\n\t\tif (offset < s->red_left_pad)\n\t\t\tusercopy_abort(\"SLUB object in left red zone\",\n\t\t\t\t       s->name, to_user, offset, n);\n\t\toffset -= s->red_left_pad;\n\t}\n\tif (offset >= s->useroffset &&\n\t    offset - s->useroffset <= s->usersize &&\n\t    n <= s->useroffset - offset + s->usersize)\n\t\treturn;\n\tobject_size = slab_ksize(s);\n\tif (usercopy_fallback &&\n\t    offset <= object_size && n <= object_size - offset) {\n\t\tusercopy_warn(\"SLUB object\", s->name, to_user, offset, n);\n\t\treturn;\n\t}\n\tusercopy_abort(\"SLUB object\", s->name, to_user, offset, n);\n}", "target": 0}
{"code": "buf_get_first_chunk_data(const buf_t *buf, const char **cp, size_t *sz)\n{\n  if (!buf || !buf->head) {\n    *cp = NULL;\n    *sz = 0;\n  } else {\n    *cp = buf->head->data;\n    *sz = buf->head->datalen;\n  }\n}", "target": 0}
{"code": "void js_pushliteral(js_State *J, const char *v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TLITSTR;\n\tSTACK[TOP].u.litstr = v;\n\t++TOP;\n}", "target": 0}
{"code": "const char* sldns_get_errorstr_parse(int e)\n{\n\tsldns_lookup_table *lt;\n\tlt = sldns_lookup_by_id(sldns_wireparse_errors, LDNS_WIREPARSE_ERROR(e));\n\treturn lt?lt->name:\"unknown error\";\n}", "target": 0}
{"code": "magic_load(struct magic_set *ms, const char *magicfile)\n{\n\tif (ms == NULL)\n\treturn -1;\n\treturn file_apprentice(ms, magicfile, FILE_LOAD);\n}", "target": 0}
{"code": "static void reset_csb_pointers(struct intel_engine_cs *engine)\n{\n\tstruct intel_engine_execlists * const execlists = &engine->execlists;\n\tconst unsigned int reset_value = execlists->csb_size - 1;\n\tring_set_paused(engine, 0);\n\texeclists->csb_head = reset_value;\n\tWRITE_ONCE(*execlists->csb_write, reset_value);\n\twmb(); \n\tinvalidate_csb_entries(&execlists->csb_status[0],\n\t\t\t       &execlists->csb_status[reset_value]);\n}", "target": 0}
{"code": "int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,\n\t\t    unsigned long pfn, unsigned long size, pgprot_t prot)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\tif (is_cow_mapping(vma->vm_flags)) {\n\t\tif (addr != vma->vm_start || end != vma->vm_end)\n\t\t\treturn -EINVAL;\n\t\tvma->vm_pgoff = pfn;\n\t}\n\tvma->vm_flags |= VM_IO | VM_RESERVED | VM_PFNMAP;\n\tBUG_ON(addr >= end);\n\tpfn -= addr >> PAGE_SHIFT;\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = remap_pud_range(mm, pgd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\treturn err;\n}", "target": 0}
{"code": "static int fill_buffer(aac_buffer *b)\n{\n    int bread;\n    if (b->bytes_consumed > 0)\n    {\n        if (b->bytes_into_buffer)\n        {\n            memmove((void*)b->buffer, (void*)(b->buffer + b->bytes_consumed),\n                b->bytes_into_buffer*sizeof(unsigned char));\n        }\n        if (!b->at_eof)\n        {\n            bread = fread((void*)(b->buffer + b->bytes_into_buffer), 1,\n                b->bytes_consumed, b->infile);\n            if (bread != b->bytes_consumed)\n                b->at_eof = 1;\n            b->bytes_into_buffer += bread;\n        }\n        b->bytes_consumed = 0;\n        if (b->bytes_into_buffer > 3)\n        {\n            if (memcmp(b->buffer, \"TAG\", 3) == 0)\n                b->bytes_into_buffer = 0;\n        }\n        if (b->bytes_into_buffer > 11)\n        {\n            if (memcmp(b->buffer, \"LYRICSBEGIN\", 11) == 0)\n                b->bytes_into_buffer = 0;\n        }\n        if (b->bytes_into_buffer > 8)\n        {\n            if (memcmp(b->buffer, \"APETAGEX\", 8) == 0)\n                b->bytes_into_buffer = 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "tiff_document_class_init (TiffDocumentClass *klass)\n{\n\tGObjectClass    *gobject_class = G_OBJECT_CLASS (klass);\n\tEvDocumentClass *ev_document_class = EV_DOCUMENT_CLASS (klass);\n\tgobject_class->finalize = tiff_document_finalize;\n\tev_document_class->load = tiff_document_load;\n\tev_document_class->save = tiff_document_save;\n\tev_document_class->get_n_pages = tiff_document_get_n_pages;\n\tev_document_class->get_page_size = tiff_document_get_page_size;\n\tev_document_class->render = tiff_document_render;\n\tev_document_class->get_thumbnail = tiff_document_get_thumbnail;\n\tev_document_class->get_page_label = tiff_document_get_page_label;\n}", "target": 0}
{"code": "static int unmount_fuse(const char *mnt, int quiet, int lazy)\n{\n\tint res;\n\tint mtablock = lock_umount();\n\tres = unmount_fuse_locked(mnt, quiet, lazy);\n\tunlock_umount(mtablock);\n\treturn res;\n}", "target": 0}
{"code": "bool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs)\n{\n\treturn false;\n}", "target": 0}
{"code": "v8::Handle<v8::Value> toV8ForMainWorld(DOMWindow* window, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)\n{\n    return toV8(window, creationContext, isolate);\n}", "target": 0}
{"code": "static ssize_t tnt_control_send(struct gps_device_t *session,\n\t\t\t\tchar *msg, size_t len UNUSED)\n{\n    ssize_t status;\n    tnt_add_checksum(msg);\n    status = write(session->gpsdata.gps_fd, msg, strlen(msg));\n    (void)tcdrain(session->gpsdata.gps_fd);\n    return status;\n}", "target": 0}
{"code": "  void GetUsageAndQuotaForEviction() {\n    quota_status_ = kQuotaStatusUnknown;\n    usage_ = -1;\n    unlimited_usage_ = -1;\n    quota_ = -1;\n    available_space_ = -1;\n    quota_manager_->GetUsageAndQuotaForEviction(\n        callback_factory_.NewCallback(\n            &QuotaManagerTest::DidGetUsageAndQuotaForEviction));\n  }", "target": 0}
{"code": "WebNavigationPolicy RenderView::decidePolicyForNavigation(\n    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,\n    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {\n  const GURL& url = request.url();\n  if (renderer_preferences_.browser_handles_top_level_requests &&\n      IsNonLocalTopLevelNavigation(url, frame, type)) {\n    last_top_level_navigation_page_id_ = page_id_;\n    GURL referrer(request.httpHeaderField(WebString::fromUTF8(\"Referer\")));\n    OpenURL(url, referrer, default_policy);\n    return WebKit::WebNavigationPolicyIgnore;  \n  }\n  bool is_content_initiated =\n      NavigationState::FromDataSource(frame->provisionalDataSource())->\n          is_content_initiated();\n  if (default_policy == WebKit::WebNavigationPolicyCurrentTab &&\n      is_content_initiated && frame->parent() == NULL &&\n      type != WebKit::WebNavigationTypeFormSubmitted &&\n      !url.SchemeIs(chrome::kAboutScheme)) {\n    if (CrossesExtensionExtents(frame, url) ||\n        BindingsPolicy::is_dom_ui_enabled(enabled_bindings_) ||\n        frame->isViewSourceModeEnabled() ||\n        url.SchemeIs(chrome::kViewSourceScheme)) {\n      OpenURL(url, GURL(), default_policy);\n      return WebKit::WebNavigationPolicyIgnore;  \n    }\n    if (BindingsPolicy::is_extension_enabled(enabled_bindings_) &&\n        IsNonLocalTopLevelNavigation(url, frame, type)) {\n        OpenURL(url, GURL(), default_policy);\n        return WebKit::WebNavigationPolicyIgnore;  \n    }\n  }\n  bool is_fork =\n      GURL(frame->url()) == GURL(chrome::kAboutBlankURL) &&\n      historyBackListCount() < 1 &&\n      historyForwardListCount() < 1 &&\n      frame->opener() == NULL &&\n      frame->parent() == NULL &&\n      is_content_initiated &&\n      default_policy == WebKit::WebNavigationPolicyCurrentTab &&\n      type == WebKit::WebNavigationTypeOther;\n  bool is_noreferrer_and_blank_target =\n      frame->parent() == NULL &&\n      frame->url().isEmpty() &&\n      historyBackListCount() < 1 &&\n      historyForwardListCount() < 1 &&\n      request.httpHeaderField(WebString::fromUTF8(\"Referer\")).isNull() &&\n      opener_suppressed_ &&\n      frame->opener() == NULL &&\n      frame->name().isNull() &&\n      !creator_url_.is_empty() &&\n      is_content_initiated &&\n      default_policy == WebKit::WebNavigationPolicyCurrentTab &&\n      type == WebKit::WebNavigationTypeOther;\n  if (is_fork || is_noreferrer_and_blank_target) {\n    OpenURL(url, GURL(), default_policy);\n    return WebKit::WebNavigationPolicyIgnore;\n  }\n  return default_policy;\n}", "target": 0}
{"code": "_XkbSetGeometry(ClientPtr client, DeviceIntPtr dev, xkbSetGeometryReq *stuff)\n{\n    XkbDescPtr\t\txkb;\n    Bool\t\tnew_name;\n    xkbNewKeyboardNotify\tnkn;\n    XkbGeometryPtr\tgeom,old;\n    XkbGeometrySizesRec\tsizes;\n    Status\t\tstatus;\n    xkb= dev->key->xkbInfo->desc;\n    old= xkb->geom;\n    xkb->geom= NULL;\n    sizes.which=\t\tXkbGeomAllMask;\n    sizes.num_properties=\tstuff->nProperties;\n    sizes.num_colors=\tstuff->nColors;\n    sizes.num_shapes=\tstuff->nShapes;\n    sizes.num_sections=\tstuff->nSections;\n    sizes.num_doodads=\tstuff->nDoodads;\n    sizes.num_key_aliases=\tstuff->nKeyAliases;\n    if ((status= XkbAllocGeometry(xkb,&sizes))!=Success) {\n        xkb->geom= old;\n        return status;\n    }\n    geom= xkb->geom;\n    geom->name= stuff->name;\n    geom->width_mm= stuff->widthMM;\n    geom->height_mm= stuff->heightMM;\n    if ((status= _CheckSetGeom(geom,stuff,client))!=Success) {\n        XkbFreeGeometry(geom,XkbGeomAllMask,True);\n        xkb->geom= old;\n        return status;\n    }\n    new_name= (xkb->names->geometry!=geom->name);\n    xkb->names->geometry= geom->name;\n    if (old)\n        XkbFreeGeometry(old,XkbGeomAllMask,True);\n    if (new_name) {\n        xkbNamesNotify\tnn;\n        bzero(&nn,sizeof(xkbNamesNotify));\n        nn.changed= XkbGeometryNameMask;\n        XkbSendNamesNotify(dev,&nn);\n    }\n    nkn.deviceID= nkn.oldDeviceID= dev->id;\n    nkn.minKeyCode= nkn.oldMinKeyCode= xkb->min_key_code;\n    nkn.maxKeyCode= nkn.oldMaxKeyCode= xkb->max_key_code;\n    nkn.requestMajor=\tXkbReqCode;\n    nkn.requestMinor=\tX_kbSetGeometry;\n    nkn.changed=\tXkbNKN_GeometryMask;\n    XkbSendNewKeyboardNotify(dev,&nkn);\n    return Success;\n}", "target": 0}
{"code": "static bool bnx2x_is_contextless_ramrod(int cmd, int cmd_type)\n{\n\tif ((cmd_type == NONE_CONNECTION_TYPE) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_FORWARD_SETUP) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_CLASSIFICATION_RULES) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_FILTER_RULES) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_MULTICAST_RULES) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_SET_MAC) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_RSS_UPDATE))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "target": 0}
{"code": "rb_set_head_page(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct buffer_page *head;\n\tstruct buffer_page *page;\n\tstruct list_head *list;\n\tint i;\n\tif (RB_WARN_ON(cpu_buffer, !cpu_buffer->head_page))\n\t\treturn NULL;\n\tlist = cpu_buffer->pages;\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->prev->next) != list))\n\t\treturn NULL;\n\tpage = head = cpu_buffer->head_page;\n\tfor (i = 0; i < 3; i++) {\n\t\tdo {\n\t\t\tif (rb_is_head_page(page, page->list.prev)) {\n\t\t\t\tcpu_buffer->head_page = page;\n\t\t\t\treturn page;\n\t\t\t}\n\t\t\trb_inc_page(&page);\n\t\t} while (page != head);\n\t}\n\tRB_WARN_ON(cpu_buffer, 1);\n\treturn NULL;\n}", "target": 0}
{"code": "void Statement::CleanQueue() {\n    Napi::Env env = this->Env();\n    Napi::HandleScope scope(env);\n    if (prepared && !queue.empty()) {\n        EXCEPTION(Napi::String::New(env, \"Statement is already finalized\"), SQLITE_MISUSE, exception);\n        Napi::Value argv[] = { exception };\n        bool called = false;\n        while (!queue.empty()) {\n            std::unique_ptr<Call> call(queue.front());\n            queue.pop();\n            std::unique_ptr<Baton> baton(call->baton);\n            Napi::Function cb = baton->callback.Value();\n            if (prepared && !cb.IsEmpty() &&\n                cb.IsFunction()) {\n                TRY_CATCH_CALL(Value(), cb, 1, argv);\n                called = true;\n            }\n        }\n        if (!called) {\n            Napi::Value info[] = { Napi::String::New(env, \"error\"), exception };\n            EMIT_EVENT(Value(), 2, info);\n        }\n    }\n    else while (!queue.empty()) {\n        std::unique_ptr<Call> call(queue.front());\n        queue.pop();\n        delete call->baton;\n    }\n}", "target": 0}
{"code": "    std::string CrwImage::mimeType() const\n    {\n        return \"image/x-canon-crw\";\n    }", "target": 0}
{"code": "acl_udpsend(const uschar *arg, uschar **log_msgptr)\n{\nint sep = 0;\nuschar *hostname;\nuschar *portstr;\nuschar *portend;\nhost_item *h;\nint portnum;\nint len;\nint r, s;\nuschar * errstr;\nhostname = string_nextinlist(&arg, &sep, NULL, 0);\nportstr = string_nextinlist(&arg, &sep, NULL, 0);\nif (!hostname)\n  {\n  *log_msgptr = US\"missing destination host in \\\"udpsend\\\" modifier\";\n  return ERROR;\n  }\nif (!portstr)\n  {\n  *log_msgptr = US\"missing destination port in \\\"udpsend\\\" modifier\";\n  return ERROR;\n  }\nif (!arg)\n  {\n  *log_msgptr = US\"missing datagram payload in \\\"udpsend\\\" modifier\";\n  return ERROR;\n  }\nportnum = Ustrtol(portstr, &portend, 10);\nif (*portend != '\\0')\n  {\n  *log_msgptr = US\"bad destination port in \\\"udpsend\\\" modifier\";\n  return ERROR;\n  }\nh = store_get(sizeof(host_item));\nmemset(h, 0, sizeof(host_item));\nh->name = hostname;\nh->port = portnum;\nh->mx = MX_NONE;\nif (string_is_ip_address(hostname, NULL))\n  h->address = hostname, r = HOST_FOUND;\nelse\n  r = host_find_byname(h, NULL, 0, NULL, FALSE);\nif (r == HOST_FIND_FAILED || r == HOST_FIND_AGAIN)\n  {\n  *log_msgptr = US\"DNS lookup failed in \\\"udpsend\\\" modifier\";\n  return DEFER;\n  }\nHDEBUG(D_acl)\n  debug_printf_indent(\"udpsend [%s]:%d %s\\n\", h->address, portnum, arg);\nr = s = ip_connectedsocket(SOCK_DGRAM, h->address, portnum, portnum,\n\t\t1, NULL, &errstr, NULL);\nif (r < 0) goto defer;\nlen = Ustrlen(arg);\nr = send(s, arg, len, 0);\nif (r < 0)\n  {\n  errstr = US strerror(errno);\n  close(s);\n  goto defer;\n  }\nclose(s);\nif (r < len)\n  {\n  *log_msgptr =\n    string_sprintf(\"\\\"udpsend\\\" truncated from %d to %d octets\", len, r);\n  return DEFER;\n  }\nHDEBUG(D_acl)\n  debug_printf_indent(\"udpsend %d bytes\\n\", r);\nreturn OK;\ndefer:\n*log_msgptr = string_sprintf(\"\\\"udpsend\\\" failed: %s\", errstr);\nreturn DEFER;\n}", "target": 0}
{"code": "static inline bool vmcs12_read_any(struct kvm_vcpu *vcpu,\n\t\t\t\t\tunsigned long field, u64 *ret)\n{\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p;\n\tif (offset < 0)\n\t\treturn 0;\n\tp = ((char *)(get_vmcs12(vcpu))) + offset;\n\tswitch (vmcs_field_type(field)) {\n\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t*ret = *((natural_width *)p);\n\t\treturn 1;\n\tcase VMCS_FIELD_TYPE_U16:\n\t\t*ret = *((u16 *)p);\n\t\treturn 1;\n\tcase VMCS_FIELD_TYPE_U32:\n\t\t*ret = *((u32 *)p);\n\t\treturn 1;\n\tcase VMCS_FIELD_TYPE_U64:\n\t\t*ret = *((u64 *)p);\n\t\treturn 1;\n\tdefault:\n\t\treturn 0; \n\t}\n}", "target": 0}
{"code": "static int mov_read_mdhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n    char language[4] = {0};\n    unsigned lang;\n    int64_t creation_time;\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n    if (sc->time_scale) {\n        av_log(c->fc, AV_LOG_ERROR, \"Multiple mdhd?\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    version = avio_r8(pb);\n    if (version > 1) {\n        avpriv_request_sample(c->fc, \"Version %d\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n    avio_rb24(pb); \n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); \n    }\n    mov_metadata_creation_time(&st->metadata, creation_time, c->fc);\n    sc->time_scale = avio_rb32(pb);\n    if (sc->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid mdhd time scale %d, defaulting to 1\\n\", sc->time_scale);\n        sc->time_scale = 1;\n    }\n    st->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); \n    lang = avio_rb16(pb); \n    if (ff_mov_lang_to_iso639(lang, language))\n        av_dict_set(&st->metadata, \"language\", language, 0);\n    avio_rb16(pb); \n    return 0;\n}", "target": 0}
{"code": "list_files_by_dir (const char *dirnam, char **pargz, size_t *pargz_len)\n{\n  DIR\t*dirp\t  = 0;\n  int    errors\t  = 0;\n  assert (dirnam && *dirnam);\n  assert (pargz);\n  assert (pargz_len);\n  assert (dirnam[LT_STRLEN(dirnam) -1] != '/');\n  dirp = opendir (dirnam);\n  if (dirp)\n    {\n      struct dirent *dp\t= 0;\n      while ((dp = readdir (dirp)))\n\tif (dp->d_name[0] != '.')\n\t  if (lt_argz_insertdir (pargz, pargz_len, dirnam, dp))\n\t    {\n\t      ++errors;\n\t      break;\n\t    }\n      closedir (dirp);\n    }\n  else\n    ++errors;\n  return errors;\n}", "target": 0}
{"code": "update_stats_dequeue(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tif (se != cfs_rq->curr)\n\t\tupdate_stats_wait_end(cfs_rq, se);\n}", "target": 0}
{"code": "void QuotaManager::GetTemporaryGlobalQuota(QuotaCallback* callback) {\n  LazyInitialize();\n  if (temporary_global_quota_ >= 0) {\n    callback->Run(kQuotaStatusOk,\n                  kStorageTypeTemporary, temporary_global_quota_);\n    delete callback;\n    return;\n  }\n  temporary_global_quota_callbacks_.Add(callback);\n}", "target": 0}
{"code": "AP_DECLARE(void) ap_hook_check_authz(ap_HOOK_auth_checker_t *pf,\n                                     const char * const *aszPre,\n                                     const char * const *aszSucc,\n                                     int nOrder, int type)\n{\n    if ((type & AP_AUTH_INTERNAL_MASK) == AP_AUTH_INTERNAL_PER_CONF) {\n        ++auth_internal_per_conf_hooks;\n    }\n    ap_hook_auth_checker(pf, aszPre, aszSucc, nOrder);\n}", "target": 0}
{"code": "scoped_ptr<gfx::GpuMemoryBuffer> RenderThreadImpl::AllocateGpuMemoryBuffer(\n    size_t width,\n    size_t height,\n    unsigned internalformat,\n    unsigned usage) {\n  TRACE_EVENT0(\"renderer\", \"RenderThreadImpl::AllocateGpuMemoryBuffer\");\n  DCHECK(allocate_gpu_memory_buffer_thread_checker_.CalledOnValidThread());\n  if (!GpuMemoryBufferImpl::IsFormatValid(internalformat))\n    return scoped_ptr<gfx::GpuMemoryBuffer>();\n  gfx::GpuMemoryBufferHandle handle;\n  bool success;\n  IPC::Message* message = new ChildProcessHostMsg_SyncAllocateGpuMemoryBuffer(\n      width, height, internalformat, usage, &handle);\n  if (base::MessageLoop::current() == message_loop())\n    success = ChildThread::Send(message);\n  else\n    success = sync_message_filter()->Send(message);\n  if (!success)\n    return scoped_ptr<gfx::GpuMemoryBuffer>();\n  scoped_ptr<GpuMemoryBufferImpl> buffer(GpuMemoryBufferImpl::CreateFromHandle(\n      handle,\n      gfx::Size(width, height),\n      internalformat,\n      base::Bind(&DeletedGpuMemoryBuffer,\n                 make_scoped_refptr(thread_safe_sender()),\n                 handle.type,\n                 handle.global_id)));\n  if (!buffer) {\n    thread_safe_sender()->Send(new ChildProcessHostMsg_DeletedGpuMemoryBuffer(\n        handle.type, handle.global_id));\n    return scoped_ptr<gfx::GpuMemoryBuffer>();\n  }\n  return buffer.PassAs<gfx::GpuMemoryBuffer>();\n}", "target": 0}
{"code": "static inline void applyCSSPropertyToTargetAndInstances(SVGElement* targetElement, const QualifiedName& attributeName, const String& valueAsString)\n{\n    ASSERT(targetElement);\n    if (attributeName == anyQName() || !targetElement->inDocument() || !targetElement->parentNode())\n        return;\n    CSSPropertyID id = cssPropertyID(attributeName.localName());\n    SVGElementInstance::InstanceUpdateBlocker blocker(targetElement);\n    applyCSSPropertyToTarget(targetElement, id, valueAsString);\n    const HashSet<SVGElementInstance*>& instances = targetElement->instancesForElement();\n    const HashSet<SVGElementInstance*>::const_iterator end = instances.end();\n    for (HashSet<SVGElementInstance*>::const_iterator it = instances.begin(); it != end; ++it) {\n        if (SVGElement* shadowTreeElement = (*it)->shadowTreeElement())\n            applyCSSPropertyToTarget(shadowTreeElement, id, valueAsString);\n    }\n}", "target": 0}
{"code": "static CURLcode brotli_map_error(BrotliDecoderErrorCode be)\n{\n  switch(be) {\n  case BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE:\n  case BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE:\n  case BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET:\n  case BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME:\n  case BROTLI_DECODER_ERROR_FORMAT_CL_SPACE:\n  case BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE:\n  case BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT:\n  case BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1:\n  case BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2:\n  case BROTLI_DECODER_ERROR_FORMAT_TRANSFORM:\n  case BROTLI_DECODER_ERROR_FORMAT_DICTIONARY:\n  case BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS:\n  case BROTLI_DECODER_ERROR_FORMAT_PADDING_1:\n  case BROTLI_DECODER_ERROR_FORMAT_PADDING_2:\n#ifdef BROTLI_DECODER_ERROR_COMPOUND_DICTIONARY\n  case BROTLI_DECODER_ERROR_COMPOUND_DICTIONARY:\n#endif\n#ifdef BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET\n  case BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET:\n#endif\n  case BROTLI_DECODER_ERROR_INVALID_ARGUMENTS:\n    return CURLE_BAD_CONTENT_ENCODING;\n  case BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES:\n  case BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS:\n  case BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP:\n  case BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1:\n  case BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2:\n  case BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES:\n    return CURLE_OUT_OF_MEMORY;\n  default:\n    break;\n  }\n  return CURLE_WRITE_ERROR;\n}", "target": 0}
{"code": "static size_t getFrameSize(unsigned FT) {\n static const size_t kFrameSizeWB[10] = {\n 132, 177, 253, 285, 317, 365, 397, 461, 477, 40\n };\n if (FT >= 10) {\n return 1;\n }\n size_t frameSize = kFrameSizeWB[FT];\n    frameSize = (frameSize + 7) / 8 + 1;\n return frameSize;\n}", "target": 0}
{"code": "int power_pmu_commit_txn(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuhw;\n\tlong i, n;\n\tif (!ppmu)\n\t\treturn -EAGAIN;\n\tcpuhw = &__get_cpu_var(cpu_hw_events);\n\tn = cpuhw->n_events;\n\tif (check_excludes(cpuhw->event, cpuhw->flags, 0, n))\n\t\treturn -EAGAIN;\n\ti = power_check_constraints(cpuhw, cpuhw->events, cpuhw->flags, n);\n\tif (i < 0)\n\t\treturn -EAGAIN;\n\tfor (i = cpuhw->n_txn_start; i < n; ++i)\n\t\tcpuhw->event[i]->hw.config = cpuhw->events[i];\n\tcpuhw->group_flag &= ~PERF_EVENT_TXN;\n\tperf_pmu_enable(pmu);\n\treturn 0;\n}", "target": 0}
{"code": "static bool torture_winbind_struct_dsgetdcname(struct torture_context *torture)\n{\n\tbool ok;\n\tbool strict = torture_setting_bool(torture, \"strict mode\", false);\n\tstruct torture_trust_domain *listd = NULL;\n\tuint32_t i;\n\tuint32_t count = 0;\n\ttorture_comment(torture, \"Running WINBINDD_DSGETDCNAME (struct based)\\n\");\n\tok = get_trusted_domains(torture, &listd);\n\ttorture_assert(torture, ok, \"failed to get trust list\");\n\tfor (i=0; listd && listd[i].netbios_name; i++) {\n\t\tstruct winbindd_request req;\n\t\tstruct winbindd_response rep;\n\t\tZERO_STRUCT(req);\n\t\tZERO_STRUCT(rep);\n\t\tif (strlen(listd[i].dns_name) == 0) continue;\n\t\tif (strcmp(listd[i].dns_name, listd[i].netbios_name) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfstrcpy(req.domain_name, listd[i].dns_name);\n\t\treq.flags = DS_DIRECTORY_SERVICE_REQUIRED;\n\t\tok = true;\n\t\tDO_STRUCT_REQ_REP_EXT(WINBINDD_DSGETDCNAME, &req, &rep,\n\t\t\t\t      NSS_STATUS_SUCCESS,\n\t\t\t\t      strict, ok = false,\n\t\t\t\t      talloc_asprintf(torture, \"DOMAIN '%s'\",\n\t\t\t\t\t\t      req.domain_name));\n\t\tif (!ok) continue;\n\t\ttorture_comment(torture, \"DOMAIN '%s' => DCNAME '%s'\\n\",\n\t\t\t\treq.domain_name, rep.data.dc_name);\n\t\tcount++;\n\t}\n\tif (count == 0) {\n\t\ttorture_warning(torture, \"WINBINDD_DSGETDCNAME\"\n\t\t\t\t\" was not tested with %d non-AD domains\",\n\t\t\t\ti);\n\t}\n\tif (strict) {\n\t\ttorture_assert(torture, count > 0,\n\t\t\t       \"WiNBINDD_DSGETDCNAME was not tested\");\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n{\n\tonig_free(*pre);\n}", "target": 0}
{"code": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tif (!pipe_buf_get(ipipe, ibuf)) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n \t\tobuf = opipe->bufs + nbuf;\n \t\t*obuf = *ibuf;\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\treturn ret;\n}", "target": 0}
{"code": "JvmtiCachedClassFileData* InstanceKlass::get_cached_class_file() {\n  if (MetaspaceShared::is_in_shared_metaspace(_cached_class_file)) {\n    return NULL;\n  } else {\n    return _cached_class_file;\n  }\n}", "target": 0}
{"code": "static void CorrectPhaseLHS(const size_t width,const size_t height,\n  double *fourier_pixels)\n{\n  register ssize_t\n    x;\n  ssize_t\n    y;\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      fourier_pixels[y*width+x]*=(-1.0);\n}", "target": 0}
{"code": "static inline void init_freelist_randomization(void) { }", "target": 0}
{"code": "static int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\tif (cap_info->index > 0 &&\n\t    (cap_info->header.headersize == 0 ||\n\t     cap_info->count < cap_info->total_size)) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t}\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "TIFFjpeg_read_header(JPEGState* sp, boolean require_image)\n{\n\treturn CALLJPEG(sp, -1, jpeg_read_header(&sp->cinfo.d, require_image));\n}", "target": 0}
{"code": "static struct eth_spe *bnx2x_sp_get_next(struct bnx2x *bp)\n{\n\tstruct eth_spe *next_spe = bp->spq_prod_bd;\n\tif (bp->spq_prod_bd == bp->spq_last_bd) {\n\t\tbp->spq_prod_bd = bp->spq;\n\t\tbp->spq_prod_idx = 0;\n\t\tDP(BNX2X_MSG_SP, \"end of spq\\n\");\n\t} else {\n\t\tbp->spq_prod_bd++;\n\t\tbp->spq_prod_idx++;\n\t}\n\treturn next_spe;\n}", "target": 0}
{"code": "static void split_certinfo(char *string, zval *hash)\n{\n\tchar *org = estrdup(string);\n\tchar *s = org;\n\tchar *split;\n\tif(org) {\n\t\tdo {\n\t\t\tchar *key;\n\t\t\tchar *val;\n\t\t\tchar *tmp;\n\t\t\tsplit = strstr(s, \"; \");\n\t\t\tif(split)\n\t\t\t\t*split = '\\0';\n\t\t\tkey = s;\n\t\t\ttmp = memchr(key, '=', 64);\n\t\t\tif(tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tval = tmp+1;\n\t\t\t\tadd_assoc_string(hash, key, val);\n\t\t\t}\n\t\t\ts = split+2;\n\t\t} while(split);\n\t\tefree(org);\n\t}\n}", "target": 0}
{"code": "int hextoint(char c)\n{\n\tif (c >= 'a' && c <= 'f')\n\t\treturn 10 + c - 'a';\n\telse if (c >= 'A' && c <= 'F')\n\t\treturn 10 + c - 'A';\n\telse if (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\telse\n\t\treturn -1;\n}", "target": 0}
{"code": "void rds_inc_put(struct rds_incoming *inc)\n{\n\trdsdebug(\"put inc %p ref %d\\n\", inc, atomic_read(&inc->i_refcount));\n\tif (atomic_dec_and_test(&inc->i_refcount)) {\n\t\tBUG_ON(!list_empty(&inc->i_item));\n\t\tinc->i_conn->c_trans->inc_free(inc);\n\t}\n}", "target": 0}
{"code": "static int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct kvm_xcrs *guest_xcrs)\n{\n\tint i, r = 0;\n\tif (!cpu_has_xsave)\n\t\treturn -EINVAL;\n\tif (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < guest_xcrs->nr_xcrs; i++)\n\t\tif (guest_xcrs->xcrs[0].xcr == XCR_XFEATURE_ENABLED_MASK) {\n\t\t\tr = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,\n\t\t\t\tguest_xcrs->xcrs[0].value);\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\tr = -EINVAL;\n\treturn r;\n}", "target": 0}
{"code": "static bool is_preallocated_map(struct bpf_map *map)\n{\n\tif (!check_map_prealloc(map))\n\t\treturn false;\n\tif (map->inner_map_meta && !check_map_prealloc(map->inner_map_meta))\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "bool ChildThread::Send(IPC::Message* msg) {\n  DCHECK(base::MessageLoop::current() == message_loop());\n  if (!channel_) {\n    delete msg;\n    return false;\n  }\n  return channel_->Send(msg);\n}", "target": 0}
{"code": "find_extra(char_u **pp)\n{\n    char_u\t*str = *pp;\n    char_u\tfirst_char = **pp;\n    for (;;)\n    {\n\tif (VIM_ISDIGIT(*str))\n\t    str = skipdigits(str + 1);\n\telse if (*str == '/' || *str == '?')\n\t{\n\t    str = skip_regexp(str + 1, *str, FALSE);\n\t    if (*str != first_char)\n\t\tstr = NULL;\n\t    else\n\t\t++str;\n\t}\n\telse\n\t{\n\t    str = (char_u *)strstr((char *)str, \"|;\\\"\");\n\t    if (str != NULL)\n\t    {\n\t\t++str;\n\t\tbreak;\n\t    }\n\t}\n\tif (str == NULL || *str != ';'\n\t\t  || !(VIM_ISDIGIT(str[1]) || str[1] == '/' || str[1] == '?'))\n\t    break;\n\t++str;\t\n\tfirst_char = *str;\n    }\n    if (str != NULL && STRNCMP(str, \";\\\"\", 2) == 0)\n    {\n\t*pp = str;\n\treturn OK;\n    }\n    return FAIL;\n}", "target": 0}
{"code": "iasecc_sdo_put_data(struct sc_card *card, struct iasecc_sdo_update *update)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tint ii, rv;\n\tLOG_FUNC_CALLED(ctx);\n\tif (update->magic != SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid SDO update data\");\n\tfor(ii=0; update->fields[ii].tag && ii < IASECC_SDO_TAGS_UPDATE_MAX; ii++)   {\n\t\tunsigned char *encoded = NULL;\n\t\tint encoded_len;\n\t\tencoded_len = iasecc_sdo_encode_update_field(ctx, update->sdo_class, update->sdo_ref,\n\t\t\t\t\t\t\t&update->fields[ii], &encoded);\n\t\tsc_log(ctx, \"iasecc_sdo_put_data() encode[%i]; tag %X; encoded_len %i\", ii, update->fields[ii].tag, encoded_len);\n\t\tLOG_TEST_RET(ctx, encoded_len, \"Cannot encode update data\");\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDB, 0x3F, 0xFF);\n\t\tapdu.data = encoded;\n\t\tapdu.datalen = encoded_len;\n\t\tapdu.lc = encoded_len;\n\t\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"SDO put data error\");\n\t\tfree(encoded);\n\t}\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}", "target": 0}
{"code": "deliver_split_address(address_item * addr)\n{\nuschar * address = addr->address;\nuschar * domain;\nuschar * t;\nint len;\nif (!(domain = Ustrrchr(address, '@')))\n  return DEFER;\t\t\nlen = domain - address;\naddr->domain = string_copylc(domain+1);    \nt = addr->cc_local_part = store_get(len+1);\nwhile(len-- > 0)\n  {\n  int c = *address++;\n  if (c == '\\\"') continue;\n  if (c == '\\\\')\n    {\n    *t++ = *address++;\n    len--;\n    }\n  else *t++ = c;\n  }\n*t = 0;\nif (percent_hack_domains)\n  {\n  int rc;\n  uschar *new_address = NULL;\n  uschar *local_part = addr->cc_local_part;\n  deliver_domain = addr->domain;  \n  while (  (rc = match_isinlist(deliver_domain, (const uschar **)&percent_hack_domains, 0,\n\t       &domainlist_anchor, addr->domain_cache, MCL_DOMAIN, TRUE, NULL))\n             == OK\n\t&& (t = Ustrrchr(local_part, '%')) != NULL\n\t)\n    {\n    new_address = string_copy(local_part);\n    new_address[t - local_part] = '@';\n    deliver_domain = string_copylc(t+1);\n    local_part = string_copyn(local_part, t - local_part);\n    }\n  if (rc == DEFER) return DEFER;   \n  if (new_address)\n    {\n    address_item *new_parent = store_get(sizeof(address_item));\n    *new_parent = *addr;\n    addr->parent = new_parent;\n    new_parent->child_count = 1;\n    addr->address = new_address;\n    addr->unique = string_copy(new_address);\n    addr->domain = deliver_domain;\n    addr->cc_local_part = local_part;\n    DEBUG(D_deliver) debug_printf(\"%%-hack changed address to: %s\\n\",\n      addr->address);\n    }\n  }\naddr->local_part = addr->lc_local_part = string_copylc(addr->cc_local_part);\nreturn OK;\n}", "target": 0}
{"code": "static void __lo_release(struct loop_device *lo)\n{\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 0}
{"code": "MagickPrivate void AnnotateComponentTerminus(void)\n{\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&annotate_semaphore);\n  RelinquishSemaphoreInfo(&annotate_semaphore);\n}", "target": 0}
{"code": "R_API RIOBank *r_io_bank_get(RIO *io, const ut32 bankid) {\n\tr_return_val_if_fail (io && io->banks, NULL);\n\treturn (RIOBank *)r_id_storage_get (io->banks, bankid);\n}", "target": 0}
{"code": "void mbedtls_ssl_buffering_free( mbedtls_ssl_context *ssl )\n{\n    unsigned offset;\n    mbedtls_ssl_handshake_params * const hs = ssl->handshake;\n    if( hs == NULL )\n        return;\n    ssl_free_buffered_record( ssl );\n    for( offset = 0; offset < MBEDTLS_SSL_MAX_BUFFERED_HS; offset++ )\n        ssl_buffering_free_slot( ssl, offset );\n}", "target": 0}
{"code": "TEST(SpecializeType, ForEachRejectsMalformedInput) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_FOR_EACH);\n  t->add_args()->set_type_id(TFT_PRODUCT);\n  NodeDef ndef;\n  AttrSlice attrs(ndef);\n  FullTypeDef ft;\n  EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());\n}", "target": 0}
{"code": "input_userauth_info_response(int type, u_int32_t seq, void *ctxt)\n{\n\tAuthctxt *authctxt = ctxt;\n\tKbdintAuthctxt *kbdintctxt;\n\tint i, authenticated = 0, res, len;\n\tu_int nresp;\n\tchar **response = NULL, *method;\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_info_response: no authctxt\");\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt == NULL || kbdintctxt->ctxt == NULL)\n\t\tfatal(\"input_userauth_info_response: no kbdintctxt\");\n\tif (kbdintctxt->device == NULL)\n\t\tfatal(\"input_userauth_info_response: no device\");\n\tauthctxt->postponed = 0;\t\n\tnresp = packet_get_int();\n\tif (nresp != kbdintctxt->nreq)\n\t\tfatal(\"input_userauth_info_response: wrong number of replies\");\n\tif (nresp > 100)\n\t\tfatal(\"input_userauth_info_response: too many replies\");\n\tif (nresp > 0) {\n\t\tresponse = xmalloc(nresp * sizeof(char *));\n\t\tfor (i = 0; i < nresp; i++)\n\t\t\tresponse[i] = packet_get_string(NULL);\n\t}\n\tpacket_check_eom();\n\tif (authctxt->valid) {\n\t\tres = kbdintctxt->device->respond(kbdintctxt->ctxt,\n\t\t    nresp, response);\n\t} else {\n\t\tres = -1;\n\t}\n\tfor (i = 0; i < nresp; i++) {\n\t\tmemset(response[i], 'r', strlen(response[i]));\n\t\txfree(response[i]);\n\t}\n\tif (response)\n\t\txfree(response);\n\tswitch (res) {\n\tcase 0:\n\t\tauthenticated = 1;\n\t\tbreak;\n\tcase 1:\n\t\tif (send_userauth_info_request(authctxt) == 1)\n\t\t\tauthctxt->postponed = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tlen = strlen(\"keyboard-interactive\") + 2 +\n\t\tstrlen(kbdintctxt->device->name);\n\tmethod = xmalloc(len);\n\tsnprintf(method, len, \"keyboard-interactive/%s\",\n\t    kbdintctxt->device->name);\n\tif (!authctxt->postponed) {\n\t\tif (authenticated) {\n\t\t\tauth2_challenge_stop(authctxt);\n\t\t} else {\n\t\t\tauth2_challenge_start(authctxt);\n\t\t}\n\t}\n\tuserauth_finish(authctxt, authenticated, method);\n\txfree(method);\n}", "target": 0}
{"code": "static inline void skb_queue_splice_tail_init(struct sk_buff_head *list,\n\t\t\t\t\t      struct sk_buff_head *head)\n{\n\tif (!skb_queue_empty(list)) {\n\t\t__skb_queue_splice(list, head->prev, (struct sk_buff *) head);\n\t\thead->qlen += list->qlen;\n\t\t__skb_queue_head_init(list);\n\t}\n}", "target": 0}
{"code": "static int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mm_struct *mm = bprm->mm;\n\tbprm->vma = vma = vm_area_alloc(mm);\n\tif (!vma)\n\t\treturn -ENOMEM;\n\tvma_set_anonymous(vma);\n\tif (down_write_killable(&mm->mmap_sem)) {\n\t\terr = -EINTR;\n\t\tgoto err_free;\n\t}\n\tBUILD_BUG_ON(VM_STACK_FLAGS & VM_STACK_INCOMPLETE_SETUP);\n\tvma->vm_end = STACK_TOP_MAX;\n\tvma->vm_start = vma->vm_end - PAGE_SIZE;\n\tvma->vm_flags = VM_SOFTDIRTY | VM_STACK_FLAGS | VM_STACK_INCOMPLETE_SETUP;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\terr = insert_vm_struct(mm, vma);\n\tif (err)\n\t\tgoto err;\n\tmm->stack_vm = mm->total_vm = 1;\n\tarch_bprm_mm_init(mm, vma);\n\tup_write(&mm->mmap_sem);\n\tbprm->p = vma->vm_end - sizeof(void *);\n\treturn 0;\nerr:\n\tup_write(&mm->mmap_sem);\nerr_free:\n\tbprm->vma = NULL;\n\tvm_area_free(vma);\n\treturn err;\n}", "target": 0}
{"code": "void Document::UpdateTitle(const String& title) {\n  if (raw_title_ == title)\n    return;\n  raw_title_ = title;\n  String old_title = title_;\n  if (raw_title_.IsEmpty())\n    title_ = String();\n  else if (raw_title_.Is8Bit())\n    title_ = CanonicalizedTitle<LChar>(this, raw_title_);\n  else\n    title_ = CanonicalizedTitle<UChar>(this, raw_title_);\n  if (!frame_ || old_title == title_)\n    return;\n  DispatchDidReceiveTitle();\n}", "target": 0}
{"code": "void ewk_view_paint_context_restore(Ewk_View_Paint_Context* context)\n{\n    EINA_SAFETY_ON_NULL_RETURN(context);\n    context->graphicContext->restore();\n    cairo_restore(context->cr);\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::SetAccessibilityFocus(int acc_obj_id) {\n  if (!host_)\n    return;\n  host_->AccessibilitySetFocus(acc_obj_id);\n}", "target": 0}
{"code": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}", "target": 0}
{"code": "bool WasmBinaryBuilder::maybeVisitSIMDStore(Expression*& out, uint32_t code) {\n  if (code != BinaryConsts::V128Store) {\n    return false;\n  }\n  auto* curr = allocator.alloc<Store>();\n  curr->bytes = 16;\n  curr->valueType = Type::v128;\n  readMemoryAccess(curr->align, curr->offset);\n  curr->isAtomic = false;\n  curr->value = popNonVoidExpression();\n  curr->ptr = popNonVoidExpression();\n  curr->finalize();\n  out = curr;\n  return true;\n}", "target": 0}
{"code": "heap_available()\n{\n    long avail = 0;\n    void *probes[max_malloc_probes];\n    uint n;\n    for (n = 0; n < max_malloc_probes; n++) {\n        if ((probes[n] = malloc(malloc_probe_size)) == 0)\n            break;\n        if_debug2('a', \"[a]heap_available probe[%d]=0x%lx\\n\",\n                  n, (ulong) probes[n]);\n        avail += malloc_probe_size;\n    }\n    while (n)\n        free(probes[--n]);\n    return avail;\n}", "target": 0}
{"code": "h2_request *h2_request_clone(apr_pool_t *p, const h2_request *src)\n{\n    h2_request *dst = apr_pmemdup(p, src, sizeof(*dst));\n    dst->method       = apr_pstrdup(p, src->method);\n    dst->scheme       = apr_pstrdup(p, src->scheme);\n    dst->authority    = apr_pstrdup(p, src->authority);\n    dst->path         = apr_pstrdup(p, src->path);\n    dst->headers      = apr_table_clone(p, src->headers);\n    return dst;\n}", "target": 0}
{"code": "void Parcel::setDataPosition(size_t pos) const\n{\n if (pos > INT32_MAX) {\n        abort();\n }\n    mDataPos = pos;\n    mNextObjectHint = 0;\n}", "target": 0}
{"code": "GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\treturn gf_isom_box_array_read(s, bs, lsr1_on_child_box);", "target": 0}
{"code": "int html_include(const char *filename)\n{\n\tFILE *f;\n\tchar buf[4096];\n\tsize_t len;\n\tif (!(f = fopen(filename, \"r\"))) {\n\t\tfprintf(stderr, \"[cgit] Failed to include file %s: %s (%d).\\n\",\n\t\t\tfilename, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\twhile((len = fread(buf, 1, 4096, f)) > 0)\n\t\twrite(htmlfd, buf, len);\n\tfclose(f);\n\treturn 0;\n}", "target": 0}
{"code": "ProcFreePixmap(ClientPtr client)\n{\n    PixmapPtr pMap;\n    int rc;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupResourceByType((void **) &pMap, stuff->id, RT_PIXMAP,\n                                 client, DixDestroyAccess);\n    if (rc == Success) {\n        FreeResource(stuff->id, RT_NONE);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->id;\n        return rc;\n    }\n}", "target": 0}
{"code": "dirserv_orconn_tls_done(const tor_addr_t *addr,\n                        uint16_t or_port,\n                        const char *digest_rcvd)\n{\n  node_t *node = NULL;\n  tor_addr_port_t orport;\n  routerinfo_t *ri = NULL;\n  time_t now = time(NULL);\n  tor_assert(addr);\n  tor_assert(digest_rcvd);\n  node = node_get_mutable_by_id(digest_rcvd);\n  if (node == NULL || node->ri == NULL)\n    return;\n  ri = node->ri;\n  tor_addr_copy(&orport.addr, addr);\n  orport.port = or_port;\n  if (router_has_orport(ri, &orport)) {\n    if (!authdir_mode_bridge(get_options()) ||\n        ri->purpose == ROUTER_PURPOSE_BRIDGE) {\n      char addrstr[TOR_ADDR_BUF_LEN];\n      log_info(LD_DIRSERV, \"Found router %s to be reachable at %s:%d. Yay.\",\n               router_describe(ri),\n               tor_addr_to_str(addrstr, addr, sizeof(addrstr), 1),\n               ri->or_port);\n      if (tor_addr_family(addr) == AF_INET) {\n        rep_hist_note_router_reachable(digest_rcvd, addr, or_port, now);\n        node->last_reachable = now;\n      } else if (tor_addr_family(addr) == AF_INET6) {\n        node->last_reachable6 = now;\n      }\n    }\n  }\n}", "target": 0}
{"code": "int RGWListBucket_ObjStore_S3::get_params()\n{\n  int ret = get_common_params();\n  if (ret < 0) {\n    return ret;\n  }\n  if (!list_versions) {\n    marker = s->info.args.get(\"marker\");\n  } else {\n    marker.name = s->info.args.get(\"key-marker\");\n    marker.instance = s->info.args.get(\"version-id-marker\");\n  }\n  return 0;\n}", "target": 0}
{"code": "static void ok_jpg_progressive_finish(ok_jpg_decoder *decoder) {\n    int16_t out_block[64];\n    for (int i = 0; i < decoder->num_components; i++) {\n        ok_jpg_component *c = decoder->components + i;\n        c->next_block = 0;\n    }\n    for (int data_unit_y = 0; data_unit_y < decoder->data_units_y; data_unit_y++) {\n        for (int data_unit_x = 0; data_unit_x < decoder->data_units_x; data_unit_x++) {\n            for (int i = 0; i < decoder->num_components; i++) {\n                ok_jpg_component *c = decoder->components + i;\n                size_t block_index = c->next_block;\n                int offset_y = 0;\n                for (int y = 0; y < c->V; y++) {\n                    int offset_x = 0;\n                    for (int x = 0; x < c->H; x++) {\n                        int16_t *in_block = c->blocks + (block_index * 64);\n                        ok_jpg_dequantize(decoder, c, in_block, out_block);\n                        c->idct(out_block, c->output + offset_x + offset_y);\n                        block_index++;\n                        offset_x += 8;\n                    }\n                    offset_y += C_WIDTH * 8;\n                    block_index += (size_t)(c->H * (decoder->data_units_x - 1));\n                }\n                c->next_block += c->H;\n            }\n            ok_jpg_convert_data_unit(decoder, data_unit_x, data_unit_y);\n        }\n        for (int i = 0; i < decoder->num_components; i++) {\n            ok_jpg_component *c = decoder->components + i;\n            c->next_block += (size_t)((c->V - 1) * c->H * decoder->data_units_x);\n        }\n    }\n}", "target": 0}
{"code": "void  opj_j2k_write_float_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT32 l_temp;\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_FLOAT32) *(l_src_data++);\n                opj_write_float(l_dest_data,l_temp);\n                l_dest_data+=sizeof(OPJ_FLOAT32);\n        }\n}", "target": 0}
{"code": "static void test_bug6049()\n{\n  MYSQL_STMT *stmt;\n  MYSQL_BIND my_bind[1];\n  MYSQL_RES *res;\n  MYSQL_ROW row;\n  const char *stmt_text;\n  char buffer[30];\n  ulong length;\n  int rc;\n  myheader(\"test_bug6049\");\n  stmt_text= \"SELECT MAKETIME(-25, 12, 12)\";\n  rc= mysql_real_query(mysql, stmt_text, strlen(stmt_text));\n  myquery(rc);\n  res= mysql_store_result(mysql);\n  row= mysql_fetch_row(res);\n  stmt= mysql_stmt_init(mysql);\n  rc= mysql_stmt_prepare(stmt, stmt_text, strlen(stmt_text));\n  check_execute(stmt, rc);\n  rc= mysql_stmt_execute(stmt);\n  check_execute(stmt, rc);\n  memset(my_bind, 0, sizeof(my_bind));\n  my_bind[0].buffer_type    = MYSQL_TYPE_STRING;\n  my_bind[0].buffer         = &buffer;\n  my_bind[0].buffer_length  = sizeof(buffer);\n  my_bind[0].length         = &length;\n  mysql_stmt_bind_result(stmt, my_bind);\n  rc= mysql_stmt_fetch(stmt);\n  DIE_UNLESS(rc == 0);\n  if (!opt_silent)\n  {\n    printf(\"Result from query: %s\\n\", row[0]);\n    printf(\"Result from prepared statement: %s\\n\", (char*) buffer);\n  }\n  DIE_UNLESS(strcmp(row[0], (char*) buffer) == 0);\n  mysql_free_result(res);\n  mysql_stmt_close(stmt);\n}", "target": 0}
{"code": "static void fts3EvalInvalidatePoslist(Fts3Phrase *pPhrase){\n  if( pPhrase->doclist.bFreeList ){\n    sqlite3_free(pPhrase->doclist.pList);\n  }\n  pPhrase->doclist.pList = 0;\n  pPhrase->doclist.nList = 0;\n  pPhrase->doclist.bFreeList = 0;\n}", "target": 0}
{"code": "int _ma_update_state_lsns(MARIA_SHARE *share, LSN lsn, TrID create_trid,\n                          my_bool do_sync, my_bool update_create_rename_lsn)\n{\n  int res;\n  DBUG_ENTER(\"_ma_update_state_lsns\");\n  mysql_mutex_lock(&share->intern_lock);\n  res= _ma_update_state_lsns_sub(share, lsn, create_trid, do_sync,\n                                 update_create_rename_lsn);\n  mysql_mutex_unlock(&share->intern_lock);\n  DBUG_RETURN(res);\n}", "target": 0}
{"code": "passFindName (const CharsString * name)\n{\n  const struct PassName *curname = passNames;\n  CharsString augmentedName;\n  for (augmentedName.length = 0; augmentedName.length < name->length;\n       augmentedName.length++)\n    augmentedName.chars[augmentedName.length] =\n      name->chars[augmentedName.length];\n  augmentedName.chars[augmentedName.length++] = passOpcode;\n  while (curname)\n    {\n      if ((augmentedName.length == curname->length) &&\n\t  (memcmp\n\t   (&augmentedName.chars[0], curname->name,\n\t    CHARSIZE * name->length) == 0))\n\treturn curname->varnum;\n      curname = curname->next;\n    }\n  compileError (passNested, \"name not found\");\n  return 0;\n}", "target": 0}
{"code": "static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\tif (la.l2_cid)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && !la.l2_psm) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\tswitch (sk->sk_state) {\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\t\tgoto wait;\n\tcase BT_CONNECTED:\n\t\tgoto done;\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\t\tbreak;\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tbacpy(&bt_sk(sk)->dst, &la.l2_bdaddr);\n\tl2cap_pi(sk)->psm = la.l2_psm;\n\terr = l2cap_do_connect(sk);\n\tif (err)\n\t\tgoto done;\nwait:\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "void GfxDeviceNColorSpace::getGray(const GfxColor *color, GfxGray *gray) const\n{\n    double x[gfxColorMaxComps], c[gfxColorMaxComps];\n    GfxColor color2;\n    int i;\n    for (i = 0; i < nComps; ++i) {\n        x[i] = colToDbl(color->c[i]);\n    }\n    func->transform(x, c);\n    for (i = 0; i < alt->getNComps(); ++i) {\n        color2.c[i] = dblToCol(c[i]);\n    }\n    alt->getGray(&color2, gray);\n}", "target": 0}
{"code": "static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                              size_t insize, const LodePNGCompressSettings* settings)\n{\n  if (!settings->custom_zlib) return 87; \n  return settings->custom_zlib(out, outsize, in, insize, settings);\n}", "target": 0}
{"code": "bgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)\n{\n  switch (afi)\n    {\n      case AFI_IP:\n#ifdef HAVE_IPV6\n      case AFI_IP6:\n#endif\n        switch (*safi)\n          {\n            case SAFI_MPLS_LABELED_VPN:\n              *safi = SAFI_MPLS_VPN;\n            case SAFI_UNICAST:\n            case SAFI_MULTICAST:\n              return 1;\n          }\n    }\n  zlog_debug (\"unknown afi/safi (%u/%u)\", afi, *safi);\n  return 0;\n}", "target": 0}
{"code": "GF_Err trgt_box_size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\tptr->size+= 4;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void phys_page_compact(PhysPageEntry *lp, Node *nodes, unsigned long *compacted)\n{\n    unsigned valid_ptr = P_L2_SIZE;\n    int valid = 0;\n    PhysPageEntry *p;\n    int i;\n    if (lp->ptr == PHYS_MAP_NODE_NIL) {\n        return;\n    }\n    p = nodes[lp->ptr];\n    for (i = 0; i < P_L2_SIZE; i++) {\n        if (p[i].ptr == PHYS_MAP_NODE_NIL) {\n            continue;\n        }\n        valid_ptr = i;\n        valid++;\n        if (p[i].skip) {\n            phys_page_compact(&p[i], nodes, compacted);\n        }\n    }\n    if (valid != 1) {\n        return;\n    }\n    assert(valid_ptr < P_L2_SIZE);\n    if (lp->skip + p[valid_ptr].skip >= (1 << 3)) {\n        return;\n    }\n    lp->ptr = p[valid_ptr].ptr;\n    if (!p[valid_ptr].skip) {\n        lp->skip = 0;\n    } else {\n        lp->skip += p[valid_ptr].skip;\n    }\n}", "target": 0}
{"code": "    int RafImage::pixelHeight() const\n    {\n        Exiv2::ExifData::const_iterator heightIter = exifData_.findKey(Exiv2::ExifKey(\"Exif.Photo.PixelYDimension\"));\n        if (heightIter != exifData_.end() && heightIter->count() > 0) {\n            return heightIter->toLong();\n        }\n        return 0;\n    }", "target": 0}
{"code": "static void _ewk_view_smart_add_console_message(Ewk_View_Smart_Data* smartData, const char* message, unsigned int lineNumber, const char* sourceID)\n{\n    INF(\"console message: %s @%d: %s\\n\", sourceID, lineNumber, message);\n}", "target": 0}
{"code": "static void _php_pgsql_notice_handler(void *resource_id, const char *message)\n{\n\tphp_pgsql_notice *notice;\n\tif (! PGG(ignore_notices)) {\n\t\tnotice = (php_pgsql_notice *)emalloc(sizeof(php_pgsql_notice));\n\t\tnotice->message = _php_pgsql_trim_message(message, &notice->len);\n\t\tif (PGG(log_notices)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"%s\", notice->message);\n\t\t}\n\t\tzend_hash_index_update_ptr(&PGG(notices), (zend_ulong)resource_id, notice);\n\t}\n}", "target": 0}
{"code": "    template<typename t>\n    const T& min_max(t& max_val) const {\n      if (is_empty())\n        throw CImgInstanceException(_cimglist_instance\n                                    \"min_max(): Empty instance.\",\n                                    cimglist_instance);\n      const T *ptr_min = _data->_data;\n      T min_value = *ptr_min, max_value = min_value;\n      cimglist_for(*this,l) {\n        const CImg<T>& img = _data[l];\n        cimg_for(img,ptrs,T) {\n          const T val = *ptrs;\n          if (val<min_value) { min_value = val; ptr_min = ptrs; }\n          if (val>max_value) max_value = val;\n        }", "target": 0}
{"code": "static std::string getComment(const std::string &fulltext, int line)\n{\n\tif (line < 1) return \"\";\n\tunsigned int start = 0;\n\tfor (; start<fulltext.length() ; ++start) {\n\t\tif (line <= 1) break;\n\t\tif (fulltext[start] == '\\n') line--;\n\t}\n\tint end = start + 1;\n\twhile (end < fulltext.size() && fulltext[end] != '\\n') end++;\n\tstd::string comment = fulltext.substr(start, end - start);\n\tunsigned int startText = 0;\n\tint noOfSemicolon = 0;\n\tbool inString = false;\n\tfor (; startText < comment.length() - 1; ++startText) {\n\t\tif (inString && comment.compare(startText, 2, \"\\\\\\\"\") == 0) {\n\t\t\tstartText++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (comment[startText] == '\"') inString = !inString;\n\t\tif (!inString) {\n\t\t\tif (comment.compare(startText, 2, \"\n\t\t\tif (comment[startText] == ';' && noOfSemicolon > 0) return \"\";\n\t\t\tif (comment[startText] == ';') noOfSemicolon++;\n\t\t}\n\t}\n\tif (startText + 2 > comment.length()) return \"\";\n\tstd::string result = comment.substr(startText + 2);\n\treturn result;\n}", "target": 0}
{"code": "void Cache::remove(CachedResource* resource)\n{\n    if (resource->inCache()) {\n        m_resources.remove(resource->url());\n        resource->setInCache(false);\n        removeFromLRUList(resource);\n        removeFromLiveDecodedResourcesList(resource);\n        HashSet<DocLoader*>::iterator end = m_docLoaders.end();\n        for (HashSet<DocLoader*>::iterator itr = m_docLoaders.begin(); itr != end; ++itr)\n            (*itr)->removeCachedResource(resource);\n        int delta = -static_cast<int>(resource->size());\n        if (delta)\n            adjustSize(resource->referenced(), delta);\n    } else\n        ASSERT(m_resources.get(resource->url()) != resource);\n    if (resource->canDelete())\n        delete resource;\n}", "target": 0}
{"code": "asmlinkage long compat_sys_epoll_wait(int epfd,\n\t\t\tstruct compat_epoll_event __user *events,\n\t\t\tint maxevents, int timeout)\n{\n\tlong i, ret, err = 0;\n\tstruct epoll_event __user *kbuf;\n\tstruct epoll_event ev;\n\tif ((maxevents <= 0) ||\n\t\t\t(maxevents > (INT_MAX / sizeof(struct epoll_event))))\n\t\treturn -EINVAL;\n\tkbuf = compat_alloc_user_space(sizeof(struct epoll_event) * maxevents);\n\tret = sys_epoll_wait(epfd, kbuf, maxevents, timeout);\n\tfor (i = 0; i < ret; i++) {\n\t\terr |= __get_user(ev.events, &kbuf[i].events);\n\t\terr |= __get_user(ev.data, &kbuf[i].data);\n\t\terr |= __put_user(ev.events, &events->events);\n\t\terr |= __put_user_unaligned(ev.data, &events->data);\n\t\tevents++;\n\t}\n\treturn err ? -EFAULT: ret;\n}", "target": 0}
{"code": "static void call_trans2ioctl(connection_struct *conn,\n\t\t\t     struct smb_request *req,\n\t\t\t     char **pparams, int total_params,\n\t\t\t     char **ppdata, int total_data,\n\t\t\t     unsigned int max_data_bytes)\n{\n\tconst struct loadparm_substitution *lp_sub =\n\t\tloadparm_s3_global_substitution();\n\tchar *pdata = *ppdata;\n\tfiles_struct *fsp = file_fsp(req, SVAL(req->vwv+15, 0));\n\tNTSTATUS status;\n\tsize_t len = 0;\n\tif (!fsp) {\n\t\treply_nterror(req, NT_STATUS_INVALID_HANDLE);\n\t\treturn;\n\t}\n\tif ((SVAL(req->vwv+16, 0) == LMCAT_SPL)\n\t    && (SVAL(req->vwv+17, 0) == LMFUNC_GETJOBID)) {\n\t\t*ppdata = (char *)SMB_REALLOC(*ppdata, 32);\n\t\tif (*ppdata == NULL) {\n\t\t\treply_nterror(req, NT_STATUS_NO_MEMORY);\n\t\t\treturn;\n\t\t}\n\t\tpdata = *ppdata;\n\t\tSSVAL(pdata, 0, print_spool_rap_jobid(fsp->print_file));\n\t\tstatus = srvstr_push(pdata, req->flags2, pdata + 2,\n\t\t\t    lp_netbios_name(), 15,\n\t\t\t    STR_ASCII|STR_TERMINATE, &len); \n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treply_nterror(req, status);\n\t\t\treturn;\n\t\t}\n\t\tstatus = srvstr_push(pdata, req->flags2, pdata+18,\n\t\t\t    lp_servicename(talloc_tos(), lp_sub, SNUM(conn)), 13,\n\t\t\t    STR_ASCII|STR_TERMINATE, &len); \n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treply_nterror(req, status);\n\t\t\treturn;\n\t\t}\n\t\tsend_trans2_replies(conn, req, NT_STATUS_OK, *pparams, 0, *ppdata, 32,\n\t\t\t\t    max_data_bytes);\n\t\treturn;\n\t}\n\tDEBUG(2,(\"Unknown TRANS2_IOCTL\\n\"));\n\treply_nterror(req, NT_STATUS_NOT_IMPLEMENTED);\n}", "target": 0}
{"code": "String HTMLFormControlElement::formEnctype() const\n{\n    const AtomicString& formEnctypeAttr = fastGetAttribute(formenctypeAttr);\n    if (formEnctypeAttr.isNull())\n        return emptyString();\n    return FormSubmission::Attributes::parseEncodingType(formEnctypeAttr);\n}", "target": 0}
{"code": "mm_user_key_allowed(struct passwd *pw, Key *key)\n{\n\treturn (mm_key_allowed(MM_USERKEY, NULL, NULL, key));\n}", "target": 0}
{"code": "MagickExport MagickBooleanType GetOneVirtualPixel(const Image *image,\n  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  const int\n    id = GetOpenMPThreadId();\n  const Quantum\n    *p;\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));\n  if (cache_info->methods.get_one_virtual_pixel_from_handler !=\n       (GetOneVirtualPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,pixel,exception));\n  assert(id < (int) cache_info->number_threads);\n  p=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    1UL,1UL,cache_info->nexus_info[id],exception);\n  return(CopyPixel(image,p,pixel));\n}", "target": 0}
{"code": "static void ip6_tnl_add_linklocal(struct inet6_dev *idev)\n{\n\tstruct net_device *link_dev;\n\tstruct net *net = dev_net(idev->dev);\n\tif (idev->dev->iflink &&\n\t    (link_dev = __dev_get_by_index(net, idev->dev->iflink))) {\n\t\tif (!ipv6_inherit_linklocal(idev, link_dev))\n\t\t\treturn;\n\t}\n\tfor_each_netdev(net, link_dev) {\n\t\tif (!ipv6_inherit_linklocal(idev, link_dev))\n\t\t\treturn;\n\t}\n\tpr_debug(\"init ip6-ip6: add_linklocal failed\\n\");\n}", "target": 0}
{"code": "cmsHTRANSFORM _cmsChain2Lab(cmsContext            ContextID,\n                            cmsUInt32Number        nProfiles,\n                            cmsUInt32Number        InputFormat,\n                            cmsUInt32Number        OutputFormat,\n                            const cmsUInt32Number  Intents[],\n                            const cmsHPROFILE      hProfiles[],\n                            const cmsBool          BPC[],\n                            const cmsFloat64Number AdaptationStates[],\n                            cmsUInt32Number        dwFlags)\n{\n    cmsHTRANSFORM xform;\n    cmsHPROFILE   hLab;\n    cmsHPROFILE   ProfileList[256];\n    cmsBool       BPCList[256];\n    cmsFloat64Number AdaptationList[256];\n    cmsUInt32Number IntentList[256];\n    cmsUInt32Number i;\n    if (nProfiles > 254) return NULL;\n    hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);\n    if (hLab == NULL) return NULL;\n    for (i=0; i < nProfiles; i++) {\n        ProfileList[i]    = hProfiles[i];\n        BPCList[i]        = BPC[i];\n        AdaptationList[i] = AdaptationStates[i];\n        IntentList[i]     = Intents[i];\n    }\n    ProfileList[nProfiles]    = hLab;\n    BPCList[nProfiles]        = 0;\n    AdaptationList[nProfiles] = 1.0;\n    IntentList[nProfiles]     = INTENT_RELATIVE_COLORIMETRIC;\n    xform = cmsCreateExtendedTransform(ContextID, nProfiles + 1, ProfileList,\n                                       BPCList,\n                                       IntentList,\n                                       AdaptationList,\n                                       NULL, 0,\n                                       InputFormat,\n                                       OutputFormat,\n                                       dwFlags);\n    cmsCloseProfile(hLab);\n    return xform;\n}", "target": 0}
{"code": "IndexedDBDatabaseError IndexedDBDatabase::CreateError(\n    uint16_t code,\n    const base::string16& message,\n    IndexedDBTransaction* transaction) {\n  transaction->IncrementNumErrorsSent();\n  return IndexedDBDatabaseError(code, message);\n}", "target": 0}
{"code": "static void sdhci_init_readonly_registers(SDHCIState *s, Error **errp)\n{\n    ERRP_GUARD();\n    switch (s->sd_spec_version) {\n    case 2 ... 3:\n        break;\n    default:\n        error_setg(errp, \"Only Spec v2/v3 are supported\");\n        return;\n    }\n    s->version = (SDHC_HCVER_VENDOR << 8) | (s->sd_spec_version - 1);\n    sdhci_check_capareg(s, errp);\n    if (*errp) {\n        return;\n    }\n}", "target": 0}
{"code": "node_new_anychar_with_fixed_option(OnigOptionType option)\n{\n  CtypeNode* ct;\n  Node* node;\n  node = node_new_anychar();\n  ct = CTYPE_(node);\n  ct->options = option;\n  NODE_STATUS_ADD(node, NST_FIXED_OPTION);\n  return node;\n}", "target": 0}
{"code": "void Clipboard::WriteBookmark(const char* title_data, size_t title_len,\n                              const char* url_data, size_t url_len) {\n  string16 url = UTF8ToUTF16(std::string(url_data, url_len) + \"\\n\");\n  string16 title = UTF8ToUTF16(std::string(title_data, title_len));\n  int data_len = 2 * (title.length() + url.length());\n  char* data = new char[data_len];\n  memcpy(data, url.data(), 2 * url.length());\n  memcpy(data + 2 * url.length(), title.data(), 2 * title.length());\n  InsertMapping(kMimeTypeMozillaURL, data, data_len);\n}", "target": 0}
{"code": "  DeleteOriginInfo(\n      QuotaManager* manager,\n      const GURL& origin,\n      StorageType type)\n      : DatabaseTaskBase(manager),\n        origin_(origin),\n        type_(type) {}", "target": 0}
{"code": "smb2_hdr_assemble(struct smb2_sync_hdr *shdr, __le16 smb2_cmd,\n\t\t  const struct cifs_tcon *tcon)\n{\n\tshdr->ProtocolId = SMB2_PROTO_NUMBER;\n\tshdr->StructureSize = cpu_to_le16(64);\n\tshdr->Command = smb2_cmd;\n\tif (tcon && tcon->ses && tcon->ses->server) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tspin_lock(&server->req_lock);\n\t\tif (server->credits >= server->max_credits)\n\t\t\tshdr->CreditRequest = cpu_to_le16(0);\n\t\telse\n\t\t\tshdr->CreditRequest = cpu_to_le16(\n\t\t\t\tmin_t(int, server->max_credits -\n\t\t\t\t\t\tserver->credits, 10));\n\t\tspin_unlock(&server->req_lock);\n\t} else {\n\t\tshdr->CreditRequest = cpu_to_le16(2);\n\t}\n\tshdr->ProcessId = cpu_to_le32((__u16)current->tgid);\n\tif (!tcon)\n\t\tgoto out;\n\tif ((tcon->ses) && (tcon->ses->server) &&\n\t    (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\tshdr->CreditCharge = cpu_to_le16(1);\n\tshdr->TreeId = tcon->tid;\n\tif (tcon->ses)\n\t\tshdr->SessionId = tcon->ses->Suid;\n\tif (tcon->ses && tcon->ses->server && tcon->ses->server->sign &&\n\t    !smb3_encryption_required(tcon))\n\t\tshdr->Flags |= SMB2_FLAGS_SIGNED;\nout:\n\treturn;\n}", "target": 0}
{"code": "__vmci_transport_send_control_pkt(struct vmci_transport_packet *pkt,\n\t\t\t\t  struct sockaddr_vm *src,\n\t\t\t\t  struct sockaddr_vm *dst,\n\t\t\t\t  enum vmci_transport_packet_type type,\n\t\t\t\t  u64 size,\n\t\t\t\t  u64 mode,\n\t\t\t\t  struct vmci_transport_waiting_info *wait,\n\t\t\t\t  u16 proto,\n\t\t\t\t  struct vmci_handle handle,\n\t\t\t\t  bool convert_error)\n{\n\tint err;\n\tvmci_transport_packet_init(pkt, src, dst, type, size, mode, wait,\n\t\t\t\t   proto, handle);\n\terr = vmci_datagram_send(&pkt->dg);\n\tif (convert_error && (err < 0))\n\t\treturn vmci_transport_error_to_vsock_error(err);\n\treturn err;\n}", "target": 0}
{"code": "static sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The following chunk had invalid length:\";\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}", "target": 0}
{"code": "void usbredirparser_send_bulk_streams_status(struct usbredirparser *parser,\n    uint64_t id,\n    struct usb_redir_bulk_streams_status_header *bulk_streams_status)\n{\n    usbredirparser_queue(parser, usb_redir_bulk_streams_status, id,\n                         bulk_streams_status, NULL, 0);\n}", "target": 0}
{"code": "cgi_add_variable(const char *name,\t\n\t\t int        element,\t\n                 const char *value)\t\n{\n  _cgi_var_t\t*var;\t\t\t\n  if (name == NULL || value == NULL || element < 0 || element > 100000)\n    return;\n  if (form_count >= form_alloc)\n  {\n    _cgi_var_t\t*temp_vars;\t\t\n    if (form_alloc == 0)\n      temp_vars = malloc(sizeof(_cgi_var_t) * 16);\n    else\n      temp_vars = realloc(form_vars, (size_t)(form_alloc + 16) * sizeof(_cgi_var_t));\n    if (!temp_vars)\n      return;\n    form_vars  = temp_vars;\n    form_alloc += 16;\n  }\n  var = form_vars + form_count;\n  if ((var->values = calloc((size_t)element + 1, sizeof(char *))) == NULL)\n    return;\n  var->name            = _cupsStrAlloc(name);\n  var->nvalues         = element + 1;\n  var->avalues         = element + 1;\n  var->values[element] = _cupsStrAlloc(value);\n  form_count ++;\n}", "target": 0}
{"code": "  envoy::config::core::v3::Metadata parseMetadataFromYaml(const std::string& yaml_string) {\n    envoy::config::core::v3::Metadata metadata;\n    TestUtility::loadFromYaml(yaml_string, metadata);\n    return metadata;\n  }", "target": 0}
{"code": "u64 gf_net_get_ntp_ts()\n{\n\tu64 res;\n\tu32 sec, frac;\n\tgf_net_get_ntp(&sec, &frac);\n\tres = sec;\n\tres<<= 32;\n\tres |= frac;\n\treturn res;\n}", "target": 0}
{"code": "gsd_xrandr_manager_dispose (GObject *object)\n{\n        GsdXrandrManager *xrandr_manager;\n        xrandr_manager = GSD_XRANDR_MANAGER (object);\n        G_OBJECT_CLASS (gsd_xrandr_manager_parent_class)->dispose (object);\n}", "target": 0}
{"code": "onig_get_string_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->string;\n}", "target": 0}
{"code": "PHP_FUNCTION(mb_ereg_match)\n{\n\tchar *arg_pattern;\n\tint arg_pattern_len;\n\tchar *string;\n\tint string_len;\n\tphp_mb_regex_t *re;\n\tOnigSyntaxType *syntax;\n\tOnigOptionType option = 0;\n\tint err;\n\t{\n\t\tchar *option_str = NULL;\n\t\tint option_str_len = 0;\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|s\",\n\t\t                          &arg_pattern, &arg_pattern_len, &string, &string_len,\n\t\t                          &option_str, &option_str_len)==FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (option_str != NULL) {\n\t\t\t_php_mb_regex_init_options(option_str, option_str_len, &option, &syntax, NULL);\n\t\t} else {\n\t\t\toption |= MBREX(regex_default_options);\n\t\t\tsyntax = MBREX(regex_default_syntax);\n\t\t}\n\t}\n\tif ((re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, option, MBREX(current_mbctype), syntax TSRMLS_CC)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\terr = onig_match(re, (OnigUChar *)string, (OnigUChar *)(string + string_len), (OnigUChar *)string, NULL, 0);\n\tif (err >= 0) {\n\t\tRETVAL_TRUE;\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n}", "target": 0}
{"code": "const GF_FilterRegister *xviddec_register(GF_FilterSession *session)\n{\n#if !defined(GPAC_DISABLE_AV_PARSERS) && defined(GPAC_HAS_XVID)\n\treturn &XVIDRegister;\n#else\n\treturn NULL;\n#endif\n}", "target": 0}
{"code": "int afGetVirtualChannels (AFfilehandle file, int trackid)\n{\n\t_Track\t*track;\n\tif ((track = _af_filehandle_get_track(file, trackid)) == NULL)\n\t\treturn -1;\n\treturn track->v.channelCount;\n}", "target": 0}
{"code": "static int attr_to_val(const char *str)\n{\n\tif (!strcasecmp(str, \"Equalizer\"))\n\t\treturn AVRCP_ATTRIBUTE_EQUALIZER;\n\telse if (!strcasecmp(str, \"Repeat\"))\n\t\treturn AVRCP_ATTRIBUTE_REPEAT_MODE;\n\telse if (!strcasecmp(str, \"Shuffle\"))\n\t\treturn AVRCP_ATTRIBUTE_SHUFFLE;\n\telse if (!strcasecmp(str, \"Scan\"))\n\t\treturn AVRCP_ATTRIBUTE_SCAN;\n\treturn -EINVAL;\n}", "target": 0}
{"code": "get_rtpref(u_int v)\n{\n\tstatic const char *rtpref_str[] = {\n\t\t\"medium\",\t\t\n\t\t\"high\",\t\t\t\n\t\t\"rsv\",\t\t\t\n\t\t\"low\"\t\t\t\n\t};\n\treturn rtpref_str[((v & ND_RA_FLAG_RTPREF_MASK) >> 3) & 0xff];\n}", "target": 0}
{"code": "    bool Image::isShortType(uint16_t type) {\n         return type == Exiv2::unsignedShort\n             || type == Exiv2::signedShort\n             ;\n    }", "target": 0}
{"code": "g_markup_parse_context_pop (GMarkupParseContext *context)\n{\n  gpointer user_data;\n  if (!context->awaiting_pop)\n    possibly_finish_subparser (context);\n  g_assert (context->awaiting_pop);\n  context->awaiting_pop = FALSE;\n  user_data = context->held_user_data;\n  context->held_user_data = NULL;\n  return user_data;\n}", "target": 0}
{"code": "next_state_val(CClassNode* cc, OnigCodePoint *from, OnigCodePoint to,\n               int* from_israw, int to_israw,\n               enum CCVALTYPE intype, enum CCVALTYPE* type,\n               enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      if (*from > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n      BITSET_SET_BIT(cc->bs, (int )(*from));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *from, *from);\n      if (r < 0) return r;\n    }\n    break;\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*from > 0xff || to > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n        if (*from > to) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*from, (int )to);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *from, to);\n        if (r < 0) return r;\n      }\n    }\n    else {\n      if (*from > to) {\n        if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n          goto ccs_range_end;\n        else\n          return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n      }\n      bitset_set_range(cc->bs, (int )*from, (int )(to < 0xff ? to : 0xff));\n      r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*from, to);\n      if (r < 0) return r;\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n  default:\n    break;\n  }\n  *from_israw = to_israw;\n  *from       = to;\n  *type       = intype;\n  return 0;\n}", "target": 0}
{"code": "void bnx2x_setup_cnic_info(struct bnx2x *bp)\n{\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\tcp->ctx_tbl_offset = FUNC_ILT_BASE(BP_FUNC(bp)) +\n\t\t\t     bnx2x_cid_ilt_lines(bp);\n\tcp->starting_cid = bnx2x_cid_ilt_lines(bp) * ILT_PAGE_CIDS;\n\tcp->fcoe_init_cid = BNX2X_FCOE_ETH_CID(bp);\n\tcp->iscsi_l2_cid = BNX2X_ISCSI_ETH_CID(bp);\n\tDP(NETIF_MSG_IFUP, \"BNX2X_1st_NON_L2_ETH_CID(bp) %x, cp->starting_cid %x, cp->fcoe_init_cid %x, cp->iscsi_l2_cid %x\\n\",\n\t   BNX2X_1st_NON_L2_ETH_CID(bp), cp->starting_cid, cp->fcoe_init_cid,\n\t   cp->iscsi_l2_cid);\n\tif (NO_ISCSI_OOO(bp))\n\t\tcp->drv_state |= CNIC_DRV_STATE_NO_ISCSI_OOO;\n}", "target": 0}
{"code": "fz_drop_link_key(fz_context *ctx, void *key_)\n{\n\tfz_link_key *key = (fz_link_key *)key_;\n\tif (fz_drop_imp(ctx, key, &key->refs))\n\t\tfz_free(ctx, key);\n}", "target": 0}
{"code": "  Parser Parser::from_c_str(const char* beg, Context& ctx, Backtraces traces, ParserState pstate, const char* source, bool allow_parent)\n  {\n    pstate.offset.column = 0;\n    pstate.offset.line = 0;\n    Parser p(ctx, pstate, traces, allow_parent);\n    p.source   = source ? source : beg;\n    p.position = beg ? beg : p.source;\n    p.end      = p.position + strlen(p.position);\n    Block_Obj root = SASS_MEMORY_NEW(Block, pstate);\n    p.block_stack.push_back(root);\n    root->is_root(true);\n    return p;\n  }", "target": 0}
{"code": "void smp_send_commitment(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  smp_send_cmd(SMP_OPCODE_PAIR_COMMITM, p_cb);\n}", "target": 0}
{"code": "void hugetlb_unshare_all_pmds(struct vm_area_struct *vma)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long sz = huge_page_size(h);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_notifier_range range;\n\tunsigned long address, start, end;\n\tspinlock_t *ptl;\n\tpte_t *ptep;\n\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\treturn;\n\tstart = ALIGN(vma->vm_start, PUD_SIZE);\n\tend = ALIGN_DOWN(vma->vm_end, PUD_SIZE);\n\tif (start >= end)\n\t\treturn;\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, mm,\n\t\t\t\tstart, end);\n\tmmu_notifier_invalidate_range_start(&range);\n\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\tfor (address = start; address < end; address += PUD_SIZE) {\n\t\tunsigned long tmp = address;\n\t\tptep = huge_pte_offset(mm, address, sz);\n\t\tif (!ptep)\n\t\t\tcontinue;\n\t\tptl = huge_pte_lock(h, mm, ptep);\n\t\thuge_pmd_unshare(mm, vma, &tmp, ptep);\n\t\tspin_unlock(ptl);\n\t}\n\tflush_hugetlb_tlb_range(vma, start, end);\n\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\tmmu_notifier_invalidate_range_end(&range);\n}", "target": 0}
{"code": "void js_remove(js_State *J, int idx)\n{\n\tidx = idx < 0 ? TOP + idx : BOT + idx;\n\tif (idx < BOT || idx >= TOP)\n\t\tjs_error(J, \"stack error!\");\n\tfor (;idx < TOP - 1; ++idx)\n\t\tSTACK[idx] = STACK[idx+1];\n\t--TOP;\n}", "target": 0}
{"code": "static u16 zipfileGetU16(const u8 *aBuf){\n  return (aBuf[1] << 8) + aBuf[0];\n}", "target": 0}
{"code": "TEST(FloatPoolingOpTest, AveragePoolActivationRelu) {\n  FloatPoolingOpModel m(BuiltinOperator_AVERAGE_POOL_2D,\n                        {TensorType_FLOAT32, {1, 2, 4, 1}},\n                        2, 2,\n                        {TensorType_FLOAT32, {}}, Padding_VALID, 2,\n                        2, ActivationFunctionType_RELU);\n  m.SetInput({\n      0, -6, 2, 4,   \n      3, 2, -10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({0.0, 0.75}));\n}", "target": 0}
{"code": "void Document::setFgColor(const AtomicString& value) {\n  SetBodyAttribute(textAttr, value);\n}", "target": 0}
{"code": "    float XmpArrayValue::toFloat(long n) const\n    {\n        return parseFloat(value_[n], ok_);\n    }", "target": 0}
{"code": "static int jpc_pi_nextrlcp(register jpc_pi_t *pi)\n{\n\tjpc_pchg_t *pchg;\n\tint *prclyrno;\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pi->maxrlvls &&\n\t  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno) {\n\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs && pi->lyrno <\n\t\t  JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t\t\t  &pi->picomps[pi->compno]; pi->compno < pi->numcomps &&\n\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,\n\t\t\t  ++pi->picomp) {\n\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\tfor (pi->prcno = 0, prclyrno = pi->pirlvl->prclyrnos;\n\t\t\t\t  pi->prcno < pi->pirlvl->numprcs; ++pi->prcno, ++prclyrno) {\n\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t*prclyrno = pi->lyrno;\n\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\nskip:\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {\n  if (type == T_SHORT || type == T_CHAR) {\n    return false;\n  }\n  Constant* c = v->as_Constant();\n  if (c && c->state_before() == NULL) {\n    return true;\n  }\n  return false;\n}", "target": 0}
{"code": "gimp_channel_buffer_changed (GeglBuffer          *buffer,\n                             const GeglRectangle *rect,\n                             GimpChannel         *channel)\n{\n  gimp_drawable_invalidate_boundary (GIMP_DRAWABLE (channel));\n}", "target": 0}
{"code": "static void spk_ttyio_send_xchar(char ch)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (check_tty(speakup_tty)) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn;\n\t}\n\tif (speakup_tty->ops->send_xchar)\n\t\tspeakup_tty->ops->send_xchar(speakup_tty, ch);\n\tmutex_unlock(&speakup_tty_mutex);\n}", "target": 0}
{"code": "static void kvm_sched_out(struct preempt_notifier *pn,\n\t\t\t  struct task_struct *next)\n{\n\tstruct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);\n\tkvm_arch_vcpu_put(vcpu);\n}", "target": 0}
{"code": "static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {\n    handler_ctx *hctx = (handler_ctx *)gwhctx;\n    if (0 == mod_wstunnel_frame_recv(hctx))\n        return HANDLER_GO_ON;\n    else {\n        request_st * const r = hctx->gw.r;\n        DEBUG_LOG_INFO(\"disconnected from client (fd=%d)\", r->con->fd);\n        DEBUG_LOG_DEBUG(\"send close response to client (fd=%d)\", r->con->fd);\n        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(\"1000\")); \n        gw_handle_request_reset(r, hctx->gw.plugin_data);\n        return HANDLER_FINISHED;\n    }\n}", "target": 0}
{"code": "namespace{void nop(){}}", "target": 0}
{"code": "static void ssl_buffering_free_slot( mbedtls_ssl_context *ssl,\n                                     uint8_t slot )\n{\n    mbedtls_ssl_handshake_params * const hs = ssl->handshake;\n    mbedtls_ssl_hs_buffer * const hs_buf = &hs->buffering.hs[slot];\n    if( slot >= MBEDTLS_SSL_MAX_BUFFERED_HS )\n        return;\n    if( hs_buf->is_valid == 1 )\n    {\n        hs->buffering.total_bytes_buffered -= hs_buf->data_len;\n        mbedtls_platform_zeroize( hs_buf->data, hs_buf->data_len );\n        mbedtls_free( hs_buf->data );\n        memset( hs_buf, 0, sizeof( mbedtls_ssl_hs_buffer ) );\n    }\n}", "target": 0}
{"code": "PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; \n\t}\n\tif (oldlen > new_size) {\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\tinverse_map = unescape_inverse_map(all, flags);\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\nempty_source:\n\t*newlen = retlen;\n\treturn ret;\n}", "target": 0}
{"code": "rb_enc_reg_raise(const char *s, long len, rb_encoding *enc, int options, const char *err)\n{\n    rb_exc_raise(rb_enc_reg_error_desc(s, len, enc, options, err));\n}", "target": 0}
{"code": "void LibRaw::dcb_pp()\n{\n  int g1, r1, b1, u = width, indx, row, col;\n  for (row = 2; row < height - 2; row++)\n    for (col = 2, indx = row * u + col; col < width - 2; col++, indx++)\n    {\n      r1 = (image[indx - 1][0] + image[indx + 1][0] + image[indx - u][0] +\n            image[indx + u][0] + image[indx - u - 1][0] +\n            image[indx + u + 1][0] + image[indx - u + 1][0] +\n            image[indx + u - 1][0]) /\n           8.0;\n      g1 = (image[indx - 1][1] + image[indx + 1][1] + image[indx - u][1] +\n            image[indx + u][1] + image[indx - u - 1][1] +\n            image[indx + u + 1][1] + image[indx - u + 1][1] +\n            image[indx + u - 1][1]) /\n           8.0;\n      b1 = (image[indx - 1][2] + image[indx + 1][2] + image[indx - u][2] +\n            image[indx + u][2] + image[indx - u - 1][2] +\n            image[indx + u + 1][2] + image[indx - u + 1][2] +\n            image[indx + u - 1][2]) /\n           8.0;\n      image[indx][0] = CLIP(r1 + (image[indx][1] - g1));\n      image[indx][2] = CLIP(b1 + (image[indx][1] - g1));\n    }\n}", "target": 0}
{"code": "  virtual void AddNetworkObserver(const std::string& service_path,\n                                  NetworkObserver* observer) {}", "target": 0}
{"code": "virStoragePoolUpdateInactive(virStoragePoolObj *obj)\n{\n    if (!virStoragePoolObjGetConfigFile(obj)) {\n        virStoragePoolObjRemove(driver->pools, obj);\n    } else if (virStoragePoolObjGetNewDef(obj)) {\n        virStoragePoolObjDefUseNewDef(obj);\n    }\n}", "target": 0}
{"code": "    void CrwMap::encode0x1810(const Image&      image,\n                              const CrwMapping* pCrwMapping,\n                                    CiffHeader* pHead)\n    {\n        assert(pCrwMapping != 0);\n        assert(pHead != 0);\n        const ExifKey kX(\"Exif.Photo.PixelXDimension\");\n        const ExifKey kY(\"Exif.Photo.PixelYDimension\");\n        const ExifKey kO(\"Exif.Image.Orientation\");\n        const ExifData &exivData = image.exifData();\n        const ExifData::const_iterator edX = exivData.findKey(kX);\n        const ExifData::const_iterator edY = exivData.findKey(kY);\n        const ExifData::const_iterator edO = exivData.findKey(kO);\n        const ExifData::const_iterator edEnd = exivData.end();\n        CiffComponent* cc = pHead->findComponent(pCrwMapping->crwTagId_,\n                                                 pCrwMapping->crwDir_);\n        if (edX != edEnd || edY != edEnd || edO != edEnd) {\n            size_t size = 28;\n            if (cc && cc->size() > size)\n                size = cc->size();\n            DataBuf buf(size);\n            std::memset(buf.pData_, 0x0, buf.size_);\n            if (cc) std::memcpy(buf.pData_ + 8, cc->pData() + 8, cc->size() - 8);\n            if (edX != edEnd && edX->size() == 4) {\n                edX->copy(buf.pData_, pHead->byteOrder());\n            }\n            if (edY != edEnd && edY->size() == 4) {\n                edY->copy(buf.pData_ + 4, pHead->byteOrder());\n            }\n            int32_t d = 0;\n            if (edO != edEnd && edO->count() > 0 && edO->typeId() == unsignedShort) {\n                d = RotationMap::degrees(static_cast<uint16_t>(edO->toLong()));\n            }\n            l2Data(buf.pData_ + 12, d, pHead->byteOrder());\n            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n        }\n        else {\n            pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);\n        }\n    } ", "target": 0}
{"code": "const char* part_mode_name(enum PartMode pm)\n{\n  switch (pm) {\n  case PART_2Nx2N: return \"2Nx2N\";\n  case PART_2NxN:  return \"2NxN\";\n  case PART_Nx2N:  return \"Nx2N\";\n  case PART_NxN:   return \"NxN\";\n  case PART_2NxnU: return \"2NxnU\";\n  case PART_2NxnD: return \"2NxnD\";\n  case PART_nLx2N: return \"nLx2N\";\n  case PART_nRx2N: return \"nRx2N\";\n  }\n  return \"undefined part mode\";\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::OnWindowActivated(aura::Window* gained_active,\n                                                 aura::Window* lost_active) {\n  DCHECK(window_ == gained_active || window_ == lost_active);\n  if (window_ == gained_active) {\n    const ui::Event* event = window_->GetDispatcher()->current_event();\n    if (event && PointerEventActivates(*event))\n      host_->OnPointerEventActivate();\n  }\n}", "target": 0}
{"code": "__nf_tables_chain_type_lookup(int family, const struct nlattr *nla)\n{\n\tint i;\n\tfor (i = 0; i < NFT_CHAIN_T_MAX; i++) {\n\t\tif (chain_type[family][i] != NULL &&\n\t\t    !nla_strcmp(nla, chain_type[family][i]->name))\n\t\t\treturn chain_type[family][i];\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "Klass* InstanceKlass::array_klass_or_null(int n) {\n  ObjArrayKlass* oak = array_klasses_acquire();\n  if (oak == NULL) {\n    return NULL;\n  } else {\n    return oak->array_klass_or_null(n);\n  }\n}", "target": 0}
{"code": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n  const int nfilled = table.size();\n  if (nfilled >= 65536)\n    ThrowRDE(\"Table lookup with %i entries is unsupported\", nfilled);\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}", "target": 0}
{"code": "static GCObject **getgclist (GCObject *o) {\n  switch (o->tt) {\n    case LUA_VTABLE: return &gco2t(o)->gclist;\n    case LUA_VLCL: return &gco2lcl(o)->gclist;\n    case LUA_VCCL: return &gco2ccl(o)->gclist;\n    case LUA_VTHREAD: return &gco2th(o)->gclist;\n    case LUA_VPROTO: return &gco2p(o)->gclist;\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      lua_assert(u->nuvalue > 0);\n      return &u->gclist;\n    }\n    default: lua_assert(0); return 0;\n  }\n}", "target": 0}
{"code": "void HTMLFormControlElement::parseAttribute(const QualifiedName& name, const AtomicString& value)\n{\n    if (name == formAttr) {\n        formAttributeChanged();\n        UseCounter::count(document(), UseCounter::FormAttribute);\n    } else if (name == disabledAttr) {\n        bool oldDisabled = m_disabled;\n        m_disabled = !value.isNull();\n        if (oldDisabled != m_disabled)\n            disabledAttributeChanged();\n    } else if (name == readonlyAttr) {\n        bool wasReadOnly = m_isReadOnly;\n        m_isReadOnly = !value.isNull();\n        if (wasReadOnly != m_isReadOnly) {\n            setNeedsWillValidateCheck();\n            setNeedsStyleRecalc();\n            if (renderer() && renderer()->style()->hasAppearance())\n                RenderTheme::theme().stateChanged(renderer(), ReadOnlyState);\n        }\n    } else if (name == requiredAttr) {\n        bool wasRequired = m_isRequired;\n        m_isRequired = !value.isNull();\n        if (wasRequired != m_isRequired)\n            requiredAttributeChanged();\n        UseCounter::count(document(), UseCounter::RequiredAttribute);\n    } else if (name == autofocusAttr) {\n        HTMLElement::parseAttribute(name, value);\n        UseCounter::count(document(), UseCounter::AutoFocusAttribute);\n    } else\n        HTMLElement::parseAttribute(name, value);\n}", "target": 0}
{"code": "static void sctp_assoc_free_asconf_acks(struct sctp_association *asoc)\n{\n\tstruct sctp_chunk *ack;\n\tstruct sctp_chunk *tmp;\n\tlist_for_each_entry_safe(ack, tmp, &asoc->asconf_ack_list,\n\t\t\t\ttransmitted_list) {\n\t\tlist_del_init(&ack->transmitted_list);\n\t\tsctp_chunk_free(ack);\n\t}\n}", "target": 0}
{"code": "xb_mysql_query(MYSQL *connection, const char *query, bool use_result,\n\t\tbool die_on_error)\n{\n\tMYSQL_RES *mysql_result = NULL;\n\tif (mysql_query(connection, query)) {\n\t\tmsg(\"Error: failed to execute query '%s': %u (%s) %s\\n\", query,\n\t\t    mysql_errno(connection),\n\t\t    mysql_errno_to_sqlstate(mysql_errno(connection)),\n\t\t    mysql_error(connection));\n\t\tif (die_on_error) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn(NULL);\n\t}\n\tif (mysql_field_count(connection) > 0) {\n\t\tif ((mysql_result = mysql_store_result(connection)) == NULL) {\n\t\t\tmsg(\"Error: failed to fetch query result %s: %s\\n\",\n\t\t\t    query, mysql_error(connection));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (!use_result) {\n\t\t\tmysql_free_result(mysql_result);\n\t\t}\n\t}\n\treturn mysql_result;\n}", "target": 0}
{"code": "void g_dhcpv6_client_create_iaid(GDHCPClient *dhcp_client, int index,\n\t\t\t\tunsigned char *iaid)\n{\n\tuint8_t buf[6];\n\t__connman_inet_get_interface_mac_address(index, buf);\n\tmemcpy(iaid, &buf[2], 4);\n\tdhcp_client->iaid = iaid[0] << 24 |\n\t\t\tiaid[1] << 16 | iaid[2] << 8 | iaid[3];\n}", "target": 0}
{"code": "free_decompression(struct archive_read *a, struct _7zip *zip)\n{\n\tint r = ARCHIVE_OK;\n#if !defined(HAVE_ZLIB_H) &&\\\n\t!(defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR))\n\t(void)a;\n#endif\n#ifdef HAVE_LZMA_H\n\tif (zip->lzstream_valid)\n\t\tlzma_end(&(zip->lzstream));\n#endif\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tif (zip->bzstream_valid) {\n\t\tif (BZ2_bzDecompressEnd(&(zip->bzstream)) != BZ_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up bzip2 decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t\tzip->bzstream_valid = 0;\n\t}\n#endif\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid) {\n\t\tif (inflateEnd(&(zip->stream)) != Z_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up zlib decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t\tzip->stream_valid = 0;\n\t}\n#endif\n\tif (zip->ppmd7_valid) {\n\t\t__archive_ppmd7_functions.Ppmd7_Free(\n\t\t\t&zip->ppmd7_context, &g_szalloc);\n\t\tzip->ppmd7_valid = 0;\n\t}\n\treturn (r);\n}", "target": 0}
{"code": "js_Value *js_tovalue(js_State *J, int idx)\n{\n\treturn stackidx(J, idx);\n}", "target": 0}
{"code": "input_utf8_add(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\tutf8_append(&ictx->utf8data, ictx->ch);\n\treturn (0);\n}", "target": 0}
{"code": "static inline void hrtick_clear(struct rq *rq)\n{\n}", "target": 0}
{"code": "PHPAPI int php_handle_auth_data(const char *auth)\n{\n\tint ret = -1;\n\tif (auth && auth[0] != '\\0' && strncmp(auth, \"Basic \", 6) == 0) {\n\t\tchar *pass;\n\t\tzend_string *user;\n\t\tuser = php_base64_decode((const unsigned char*)auth + 6, strlen(auth) - 6);\n\t\tif (user) {\n\t\t\tpass = strchr(ZSTR_VAL(user), ':');\n\t\t\tif (pass) {\n\t\t\t\t*pass++ = '\\0';\n\t\t\t\tSG(request_info).auth_user = estrndup(ZSTR_VAL(user), ZSTR_LEN(user));\n\t\t\t\tSG(request_info).auth_password = estrdup(pass);\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tzend_string_free(user);\n\t\t}\n\t}\n\tif (ret == -1) {\n\t\tSG(request_info).auth_user = SG(request_info).auth_password = NULL;\n\t} else {\n\t\tSG(request_info).auth_digest = NULL;\n\t}\n\tif (ret == -1 && auth && auth[0] != '\\0' && strncmp(auth, \"Digest \", 7) == 0) {\n\t\tSG(request_info).auth_digest = estrdup(auth + 7);\n\t\tret = 0;\n\t}\n\tif (ret == -1) {\n\t\tSG(request_info).auth_digest = NULL;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static void validate_slab_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\tunsigned long *map)\n{\n\tif (slab_trylock(page)) {\n\t\tvalidate_slab(s, page, map);\n\t\tslab_unlock(page);\n\t} else\n\t\tprintk(KERN_INFO \"SLUB %s: Skipped busy slab 0x%p\\n\",\n\t\t\ts->name, page);\n\tif (s->flags & DEBUG_DEFAULT_FLAGS) {\n\t\tif (!SlabDebug(page))\n\t\t\tprintk(KERN_ERR \"SLUB %s: SlabDebug not set \"\n\t\t\t\t\"on slab 0x%p\\n\", s->name, page);\n\t} else {\n\t\tif (SlabDebug(page))\n\t\t\tprintk(KERN_ERR \"SLUB %s: SlabDebug set on \"\n\t\t\t\t\"slab 0x%p\\n\", s->name, page);\n\t}\n}", "target": 0}
{"code": "int GetDevicelinkColorSpace(cmsHPROFILE hProfile)\n{\n    cmsColorSpaceSignature ProfileSpace = cmsGetPCS(hProfile);\n\treturn _cmsLCMScolorSpace(ProfileSpace);\n}", "target": 0}
{"code": "partition_create_data_unref (CreatePartitionData *data)\n{\n  data->refcount--;\n  if (data->refcount == 0)\n    {\n      g_object_unref (data->device);\n      g_free (data->fstype);\n      g_strfreev (data->fsoptions);\n      g_free (data);\n    }\n}", "target": 0}
{"code": "do_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)\n{\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint error = -ESRCH;\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\tif (!error && sig && lock_task_sighand(p, &flags)) {\n\t\t\terror = specific_send_sig_info(sig, info, p);\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn error;\n}", "target": 0}
{"code": "void HTMLFormControlElement::updateVisibleValidationMessage()\n{\n    Page* page = document().page();\n    if (!page)\n        return;\n    String message;\n    if (renderer() && willValidate())\n        message = validationMessage().stripWhiteSpace();\n    if (!m_validationMessage)\n        m_validationMessage = ValidationMessage::create(this);\n    m_validationMessage->updateValidationMessage(message);\n}", "target": 0}
{"code": "static struct node *get_node_nocheck(struct fuse *f, fuse_ino_t nodeid)\n{\n    size_t hash = nodeid % f->id_table_size;\n    struct node *node;\n    for (node = f->id_table[hash]; node != NULL; node = node->id_next)\n        if (node->nodeid == nodeid)\n            return node;\n    return NULL;\n}", "target": 0}
{"code": "static void ahci_irq_set(void *opaque, int n, int level)\n{\n}", "target": 0}
{"code": "static int process_timer_func(struct bpf_verifier_env *env, int regno,\n\t\t\t      struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tbool is_const = tnum_is_const(reg->var_off);\n\tstruct bpf_map *map = reg->map_ptr;\n\tu64 val = reg->var_off.value;\n\tif (!is_const) {\n\t\tverbose(env,\n\t\t\t\"R%d doesn't have constant offset. bpf_timer has to be at the constant offset\\n\",\n\t\t\tregno);\n\t\treturn -EINVAL;\n\t}\n\tif (!map->btf) {\n\t\tverbose(env, \"map '%s' has to have BTF in order to use bpf_timer\\n\",\n\t\t\tmap->name);\n\t\treturn -EINVAL;\n\t}\n\tif (!map_value_has_timer(map)) {\n\t\tif (map->timer_off == -E2BIG)\n\t\t\tverbose(env,\n\t\t\t\t\"map '%s' has more than one 'struct bpf_timer'\\n\",\n\t\t\t\tmap->name);\n\t\telse if (map->timer_off == -ENOENT)\n\t\t\tverbose(env,\n\t\t\t\t\"map '%s' doesn't have 'struct bpf_timer'\\n\",\n\t\t\t\tmap->name);\n\t\telse\n\t\t\tverbose(env,\n\t\t\t\t\"map '%s' is not a struct type or bpf_timer is mangled\\n\",\n\t\t\t\tmap->name);\n\t\treturn -EINVAL;\n\t}\n\tif (map->timer_off != val + reg->off) {\n\t\tverbose(env, \"off %lld doesn't point to 'struct bpf_timer' that is at %d\\n\",\n\t\t\tval + reg->off, map->timer_off);\n\t\treturn -EINVAL;\n\t}\n\tif (meta->map_ptr) {\n\t\tverbose(env, \"verifier bug. Two map pointers in a timer helper\\n\");\n\t\treturn -EFAULT;\n\t}\n\tmeta->map_uid = reg->map_uid;\n\tmeta->map_ptr = map;\n\treturn 0;\n}", "target": 0}
{"code": "assegment_normalise (struct assegment *head)\n{\n  struct assegment *seg = head, *pin;\n  struct assegment *tmp;\n  if (!head)\n    return head;\n  while (seg)\n    {\n      pin = seg;\n      if (seg->type == AS_SET || seg->type == AS_CONFED_SET)\n      \t{\n\t  int tail = 0;\n\t  int i;\n\t  qsort (seg->as, seg->length, sizeof(as_t), int_cmp);\n\t  for (i=1; i < seg->length; i++)\n\t    {\n\t      if (seg->as[tail] == seg->as[i])\n\t      \tcontinue;\n\t      tail++;\n\t      if (tail < i)\n\t      \tseg->as[tail] = seg->as[i];\n\t    }\n\t  if (seg->length)\n\t    seg->length = tail + 1;\n\t}\n      while (pin->next && ASSEGMENT_TYPES_PACKABLE(pin, pin->next))\n        {\n          tmp = pin->next;\n          seg = pin->next;\n          pin = assegment_append_asns (pin, seg->as, seg->length);\n          pin->next = seg->next;\n          assegment_free (tmp);\n        }\n      seg = pin->next;\n    }\n  return head;\n}", "target": 0}
{"code": "cgiGetSize(const char *name)\t\t\n{\n  _cgi_var_t\t*var;\t\t\t\n  if ((var = cgi_find_variable(name)) == NULL)\n    return (0);\n  return (var->nvalues);\n}", "target": 0}
{"code": "int key_default_cmp(const struct key *key,\n\t\t    const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}", "target": 0}
{"code": "gimp_channel_scale (GimpItem              *item,\n                    gint                   new_width,\n                    gint                   new_height,\n                    gint                   new_offset_x,\n                    gint                   new_offset_y,\n                    GimpInterpolationType  interpolation_type,\n                    GimpProgress          *progress)\n{\n  GimpChannel *channel = GIMP_CHANNEL (item);\n  if (G_TYPE_FROM_INSTANCE (item) == GIMP_TYPE_CHANNEL)\n    {\n      new_offset_x = 0;\n      new_offset_y = 0;\n    }\n  if (channel->bounds_known && channel->empty)\n    {\n      GimpDrawable *drawable = GIMP_DRAWABLE (item);\n      GeglBuffer   *new_buffer;\n      new_buffer =\n        gegl_buffer_new (GEGL_RECTANGLE (0, 0, new_width, new_height),\n                         gimp_drawable_get_format (drawable));\n      gimp_drawable_set_buffer_full (drawable,\n                                     gimp_item_is_attached (item), NULL,\n                                     new_buffer,\n                                     GEGL_RECTANGLE (new_offset_x, new_offset_y,\n                                                     0,            0),\n                                     TRUE);\n      g_object_unref (new_buffer);\n      gimp_channel_clear (GIMP_CHANNEL (item), NULL, FALSE);\n    }\n  else\n    {\n      GIMP_ITEM_CLASS (parent_class)->scale (item, new_width, new_height,\n                                             new_offset_x, new_offset_y,\n                                             interpolation_type, progress);\n    }\n}", "target": 0}
{"code": "storageDriverAutostart(void)\n{\n    virStoragePoolObjListForEach(driver->pools,\n                                 storageDriverAutostartCallback,\n                                 NULL);\n}", "target": 0}
{"code": "void eval_expr(VAR *v, const char *p, const char **p_end,\n               bool open_end, bool do_eval)\n{\n  DBUG_ENTER(\"eval_expr\");\n  DBUG_PRINT(\"enter\", (\"p: '%s'\", p));\n  if (! do_eval)\n    goto NO_EVAL;\n  if (*p == '$')\n  {\n    VAR *vp;\n    const char* expected_end= *p_end; \n    if ((vp= var_get(p, p_end, 0, 0)))\n      var_copy(v, vp);\n    v->str_val[v->str_val_len]= 0;\n    const char* end= *p_end + 1;\n    if (end < expected_end && !open_end)\n      die(\"Found junk '%.*s' after $variable in expression\",\n          (int)(expected_end - end - 1), end);\n    DBUG_VOID_RETURN;\n  }\n  if (*p == '`')\n  {\n    var_query_set(v, p, p_end);\n    DBUG_VOID_RETURN;\n  }\n  {\n    const char* get_value_str= \"query_get_value\";\n    const size_t len= strlen(get_value_str);\n    if (strncmp(p, get_value_str, len)==0)\n    {\n      struct st_command command;\n      memset(&command, 0, sizeof(command));\n      command.query= (char*)p;\n      command.first_word_len= len;\n      command.first_argument= command.query + len;\n      command.end= (char*)*p_end;\n      command.abort_on_error= 1; \n      var_set_query_get_value(&command, v);\n      DBUG_VOID_RETURN;\n    }\n  }\n NO_EVAL:\n  {\n    int new_val_len = (p_end && *p_end) ?\n      (int) (*p_end - p) : (int) strlen(p);\n    if (new_val_len + 1 >= v->alloced_len)\n    {\n      static int MIN_VAR_ALLOC= 32;\n      v->alloced_len = (new_val_len < MIN_VAR_ALLOC - 1) ?\n        MIN_VAR_ALLOC : new_val_len + 1;\n      if (!(v->str_val =\n            v->str_val ?\n            (char*)my_realloc(v->str_val, v->alloced_len+1, MYF(MY_WME)) :\n            (char*)my_malloc(v->alloced_len+1, MYF(MY_WME))))\n        die(\"Out of memory\");\n    }\n    v->str_val_len = new_val_len;\n    memcpy(v->str_val, p, new_val_len);\n    v->str_val[new_val_len] = 0;\n    var_check_int(v);\n  }\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, Snapshot) {\n    addIndex(BSON(\"a\" << 1));\n    runQuerySnapshot(fromjson(\"{a: {$gt: 0}}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {filter: {a: {$gt: 0}}, dir: 1}}\");\n}", "target": 0}
{"code": "  template<typename T>\n  inline CImg<_cimg_Tfloat> tan(const CImg<T>& instance) {\n    return instance.get_tan();", "target": 0}
{"code": "static int data_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_data *pkt;\n\tsize_t alloclen;\n\tline++;\n\tlen--;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_DATA;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\t*out = (git_pkt *) pkt;\n\treturn 0;\n}", "target": 0}
{"code": "void hci_sock_dev_event(struct hci_dev *hdev, int event)\n{\n\tstruct hci_ev_si_device ev;\n\tBT_DBG(\"hdev %s event %d\", hdev->name, event);\n\tif (atomic_read(&monitor_promisc)) {\n\t\tstruct sk_buff *skb;\n\t\tskb = create_monitor_event(hdev, event);\n\t\tif (skb) {\n\t\t\tsend_monitor_event(skb);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\tev.event  = event;\n\tev.dev_id = hdev->id;\n\thci_si_event(NULL, HCI_EV_SI_DEVICE, sizeof(ev), &ev);\n\tif (event == HCI_DEV_UNREG) {\n\t\tstruct sock *sk;\n\t\tstruct hlist_node *node;\n\t\tread_lock(&hci_sk_list.lock);\n\t\tsk_for_each(sk, node, &hci_sk_list.head) {\n\t\t\tbh_lock_sock_nested(sk);\n\t\t\tif (hci_pi(sk)->hdev == hdev) {\n\t\t\t\thci_pi(sk)->hdev = NULL;\n\t\t\t\tsk->sk_err = EPIPE;\n\t\t\t\tsk->sk_state = BT_OPEN;\n\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\thci_dev_put(hdev);\n\t\t\t}\n\t\t\tbh_unlock_sock(sk);\n\t\t}\n\t\tread_unlock(&hci_sk_list.lock);\n\t}\n}", "target": 0}
{"code": "MagickPrivate void ConvertRGBToLab(const double red,const double green,\n  const double blue,double *L,double *a,double *b)\n{\n  double\n    X,\n    Y,\n    Z;\n  ConvertRGBToXYZ(red,green,blue,&X,&Y,&Z);\n  ConvertXYZToLab(X,Y,Z,L,a,b);\n}", "target": 0}
{"code": "bool WebContentsImpl::UpdateTitleForEntry(NavigationEntryImpl* entry,\n                                          const string16& title) {\n  string16 final_title;\n  bool explicit_set;\n  if (entry && entry->GetURL().SchemeIsFile() && title.empty()) {\n    final_title = UTF8ToUTF16(entry->GetURL().ExtractFileName());\n    explicit_set = false;  \n  } else {\n    TrimWhitespace(title, TRIM_ALL, &final_title);\n    explicit_set = true;\n  }\n  if (entry) {\n    if (final_title == entry->GetTitle())\n      return false;  \n    entry->SetTitle(final_title);\n  } else {\n    if (page_title_when_no_navigation_entry_ == final_title)\n      return false;  \n    page_title_when_no_navigation_entry_ = final_title;\n  }\n  view_->SetPageTitle(final_title);\n  std::pair<NavigationEntry*, bool> details =\n      std::make_pair(entry, explicit_set);\n  NotificationService::current()->Notify(\n      NOTIFICATION_WEB_CONTENTS_TITLE_UPDATED,\n      Source<WebContents>(this),\n      Details<std::pair<NavigationEntry*, bool> >(&details));\n  return true;\n}", "target": 0}
{"code": "  cert_chain_t::clear() {\n    _certs.clear();\n  }", "target": 0}
{"code": "static gboolean delayed_cache_free(gpointer data)\n{\n    Cache* cache = data;\n    int i;\n    if(g_source_is_destroyed(g_main_current_source()))\n        return FALSE;\n    g_hash_table_remove( hash, cache->md5 );\n    for(i = 0; i < cache->n_files; ++i)\n    {\n        g_file_monitor_cancel( cache->mons[i] );\n        g_object_unref( cache->mons[i] );\n    }\n    g_free( cache->mons );\n    g_free(cache->menu_name);\n    g_free(cache->lang_name);\n    g_free(cache->cache_file);\n    g_strfreev( cache->env );\n    g_strfreev( cache->files );\n    if( cache->delayed_reload_handler )\n        g_source_remove( cache->delayed_reload_handler );\n    g_slice_free( Cache, cache );\n    if(g_hash_table_size(hash) == 0)\n        g_main_loop_quit(main_loop);\n    return FALSE;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ExprEqCanUseIndex) {\n    params.options &= ~QueryPlannerParams::INCLUDE_COLLSCAN;\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{a: {$_internalExprEq: 1}}\"));\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a: 1}, bounds: {a: \"\n        \"[[1,1,true,true]]}}}}}\");\n}", "target": 0}
{"code": "static int find_mount_flag(const char *s, unsigned len, int *on, int *flag)\n{\n\tint i;\n\tfor (i = 0; mount_flags[i].opt != NULL; i++) {\n\t\tconst char *opt = mount_flags[i].opt;\n\t\tif (strlen(opt) == len && strncmp(opt, s, len) == 0) {\n\t\t\t*on = mount_flags[i].on;\n\t\t\t*flag = mount_flags[i].flag;\n\t\t\tif (!mount_flags[i].safe && getuid() != 0) {\n\t\t\t\t*flag = 0;\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s: unsafe option %s ignored\\n\",\n\t\t\t\t\tprogname, opt);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "virgl_resource_attach_backing(VuGpu *g,\n                              struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_attach_backing att_rb;\n    struct iovec *res_iovs;\n    int ret;\n    VUGPU_FILL_CMD(att_rb);\n    ret = vg_create_mapping_iov(g, &att_rb, cmd, &res_iovs);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n    ret = virgl_renderer_resource_attach_iov(att_rb.resource_id,\n                                       res_iovs, att_rb.nr_entries);\n    if (ret != 0) {\n        g_free(res_iovs);\n    }\n}", "target": 0}
{"code": "static struct key *nfs_idmap_request_key(const char *name, size_t namelen,\n\t\t\t\t\t const char *type, struct idmap *idmap)\n{\n\tchar *desc;\n\tstruct key *rkey;\n\tssize_t ret;\n\tret = nfs_idmap_get_desc(name, namelen, type, strlen(type), &desc);\n\tif (ret <= 0)\n\t\treturn ERR_PTR(ret);\n\trkey = request_key(&key_type_id_resolver, desc, \"\");\n\tif (IS_ERR(rkey)) {\n\t\tmutex_lock(&idmap->idmap_mutex);\n\t\trkey = request_key_with_auxdata(&key_type_id_resolver_legacy,\n\t\t\t\t\t\tdesc, \"\", 0, idmap);\n\t\tmutex_unlock(&idmap->idmap_mutex);\n\t}\n\tif (!IS_ERR(rkey))\n\t\tset_bit(KEY_FLAG_ROOT_CAN_INVAL, &rkey->flags);\n\tkfree(desc);\n\treturn rkey;\n}", "target": 0}
{"code": "    void TiffReader::visitImageEntry(TiffImageEntry* object)\n    {\n        readDataEntryBase(object);\n    }", "target": 0}
{"code": "utf32le_get_case_fold_codes_by_str(OnigCaseFoldType flag,\n\t\t\t\t   const OnigUChar* p, const OnigUChar* end,\n\t\t\t\t   OnigCaseFoldCodeItem items[],\n\t\t\t\t   OnigEncoding enc)\n{\n  return onigenc_unicode_get_case_fold_codes_by_str(enc,\n\t\t\t\t\t\t    flag, p, end, items);\n}", "target": 0}
{"code": "epass2003_get_serialnr(struct sc_card *card, sc_serial_number_t * serial)\n{\n\tu8 rbuf[8];\n\tsize_t rbuf_len = sizeof(rbuf);\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (SC_SUCCESS != get_data(card, 0x80, rbuf, rbuf_len))\n\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\tcard->serialnr.len = serial->len = 8;\n\tmemcpy(card->serialnr.value, rbuf, 8);\n\tmemcpy(serial->value, rbuf, 8);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}", "target": 0}
{"code": "    DataBuf::DataBuf(const DataBufRef &rhs) : pData_(rhs.p.first), size_(rhs.p.second) {}", "target": 0}
{"code": "void SavePackage::Finish() {\n  if (canceled())\n    return;\n  wait_state_ = SUCCESSFUL;\n  finished_ = true;\n  RecordSavePackageEvent(SAVE_PACKAGE_FINISHED);\n  if (wrote_to_completed_file_) {\n    RecordSavePackageEvent(SAVE_PACKAGE_WRITE_TO_COMPLETED);\n  }\n  if (wrote_to_failed_file_) {\n    RecordSavePackageEvent(SAVE_PACKAGE_WRITE_TO_FAILED);\n  }\n  SaveIDList save_ids;\n  for (SaveUrlItemMap::iterator it = saved_failed_items_.begin();\n       it != saved_failed_items_.end(); ++it)\n    save_ids.push_back(it->second->save_id());\n  BrowserThread::PostTask(\n      BrowserThread::FILE, FROM_HERE,\n      base::Bind(&SaveFileManager::RemoveSavedFileFromFileMap,\n                 file_manager_,\n                 save_ids));\n  if (download_) {\n    if (download_->IsInProgress()) {\n      if (save_type_ != SAVE_PAGE_TYPE_AS_MHTML) {\n        download_->UpdateProgress(all_save_items_count_, CurrentSpeed(), \"\");\n        download_->OnAllDataSaved(DownloadItem::kEmptyFileHash);\n      }\n      download_->MarkAsComplete();\n    }\n    FinalizeDownloadEntry();\n  }\n}", "target": 0}
{"code": "dir_each_entry(VALUE dir, VALUE (*each)(VALUE, VALUE), VALUE arg, int children_only)\n{\n    struct dir_data *dirp;\n    struct dirent *dp;\n    IF_NORMALIZE_UTF8PATH(int norm_p);\n    GetDIR(dir, dirp);\n    rewinddir(dirp->dir);\n    IF_NORMALIZE_UTF8PATH(norm_p = need_normalization(dirp->dir, RSTRING_PTR(dirp->path)));\n    while ((dp = READDIR(dirp->dir, dirp->enc)) != NULL) {\n\tconst char *name = dp->d_name;\n\tsize_t namlen = NAMLEN(dp);\n\tVALUE path;\n\tif (children_only && name[0] == '.') {\n\t    if (namlen == 1) continue; \n\t    if (namlen == 2 && name[1] == '.') continue; \n\t}\n#if NORMALIZE_UTF8PATH\n\tif (norm_p && has_nonascii(name, namlen) &&\n\t    !NIL_P(path = rb_str_normalize_ospath(name, namlen))) {\n\t    path = rb_external_str_with_enc(path, dirp->enc);\n\t}\n\telse\n#endif\n\tpath = rb_external_str_new_with_enc(name, namlen, dirp->enc);\n\t(*each)(arg, path);\n    }\n    return dir;\n}", "target": 0}
{"code": "static void send_monitor_event(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\tBT_DBG(\"len %d\", skb->len);\n\tread_lock(&hci_sk_list.lock);\n\tsk_for_each(sk, node, &hci_sk_list.head) {\n\t\tstruct sk_buff *nskb;\n\t\tif (sk->sk_state != BT_BOUND)\n\t\t\tcontinue;\n\t\tif (hci_pi(sk)->channel != HCI_CHANNEL_MONITOR)\n\t\t\tcontinue;\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\tread_unlock(&hci_sk_list.lock);\n}", "target": 0}
{"code": "    TiffComponent* TiffMnEntry::doAddNext(TiffComponent::UniquePtr tiffComponent)\n    {\n        TiffComponent* tc = 0;\n        if (mn_) {\n            tc = mn_->addNext(std::move(tiffComponent));\n        }\n        return tc;\n    } ", "target": 0}
{"code": "  StorageType type() const { return type_; }", "target": 0}
{"code": "static void irda_connect_response(struct irda_sock *self)\n{\n\tstruct sk_buff *skb;\n\tIRDA_DEBUG(2, \"%s()\\n\", __func__);\n\tskb = alloc_skb(TTP_MAX_HEADER + TTP_SAR_HEADER,\n\t\t\tGFP_ATOMIC);\n\tif (skb == NULL) {\n\t\tIRDA_DEBUG(0, \"%s() Unable to allocate sk_buff!\\n\",\n\t\t\t   __func__);\n\t\treturn;\n\t}\n\tskb_reserve(skb, IRDA_MAX_HEADER);\n\tirttp_connect_response(self->tsap, self->max_sdu_size_rx, skb);\n}", "target": 0}
{"code": "void apply_transition_effects(ASS_Renderer *render_priv, ASS_Event *event)\n{\n    int v[4];\n    int cnt;\n    char *p = event->Effect;\n    if (!p || !*p)\n        return;\n    cnt = 0;\n    while (cnt < 4 && (p = strchr(p, ';'))) {\n        v[cnt++] = atoi(++p);\n    }\n    if (strncmp(event->Effect, \"Banner;\", 7) == 0) {\n        int delay;\n        if (cnt < 1) {\n            ass_msg(render_priv->library, MSGL_V,\n                    \"Error parsing effect: '%s'\", event->Effect);\n            return;\n        }\n        if (cnt >= 2 && v[1] == 0)      \n            render_priv->state.scroll_direction = SCROLL_RL;\n        else                    \n            render_priv->state.scroll_direction = SCROLL_LR;\n        delay = v[0];\n        if (delay == 0)\n            delay = 1;          \n        render_priv->state.scroll_shift =\n            (render_priv->time - render_priv->state.event->Start) / delay;\n        render_priv->state.evt_type = EVENT_HSCROLL;\n        return;\n    }\n    if (strncmp(event->Effect, \"Scroll up;\", 10) == 0) {\n        render_priv->state.scroll_direction = SCROLL_BT;\n    } else if (strncmp(event->Effect, \"Scroll down;\", 12) == 0) {\n        render_priv->state.scroll_direction = SCROLL_TB;\n    } else {\n        ass_msg(render_priv->library, MSGL_DBG2,\n                \"Unknown transition effect: '%s'\", event->Effect);\n        return;\n    }\n    {\n        int delay;\n        int y0, y1;\n        if (cnt < 3) {\n            ass_msg(render_priv->library, MSGL_V,\n                    \"Error parsing effect: '%s'\", event->Effect);\n            return;\n        }\n        delay = v[2];\n        if (delay == 0)\n            delay = 1;          \n        render_priv->state.scroll_shift =\n            (render_priv->time - render_priv->state.event->Start) / delay;\n        if (v[0] < v[1]) {\n            y0 = v[0];\n            y1 = v[1];\n        } else {\n            y0 = v[1];\n            y1 = v[0];\n        }\n        if (y1 == 0)\n            y1 = render_priv->track->PlayResY;  \n        render_priv->state.clip_y0 = y0;\n        render_priv->state.clip_y1 = y1;\n        render_priv->state.evt_type = EVENT_VSCROLL;\n        render_priv->state.detect_collisions = 0;\n    }\n}", "target": 0}
{"code": "static void naldmx_bs_log(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3)\n{\n\tGF_NALUDmxCtx *ctx = (GF_NALUDmxCtx *) udta;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\" %s\", field_name));\n\tif (idx1>=0) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"_%d\", idx1));\n\t\tif (idx2>=0) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"_%d\", idx2));\n\t\t\tif (idx3>=0) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"_%d\", idx3));\n\t\t\t}\n\t\t}\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"=\\\"\"LLD, field_val));\n\tif ((ctx->bsdbg==2) && ((s32) nb_bits > 1) )\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"(%u)\", nb_bits));\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"\\\" \"));\n}", "target": 0}
{"code": "static int php_pgsql_add_quotes(zval *src, zend_bool should_free) \n{\n\tsmart_str str = {0};\n\tassert(Z_TYPE_P(src) == IS_STRING);\n\tassert(should_free == 1 || should_free == 0);\n\tsmart_str_appendc(&str, 'E');\n\tsmart_str_appendc(&str, '\\'');\n\tsmart_str_appendl(&str, Z_STRVAL_P(src), Z_STRLEN_P(src));\n\tsmart_str_appendc(&str, '\\'');\n\tsmart_str_0(&str);\n\tif (should_free) {\n\t\tzval_ptr_dtor(src);\n\t}\n\tZVAL_NEW_STR(src, str.s);\n\treturn SUCCESS;\n}", "target": 0}
{"code": "static int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||\n\t\t    kctl->put == NULL ||\n\t\t    (file && vd->owner && vd->owner != file)) {\n\t\t\tresult = -EPERM;\n\t\t} else {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->put(kctl, control);\n\t\t}\n\t\tif (result > 0) {\n\t\t\tstruct snd_ctl_elem_id id = control->id;\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &id);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}", "target": 0}
{"code": "static int acurite_rain_896_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    uint8_t *b = bitbuffer->bb[0];\n    int id;\n    float total_rain;\n    data_t *data;\n    if (bitbuffer->bits_per_row[0] < 24)\n        return DECODE_ABORT_LENGTH;\n    if ((b[0] == 0) || (b[1] == 0) || (b[2] == 0) || (b[3] != 0) || (b[4] != 0))\n        return DECODE_ABORT_EARLY;\n    id = b[0];\n    total_rain = ((b[1] & 0xf) << 8) | b[2];\n    total_rain *= 0.5; \n    decoder_logf(decoder, 2, __func__, \"Total Rain is %2.1fmm\", total_rain);\n    decoder_log_bitrow(decoder, 2, __func__, b, bitbuffer->bits_per_row[0], \"Raw Message \");\n    data = data_make(\n            \"model\",                \"\",             DATA_STRING, \"Acurite-Rain\",\n            \"id\",                   \"\",             DATA_INT,    id,\n            \"rain_mm\",              \"Total Rain\",   DATA_FORMAT, \"%.1f mm\", DATA_DOUBLE, total_rain,\n            NULL);\n    decoder_output_data(decoder, data);\n    return 1;\n}", "target": 0}
{"code": "test_keys( ELG_secret_key *sk, unsigned int nbits )\n{\n    ELG_public_key pk;\n    MPI test = mpi_alloc( 0 );\n    MPI out1_a = mpi_alloc ( mpi_nlimb_hint_from_nbits (nbits) );\n    MPI out1_b = mpi_alloc ( mpi_nlimb_hint_from_nbits (nbits) );\n    MPI out2   = mpi_alloc ( mpi_nlimb_hint_from_nbits (nbits) );\n    pk.p = sk->p;\n    pk.g = sk->g;\n    pk.y = sk->y;\n    {\tchar *p = get_random_bits( nbits, 0, 0 );\n\tmpi_set_buffer( test, p, (nbits+7)/8, 0 );\n\txfree(p);\n    }\n    do_encrypt( out1_a, out1_b, test, &pk );\n    decrypt( out2, out1_a, out1_b, sk );\n    if( mpi_cmp( test, out2 ) )\n\tlog_fatal(\"Elgamal operation: encrypt, decrypt failed\\n\");\n    mpi_free( test );\n    mpi_free( out1_a );\n    mpi_free( out1_b );\n    mpi_free( out2 );\n}", "target": 0}
{"code": "void FrameLoader::load(const ResourceRequest& request, const String& frameName, bool lockHistory)\n{\n    if (frameName.isEmpty()) {\n        load(request, lockHistory);\n        return;\n    }\n    Frame* frame = findFrameForNavigation(frameName);\n    if (frame) {\n        frame->loader()->load(request, lockHistory);\n        return;\n    }\n    policyChecker()->checkNewWindowPolicy(NavigationAction(request.url(), NavigationTypeOther), FrameLoader::callContinueLoadAfterNewWindowPolicy, request, 0, frameName, this);\n}", "target": 0}
{"code": "static inline struct rtable *skb_rtable(const struct sk_buff *skb)\n{\n\treturn (struct rtable *)skb_dst(skb);\n}", "target": 0}
{"code": "int __audit_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification)\n{\n\tstruct audit_aux_data_mq_notify *ax;\n\tstruct audit_context *context = current->audit_context;\n\tif (!audit_enabled)\n\t\treturn 0;\n\tif (likely(!context))\n\t\treturn 0;\n\tax = kmalloc(sizeof(*ax), GFP_ATOMIC);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\tif (u_notification != NULL) {\n\t\tif (copy_from_user(&ax->notification, u_notification, sizeof(ax->notification))) {\n\t\t\tkfree(ax);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else\n\t\tmemset(&ax->notification, 0, sizeof(ax->notification));\n\tax->mqdes = mqdes;\n\tax->d.type = AUDIT_MQ_NOTIFY;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\treturn 0;\n}", "target": 0}
{"code": "storageConnectListStoragePools(virConnectPtr conn,\n                               char **const names,\n                               int maxnames)\n{\n    if (virConnectListStoragePoolsEnsureACL(conn) < 0)\n        return -1;\n    return virStoragePoolObjGetNames(driver->pools, conn, true,\n                                     virConnectListStoragePoolsCheckACL,\n                                     names, maxnames);\n}", "target": 0}
{"code": "static void set_min_partial(struct kmem_cache *s, unsigned long min)\n{\n\tif (min < MIN_PARTIAL)\n\t\tmin = MIN_PARTIAL;\n\telse if (min > MAX_PARTIAL)\n\t\tmin = MAX_PARTIAL;\n\ts->min_partial = min;\n}", "target": 0}
{"code": "static int check_map_access(struct bpf_verifier_env *env, u32 regno,\n\t\t\t    int off, int size, bool zero_size_allowed)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *reg = &state->regs[regno];\n\tint err;\n\tif (env->log.level)\n\t\tprint_verifier_state(env, state);\n\tif (reg->smin_value < 0) {\n\t\tverbose(env, \"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",\n\t\t\tregno);\n\t\treturn -EACCES;\n\t}\n\terr = __check_map_access(env, regno, reg->smin_value + off, size,\n\t\t\t\t zero_size_allowed);\n\tif (err) {\n\t\tverbose(env, \"R%d min value is outside of the array range\\n\",\n\t\t\tregno);\n\t\treturn err;\n\t}\n\tif (reg->umax_value >= BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"R%d unbounded memory access, make sure to bounds check any array access into a map\\n\",\n\t\t\tregno);\n\t\treturn -EACCES;\n\t}\n\terr = __check_map_access(env, regno, reg->umax_value + off, size,\n\t\t\t\t zero_size_allowed);\n\tif (err)\n\t\tverbose(env, \"R%d max value is outside of the array range\\n\",\n\t\t\tregno);\n\treturn err;\n}", "target": 0}
