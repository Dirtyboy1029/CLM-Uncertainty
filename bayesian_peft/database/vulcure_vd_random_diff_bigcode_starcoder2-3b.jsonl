{"code": "push_partial_as_tag (GMarkupParseContext *context)\n{\n  GString *str = context->partial_chunk;\n  context->tag_stack = g_slist_concat (get_list_node (context, str->str), context->tag_stack);\n  context->tag_stack_gstr = g_slist_concat (get_list_node (context, str), context->tag_stack_gstr);\n  context->partial_chunk = NULL;\n}", "target": 0}
{"code": "static int evdev_open_device(struct evdev *evdev)\n{\n\tint retval;\n\tretval = mutex_lock_interruptible(&evdev->mutex);\n\tif (retval)\n\t\treturn retval;\n\tif (!evdev->exist)\n\t\tretval = -ENODEV;\n\telse if (!evdev->open++) {\n\t\tretval = input_open_device(&evdev->handle);\n\t\tif (retval)\n\t\t\tevdev->open--;\n\t}\n\tmutex_unlock(&evdev->mutex);\n\treturn retval;\n}", "target": 0}
{"code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n\tint i, count = 0;\n\tmemset(outbuf, 0, outlen);\n\tin++;\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\twhile (octets_left) {\n\t\tint bits_to_go;\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}", "target": 1}
{"code": "static void vmci_transport_peer_attach_cb(u32 sub_id,\n\t\t\t\t\t  const struct vmci_event_data *e_data,\n\t\t\t\t\t  void *client_data)\n{\n\tstruct sock *sk = client_data;\n\tconst struct vmci_event_payload_qp *e_payload;\n\tstruct vsock_sock *vsk;\n\te_payload = vmci_event_data_const_payload(e_data);\n\tvsk = vsock_sk(sk);\n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\tif (vmci_handle_is_equal(vmci_trans(vsk)->qp_handle,\n\t\t\t\t e_payload->handle)) {\n\t\tgoto out;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n}", "target": 0}
{"code": "struct nft_flow_rule *nft_flow_rule_create(struct net *net,\n\t\t\t\t\t   const struct nft_rule *rule)\n{\n\tstruct nft_offload_ctx *ctx;\n\tstruct nft_flow_rule *flow;\n\tint num_actions = 0, err;\n\tstruct nft_expr *expr;\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (expr->ops->offload_flags & NFT_OFFLOAD_F_ACTION)\n\t\t\tnum_actions++;\n\t\texpr = nft_expr_next(expr);\n\t}\n\tif (num_actions == 0)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tflow = nft_flow_rule_alloc(num_actions);\n\tif (!flow)\n\t\treturn ERR_PTR(-ENOMEM);\n\texpr = nft_expr_first(rule);\n\tctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tctx->net = net;\n\tctx->dep.type = NFT_OFFLOAD_DEP_UNSPEC;\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (!expr->ops->offload) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = expr->ops->offload(ctx, flow, expr);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t\texpr = nft_expr_next(expr);\n\t}\n\tnft_flow_rule_transfer_vlan(ctx, flow);\n\tflow->proto = ctx->dep.l3num;\n\tkfree(ctx);\n\treturn flow;\nerr_out:\n\tkfree(ctx);\n\tnft_flow_rule_destroy(flow);\n\treturn ERR_PTR(err);\n}", "target": 1}
{"code": "pci_lintr_release(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tsi->si_intpins[pin].ii_count = 0;\n\t\tsi->si_intpins[pin].ii_pirq_pin = 0;\n\t\tsi->si_intpins[pin].ii_ioapic_irq = 0;\n\t}\n}", "target": 1}
{"code": "static int bio_copy_to_iter(struct bio *bio, struct iov_iter iter)\n{\n\tstruct bio_vec *bvec;\n\tstruct bvec_iter_all iter_all;\n\tbio_for_each_segment_all(bvec, bio, iter_all) {\n\t\tssize_t ret;\n\t\tret = copy_page_to_iter(bvec->bv_page,\n\t\t\t\t\tbvec->bv_offset,\n\t\t\t\t\tbvec->bv_len,\n\t\t\t\t\t&iter);\n\t\tif (!iov_iter_count(&iter))\n\t\t\tbreak;\n\t\tif (ret < bvec->bv_len)\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "cdf_read_header(const cdf_info_t *info, cdf_header_t *h)\n{\n\tchar buf[512];\n\t(void)memcpy(cdf_bo.s, \"\\01\\02\\03\\04\", 4);\n\tif (cdf_read(info, (off_t)0, buf, sizeof(buf)) == -1)\n\t\treturn -1;\n\tcdf_unpack_header(h, buf);\n\tcdf_swap_header(h);\n\tif (h->h_magic != CDF_MAGIC) {\n\t\tDPRINTF((\"Bad magic 0x%\" INT64_T_FORMAT \"x != 0x%\"\n\t\t    INT64_T_FORMAT \"x\\n\",\n\t\t    (unsigned long long)h->h_magic,\n\t\t    (unsigned long long)CDF_MAGIC));\n\t\tgoto out;\n\t}\n\tif (h->h_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad sector size 0x%u\\n\", h->h_sec_size_p2));\n\t\tgoto out;\n\t}\n\tif (h->h_short_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad short sector size 0x%u\\n\",\n\t\t    h->h_short_sec_size_p2));\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "static BOOL update_gdi_mem3blt(rdpContext* context, MEM3BLT_ORDER* mem3blt)\n{\n\tBYTE style;\n\trdpBitmap* bitmap;\n\trdpCache* cache = context->cache;\n\trdpBrush* brush = &mem3blt->brush;\n\tBOOL ret = TRUE;\n\tif (mem3blt->cacheId == 0xFF)\n\t\tbitmap = offscreen_cache_get(cache->offscreen, mem3blt->cacheIndex);\n\telse\n\t\tbitmap = bitmap_cache_get(cache->bitmap, (BYTE)mem3blt->cacheId, mem3blt->cacheIndex);\n\tif (!bitmap)\n\t\treturn TRUE;\n\tstyle = brush->style;\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->data = brush_cache_get(cache->brush, brush->index, &brush->bpp);\n\t\tif (!brush->data)\n\t\t\treturn FALSE;\n\t\tbrush->style = 0x03;\n\t}\n\tmem3blt->bitmap = bitmap;\n\tIFCALLRET(cache->bitmap->Mem3Blt, ret, context, mem3blt);\n\tbrush->style = style;\n\treturn ret;\n}", "target": 0}
{"code": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\tfile->f_flags = op->open_flag;\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n\t}\n\terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { \n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tpath_cleanup(nd);\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}", "target": 1}
{"code": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))\n\t\treturn;\n\ttlb_flush_mmu_tlbonly(tlb);\n}", "target": 1}
{"code": "static unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\tarea = current->mm->uprobes_state.xol_area;\n\tsmp_read_barrier_depends();\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\treturn trampoline_vaddr;\n}", "target": 0}
{"code": "void Module::setSource(Module *module) { m_source = module; }", "target": 0}
{"code": "static struct sctp_transport *sctp_trans_elect_tie(struct sctp_transport *trans1,\n\t\t\t\t\t\t   struct sctp_transport *trans2)\n{\n\tif (trans1->error_count > trans2->error_count) {\n\t\treturn trans2;\n\t} else if (trans1->error_count == trans2->error_count &&\n\t\t   ktime_after(trans2->last_time_heard,\n\t\t\t       trans1->last_time_heard)) {\n\t\treturn trans2;\n\t} else {\n\t\treturn trans1;\n\t}\n}", "target": 0}
{"code": "static int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = ops;\n\tsock_init_data(sock, sk);\n\tsk->sk_family = PF_IEEE802154;\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}", "target": 1}
{"code": "static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpf_init_units();\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\tio_put_file(req->file);\n\treq->file = NULL;\n\treturn IOU_OK;\n}", "target": 1}
{"code": "void rose_stop_idletimer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->idletimer);\n}", "target": 1}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "update_job_run (updateJobPtr job)\n{\n\tif (*(job->request->source) == '|') {\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n\t\tupdate_exec_cmd (job);\n\t\treturn;\n\t}\n\tif (strstr (job->request->source, \":\n\t\tnetwork_process_request (job);\n\t\treturn;\n\t}\n\t{\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized file URI: %s\", job->request->source);\n\t\tupdate_load_file (job);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "  HostQuotaCallback* NewWaitableHostQuotaCallback() {\n    ++waiting_callbacks_;\n    return callback_factory_.NewCallback(\n            &UsageAndQuotaDispatcherTask::DidGetHostQuota);\n  }", "target": 0}
{"code": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\tBUG_ON(hdr_off || sg || off);\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\trds_message_addref(rm);\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\trds_inc_put(&rm->m_inc);\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}", "target": 1}
{"code": "mm_skey_query(void *ctx, char **name, char **infotxt,\n   u_int *numprompts, char ***prompts, u_int **echo_on)\n{\n\tBuffer m;\n\tint len;\n\tu_int success;\n\tchar *p, *challenge;\n\tdebug3(\"%s: entering\", __func__);\n\tbuffer_init(&m);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYQUERY, &m);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SKEYQUERY,\n\t    &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: no challenge\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (-1);\n\t}\n\tchallenge  = buffer_get_string(&m, NULL);\n\tbuffer_free(&m);\n\tdebug3(\"%s: received challenge: %s\", __func__, challenge);\n\tmm_chall_setup(name, infotxt, numprompts, prompts, echo_on);\n\tlen = strlen(challenge) + strlen(SKEY_PROMPT) + 1;\n\tp = xmalloc(len);\n\tstrlcpy(p, challenge, len);\n\tstrlcat(p, SKEY_PROMPT, len);\n\t(*prompts)[0] = p;\n\txfree(challenge);\n\treturn (0);\n}", "target": 0}
{"code": "cmnd_matches_all(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    const bool negated = m->negated;\n    struct sudo_command *c;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (matched != UNSPEC) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - FF_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + FF_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p + min_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n}", "target": 0}
{"code": "int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n\t\t     int flen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\tif (udf_build_ustr_exact(unifilename, sname, flen))\n\t\tgoto out2;\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}", "target": 1}
{"code": "static inline void show_node(struct zone *zone)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tprintk(\"Node %d \", zone_to_nid(zone));\n}", "target": 0}
{"code": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}", "target": 1}
{"code": "vte_sequence_handler_sc (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tscreen = terminal->pvt->screen;\n\tscreen->cursor_saved.col = screen->cursor_current.col;\n\tscreen->cursor_saved.row = CLAMP(screen->cursor_current.row -\n\t\t\t\t\t screen->insert_delta,\n\t\t\t\t\t 0, terminal->row_count - 1);\n}", "target": 0}
{"code": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "static inline struct shmid_kernel *shm_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock(&shm_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn (void *)ipcp;\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}", "target": 0}
{"code": "static int snd_timer_stop1(struct snd_timer_instance *timeri, bool stop)\n{\n\tstruct snd_timer *timer;\n\tint result = 0;\n\tunsigned long flags;\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (!(timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t       SNDRV_TIMER_IFLG_START))) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif (timer->card && timer->card->shutdown)\n\t\tgoto unlock;\n\tif (stop) {\n\t\ttimeri->cticks = timeri->ticks;\n\t\ttimeri->pticks = 0;\n\t}\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\ttimeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tsnd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}", "target": 0}
{"code": "snmp_oid_print(uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  LOG_DBG(\"{\");\n  while(oid[i] != ((uint32_t)-1)) {\n    LOG_DBG_(\"%lu\", (unsigned long)oid[i]);\n    i++;\n    if(oid[i] != ((uint32_t)-1)) {\n      LOG_DBG_(\".\");\n    }\n  }\n  LOG_DBG_(\"}\\n\");\n}", "target": 1}
{"code": "copy_text_attr(\n    int\t\toff,\n    char_u\t*buf,\n    int\t\tlen,\n    int\t\tattr)\n{\n    int\t\ti;\n    mch_memmove(ScreenLines + off, buf, (size_t)len);\n    if (enc_utf8)\n\tvim_memset(ScreenLinesUC + off, 0, sizeof(u8char_T) * (size_t)len);\n    for (i = 0; i < len; ++i)\n\tScreenAttrs[off + i] = attr;\n}", "target": 0}
{"code": "static int whiteheat_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint retval;\n\tretval = start_command_port(port->serial);\n\tif (retval)\n\t\tgoto exit;\n\tretval = firm_open(port);\n\tif (retval) {\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\tretval = firm_purge(port, WHITEHEAT_PURGE_RX | WHITEHEAT_PURGE_TX);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\tif (tty)\n\t\tfirm_setup_port(tty);\n\tusb_clear_halt(port->serial->dev, port->read_urb->pipe);\n\tusb_clear_halt(port->serial->dev, port->write_urb->pipe);\n\tretval = usb_serial_generic_open(tty, port);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\nexit:\n\treturn retval;\n}", "target": 0}
{"code": "pipe_setup (Pipe *pipe, FILE *logf, gpointer user_data)\n{\n\tGIOFlags flags = 0;\n\tpipe->logf = logf;\n\tpipe->buf = g_string_sized_new (512);\n\tpipe->channel = g_io_channel_unix_new (pipe->fd);\n\tg_io_channel_set_encoding (pipe->channel, NULL, NULL);\n\tflags = g_io_channel_get_flags (pipe->channel);\n\tg_io_channel_set_flags (pipe->channel, flags | G_IO_FLAG_NONBLOCK, NULL);\n\tg_io_channel_set_buffered (pipe->channel, FALSE);\n\tpipe->watch = g_io_add_watch (pipe->channel,\n\t                              G_IO_IN | G_IO_ERR | G_IO_PRI,\n\t                              data_available,\n\t                              user_data);\n}", "target": 0}
{"code": "delta_head_create(struct delta_head **result)\n{\n\tstruct delta_head *tmp;\n\ttmp = malloc(sizeof(struct delta_head));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tdoc_data_init(&tmp->doc_data);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "bytesPerDeepLineTable (const Header &header,\n                       int minY, int maxY,\n                       const char* base,\n                       int xStride,\n                       int yStride,\n                       vector<size_t> &bytesPerLine)\n{\n    const Box2i &dataWindow = header.dataWindow();\n    const ChannelList &channels = header.channels();\n    for (ChannelList::ConstIterator c = channels.begin();\n         c != channels.end();\n         ++c)\n    {\n        const int ySampling = abs(c.channel().ySampling);\n        const int xSampling = abs(c.channel().xSampling);\n        const int pixelSize = pixelTypeSize (c.channel().type);\n        const int sampleMinY = roundToNextMultiple(minY, ySampling);\n        const int sampleMaxY = roundToPrevMultiple(maxY, ySampling);\n        const int sampleMinX = roundToNextMultiple(dataWindow.min.x, xSampling);\n        const int sampleMaxX = roundToPrevMultiple(dataWindow.max.x, xSampling);\n        for (int y = sampleMinY; y <= sampleMaxY; y+=ySampling)\n        {\n            int nBytes = 0;\n            for (int x = sampleMinX; x <= sampleMaxX; x += xSampling)\n            {\n                nBytes += pixelSize *\n                          sampleCount(base, xStride, yStride, x, y);\n            }\n            bytesPerLine[y - dataWindow.min.y] += nBytes;\n        }\n    }\n    size_t maxBytesPerLine = 0;\n    for (int y = minY; y <= maxY; ++y)\n        if (maxBytesPerLine < bytesPerLine[y - dataWindow.min.y])\n            maxBytesPerLine = bytesPerLine[y - dataWindow.min.y];\n    return maxBytesPerLine;\n}", "target": 1}
{"code": "buf_find_string_offset(const buf_t *buf, const char *s, size_t n)\n{\n  buf_pos_t pos;\n  buf_pos_init(buf, &pos);\n  while (buf_find_pos_of_char(*s, &pos) >= 0) {\n    if (buf_matches_at_pos(&pos, s, n)) {\n      tor_assert(pos.chunk_pos + pos.pos < INT_MAX);\n      return (int)(pos.chunk_pos + pos.pos);\n    } else {\n      if (buf_pos_inc(&pos)<0)\n        return -1;\n    }\n  }\n  return -1;\n}", "target": 0}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 count, now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tu32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;\n\t\tchallenge_timestamp = now;\n\t\tWRITE_ONCE(challenge_count, half +\n\t\t\t   prandom_u32_max(sysctl_tcp_challenge_ack_limit));\n\t}\n\tcount = READ_ONCE(challenge_count);\n\tif (count > 0) {\n\t\tWRITE_ONCE(challenge_count, count - 1);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 0}
{"code": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n{\n\tstruct srpt_device *sdev;\n\tstruct srpt_rdma_ch *ch;\n\tstruct srpt_send_ioctx *target;\n\tint ret, i;\n\tret = -EINVAL;\n\tch = ioctx->ch;\n\tBUG_ON(!ch);\n\tBUG_ON(!ch->sport);\n\tsdev = ch->sport->sdev;\n\tBUG_ON(!sdev);\n\tspin_lock_irq(&sdev->spinlock);\n\tfor (i = 0; i < ch->rq_size; ++i) {\n\t\ttarget = ch->ioctx_ring[i];\n\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n\t\t    target->cmd.tag == tag &&\n\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&sdev->spinlock);\n\treturn ret;\n}", "target": 1}
{"code": "static __init int vdso_do_find_sections(struct lib32_elfinfo *v32,\n\t\t\t\t\tstruct lib64_elfinfo *v64)\n{\n\tvoid *sect;\n\tv32->dynsym = find_section32(v32->hdr, \".dynsym\", &v32->dynsymsize);\n\tv32->dynstr = find_section32(v32->hdr, \".dynstr\", NULL);\n\tif (v32->dynsym == NULL || v32->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section32(v32->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv32->text = sect - vdso32_kbase;\n#ifdef CONFIG_PPC64\n\tv64->dynsym = find_section64(v64->hdr, \".dynsym\", &v64->dynsymsize);\n\tv64->dynstr = find_section64(v64->hdr, \".dynstr\", NULL);\n\tif (v64->dynsym == NULL || v64->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section64(v64->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv64->text = sect - vdso64_kbase;\n#endif \n\treturn 0;\n}", "target": 0}
{"code": "static int em_bsf(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 zf;\n\t__asm__ (\"bsf %2, %0; setz %1\"\n\t\t : \"=r\"(ctxt->dst.val), \"=q\"(zf)\n\t\t : \"r\"(ctxt->src.val));\n\tctxt->eflags &= ~X86_EFLAGS_ZF;\n\tif (zf) {\n\t\tctxt->eflags |= X86_EFLAGS_ZF;\n\t\tctxt->dst.type = OP_NONE;\n\t}\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "dodynamic(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap)\n{\n\tElf32_Dyn dh32;\n\tElf64_Dyn dh64;\n\tunsigned char *dbuf = CAST(unsigned char *, vbuf);\n\tif (xdh_sizeof + offset > size) {\n\t\treturn xdh_sizeof + offset;\n\t}\n\tmemcpy(xdh_addr, &dbuf[offset], xdh_sizeof);\n\toffset += xdh_sizeof;\n\tswitch (xdh_tag) {\n\tcase DT_FLAGS_1:\n\t\tif (xdh_val & DF_1_PIE)\n\t\t\tms->mode |= 0111;\n\t\telse\n\t\t\tms->mode &= ~0111;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset;\n}", "target": 0}
{"code": "pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)\n{\n\tInitializeCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "void WebGraphicsContext3DDefaultImpl::activeTexture(unsigned long texture)\n{\n    if (texture < GL_TEXTURE0 || texture > GL_TEXTURE0+32)\n        return;\n    makeContextCurrent();\n    glActiveTexture(texture);\n}", "target": 0}
{"code": "static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\treturn cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);\n}", "target": 1}
{"code": "bool GLSurfaceOzoneSurfacelessSurfaceImpl::OnMakeCurrent(GLContext* context) {\n  DCHECK(!context_ || context == context_);\n  context_ = context;\n  if (!fbo_) {\n    glGenFramebuffersEXT(1, &fbo_);\n    if (!fbo_)\n      return false;\n    glGenTextures(arraysize(textures_), textures_);\n    if (!CreatePixmaps())\n      return false;\n  }\n  BindFramebuffer();\n  glBindFramebufferEXT(GL_FRAMEBUFFER, fbo_);\n  return SurfacelessEGL::OnMakeCurrent(context);\n}", "target": 0}
{"code": "void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t\tsas_discover_event(dev->port, DISCE_DESTRUCT);\n\t}\n}", "target": 1}
{"code": "static void hci_sock_cmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct sk_buff *skb)\n{\n\t__u32 mask = hci_pi(sk)->cmsg_mask;\n\tif (mask & HCI_CMSG_DIR) {\n\t\tint incoming = bt_cb(skb)->incoming;\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_DIR, sizeof(incoming),\n\t\t\t &incoming);\n\t}\n\tif (mask & HCI_CMSG_TSTAMP) {\n#ifdef CONFIG_COMPAT\n\t\tstruct compat_timeval ctv;\n#endif\n\t\tstruct timeval tv;\n\t\tvoid *data;\n\t\tint len;\n\t\tskb_get_timestamp(skb, &tv);\n\t\tdata = &tv;\n\t\tlen = sizeof(tv);\n#ifdef CONFIG_COMPAT\n\t\tif (!COMPAT_USE_64BIT_TIME &&\n\t\t    (msg->msg_flags & MSG_CMSG_COMPAT)) {\n\t\t\tctv.tv_sec = tv.tv_sec;\n\t\t\tctv.tv_usec = tv.tv_usec;\n\t\t\tdata = &ctv;\n\t\t\tlen = sizeof(ctv);\n\t\t}\n#endif\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_TSTAMP, len, data);\n\t}\n}", "target": 0}
{"code": "static int16_t findOffset(const char* const* list, const char* key)\n{\n\tconst char* const* anchor = list;\n\twhile (*list != NULL) {\n\t\tif (strcmp(key, *list) == 0) {\n\t\t\treturn (int16_t)(list - anchor);\n\t\t}\n\t\tlist++;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "void OfflineAudioDestinationHandler::PrepareTaskRunnerForRendering() {\n  DCHECK(IsMainThread());\n  AudioWorklet* audio_worklet = Context()->audioWorklet();\n  if (audio_worklet && audio_worklet->IsReady()) {\n    if (!render_thread_) {\n      if (!render_thread_task_runner_) {\n        render_thread_task_runner_ =\n            audio_worklet->GetMessagingProxy()->GetBackingWorkerThread()\n                         ->GetTaskRunner(TaskType::kMiscPlatformAPI);\n      }\n    } else {\n      render_thread_ = nullptr;\n      render_thread_task_runner_ =\n          audio_worklet->GetMessagingProxy()->GetBackingWorkerThread()\n                       ->GetTaskRunner(TaskType::kMiscPlatformAPI);\n    }\n  } else {\n    if (!render_thread_) {\n      render_thread_ = Platform::Current()->CreateThread(\n          ThreadCreationParams(WebThreadType::kOfflineAudioRenderThread));\n      render_thread_task_runner_ = render_thread_->GetTaskRunner();\n    }\n  }\n  DCHECK(render_thread_task_runner_);\n}", "target": 0}
{"code": "int ssh_scp_init(ssh_scp scp)\n{\n    int rc;\n    char execbuffer[1024] = {0};\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->state != SSH_SCP_NEW) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"ssh_scp_init called under invalid state\");\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PROTOCOL,\n            \"Initializing scp session %s %son location '%s'\",\n            scp->mode == SSH_SCP_WRITE?\"write\":\"read\",\n            scp->recursive?\"recursive \":\"\",\n            scp->location);\n    scp->channel = ssh_channel_new(scp->session);\n    if (scp->channel == NULL) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    rc = ssh_channel_open_session(scp->channel);\n    if (rc == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -t %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    } else {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -f %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    }\n    if (ssh_channel_request_exec(scp->channel, execbuffer) == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        rc = ssh_scp_response(scp, NULL);\n        if (rc != 0) {\n            return SSH_ERROR;\n        }\n    } else {\n        ssh_channel_write(scp->channel, \"\", 1);\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        scp->state = SSH_SCP_WRITE_INITED;\n    } else {\n        scp->state = SSH_SCP_READ_INITED;\n    }\n    return SSH_OK;\n}", "target": 1}
{"code": "static int sctp_bindx_rem(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tint cnt;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tunion sctp_addr *sa_addr;\n\tstruct sctp_af *af;\n\tSCTP_DEBUG_PRINTK(\"sctp_bindx_rem (sk: %p, addrs: %p, addrcnt: %d)\\n\",\n\t\t\t  sk, addrs, addrcnt);\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\tif (list_empty(&bp->address_list) ||\n\t\t    (sctp_list_single_entry(&bp->address_list))) {\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tsa_addr = (union sctp_addr *)addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa.sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tif (!af->addr_valid(sa_addr, sp, NULL)) {\n\t\t\tretval = -EADDRNOTAVAIL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tif (sa_addr->v4.sin_port != htons(bp->port)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tretval = sctp_del_bind_addr(bp, sa_addr);\n\t\taddr_buf += af->sockaddr_len;\nerr_bindx_rem:\n\t\tif (retval < 0) {\n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_add(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n    const Tensor* sep_t;\n    OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));\n    const tstring separator = sep_t->scalar<tstring>()();\n    std::vector<std::unique_ptr<ColumnInterface<tstring>>> columns =\n        GenerateColumnsFromInput<tstring>(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    StringCrosser<tstring> crosser(columns, 0, 0, separator);\n    OutputUpdater<tstring> updater(output_start_indices, indices_out,\n                                   values_out);\n    auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<tstring> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageGifCtx(im, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "static int nsim_bpf_verifier_prep(struct bpf_prog *prog)\n{\n\tstruct nsim_dev *nsim_dev =\n\t\t\tbpf_offload_dev_priv(prog->aux->offload->offdev);\n\tif (!nsim_dev->bpf_bind_accept)\n\t\treturn -EOPNOTSUPP;\n\treturn nsim_bpf_create_prog(nsim_dev, prog);\n}", "target": 0}
{"code": "EnableLimitedSchedulingLatency(void)\n{\n    ++SmartScheduleLatencyLimited;\n    SmartScheduleSlice = SmartScheduleInterval;\n}", "target": 0}
{"code": "void closeFile(PlatformFileHandle& handle)\n{\n    if (isHandleValid(handle)) {\n        ::CloseHandle(handle);\n        handle = invalidPlatformFileHandle;\n    }\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MergeSort) {\n    addIndex(BSON(\"a\" << 1 << \"c\" << 1));\n    addIndex(BSON(\"b\" << 1 << \"c\" << 1));\n    runQuerySortProj(fromjson(\"{$or: [{a:1}, {b:1}]}\"), fromjson(\"{c:1}\"), BSONObj());\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {c: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {dir: 1}}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {a: 1, c: 1}}}, {ixscan: {pattern: {b: 1, c: 1}}}]}}}}\");\n}", "target": 0}
{"code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                if (cid <= 0)\n                    continue;\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}", "target": 1}
{"code": "bool bnx2x_port_after_undi(struct bnx2x *bp)\n{\n\tstruct bnx2x_prev_path_list *entry;\n\tbool val;\n\tdown(&bnx2x_prev_sem);\n\tentry = bnx2x_prev_path_get_entry(bp);\n\tval = !!(entry && (entry->undi & (1 << BP_PORT(bp))));\n\tup(&bnx2x_prev_sem);\n\treturn val;\n}", "target": 0}
{"code": "static void nvme_aio_err(NvmeRequest *req, int ret)\n{\n    uint16_t status = NVME_SUCCESS;\n    Error *local_err = NULL;\n    switch (req->cmd.opcode) {\n    case NVME_CMD_READ:\n        status = NVME_UNRECOVERED_READ;\n        break;\n    case NVME_CMD_FLUSH:\n    case NVME_CMD_WRITE:\n    case NVME_CMD_WRITE_ZEROES:\n    case NVME_CMD_ZONE_APPEND:\n        status = NVME_WRITE_FAULT;\n        break;\n    default:\n        status = NVME_INTERNAL_DEV_ERROR;\n        break;\n    }\n    trace_pci_nvme_err_aio(nvme_cid(req), strerror(-ret), status);\n    error_setg_errno(&local_err, -ret, \"aio failed\");\n    error_report_err(local_err);\n    if (req->status && status != NVME_INTERNAL_DEV_ERROR) {\n        return;\n    }\n    req->status = status;\n}", "target": 0}
{"code": "storageStateInitialize(bool privileged,\n                       const char *root,\n                       virStateInhibitCallback callback G_GNUC_UNUSED,\n                       void *opaque G_GNUC_UNUSED)\n{\n    g_autofree char *configdir = NULL;\n    g_autofree char *rundir = NULL;\n    bool autostart = true;\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n    driver = g_new0(virStorageDriverState, 1);\n    driver->lockFD = -1;\n    if (virMutexInit(&driver->lock) < 0) {\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n    storageDriverLock();\n    if (!(driver->pools = virStoragePoolObjListNew()))\n        goto error;\n    if (privileged) {\n        driver->configDir = g_strdup(SYSCONFDIR \"/libvirt/storage\");\n        driver->autostartDir = g_strdup(SYSCONFDIR \"/libvirt/storage/autostart\");\n        driver->stateDir = g_strdup(RUNSTATEDIR \"/libvirt/storage\");\n    } else {\n        configdir = virGetUserConfigDirectory();\n        rundir = virGetUserRuntimeDirectory();\n        driver->configDir = g_strdup_printf(\"%s/storage\", configdir);\n        driver->autostartDir = g_strdup_printf(\"%s/storage/autostart\", configdir);\n        driver->stateDir = g_strdup_printf(\"%s/storage/run\", rundir);\n    }\n    driver->privileged = privileged;\n    if (g_mkdir_with_parents(driver->stateDir, 0777) < 0) {\n        virReportError(errno,\n                       _(\"cannot create directory %s\"),\n                       driver->stateDir);\n        goto error;\n    }\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\",\n                           false, getpid())) < 0)\n        goto error;\n    if (virStoragePoolObjLoadAllState(driver->pools,\n                                      driver->stateDir) < 0)\n        goto error;\n    if (virStoragePoolObjLoadAllConfigs(driver->pools,\n                                        driver->configDir,\n                                        driver->autostartDir) < 0)\n        goto error;\n    storagePoolUpdateAllState();\n    if (virDriverShouldAutostart(driver->stateDir, &autostart) < 0)\n        goto error;\n    if (autostart)\n        storageDriverAutostart();\n    driver->storageEventState = virObjectEventStateNew();\n    if (!(driver->caps = virStorageBackendGetCapabilities()))\n        goto error;\n    storageDriverUnlock();\n    return VIR_DRV_STATE_INIT_COMPLETE;\n error:\n    storageDriverUnlock();\n    storageStateCleanup();\n    return VIR_DRV_STATE_INIT_ERROR;\n}", "target": 0}
{"code": "int ossl_dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret)\n{\n    *ret = 0;\n    return (dsa->params.q != NULL\n            && ossl_ffc_validate_private_key(dsa->params.q, priv_key, ret));\n}", "target": 1}
{"code": "setContext(XML_Parser parser, const XML_Char *context) {\n  DTD *const dtd = parser->m_dtd; \n  const XML_Char *s = context;\n  while (*context != XML_T('\\0')) {\n    if (*s == CONTEXT_SEP || *s == XML_T('\\0')) {\n      ENTITY *e;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      e = (ENTITY *)lookup(parser, &dtd->generalEntities,\n                           poolStart(&parser->m_tempPool), 0);\n      if (e)\n        e->open = XML_TRUE;\n      if (*s != XML_T('\\0'))\n        s++;\n      context = s;\n      poolDiscard(&parser->m_tempPool);\n    } else if (*s == XML_T(ASCII_EQUALS)) {\n      PREFIX *prefix;\n      if (poolLength(&parser->m_tempPool) == 0)\n        prefix = &dtd->defaultPrefix;\n      else {\n        if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n          return XML_FALSE;\n        prefix\n            = (PREFIX *)lookup(parser, &dtd->prefixes,\n                               poolStart(&parser->m_tempPool), sizeof(PREFIX));\n        if (! prefix)\n          return XML_FALSE;\n        if (prefix->name == poolStart(&parser->m_tempPool)) {\n          prefix->name = poolCopyString(&dtd->pool, prefix->name);\n          if (! prefix->name)\n            return XML_FALSE;\n        }\n        poolDiscard(&parser->m_tempPool);\n      }\n      for (context = s + 1; *context != CONTEXT_SEP && *context != XML_T('\\0');\n           context++)\n        if (! poolAppendChar(&parser->m_tempPool, *context))\n          return XML_FALSE;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      if (addBinding(parser, prefix, NULL, poolStart(&parser->m_tempPool),\n                     &parser->m_inheritedBindings)\n          != XML_ERROR_NONE)\n        return XML_FALSE;\n      poolDiscard(&parser->m_tempPool);\n      if (*context != XML_T('\\0'))\n        ++context;\n      s = context;\n    } else {\n      if (! poolAppendChar(&parser->m_tempPool, *s))\n        return XML_FALSE;\n      s++;\n    }\n  }\n  return XML_TRUE;\n}", "target": 0}
{"code": "static Image *RenderHoughLines(const ImageInfo *image_info,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n#define BoundingBox  \"viewbox\"\n  DrawInfo\n    *draw_info;\n  Image\n    *image;\n  MagickBooleanType\n    status;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->columns=columns;\n  image->rows=rows;\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->affine.sx=image->resolution.x == 0.0 ? 1.0 : image->resolution.x/\n    DefaultResolution;\n  draw_info->affine.sy=image->resolution.y == 0.0 ? 1.0 : image->resolution.y/\n    DefaultResolution;\n  image->columns=(size_t) (draw_info->affine.sx*image->columns);\n  image->rows=(size_t) (draw_info->affine.sy*image->rows);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (GetBlobStreamData(image) == (unsigned char *) NULL)\n    draw_info->primitive=FileToString(image->filename,~0UL,exception);\n  else\n    {\n      draw_info->primitive=(char *) AcquireMagickMemory((size_t)\n        GetBlobSize(image)+1);\n      if (draw_info->primitive != (char *) NULL)\n        {\n          (void) memcpy(draw_info->primitive,GetBlobStreamData(image),\n            (size_t) GetBlobSize(image));\n          draw_info->primitive[GetBlobSize(image)]='\\0';\n        }\n     }\n  (void) DrawImage(image,draw_info,exception);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 0}
{"code": "static int result(void)\n{\n\tint i;\n\tint status = 0;\n\tfor (i = 0; i < MAX_REPLIES; i++) {\n\t\tstatus = wait_til_ready();\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\n\t\tif ((status & ~STATUS_BUSY) == STATUS_READY) {\n\t\t\tresultjiffies = jiffies;\n\t\t\tresultsize = i;\n\t\t\treturn i;\n\t\t}\n\t\tif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\n\t\t\treply_buffer[i] = fd_inb(FD_DATA);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",\n\t\t       fdc, status, i);\n\t\tshow_floppy();\n\t}\n\tFDCS->reset = 1;\n\treturn -1;\n}", "target": 0}
{"code": "bool HeaderToMetadataFilter::addMetadata(StructMap& map, const std::string& meta_namespace,\n                                         const std::string& key, std::string value, ValueType type,\n                                         ValueEncode encode) const {\n  ProtobufWkt::Value val;\n  ASSERT(!value.empty());\n  if (value.size() >= MAX_HEADER_VALUE_LEN) {\n    ENVOY_LOG(debug, \"metadata value is too long\");\n    return false;\n  }\n  if (encode == envoy::extensions::filters::http::header_to_metadata::v3::Config::BASE64) {\n    value = Base64::decodeWithoutPadding(value);\n    if (value.empty()) {\n      ENVOY_LOG(debug, \"Base64 decode failed\");\n      return false;\n    }\n  }\n  switch (type) {\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::STRING:\n    val.set_string_value(std::move(value));\n    break;\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::NUMBER: {\n    double dval;\n    if (absl::SimpleAtod(StringUtil::trim(value), &dval)) {\n      val.set_number_value(dval);\n    } else {\n      ENVOY_LOG(debug, \"value to number conversion failed\");\n      return false;\n    }\n    break;\n  }\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::PROTOBUF_VALUE: {\n    if (!val.ParseFromString(value)) {\n      ENVOY_LOG(debug, \"parse from decoded string failed\");\n      return false;\n    }\n    break;\n  }\n  default:\n    NOT_REACHED_GCOVR_EXCL_LINE;\n  }\n  auto namespace_iter = map.find(meta_namespace);\n  if (namespace_iter == map.end()) {\n    map[meta_namespace] = ProtobufWkt::Struct();\n    namespace_iter = map.find(meta_namespace);\n  }\n  auto& keyval = namespace_iter->second;\n  (*keyval.mutable_fields())[key] = val;\n  return true;\n}", "target": 0}
{"code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);", "target": 1}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "bool WebContentsImpl::ShouldAssignSiteForURL(const GURL& url) {\n  if (url == GURL(kAboutBlankURL))\n    return false;\n  return GetContentClient()->browser()->ShouldAssignSiteForURL(url);\n}", "target": 0}
{"code": "static int check_cert(X509_STORE_CTX *ctx)\n{\n    X509_CRL *crl = NULL, *dcrl = NULL;\n    X509 *x = NULL;\n    int ok = 0, cnum = 0;\n    unsigned int last_reasons = 0;\n    cnum = ctx->error_depth;\n    x = sk_X509_value(ctx->chain, cnum);\n    ctx->current_cert = x;\n    ctx->current_issuer = NULL;\n    ctx->current_crl_score = 0;\n    ctx->current_reasons = 0;\n    while (ctx->current_reasons != CRLDP_ALL_REASONS) {\n        last_reasons = ctx->current_reasons;\n        if (ctx->get_crl)\n            ok = ctx->get_crl(ctx, &crl, x);\n        else\n            ok = get_crl_delta(ctx, &crl, &dcrl, x);\n        if (!ok) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n        ctx->current_crl = crl;\n        ok = ctx->check_crl(ctx, crl);\n        if (!ok)\n            goto err;\n        if (dcrl) {\n            ok = ctx->check_crl(ctx, dcrl);\n            if (!ok)\n                goto err;\n            ok = ctx->cert_crl(ctx, dcrl, x);\n            if (!ok)\n                goto err;\n        } else\n            ok = 1;\n        if (ok != 2) {\n            ok = ctx->cert_crl(ctx, crl, x);\n            if (!ok)\n                goto err;\n        }\n        X509_CRL_free(crl);\n        X509_CRL_free(dcrl);\n        crl = NULL;\n        dcrl = NULL;\n        if (last_reasons == ctx->current_reasons) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n    }\n err:\n    X509_CRL_free(crl);\n    X509_CRL_free(dcrl);\n    ctx->current_crl = NULL;\n    return ok;\n}", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 p_total_data_size,\n                                  OPJ_UINT32 * p_data_written,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n    if (p_total_data_size < 12) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOT marker\\n\");\n        return OPJ_FALSE;\n    }\n    opj_write_bytes(p_data, J2K_MS_SOT,\n                    2);                                 \n    p_data += 2;\n    opj_write_bytes(p_data, 10,\n                    2);                                                   \n    p_data += 2;\n    opj_write_bytes(p_data, p_j2k->m_current_tile_number,\n                    2);                        \n    p_data += 2;\n    p_data += 4;\n    opj_write_bytes(p_data,\n                    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,\n                    1);                        \n    ++p_data;\n    opj_write_bytes(p_data,\n                    p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,\n                    1);                      \n    ++p_data;\n#ifdef USE_JPWL\n    assert(0 && \"TODO\");\n#endif \n    * p_data_written = 12;\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "unsigned long kvm_vcpu_gfn_to_hva(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn gfn_to_hva_many(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn, NULL);\n}", "target": 0}
{"code": "static int cens_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret, rem_bytes;\n    uint8_t *data;\n    if (!sc->cenc.aes_ctr) {\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n    if (!sample->subsample_count) {\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    } else if (!sample->crypt_byte_block && !sample->skip_byte_block) {\n        av_log(c->fc, AV_LOG_ERROR, \"pattern encryption is not present in 'cens' scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n        data = input;\n        rem_bytes = sample->subsamples[i].bytes_of_protected_data;\n        while (rem_bytes > 0) {\n            if (rem_bytes < 16*sample->crypt_byte_block) {\n                break;\n            }\n            av_aes_ctr_crypt(sc->cenc.aes_ctr, data, data, 16*sample->crypt_byte_block);\n            data += 16*sample->crypt_byte_block;\n            rem_bytes -= 16*sample->crypt_byte_block;\n            data += FFMIN(16*sample->skip_byte_block, rem_bytes);\n            rem_bytes -= FFMIN(16*sample->skip_byte_block, rem_bytes);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"code": "static int vhost_worker(void *data)\n{\n\tstruct vhost_dev *dev = data;\n\tstruct vhost_work *work = NULL;\n\tunsigned uninitialized_var(seq);\n\tmm_segment_t oldfs = get_fs();\n\tset_fs(USER_DS);\n\tuse_mm(dev->mm);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock_irq(&dev->work_lock);\n\t\tif (work) {\n\t\t\twork->done_seq = seq;\n\t\t\tif (work->flushing)\n\t\t\t\twake_up_all(&work->done);\n\t\t}\n\t\tif (kthread_should_stop()) {\n\t\t\tspin_unlock_irq(&dev->work_lock);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tif (!list_empty(&dev->work_list)) {\n\t\t\twork = list_first_entry(&dev->work_list,\n\t\t\t\t\t\tstruct vhost_work, node);\n\t\t\tlist_del_init(&work->node);\n\t\t\tseq = work->queue_seq;\n\t\t} else\n\t\t\twork = NULL;\n\t\tspin_unlock_irq(&dev->work_lock);\n\t\tif (work) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\twork->fn(work);\n\t\t\tif (need_resched())\n\t\t\t\tschedule();\n\t\t} else\n\t\t\tschedule();\n\t}\n\tunuse_mm(dev->mm);\n\tset_fs(oldfs);\n\treturn 0;\n}", "target": 0}
{"code": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(rng);\n\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n\tif (oalg->rng_make_random) {\n\t\trng->generate = generate;\n\t\trng->seed = rngapi_reset;\n\t\trng->seedsize = oalg->seedsize;\n\t\treturn 0;\n\t}\n\trng->generate = alg->generate;\n\trng->seed = alg->seed;\n\trng->seedsize = alg->seedsize;\n\treturn 0;\n}", "target": 1}
{"code": "static struct nfs4_ff_layout_mirror *ff_layout_alloc_mirror(gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tmirror = kzalloc(sizeof(*mirror), gfp_flags);\n\tif (mirror != NULL) {\n\t\tspin_lock_init(&mirror->lock);\n\t\trefcount_set(&mirror->ref, 1);\n\t\tINIT_LIST_HEAD(&mirror->mirrors);\n\t}\n\treturn mirror;\n}", "target": 0}
{"code": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n\t};\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}", "target": 1}
{"code": "    **/\n    bool operator==(const char *const expression) const {\n      return *this==(+*this)._fill(expression,true,true,0,0,\"operator==\",this);", "target": 0}
{"code": "can_prompt_again(secuPWData *pwdata)\n{\n\tif (pwdata->orig_source == PW_PROMPT)\n\t\treturn true;\n\tif (pwdata->source == PW_DEVICE)\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "static int __init personal_server_map_irq(const struct pci_dev *dev, u8 slot,\n\tu8 pin)\n{\n\tunsigned char line;\n\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, &line);\n\tif (line > 0x40 && line <= 0x5f) {\n\t\treturn irqmap_personal_server[(line & 0x1f) - 8];\n\t} else if (line == 0) {\n\t\treturn 0;\n\t} else\n\t\treturn irqmap_personal_server[(line - 1) & 3];\n}", "target": 1}
{"code": "PHP_MINIT_FUNCTION(spl_heap) \n{\n\tREGISTER_SPL_STD_CLASS_EX(SplHeap, spl_heap_object_new, spl_funcs_SplHeap);\n\tmemcpy(&spl_handler_SplHeap, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tspl_handler_SplHeap.clone_obj      = spl_heap_object_clone;\n\tspl_handler_SplHeap.count_elements = spl_heap_object_count_elements;\n\tspl_handler_SplHeap.get_debug_info = spl_heap_object_get_debug_info;\n\tREGISTER_SPL_IMPLEMENTS(SplHeap, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(SplHeap, Countable);\n\tspl_ce_SplHeap->get_iterator = spl_heap_get_iterator;\n\tREGISTER_SPL_SUB_CLASS_EX(SplMinHeap,           SplHeap,        spl_heap_object_new, spl_funcs_SplMinHeap);\n\tREGISTER_SPL_SUB_CLASS_EX(SplMaxHeap,           SplHeap,        spl_heap_object_new, spl_funcs_SplMaxHeap);\n\tspl_ce_SplMaxHeap->get_iterator = spl_heap_get_iterator;\n\tspl_ce_SplMinHeap->get_iterator = spl_heap_get_iterator;\n\tREGISTER_SPL_STD_CLASS_EX(SplPriorityQueue, spl_heap_object_new, spl_funcs_SplPriorityQueue);\n\tmemcpy(&spl_handler_SplPriorityQueue, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tspl_handler_SplPriorityQueue.clone_obj      = spl_heap_object_clone;\n\tspl_handler_SplPriorityQueue.count_elements = spl_heap_object_count_elements;\n\tspl_handler_SplPriorityQueue.get_debug_info = spl_pqueue_object_get_debug_info;\n\tREGISTER_SPL_IMPLEMENTS(SplPriorityQueue, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(SplPriorityQueue, Countable);\n\tspl_ce_SplPriorityQueue->get_iterator = spl_pqueue_get_iterator;\n\tREGISTER_SPL_CLASS_CONST_LONG(SplPriorityQueue, \"EXTR_BOTH\",      SPL_PQUEUE_EXTR_BOTH);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplPriorityQueue, \"EXTR_PRIORITY\",  SPL_PQUEUE_EXTR_PRIORITY);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplPriorityQueue, \"EXTR_DATA\",      SPL_PQUEUE_EXTR_DATA);\n\treturn SUCCESS;\n}", "target": 0}
{"code": "int sc_path_set(sc_path_t *path, int type, const u8 *id, size_t id_len,\n\tint idx, int count)\n{\n\tif (path == NULL || id == NULL || id_len == 0 || id_len > SC_MAX_PATH_SIZE)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemset(path, 0, sizeof(*path));\n\tmemcpy(path->value, id, id_len);\n\tpath->len   = id_len;\n\tpath->type  = type;\n\tpath->index = idx;\n\tpath->count = count;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "void HTMLInputElement::listAttributeTargetChanged()\n{\n    m_inputTypeView->listAttributeTargetChanged();\n}", "target": 0}
{"code": "static inline void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}", "target": 0}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n    authResult = rfbClientSwap32IfLE(authResult);\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "target": 1}
{"code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n\tint offset, upb;\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\treturn;\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n}", "target": 1}
{"code": "static void mark_object(struct object *obj, struct strbuf *path,\n\t\t\tconst char *name, void *data)\n{\n\tupdate_progress(data);\n}", "target": 1}
{"code": "static char* getPreferredTag(const char* gf_tag)\n{ \n\tchar* result = NULL;\n\tint grOffset = 0;\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "int GfxUnivariateShading::getColor(double t, GfxColor *color)\n{\n    double out[gfxColorMaxComps];\n    int nComps;\n    if (likely(getNFuncs() >= 1)) {\n        nComps = getNFuncs() * funcs[0]->getOutputSize();\n    }\n    if (unlikely(getNFuncs() < 1 || nComps > gfxColorMaxComps)) {\n        clearGfxColor(color);\n        return gfxColorMaxComps;\n    }\n    if (cacheSize > 0) {\n        double x, ix, *l, *u, *upper;\n        if (cacheBounds[lastMatch - 1] >= t) {\n            upper = std::lower_bound(cacheBounds, cacheBounds + lastMatch - 1, t);\n            lastMatch = upper - cacheBounds;\n            lastMatch = std::min<int>(std::max<int>(1, lastMatch), cacheSize - 1);\n        } else if (cacheBounds[lastMatch] < t) {\n            upper = std::lower_bound(cacheBounds + lastMatch + 1, cacheBounds + cacheSize, t);\n            lastMatch = upper - cacheBounds;\n            lastMatch = std::min<int>(std::max<int>(1, lastMatch), cacheSize - 1);\n        }\n        x = (t - cacheBounds[lastMatch - 1]) * cacheCoeff[lastMatch];\n        ix = 1.0 - x;\n        u = cacheValues + lastMatch * nComps;\n        l = u - nComps;\n        for (int i = 0; i < nComps; ++i) {\n            out[i] = ix * l[i] + x * u[i];\n        }\n    } else {\n        for (int i = 0; i < nComps; ++i) {\n            out[i] = 0;\n        }\n        for (int i = 0; i < getNFuncs(); ++i) {\n            if (funcs[i]->getInputSize() != 1) {\n                error(errSyntaxWarning, -1, \"Invalid shading function (input != 1)\");\n                break;\n            }\n            funcs[i]->transform(&t, &out[i]);\n        }\n    }\n    for (int i = 0; i < nComps; ++i) {\n        color->c[i] = dblToCol(out[i]);\n    }\n    return nComps;\n}", "target": 0}
{"code": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!start)\n\t\treturn true;\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static int multipart_buffer_headers(multipart_buffer *self, zend_llist *header TSRMLS_DC)\n{\n\tchar *line;\n\tmime_header_entry prev_entry = {0}, entry;\n\tint prev_len, cur_len;\n\tif (!find_boundary(self, self->boundary TSRMLS_CC)) {\n\t\treturn 0;\n\t}\n\twhile( (line = get_line(self TSRMLS_CC)) && strlen(line) > 0 )\n\t{\n\t\tchar *key = line;\n\t\tchar *value = NULL;\n\t\tif (php_rfc1867_encoding_translation(TSRMLS_C)) {\n\t\t\tself->input_encoding = zend_multibyte_encoding_detector(line, strlen(line), self->detect_order, self->detect_order_size TSRMLS_CC);\n\t\t}\n\t\tif (!isspace(line[0])) {\n\t\t\tvalue = strchr(line, ':');\n\t\t}\n\t\tif (value) {\n\t\t\t*value = 0;\n\t\t\tdo { value++; } while(isspace(*value));\n\t\t\tentry.value = estrdup(value);\n\t\t\tentry.key = estrdup(key);\n\t\t} else if (zend_llist_count(header)) { \n\t\t\tprev_len = strlen(prev_entry.value);\n\t\t\tcur_len = strlen(line);\n\t\t\tentry.value = emalloc(prev_len + cur_len + 1);\n\t\t\tmemcpy(entry.value, prev_entry.value, prev_len);\n\t\t\tmemcpy(entry.value + prev_len, line, cur_len);\n\t\t\tentry.value[cur_len + prev_len] = '\\0';\n\t\t\tentry.key = estrdup(prev_entry.key);\n\t\t\tzend_llist_remove_tail(header);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tzend_llist_add_element(header, &entry);\n\t\tprev_entry = entry;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "    OVS_REQUIRES(ofproto_mutex)\n{\n    const struct rule_actions *actions = rule_get_actions(rule);\n    ovs_assert(rule->state == RULE_INITIALIZED);\n    if (rule->hard_timeout || rule->idle_timeout) {\n        ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n    rule->state = RULE_INSERTED;\n}", "target": 1}
{"code": "static void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n#ifdef CONFIG_SMP\n\tfree_percpu(s->s_files);\n#endif\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}", "target": 1}
{"code": "int set_binfmt(struct linux_binfmt *new)\n{\n\tstruct linux_binfmt *old = current->binfmt;\n\tif (new) {\n\t\tif (!try_module_get(new->module))\n\t\t\treturn -1;\n\t}\n\tcurrent->binfmt = new;\n\tif (old)\n\t\tmodule_put(old->module);\n\treturn 0;\n}", "target": 0}
{"code": "void GfxSeparationColorSpace::getDeviceN(const GfxColor *color, GfxColor *deviceN) const\n{\n    clearGfxColor(deviceN);\n    if (mapping == nullptr || mapping[0] == -1) {\n        GfxCMYK cmyk;\n        getCMYK(color, &cmyk);\n        deviceN->c[0] = cmyk.c;\n        deviceN->c[1] = cmyk.m;\n        deviceN->c[2] = cmyk.y;\n        deviceN->c[3] = cmyk.k;\n    } else {\n        deviceN->c[mapping[0]] = color->c[0];\n    }\n}", "target": 0}
{"code": "bgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)\n{\n  if ((afi == AFI_IP6 && *safi == BGP_SAFI_VPNV4)\n      || (afi == AFI_IP && *safi == BGP_SAFI_VPNV6))\n    {\n      zlog_warn (\"Invalid afi/safi combination (%u/%u)\", afi, *safi);\n      return 0;\n    }\n  switch (afi)\n    {\n      case AFI_IP:\n#ifdef HAVE_IPV6\n      case AFI_IP6:\n#endif\n        switch (*safi)\n          {\n            case BGP_SAFI_VPNV4:\n            case BGP_SAFI_VPNV6:\n              *safi = SAFI_MPLS_VPN;\n            case SAFI_UNICAST:\n            case SAFI_MULTICAST:\n            case SAFI_MPLS_VPN:\n              return 1;\n          }\n    }\n  zlog_debug (\"unknown afi/safi (%u/%u)\", afi, *safi);\n  return 0;\n}", "target": 0}
{"code": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\tdelete[] audioDriverName;\n\tdelete listener;\n}", "target": 1}
{"code": "LogData::LogData()\n    : routing_id(0),\n      type(0),\n      sent(0),\n      receive(0),\n      dispatch(0) {\n}", "target": 0}
{"code": "static void do_free_publickey(struct rsa_public_key *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n}", "target": 1}
{"code": "read_data_stored(struct archive_read *a, const void **buff, size_t *size,\n                 int64_t *offset)\n{\n  struct rar *rar;\n  ssize_t bytes_avail;\n  rar = (struct rar *)(a->format->data);\n  if (rar->bytes_remaining == 0 &&\n    !(rar->main_flags & MHD_VOLUME && rar->file_flags & FHD_SPLIT_AFTER))\n  {\n    *buff = NULL;\n    *size = 0;\n    *offset = rar->offset;\n    if (rar->file_crc != rar->crc_calculated) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"File CRC error\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->entry_eof = 1;\n    return (ARCHIVE_EOF);\n  }\n  *buff = rar_read_ahead(a, 1, &bytes_avail);\n  if (bytes_avail <= 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    return (ARCHIVE_FATAL);\n  }\n  *size = bytes_avail;\n  *offset = rar->offset;\n  rar->offset += bytes_avail;\n  rar->offset_seek += bytes_avail;\n  rar->bytes_remaining -= bytes_avail;\n  rar->bytes_unconsumed = bytes_avail;\n  rar->crc_calculated = crc32(rar->crc_calculated, *buff,\n    (unsigned)bytes_avail);\n  return (ARCHIVE_OK);\n}", "target": 0}
{"code": "static int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *de;\n\tstruct vfsmount *mnt = NULL;\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &de, &mnt);\n\tif (error)\n\t\tgoto out;\n\terror = do_proc_readlink(de, mnt, buffer, buflen);\n\tdput(de);\n\tmntput(mnt);\nout:\n\treturn error;\n}", "target": 0}
{"code": "static bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; \n\tbool result = true;\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; \n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tgoto done;\nunref:\n\tgluster_cache_refresh(fs, path);\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\treturn result;\n}", "target": 1}
{"code": "static inline bool spectre_v2_in_ibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_IBRS ||\n\t       mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 1}
{"code": "static int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = -ENOIOCTLCMD;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\tcase SIOCSARP:\t\t\n\tcase SIOCDARP:\t\t\n\t\trtnl_lock();\n\t\trc = atif_ioctl(cmd, argp);\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "void *address_space_map(AddressSpace *as,\n                        hwaddr addr,\n                        hwaddr *plen,\n                        bool is_write)\n{\n    hwaddr len = *plen;\n    hwaddr done = 0;\n    hwaddr l, xlat, base;\n    MemoryRegion *mr, *this_mr;\n    ram_addr_t raddr;\n    if (len == 0) {\n        return NULL;\n    }\n    l = len;\n    rcu_read_lock();\n    mr = address_space_translate(as, addr, &xlat, &l, is_write);\n    if (!memory_access_is_direct(mr, is_write)) {\n        if (atomic_xchg(&bounce.in_use, true)) {\n            rcu_read_unlock();\n            return NULL;\n        }\n        l = MIN(l, TARGET_PAGE_SIZE);\n        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, l);\n        bounce.addr = addr;\n        bounce.len = l;\n        memory_region_ref(mr);\n        bounce.mr = mr;\n        if (!is_write) {\n            address_space_read(as, addr, MEMTXATTRS_UNSPECIFIED,\n                               bounce.buffer, l);\n        }\n        rcu_read_unlock();\n        *plen = l;\n        return bounce.buffer;\n    }\n    base = xlat;\n    raddr = memory_region_get_ram_addr(mr);\n    for (;;) {\n        len -= l;\n        addr += l;\n        done += l;\n        if (len == 0) {\n            break;\n        }\n        l = len;\n        this_mr = address_space_translate(as, addr, &xlat, &l, is_write);\n        if (this_mr != mr || xlat != base + done) {\n            break;\n        }\n    }\n    memory_region_ref(mr);\n    rcu_read_unlock();\n    *plen = done;\n    return qemu_ram_ptr_length(raddr + base, plen);\n}", "target": 0}
{"code": "static int scrub_extent_for_parity(struct scrub_parity *sparity,\n\t\t\t\t   u64 logical, u64 len,\n\t\t\t\t   u64 physical, struct btrfs_device *dev,\n\t\t\t\t   u64 flags, u64 gen, int mirror_num)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tint ret;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 blocksize;\n\tif (test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state)) {\n\t\tscrub_parity_mark_sectors_error(sparity, logical, len);\n\t\treturn 0;\n\t}\n\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\tblocksize = sparity->stripe_len;\n\t} else if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tblocksize = sparity->stripe_len;\n\t} else {\n\t\tblocksize = sctx->fs_info->sectorsize;\n\t\tWARN_ON(1);\n\t}\n\twhile (len) {\n\t\tu64 l = min_t(u64, len, blocksize);\n\t\tint have_csum = 0;\n\t\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\t\thave_csum = scrub_find_csum(sctx, logical, csum);\n\t\t\tif (have_csum == 0)\n\t\t\t\tgoto skip;\n\t\t}\n\t\tret = scrub_pages_for_parity(sparity, logical, l, physical, dev,\n\t\t\t\t\t     flags, gen, mirror_num,\n\t\t\t\t\t     have_csum ? csum : NULL);\n\t\tif (ret)\n\t\t\treturn ret;\nskip:\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n}", "target": 1}
{"code": "static inline void snow_set_blocks(SnowContext *s, int level, int x, int y, int l, int cb, int cr, int mx, int my, int ref, int type){\n    const int w= s->b_width << s->block_max_depth;\n    const int rem_depth= s->block_max_depth - level;\n    const int index= (x + y*w) << rem_depth;\n    const int block_w= 1<<rem_depth;\n    BlockNode block;\n    int i,j;\n    block.color[0]= l;\n    block.color[1]= cb;\n    block.color[2]= cr;\n    block.mx= mx;\n    block.my= my;\n    block.ref= ref;\n    block.type= type;\n    block.level= level;\n    for(j=0; j<block_w; j++){\n        for(i=0; i<block_w; i++){\n            s->block[index + i + j*w]= block;\n        }\n    }\n}", "target": 0}
{"code": "void vsock_remove_bound(struct vsock_sock *vsk)\n{\n\tspin_lock_bh(&vsock_table_lock);\n\t__vsock_remove_bound(vsk);\n\tspin_unlock_bh(&vsock_table_lock);\n}", "target": 0}
{"code": "static int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs;\n\tstruct inode *inode = page->mapping->host;\n\ttrace_ext4_writepage(inode, page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tif (page_has_buffers(page)) {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tret = block_prepare_write(page, 0, len,\n\t\t\t\t\t  noalloc_get_block_write);\n\t\tif (!ret) {\n\t\t\tpage_bufs = page_buffers(page);\n\t\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tunlock_page(page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tblock_commit_write(page, 0, len);\n\t}\n\tif (PageChecked(page) && ext4_should_journal_data(inode)) {\n\t\tClearPageChecked(page);\n\t\treturn __ext4_journalled_writepage(page, len);\n\t}\n\tif (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))\n\t\tret = nobh_writepage(page, noalloc_get_block_write, wbc);\n\telse\n\t\tret = block_write_full_page(page, noalloc_get_block_write,\n\t\t\t\t\t    wbc);\n\treturn ret;\n}", "target": 1}
{"code": "static int hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\tif (read_cr4() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\tcrash_enable_local_vmclear(cpu);\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\tif ((old & test_bits) != test_bits) {\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\twrite_cr4(read_cr4() | X86_CR4_VMXE); \n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\tnative_store_gdt(this_cpu_ptr(&host_gdt));\n\treturn 0;\n}", "target": 0}
{"code": "int32_t CxImage::GetSize()\n{\n\treturn head.biSize + head.biSizeImage + GetPaletteSize();\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext   *ctx     = inlink->dst;\n    FieldOrderContext *s       = ctx->priv;\n    AVFilterLink      *outlink = ctx->outputs[0];\n    int h, plane, line_step, line_size, line;\n    uint8_t *data;\n    if (!frame->interlaced_frame ||\n        frame->top_field_first == s->dst_tff)\n        return ff_filter_frame(outlink, frame);\n    av_dlog(ctx,\n            \"picture will move %s one line\\n\",\n            s->dst_tff ? \"up\" : \"down\");\n    h = frame->height;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        line_step = frame->linesize[plane];\n        line_size = s->line_size[plane];\n        data = frame->data[plane];\n        if (s->dst_tff) {\n            for (line = 0; line < h; line++) {\n                if (1 + line < frame->height) {\n                    memcpy(data, data + line_step, line_size);\n                } else {\n                    memcpy(data, data - line_step - line_step, line_size);\n                }\n                data += line_step;\n            }\n        } else {\n            data += (h - 1) * line_step;\n            for (line = h - 1; line >= 0 ; line--) {\n                if (line > 0) {\n                    memcpy(data, data - line_step, line_size);\n                } else {\n                    memcpy(data, data + line_step + line_step, line_size);\n                }\n                data -= line_step;\n            }\n        }\n    }\n    frame->top_field_first = s->dst_tff;\n    return ff_filter_frame(outlink, frame);\n}", "target": 1}
{"code": "int ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info;\n\tint i, j, count;\n\tkgid_t low, high;\n\tint ret = 0;\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\tgroup_info = get_current_groups();\n\tcount = group_info->ngroups;\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\tgoto out_release_group;\n\t\t}\n\t\tcount -= cp_count;\n\t}\n\tret = -EACCES;\nout_release_group:\n\tput_group_info(group_info);\n\treturn ret;\n}", "target": 0}
{"code": "unsigned long __ref init_memory_mapping(unsigned long start,\n\t\t\t\t\t       unsigned long end)\n{\n\tstruct map_range mr[NR_RANGE_MR];\n\tunsigned long ret = 0;\n\tint nr_range, i;\n\tpr_debug(\"init_memory_mapping: [mem %#010lx-%#010lx]\\n\",\n\t       start, end - 1);\n\tmemset(mr, 0, sizeof(mr));\n\tnr_range = split_mem_range(mr, 0, start, end);\n\tfor (i = 0; i < nr_range; i++)\n\t\tret = kernel_physical_mapping_init(mr[i].start, mr[i].end,\n\t\t\t\t\t\t   mr[i].page_size_mask);\n\tadd_pfn_range_mapped(start >> PAGE_SHIFT, ret >> PAGE_SHIFT);\n\treturn ret >> PAGE_SHIFT;\n}", "target": 0}
{"code": "DLLEXPORT int DLLCALL tjEncodeYUV3(tjhandle handle,\n\tconst unsigned char *srcBuf, int width, int pitch, int height,\n\tint pixelFormat, unsigned char *dstBuf, int pad, int subsamp, int flags)\n{\n\tunsigned char *dstPlanes[3];\n\tint pw0, ph0, strides[3], retval=-1;\n\tif(width<=0 || height<=0 || dstBuf==NULL || pad<0 || !isPow2(pad)\n\t\t|| subsamp<0 || subsamp>=NUMSUBOPT)\n\t\t_throw(\"tjEncodeYUV3(): Invalid argument\");\n\tpw0=tjPlaneWidth(0, width, subsamp);\n\tph0=tjPlaneHeight(0, height, subsamp);\n\tdstPlanes[0]=dstBuf;\n\tstrides[0]=PAD(pw0, pad);\n\tif(subsamp==TJSAMP_GRAY)\n\t{\n\t\tstrides[1]=strides[2]=0;\n\t\tdstPlanes[1]=dstPlanes[2]=NULL;\n\t}\n\telse\n\t{\n\t\tint pw1=tjPlaneWidth(1, width, subsamp);\n\t\tint ph1=tjPlaneHeight(1, height, subsamp);\n\t\tstrides[1]=strides[2]=PAD(pw1, pad);\n\t\tdstPlanes[1]=dstPlanes[0]+strides[0]*ph0;\n\t\tdstPlanes[2]=dstPlanes[1]+strides[1]*ph1;\n\t}\n\treturn tjEncodeYUVPlanes(handle, srcBuf, width, pitch, height, pixelFormat,\n\t\tdstPlanes, strides, subsamp, flags);\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n    return(1);\n    }", "target": 1}
{"code": "g_opendir(Char *str, glob_t *pglob)\n{\n    char buf[PATH_MAX];\n    if (!*str) {\n        buf[0] = '.';\n        buf[1] = 0;\n    } else {\n        if (g_Ctoc(str, buf, sizeof(buf))) {\n            return NULL;\n        }\n    }\n    if (pglob->gl_flags & GLOB_ALTDIRFUNC) {\n        return (*pglob->gl_opendir)(buf);\n    }\n    return opendir(buf);\n}", "target": 0}
{"code": "__visible void kvm_lock_spinning(struct arch_spinlock *lock, __ticket_t want)\n{\n\tstruct kvm_lock_waiting *w;\n\tint cpu;\n\tu64 start;\n\tunsigned long flags;\n\tif (in_nmi())\n\t\treturn;\n\tw = this_cpu_ptr(&klock_waiting);\n\tcpu = smp_processor_id();\n\tstart = spin_time_start();\n\tlocal_irq_save(flags);\n\tw->lock = NULL;\n\tsmp_wmb();\n\tw->want = want;\n\tsmp_wmb();\n\tw->lock = lock;\n\tadd_stats(TAKEN_SLOW, 1);\n\tcpumask_set_cpu(cpu, &waiting_cpus);\n\tbarrier();\n\t__ticket_enter_slowpath(lock);\n\tif (ACCESS_ONCE(lock->tickets.head) == want) {\n\t\tadd_stats(TAKEN_SLOW_PICKUP, 1);\n\t\tgoto out;\n\t}\n\tif (arch_irqs_disabled_flags(flags))\n\t\thalt();\n\telse\n\t\tsafe_halt();\nout:\n\tcpumask_clear_cpu(cpu, &waiting_cpus);\n\tw->lock = NULL;\n\tlocal_irq_restore(flags);\n\tspin_time_accum_blocked(start);\n}", "target": 0}
{"code": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}", "target": 1}
{"code": "static FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\tchar *dir = \"/etc\";\n\tif ((fd = xfmkstemp(&tmpname, dir)) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}", "target": 1}
{"code": "sudo_auth_end_session(void)\n{\n    sudo_auth *auth;\n    int status;\n    debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->end_session && !IS_DISABLED(auth)) {\n\t    status = (auth->end_session)(auth);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}", "target": 1}
{"code": "ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\tif (pskb_may_pull(skb, 2)) {\n#ifdef CONFIG_PPP_MULTILINK\n\t\tif (PPP_PROTO(skb) == PPP_MP)\n\t\t\tppp_receive_mp_frame(ppp, skb, pch);\n\t\telse\n#endif \n\t\t\tppp_receive_nonmp_frame(ppp, skb);\n\t\treturn;\n\t}\n\tif (skb->len > 0)\n\t\t++ppp->dev->stats.rx_length_errors;\n\tkfree_skb(skb);\n\tppp_receive_error(ppp);\n}", "target": 0}
{"code": "static int idr_get_empty_slot(struct idr *idp, int starting_id,\n\t\t\t      struct idr_layer **pa)\n{\n\tstruct idr_layer *p, *new;\n\tint layers, v, id;\n\tunsigned long flags;\n\tid = starting_id;\nbuild_up:\n\tp = idp->top;\n\tlayers = idp->layers;\n\tif (unlikely(!p)) {\n\t\tif (!(p = get_from_free_list(idp)))\n\t\t\treturn -1;\n\t\tp->layer = 0;\n\t\tlayers = 1;\n\t}\n\twhile ((layers < (MAX_LEVEL - 1)) && (id >= (1 << (layers*IDR_BITS)))) {\n\t\tlayers++;\n\t\tif (!p->count) {\n\t\t\tp->layer++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(new = get_from_free_list(idp))) {\n\t\t\tspin_lock_irqsave(&idp->lock, flags);\n\t\t\tfor (new = p; p && p != idp->top; new = p) {\n\t\t\t\tp = p->ary[0];\n\t\t\t\tnew->ary[0] = NULL;\n\t\t\t\tnew->bitmap = new->count = 0;\n\t\t\t\t__move_to_free_list(idp, new);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&idp->lock, flags);\n\t\t\treturn -1;\n\t\t}\n\t\tnew->ary[0] = p;\n\t\tnew->count = 1;\n\t\tnew->layer = layers-1;\n\t\tif (p->bitmap == IDR_FULL)\n\t\t\t__set_bit(0, &new->bitmap);\n\t\tp = new;\n\t}\n\trcu_assign_pointer(idp->top, p);\n\tidp->layers = layers;\n\tv = sub_alloc(idp, &id, pa);\n\tif (v == IDR_NEED_TO_GROW)\n\t\tgoto build_up;\n\treturn(v);\n}", "target": 0}
{"code": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))\n\t\treturn -EIO;\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\tget_bh(iloc->bh);\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}", "target": 0}
{"code": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\treturn &rt->dst;\n}", "target": 1}
{"code": "  bool const_item() const { return used_tables() == 0; }", "target": 1}
{"code": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "static void override_ssh_variant(enum ssh_variant *ssh_variant)\n{\n\tconst char *variant = getenv(\"GIT_SSH_VARIANT\");\n\tif (!variant && git_config_get_string_const(\"ssh.variant\", &variant))\n\t\treturn;\n\tif (!strcmp(variant, \"auto\"))\n\t\t*ssh_variant = VARIANT_AUTO;\n\telse if (!strcmp(variant, \"plink\"))\n\t\t*ssh_variant = VARIANT_PLINK;\n\telse if (!strcmp(variant, \"putty\"))\n\t\t*ssh_variant = VARIANT_PUTTY;\n\telse if (!strcmp(variant, \"tortoiseplink\"))\n\t\t*ssh_variant = VARIANT_TORTOISEPLINK;\n\telse if (!strcmp(variant, \"simple\"))\n\t\t*ssh_variant = VARIANT_SIMPLE;\n\telse\n\t\t*ssh_variant = VARIANT_SSH;\n}", "target": 0}
{"code": "vte_sequence_handler_DO (VteTerminal *terminal, GValueArray *params)\n{\n\tvte_sequence_handler_multiple(terminal, params, vte_sequence_handler_do);\n}", "target": 0}
{"code": "fmtint(int64 value, char type, int forcesign, int leftjust,\n\t   int minlen, int zpad, int precision, int pointflag,\n\t   PrintfTarget *target)\n{\n\tuint64\t\tbase;\n\tint\t\t\tdosign;\n\tconst char *cvt = \"0123456789abcdef\";\n\tint\t\t\tsignvalue = 0;\n\tchar\t\tconvert[64];\n\tint\t\t\tvallen = 0;\n\tint\t\t\tpadlen = 0;\t\t\n\tint\t\t\tzeropad;\t\t\n\tswitch (type)\n\t{\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tbase = 10;\n\t\t\tdosign = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tbase = 8;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tbase = 10;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tcvt = \"0123456789ABCDEF\";\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\t\t\t\t\n\t}\n\tif (dosign && adjust_sign((value < 0), forcesign, &signvalue))\n\t\tvalue = -value;\n\tif (value == 0 && pointflag && precision == 0)\n\t\tvallen = 0;\n\telse\n\t{\n\t\tuint64\t\tuvalue = (uint64) value;\n\t\tdo\n\t\t{\n\t\t\tconvert[vallen++] = cvt[uvalue % base];\n\t\t\tuvalue = uvalue / base;\n\t\t} while (uvalue);\n\t}\n\tzeropad = Max(0, precision - vallen);\n\tadjust_padlen(minlen, vallen + zeropad, leftjust, &padlen);\n\tleading_pad(zpad, &signvalue, &padlen, target);\n\twhile (zeropad-- > 0)\n\t\tdopr_outch('0', target);\n\twhile (vallen > 0)\n\t\tdopr_outch(convert[--vallen], target);\n\ttrailing_pad(&padlen, target);\n}", "target": 0}
{"code": "  virtual ~FFmpegVideoDecoderTest() {}", "target": 0}
{"code": "static size_t vnc_client_read_plain(VncState *vs)\n{\n    size_t ret;\n    VNC_DEBUG(\"Read plain %p size %zd offset %zd\\n\",\n              vs->input.buffer, vs->input.capacity, vs->input.offset);\n    buffer_reserve(&vs->input, 4096);\n    ret = vnc_client_read_buf(vs, buffer_end(&vs->input), 4096);\n    if (!ret)\n        return 0;\n    vs->input.offset += ret;\n    return ret;\n}", "target": 0}
{"code": "static unsigned addChunk_iTXt(ucvector* out, unsigned compressed, const char* keyword, const char* langtag,\n                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings)\n{\n  unsigned error = 0;\n  ucvector data;\n  size_t i, textsize = strlen(textstring);\n  ucvector_init(&data);\n  for(i = 0; keyword[i] != 0; i++) ucvector_push_back(&data, (unsigned char)keyword[i]);\n  if(i < 1 || i > 79) return 89; \n  ucvector_push_back(&data, 0); \n  ucvector_push_back(&data, compressed ? 1 : 0); \n  ucvector_push_back(&data, 0); \n  for(i = 0; langtag[i] != 0; i++) ucvector_push_back(&data, (unsigned char)langtag[i]);\n  ucvector_push_back(&data, 0); \n  for(i = 0; transkey[i] != 0; i++) ucvector_push_back(&data, (unsigned char)transkey[i]);\n  ucvector_push_back(&data, 0); \n  if(compressed)\n  {\n    ucvector compressed_data;\n    ucvector_init(&compressed_data);\n    error = zlib_compress(&compressed_data.data, &compressed_data.size,\n                          (unsigned char*)textstring, textsize, zlibsettings);\n    if(!error)\n    {\n      for(i = 0; i < compressed_data.size; i++) ucvector_push_back(&data, compressed_data.data[i]);\n    }\n    ucvector_cleanup(&compressed_data);\n  }\n  else \n  {\n    for(i = 0; textstring[i] != 0; i++) ucvector_push_back(&data, (unsigned char)textstring[i]);\n  }\n  if(!error) error = addChunk(out, \"iTXt\", data.data, data.size);\n  ucvector_cleanup(&data);\n  return error;\n}", "target": 0}
{"code": "    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n            ++sCur;\n        bool bASCII = false;\n        if ( isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }", "target": 1}
{"code": "static bool is_maintenance_mode_cmd(struct kernel_ipmi_msg *msg)\n{\n\treturn (((msg->netfn == IPMI_NETFN_APP_REQUEST)\n\t\t && ((msg->cmd == IPMI_COLD_RESET_CMD)\n\t\t     || (msg->cmd == IPMI_WARM_RESET_CMD)))\n\t\t|| (msg->netfn == IPMI_NETFN_FIRMWARE_REQUEST));\n}", "target": 0}
{"code": "coolkey_get_public_key(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj, CK_KEY_TYPE key_type)\n{\n\tsc_pkcs15_pubkey_t *key;\n\tkey = coolkey_make_public_key(p15card->card, obj, key_type);\n\tif (key) {\n\t\treturn key;\n\t}\n\treturn coolkey_get_public_key_from_certificate(p15card, obj);\n}", "target": 0}
{"code": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}", "target": 1}
{"code": "close_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}", "target": 0}
{"code": "void RGWDeleteLC_ObjStore_S3::send_response()\n{\n  if (op_ret == 0)\n      op_ret = STATUS_NO_CONTENT;\n  if (op_ret) {   \n    set_req_state_err(s, op_ret);\n  }\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n}", "target": 0}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "parse_string(xmlTextReaderPtr reader, char const *attr, char **result)\n{\n\txmlChar *xml_value;\n\tchar *tmp;\n\tif (attr == NULL)\n\t\txml_value = xmlTextReaderValue(reader);\n\telse\n\t\txml_value = xmlTextReaderGetAttribute(reader, BAD_CAST attr);\n\tif (xml_value == NULL)\n\t\treturn pr_val_err(\"RRDP file: Couldn't find %s from '%s'\",\n\t\t    (attr == NULL ? \"string content\" : \"xml attribute\"),\n\t\t    xmlTextReaderConstLocalName(reader));\n\ttmp = malloc(xmlStrlen(xml_value) + 1);\n\tif (tmp == NULL) {\n\t\txmlFree(xml_value);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(tmp, xml_value, xmlStrlen(xml_value));\n\ttmp[xmlStrlen(xml_value)] = '\\0';\n\txmlFree(xml_value);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "Bool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)\n{\n\tBool res = GF_FALSE;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_BitStream *bs1, *bs2;\n\tu8 *buf1, *buf2;\n\tu32 len1, len2;\n\tif (!ptr1 || !ptr2)\n\t\treturn GF_FALSE;\n\tbs1 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr1, bs1);\n\t} else {\n\t\tgf_isom_box_size((GF_Box *)ptr1);\n\t\tgf_isom_box_write((GF_Box *)ptr1, bs1);\n\t}\n\tgf_bs_get_content(bs1, &buf1, &len1);\n\tgf_bs_del(bs1);\n\tbs2 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr2, bs2);\n\t} else {\n\t\tgf_isom_box_write((GF_Box *)ptr2, bs2);\n\t}\n\tgf_bs_get_content(bs2, &buf2, &len2);\n\tgf_bs_del(bs2);\n\tif ((len1==len2) && !memcmp(buf1, buf2, len1))\n\t\tres = GF_TRUE;\n\tgf_free(buf1);\n\tgf_free(buf2);\n#endif\n\treturn res;", "target": 0}
{"code": "static void set_ntacl_dacl(struct user_namespace *user_ns,\n\t\t\t   struct smb_acl *pndacl,\n\t\t\t   struct smb_acl *nt_dacl,\n\t\t\t   const struct smb_sid *pownersid,\n\t\t\t   const struct smb_sid *pgrpsid,\n\t\t\t   struct smb_fattr *fattr)\n{\n\tstruct smb_ace *ntace, *pndace;\n\tint nt_num_aces = le32_to_cpu(nt_dacl->num_aces), num_aces = 0;\n\tunsigned short size = 0;\n\tint i;\n\tpndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\tif (nt_num_aces) {\n\t\tntace = (struct smb_ace *)((char *)nt_dacl + sizeof(struct smb_acl));\n\t\tfor (i = 0; i < nt_num_aces; i++) {\n\t\t\tmemcpy((char *)pndace + size, ntace, le16_to_cpu(ntace->size));\n\t\t\tsize += le16_to_cpu(ntace->size);\n\t\t\tntace = (struct smb_ace *)((char *)ntace + le16_to_cpu(ntace->size));\n\t\t\tnum_aces++;\n\t\t}\n\t}\n\tset_posix_acl_entries_dacl(user_ns, pndace, fattr,\n\t\t\t\t   &num_aces, &size, nt_num_aces);\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}", "target": 1}
{"code": "create_tls_session(int csock, int type  )\n{\n    int rc = 0;\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n        case GNUTLS_SERVER:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_s);\n            break;\n        case GNUTLS_CLIENT:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_c);\n            break;\n    }\n    do {\n        rc = gnutls_handshake(*session);\n    } while (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN);\n    if (rc < 0) {\n        crm_err(\"Handshake failed: %s\", gnutls_strerror(rc));\n        gnutls_deinit(*session);\n        gnutls_free(session);\n        return NULL;\n    }\n    return session;\n}", "target": 1}
{"code": "static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n{\n    return primes[hashtable->num_buckets];\n}", "target": 1}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "vhost_user_set_req_fd(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tint fd = msg->fds[0];\n\tif (validate_msg_fds(msg, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (fd < 0) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\t\"Invalid file descriptor for slave channel (%d)\\n\",\n\t\t\t\tfd);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tif (dev->slave_req_fd >= 0)\n\t\tclose(dev->slave_req_fd);\n\tdev->slave_req_fd = fd;\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "static int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n\tstruct pppol2tp_session *ps;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlen = min_t(unsigned int, len, sizeof(int));\n\tif (len < 0)\n\t\treturn -EINVAL;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\tif (copy_to_user((void __user *) optval, &val, len))\n\t\tgoto end_put_sess;\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 1}
{"code": "vhost_user_set_vring_addr(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tstruct vhost_virtqueue *vq;\n\tstruct vhost_vring_addr *addr = &msg->payload.addr;\n\tbool access_ok;\n\tif (validate_msg_fds(msg, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (dev->mem == NULL)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tvq = dev->virtqueue[msg->payload.addr.index];\n\taccess_ok = vq->access_ok;\n\tmemcpy(&vq->ring_addrs, addr, sizeof(*addr));\n\tvring_invalidate(dev, vq);\n\tif ((vq->enabled && (dev->features &\n\t\t\t\t(1ULL << VHOST_USER_F_PROTOCOL_FEATURES))) ||\n\t\t\taccess_ok) {\n\t\tdev = translate_ring_addresses(dev, msg->payload.addr.index);\n\t\tif (!dev)\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t*pdev = dev;\n\t}\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "static void cma_leave_mc_groups(struct rdma_id_private *id_priv)\n{\n\tstruct cma_multicast *mc;\n\twhile (!list_empty(&id_priv->mc_list)) {\n\t\tmc = list_first_entry(&id_priv->mc_list, struct cma_multicast,\n\t\t\t\t      list);\n\t\tlist_del(&mc->list);\n\t\tdestroy_mc(id_priv, mc);\n\t}\n}", "target": 0}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "static int fixup_call_args(struct bpf_verifier_env *env)\n{\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint i, depth;\n#endif\n\tint err = 0;\n\tif (env->prog->jit_requested &&\n\t    !bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\terr = jit_subprogs(env);\n\t\tif (err == 0)\n\t\t\treturn 0;\n\t\tif (err == -EFAULT)\n\t\t\treturn err;\n\t}\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tfor (i = 0; i < prog->len; i++, insn++) {\n\t\tif (insn->code != (BPF_JMP | BPF_CALL) ||\n\t\t    insn->src_reg != BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\t\tdepth = get_callee_stack_depth(env, insn, i);\n\t\tif (depth < 0)\n\t\t\treturn depth;\n\t\tbpf_patch_call_args(insn, depth);\n\t}\n\terr = 0;\n#endif\n\treturn err;\n}", "target": 0}
{"code": "fribidi_cap_rtl_to_unicode (\n  const char *s,\n  FriBidiStrIndex len,\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n  return j;\n}", "target": 1}
{"code": "void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\tgf_bs_align(bs);\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t\tif (bs->position>bs->size) {\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->overflow_state = 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}", "target": 0}
{"code": "void HeaderUtility::stripPortFromHost(RequestHeaderMap& headers, uint32_t listener_port) {\n  if (headers.getMethodValue() == Http::Headers::get().MethodValues.Connect) {\n    return;\n  }\n  const absl::string_view original_host = headers.getHostValue();\n  const absl::string_view::size_type port_start = original_host.rfind(':');\n  if (port_start == absl::string_view::npos) {\n    return;\n  }\n  const auto v6_end_index = original_host.rfind(\"]\");\n  if (v6_end_index == absl::string_view::npos || v6_end_index < port_start) {\n    if ((port_start + 1) > original_host.size()) {\n      return;\n    }\n    const absl::string_view port_str = original_host.substr(port_start + 1);\n    uint32_t port = 0;\n    if (!absl::SimpleAtoi(port_str, &port)) {\n      return;\n    }\n    if (port != listener_port) {\n      return;\n    }\n    const absl::string_view host = original_host.substr(0, port_start);\n    headers.setHost(host);\n  }\n}", "target": 0}
{"code": "bool HTMLFormControlElement::isAutofocusable() const\n {\n    if (!fastHasAttribute(autofocusAttr))\n        return false;\n    if (hasTagName(inputTag))\n        return !toHTMLInputElement(this)->isInputTypeHidden();\n    if (hasTagName(selectTag))\n        return true;\n    if (hasTagName(keygenTag))\n        return true;\n    if (hasTagName(buttonTag))\n        return true;\n    if (hasTagName(textareaTag))\n        return true;\n     return false;\n }", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": "int phar_tar_setmetadata(zval *metadata, phar_entry_info *entry, char **error TSRMLS_DC) \n{\n\tphp_serialize_data_t metadata_hash;\n\tif (entry->metadata_str.c) {\n\t\tsmart_str_free(&entry->metadata_str);\n\t}\n\tentry->metadata_str.c = 0;\n\tentry->metadata_str.len = 0;\n\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\tphp_var_serialize(&entry->metadata_str, &metadata, &metadata_hash TSRMLS_CC);\n\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\tentry->uncompressed_filesize = entry->compressed_filesize = entry->metadata_str.len;\n\tif (entry->fp && entry->fp_type == PHAR_MOD) {\n\t\tphp_stream_close(entry->fp);\n\t}\n\tentry->fp_type = PHAR_MOD;\n\tentry->is_modified = 1;\n\tentry->fp = php_stream_fopen_tmpfile();\n\tentry->offset = entry->offset_abs = 0;\n\tif (entry->fp == NULL) {\n\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\treturn -1;\n\t}\n\tif (entry->metadata_str.len != php_stream_write(entry->fp, entry->metadata_str.c, entry->metadata_str.len)) {\n\t\tspprintf(error, 0, \"phar tar error: unable to write metadata to magic metadata file \\\"%s\\\"\", entry->filename);\n\t\tzend_hash_del(&(entry->phar->manifest), entry->filename, entry->filename_len);\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\treturn ZEND_HASH_APPLY_KEEP;\n}", "target": 0}
{"code": "static int decode_attr_security_label(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n\tuint32_t pi = 0;\n\tuint32_t lfs = 0;\n\t__u32 len;\n\t__be32 *p;\n\tint status = 0;\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_SECURITY_LABEL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlfs = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tpi = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tif (len < NFS4_MAXLABELLEN) {\n\t\t\tif (label) {\n\t\t\t\tmemcpy(label->label, p, len);\n\t\t\t\tlabel->len = len;\n\t\t\t\tlabel->pi = pi;\n\t\t\t\tlabel->lfs = lfs;\n\t\t\t\tstatus = NFS_ATTR_FATTR_V4_SECURITY_LABEL;\n\t\t\t}\n\t\t\tbitmap[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: label too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t}\n\tif (label && label->label)\n\t\tdprintk(\"%s: label=%s, len=%d, PI=%d, LFS=%d\\n\", __func__,\n\t\t\t(char *)label->label, label->len, label->pi, label->lfs);\n\treturn status;\n}", "target": 1}
{"code": "void set_cron_watched(int fd) {\n\tpid_t pid = getpid();\n\tint i;\n\tif (fd < 0) {\n\t\tinotify_enabled = 0;\n\t\treturn;\n\t}\n\tfor (i = 0; i < sizeof (wd) / sizeof (wd[0]); ++i) {\n\t\tint w;\n\t\tif (open(watchpaths[i], O_RDONLY | O_NONBLOCK, 0) != -1) {\n\t\t\tw = inotify_add_watch(fd, watchpaths[i],\n\t\t\t\tIN_CREATE | IN_CLOSE_WRITE | IN_ATTRIB | IN_MODIFY | IN_MOVED_TO |\n\t\t\t\tIN_MOVED_FROM | IN_MOVE_SELF | IN_DELETE | IN_DELETE_SELF);\n\t\t\tif (w < 0) {\n\t\t\t\tif (wd[i] != -1) {\n\t\t\t\t\tlog_it(\"CRON\", pid, \"This directory or file can't be watched\",\n\t\t\t\t\t\twatchpaths[i], errno);\n\t\t\t\t\tlog_it(\"CRON\", pid, \"INFO\", \"running without inotify support\", 0);\n\t\t\t\t}\n\t\t\t\tinotify_enabled = 0;\n\t\t\t\tset_cron_unwatched(fd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twd[i] = w;\n\t\t}\n\t}\n\tif (!inotify_enabled) {\n\t\tlog_it(\"CRON\", pid, \"INFO\", \"running with inotify support\", 0);\n\t}\n\tinotify_enabled = 1;\n}", "target": 1}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tgpointer         data)\n{\n\tdouble *scale = data;\n\tint w = (width  * (*scale) + 0.5);\n\tint h = (height * (*scale) + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 1}
{"code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}", "target": 1}
{"code": "read_yin_subnode(struct ly_ctx *ctx, struct lyxml_elem *node, const char *name)\n{\n    int len;\n    if (!node->child || !node->child->name || strcmp(node->child->name, name)) {\n        LOGERR(ctx, LY_EVALID, \"Expected \\\"%s\\\" element in \\\"%s\\\" element.\", name, node->name);\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, name, node->name);\n        return NULL;\n    } else if (node->child->content) {\n        len = strlen(node->child->content);\n        return lydict_insert(ctx, node->child->content, len);\n    } else {\n        return lydict_insert(ctx, \"\", 0);\n    }\n}", "target": 0}
{"code": "init(void)\n{\n#ifdef USE_CALLOUT\n    int id;\n    OnigEncoding enc;\n    char* name;\n    unsigned int args[4];\n    OnigValue opts[4];\n    enc = ONIG_ENCODING_UTF16_BE;\n    name = \"\\000F\\000A\\000I\\000L\\000\\000\";            BC0_P(name, fail);\n    name = \"\\000M\\000I\\000S\\000M\\000A\\000T\\000C\\000H\\000\\000\"; BC0_P(name, mismatch);\n    name = \"\\000M\\000A\\000X\\000\\000\";\n    args[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    args[1] = ONIG_TYPE_CHAR;\n    opts[0].c = 'X';\n    BC_B_O(name, max, 2, args, 1, opts);\n    name = \"\\000E\\000R\\000R\\000O\\000R\\000\\000\";\n    args[0] = ONIG_TYPE_LONG; opts[0].l = ONIG_ABORT;\n    BC_P_O(name, error, 1, args, 1, opts);\n    name = \"\\000C\\000O\\000U\\000N\\000T\\000\\000\";\n    args[0] = ONIG_TYPE_CHAR; opts[0].c = '>';\n    BC_B_O(name, count, 1, args, 1, opts);\n    name = \"\\000T\\000O\\000T\\000A\\000L\\000_\\000C\\000O\\000U\\000N\\000T\\000\\000\";\n    args[0] = ONIG_TYPE_CHAR; opts[0].c = '>';\n    BC_B_O(name, total_count, 1, args, 1, opts);\n    name = \"\\000C\\000M\\000P\\000\\000\";\n    args[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    args[1] = ONIG_TYPE_STRING;\n    args[2] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    BC_P(name, cmp, 3, args);\n#endif \n  return ONIG_NORMAL;\n}", "target": 0}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n    out[outlen] = '\\0';\ndone:\n    if (ret) {\n        safefree(out);\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n\tfl6.saddr = transport->saddr.v6.sin6_addr;\n\tfl6.flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n\telse\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tif (np->opt && np->opt->srcrt) {\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n\t\tfl6.daddr = *rt0->addr;\n\t}\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6.saddr, &fl6.daddr);\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->local_df = 1;\n\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n}", "target": 1}
{"code": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}", "target": 1}
{"code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\twl_lock(lp, &flags);\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} ", "target": 1}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}", "target": 1}
{"code": "_polkit_subject_get_cmdline (PolkitSubject *subject, gint *pid, gint *uid)\n{\n  PolkitSubject *process;\n  gchar *ret;\n  gchar *filename;\n  gchar *contents;\n  gsize contents_len;\n  GError *error;\n  guint n;\n  g_return_val_if_fail (subject != NULL, NULL);\n  error = NULL;\n  ret = NULL;\n  process = NULL;\n  filename = NULL;\n  contents = NULL;\n  if (POLKIT_IS_UNIX_PROCESS (subject))\n   {\n      process = g_object_ref (subject);\n    }\n  else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))\n    {\n      process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject),\n                                                         NULL,\n                                                         &error);\n      if (process == NULL)\n        {\n          g_warning (\"Error getting process for system bus name `%s': %s\",\n                     polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (subject)),\n                     error->message);\n          g_error_free (error);\n          goto out;\n        }\n    }\n  else\n    {\n      g_warning (\"Unknown subject type passed to guess_program_name()\");\n      goto out;\n    }\n  *pid = polkit_unix_process_get_pid (POLKIT_UNIX_PROCESS (process));\n  *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  filename = g_strdup_printf (\"/proc/%d/cmdline\", *pid);\n  if (!g_file_get_contents (filename,\n                            &contents,\n                            &contents_len,\n                            &error))\n    {\n      g_warning (\"Error openeing `%s': %s\",\n                 filename,\n                 error->message);\n      g_error_free (error);\n      goto out;\n    }\n  for (n = 0; n < contents_len - 1; n++)\n    {\n      if (contents[n] == '\\0')\n        contents[n] = ' ';\n    }\n  ret = g_strdup (contents);\n  g_strstrip (ret);\n out:\n  g_free (filename);\n  g_free (contents);\n  if (process != NULL)\n    g_object_unref (process);\n  return ret;\n}", "target": 0}
{"code": "static void rfc2231_decode_one (char *dest, char *src)\n{\n  char *d;\n  for (d = dest; *src; src++)\n  {\n    if (*src == '%' &&\n        isxdigit ((unsigned char) *(src + 1)) &&\n        isxdigit ((unsigned char) *(src + 2)))\n    {\n      *d++ = (hexval (*(src + 1)) << 4) | (hexval (*(src + 2)));\n      src += 2;\n    }\n    else\n      *d++ = *src;\n  }\n  *d = '\\0';\n}", "target": 0}
{"code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}", "target": 1}
{"code": "static int persist__subs_save_all(FILE *db_fptr)\n{\n\tstruct mosquitto__subhier *subhier, *subhier_tmp;\n\tHASH_ITER(hh, db.subs, subhier, subhier_tmp){\n\t\tif(subhier->children){\n\t\t\tpersist__subs_save(db_fptr, subhier->children, \"\", 0);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tstruct list_head *list;\n#ifdef CONFIG_SMP\n\tint cpu;\n\tcpu = smp_processor_id();\n\tfile->f_sb_list_cpu = cpu;\n\tlist = per_cpu_ptr(sb->s_files, cpu);\n#else\n\tlist = &sb->s_files;\n#endif\n\tlist_add(&file->f_u.fu_list, list);\n}", "target": 1}
{"code": "ddxGiveUp(enum ExitCode error)\n{\n    int i;\n    xf86VGAarbiterFini();\n#ifdef XF86PM\n    if (xf86OSPMClose)\n        xf86OSPMClose();\n    xf86OSPMClose = NULL;\n#endif\n    for (i = 0; i < xf86NumScreens; i++) {\n        xf86Screens[i]->vtSema = FALSE;\n    }\n#ifdef XFreeXDGA\n    DGAShutdown();\n#endif\n    if (xorgHWOpenConsole)\n        xf86CloseConsole();\n    systemd_logind_fini();\n    dbus_core_fini();\n    xf86CloseLog(error);\n    if (xf86Info.caughtSignal)\n        OsAbort();\n}", "target": 0}
{"code": "static long cec_adap_g_log_addrs(struct cec_adapter *adap,\n\t\t\t\t struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\tmutex_lock(&adap->lock);\n\tlog_addrs = adap->log_addrs;\n\tif (!adap->is_configured)\n\t\tmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\n\t\t       sizeof(log_addrs.log_addr));\n\tmutex_unlock(&adap->lock);\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\ttmp = xmalloc(len);\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}", "target": 1}
{"code": "WebUI* WebContentsImpl::GetCommittedWebUI() const {\n  return render_manager_.web_ui();\n}", "target": 0}
{"code": "xfs_bunmapi(\n\txfs_trans_t\t\t*tp,\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\tflags,\n\txfs_extnum_t\t\tnexts,\n\txfs_fsblock_t\t\t*firstblock,\n\tstruct xfs_defer_ops\t*dfops,\n\tint\t\t\t*done)\n{\n\tint\t\t\terror;\n\terror = __xfs_bunmapi(tp, ip, bno, &len, flags, nexts, firstblock,\n\t\t\tdfops);\n\t*done = (len == 0);\n\treturn error;\n}", "target": 0}
{"code": "static int handle_pte_fault(struct mm_struct *mm,\n\t\t     struct vm_area_struct *vma, unsigned long address,\n\t\t     pte_t *pte, pmd_t *pmd, unsigned int flags)\n{\n\tpte_t entry;\n\tspinlock_t *ptl;\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_fault(mm, vma, address, pte,\n\t\t\t\t\t\t\tpmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\tif (pte_protnone(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*pte, entry)))\n\t\tgoto unlock;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, ptl, entry);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vma, address, pte, entry, flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vma, address, pte);\n\t} else {\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\nunlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn 0;\n}", "target": 1}
{"code": "ciEnv::~ciEnv() {\n  GUARDED_VM_ENTRY(\n      CompilerThread* current_thread = CompilerThread::current();\n      _factory->remove_symbols();\n      current_thread->set_env(NULL);\n  )\n}", "target": 0}
{"code": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\terror = (*nproc)(priv, cookie, call_nests);\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\treturn error;\n}", "target": 0}
{"code": "void LibRaw::nikon_coolscan_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int bypp = tiff_bps <= 8 ? 1 : 2;\n  int bufsize = width * 3 * bypp;\n  unsigned char *buf = (unsigned char *)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  if (tiff_bps <= 8)\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n  else\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);\n  fseek(ifp, data_offset, SEEK_SET);\n  for (int row = 0; row < raw_height; row++)\n  {\n      if(tiff_bps <=8)\n        fread(buf, 1, bufsize, ifp);\n      else\n          read_shorts(ubuf,width*3);\n    unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;\n    if (is_NikonTransfer == 2)\n    { \n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = ((float)curve[buf[col * 3]]) / 255.0f;\n        ip[col][1] = ((float)curve[buf[col * 3 + 1]]) / 255.0f;\n        ip[col][2] = ((float)curve[buf[col * 3 + 2]]) / 255.0f;\n        ip[col][3] = 0;\n      }\n    }\n    else if (tiff_bps <= 8)\n    {\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[buf[col * 3]];\n        ip[col][1] = curve[buf[col * 3 + 1]];\n        ip[col][2] = curve[buf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    }\n    else\n    {\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[ubuf[col * 3]];\n        ip[col][1] = curve[ubuf[col * 3 + 1]];\n        ip[col][2] = curve[ubuf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    }\n  }\n  free(buf);\n}", "target": 0}
{"code": "int cfg80211_mgd_wext_giwessid(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\tdata->flags = 0;\n\twdev_lock(wdev);\n\tif (wdev->current_bss) {\n\t\tconst u8 *ie;\n\t\trcu_read_lock();\n\t\tie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t  WLAN_EID_SSID);\n\t\tif (ie) {\n\t\t\tdata->flags = 1;\n\t\t\tdata->length = ie[1];\n\t\t\tmemcpy(ssid, ie + 2, data->length);\n\t\t}\n\t\trcu_read_unlock();\n\t} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->wext.connect.ssid_len;\n\t\tmemcpy(ssid, wdev->wext.connect.ssid, data->length);\n\t}\n\twdev_unlock(wdev);\n\treturn 0;\n}", "target": 1}
{"code": "static uint_fast32_t jpc_abstorelstepsize(jpc_fix_t absdelta, int scaleexpn)\n{\n\tint p;\n\tuint_fast32_t mant;\n\tuint_fast32_t expn;\n\tint n;\n\tif (absdelta < 0) {\n\t\tabort();\n\t}\n\tp = jpc_fix_firstone(absdelta) - JPC_FIX_FRACBITS;\n\tn = 11 - jpc_fix_firstone(absdelta);\n\tmant = ((n < 0) ? (absdelta >> (-n)) : (absdelta << n)) & 0x7ff;\n\texpn = scaleexpn - p;\n\tif (scaleexpn < p) {\n\t\tabort();\n\t}\n\treturn JPC_QCX_EXPN(expn) | JPC_QCX_MANT(mant);\n}", "target": 1}
{"code": "void GfxDeviceCMYKColorSpace::getCMYKLine(unsigned char *in, unsigned char *out, int length)\n{\n    for (int i = 0; i < length; i++) {\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = *in++;\n    }\n}", "target": 0}
{"code": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 1 );\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 1}
{"code": "static void prefetch_table(const volatile byte *tab, size_t len)\n{\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)tab[i + 0 * 32];\n      (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n      (void)tab[i + 6 * 32];\n      (void)tab[i + 7 * 32];\n    }\n  (void)tab[len - 1];\n}", "target": 1}
{"code": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n    emit newLogPeer(temp);\n}", "target": 1}
{"code": "static int hash_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_ahash_setkey(private, key, keylen);\n}", "target": 0}
{"code": "void LinkResolver::resolve_invoke(CallInfo& result, Handle& recv,\n                             const methodHandle& attached_method,\n                             Bytecodes::Code byte, TRAPS) {\n  Klass* defc = attached_method->method_holder();\n  Symbol* name = attached_method->name();\n  Symbol* type = attached_method->signature();\n  LinkInfo link_info(defc, name, type);\n  switch(byte) {\n    case Bytecodes::_invokevirtual:\n      resolve_virtual_call(result, recv, recv->klass(), link_info,\n                           true, CHECK);\n      break;\n    case Bytecodes::_invokeinterface:\n      resolve_interface_call(result, recv, recv->klass(), link_info,\n                             true, CHECK);\n      break;\n    case Bytecodes::_invokestatic:\n      resolve_static_call(result, link_info, false, CHECK);\n      break;\n    case Bytecodes::_invokespecial:\n      resolve_special_call(result, recv, link_info, CHECK);\n      break;\n    default:\n      fatal(\"bad call: %s\", Bytecodes::name(byte));\n      break;\n  }\n}", "target": 0}
{"code": "        Header readHeader(BasicIo& io)\n        {\n            byte header[2];\n            io.read(header, 2);\n            ByteOrder byteOrder = invalidByteOrder;\n            if (header[0] == 'I' && header[1] == 'I')\n                byteOrder = littleEndian;\n            else if (header[0] == 'M' && header[1] == 'M')\n                byteOrder = bigEndian;\n            if (byteOrder == invalidByteOrder)\n                return Header();\n            byte version[2];\n            io.read(version, 2);\n            const uint16_t magic = getUShort(version, byteOrder);\n            if (magic != 0x2A && magic != 0x2B)\n                return Header();\n            Header result;\n            if (magic == 0x2A)\n            {\n                byte buffer[4];\n                io.read(buffer, 4);\n                const uint32_t offset = getULong(buffer, byteOrder);\n                result = Header(byteOrder, magic, 4, offset);\n            }\n            else\n            {\n                byte buffer[8];\n                io.read(buffer, 2);\n                const int size = getUShort(buffer, byteOrder);\n                assert(size == 8);\n                io.read(buffer, 2); \n                io.read(buffer, 8);\n                const uint64_t offset = getULongLong(buffer, byteOrder);\n                result = Header(byteOrder, magic, size, offset);\n            }\n            return result;\n        }", "target": 1}
{"code": "static unsigned int count_acl_entries(connection_struct *conn, SMB_ACL_T posix_acl)\n{\n\tunsigned int ace_count = 0;\n\tint entry_id = SMB_ACL_FIRST_ENTRY;\n\tSMB_ACL_ENTRY_T entry;\n\twhile ( posix_acl && (sys_acl_get_entry(posix_acl, entry_id, &entry) == 1)) {\n\t\tif (entry_id == SMB_ACL_FIRST_ENTRY) {\n\t\t\tentry_id = SMB_ACL_NEXT_ENTRY;\n\t\t}\n\t\tace_count++;\n\t}\n\treturn ace_count;\n}", "target": 0}
{"code": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n    res = FALSE;\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n    return res;\n}", "target": 1}
{"code": "static void mspack_fmap_free(void *mem)\n{\n\tfree(mem);\n}", "target": 1}
{"code": "static int parse_public_key(const u8 *key, size_t keysize, RSA *rsa)\n{\n\tconst u8 *p = key;\n\tBIGNUM *n, *e;\n\tint base;\n\tbase = (keysize - 7) / 5;\n\tif (base != 32 && base != 48 && base != 64 && base != 128) {\n\t\tfprintf(stderr, \"Invalid public key.\\n\");\n\t\treturn -1;\n\t}\n\tp += 3;\n\tn = BN_new();\n\tif (n == NULL)\n\t\treturn -1;\n\tcf2bn(p, 2 * base, n);\n\tp += 2 * base;\n\tp += base;\n\tp += 2 * base;\n\te = BN_new();\n\tif (e == NULL)\n\t\treturn -1;\n\tcf2bn(p, 4, e);\n\tif (RSA_set0_key(rsa, n, e, NULL) != 1)\n\t    return -1;\n\treturn 0;\n}", "target": 0}
{"code": "static RBinSection *bin_section_from_segment(RCoreSymCacheElementSegment *seg) {\n\tif (!seg->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (seg->name, 16);\n\ts->size = seg->size;\n\ts->vsize = seg->vsize;\n\ts->paddr = seg->paddr;\n\ts->vaddr = seg->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = true;\n\treturn s;\n}", "target": 0}
{"code": "void ApplyChannelMatrix::run(const void *inputData, void *outputData, int frameCount)\n{\n\tconst T *input = reinterpret_cast<const T *>(inputData);\n\tT *output = reinterpret_cast<T *>(outputData);\n\tfor (int frame=0; frame<frameCount; frame++)\n\t{\n\t\tconst T *inputSave = input;\n\t\tconst double *m = m_matrix;\n\t\tfor (int outChannel=0; outChannel < m_outChannels; outChannel++)\n\t\t{\n\t\t\tinput = inputSave;\n\t\t\tdouble t = 0;\n\t\t\tfor (int inChannel=0; inChannel < m_inChannels; inChannel++)\n\t\t\t\tt += *input++ * *m++;\n\t\t\t*output++ = t;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int avrcp_target_server_probe(struct btd_profile *p,\n\t\t\t\t\t\tstruct btd_adapter *adapter)\n{\n\tsdp_record_t *record;\n\tstruct avrcp_server *server;\n\tDBG(\"path %s\", adapter_get_path(adapter));\n\tserver = find_server(servers, adapter);\n\tif (server != NULL)\n\t\tgoto done;\n\tserver = avrcp_server_register(adapter);\n\tif (server == NULL)\n\t\treturn -EPROTONOSUPPORT;\ndone:\n\trecord = avrcp_tg_record();\n\tif (!record) {\n\t\terror(\"Unable to allocate new service record\");\n\t\tavrcp_target_server_remove(p, adapter);\n\t\treturn -1;\n\t}\n\tif (adapter_service_add(adapter, record) < 0) {\n\t\terror(\"Unable to register AVRCP target service record\");\n\t\tavrcp_target_server_remove(p, adapter);\n\t\tsdp_record_free(record);\n\t\treturn -1;\n\t}\n\tserver->tg_record_id = record->handle;\n\treturn 0;\n}", "target": 0}
{"code": "xmlDictComputeFastQKey(const xmlChar *prefix, int plen,\n                       const xmlChar *name, int len, int seed)\n{\n    unsigned long value = (unsigned long) seed;\n    if (plen == 0)\n\tvalue += 30 * (unsigned long) ':';\n    else\n\tvalue += 30 * (*prefix);\n    if (len > 10) {\n        value += name[len - (plen + 1 + 1)];\n        len = 10;\n\tif (plen > 10)\n\t    plen = 10;\n    }\n    switch (plen) {\n        case 10: value += prefix[9];\n        case 9: value += prefix[8];\n        case 8: value += prefix[7];\n        case 7: value += prefix[6];\n        case 6: value += prefix[5];\n        case 5: value += prefix[4];\n        case 4: value += prefix[3];\n        case 3: value += prefix[2];\n        case 2: value += prefix[1];\n        case 1: value += prefix[0];\n        default: break;\n    }\n    len -= plen;\n    if (len > 0) {\n        value += (unsigned long) ':';\n\tlen--;\n    }\n    switch (len) {\n        case 10: value += name[9];\n        case 9: value += name[8];\n        case 8: value += name[7];\n        case 7: value += name[6];\n        case 6: value += name[5];\n        case 5: value += name[4];\n        case 4: value += name[3];\n        case 3: value += name[2];\n        case 2: value += name[1];\n        case 1: value += name[0];\n        default: break;\n    }\n    return(value);\n}", "target": 1}
{"code": "find_file (const char *search_path, const char *base_name, char **pdir)\n{\n  FILE *file = 0;\n  foreach_dirinpath (search_path, base_name, find_file_callback, pdir, &file);\n  return file;\n}", "target": 0}
{"code": "ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}", "target": 1}
{"code": "static const char *fault_name(unsigned int esr)\n{\n\tconst struct fault_info *inf = fault_info + (esr & 63);\n\treturn inf->name;\n}", "target": 0}
{"code": "bool kvm_check_and_clear_guest_paused(void)\n{\n\tbool ret = false;\n\tstruct pvclock_vcpu_time_info *src;\n\tint cpu = smp_processor_id();\n\tif (!hv_clock)\n\t\treturn ret;\n\tsrc = &hv_clock[cpu].pvti;\n\tif ((src->flags & PVCLOCK_GUEST_STOPPED) != 0) {\n\t\tsrc->flags &= ~PVCLOCK_GUEST_STOPPED;\n\t\tpvclock_touch_watchdogs();\n\t\tret = true;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  char tmphost[250];\n  int tmphostlen;\n#ifdef LIBVNCSERVER_IPv6\n  client->sock = ConnectClientToTcpAddr6(repeaterHost, repeaterPort);\n  if (client->sock == -1)\n#endif\n  {\n    unsigned int host;\n    if (!StringToIPAddr(repeaterHost, &host)) {\n      rfbClientLog(\"Couldn't convert '%s' to host address\\n\", repeaterHost);\n      return FALSE;\n    }\n    client->sock = ConnectClientToTcpAddr(host, repeaterPort);\n  }\n  if (client->sock < 0) {\n    rfbClientLog(\"Unable to connect to VNC repeater\\n\");\n    return FALSE;\n  }\n  if (!SetNonBlocking(client->sock))\n    return FALSE;\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg))\n    return FALSE;\n  pv[sz_rfbProtocolVersionMsg] = 0;\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2 || major != 0 || minor != 0) {\n    rfbClientLog(\"Not a valid VNC repeater (%s)\\n\",pv);\n    return FALSE;\n  }\n  rfbClientLog(\"Connected to VNC repeater, using protocol version %d.%d\\n\", major, minor);\n  tmphostlen = snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort);\n  if(tmphostlen < 0 || tmphostlen >= (int)sizeof(tmphost))\n    return FALSE; \n  if (!WriteToRFBServer(client, tmphost, tmphostlen + 1))\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {\n\tRBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);\n\tif (local_name) {\n\t\tif (!consume_u32_r (b, bound, &local_name->index)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tlocal_name->names = r_id_storage_new (0, UT32_MAX);\n\t\tif (!local_name->names) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {\n\t\t\tgoto beach;\n\t\t}\n\t\treturn local_name;\n\t}\nbeach:\n\twasm_custom_name_local_free (local_name);\n\treturn NULL;\n}", "target": 0}
{"code": "static int snd_disconnect_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_monitor_file *df = NULL, *_df;\n\tspin_lock(&shutdown_lock);\n\tlist_for_each_entry(_df, &shutdown_files, shutdown_list) {\n\t\tif (_df->file == file) {\n\t\t\tdf = _df;\n\t\t\tlist_del_init(&df->shutdown_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&shutdown_lock);\n\tif (likely(df)) {\n\t\tif ((file->f_flags & FASYNC) && df->disconnected_f_op->fasync)\n\t\t\tdf->disconnected_f_op->fasync(-1, file, 0);\n\t\treturn df->disconnected_f_op->release(inode, file);\n\t}\n\tpanic(\"%s(%p, %p) failed!\", __func__, inode, file);\n}", "target": 0}
{"code": "static int inet6_fill_ifaddr(struct sk_buff *skb, struct inet6_ifaddr *ifa,\n\t\t\t     u32 portid, u32 seq, int event, unsigned int flags)\n{\n\tstruct nlmsghdr  *nlh;\n\tu32 preferred, valid;\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct ifaddrmsg), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\tput_ifaddrmsg(nlh, ifa->prefix_len, ifa->flags, rt_scope(ifa->scope),\n\t\t      ifa->idev->dev->ifindex);\n\tif (!(ifa->flags&IFA_F_PERMANENT)) {\n\t\tpreferred = ifa->prefered_lft;\n\t\tvalid = ifa->valid_lft;\n\t\tif (preferred != INFINITY_LIFE_TIME) {\n\t\t\tlong tval = (jiffies - ifa->tstamp)/HZ;\n\t\t\tif (preferred > tval)\n\t\t\t\tpreferred -= tval;\n\t\t\telse\n\t\t\t\tpreferred = 0;\n\t\t\tif (valid != INFINITY_LIFE_TIME) {\n\t\t\t\tif (valid > tval)\n\t\t\t\t\tvalid -= tval;\n\t\t\t\telse\n\t\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpreferred = INFINITY_LIFE_TIME;\n\t\tvalid = INFINITY_LIFE_TIME;\n\t}\n\tif (!ipv6_addr_any(&ifa->peer_addr)) {\n\t\tif (nla_put(skb, IFA_LOCAL, 16, &ifa->addr) < 0 ||\n\t\t    nla_put(skb, IFA_ADDRESS, 16, &ifa->peer_addr) < 0)\n\t\t\tgoto error;\n\t} else\n\t\tif (nla_put(skb, IFA_ADDRESS, 16, &ifa->addr) < 0)\n\t\t\tgoto error;\n\tif (put_cacheinfo(skb, ifa->cstamp, ifa->tstamp, preferred, valid) < 0)\n\t\tgoto error;\n\treturn nlmsg_end(skb, nlh);\nerror:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}", "target": 0}
{"code": "soup_client_context_new (SoupServer *server, SoupSocket *sock)\n{\n\tSoupClientContext *client = g_slice_new0 (SoupClientContext);\n\tclient->server = server;\n\tclient->sock = sock;\n\tclient->ref_count = 1;\n\treturn client;\n}", "target": 0}
{"code": "sg_finish_rem_req(Sg_request *srp)\n{\n\tint ret = 0;\n\tSg_fd *sfp = srp->parentfp;\n\tSg_scatter_hold *req_schp = &srp->data;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t      \"sg_finish_rem_req: res_used=%d\\n\",\n\t\t\t\t      (int) srp->res_used));\n\tif (srp->bio)\n\t\tret = blk_rq_unmap_user(srp->bio);\n\tif (srp->rq) {\n\t\tscsi_req_free_cmd(scsi_req(srp->rq));\n\t\tblk_put_request(srp->rq);\n\t}\n\tif (srp->res_used)\n\t\tsg_unlink_reserve(sfp, srp);\n\telse\n\t\tsg_remove_scat(sfp, req_schp);\n\treturn ret;\n}", "target": 0}
{"code": "bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t   int protocol, bufferlist& authorizer_data,\n\t\t\t\t   bufferlist& authorizer_reply,\n\t\t\t\t   bool& isvalid, CryptoKey& session_key)\n{\n  dout(10) << \"ms_verify_authorizer \" << con->get_peer_addr()\n\t   << \" \" << ceph_entity_type_name(peer_type)\n\t   << \" protocol \" << protocol << dendl;\n  if (is_shutdown())\n    return false;\n  if (peer_type == CEPH_ENTITY_TYPE_MON &&\n      auth_cluster_required.is_supported_auth(CEPH_AUTH_CEPHX)) {\n    isvalid = false;\n    if (protocol == CEPH_AUTH_CEPHX) {\n      bufferlist::iterator iter = authorizer_data.begin();\n      CephXServiceTicketInfo auth_ticket_info;\n      if (authorizer_data.length()) {\n\tbool ret = cephx_verify_authorizer(g_ceph_context, &keyring, iter,\n\t\t\t\t\t  auth_ticket_info, authorizer_reply);\n\tif (ret) {\n\t  session_key = auth_ticket_info.session_key;\n\t  isvalid = true;\n\t} else {\n\t  dout(0) << \"ms_verify_authorizer bad authorizer from mon \" << con->get_peer_addr() << dendl;\n        }\n      }\n    } else {\n      dout(0) << \"ms_verify_authorizer cephx enabled, but no authorizer (required for mon)\" << dendl;\n    }\n  } else {\n    isvalid = true;\n  }\n  return true;\n}", "target": 1}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 1}
{"code": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tint ret;\n\tif (current_chrooted())\n\t\treturn -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\tatomic_set(&ns->count, 1);\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\tset_cred_user_ns(new, ns);\n\treturn 0;\n}", "target": 0}
{"code": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n#ifdef CONFIG_SND_CTL_DEBUG\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\thlist_for_each_entry_rcu(timer, head, t_hash) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "int wmi_set_ie(struct wil6210_priv *wil, u8 type, u16 ie_len, const void *ie)\n{\n\tstatic const char *const names[] = {\n\t\t[WMI_FRAME_BEACON]\t= \"BEACON\",\n\t\t[WMI_FRAME_PROBE_REQ]\t= \"PROBE_REQ\",\n\t\t[WMI_FRAME_PROBE_RESP]\t= \"WMI_FRAME_PROBE_RESP\",\n\t\t[WMI_FRAME_ASSOC_REQ]\t= \"WMI_FRAME_ASSOC_REQ\",\n\t\t[WMI_FRAME_ASSOC_RESP]\t= \"WMI_FRAME_ASSOC_RESP\",\n\t};\n\tint rc;\n\tu16 len = sizeof(struct wmi_set_appie_cmd) + ie_len;\n\tstruct wmi_set_appie_cmd *cmd = kzalloc(len, GFP_KERNEL);\n\tif (!cmd) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (!ie)\n\t\tie_len = 0;\n\tcmd->mgmt_frm_type = type;\n\tcmd->ie_len = cpu_to_le16(ie_len);\n\tmemcpy(cmd->ie_info, ie, ie_len);\n\trc = wmi_send(wil, WMI_SET_APPIE_CMDID, cmd, len);\n\tkfree(cmd);\nout:\n\tif (rc) {\n\t\tconst char *name = type < ARRAY_SIZE(names) ?\n\t\t\t\t   names[type] : \"??\";\n\t\twil_err(wil, \"set_ie(%d %s) failed : %d\\n\", type, name, rc);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "size_t intsetBlobLen(intset *is) {\n    return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n}", "target": 1}
{"code": "static void nfs4_handle_setlk_error(struct nfs_server *server, struct nfs4_lock_state *lsp, int new_lock_owner, int error)\n{\n\tswitch (error) {\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\t\tif (new_lock_owner != 0 ||\n\t\t   test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0)\n\t\t\tnfs4_schedule_stateid_recovery(server, lsp->ls_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\tcase -NFS4ERR_EXPIRED:\n\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t};\n}", "target": 0}
{"code": "int compat_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint err;\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\n\t\tif (udp_prot.compat_getsockopt != NULL)\n\t\t\treturn udp_prot.compat_getsockopt(sk, level, optname,\n\t\t\t\t\t\t\t  optval, optlen);\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\t}\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\tif (optname == MCAST_MSFILTER)\n\t\treturn compat_mc_getsockopt(sk, level, optname, optval, optlen,\n\t\t\tipv6_getsockopt);\n\terr = do_ipv6_getsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t MSG_CMSG_COMPAT);\n#ifdef CONFIG_NETFILTER\n\tif (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {\n\t\tint len;\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\terr = compat_nf_getsockopt(sk, PF_INET6, optname, optval, &len);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t}\n#endif\n\treturn err;\n}", "target": 0}
{"code": "  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n                             const int kx, const int ky, const int sx,\n                             const int sy, const string& data_format,\n                             const string& padding) {\n    OpContext op_context;\n    const std::vector<int> x = {n, h, w, c};\n    const std::vector<int> ksize = {1, kx, ky, 1};\n    std::vector<int> strides;\n    if (data_format == \"NHWC\") {\n      strides = {1, sy, sx, 1};\n    } else {\n      strides = {1, 1, sy, sx};\n    }\n    auto& op_info = op_context.op_info;\n    SetCpuDevice(&op_info);\n    op_info.set_op(\"MaxPool\");\n    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n    auto* attr = op_info.mutable_attr();\n    SetAttrValue(data_format, &(*attr)[\"data_format\"]);\n    SetAttrValue(padding, &(*attr)[\"padding\"]);\n    SetAttrValue(strides, &(*attr)[\"strides\"]);\n    SetAttrValue(ksize, &(*attr)[\"ksize\"]);\n    bool found_unknown_shapes;\n    return OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n  }", "target": 0}
{"code": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n};", "target": 1}
{"code": "static void numtostr(js_State *J, const char *fmt, int w, double n)\n{\n\tchar buf[32], *e;\n\tsprintf(buf, fmt, w, n);\n\te = strchr(buf, 'e');\n\tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}", "target": 1}
{"code": "static inline void native_set_ldt(const void *addr, unsigned int entries)\n{\n\tif (likely(entries == 0))\n\t\tasm volatile(\"lldt %w0\"::\"q\" (0));\n\telse {\n\t\tunsigned cpu = smp_processor_id();\n\t\tldt_desc ldt;\n\t\tset_tssldt_descriptor(&ldt, (unsigned long)addr,\n\t\t\t\t      DESC_LDT, entries * sizeof(ldt) - 1);\n\t\twrite_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_LDT,\n\t\t\t\t&ldt, DESC_LDT);\n\t\tasm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8));\n\t}\n}", "target": 1}
{"code": "irqreturn_t bnx2x_msix_sp_int(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tbnx2x_ack_sb(bp, bp->igu_dsb_id, USTORM_ID, 0,\n\t\t     IGU_INT_DISABLE, 0);\n#ifdef BNX2X_STOP_ON_ERROR\n\tif (unlikely(bp->panic))\n\t\treturn IRQ_HANDLED;\n#endif\n\tif (CNIC_LOADED(bp)) {\n\t\tstruct cnic_ops *c_ops;\n\t\trcu_read_lock();\n\t\tc_ops = rcu_dereference(bp->cnic_ops);\n\t\tif (c_ops)\n\t\t\tc_ops->cnic_handler(bp->cnic_data, NULL);\n\t\trcu_read_unlock();\n\t}\n\tbnx2x_schedule_sp_task(bp);\n\treturn IRQ_HANDLED;\n}", "target": 0}
{"code": "static void drive_file_fix_path(WCHAR* path)\n{\n\tsize_t i;\n\tsize_t length = _wcslen(path);\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (path[i] == L'\\\\')\n\t\t\tpath[i] = L'/';\n\t}\n#ifdef WIN32\n\tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n\t\treturn;\n#else\n\tif ((length == 1) && (path[0] == L'/'))\n\t\treturn;\n#endif\n\tif ((length > 0) && (path[length - 1] == L'/'))\n\t\tpath[length - 1] = L'\\0';\n}", "target": 1}
{"code": "push_spaces(struct readbuffer *obuf, int pre_mode, int width)\n{\n    int i;\n    if (width <= 0)\n\treturn;\n    check_breakpoint(obuf, pre_mode, \" \");\n    for (i = 0; i < width; i++)\n\tStrcat_char(obuf->line, ' ');\n    obuf->pos += width;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->flag |= RB_NFLUSHED;\n}", "target": 0}
{"code": "void smp_process_local_nonce(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n switch (p_cb->selected_association_model) {\n case SMP_MODEL_SEC_CONN_JUSTWORKS:\n case SMP_MODEL_SEC_CONN_NUM_COMP:\n if (p_cb->role == HCI_ROLE_SLAVE) {\n        smp_calculate_local_commitment(p_cb);\n        smp_send_commitment(p_cb, NULL);\n        smp_set_state(SMP_STATE_WAIT_NONCE);\n } else \n {\n if (p_cb->flags & SMP_PAIR_FLAG_HAVE_PEER_COMM) {\n          SMP_TRACE_DEBUG(\n \"master in assoc mode = %d \"\n \"already rcvd slave commitment - race condition\",\n              p_cb->selected_association_model);\n          p_cb->flags &= ~SMP_PAIR_FLAG_HAVE_PEER_COMM;\n          smp_send_rand(p_cb, NULL);\n          smp_set_state(SMP_STATE_WAIT_NONCE);\n }\n }\n break;\n case SMP_MODEL_SEC_CONN_PASSKEY_ENT:\n case SMP_MODEL_SEC_CONN_PASSKEY_DISP:\n      smp_calculate_local_commitment(p_cb);\n if (p_cb->role == HCI_ROLE_MASTER) {\n        smp_send_commitment(p_cb, NULL);\n } else \n {\n if (p_cb->flags & SMP_PAIR_FLAG_HAVE_PEER_COMM) {\n          smp_send_commitment(p_cb, NULL);\n          smp_set_state(SMP_STATE_WAIT_NONCE);\n }\n }\n break;\n case SMP_MODEL_SEC_CONN_OOB:\n if (p_cb->role == HCI_ROLE_MASTER) {\n        smp_send_rand(p_cb, NULL);\n }\n      smp_set_state(SMP_STATE_WAIT_NONCE);\n break;\n default:\n      SMP_TRACE_ERROR(\"Association Model = %d is not used in LE SC\",\n                      p_cb->selected_association_model);\n break;\n }\n}", "target": 0}
{"code": "  NoStartupWindowTest() {}", "target": 0}
{"code": "gen_S(codegen_scope *s, uint16_t i)\n{\n  emit_S(s, s->pc, i);\n  s->pc += 2;\n}", "target": 0}
{"code": "static int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}", "target": 0}
{"code": "elf_core_copy_task_xfpregs(struct task_struct *t, elf_fpxregset_t *xfpu)\n{\n\tstruct pt_regs *regs = task_pt_regs(t);\n\tif (!tsk_used_math(t))\n\t\treturn 0;\n\tif (t == current)\n\t\tunlazy_fpu(t); \n\tmemcpy(xfpu, &t->thread.i387.fxsave, sizeof(elf_fpxregset_t));\n\txfpu->fcs = regs->cs; \n\txfpu->fos = t->thread.ds;  \n\treturn 1;\n}", "target": 0}
{"code": "bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct btrfs_device *failing_dev)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tu64 next_start = 0;\n\tbool ret = true;\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, 0, (u64)-1);\n\tread_unlock(&map_tree->map_tree.lock);\n\tif (!em) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\twhile (em) {\n\t\tstruct map_lookup *map;\n\t\tint missing = 0;\n\t\tint max_tolerated;\n\t\tint i;\n\t\tmap = em->map_lookup;\n\t\tmax_tolerated =\n\t\t\tbtrfs_get_num_tolerated_disk_barrier_failures(\n\t\t\t\t\tmap->type);\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tstruct btrfs_device *dev = map->stripes[i].dev;\n\t\t\tif (!dev || !dev->bdev ||\n\t\t\t    test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state) ||\n\t\t\t    dev->last_flush_error)\n\t\t\t\tmissing++;\n\t\t\telse if (failing_dev && failing_dev == dev)\n\t\t\t\tmissing++;\n\t\t}\n\t\tif (missing > max_tolerated) {\n\t\t\tif (!failing_dev)\n\t\t\t\tbtrfs_warn(fs_info,\n\t\"chunk %llu missing %d devices, max tolerance is %d for writable mount\",\n\t\t\t\t   em->start, missing, max_tolerated);\n\t\t\tfree_extent_map(em);\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\t\tnext_start = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tread_lock(&map_tree->map_tree.lock);\n\t\tem = lookup_extent_mapping(&map_tree->map_tree, next_start,\n\t\t\t\t\t   (u64)(-1) - next_start);\n\t\tread_unlock(&map_tree->map_tree.lock);\n\t}\nout:\n\treturn ret;\n}", "target": 0}
{"code": "static void __net_exit ip6_route_net_exit(struct net *net)\n{\n\tkfree(net->ipv6.ip6_null_entry);\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tkfree(net->ipv6.ip6_prohibit_entry);\n\tkfree(net->ipv6.ip6_blk_hole_entry);\n#endif\n\tdst_entries_destroy(&net->ipv6.ip6_dst_ops);\n}", "target": 0}
{"code": "static int gaff_init(struct hid_device *hid)\n{\n\tstruct gaff_device *gaff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct list_head *report_ptr = report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport_ptr = report_ptr->next;\n\treport = list_entry(report_ptr, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 6) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\tgaff = kzalloc(sizeof(struct gaff_device), GFP_KERNEL);\n\tif (!gaff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, gaff, hid_gaff_play);\n\tif (error) {\n\t\tkfree(gaff);\n\t\treturn error;\n\t}\n\tgaff->report = report;\n\tgaff->report->field[0]->value[0] = 0x51;\n\tgaff->report->field[0]->value[1] = 0x00;\n\tgaff->report->field[0]->value[2] = 0x00;\n\tgaff->report->field[0]->value[3] = 0x00;\n\thid_hw_request(hid, gaff->report, HID_REQ_SET_REPORT);\n\tgaff->report->field[0]->value[0] = 0xfa;\n\tgaff->report->field[0]->value[1] = 0xfe;\n\thid_hw_request(hid, gaff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force Feedback for GreenAsia 0x12 devices by Lukasz Lubojanski <lukasz@lubojanski.info>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static int php_zip_ops_close(php_stream *stream, int close_handle TSRMLS_DC)\n{\n\tSTREAM_DATA_FROM_STREAM();\n\tif (close_handle) {\n\t\tif (self->zf) {\n\t\t\tzip_fclose(self->zf);\n\t\t\tself->zf = NULL;\n\t\t}\n\t\tif (self->za) {\n\t\t\tzip_close(self->za);\n\t\t\tself->za = NULL;\n\t\t}\n\t}\n\tefree(self);\n\tstream->abstract = NULL;\n\treturn EOF;\n}", "target": 0}
{"code": "zend_bool php_std_auto_global_callback(char *name, uint name_len TSRMLS_DC)\n{\n\tzend_printf(\"%s\\n\", name);\n\treturn 0; \n}", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "void license_decrypt_platform_challenge(rdpLicense* license)\n{\n\tCryptoRc4 rc4;\n\tlicense->PlatformChallenge->data = (BYTE*) malloc(license->EncryptedPlatformChallenge->length);\n\tlicense->PlatformChallenge->length = license->EncryptedPlatformChallenge->length;\n\trc4 = crypto_rc4_init(license->LicensingEncryptionKey, LICENSING_ENCRYPTION_KEY_LENGTH);\n\tcrypto_rc4(rc4, license->EncryptedPlatformChallenge->length,\n\t\t\tlicense->EncryptedPlatformChallenge->data,\n\t\t\tlicense->PlatformChallenge->data);\n\tcrypto_rc4_free(rc4);\n}", "target": 0}
{"code": "save_fonteffect(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    if (obuf->fontstat_sp < FONT_STACK_SIZE)\n\tbcopy(obuf->fontstat, obuf->fontstat_stack[obuf->fontstat_sp],\n\t      FONTSTAT_SIZE);\n    obuf->fontstat_sp++;\n    if (obuf->in_bold)\n\tpush_tag(obuf, \"</b>\", HTML_N_B);\n    if (obuf->in_italic)\n\tpush_tag(obuf, \"</i>\", HTML_N_I);\n    if (obuf->in_under)\n\tpush_tag(obuf, \"</u>\", HTML_N_U);\n    if (obuf->in_strike)\n\tpush_tag(obuf, \"</s>\", HTML_N_S);\n    if (obuf->in_ins)\n\tpush_tag(obuf, \"</ins>\", HTML_N_INS);\n    bzero(obuf->fontstat, FONTSTAT_SIZE);\n}", "target": 0}
{"code": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    event = CreateEvent(isolate);\n  }\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}", "target": 1}
{"code": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "static void do_busid_cmd(ESPState *s, uint8_t busid)\n{\n    uint32_t cmdlen;\n    int32_t datalen;\n    int lun;\n    SCSIDevice *current_lun;\n    uint8_t buf[ESP_CMDFIFO_SZ];\n    trace_esp_do_busid_cmd(busid);\n    lun = busid & 7;\n    cmdlen = fifo8_num_used(&s->cmdfifo);\n    esp_fifo_pop_buf(&s->cmdfifo, buf, cmdlen);\n    current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, lun);\n    s->current_req = scsi_req_new(current_lun, 0, lun, buf, s);\n    datalen = scsi_req_enqueue(s->current_req);\n    s->ti_size = datalen;\n    fifo8_reset(&s->cmdfifo);\n    if (datalen != 0) {\n        s->rregs[ESP_RSTAT] = STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        s->ti_cmd = 0;\n        esp_set_tc(s, 0);\n        if (datalen > 0) {\n            s->data_in_ready = false;\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n        } else {\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            esp_raise_irq(s);\n            esp_lower_drq(s);\n        }\n        scsi_req_continue(s->current_req);\n        return;\n    }\n}", "target": 1}
{"code": "get_manuf_name(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    manuf_value = manuf_name_lookup(addr);\n    if (gbl_resolv_flags.mac_name && manuf_value->status != HASHETHER_STATUS_UNRESOLVED)\n        return manuf_value->resolved_name;\n    return manuf_value->hexaddr;\n} ", "target": 1}
{"code": "sc_oberthur_decode_usage(unsigned flags)\n{\n\tunsigned ret = 0;\n\tif (flags & OBERTHUR_ATTR_ENCRYPT)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_ENCRYPT;\n\tif (flags & OBERTHUR_ATTR_DECRYPT)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\tif (flags & OBERTHUR_ATTR_SIGN)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_SIGN;\n\tif (flags & OBERTHUR_ATTR_RSIGN)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_SIGNRECOVER;\n\tif (flags & OBERTHUR_ATTR_WRAP)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_WRAP;\n\tif (flags & OBERTHUR_ATTR_UNWRAP)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_UNWRAP;\n\tif (flags & OBERTHUR_ATTR_VERIFY)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_VERIFY;\n\tif (flags & OBERTHUR_ATTR_RVERIFY)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER;\n\tif (flags & OBERTHUR_ATTR_DERIVE)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_DERIVE;\n\treturn ret;\n}", "target": 0}
{"code": "static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\terr = udp_send_skb(skb, fl4);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}", "target": 1}
{"code": "void __init proc_root_init(void)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\tmnt = kern_mount_data(&proc_fs_type, &init_pid_ns);\n\tif (IS_ERR(mnt)) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\tinit_pid_ns.proc_mnt = mnt;\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\tproc_net_init();\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); \n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}", "target": 1}
{"code": " static blink::WebScreenOrientations stringToOrientations(const AtomicString& orientationString)\n {\n     DEFINE_STATIC_LOCAL(const AtomicString, portrait, (\"portrait\", AtomicString::ConstructFromLiteral));\n     DEFINE_STATIC_LOCAL(const AtomicString, landscape, (\"landscape\", AtomicString::ConstructFromLiteral));\n     if (orientationString == portrait)\n         return blink::WebScreenOrientationPortraitPrimary | blink::WebScreenOrientationPortraitSecondary;\n     if (orientationString == landscape)\n        return blink::WebScreenOrientationLandscapePrimary | blink::WebScreenOrientationLandscapeSecondary;\n    unsigned length = 0;\n    ScreenOrientationInfo* orientationMap = orientationsMap(length);\n    for (unsigned i = 0; i < length; ++i) {\n        if (orientationMap[i].name == orientationString)\n            return orientationMap[i].orientation;\n    }\n    return 0;\n}", "target": 1}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (WriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (WriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": "static struct socket *get_raw_socket(int fd)\n{\n\tstruct {\n\t\tstruct sockaddr_ll sa;\n\t\tchar  buf[MAX_ADDR_LEN];\n\t} uaddr;\n\tint r;\n\tstruct socket *sock = sockfd_lookup(fd, &r);\n\tif (!sock)\n\t\treturn ERR_PTR(-ENOTSOCK);\n\tif (sock->sk->sk_type != SOCK_RAW) {\n\t\tr = -ESOCKTNOSUPPORT;\n\t\tgoto err;\n\t}\n\tr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa, 0);\n\tif (r < 0)\n\t\tgoto err;\n\tif (uaddr.sa.sll_family != AF_PACKET) {\n\t\tr = -EPFNOSUPPORT;\n\t\tgoto err;\n\t}\n\treturn sock;\nerr:\n\tsockfd_put(sock);\n\treturn ERR_PTR(r);\n}", "target": 1}
{"code": "int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}", "target": 1}
{"code": "zzip_disk_entry_fopen (ZZIP_DISK* disk, ZZIP_DISK_ENTRY* entry)\n{\n    ZZIP_DISK_FILE* file = malloc(sizeof(ZZIP_DISK_FILE));\n    if (! file) return file;\n    file->buffer = disk->buffer;\n    file->endbuf = disk->endbuf;\n    file->header = zzip_disk_entry_to_file_header (disk, entry);\n    if (! file->header) { free (file); return 0; }\n    file->avail = zzip_file_header_usize (file->header);\n    if (! file->avail || zzip_file_header_data_stored (file->header))\n    { file->stored = zzip_file_header_to_data (file->header); return file; }\n    file->stored = 0;\n    file->zlib.opaque = 0;\n    file->zlib.zalloc = Z_NULL;\n    file->zlib.zfree = Z_NULL;\n    file->zlib.avail_in = zzip_file_header_csize (file->header);\n    file->zlib.next_in = zzip_file_header_to_data (file->header);\n    if (! zzip_file_header_data_deflated (file->header) ||\n\tinflateInit2 (& file->zlib, -MAX_WBITS) != Z_OK)\n    { free (file); return 0; }\n    return file;\n}", "target": 1}
{"code": "int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tkey_check(key);\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\tdown_write(&key->sem);\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[kHeightRank];\n  const int input_width = input->dims->data[kWidthRank];\n  const int input_channels = input->dims->data[kDepthRank];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n  TfLiteEvalTensor* output_eval =\n      tflite::micro::GetEvalOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_OK(context, tflite::micro::CreateWritableTensorDimsWithCopy(\n                                 context, output, output_eval));\n  output->dims->data[kBatchRank] = input->dims->data[kBatchRank];\n  output->dims->data[kHeightRank] = output_height;\n  output->dims->data[kWidthRank] = output_width;\n  output->dims->data[kDepthRank] = output_channels;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}", "target": 1}
{"code": "htp_param_t *htp_tx_req_get_param_ex(htp_tx_t *tx, enum htp_data_source_t source, const char *name, size_t name_len) {\n    if ((tx == NULL) || (name == NULL)) return NULL;\n    htp_param_t *p = NULL;\n    for (size_t i = 0, n = htp_table_size(tx->request_params); i < n; i++) {\n        p = htp_table_get_index(tx->request_params, i, NULL);\n        if (p->source != source) continue;\n        if (bstr_cmp_mem_nocase(p->name, name, name_len) == 0) return p;\n    }\n    return NULL;\n}", "target": 0}
{"code": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct task_struct *rtn = current->group_leader;\n\tif ((event->sigev_notify & SIGEV_THREAD_ID ) &&\n\t\t(!(rtn = find_task_by_vpid(event->sigev_notify_thread_id)) ||\n\t\t !same_thread_group(rtn, current) ||\n\t\t (event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_SIGNAL))\n\t\treturn NULL;\n\tif (((event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE) &&\n\t    ((event->sigev_signo <= 0) || (event->sigev_signo > SIGRTMAX)))\n\t\treturn NULL;\n\treturn task_pid(rtn);\n}", "target": 1}
{"code": "gif_read_image(FILE       *fp,\t\t\n\t       image_t    *img,\t\t\n\t       gif_cmap_t cmap,\t\t\n\t       int        interlace,\t\n\t       int        transparent)\t\n{\n  uchar\t\tcode_size,\t\t\n\t\t*temp;\t\t\t\n  int\t\txpos,\t\t\t\n\t\typos,\t\t\t\n\t\tpass;\t\t\t\n  int\t\tpixel;\t\t\t\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n  if (code_size > 12)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Bad GIF file \\\"%s\\\" - invalid code size %d.\", img->filename, code_size);\n    return (-1);\n  }\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n  temp = img->pixels;\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n    if (ypos >= img->height)\n      break;\n  }\n  return (0);\n}", "target": 0}
{"code": "int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n\tstruct scsi_device *SDev;\n\tstruct scsi_sense_hdr sshdr;\n\tint result, err = 0, retries = 0;\n\tSDev = cd->device;\n      retry:\n\tif (!scsi_block_when_processing_errors(SDev)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen,\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n\t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n\tif (driver_byte(result) != 0) {\n\t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n      out:\n\tcgc->stat = err;\n\treturn err;\n}", "target": 1}
{"code": "coolkey_attribute_start(const u8 *obj, u8 object_record_type, size_t buf_len)\n{\n\tsize_t offset = object_record_type == COOLKEY_V1_OBJECT ? sizeof(coolkey_object_header_t) :\n\t\t\tsizeof(coolkey_v0_object_header_t);\n\tif ((object_record_type != COOLKEY_V1_OBJECT) && (object_record_type != COOLKEY_V0_OBJECT)) {\n\t\treturn NULL;\n\t}\n\tif (offset > buf_len) {\n\t\treturn NULL;\n\t}\n\treturn obj + offset;\n}", "target": 0}
{"code": "static void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\tdrive = 0;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY1_TYPE;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = UDP->cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tchar temparea[32];\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsnprintf(temparea, sizeof(temparea),\n\t\t\t\t \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\t*UDP = *params;\n\t}\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}", "target": 0}
{"code": " cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const cdf_directory_t *root_storage)\n {\n         cdf_summary_info_header_t si;\n         cdf_property_info_t *info;\n        size_t count;\n        int m;\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                 return -2;\n                         break;\n                 }\n\t\tif (root_storage) {\n\t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);\n\t\t\tif (str)\n\t\t\t\tif (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n        m = cdf_file_property_info(ms, info, count, root_storage);\n         free(info);\n         return m == -1 ? -2 : m;\n}", "target": 0}
{"code": "kick_jobs(tube t, unsigned int n)\n{\n    if (buried_job_p(t)) return kick_buried_jobs(t, n);\n    return kick_delayed_jobs(t, n);\n}", "target": 0}
{"code": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 1}
{"code": "static int snd_timer_register_system(void)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_system_private *priv;\n\tint err;\n\terr = snd_timer_global_new(\"system\", SNDRV_TIMER_GLOBAL_SYSTEM, &timer);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(timer->name, \"system timer\");\n\ttimer->hw = snd_timer_system;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL) {\n\t\tsnd_timer_free(timer);\n\t\treturn -ENOMEM;\n\t}\n\tsetup_timer(&priv->tlist, snd_timer_s_function, (unsigned long) timer);\n\ttimer->private_data = priv;\n\ttimer->private_free = snd_timer_free_system;\n\treturn snd_timer_global_register(timer);\n}", "target": 0}
{"code": "static ssize_t ext4_direct_IO_read(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\tinode_lock_shared(inode);\n\tret = filemap_write_and_wait_range(mapping, iocb->ki_pos,\n\t\t\t\t\t   iocb->ki_pos + count - 1);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t   iter, ext4_dio_get_block, NULL, NULL, 0);\nout_unlock:\n\tinode_unlock_shared(inode);\n\treturn ret;\n}", "target": 0}
{"code": "void GfxPath::lineTo(double x, double y)\n{\n    if (justMoved || (n > 0 && subpaths[n - 1]->isClosed())) {\n        if (n >= size) {\n            size *= 2;\n            subpaths = (GfxSubpath **)greallocn(subpaths, size, sizeof(GfxSubpath *));\n        }\n        if (justMoved) {\n            subpaths[n] = new GfxSubpath(firstX, firstY);\n        } else {\n            subpaths[n] = new GfxSubpath(subpaths[n - 1]->getLastX(), subpaths[n - 1]->getLastY());\n        }\n        ++n;\n        justMoved = false;\n    }\n    subpaths[n - 1]->lineTo(x, y);\n}", "target": 0}
{"code": "comics_document_thumbnails_get_dimensions (EvDocumentThumbnails *document,\n\t\t\t\t\t   EvRenderContext      *rc,\n\t\t\t\t\t   gint                 *width,\n\t\t\t\t\t   gint                 *height)\n{\n\tgdouble page_width, page_height;\n\tcomics_document_get_page_size (EV_DOCUMENT (document), rc->page,\n\t\t\t\t       &page_width, &page_height);\n\tif (rc->rotation == 90 || rc->rotation == 270) {\n\t\t*width = (gint) (page_height * rc->scale);\n\t\t*height = (gint) (page_width * rc->scale);\n\t} else {\n\t\t*width = (gint) (page_width * rc->scale);\n\t\t*height = (gint) (page_height * rc->scale);\n\t}\n}", "target": 1}
{"code": "string PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++);\n  return ret;\n}", "target": 1}
{"code": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}", "target": 1}
{"code": "Variant array_search(const Variant& needle,\n                     const Variant& haystack,\n                     bool strict ) {\n  Variant ret = false;\n  auto ok = strict ?\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::same(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; }) :\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::equal(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; });\n  if (UNLIKELY(!ok)) {\n    raise_warning(\"array_search() expects parameter 2 to be an array \"\n                  \"or collection\");\n    return init_null();\n  }\n  return ret;\n}", "target": 0}
{"code": "static int uas_find_uas_alt_setting(struct usb_interface *intf)\n{\n\tint i;\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt->desc.bAlternateSetting;\n\t}\n\treturn -ENODEV;\n}", "target": 1}
{"code": "static void initialize_typed_array_from_array_buffer(GlobalObject& global_object, TypedArrayBase& typed_array, ArrayBuffer& array_buffer, Value byte_offset, Value length)\n{\n    auto& vm = global_object.vm();\n    auto element_size = typed_array.element_size();\n    auto offset = byte_offset.to_index(global_object);\n    if (vm.exception())\n        return;\n    if (offset % element_size != 0) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);\n        return;\n    }\n    size_t new_length { 0 };\n    if (!length.is_undefined()) {\n        new_length = length.to_index(global_object);\n        if (vm.exception())\n            return;\n    }\n    auto buffer_byte_length = array_buffer.byte_length();\n    size_t new_byte_length;\n    if (length.is_undefined()) {\n        if (buffer_byte_length % element_size != 0) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size, buffer_byte_length);\n            return;\n        }\n        if (offset > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset, offset, buffer_byte_length);\n            return;\n        }\n        new_byte_length = buffer_byte_length - offset;\n    } else {\n        new_byte_length = new_length * element_size;\n        if (offset + new_byte_length > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength, offset, offset + new_byte_length, buffer_byte_length);\n            return;\n        }\n    }\n    typed_array.set_viewed_array_buffer(&array_buffer);\n    typed_array.set_byte_length(new_byte_length);\n    typed_array.set_byte_offset(offset);\n    typed_array.set_array_length(new_byte_length / element_size);\n}", "target": 1}
{"code": "static void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}", "target": 1}
{"code": "bool InstanceKlass::should_be_initialized() const {\n  return !is_initialized();\n}", "target": 0}
{"code": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}", "target": 1}
{"code": "PHP_PGSQL_API int php_pgsql_delete(PGconn *pg_link, const char *table, zval *ids_array, zend_ulong opt, zend_string **sql) \n{\n\tzval ids_converted;\n\tsmart_str querystr = {0};\n\tint ret = FAILURE;\n\tassert(pg_link != NULL);\n\tassert(table != NULL);\n\tassert(Z_TYPE_P(ids_array) == IS_ARRAY);\n\tassert(!(opt & ~(PGSQL_CONV_FORCE_NULL|PGSQL_DML_EXEC|PGSQL_DML_STRING|PGSQL_DML_ESCAPE)));\n\tif (zend_hash_num_elements(Z_ARRVAL_P(ids_array)) == 0) {\n\t\treturn FAILURE;\n\t}\n\tZVAL_UNDEF(&ids_converted);\n\tif (!(opt & (PGSQL_DML_NO_CONV|PGSQL_DML_ESCAPE))) {\n\t\tarray_init(&ids_converted);\n\t\tif (php_pgsql_convert(pg_link, table, ids_array, &ids_converted, (opt & PGSQL_CONV_OPTS)) == FAILURE) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tids_array = &ids_converted;\n\t}\n\tsmart_str_appends(&querystr, \"DELETE FROM \");\n\tbuild_tablename(&querystr, pg_link, table);\n\tsmart_str_appends(&querystr, \" WHERE \");\n\tif (build_assignment_string(pg_link, &querystr, Z_ARRVAL_P(ids_array), 1, \" AND \", sizeof(\" AND \")-1, opt))\n\t\tgoto cleanup;\n\tsmart_str_appendc(&querystr, ';');\n\tsmart_str_0(&querystr);\n\tif ((opt & PGSQL_DML_EXEC) && do_exec(&querystr, PGRES_COMMAND_OK, pg_link, opt) == 0) {\n\t\tret = SUCCESS;\n\t} else if (opt & PGSQL_DML_STRING) {\n\t\tret = SUCCESS;\n\t}\ncleanup:\n\tzval_ptr_dtor(&ids_converted);\n\tif (ret == SUCCESS && (opt & PGSQL_DML_STRING)) {\n\t\t*sql = querystr.s;\n\t}\n\telse {\n\t\tsmart_str_free(&querystr);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "int rta_addattr16(struct rtattr *rta, int maxlen, int type, __u16 data)\n{\n\treturn rta_addattr_l(rta, maxlen, type, &data, sizeof(__u16));\n}", "target": 0}
{"code": "static bool tailmatch(const char *little, const char *bigone)\n{\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n  if(littlelen > biglen)\n    return FALSE;\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n}", "target": 1}
{"code": "gdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdFree(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tgdFree(tmp_im);\n\treturn dst;\n}", "target": 1}
{"code": "    CommentValue::CommentValue()\n        : StringValueBase(Exiv2::undefined), byteOrder_(littleEndian)\n    {\n    }", "target": 0}
{"code": "allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\tbuf->tr = tr;\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\treturn -ENOMEM;\n\t}\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\treturn 0;\n}", "target": 1}
{"code": "static int cg_rmdir(const char *path)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",\n\t\t\tcontroller, cgdir, path);\n\tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "void traverse_commit_list(struct rev_info *revs,\n\t\t\t  show_commit_fn show_commit,\n\t\t\t  show_object_fn show_object,\n\t\t\t  void *data)\n{\n\tint i;\n\tstruct commit *commit;\n\tstruct strbuf base;\n\tstrbuf_init(&base, PATH_MAX);\n\twhile ((commit = get_revision(revs)) != NULL) {\n\t\tif (commit->tree)\n\t\t\tadd_pending_tree(revs, commit->tree);\n\t\tshow_commit(commit, data);\n\t}\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *pending = revs->pending.objects + i;\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tconst char *path = pending->path;\n\t\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\t\tcontinue;\n\t\tif (obj->type == OBJ_TAG) {\n\t\t\tobj->flags |= SEEN;\n\t\t\tshow_object(obj, NULL, name, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!path)\n\t\t\tpath = \"\";\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tprocess_tree(revs, (struct tree *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tprocess_blob(revs, (struct blob *)obj, show_object,\n\t\t\t\t     NULL, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\",\n\t\t    oid_to_hex(&obj->oid), name);\n\t}\n\tobject_array_clear(&revs->pending);\n\tstrbuf_release(&base);\n}", "target": 1}
{"code": "  const std::string& get_tenant() const {\n    ceph_assert(t != Wildcard);\n    return u.tenant;\n  }", "target": 1}
{"code": "static void reset_fdc_info(int mode)\n{\n\tint drive;\n\tFDCS->spec1 = FDCS->spec2 = -1;\n\tFDCS->need_configure = 1;\n\tFDCS->perp_mode = 1;\n\tFDCS->rawcmd = 0;\n\tfor (drive = 0; drive < N_DRIVE; drive++)\n\t\tif (FDC(drive) == fdc && (mode || UDRS->track != NEED_1_RECAL))\n\t\t\tUDRS->track = NEED_2_RECAL;\n}", "target": 0}
{"code": "SWFShape_setLineStyle_internal(SWFShape shape, unsigned short width,\n                      byte r, byte g, byte b, byte a)\n{\n\tint line;\n\tif ( shape->isEnded )\n\t\treturn;\n\tfor ( line=0; line<shape->nLines; ++line )\n\t{\n\t\tif ( SWFLineStyle_equals(shape->lines[line], width, r, g, b, a, 0) )\n\t\t\tbreak;\n\t}\n\tif ( line == shape->nLines )\n\t\tline = SWFShape_addLineStyle(shape, width, r, g, b, a);\n\telse\n\t\t++line;\n\tfinishSetLine(shape, line, width);\n}", "target": 0}
{"code": "void Document::ImplicitClose() {\n  DCHECK(!InStyleRecalc());\n  DCHECK(parser_);\n  load_event_progress_ = kLoadEventInProgress;\n  DetachParser();\n  if (SvgExtensions())\n    AccessSVGExtensions().DispatchSVGLoadEventToOutermostSVGElements();\n  if (domWindow())\n    domWindow()->DocumentWasClosed();\n  if (GetFrame()) {\n    GetFrame()->Client()->DispatchDidHandleOnloadEvents();\n    Loader()->GetApplicationCacheHost()->StopDeferringEvents();\n  }\n  if (!GetFrame()) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (GetFrame()->GetNavigationScheduler().LocationChangePending() &&\n      ElapsedTime() < kCLayoutScheduleThreshold) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (!LocalOwner() || (LocalOwner()->GetLayoutObject() &&\n                        !LocalOwner()->GetLayoutObject()->NeedsLayout())) {\n    UpdateStyleAndLayoutTree();\n    if (View() && !GetLayoutViewItem().IsNull() &&\n        (!GetLayoutViewItem().FirstChild() ||\n         GetLayoutViewItem().NeedsLayout()))\n      View()->UpdateLayout();\n  }\n  load_event_progress_ = kLoadEventCompleted;\n  if (GetFrame() && !GetLayoutViewItem().IsNull() &&\n      GetSettings()->GetAccessibilityEnabled()) {\n    if (AXObjectCache* cache = GetOrCreateAXObjectCache()) {\n      if (this == &AXObjectCacheOwner())\n        cache->HandleLoadComplete(this);\n      else\n        cache->HandleLayoutComplete(this);\n    }\n  }\n  if (SvgExtensions())\n    AccessSVGExtensions().StartAnimations();\n}", "target": 0}
{"code": "Method* ciEnv::lookup_method(ciInstanceKlass* accessor,\n                             ciKlass*         holder,\n                             Symbol*          name,\n                             Symbol*          sig,\n                             Bytecodes::Code  bc,\n                             constantTag      tag) {\n  InstanceKlass* accessor_klass = accessor->get_instanceKlass();\n  Klass* holder_klass = holder->get_Klass();\n  assert(check_klass_accessibility(accessor, holder_klass), \"holder not accessible\");\n  LinkInfo link_info(holder_klass, name, sig, accessor_klass,\n                     LinkInfo::AccessCheck::required,\n                     LinkInfo::LoaderConstraintCheck::required,\n                     tag);\n  switch (bc) {\n    case Bytecodes::_invokestatic:\n      return LinkResolver::resolve_static_call_or_null(link_info);\n    case Bytecodes::_invokespecial:\n      return LinkResolver::resolve_special_call_or_null(link_info);\n    case Bytecodes::_invokeinterface:\n      return LinkResolver::linktime_resolve_interface_method_or_null(link_info);\n    case Bytecodes::_invokevirtual:\n      return LinkResolver::linktime_resolve_virtual_method_or_null(link_info);\n    default:\n      fatal(\"Unhandled bytecode: %s\", Bytecodes::name(bc));\n      return NULL; \n  }\n}", "target": 0}
{"code": "bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}", "target": 1}
{"code": "static void cliRefreshPrompt(void) {\n    int len;\n    if (config.eval_ldb) return;\n    if (config.hostsocket != NULL)\n        len = snprintf(config.prompt,sizeof(config.prompt),\"redis %s\",\n                       config.hostsocket);\n    else\n        len = anetFormatAddr(config.prompt, sizeof(config.prompt),\n                           config.hostip, config.hostport);\n    if (config.dbnum != 0)\n        len += snprintf(config.prompt+len,sizeof(config.prompt)-len,\"[%d]\",\n            config.dbnum);\n    snprintf(config.prompt+len,sizeof(config.prompt)-len,\"> \");\n}", "target": 1}
{"code": "static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t\t\t  __be16 sport, __be16 dport   )\n{\n\treturn secure_tcpv6_sequence_number(saddr, daddr, sport, dport);\n}", "target": 1}
{"code": "static int nf_tables_set_alloc_name(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t    const char *name)\n{\n\tconst struct nft_set *i;\n\tconst char *p;\n\tunsigned long *inuse;\n\tunsigned int n = 0, min = 0;\n\tp = strnchr(name, IFNAMSIZ, '%');\n\tif (p != NULL) {\n\t\tif (p[1] != 'd' || strchr(p + 2, '%'))\n\t\t\treturn -EINVAL;\n\t\tinuse = (unsigned long *)get_zeroed_page(GFP_KERNEL);\n\t\tif (inuse == NULL)\n\t\t\treturn -ENOMEM;\ncont:\n\t\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\t\tint tmp;\n\t\t\tif (!sscanf(i->name, name, &tmp))\n\t\t\t\tcontinue;\n\t\t\tif (tmp < min || tmp >= min + BITS_PER_BYTE * PAGE_SIZE)\n\t\t\t\tcontinue;\n\t\t\tset_bit(tmp - min, inuse);\n\t\t}\n\t\tn = find_first_zero_bit(inuse, BITS_PER_BYTE * PAGE_SIZE);\n\t\tif (n >= BITS_PER_BYTE * PAGE_SIZE) {\n\t\t\tmin += BITS_PER_BYTE * PAGE_SIZE;\n\t\t\tmemset(inuse, 0, PAGE_SIZE);\n\t\t\tgoto cont;\n\t\t}\n\t\tfree_page((unsigned long)inuse);\n\t}\n\tsnprintf(set->name, sizeof(set->name), name, min + n);\n\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\tif (!strcmp(set->name, i->name))\n\t\t\treturn -ENFILE;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "bool IsRelativeSymlinkSafe(CommandData *Cmd,const wchar *SrcName,const wchar *PrepSrcName,const wchar *TargetName)\n{\n  if (IsFullRootPath(SrcName) || IsFullRootPath(TargetName))\n    return false;\n  int UpLevels=0;\n  for (int Pos=0;*TargetName!=0;Pos++)\n  {\n    bool Dot2=TargetName[0]=='.' && TargetName[1]=='.' && \n              (IsPathDiv(TargetName[2]) || TargetName[2]==0) &&\n              (Pos==0 || IsPathDiv(*(TargetName-1)));\n    if (Dot2)\n      UpLevels++;\n    TargetName++;\n  }\n  if (UpLevels>0 && LinkInPath(PrepSrcName))\n    return false;\n  int AllowedDepth=CalcAllowedDepth(SrcName); \n  size_t ExtrPathLength=wcslen(Cmd->ExtrPath);\n  if (ExtrPathLength>0 && wcsncmp(PrepSrcName,Cmd->ExtrPath,ExtrPathLength)==0)\n  {\n    PrepSrcName+=ExtrPathLength;\n    while (IsPathDiv(*PrepSrcName))\n      PrepSrcName++;\n  }\n  int PrepAllowedDepth=CalcAllowedDepth(PrepSrcName);\n  return AllowedDepth>=UpLevels && PrepAllowedDepth>=UpLevels;\n}", "target": 1}
{"code": " */\nPHP_MINFO_FUNCTION(spl)\n{\n\tzval list;\n\tchar *strg;\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"SPL support\",        \"enabled\");\n\tINIT_PZVAL(&list);\n\tarray_init(&list);\n\tSPL_LIST_CLASSES(&list, 0, 1, ZEND_ACC_INTERFACE)\n\tstrg = estrdup(\"\");\n\tzend_hash_apply_with_argument(Z_ARRVAL_P(&list), (apply_func_arg_t)spl_build_class_list_string, &strg TSRMLS_CC);\n\tzval_dtor(&list);\n\tphp_info_print_table_row(2, \"Interfaces\", strg + 2);\n\tefree(strg);\n\tINIT_PZVAL(&list);\n\tarray_init(&list);\n\tSPL_LIST_CLASSES(&list, 0, -1, ZEND_ACC_INTERFACE)\n\tstrg = estrdup(\"\");\n\tzend_hash_apply_with_argument(Z_ARRVAL_P(&list), (apply_func_arg_t)spl_build_class_list_string, &strg TSRMLS_CC);\n\tzval_dtor(&list);\n\tphp_info_print_table_row(2, \"Classes\", strg + 2);\n\tefree(strg);\n\tphp_info_print_table_end();", "target": 0}
{"code": "static inline int quic_token_validate(struct quic_rx_packet *pkt,\n                                      struct quic_dgram *dgram,\n                                      struct listener *l, struct quic_conn *qc,\n                                      struct quic_cid *odcid)\n{\n\tint ret = 0;\n\tTRACE_ENTER(QUIC_EV_CONN_LPKT, qc);\n\tswitch (*pkt->token) {\n\tcase QUIC_TOKEN_FMT_RETRY:\n\t\tret = quic_retry_token_check(pkt, dgram, l, qc, odcid);\n\t\tbreak;\n\tcase QUIC_TOKEN_FMT_NEW:\n\t\tret = quic_token_check(pkt, dgram, qc);\n\t\tif (!ret) {\n\t\t\tdgram->flags |= QUIC_DGRAM_FL_SEND_RETRY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTRACE_PROTO(\"Packet dropped\", QUIC_EV_CONN_LPKT, qc, NULL, NULL, pkt->version);\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tgoto err;\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_LPKT, qc);\n\treturn ret;\n err:\n\tTRACE_DEVEL(\"leaving in error\", QUIC_EV_CONN_LPKT, qc);\n\tgoto leave;\n}", "target": 0}
{"code": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "perf_event_set_output(struct perf_event *event, struct perf_event *output_event)\n{\n\tstruct ring_buffer *rb = NULL, *old_rb = NULL;\n\tint ret = -EINVAL;\n\tif (!output_event)\n\t\tgoto set;\n\tif (event == output_event)\n\t\tgoto out;\n\tif (output_event->cpu != event->cpu)\n\t\tgoto out;\n\tif (output_event->cpu == -1 && output_event->ctx != event->ctx)\n\t\tgoto out;\nset:\n\tmutex_lock(&event->mmap_mutex);\n\tif (atomic_read(&event->mmap_count))\n\t\tgoto unlock;\n\tif (output_event) {\n\t\trb = ring_buffer_get(output_event);\n\t\tif (!rb)\n\t\t\tgoto unlock;\n\t}\n\told_rb = event->rb;\n\trcu_assign_pointer(event->rb, rb);\n\tif (old_rb)\n\t\tring_buffer_detach(event, old_rb);\n\tret = 0;\nunlock:\n\tmutex_unlock(&event->mmap_mutex);\n\tif (old_rb)\n\t\tring_buffer_put(old_rb);\nout:\n\treturn ret;\n}", "target": 0}
{"code": "static inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tnfsdstats.nfs4_opcount[opnum]++;\n}", "target": 0}
{"code": "entityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: \n      default:\n        break;\n      }\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n      *nextPtr = next;\n      s = next;\n    }\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}", "target": 1}
{"code": "static int hclge_tm_schd_mode_vnet_base_cfg(struct hclge_vport *vport)\n{\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\tu8 i;\n\tret = hclge_tm_pri_schd_mode_cfg(hdev, vport->vport_id);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < kinfo->num_tc; i++) {\n\t\tu8 sch_mode = hdev->tm_info.tc_info[i].tc_sch_mode;\n\t\tret = hclge_tm_qs_schd_mode_cfg(hdev, vport->qs_offset + i,\n\t\t\t\t\t\tsch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\tif (ctxt) {\n\t\tzend_bool old;\n\t\tctxt->keepBlanks = 0;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\told = php_libxml_disable_entity_loader(1);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\treturn (attr->attrib_type);\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &subtwolen );\n        bson_append_byte( b, type );\n        bson_append32( b, &len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "static unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n  unsigned char\n    *compact_pixels;\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n    }\n  return(compact_pixels);\n}", "target": 1}
{"code": "static int sco_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tu32 phys;\n\tint pkt_status;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_VOICE:\n\t\tvoice.setting = sco_pi(sk)->setting;\n\t\tlen = min_t(unsigned int, len, sizeof(voice));\n\t\tif (copy_to_user(optval, (char *)&voice, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_PHY:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tphys = hci_conn_get_phy(sco_pi(sk)->conn->hcon);\n\t\tif (put_user(phys, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_PKT_STATUS:\n\t\tpkt_status = (sco_pi(sk)->cmsg_mask & SCO_CMSG_PKT_STATUS);\n\t\tif (put_user(pkt_status, (int __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_SNDMTU:\n\tcase BT_RCVMTU:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(sco_pi(sk)->conn->mtu, (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "mono_loader_set_error_method_load (const char *class_name, const char *member_name)\n{\n\tMonoLoaderError *error;\n\tif (mono_loader_get_last_error ())\n\t\treturn;\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_MISSING_METHOD;\n\terror->class_name = g_strdup (class_name);\n\terror->member_name = member_name;\n\tset_loader_error (error);\n}", "target": 0}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    LutContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    AVFrame *out;\n    uint8_t *inrow, *outrow, *inrow0, *outrow0;\n    int i, j, plane, direct = 0;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    if (s->is_rgb) {\n        inrow0  = in ->data[0];\n        outrow0 = out->data[0];\n        for (i = 0; i < in->height; i ++) {\n            int w = inlink->w;\n            const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;\n            inrow  = inrow0;\n            outrow = outrow0;\n            for (j = 0; j < w; j++) {\n                switch (s->step) {\n                case 4:  outrow[3] = tab[3][inrow[3]]; \n                case 3:  outrow[2] = tab[2][inrow[2]]; \n                case 2:  outrow[1] = tab[1][inrow[1]]; \n                default: outrow[0] = tab[0][inrow[0]];\n                }\n                outrow += s->step;\n                inrow  += s->step;\n            }\n            inrow0  += in ->linesize[0];\n            outrow0 += out->linesize[0];\n        }\n    } else {\n        for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n            int vsub = plane == 1 || plane == 2 ? s->vsub : 0;\n            int hsub = plane == 1 || plane == 2 ? s->hsub : 0;\n            int h = FF_CEIL_RSHIFT(inlink->h, vsub);\n            int w = FF_CEIL_RSHIFT(inlink->w, hsub);\n            inrow  = in ->data[plane];\n            outrow = out->data[plane];\n            for (i = 0; i < h; i++) {\n                const uint8_t *tab = s->lut[plane];\n                for (j = 0; j < w; j++)\n                    outrow[j] = tab[inrow[j]];\n                inrow  += in ->linesize[plane];\n                outrow += out->linesize[plane];\n            }\n        }\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "int setup_conds(THD *thd, TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                COND **conds)\n{\n  SELECT_LEX *select_lex= thd->lex->current_select;\n  TABLE_LIST *table= NULL;\t\n  bool it_is_update= (select_lex == &thd->lex->select_lex) &&\n    thd->lex->which_check_option_applicable();\n  bool save_is_item_list_lookup= select_lex->is_item_list_lookup;\n  TABLE_LIST *derived= select_lex->master_unit()->derived;\n  DBUG_ENTER(\"setup_conds\");\n  if (derived && derived->merged)\n    DBUG_RETURN(0);\n  select_lex->is_item_list_lookup= 0;\n  thd->mark_used_columns= MARK_COLUMNS_READ;\n  DBUG_PRINT(\"info\", (\"thd->mark_used_columns: %d\", thd->mark_used_columns));\n  select_lex->cond_count= 0;\n  select_lex->between_count= 0;\n  select_lex->max_equal_elems= 0;\n  for (table= tables; table; table= table->next_local)\n  {\n    if (select_lex == &thd->lex->select_lex &&\n        select_lex->first_cond_optimization &&\n        table->merged_for_insert &&\n        table->prepare_where(thd, conds, FALSE))\n      goto err_no_arena;\n  }\n  if (*conds)\n  {\n    thd->where=\"where clause\";\n    DBUG_EXECUTE(\"where\",\n                 print_where(*conds,\n                             \"WHERE in setup_conds\",\n                             QT_ORDINARY););\n    if ((*conds)->type() == Item::FIELD_ITEM && !derived)\n      wrap_ident(thd, conds);\n    (*conds)->mark_as_condition_AND_part(NO_JOIN_NEST);\n    if ((!(*conds)->fixed && (*conds)->fix_fields(thd, conds)) ||\n\t(*conds)->check_cols(1))\n      goto err_no_arena;\n  }\n  if (setup_on_expr(thd, tables, it_is_update))\n    goto err_no_arena;\n  if (!thd->stmt_arena->is_conventional())\n  {\n    select_lex->where= *conds;\n  }\n  thd->lex->current_select->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(MY_TEST(thd->is_error()));\nerr_no_arena:\n  select_lex->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(1);\n}", "target": 0}
{"code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\tbool success = true;\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\tfree(buffer);\n\treturn success;\n}", "target": 1}
{"code": "void prefetch_table(const void *tab, size_t len)\n{\n  const volatile byte *vtab = tab;\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)vtab[i + 0 * 32];\n      (void)vtab[i + 1 * 32];\n      (void)vtab[i + 2 * 32];\n      (void)vtab[i + 3 * 32];\n      (void)vtab[i + 4 * 32];\n      (void)vtab[i + 5 * 32];\n      (void)vtab[i + 6 * 32];\n      (void)vtab[i + 7 * 32];\n    }\n  (void)vtab[len - 1];\n}", "target": 1}
{"code": "static int pam_winbind_request_log(struct pwb_context *ctx,\n\t\t\t\t   int retval,\n\t\t\t\t   const char *user,\n\t\t\t\t   const char *fn)\n{\n\tswitch (retval) {\n\tcase PAM_AUTH_ERR:\n\t\t_pam_log(ctx, LOG_WARNING, \"user '%s' denied access \"\n\t\t\t \"(incorrect password or invalid membership)\", user);\n\t\treturn retval;\n\tcase PAM_ACCT_EXPIRED:\n\t\t_pam_log(ctx, LOG_WARNING, \"user '%s' account expired\",\n\t\t\t user);\n\t\treturn retval;\n\tcase PAM_AUTHTOK_EXPIRED:\n\t\t_pam_log(ctx, LOG_WARNING, \"user '%s' password expired\",\n\t\t\t user);\n\t\treturn retval;\n\tcase PAM_NEW_AUTHTOK_REQD:\n\t\t_pam_log(ctx, LOG_WARNING, \"user '%s' new password \"\n\t\t\t \"required\", user);\n\t\treturn retval;\n\tcase PAM_USER_UNKNOWN:\n\t\t_pam_log_debug(ctx, LOG_NOTICE, \"user '%s' not found\",\n\t\t\t       user);\n\t\tif (ctx->ctrl & WINBIND_UNKNOWN_OK_ARG) {\n\t\t\treturn PAM_IGNORE;\n\t\t}\n\t\treturn retval;\n\tcase PAM_SUCCESS:\n\t\tif (strcmp(fn, \"wbcLogonUser\") == 0) {\n\t\t\t_pam_log(ctx, LOG_NOTICE,\n\t\t\t\t \"user '%s' granted access\", user);\n\t\t} else {\n\t\t\t_pam_log(ctx, LOG_NOTICE,\n\t\t\t\t \"user '%s' OK\", user);\n\t\t}\n\t\treturn retval;\n\tdefault:\n\t\t_pam_log(ctx, LOG_ERR,\n\t\t\t \"internal module error (retval = %s(%d), user = '%s')\",\n\t\t\t_pam_error_code_str(retval), retval, user);\n\t\treturn retval;\n\t}\n}", "target": 0}
{"code": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "    inline double log2(const double x) {\n      const double base = std::log(2.0);\n      return std::log(x)/base;", "target": 0}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"atril-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 0}
{"code": "rb_reg_last_match(VALUE match)\n{\n    return rb_reg_nth_match(0, match);\n}", "target": 0}
{"code": "int dccp_disconnect(struct sock *sk, int flags)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint err = 0;\n\tconst int old_state = sk->sk_state;\n\tif (old_state != DCCP_CLOSED)\n\t\tdccp_set_state(sk, DCCP_CLOSED);\n\tif (old_state == DCCP_LISTEN) {\n\t\tinet_csk_listen_stop(sk);\n\t} else if (dccp_need_reset(old_state)) {\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\n\t\tsk->sk_err = ECONNRESET;\n\t} else if (old_state == DCCP_REQUESTING)\n\t\tsk->sk_err = ECONNRESET;\n\tdccp_clear_xmit_timers(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tif (sk->sk_send_head != NULL) {\n\t\t__kfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\tinet->inet_dport = 0;\n\tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\n\t\tinet_reset_saddr(sk);\n\tsk->sk_shutdown = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\ticsk->icsk_backoff = 0;\n\tinet_csk_delack_init(sk);\n\t__sk_dst_reset(sk);\n\tWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);\n\tsk->sk_error_report(sk);\n\treturn err;\n}", "target": 1}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p = key->payload.data;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}", "target": 0}
{"code": "static uint16_t nvme_tx(NvmeCtrl *n, NvmeSg *sg, uint8_t *ptr, uint32_t len,\n                        NvmeTxDirection dir)\n{\n    assert(sg->flags & NVME_SG_ALLOC);\n    if (sg->flags & NVME_SG_DMA) {\n        const MemTxAttrs attrs = MEMTXATTRS_UNSPECIFIED;\n        dma_addr_t residual;\n        if (dir == NVME_TX_DIRECTION_TO_DEVICE) {\n            dma_buf_write(ptr, len, &residual, &sg->qsg, attrs);\n        } else {\n            dma_buf_read(ptr, len, &residual, &sg->qsg, attrs);\n        }\n        if (unlikely(residual)) {\n            trace_pci_nvme_err_invalid_dma();\n            return NVME_INVALID_FIELD | NVME_DNR;\n        }\n    } else {\n        size_t bytes;\n        if (dir == NVME_TX_DIRECTION_TO_DEVICE) {\n            bytes = qemu_iovec_to_buf(&sg->iov, 0, ptr, len);\n        } else {\n            bytes = qemu_iovec_from_buf(&sg->iov, 0, ptr, len);\n        }\n        if (unlikely(bytes != len)) {\n            trace_pci_nvme_err_invalid_dma();\n            return NVME_INVALID_FIELD | NVME_DNR;\n        }\n    }\n    return NVME_SUCCESS;\n}", "target": 0}
{"code": "static const char *tls_dns_name(const GENERAL_NAME * gn)\n{\n\tconst char *dnsname;\n\tif (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {\n\t\tg_warning(\"Invalid ASN1 value type in subjectAltName\");\n\t\treturn NULL;\n\t}\n\tdnsname = (char *) ASN1_STRING_data(gn->d.ia5);\n\tif (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {\n\t\tg_warning(\"Internal NUL in subjectAltName\");\n\t\treturn NULL;\n\t}\n\treturn dnsname;\n}", "target": 0}
{"code": "    bool triggered() const { return m_triggered; }", "target": 0}
{"code": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_typed_array_prop_set(vm, array, index, num);\n    njs_set_number(setval, num);\n    return NJS_OK;\n}", "target": 1}
{"code": "int udp_lib_setsockopt(struct sock *sk, int level, int optname,\n\t\t       char __user *optval, unsigned int optlen,\n\t\t       int (*push_pending_frames)(struct sock *))\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tint val, valbool;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tvalbool = val ? 1 : 0;\n\tswitch (optname) {\n\tcase UDP_CORK:\n\t\tif (val != 0) {\n\t\t\tup->corkflag = 1;\n\t\t} else {\n\t\t\tup->corkflag = 0;\n\t\t\tlock_sock(sk);\n\t\t\tpush_pending_frames(sk);\n\t\t\trelease_sock(sk);\n\t\t}\n\t\tbreak;\n\tcase UDP_ENCAP:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\tcase UDP_ENCAP_ESPINUDP:\n\t\tcase UDP_ENCAP_ESPINUDP_NON_IKE:\n\t\t\tup->encap_rcv = xfrm4_udp_encap_rcv;\n\t\tcase UDP_ENCAP_L2TPINUDP:\n\t\t\tup->encap_type = val;\n\t\t\tudp_encap_enable();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase UDP_NO_CHECK6_TX:\n\t\tup->no_check6_tx = valbool;\n\t\tbreak;\n\tcase UDP_NO_CHECK6_RX:\n\t\tup->no_check6_rx = valbool;\n\t\tbreak;\n\tcase UDPLITE_SEND_CSCOV:\n\t\tif (!is_udplite)         \n\t\t\treturn -ENOPROTOOPT;\n\t\tif (val != 0 && val < 8) \n\t\t\tval = 8;\n\t\telse if (val > USHRT_MAX)\n\t\t\tval = USHRT_MAX;\n\t\tup->pcslen = val;\n\t\tup->pcflag |= UDPLITE_SEND_CC;\n\t\tbreak;\n\tcase UDPLITE_RECV_CSCOV:\n\t\tif (!is_udplite)         \n\t\t\treturn -ENOPROTOOPT;\n\t\tif (val != 0 && val < 8) \n\t\t\tval = 8;\n\t\telse if (val > USHRT_MAX)\n\t\t\tval = USHRT_MAX;\n\t\tup->pcrlen = val;\n\t\tup->pcflag |= UDPLITE_RECV_CC;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static struct sock *rfcomm_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)\n{\n\tstruct rfcomm_dlc *d;\n\tstruct sock *sk;\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &rfcomm_proto);\n\tif (!sk)\n\t\treturn NULL;\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\td = rfcomm_dlc_alloc(prio);\n\tif (!d) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\td->data_ready   = rfcomm_sk_data_ready;\n\td->state_change = rfcomm_sk_state_change;\n\trfcomm_pi(sk)->dlc = d;\n\td->owner = sk;\n\tsk->sk_destruct = rfcomm_sock_destruct;\n\tsk->sk_sndtimeo = RFCOMM_CONN_TIMEOUT;\n\tsk->sk_sndbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\tsk->sk_rcvbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = proto;\n\tsk->sk_state    = BT_OPEN;\n\tbt_sock_link(&rfcomm_sk_list, sk);\n\tBT_DBG(\"sk %p\", sk);\n\treturn sk;\n}", "target": 0}
{"code": "static void selinux_task_to_inode(struct task_struct *p,\n\t\t\t\t  struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tu32 sid = task_sid(p);\n\tspin_lock(&isec->lock);\n\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\tisec->sid = sid;\n\tisec->initialized = LABEL_INITIALIZED;\n\tspin_unlock(&isec->lock);\n}", "target": 0}
{"code": "TIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n    if( td->td_nstrips )\n        return td->td_nstrips;\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}", "target": 1}
{"code": "MP4::Properties::bitrate() const\n{\n  return d->bitrate;\n}", "target": 0}
{"code": "gb18030_code_to_mbclen(OnigCodePoint code)\n{\n       if ((code & 0xff000000) != 0) return 4;\n  else if ((code &   0xff0000) != 0) return ONIGERR_INVALID_CODE_POINT_VALUE;\n  else if ((code &     0xff00) != 0) return 2;\n  else {\n    if (GB18030_MAP[(int )(code & 0xff)] == CM)\n      return ONIGERR_INVALID_CODE_POINT_VALUE;\n    return 1;\n  }\n}", "target": 0}
{"code": "static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tms = 0;\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\tdec->state = JPC_MT;\n\treturn 1;\n}", "target": 0}
{"code": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\treturn 0;\n}", "target": 1}
{"code": "static int ax_close(struct net_device *dev)\n{\n\tstruct mkiss *ax = netdev_priv(dev);\n\tif (ax->tty)\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &ax->tty->flags);\n\tnetif_stop_queue(dev);\n\treturn 0;\n}", "target": 0}
{"code": "hb_ot_layout_build_glyph_classes (hb_face_t      *face,\n\t\t\t\t  uint16_t        num_total_glyphs,\n\t\t\t\t  hb_codepoint_t *glyphs,\n\t\t\t\t  unsigned char  *klasses,\n\t\t\t\t  uint16_t        count)\n{\n  if (HB_OBJECT_IS_INERT (face))\n    return;\n  hb_ot_layout_t *layout = &face->ot_layout;\n  if (HB_UNLIKELY (!count || !glyphs || !klasses))\n    return;\n  if (layout->new_gdef.len == 0) {\n    layout->new_gdef.klasses = (unsigned char *) calloc (num_total_glyphs, sizeof (unsigned char));\n    layout->new_gdef.len = count;\n  }\n  for (unsigned int i = 0; i < count; i++)\n    _hb_ot_layout_set_glyph_class (face, glyphs[i], (hb_ot_layout_glyph_class_t) klasses[i]);\n}", "target": 1}
{"code": "int lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\treturn 0;\n}", "target": 0}
{"code": "static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t\tpmd_t *pmd, unsigned int flags)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_chunk_trans_blocks(inode,\n\t\t\t\t\t\t\tPMD_SIZE / PAGE_SIZE));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_pmd_fault(vma, addr, pmd, flags,\n\t\t\t\text4_get_block_dax, ext4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "display_debug_macinfo (struct dwarf_section *section,\n\t\t       void *file ATTRIBUTE_UNUSED)\n{\n  unsigned char *start = section->start;\n  unsigned char *end = start + section->size;\n  unsigned char *curr = start;\n  enum dwarf_macinfo_record_type op;\n  introduce (section, false);\n  while (curr < end)\n    {\n      unsigned int lineno;\n      const unsigned char *string;\n      op = (enum dwarf_macinfo_record_type) *curr;\n      curr++;\n      switch (op)\n\t{\n\tcase DW_MACINFO_start_file:\n\t  {\n\t    unsigned int filenum;\n\t    READ_ULEB (lineno, curr, end);\n\t    READ_ULEB (filenum, curr, end);\n\t    printf (_(\" DW_MACINFO_start_file - lineno: %d filenum: %d\\n\"),\n\t\t    lineno, filenum);\n\t  }\n\t  break;\n\tcase DW_MACINFO_end_file:\n\t  printf (_(\" DW_MACINFO_end_file\\n\"));\n\t  break;\n\tcase DW_MACINFO_define:\n\t  READ_ULEB (lineno, curr, end);\n\t  string = curr;\n\t  curr += strnlen ((char *) string, end - string);\n\t  printf (_(\" DW_MACINFO_define - lineno : %d macro : %*s\\n\"),\n\t\t  lineno, (int) (curr - string), string);\n\t  if (curr < end)\n\t    curr++;\n\t  break;\n\tcase DW_MACINFO_undef:\n\t  READ_ULEB (lineno, curr, end);\n\t  string = curr;\n\t  curr += strnlen ((char *) string, end - string);\n\t  printf (_(\" DW_MACINFO_undef - lineno : %d macro : %*s\\n\"),\n\t\t  lineno, (int) (curr - string), string);\n\t  if (curr < end)\n\t    curr++;\n\t  break;\n\tcase DW_MACINFO_vendor_ext:\n\t  {\n\t    unsigned int constant;\n\t    READ_ULEB (constant, curr, end);\n\t    string = curr;\n\t    curr += strnlen ((char *) string, end - string);\n\t    printf (_(\" DW_MACINFO_vendor_ext - constant : %d string : %*s\\n\"),\n\t\t    constant, (int) (curr - string), string);\n\t    if (curr < end)\n\t      curr++;\n\t  }\n\t  break;\n\t}\n    }\n  return 1;\n}", "target": 0}
{"code": "TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 rowsperstrip;\n\tuint32 stripsperplane;\n\tuint32 stripinplane;\n\tuint16 plane;\n\tuint32 rows;\n\ttmsize_t stripsize;\n\tif (!TIFFCheckRead(tif,0))\n\t\treturn((tmsize_t)(-1));\n\tif (strip>=td->td_nstrips)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\n\t\t    (unsigned long)td->td_nstrips);\n\t\treturn((tmsize_t)(-1));\n\t}\n\trowsperstrip=td->td_rowsperstrip;\n\tif (rowsperstrip>td->td_imagelength)\n\t\trowsperstrip=td->td_imagelength;\n\tstripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip);\n\tstripinplane=(strip%stripsperplane);\n\tplane=(uint16)(strip/stripsperplane);\n\trows=td->td_imagelength-stripinplane*rowsperstrip;\n\tif (rows>rowsperstrip)\n\t\trows=rowsperstrip;\n\tstripsize=TIFFVStripSize(tif,rows);\n\tif (stripsize==0)\n\t\treturn((tmsize_t)(-1));\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= stripsize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,stripsize);\n        (*tif->tif_postdecode)(tif,buf,stripsize);\n        return (stripsize);\n    }\n\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\n\t\tstripsize=size;\n\tif (!TIFFFillStrip(tif,strip))\n\t\treturn((tmsize_t)(-1));\n\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n\t\treturn((tmsize_t)(-1));\n\t(*tif->tif_postdecode)(tif,buf,stripsize);\n\treturn(stripsize);\n}", "target": 1}
{"code": "unsigned short bebytes2ushort(const u8 *buf)\n{\n\tif (buf == NULL)\n\t\treturn 0U;\n\treturn (unsigned short) (buf[0] << 8 | buf[1]);\n}", "target": 0}
{"code": "static void write_response(ESPState *s)\n{\n    uint32_t n;\n    trace_esp_write_response(s->status);\n    fifo8_reset(&s->fifo);\n    esp_fifo_push(s, s->status);\n    esp_fifo_push(s, 0);\n    if (s->dma) {\n        if (s->dma_memory_write) {\n            s->dma_memory_write(s->dma_opaque,\n                                (uint8_t *)fifo8_pop_buf(&s->fifo, 2, &n), 2);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n        } else {\n            s->pdma_cb = write_response_pdma_cb;\n            esp_raise_drq(s);\n            return;\n        }\n    } else {\n        s->ti_size = 2;\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}", "target": 1}
{"code": "vrrp_print_data(void)\n{\n\tFILE *file = fopen (dump_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tdump_data_vrrp(file);\n\tfclose(file);\n}", "target": 1}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    native->size = 0;\n    native->free = NULL;\n    native->free_size = 0;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t\text4_end_io_unwritten);\n}", "target": 1}
{"code": "GF_Err gf_filter_add_event_listener(GF_Filter *filter, GF_FSEventListener *el)\n{\n\tGF_Err e;\n\tif (!filter || !filter->session || !el || !el->on_event) return GF_BAD_PARAM;\n\twhile (filter->session->in_event_listener) gf_sleep(1);\n\tgf_mx_p(filter->session->evt_mx);\n\tif (!filter->session->event_listeners) {\n\t\tfilter->session->event_listeners = gf_list_new();\n\t}\n\te = gf_list_add(filter->session->event_listeners, el);\n\tgf_mx_v(filter->session->evt_mx);\n\treturn e;\n}", "target": 0}
{"code": "static inline MagickBooleanType ValidatePixelCacheMorphology(\n  const Image *magick_restrict image)\n{\n  const CacheInfo\n    *magick_restrict cache_info;\n  const PixelChannelMap\n    *magick_restrict p,\n    *magick_restrict q;\n  cache_info=(CacheInfo *) image->cache;\n  p=image->channel_map;\n  q=cache_info->channel_map;\n  if ((image->storage_class != cache_info->storage_class) ||\n      (image->colorspace != cache_info->colorspace) ||\n      (image->alpha_trait != cache_info->alpha_trait) ||\n      (image->read_mask != cache_info->read_mask) ||\n      (image->write_mask != cache_info->write_mask) ||\n      (image->columns != cache_info->columns) ||\n      (image->rows != cache_info->rows) ||\n      (image->number_channels != cache_info->number_channels) ||\n      (memcmp(p,q,image->number_channels*sizeof(*p)) != 0) ||\n      (image->metacontent_extent != cache_info->metacontent_extent) ||\n      (cache_info->nexus_info == (NexusInfo **) NULL))\n    return(MagickFalse);\n  return(MagickTrue);\n}", "target": 0}
{"code": "static int transmit_skb(struct sk_buff *skb, struct caifsock *cf_sk,\n\t\t\tint noblock, long timeo)\n{\n\tstruct cfpkt *pkt;\n\tpkt = cfpkt_fromnative(CAIF_DIR_OUT, skb);\n\tmemset(skb->cb, 0, sizeof(struct caif_payload_info));\n\tcfpkt_set_prio(pkt, cf_sk->sk.sk_priority);\n\tif (cf_sk->layer.dn == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\treturn cf_sk->layer.dn->transmit(cf_sk->layer.dn, pkt);\n}", "target": 0}
{"code": "static int MVGMacroCompare(const void *target,const void *source)\n{\n  const char\n    *p,\n    *q;\n  p=(const char *) target;\n  q=(const char *) source;\n  return(strcmp(p,q));\n}", "target": 0}
{"code": "void ide_atapi_cmd_reply_end(IDEState *s)\n{\n    int byte_count_limit, size, ret;\n    while (s->packet_transfer_size > 0) {\n        trace_ide_atapi_cmd_reply_end(s, s->packet_transfer_size,\n                                      s->elementary_transfer_size,\n                                      s->io_buffer_index);\n        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {\n            if (!s->elementary_transfer_size) {\n                ret = cd_read_sector(s);\n                if (ret < 0) {\n                    ide_atapi_io_error(s, ret);\n                }\n                return;\n            } else {\n                ret = cd_read_sector_sync(s);\n                if (ret < 0) {\n                    ide_atapi_io_error(s, ret);\n                    return;\n                }\n            }\n        }\n        if (s->elementary_transfer_size > 0) {\n            size = s->cd_sector_size - s->io_buffer_index;\n            if (size > s->elementary_transfer_size)\n                size = s->elementary_transfer_size;\n        } else {\n            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;\n            ide_set_irq(s->bus);\n            byte_count_limit = atapi_byte_count_limit(s);\n            trace_ide_atapi_cmd_reply_end_bcl(s, byte_count_limit);\n            size = s->packet_transfer_size;\n            if (size > byte_count_limit) {\n                if (byte_count_limit & 1)\n                    byte_count_limit--;\n                size = byte_count_limit;\n            }\n            s->lcyl = size;\n            s->hcyl = size >> 8;\n            s->elementary_transfer_size = size;\n            if (s->lba != -1) {\n                if (size > (s->cd_sector_size - s->io_buffer_index))\n                    size = (s->cd_sector_size - s->io_buffer_index);\n            }\n            trace_ide_atapi_cmd_reply_end_new(s, s->status);\n        }\n        s->packet_transfer_size -= size;\n        s->elementary_transfer_size -= size;\n        s->io_buffer_index += size;\n        if (!ide_transfer_start_norecurse(s,\n                                          s->io_buffer + s->io_buffer_index - size,\n                                          size, ide_atapi_cmd_reply_end)) {\n            return;\n        }\n    }\n    trace_ide_atapi_cmd_reply_end_eot(s, s->status);\n    ide_atapi_cmd_ok(s);\n    ide_set_irq(s->bus);\n}", "target": 1}
{"code": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\tif (!acl)\n\t\tgoto set_acl;\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}", "target": 1}
{"code": "gen_k( gcry_mpi_t p, int small_k )\n{\n  gcry_mpi_t k = mpi_alloc_secure( 0 );\n  gcry_mpi_t temp = mpi_alloc( mpi_get_nlimbs(p) );\n  gcry_mpi_t p_1 = mpi_copy(p);\n  unsigned int orig_nbits = mpi_get_nbits(p);\n  unsigned int nbits, nbytes;\n  char *rndbuf = NULL;\n  if (small_k)\n    {\n      nbits = wiener_map( orig_nbits ) * 3 / 2;\n      if( nbits >= orig_nbits )\n        BUG();\n    }\n  else\n    nbits = orig_nbits;\n  nbytes = (nbits+7)/8;\n  if( DBG_CIPHER )\n    log_debug(\"choosing a random k\\n\");\n  mpi_sub_ui( p_1, p, 1);\n  for(;;)\n    {\n      if( !rndbuf || nbits < 32 )\n        {\n          xfree(rndbuf);\n          rndbuf = _gcry_random_bytes_secure( nbytes, GCRY_STRONG_RANDOM );\n        }\n      else\n        {\n          char *pp = _gcry_random_bytes_secure( 4, GCRY_STRONG_RANDOM );\n          memcpy( rndbuf, pp, 4 );\n          xfree(pp);\n\t}\n      _gcry_mpi_set_buffer( k, rndbuf, nbytes, 0 );\n      for(;;)\n        {\n          if( !(mpi_cmp( k, p_1 ) < 0) )  \n            {\n              if( DBG_CIPHER )\n                progress('+');\n              break; \n            }\n          if( !(mpi_cmp_ui( k, 0 ) > 0) )  \n            {\n              if( DBG_CIPHER )\n                progress('-');\n              break; \n            }\n          if (mpi_gcd( temp, k, p_1 ))\n            goto found;  \n          mpi_add_ui( k, k, 1 );\n          if( DBG_CIPHER )\n            progress('.');\n\t}\n    }\n found:\n  xfree (rndbuf);\n  if( DBG_CIPHER )\n    progress('\\n');\n  mpi_free(p_1);\n  mpi_free(temp);\n  return k;\n}", "target": 0}
{"code": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n}", "target": 1}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}", "target": 1}
{"code": "static bool get_user_list(struct torture_context *torture, char ***users)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tchar **u = NULL;\n\tuint32_t count;\n\tchar name[256];\n\tconst char *extra_data;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_LIST_USERS, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL extra data\");\n\tfor(count = 0;\n\t    next_token(&extra_data, name, \",\", sizeof(name));\n\t    count++)\n\t{\n\t\tu = talloc_realloc(torture, u, char *, count + 2);\n\t\tu[count+1] = NULL;\n\t\tu[count] = talloc_strdup(u, name);\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\t*users = u;\n\treturn true;\n}", "target": 0}
{"code": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}", "target": 1}
{"code": "unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,\n                                   const unsigned char* image, unsigned w, unsigned h,\n                                   const LodePNGColorMode* mode_in)\n{\n  LodePNGColorProfile prof;\n  unsigned error = 0;\n  unsigned i, n, palettebits, grey_ok, palette_ok;\n  lodepng_color_profile_init(&prof);\n  error = get_color_profile(&prof, image, w, h, mode_in);\n  if(error) return error;\n  mode_out->key_defined = 0;\n  if(prof.key && w * h <= 16) prof.alpha = 1; \n  grey_ok = !prof.colored && !prof.alpha; \n  n = prof.numcolors;\n  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));\n  palette_ok = n <= 256 && (n * 2 < w * h) && prof.bits <= 8;\n  if(w * h < n * 2) palette_ok = 0; \n  if(grey_ok && prof.bits <= palettebits) palette_ok = 0; \n  if(palette_ok)\n  {\n    unsigned char* p = prof.palette;\n    lodepng_palette_clear(mode_out); \n    for(i = 0; i < prof.numcolors; i++)\n    {\n      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);\n      if(error) break;\n    }\n    mode_out->colortype = LCT_PALETTE;\n    mode_out->bitdepth = palettebits;\n    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize\n        && mode_in->bitdepth == mode_out->bitdepth)\n    {\n      lodepng_color_mode_cleanup(mode_out);\n      lodepng_color_mode_copy(mode_out, mode_in);\n    }\n  }\n  else \n  {\n    mode_out->bitdepth = prof.bits;\n    mode_out->colortype = prof.alpha ? (prof.colored ? LCT_RGBA : LCT_GREY_ALPHA)\n                                     : (prof.colored ? LCT_RGB : LCT_GREY);\n    if(prof.key && !prof.alpha)\n    {\n      unsigned mask = (1u << mode_out->bitdepth) - 1u; \n      mode_out->key_r = prof.key_r & mask;\n      mode_out->key_g = prof.key_g & mask;\n      mode_out->key_b = prof.key_b & mask;\n      mode_out->key_defined = 1;\n    }\n  }\n  return error;\n}", "target": 0}
{"code": "static void cleanup_key_data(context, count, data)\n    krb5_context   context;\n    int                    count;\n    krb5_key_data        * data;\n{\n    int i, j;\n    for (i = 0; i < count; i++)\n        for (j = 0; j < data[i].key_data_ver; j++)\n            if (data[i].key_data_length[j])\n                krb5_db_free(context, data[i].key_data_contents[j]);\n    krb5_db_free(context, data);\n}", "target": 0}
{"code": "FileSpec::FileSpec(const Object *fileSpecA)\n{\n  ok = true;\n  fileName = nullptr;\n  platformFileName = nullptr;\n  embFile = nullptr;\n  desc = nullptr;\n  fileSpec = fileSpecA->copy();\n  Object obj1 = getFileSpecName(fileSpecA);\n  if (!obj1.isString()) {\n    ok = false;\n    error(errSyntaxError, -1, \"Invalid FileSpec\");\n    return;\n  }\n  fileName = obj1.getString()->copy();\n  if (fileSpec.isDict()) {\n    obj1 = fileSpec.dictLookup(\"EF\");\n    if (obj1.isDict()) {\n      fileStream = obj1.dictLookupNF(\"F\");\n      if (!fileStream.isRef()) {\n        ok = false;\n        fileStream.setToNull();\n        error(errSyntaxError, -1, \"Invalid FileSpec: Embedded file stream is not an indirect reference\");\n        return;\n      }\n    }\n  }\n  obj1 = fileSpec.dictLookup(\"Desc\");\n  if (obj1.isString())\n    desc = obj1.getString()->copy();\n}", "target": 1}
{"code": "unquoted_glob_pattern_p (string)\n     register char *string;\n{\n  register int c;\n  char *send;\n  int open, bsquote;\n  DECLARE_MBSTATE;\n  open = bsquote = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string != '\\0' && *string != '/')\n\t    {\n\t      bsquote = 1;\n\t      string++;\n\t      continue;\n\t    }\n\t  else if (*string == 0)\n\t    return (0);\n\tcase CTLESC:\n\t  if (*string++ == '\\0')\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return ((bsquote && posix_glob_backslash) ? 2 : 0);\n}", "target": 1}
{"code": "static ssize_t ucma_migrate_id(struct ucma_file *new_file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_migrate_id cmd;\n\tstruct rdma_ucm_migrate_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct fd f;\n\tstruct ucma_file *cur_file;\n\tint ret = 0;\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\tf = fdget(cmd.fd);\n\tif (!f.file)\n\t\treturn -ENOENT;\n\tif (f.file->f_op != &ucma_fops) {\n\t\tret = -EINVAL;\n\t\tgoto file_put;\n\t}\n\tctx = ucma_get_ctx(f.file->private_data, cmd.id);\n\tif (IS_ERR(ctx)) {\n\t\tret = PTR_ERR(ctx);\n\t\tgoto file_put;\n\t}\n\trdma_lock_handler(ctx->cm_id);\n\tcur_file = ctx->file;\n\tif (cur_file == new_file) {\n\t\tmutex_lock(&cur_file->mut);\n\t\tresp.events_reported = ctx->events_reported;\n\t\tmutex_unlock(&cur_file->mut);\n\t\tgoto response;\n\t}\n\tucma_lock_files(cur_file, new_file);\n\txa_lock(&ctx_table);\n\tlist_move_tail(&ctx->list, &new_file->ctx_list);\n\tucma_move_events(ctx, new_file);\n\tctx->file = new_file;\n\tresp.events_reported = ctx->events_reported;\n\txa_unlock(&ctx_table);\n\tucma_unlock_files(cur_file, new_file);\nresponse:\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\trdma_unlock_handler(ctx->cm_id);\n\tucma_put_ctx(ctx);\nfile_put:\n\tfdput(f);\n\treturn ret;\n}", "target": 1}
{"code": "header_cache_t* imap_hcache_open (IMAP_DATA* idata, const char* path)\n{\n  IMAP_MBOX mx;\n  ciss_url_t url;\n  char cachepath[LONG_STRING];\n  char mbox[LONG_STRING];\n  if (path)\n    imap_cachepath (idata, path, mbox, sizeof (mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path (idata->ctx->path, &mx) < 0)\n      return NULL;\n    imap_cachepath (idata, mx.mbox, mbox, sizeof (mbox));\n    FREE (&mx.mbox);\n  }\n  mutt_account_tourl (&idata->conn->account, &url);\n  url.path = mbox;\n  url_ciss_tostring (&url, cachepath, sizeof (cachepath), U_PATH);\n  return mutt_hcache_open (HeaderCache, cachepath, imap_hcache_namer);\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_lo_write)\n{\n  \tzval *pgsql_id;\n  \tchar *str;\n  \tlong z_len;\n\tint str_len, nbytes;\n\tint len;\n\tpgLofp *pgsql;\n\tint argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"rs|l\", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (argc > 2) {\n\t\tif (z_len > str_len) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot write more than buffer size %d. Tried to write %ld\", str_len, z_len);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (z_len < 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Buffer size must be larger than 0, but %ld was specified\", z_len);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tlen = z_len;\n\t}\n\telse {\n\t\tlen = str_len;\n\t}\n\tZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, \"PostgreSQL large object\", le_lofp);\n\tif ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(nbytes);\n}", "target": 0}
{"code": "static int netbk_count_requests(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_tx_request *first,\n\t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n\tdo {\n\t\tif (frags >= work_to_do) {\n\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n\t\t       sizeof(*txp));\n\t\tif (txp->size > first->size) {\n\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tfirst->size -= txp->size;\n\t\tfrags++;\n\t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n\t\t\t\t txp->offset, txp->size);\n\t\t\treturn -frags;\n\t\t}\n\t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}", "target": 1}
{"code": "static const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)\n{\n    int offset = 0;\n    const uint8_t *ptr = NULL;\n    if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 || \n            asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))\n        goto end_get_sig;\n    if (asn1_sig[offset++] != ASN1_OCTET_STRING)\n        goto end_get_sig;\n    *len = get_asn1_length(asn1_sig, &offset);\n    ptr = &asn1_sig[offset];          \nend_get_sig:\n    return ptr;\n}", "target": 1}
{"code": "static inline int unserialize_allowed_class(zend_string *class_name, HashTable *classes)\n{\n\tzend_string *lcname;\n\tint res;\n\tALLOCA_FLAG(use_heap)\n\tif(classes == NULL) {\n\t\treturn 1;\n\t}\n\tif(!zend_hash_num_elements(classes)) {\n\t\treturn 0;\n\t}\n\tSTR_ALLOCA_ALLOC(lcname, class_name->len, use_heap);\n\tzend_str_tolower_copy(lcname->val, class_name->val, class_name->len);\n\tres = zend_hash_exists(classes, lcname);\n\tSTR_ALLOCA_FREE(lcname, use_heap);\n\treturn res;\n}", "target": 0}
{"code": "hb_buffer_destroy (hb_buffer_t *buffer)\n{\n  HB_OBJECT_DO_DESTROY (buffer);\n  hb_unicode_funcs_destroy (buffer->unicode);\n  free (buffer->info);\n  free (buffer->pos);\n  free (buffer);\n}", "target": 0}
{"code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}", "target": 1}
{"code": "static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, addr, R_BUF_SET);\n\tmodule->base_of_image = r_buf_read_le64 (b);\n\tmodule->size_of_image = r_buf_read_le32 (b);\n\tmodule->check_sum = r_buf_read_le32 (b);\n\tmodule->time_date_stamp = r_buf_read_le32 (b);\n\tmodule->module_name_rva = r_buf_read_le32 (b);\n\tmodule->version_info.dw_signature = r_buf_read_le32 (b);\n\tmodule->version_info.dw_struc_version = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags_mask = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_os = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_type = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_subtype = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ls = r_buf_read_le32 (b);\n\tmodule->cv_record.data_size = r_buf_read_le32 (b);\n\tmodule->cv_record.rva = r_buf_read_le32 (b);\n\tmodule->misc_record.data_size = r_buf_read_le32 (b);\n\tmodule->misc_record.rva = r_buf_read_le32 (b);\n\tmodule->reserved_0 = r_buf_read_le64 (b);\n\tmodule->reserved_1 = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}", "target": 1}
{"code": "static inline void skb_get_timestampns(const struct sk_buff *skb,\n\t\t\t\t       struct timespec *stamp)\n{\n\t*stamp = ktime_to_timespec(skb->tstamp);\n}", "target": 0}
{"code": "util_write_callback(int flags, char *ptr, size_t size, size_t nmemb, void *stream)\n{\n    CurlObject *self;\n    PyObject *arglist;\n    PyObject *result = NULL;\n    size_t ret = 0;     \n    PyObject *cb;\n    int total_size;\n    PYCURL_DECLARE_THREAD_STATE;\n    self = (CurlObject *)stream;\n    if (!PYCURL_ACQUIRE_THREAD())\n        return ret;\n    cb = flags ? self->h_cb : self->w_cb;\n    if (cb == NULL)\n        goto silent_error;\n    if (size <= 0 || nmemb <= 0)\n        goto done;\n    total_size = (int)(size * nmemb);\n    if (total_size < 0 || (size_t)total_size / size != nmemb) {\n        PyErr_SetString(ErrorObject, \"integer overflow in write callback\");\n        goto verbose_error;\n    }\n#if PY_MAJOR_VERSION >= 3\n    arglist = Py_BuildValue(\"(y#)\", ptr, total_size);\n#else\n    arglist = Py_BuildValue(\"(s#)\", ptr, total_size);\n#endif\n    if (arglist == NULL)\n        goto verbose_error;\n    result = PyEval_CallObject(cb, arglist);\n    Py_DECREF(arglist);\n    if (result == NULL)\n        goto verbose_error;\n    if (result == Py_None) {\n        ret = total_size;           \n    }\n    else if (PyInt_Check(result) || PyLong_Check(result)) {\n        ret = (size_t) PyLong_AsLong(result);\n    }\n    else {\n        PyErr_SetString(ErrorObject, \"write callback must return int or None\");\n        goto verbose_error;\n    }\ndone:\nsilent_error:\n    Py_XDECREF(result);\n    PYCURL_RELEASE_THREAD();\n    return ret;\nverbose_error:\n    PyErr_Print();\n    goto silent_error;\n}", "target": 0}
{"code": "_gnutls_ecc_ansi_x963_export (gnutls_ecc_curve_t curve, bigint_t x, bigint_t y,\n                              gnutls_datum_t * out)\n{\n  int numlen = gnutls_ecc_curve_get_size (curve);\n  int byte_size, ret;\n  size_t size;\n  if (numlen == 0)\n    return gnutls_assert_val (GNUTLS_E_INVALID_REQUEST);\n  out->size = 1 + 2 * numlen;\n  out->data = gnutls_malloc (out->size);\n  if (out->data == NULL)\n    return gnutls_assert_val (GNUTLS_E_MEMORY_ERROR);\n  memset (out->data, 0, out->size);\n  out->data[0] = 0x04;\n  byte_size = (_gnutls_mpi_get_nbits (x) + 7) / 8;\n  size = out->size - (1 + (numlen - byte_size));\n  ret = _gnutls_mpi_print (x, &out->data[1 + (numlen - byte_size)], &size);\n  if (ret < 0)\n    return gnutls_assert_val (ret);\n  byte_size = (_gnutls_mpi_get_nbits (y) + 7) / 8;\n  size = out->size - (1 + (numlen + numlen - byte_size));\n  ret =\n    _gnutls_mpi_print (y, &out->data[1 + numlen + numlen - byte_size], &size);\n  if (ret < 0)\n    return gnutls_assert_val (ret);\n  return 0;\n}", "target": 1}
{"code": "static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }\n    for (int i = 1; i < rpl->ref_pic_num; ++i) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        if (delta_poc_st != 0)\n            strp_entry_sign_flag = get_bits(gb, 1);\n        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));\n    }\n    return 0;\n}", "target": 1}
{"code": "RenderProcessHost* RenderFrameHostImpl::GetProcess() {\n  return render_view_host_->GetProcess();\n}", "target": 0}
{"code": "fill_record_n_invoke_before_triggers(THD *thd, TABLE *table, Field **ptr,\n                                     List<Item> &values, bool ignore_errors,\n                                     enum trg_event_type event)\n{\n  bool result;\n  Table_triggers_list *triggers= table->triggers;\n  result= fill_record(thd, table, ptr, values, ignore_errors, FALSE);\n  if (!result && triggers && *ptr)\n    result= triggers->process_triggers(thd, event, TRG_ACTION_BEFORE, TRUE) ||\n            not_null_fields_have_null_values(table);\n  if (!result && triggers && *ptr)\n  {\n    DBUG_ASSERT(table == (*ptr)->table);\n    if (table->vfield)\n      result= table->update_virtual_fields(table->file, VCOL_UPDATE_FOR_WRITE);\n  }\n  return result;\n}", "target": 0}
{"code": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}", "target": 1}
{"code": "xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}", "target": 0}
{"code": "static int mov_read_dfla(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int last, type, size, ret;\n    uint8_t buf[4];\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 42)\n        return AVERROR_INVALIDDATA;\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    avio_rb24(pb); \n    if (avio_read(pb, buf, sizeof(buf)) != sizeof(buf)) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read FLAC metadata block header\\n\");\n        return pb->error < 0 ? pb->error : AVERROR_INVALIDDATA;\n    }\n    flac_parse_block_header(buf, &last, &type, &size);\n    if (type != FLAC_METADATA_TYPE_STREAMINFO || size != FLAC_STREAMINFO_SIZE) {\n        av_log(c->fc, AV_LOG_ERROR, \"STREAMINFO must be first FLACMetadataBlock\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n    if (ret < 0)\n        return ret;\n    if (!last)\n        av_log(c->fc, AV_LOG_WARNING, \"non-STREAMINFO FLACMetadataBlock(s) ignored\\n\");\n    return 0;\n}", "target": 0}
{"code": "static int __tipc_nl_add_monitor_prop(struct net *net, struct tipc_nl_msg *msg)\n{\n\tstruct nlattr *attrs;\n\tvoid *hdr;\n\tu32 val;\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  0, TIPC_NL_MON_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_MON);\n\tif (!attrs)\n\t\tgoto msg_full;\n\tval = tipc_nl_monitor_get_threshold(net);\n\tif (nla_put_u32(msg->skb, TIPC_NLA_MON_ACTIVATION_THRESHOLD, val))\n\t\tgoto attr_msg_full;\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\treturn 0;\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "static void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint opts;\n\tResub m;\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushboolean(J, 0);\n}", "target": 1}
{"code": "static int dnxhd_write_header(AVCodecContext *avctx, uint8_t *buf)\n{\n    DNXHDEncContext *ctx = avctx->priv_data;\n    static const uint8_t header_prefix[5] = { 0x00,0x00,0x02,0x80,0x01 };\n    memset(buf, 0, 640);\n    memcpy(buf, header_prefix, 5);\n    buf[5] = ctx->interlaced ? ctx->cur_field+2 : 0x01;\n    buf[6] = 0x80; \n    buf[7] = 0xa0; \n    AV_WB16(buf + 0x18, avctx->height>>ctx->interlaced); \n    AV_WB16(buf + 0x1a, avctx->width);  \n    AV_WB16(buf + 0x1d, avctx->height>>ctx->interlaced); \n    buf[0x21] = ctx->cid_table->bit_depth == 10 ? 0x58 : 0x38;\n    buf[0x22] = 0x88 + (ctx->interlaced<<2);\n    AV_WB32(buf + 0x28, ctx->cid); \n    buf[0x2c] = ctx->interlaced ? 0 : 0x80;\n    buf[0x5f] = 0x01; \n    buf[0x167] = 0x02; \n    AV_WB16(buf + 0x16a, ctx->m.mb_height * 4 + 4); \n    buf[0x16d] = ctx->m.mb_height; \n    buf[0x16f] = 0x10; \n    ctx->msip = buf + 0x170;\n    return 0;\n}", "target": 0}
{"code": "void free_pgtables(struct mmu_gather **tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\t\tanon_vma_unlink(vma);\n\t\tunlink_file_vma(vma);\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t} else {\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tanon_vma_unlink(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}", "target": 0}
{"code": "static inline void __skb_queue_head(struct sk_buff_head *list,\n\t\t\t\t    struct sk_buff *newsk)\n{\n\t__skb_queue_after(list, (struct sk_buff *)list, newsk);\n}", "target": 0}
{"code": "Adaptation::Ecap::FirstLineRep::protocol() const\n{\n    switch (theMessage.http_ver.protocol) {\n    case AnyP::PROTO_HTTP:\n        return libecap::protocolHttp;\n    case AnyP::PROTO_HTTPS:\n        return libecap::protocolHttps;\n    case AnyP::PROTO_FTP:\n        return libecap::protocolFtp;\n    case AnyP::PROTO_GOPHER:\n        return libecap::protocolGopher;\n    case AnyP::PROTO_WAIS:\n        return libecap::protocolWais;\n    case AnyP::PROTO_WHOIS:\n        return libecap::protocolWhois;\n    case AnyP::PROTO_URN:\n        return libecap::protocolUrn;\n    case AnyP::PROTO_ICP:\n        return protocolIcp;\n#if USE_HTCP\n    case AnyP::PROTO_HTCP:\n        return protocolHtcp;\n#endif\n    case AnyP::PROTO_CACHE_OBJECT:\n        return protocolCacheObj;\n    case AnyP::PROTO_ICY:\n        return protocolIcy;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS: \n    case AnyP::PROTO_AUTHORITY_FORM:\n    case AnyP::PROTO_SSL:\n    case AnyP::PROTO_TLS:\n    case AnyP::PROTO_UNKNOWN:\n        return protocolUnknown; \n    case AnyP::PROTO_NONE:\n        return Name();\n    case AnyP::PROTO_MAX:\n        break; \n    }\n    Must(false); \n    return Name();\n}", "target": 1}
{"code": "static inline void phar_set_inode(phar_entry_info *entry TSRMLS_DC) \n{\n\tchar tmp[MAXPATHLEN];\n\tint tmp_len;\n\ttmp_len = entry->filename_len + entry->phar->fname_len;\n\tmemcpy(tmp, entry->phar->fname, entry->phar->fname_len);\n\tmemcpy(tmp + entry->phar->fname_len, entry->filename, entry->filename_len);\n\tentry->inode = (unsigned short)zend_get_hash_value(tmp, tmp_len);\n}", "target": 1}
{"code": "static void copy_sec_desc(const struct cifs_ntsd *pntsd,\n\t\t\t\tstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\n{\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tpnntsd->revision = pntsd->revision;\n\tpnntsd->type = pntsd->type;\n\tpnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\n\tpnntsd->sacloffset = 0;\n\tpnntsd->osidoffset = cpu_to_le32(sidsoffset);\n\tpnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\n\tcifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\n\t\t\t\t\tsizeof(struct cifs_sid));\n\tcifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\n\treturn;\n}", "target": 0}
{"code": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "static inline void init_keys(at91_aes_key_size_t *key_size,\n\t\t\t     unsigned int *cipher_key,\n\t\t\t     unsigned int *cmac_key,\n\t\t\t     unsigned int *iv)\n{\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\t*key_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\t*key_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\t*key_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\tiv[0]\t\t= CONFIG_AES_IV_WORD0;\n\tiv[1]\t\t= CONFIG_AES_IV_WORD1;\n\tiv[2]\t\t= CONFIG_AES_IV_WORD2;\n\tiv[3]\t\t= CONFIG_AES_IV_WORD3;\n\tcipher_key[0]\t= CONFIG_AES_CIPHER_KEY_WORD0;\n\tcmac_key[0]\t= CONFIG_AES_CMAC_KEY_WORD0;\n\tcipher_key[1]\t= CONFIG_AES_CIPHER_KEY_WORD1;\n\tcmac_key[1]\t= CONFIG_AES_CMAC_KEY_WORD1;\n\tcipher_key[2]\t= CONFIG_AES_CIPHER_KEY_WORD2;\n\tcmac_key[2]\t= CONFIG_AES_CMAC_KEY_WORD2;\n\tcipher_key[3]\t= CONFIG_AES_CIPHER_KEY_WORD3;\n\tcmac_key[3]\t= CONFIG_AES_CMAC_KEY_WORD3;\n#if defined(CONFIG_AES_KEY_SIZE_192) || defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[4]\t= CONFIG_AES_CIPHER_KEY_WORD4;\n\tcmac_key[4]\t= CONFIG_AES_CMAC_KEY_WORD4;\n\tcipher_key[5]\t= CONFIG_AES_CIPHER_KEY_WORD5;\n\tcmac_key[5]\t= CONFIG_AES_CMAC_KEY_WORD5;\n#endif\n#if defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[6]\t= CONFIG_AES_CIPHER_KEY_WORD6;\n\tcmac_key[6]\t= CONFIG_AES_CMAC_KEY_WORD6;\n\tcipher_key[7]\t= CONFIG_AES_CIPHER_KEY_WORD7;\n\tcmac_key[7]\t= CONFIG_AES_CMAC_KEY_WORD7;\n#endif\n}", "target": 1}
{"code": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n}", "target": 1}
{"code": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n \tstruct oz_app_hdr *app_hdr;\n \tstruct oz_serial_ctx *ctx;\n \tspin_lock_bh(&g_cdev.lock);\n \tpd = g_cdev.active_pd;\n \tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}", "target": 1}
{"code": "static void FNAME_DECL(uncompress_row0_seg)(int i,\n                                            PIXEL * const cur_row,\n                                            const int end,\n                                            const unsigned int waitmask,\n                                            const unsigned int bpc_mask)\n{\n    DECLARE_STATE_VARIABLES;\n    DECLARE_CHANNEL_VARIABLES;\n    int stopidx;\n    spice_assert(end - i > 0);\n    if (i == 0) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0_0);\n        if (state->waitcnt) {\n            --state->waitcnt;\n        } else {\n            state->waitcnt = (tabrand(&state->tabrand_seed) & waitmask);\n            UPDATE_MODEL(0);\n        }\n        stopidx = ++i + state->waitcnt;\n    } else {\n        stopidx = i + state->waitcnt;\n    }\n    while (stopidx < end) {\n        for (; i <= stopidx; i++) {\n            unsigned int codewordlen;\n            UNCOMPRESS_PIX_START(&cur_row[i]);\n            APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n        }\n        UPDATE_MODEL(stopidx);\n        stopidx = i + (tabrand(&state->tabrand_seed) & waitmask);\n    }\n    for (; i < end; i++) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n    }\n    state->waitcnt = stopidx - end;\n}", "target": 0}
{"code": "\tvirtual ~CxFile() { };", "target": 1}
{"code": "void GLES2DecoderImpl::DoTexParameterfv(\n    GLenum target, GLenum pname, const GLfloat* params) {\n  TextureManager::TextureInfo* info = GetTextureInfoForTarget(target);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glTexParameterfv: unknown texture\");\n    return;\n  }\n  if (!texture_manager()->SetParameter(\n      info, pname, static_cast<GLint>(params[0]))) {\n    SetGLError(GL_INVALID_ENUM, \"glTexParameterfv: param GL_INVALID_ENUM\");\n    return;\n  }\n  glTexParameterfv(target, pname, params);\n}", "target": 0}
{"code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}", "target": 1}
{"code": "static int _nfs4_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tint status;\n\tstatus = nfs4_run_open_task(data, 0);\n\tif (!data->rpc_done)\n\t\treturn status;\n\tif (status != 0) {\n\t\tif (status == -NFS4ERR_BADNAME &&\n\t\t\t\t!(o_arg->open_flags & O_CREAT))\n\t\t\treturn -ENOENT;\n\t\treturn status;\n\t}\n\tnfs_fattr_map_and_free_names(server, &data->f_attr);\n\tif (o_arg->open_flags & O_CREAT)\n\t\tupdate_changeattr(dir, &o_res->cinfo);\n\tif ((o_res->rflags & NFS4_OPEN_RESULT_LOCKTYPE_POSIX) == 0)\n\t\tserver->caps &= ~NFS_CAP_POSIX_LOCK;\n\tif(o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\tif (!(o_res->f_attr->valid & NFS_ATTR_FATTR))\n\t\t_nfs4_proc_getattr(server, &o_res->fh, o_res->f_attr);\n\treturn 0;\n}", "target": 0}
{"code": "static int ext4_iomap_end(struct inode *inode, loff_t offset, loff_t length,\n\t\t\t  ssize_t written, unsigned flags, struct iomap *iomap)\n{\n\tint ret = 0;\n\thandle_t *handle;\n\tint blkbits = inode->i_blkbits;\n\tbool truncate = false;\n\tif (!(flags & IOMAP_WRITE) || (flags & IOMAP_FAULT))\n\t\treturn 0;\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto orphan_del;\n\t}\n\tif (ext4_update_inode_size(inode, offset + written))\n\t\text4_mark_inode_dirty(handle, inode);\n\tif (iomap->offset + iomap->length > \n\t    ALIGN(inode->i_size, 1 << blkbits)) {\n\t\text4_lblk_t written_blk, end_blk;\n\t\twritten_blk = (offset + written) >> blkbits;\n\t\tend_blk = (offset + length) >> blkbits;\n\t\tif (written_blk < end_blk && ext4_can_truncate(inode))\n\t\t\ttruncate = true;\n\t}\n\tif (!truncate && inode->i_nlink &&\n\t    !list_empty(&EXT4_I(inode)->i_orphan))\n\t\text4_orphan_del(handle, inode);\n\text4_journal_stop(handle);\n\tif (truncate) {\n\t\text4_truncate_failed_write(inode);\norphan_del:\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int sco_connect(struct sock *sk)\n{\n\tbdaddr_t *src = &bt_sk(sk)->src;\n\tbdaddr_t *dst = &bt_sk(sk)->dst;\n\tstruct sco_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev  *hdev;\n\tint err, type;\n\tBT_DBG(\"%s -> %s\", batostr(src), batostr(dst));\n\thdev = hci_get_route(dst, src);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\thci_dev_lock_bh(hdev);\n\terr = -ENOMEM;\n\tif (lmp_esco_capable(hdev) && !disable_esco)\n\t\ttype = ESCO_LINK;\n\telse\n\t\ttype = SCO_LINK;\n\thcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);\n\tif (!hcon)\n\t\tgoto done;\n\tconn = sco_conn_add(hcon, 0);\n\tif (!conn) {\n\t\thci_conn_put(hcon);\n\t\tgoto done;\n\t}\n\tbacpy(src, conn->src);\n\terr = sco_chan_add(conn, sk, NULL);\n\tif (err)\n\t\tgoto done;\n\tif (hcon->state == BT_CONNECTED) {\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t} else {\n\t\tsk->sk_state = BT_CONNECT;\n\t\tsco_sock_set_timer(sk, sk->sk_sndtimeo);\n\t}\ndone:\n\thci_dev_unlock_bh(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}", "target": 0}
{"code": " OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k,\n                            OPJ_UINT32 p_tile_no,\n                            OPJ_UINT32 p_comp_no,\n                            OPJ_UINT32 nb_comps,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_rgn_size;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n        OPJ_UINT32 l_comp_room;\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n        if (nb_comps <= 256) {\n                l_comp_room = 1;\n        }\n        else {\n                l_comp_room = 2;\n        }\n        l_rgn_size = 6 + l_comp_room;\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n        opj_write_bytes(l_current_data,J2K_MS_RGN,2);                                   \n        l_current_data += 2;\n        opj_write_bytes(l_current_data,l_rgn_size-2,2);                                 \n        l_current_data += 2;\n        opj_write_bytes(l_current_data,p_comp_no,l_comp_room);                          \n        l_current_data+=l_comp_room;\n        opj_write_bytes(l_current_data, 0,1);                                           \n        ++l_current_data;\n        opj_write_bytes(l_current_data, (OPJ_UINT32)l_tccp->roishift,1);                            \n        ++l_current_data;\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_rgn_size,p_manager) != l_rgn_size) {\n                return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rall\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tnpoints = NPOINTS;\n\tcol = COL;\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have at least 3 points in your array\");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must give a positive number of points\");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to use %d points in array with only %d points\", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL((var));\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL(var);\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t}\n\t}\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\tefree(points);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}", "target": 1}
{"code": "extract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n    gboolean result = FALSE;\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n\t\t\tgoto out;\n        }\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}", "target": 1}
{"code": "static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tfault_in_pages_readable(iov->iov_base, this_len);\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n}", "target": 1}
{"code": "static void __ref adjust_range_page_size_mask(struct map_range *mr,\n\t\t\t\t\t\t\t int nr_range)\n{\n\tint i;\n\tfor (i = 0; i < nr_range; i++) {\n\t\tif ((page_size_mask & (1<<PG_LEVEL_2M)) &&\n\t\t    !(mr[i].page_size_mask & (1<<PG_LEVEL_2M))) {\n\t\t\tunsigned long start = round_down(mr[i].start, PMD_SIZE);\n\t\t\tunsigned long end = round_up(mr[i].end, PMD_SIZE);\n#ifdef CONFIG_X86_32\n\t\t\tif ((end >> PAGE_SHIFT) > max_low_pfn)\n\t\t\t\tcontinue;\n#endif\n\t\t\tif (memblock_is_region_memory(start, end - start))\n\t\t\t\tmr[i].page_size_mask |= 1<<PG_LEVEL_2M;\n\t\t}\n\t\tif ((page_size_mask & (1<<PG_LEVEL_1G)) &&\n\t\t    !(mr[i].page_size_mask & (1<<PG_LEVEL_1G))) {\n\t\t\tunsigned long start = round_down(mr[i].start, PUD_SIZE);\n\t\t\tunsigned long end = round_up(mr[i].end, PUD_SIZE);\n\t\t\tif (memblock_is_region_memory(start, end - start))\n\t\t\t\tmr[i].page_size_mask |= 1<<PG_LEVEL_1G;\n\t\t}\n\t}\n}", "target": 0}
{"code": "put_demapped_rgb (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n                  JDIMENSION rows_supplied)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;\n  register char *bufferptr;\n  register int pixval;\n  register JSAMPROW ptr;\n  register JSAMPROW color_map0 = cinfo->colormap[0];\n  register JSAMPROW color_map1 = cinfo->colormap[1];\n  register JSAMPROW color_map2 = cinfo->colormap[2];\n  register JDIMENSION col;\n  ptr = dest->pub.buffer[0];\n  bufferptr = dest->iobuffer;\n  for (col = cinfo->output_width; col > 0; col--) {\n    pixval = GETJSAMPLE(*ptr++);\n    PUTPPMSAMPLE(bufferptr, GETJSAMPLE(color_map0[pixval]));\n    PUTPPMSAMPLE(bufferptr, GETJSAMPLE(color_map1[pixval]));\n    PUTPPMSAMPLE(bufferptr, GETJSAMPLE(color_map2[pixval]));\n  }\n  (void) JFWRITE(dest->pub.output_file, dest->iobuffer, dest->buffer_width);\n}", "target": 0}
{"code": "static unsigned long __init init_range_memory_mapping(\n\t\t\t\t\t   unsigned long r_start,\n\t\t\t\t\t   unsigned long r_end)\n{\n\tunsigned long start_pfn, end_pfn;\n\tunsigned long mapped_ram_size = 0;\n\tint i;\n\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, NULL) {\n\t\tu64 start = clamp_val(PFN_PHYS(start_pfn), r_start, r_end);\n\t\tu64 end = clamp_val(PFN_PHYS(end_pfn), r_start, r_end);\n\t\tif (start >= end)\n\t\t\tcontinue;\n\t\tcan_use_brk_pgt = max(start, (u64)pgt_buf_end<<PAGE_SHIFT) >=\n\t\t\t\t    min(end, (u64)pgt_buf_top<<PAGE_SHIFT);\n\t\tinit_memory_mapping(start, end);\n\t\tmapped_ram_size += end - start;\n\t\tcan_use_brk_pgt = true;\n\t}\n\treturn mapped_ram_size;\n}", "target": 0}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "void RegisterInternalHandlers() {\n  if (!TrustedPrimitives::RegisterEntryHandler(kSelectorAsyloDonateThread,\n                                               EntryHandler{DonateThread})\n           .ok()) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Could not register entry handler: DonateThread.\");\n  }\n  if (!TrustedPrimitives::RegisterEntryHandler(kSelectorAsyloFini,\n                                               EntryHandler{FinalizeEnclave})\n           .ok()) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Could not register entry handler: FinalizeEnclave\");\n  }\n}", "target": 0}
{"code": "fz_new_cmm_context(fz_context *ctx)\n{\n\tctx->cmm_instance = fz_cmm_new_instance(ctx);\n}", "target": 0}
{"code": "md_uuid_free(void *x)\n{\n  md_uuid *a = x;\n  free(a->path);\n  free(a);\n}", "target": 0}
{"code": "static int mxf_parse_package_comments(MXFContext *mxf, AVDictionary **pm, MXFPackage *package)\n{\n    MXFTaggedValue *tag;\n    int size, i;\n    char *key = NULL;\n    for (i = 0; i < package->comment_count; i++) {\n        tag = mxf_resolve_strong_ref(mxf, &package->comment_refs[i], TaggedValue);\n        if (!tag || !tag->name || !tag->value)\n            continue;\n        size = strlen(tag->name) + 8 + 1;\n        key = av_mallocz(size);\n        if (!key)\n            return AVERROR(ENOMEM);\n        snprintf(key, size, \"comment_%s\", tag->name);\n        av_dict_set(pm, key, tag->value, AV_DICT_DONT_STRDUP_KEY);\n    }\n    return 0;\n}", "target": 0}
{"code": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}", "target": 1}
{"code": "static av_always_inline int dnxhd_calc_ac_bits(DNXHDEncContext *ctx, int16_t *block, int last_index)\n{\n    int last_non_zero = 0;\n    int bits = 0;\n    int i, j, level;\n    for (i = 1; i <= last_index; i++) {\n        j = ctx->m.intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            int run_level = i - last_non_zero - 1;\n            bits += ctx->vlc_bits[(level<<1)|!!run_level]+ctx->run_bits[run_level];\n            last_non_zero = i;\n        }\n    }\n    return bits;\n}", "target": 0}
{"code": "PHP_FUNCTION(move_uploaded_file)\n{\n\tchar *path, *new_path;\n\tint path_len, new_path_len;\n\tzend_bool successful = 0;\n#ifndef PHP_WIN32\n\tint oldmask; int ret;\n#endif\n\tif (!SG(rfc1867_uploaded_files)) {\n                RETURN_FALSE;\n        }\n       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &path, &path_len, &new_path, &new_path_len) == FAILURE) {\n                return;\n        }\n\tif (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (php_check_open_basedir(new_path TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (VCWD_RENAME(path, new_path) == 0) {\n\t\tsuccessful = 1;\n#ifndef PHP_WIN32\n\t\toldmask = umask(077);\n\t\tumask(oldmask);\n\t\tret = VCWD_CHMOD(new_path, 0666 & ~oldmask);\n\t\tif (ret == -1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\t}\n#endif\n\t} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {\n\t\tVCWD_UNLINK(path);\n\t\tsuccessful = 1;\n\t}\n\tif (successful) {\n\t\tzend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to move '%s' to '%s'\", path, new_path);\n\t}\n\tRETURN_BOOL(successful);\n}", "target": 1}
{"code": "static int ftp_send_command(struct connectdata *conn, const char *message, ...)\n{\n  int ftp_code;\n  ssize_t nread = 0;\n  va_list args;\n  char print_buffer[50];\n  va_start(args, message);\n  mvsnprintf(print_buffer, sizeof(print_buffer), message, args);\n  va_end(args);\n  if(Curl_ftpsend(conn, print_buffer)) {\n    ftp_code = -1;\n  }\n  else {\n    if(Curl_GetFTPResponse(&nread, conn, &ftp_code))\n      ftp_code = -1;\n  }\n  (void)nread; \n  return ftp_code;\n}", "target": 0}
{"code": "MenuCache* menu_cache_lookup( const char* menu_name )\n{\n    MenuCache* cache;\n    MENU_CACHE_LOCK;\n#if !GLIB_CHECK_VERSION(2, 32, 0)\n    if(!sync_run_mutex)\n        sync_run_mutex = g_mutex_new();\n    if(!sync_run_cond)\n        sync_run_cond = g_cond_new();\n#endif\n    if( G_UNLIKELY( ! hash ) )\n        hash = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL );\n    else\n    {\n        cache = (MenuCache*)g_hash_table_lookup(hash, menu_name);\n        if( cache )\n        {\n            menu_cache_ref(cache);\n            MENU_CACHE_UNLOCK;\n            return cache;\n        }\n    }\n    MENU_CACHE_UNLOCK;\n    cache = menu_cache_create(menu_name);\n    cache->cancellable = g_cancellable_new();\n#if GLIB_CHECK_VERSION(2, 32, 0)\n    cache->thr = g_thread_new(menu_name, menu_cache_loader_thread, cache);\n#else\n    cache->thr = g_thread_create(menu_cache_loader_thread, cache, TRUE, NULL);\n#endif\n    return cache;\n}", "target": 0}
{"code": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\treturn threads;\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1}
{"code": "fill_yin_revision(struct lys_module *module, struct lyxml_elem *yin, struct lys_revision *rev,\n                  struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lyxml_elem *next, *child;\n    const char *value;\n    GETVAL(ctx, value, yin, \"date\");\n    if (lyp_check_date(ctx, value)) {\n        goto error;\n    }\n    memcpy(rev->date, value, LY_REV_SIZE - 1);\n    LY_TREE_FOR_SAFE(yin->child, next, child) {\n        if (!child->ns) {\n            continue;\n        } else if (strcmp(child->ns->value, LY_NSYIN)) {\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_SELF, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(child->name, \"description\")) {\n            if (rev->dsc) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, child->name, yin->name);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_DESCRIPTION, 0, unres)) {\n                goto error;\n            }\n            rev->dsc = read_yin_subnode(ctx, child, \"text\");\n            if (!rev->dsc) {\n                goto error;\n            }\n        } else if (!strcmp(child->name, \"reference\")) {\n            if (rev->ref) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, child->name, yin->name);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_REFERENCE, 0, unres)) {\n                goto error;\n            }\n            rev->ref = read_yin_subnode(ctx, child, \"text\");\n            if (!rev->ref) {\n                goto error;\n            }\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, child->name);\n            goto error;\n        }\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "static int __feat_register_sp(struct list_head *fn, u8 feat, u8 is_local,\n\t\t\t      u8 mandatory, u8 const *sp_val, u8 sp_len)\n{\n\tdccp_feat_val fval;\n\tif (dccp_feat_type(feat) != FEAT_SP ||\n\t    !dccp_feat_sp_list_ok(feat, sp_val, sp_len))\n\t\treturn -EINVAL;\n\tif (feat == DCCPF_CCID && !ccid_support_check(sp_val, sp_len))\n\t\treturn -EOPNOTSUPP;\n\tif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\n\t\treturn -ENOMEM;\n\treturn dccp_feat_push_change(fn, feat, is_local, mandatory, &fval);\n}", "target": 1}
{"code": "static void alterCurrentValue(PlatformUIElement element, int factor)\n{\n    if (!element || !ATK_IS_VALUE(element))\n        return;\n    GValue currentValue = G_VALUE_INIT;\n    atk_value_get_current_value(ATK_VALUE(element), &currentValue);\n    GValue increment = G_VALUE_INIT;\n    atk_value_get_minimum_increment(ATK_VALUE(element), &increment);\n    GValue newValue = G_VALUE_INIT;\n    g_value_init(&newValue, G_TYPE_DOUBLE);\n    g_value_set_float(&newValue, g_value_get_float(&currentValue) + factor * g_value_get_float(&increment));\n    atk_value_set_current_value(ATK_VALUE(element), &newValue);\n    g_value_unset(&newValue);\n    g_value_unset(&increment);\n     g_value_unset(&currentValue);\n }", "target": 0}
{"code": "static int partition_get_logical_type(blkid_partition par)\n{\n\tblkid_parttable tab;\n\tif (!par)\n\t\treturn -1;\n\ttab = blkid_partition_get_table(par);\n\tif (!tab || !tab->type)\n\t\treturn -1;\n\tif (tab->parent)\n\t\treturn 'L';  \n\tif (!strcmp(tab->type, \"dos\")) {\n\t\tif (par->partno > 4)\n\t\t\treturn 'L';\t\n\t        if(par->type == MBR_DOS_EXTENDED_PARTITION ||\n                   par->type == MBR_W95_EXTENDED_PARTITION ||\n\t\t   par->type == MBR_LINUX_EXTENDED_PARTITION)\n\t\t\treturn 'E';\n\t}\n\treturn 'P';\n}", "target": 0}
{"code": "rndset(unsigned long v)\n{\n\tregister uint32_t h;\n#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)\n\tregister uint32_t t;\n#endif\n\tstruct {\n\t\tstruct timeval tv;\n\t\tvoid *sp;\n\t\tuint32_t qh;\n\t\tpid_t pp;\n\t\tshort r;\n\t} z;\n#ifdef DEBUG\n\tmemset(&z, 0, sizeof(z));\n#endif\n\th = lcg_state;\n\tBAFHFinish_reg(h);\n\tBAFHUpdateMem_reg(h, &v, sizeof(v));\n\tmksh_TIME(z.tv);\n\tz.sp = &lcg_state;\n\tz.pp = procpid;\n\tz.r = (short)rndget();\n#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)\n\tt = qh_state;\n\tBAFHFinish_reg(t);\n\tz.qh = (t & 0xFFFF8000) | rndget();\n\tlcg_state = (t << 15) | rndget();\n\tt = h;\n\tBAFHUpdateMem_reg(t, &lcg_state, sizeof(lcg_state));\n\tBAFHFinish_reg(t);\n\tlcg_state = t;\n#if defined(arc4random_pushb_fast)\n\tarc4random_pushb_fast(&lcg_state, sizeof(lcg_state));\n\tlcg_state = arc4random();\n#else\n\tlcg_state = arc4random_pushb(&lcg_state, sizeof(lcg_state));\n#endif\n\tBAFHUpdateMem_reg(h, &lcg_state, sizeof(lcg_state));\n#else\n\tz.qh = qh_state;\n#endif\n\tBAFHUpdateMem_reg(h, &z, sizeof(z));\n\tBAFHFinish_reg(h);\n\tlcg_state = h;\n}", "target": 0}
{"code": "static int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {\n\t\tif (!IS_ATOMIC_WRITTEN_PAGE(page)) {\n\t\t\tf2fs_register_inmem_page(inode, page);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tf2fs_update_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void Inspect::operator()(Complex_Selector_Ptr c)\n  {\n    Compound_Selector_Obj      head = c->head();\n    Complex_Selector_Obj            tail = c->tail();\n    Complex_Selector::Combinator comb = c->combinator();\n    if (comb == Complex_Selector::ANCESTOR_OF && (!head || head->empty())) {\n      if (tail) tail->perform(this);\n      return;\n    }\n    if (c->has_line_feed()) {\n      if (!(c->has_parent_ref())) {\n        append_optional_linefeed();\n        append_indentation();\n      }\n    }\n    if (head && head->length() != 0) head->perform(this);\n    bool is_empty = !head || head->length() == 0 || head->is_empty_reference();\n    bool is_tail = head && !head->is_empty_reference() && tail;\n    if (output_style() == COMPRESSED && comb != Complex_Selector::ANCESTOR_OF) scheduled_space = 0;\n    switch (comb) {\n      case Complex_Selector::ANCESTOR_OF:\n        if (is_tail) append_mandatory_space();\n      break;\n      case Complex_Selector::PARENT_OF:\n        append_optional_space();\n        append_string(\">\");\n        append_optional_space();\n      break;\n      case Complex_Selector::ADJACENT_TO:\n        append_optional_space();\n        append_string(\"+\");\n        append_optional_space();\n      break;\n      case Complex_Selector::REFERENCE:\n        append_mandatory_space();\n        append_string(\"/\");\n        c->reference()->perform(this);\n        append_string(\"/\");\n        append_mandatory_space();\n      break;\n      case Complex_Selector::PRECEDES:\n        if (is_empty) append_optional_space();\n        else append_mandatory_space();\n        append_string(\"~\");\n        if (tail) append_mandatory_space();\n        else append_optional_space();\n      break;\n      default: break;\n    }\n    if (tail && comb != Complex_Selector::ANCESTOR_OF) {\n      if (c->has_line_break()) append_optional_linefeed();\n    }\n    if (tail) tail->perform(this);\n    if (!tail && c->has_line_break()) {\n      if (output_style() == COMPACT) {\n        append_mandatory_space();\n      }\n    }\n  }", "target": 1}
{"code": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\tport->port.drain_delay = 256;\n\treturn 0;\n}", "target": 0}
{"code": "static int mxf_read_sync(AVIOContext *pb, const uint8_t *key, unsigned size)\n{\n    int i, b;\n    for (i = 0; i < size && !avio_feof(pb); i++) {\n        b = avio_r8(pb);\n        if (b == key[0])\n            i = 0;\n        else if (b != key[i])\n            i = -1;\n    }\n    return i == size;\n}", "target": 0}
{"code": "void close_cached_dir(struct cached_fid *cfid)\n{\n\tmutex_lock(&cfid->fid_mutex);\n\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n\tmutex_unlock(&cfid->fid_mutex);\n}", "target": 0}
{"code": "static void validate_my_share_entries(struct smbd_server_connection *sconn,\n\t\t\t\t      int num,\n\t\t\t\t      struct share_mode_entry *share_entry)\n{\n\tstruct server_id self = messaging_server_id(sconn->msg_ctx);\n\tfiles_struct *fsp;\n\tif (!serverid_equal(&self, &share_entry->pid)) {\n\t\treturn;\n\t}\n\tif (!is_valid_share_mode_entry(share_entry)) {\n\t\treturn;\n\t}\n\tfsp = file_find_dif(sconn, share_entry->id,\n\t\t\t    share_entry->share_file_id);\n\tif (!fsp) {\n\t\tDEBUG(0,(\"validate_my_share_entries: PANIC : %s\\n\",\n\t\t\t share_mode_str(talloc_tos(), num, share_entry) ));\n\t\tsmb_panic(\"validate_my_share_entries: Cannot match a \"\n\t\t\t  \"share entry with an open file\\n\");\n\t}\n\tif (((uint16)fsp->oplock_type) != share_entry->op_type) {\n\t\tgoto panic;\n\t}\n\treturn;\n panic:\n\t{\n\t\tchar *str;\n\t\tDEBUG(0,(\"validate_my_share_entries: PANIC : %s\\n\",\n\t\t\t share_mode_str(talloc_tos(), num, share_entry) ));\n\t\tstr = talloc_asprintf(talloc_tos(),\n\t\t\t\"validate_my_share_entries: \"\n\t\t\t\"file %s, oplock_type = 0x%x, op_type = 0x%x\\n\",\n\t\t\t fsp->fsp_name->base_name,\n\t\t\t (unsigned int)fsp->oplock_type,\n\t\t\t (unsigned int)share_entry->op_type );\n\t\tsmb_panic(str);\n\t}\n}", "target": 0}
{"code": "static struct desc_struct *get_desc(unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc = NULL;\n\t\tstruct ldt_struct *ldt;\n\t\tsel >>= 3;\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries)\n\t\t\tdesc = &ldt->entries[sel];\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\t\treturn desc;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\tif (desc_base > gdt_desc.size)\n\t\treturn NULL;\n\treturn (struct desc_struct *)(gdt_desc.address + desc_base);\n}", "target": 1}
{"code": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "LogFilePrep(const char *fname, const char *backup, const char *idstring)\n{\n    char *logFileName = NULL;\n    if (asprintf(&logFileName, fname, idstring) == -1)\n        FatalError(\"Cannot allocate space for the log file name\\n\");\n    if (backup && *backup) {\n        struct stat buf;\n        if (!stat(logFileName, &buf) && S_ISREG(buf.st_mode)) {\n            char *suffix;\n            char *oldLog;\n            if ((asprintf(&suffix, backup, idstring) == -1) ||\n                (asprintf(&oldLog, \"%s%s\", logFileName, suffix) == -1)) {\n                FatalError(\"Cannot allocate space for the log file name\\n\");\n            }\n            free(suffix);\n            if (rename(logFileName, oldLog) == -1) {\n                FatalError(\"Cannot move old log file \\\"%s\\\" to \\\"%s\\\"\\n\",\n                           logFileName, oldLog);\n            }\n            free(oldLog);\n        }\n    }\n    else {\n        if (remove(logFileName) != 0 && errno != ENOENT) {\n            FatalError(\"Cannot remove old log file \\\"%s\\\": %s\\n\",\n                       logFileName, strerror(errno));\n        }\n    }\n    return logFileName;\n}", "target": 1}
{"code": "    uint32_t TiffImageEntry::doSizeImage() const\n    {\n        if (!pValue()) return 0;\n        uint32_t len = pValue()->sizeDataArea();\n        if (len == 0) {\n            for (Strips::const_iterator i = strips_.begin(); i != strips_.end(); ++i) {\n                len += i->second;\n            }\n        }\n        return len;\n    } ", "target": 0}
{"code": "get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0 &&\n\t\t   unconditional(&s->ip)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\treturn 0;\n}", "target": 1}
{"code": "static int ssl_flight_append( mbedtls_ssl_context *ssl )\n{\n    mbedtls_ssl_flight_item *msg;\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> ssl_flight_append\" ) );\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"message appended to flight\",\n                           ssl->out_msg, ssl->out_msglen );\n    if( ( msg = mbedtls_calloc( 1, sizeof(  mbedtls_ssl_flight_item ) ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc %\" MBEDTLS_PRINTF_SIZET \" bytes failed\",\n                            sizeof( mbedtls_ssl_flight_item ) ) );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n    if( ( msg->p = mbedtls_calloc( 1, ssl->out_msglen ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc %\" MBEDTLS_PRINTF_SIZET \" bytes failed\",\n                                    ssl->out_msglen ) );\n        mbedtls_free( msg );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n    memcpy( msg->p, ssl->out_msg, ssl->out_msglen );\n    msg->len = ssl->out_msglen;\n    msg->type = ssl->out_msgtype;\n    msg->next = NULL;\n    if( ssl->handshake->flight == NULL )\n        ssl->handshake->flight = msg;\n    else\n    {\n        mbedtls_ssl_flight_item *cur = ssl->handshake->flight;\n        while( cur->next != NULL )\n            cur = cur->next;\n        cur->next = msg;\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= ssl_flight_append\" ) );\n    return( 0 );\n}", "target": 0}
{"code": "reallocWrapper (void *address, size_t size)\n{\n  if (!(address = realloc (address, size)) && size)\n    outOfMemory ();\n  return address;\n}", "target": 0}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "static unsigned long unmap_page_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tlong *zap_work, struct zap_details *details)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tif (details && !details->check_mapping && !details->nonlinear_vma)\n\t\tdetails = NULL;\n\tBUG_ON(addr >= end);\n\ttlb_start_vma(tlb, vma);\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd)) {\n\t\t\t(*zap_work)--;\n\t\t\tcontinue;\n\t\t}\n\t\tnext = zap_pud_range(tlb, vma, pgd, addr, next,\n\t\t\t\t\t\tzap_work, details);\n\t} while (pgd++, addr = next, (addr != end && *zap_work > 0));\n\ttlb_end_vma(tlb, vma);\n\treturn addr;\n}", "target": 0}
{"code": "static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\thci_send_sco(conn->hcon, skb);\n\treturn len;\n}", "target": 1}
{"code": "char_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t end, nb = 0, i, f_begin, f_end;\n\twhile (nb < size && data[nb] == '`')\n\t\tnb++;\n\ti = 0;\n\tfor (end = nb; end < size && i < nb; end++) {\n\t\tif (data[end] == '`') i++;\n\t\telse i = 0;\n\t}\n\tif (i < nb && end >= size)\n\t\treturn 0; \n\tf_begin = nb;\n\twhile (f_begin < end && data[f_begin] == ' ')\n\t\tf_begin++;\n\tf_end = end - nb;\n\twhile (f_end > nb && data[f_end-1] == ' ')\n\t\tf_end--;\n\tif (f_begin < f_end) {\n\t\tstruct buf work = { data + f_begin, f_end - f_begin, 0, 0 };\n\t\tif (!rndr->cb.codespan(ob, &work, rndr->opaque))\n\t\t\tend = 0;\n\t} else {\n\t\tif (!rndr->cb.codespan(ob, 0, rndr->opaque))\n\t\t\tend = 0;\n\t}\n\treturn end;\n}", "target": 0}
{"code": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\tif (flags & O_CREAT)\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t} else if (flags & O_PATH) {\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\top->open_flag = flags;\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\top->acc_mode = acc_mode;\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}", "target": 0}
{"code": "static int curl_fnmatch(void *ctx, const char *pattern, const char *string)\n{\n\tphp_curl *ch = (php_curl *) ctx;\n\tphp_curl_fnmatch *t = ch->handlers->fnmatch;\n\tint rval = CURL_FNMATCHFUNC_FAIL;\n\tswitch (t->method) {\n\t\tcase PHP_CURL_USER: {\n\t\t\tzval argv[3];\n\t\t\tzval retval;\n\t\t\tint  error;\n\t\t\tzend_fcall_info fci;\n\t\t\tZVAL_RES(&argv[0], ch->res);\n\t\t\tZ_ADDREF(argv[0]);\n\t\t\tZVAL_STRING(&argv[1], pattern);\n\t\t\tZVAL_STRING(&argv[2], string);\n\t\t\tfci.size = sizeof(fci);\n\t\t\tfci.function_table = EG(function_table);\n\t\t\tZVAL_COPY_VALUE(&fci.function_name, &t->func_name);\n\t\t\tfci.object = NULL;\n\t\t\tfci.retval = &retval;\n\t\t\tfci.param_count = 3;\n\t\t\tfci.params = argv;\n\t\t\tfci.no_separation = 0;\n\t\t\tfci.symbol_table = NULL;\n\t\t\tch->in_callback = 1;\n\t\t\terror = zend_call_function(&fci, &t->fci_cache);\n\t\t\tch->in_callback = 0;\n\t\t\tif (error == FAILURE) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot call the CURLOPT_FNMATCH_FUNCTION\");\n\t\t\t} else if (!Z_ISUNDEF(retval)) {\n\t\t\t\tif (Z_TYPE(retval) != IS_LONG) {\n\t\t\t\t\tconvert_to_long_ex(&retval);\n\t\t\t\t}\n\t\t\t\trval = Z_LVAL(retval);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&argv[0]);\n\t\t\tzval_ptr_dtor(&argv[1]);\n\t\t\tzval_ptr_dtor(&argv[2]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rval;\n}", "target": 0}
{"code": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n\tunsigned long inodes;\n\tint error = -EINVAL;\n\tif (shmem_parse_options(data, &config, true))\n\t\treturn error;\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n\tsbinfo->max_inodes  = config.max_inodes;\n\tsbinfo->free_inodes = config.max_inodes - inodes;\n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t\nout:\n\tspin_unlock(&sbinfo->stat_lock);\n\treturn error;\n}", "target": 1}
{"code": "nodeVPush(xmlValidCtxtPtr ctxt, xmlNodePtr value)\n{\n    if (ctxt->nodeMax <= 0) {\n        ctxt->nodeMax = 4;\n        ctxt->nodeTab =\n            (xmlNodePtr *) xmlMalloc(ctxt->nodeMax *\n                                     sizeof(ctxt->nodeTab[0]));\n        if (ctxt->nodeTab == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n            ctxt->nodeMax = 0;\n            return (0);\n        }\n    }\n    if (ctxt->nodeNr >= ctxt->nodeMax) {\n        xmlNodePtr *tmp;\n        tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,\n\t\t\t      ctxt->nodeMax * 2 * sizeof(ctxt->nodeTab[0]));\n        if (tmp == NULL) {\n\t    xmlVErrMemory(ctxt, \"realloc failed\");\n            return (0);\n        }\n        ctxt->nodeMax *= 2;\n\tctxt->nodeTab = tmp;\n    }\n    ctxt->nodeTab[ctxt->nodeNr] = value;\n    ctxt->node = value;\n    return (ctxt->nodeNr++);\n}", "target": 0}
{"code": "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": " void PageClickTracker::handleEvent(const WebDOMEvent& event) {\n   last_node_clicked_.reset();\n  if (!event.isMouseEvent())\n    return;\n   const WebDOMMouseEvent mouse_event = event.toConst<WebDOMMouseEvent>();\n   DCHECK(mouse_event.buttonDown());\n   if (mouse_event.button() != 0)\n    return;  \n  last_node_clicked_ = mouse_event.target();\n  was_focused_ = (GetFocusedNode() == last_node_clicked_);\n}", "target": 0}
{"code": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void unregister_blkdev(unsigned int major, const char *name)\n{\n\tstruct blk_major_name **n;\n\tstruct blk_major_name *p = NULL;\n\tint index = major_to_index(major);\n\tmutex_lock(&block_class_lock);\n\tfor (n = &major_names[index]; *n; n = &(*n)->next)\n\t\tif ((*n)->major == major)\n\t\t\tbreak;\n\tif (!*n || strcmp((*n)->name, name)) {\n\t\tWARN_ON(1);\n\t} else {\n\t\tp = *n;\n\t\t*n = p->next;\n\t}\n\tmutex_unlock(&block_class_lock);\n\tkfree(p);\n}", "target": 0}
{"code": "bgp_capability_mp (struct peer *peer, struct capability *cap)\n{\n  if (ntohs (cap->mpc.afi) == AFI_IP)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST) \n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == BGP_SAFI_VPNV4)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n\t    peer->afc_nego[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#ifdef HAVE_IPV6\n  else if (ntohs (cap->mpc.afi) == AFI_IP6)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#endif \n  else\n    {\n      return -1;\n    }\n  return 0;\n}", "target": 1}
{"code": "static apr_status_t lua_websocket_readbytes(conn_rec* c, char* buffer, \n        apr_off_t len) \n{\n    apr_bucket_brigade *brigade = apr_brigade_create(c->pool, c->bucket_alloc);\n    apr_status_t rv;\n    rv = ap_get_brigade(c->input_filters, brigade, AP_MODE_READBYTES, \n            APR_BLOCK_READ, len);\n    if (rv == APR_SUCCESS) {\n        if (!APR_BRIGADE_EMPTY(brigade)) {\n            apr_bucket* bucket = APR_BRIGADE_FIRST(brigade);\n            const char* data = NULL;\n            apr_size_t data_length = 0;\n            rv = apr_bucket_read(bucket, &data, &data_length, APR_BLOCK_READ);\n            if (rv == APR_SUCCESS) {\n                memcpy(buffer, data, len);\n            }\n            apr_bucket_delete(bucket);\n        }\n    }\n    apr_brigade_cleanup(brigade);\n    return rv;\n}", "target": 0}
{"code": "    long IptcData::size() const\n    {\n        size_t newSize = 0;\n        const_iterator iter = iptcMetadata_.begin();\n        const_iterator end = iptcMetadata_.end();\n        for ( ; iter != end; ++iter) {\n            newSize += 5;\n            size_t dataSize = iter->size();\n            newSize += dataSize;\n            if (dataSize > 32767) {\n                newSize += 4;\n            }\n        }\n        return (long)newSize;\n    }", "target": 0}
{"code": "jinit_merged_upsampler(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample;\n  upsample = (my_upsample_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_upsampler));\n  cinfo->upsample = (struct jpeg_upsampler *)upsample;\n  upsample->pub.start_pass = start_pass_merged_upsample;\n  upsample->pub.need_context_rows = FALSE;\n  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;\n  if (cinfo->max_v_samp_factor == 2) {\n    upsample->pub.upsample = merged_2v_upsample;\n    if (jsimd_can_h2v2_merged_upsample())\n      upsample->upmethod = jsimd_h2v2_merged_upsample;\n    else\n      upsample->upmethod = h2v2_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v2_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v2_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = (JSAMPROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                (size_t)(upsample->out_row_width * sizeof(JSAMPLE)));\n  } else {\n    upsample->pub.upsample = merged_1v_upsample;\n    if (jsimd_can_h2v1_merged_upsample())\n      upsample->upmethod = jsimd_h2v1_merged_upsample;\n    else\n      upsample->upmethod = h2v1_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v1_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v1_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = NULL;\n  }\n  build_ycc_rgb_table(cinfo);\n}", "target": 1}
{"code": "static bool setup_natural_join_row_types(THD *thd,\n                                         List<TABLE_LIST> *from_clause,\n                                         Name_resolution_context *context)\n{\n  DBUG_ENTER(\"setup_natural_join_row_types\");\n  thd->where= \"from clause\";\n  if (from_clause->elements == 0)\n    DBUG_RETURN(false); \n  if (!context->select_lex->first_natural_join_processing)\n  {\n    context->first_name_resolution_table= context->natural_join_first_table;\n    DBUG_PRINT(\"info\", (\"using cached setup_natural_join_row_types\"));\n    DBUG_RETURN(false);\n  }\n  List_iterator_fast<TABLE_LIST> table_ref_it(*from_clause);\n  TABLE_LIST *table_ref; \n  TABLE_LIST *left_neighbor;\n  TABLE_LIST *right_neighbor= NULL;\n  for (left_neighbor= table_ref_it++; left_neighbor ; )\n  {\n    table_ref= left_neighbor;\n    do\n    {\n      left_neighbor= table_ref_it++;\n    }\n    while (left_neighbor && left_neighbor->sj_subq_pred);\n    if (store_top_level_join_columns(thd, table_ref,\n                                     left_neighbor, right_neighbor))\n      DBUG_RETURN(true);\n    if (left_neighbor)\n    {\n      TABLE_LIST *first_leaf_on_the_right;\n      first_leaf_on_the_right= table_ref->first_leaf_for_name_resolution();\n      left_neighbor->next_name_resolution_table= first_leaf_on_the_right;\n    }\n    right_neighbor= table_ref;\n  }\n  DBUG_ASSERT(right_neighbor);\n  context->first_name_resolution_table=\n    right_neighbor->first_leaf_for_name_resolution();\n  context->natural_join_first_table= context->first_name_resolution_table;\n  context->select_lex->first_natural_join_processing= false;\n  DBUG_RETURN (false);\n}", "target": 0}
{"code": "static int handle_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data;\n\tif (vmx_get_msr(vcpu, ecx, &data)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_read(ecx, data);\n\tvcpu->arch.regs[VCPU_REGS_RAX] = data & -1u;\n\tvcpu->arch.regs[VCPU_REGS_RDX] = (data >> 32) & -1u;\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "MagickExport MagickBooleanType IsOptionMember(const char *option,\n  const char *options)\n{\n  char\n    **option_list,\n    *string;\n  int\n    number_options;\n  MagickBooleanType\n    member;\n  register ssize_t\n    i;\n  if (options == (const char *) NULL)\n    return(MagickFalse);\n  string=ConstantString(options);\n  (void) SubstituteString(&string,\",\",\" \");\n  option_list=StringToArgv(string,&number_options);\n  string=DestroyString(string);\n  if (option_list == (char **) NULL)\n    return(MagickFalse);\n  member=MagickFalse;\n  for (i=1; i < (ssize_t) number_options; i++)\n  {\n    if ((*option_list[i] == '!') &&\n        (LocaleCompare(option,option_list[i]+1) == 0))\n      break;\n    if (GlobExpression(option,option_list[i],MagickTrue) != MagickFalse)\n      {\n        member=MagickTrue;\n        break;\n      }\n    option_list[i]=DestroyString(option_list[i]);\n  }\n  for ( ; i < (ssize_t) number_options; i++)\n    option_list[i]=DestroyString(option_list[i]);\n  option_list=(char **) RelinquishMagickMemory(option_list);\n  return(member);\n}", "target": 1}
{"code": "    virtual AP4_Result WritePartial(const void* buffer,\n                                    AP4_Size    bytes_to_write, \n                                    AP4_Size&   bytes_written) {\n        AP4_UI08* out = new AP4_UI08[bytes_to_write+16];\n        AP4_Size  out_size = bytes_to_write+16;\n        AP4_Result result = m_StreamCipher->ProcessBuffer((const AP4_UI08*)buffer,\n                                                          bytes_to_write,\n                                                          out,\n                                                          &out_size);\n        if (AP4_SUCCEEDED(result)) {\n            result = m_Output->Write(out, out_size);\n            bytes_written = bytes_to_write;\n            m_Size       += bytes_to_write;\n        } else {\n            bytes_written = 0;\n        }\n        delete[] out;\n        return result;\n    }", "target": 0}
{"code": "\tFOR_EACH_MODULE_Type(CIRCNetwork* pNetwork) : CMuser(pNetwork ? pNetwork->GetUser()->GetModules() : CMtemp), CMnet(pNetwork ? pNetwork->GetModules() : CMtemp) {\n\t\twhere = AtGlobal;\n\t}", "target": 0}
{"code": "smb3_is_transform_hdr(void *buf)\n{\n\tstruct smb2_transform_hdr *trhdr = buf;\n\treturn trhdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM;\n}", "target": 0}
{"code": "static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\nout:\n\tfree(command);\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\treturn fret;\n}", "target": 0}
{"code": "int vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\tstruct file *file_out, loff_t pos_out, u64 len)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tint ret;\n\tif (inode_in->i_sb != inode_out->i_sb ||\n\t    file_in->f_path.mnt != file_out->f_path.mnt)\n\t\treturn -EXDEV;\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND) ||\n\t    !file_in->f_op->clone_file_range)\n\t\treturn -EBADF;\n\tret = clone_verify_area(file_in, pos_in, len, false);\n\tif (ret)\n\t\treturn ret;\n\tret = clone_verify_area(file_out, pos_out, len, true);\n\tif (ret)\n\t\treturn ret;\n\tif (pos_in + len > i_size_read(inode_in))\n\t\treturn -EINVAL;\n\tret = mnt_want_write_file(file_out);\n\tif (ret)\n\t\treturn ret;\n\tret = file_in->f_op->clone_file_range(file_in, pos_in,\n\t\t\tfile_out, pos_out, len);\n\tif (!ret) {\n\t\tfsnotify_access(file_in);\n\t\tfsnotify_modify(file_out);\n\t}\n\tmnt_drop_write_file(file_out);\n\treturn ret;\n}", "target": 0}
{"code": "static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}", "target": 1}
{"code": "static void sock_def_readable(struct sock *sk, int len)\n{\n\tread_lock(&sk->sk_callback_lock);\n\tif (sk->sk_sleep && waitqueue_active(sk->sk_sleep))\n\t\twake_up_interruptible_sync(sk->sk_sleep);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\tread_unlock(&sk->sk_callback_lock);\n}", "target": 0}
{"code": "int _gnutls_x509_verify_signature(const gnutls_datum_t * tbs,\n\t\t\t\t  const gnutls_datum_t * signature,\n\t\t\t\t  gnutls_x509_crt_t issuer)\n{\n    mpi_t issuer_params[MAX_PUBLIC_PARAMS_SIZE];\n    int ret, issuer_params_size, i;\n    issuer_params_size = MAX_PUBLIC_PARAMS_SIZE;\n    ret =\n\t_gnutls_x509_crt_get_mpis(issuer, issuer_params,\n\t\t\t\t  &issuer_params_size);\n    if (ret < 0) {\n\tgnutls_assert();\n\treturn ret;\n    }\n    ret =\n\tverify_sig(tbs, signature,\n\t\t   gnutls_x509_crt_get_pk_algorithm(issuer, NULL),\n\t\t   issuer_params, issuer_params_size);\n    if (ret < 0) {\n\tgnutls_assert();\n    }\n    for (i = 0; i < issuer_params_size; i++) {\n\t_gnutls_mpi_release(&issuer_params[i]);\n    }\n    return ret;\n}", "target": 0}
{"code": "print_optimize_info(FILE* f, regex_t* reg)\n{\n  static const char* on[] = { \"NONE\", \"EXACT\", \"EXACT_BM\", \"EXACT_BM_NOT_REV\",\n                              \"EXACT_IC\", \"MAP\" };\n  fprintf(f, \"optimize: %s\\n\", on[reg->optimize]);\n  fprintf(f, \"  anchor: \"); print_anchor(f, reg->anchor);\n  if ((reg->anchor & ANCHOR_END_BUF_MASK) != 0)\n    print_distance_range(f, reg->anchor_dmin, reg->anchor_dmax);\n  fprintf(f, \"\\n\");\n  if (reg->optimize) {\n    fprintf(f, \"  sub anchor: \"); print_anchor(f, reg->sub_anchor);\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"\\n\");\n  if (reg->exact) {\n    UChar *p;\n    fprintf(f, \"exact: [\");\n    for (p = reg->exact; p < reg->exact_end; p++) {\n      fputc(*p, f);\n    }\n    fprintf(f, \"]: length: %ld\\n\", (reg->exact_end - reg->exact));\n  }\n  else if (reg->optimize & ONIG_OPTIMIZE_MAP) {\n    int c, i, n = 0;\n    for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)\n      if (reg->map[i]) n++;\n    fprintf(f, \"map: n=%d\\n\", n);\n    if (n > 0) {\n      c = 0;\n      fputc('[', f);\n      for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) {\n\tif (reg->map[i] != 0) {\n          if (c > 0)  fputs(\", \", f);\n          c++;\n          if (ONIGENC_MBC_MAXLEN(reg->enc) == 1 &&\n              ONIGENC_IS_CODE_PRINT(reg->enc, (OnigCodePoint )i))\n            fputc(i, f);\n          else\n            fprintf(f, \"%d\", i);\n        }\n      }\n      fprintf(f, \"]\\n\");\n    }\n  }\n}", "target": 0}
{"code": "void ConnectDialog::on_qaUrl_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || si->qsUrl.isEmpty())\n\t\treturn;\n\tQDesktopServices::openUrl(QUrl(si->qsUrl));\n}", "target": 1}
{"code": "int af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}", "target": 1}
{"code": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tmark_files_ro(sb);\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}", "target": 1}
{"code": "char *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n    h1 = s[i + 1];\n    if (!h1) {\n        *d = '\\0';\n        return NULL;\n    }\n    h2 = s[i + 2];\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      *d = c, i += 2;\n      continue;\n    }\n    if (h1 >= 'a' )\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' )\n      h2 = h2 - 'a' + 'A';\n    d[0] = '%', d[1] = h1, d[2] = h2;\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n  *d = '\\0';\n  return d;\n}", "target": 0}
{"code": "void CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  size_t expected_bytes;\n  bool size_result = viz::ResourceSizes::MaybeSizeInBytes(\n      pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes);\n  if (!size_result) {\n    return;\n  }\n  pixel_size_ = pixel_size;\n  shared_memory_ = region.Map();\n  DCHECK(shared_memory_.IsValid());\n}", "target": 1}
{"code": "GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n{\n\tu32 i;\n\tif (!nb_pack) nb_pack = 1;\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tstbl->SampleSize->sampleSize = size;\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n\t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n\t\tALLOC_INC(stbl->SampleSize->alloc_size);\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)\n\t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n\t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n\t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );\n\t\tif (init_table) {\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++)\n\t\t\t\tstbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;\n\t\t}\n\t}\n\tstbl->SampleSize->sampleSize = 0;\n\tfor (i=0; i<nb_pack; i++) {\n\t\tstbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;\n\t}\n\tstbl->SampleSize->sampleCount += nb_pack;\n\tif (size > stbl->SampleSize->max_size)\n\t\tstbl->SampleSize->max_size = size;\n\tstbl->SampleSize->total_size += size;\n\tstbl->SampleSize->total_samples += nb_pack;\n\treturn GF_OK;\n}", "target": 1}
{"code": "void forward_cancel_request(PgSocket *server)\n{\n\tbool res;\n\tPgSocket *req = first_socket(&server->pool->cancel_req_list);\n\tAssert(req != NULL && req->state == CL_CANCEL);\n\tAssert(server->state == SV_LOGIN);\n\tSEND_CancelRequest(res, server, req->cancel_key);\n\tchange_client_state(req, CL_JUSTFREE);\n}", "target": 0}
{"code": "DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)\n{\n    int i;\n    storeAppendPrintf(sentry, \"HTTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.http_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.http_read_hist[i],\n                          Math::doublePercent(stats.http_read_hist[i], stats.http_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"FTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.ftp_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.ftp_read_hist[i],\n                          Math::doublePercent(stats.ftp_read_hist[i], stats.ftp_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"Gopher I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.gopher_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.gopher_read_hist[i],\n                          Math::doublePercent(stats.gopher_read_hist[i], stats.gopher_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n}", "target": 1}
{"code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n    return expr;\n}", "target": 1}
{"code": "static void logi_dj_recv_queue_notification(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t   struct dj_report *dj_report)\n{\n\tkfifo_in(&djrcv_dev->notif_fifo, dj_report, sizeof(struct dj_report));\n\tif (schedule_work(&djrcv_dev->work) == 0) {\n\t\tdbg_hid(\"%s: did not schedule the work item, was already \"\n\t\t\t\"queued\\n\", __func__);\n\t}\n}", "target": 0}
{"code": "static __init int efivar_ssdt_iter(efi_char16_t *name, efi_guid_t vendor,\n\t\t\t\t   unsigned long name_size, void *data)\n{\n\tstruct efivar_entry *entry;\n\tstruct list_head *list = data;\n\tchar utf8_name[EFIVAR_SSDT_NAME_MAX];\n\tint limit = min_t(unsigned long, EFIVAR_SSDT_NAME_MAX, name_size);\n\tucs2_as_utf8(utf8_name, name, limit - 1);\n\tif (strncmp(utf8_name, efivar_ssdt, limit) != 0)\n\t\treturn 0;\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn 0;\n\tmemcpy(entry->var.VariableName, name, name_size);\n\tmemcpy(&entry->var.VendorGuid, &vendor, sizeof(efi_guid_t));\n\tefivar_entry_add(entry, list);\n\treturn 0;\n}", "target": 0}
{"code": "set_cs_start(char *line)\n{\n  char *p, *q, *r;\n  if ((p = strstr(line, \"string currentfile\"))) {\n    if (!strstr(line, \"readstring\"))\n      return;\n    *p = '\\0';\t\t\t\t\t  \n    q = strrchr(line, '/');\n    if (q) {\n      r = cs_start;\n      ++q;\n      while (!isspace(*q) && *q != '{')\n\t*r++ = *q++;\n      *r = '\\0';\n    }\n    *p = 's';\t\t\t\t\t  \n  }\n}", "target": 1}
{"code": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n\tif (src_known && dst_known)\n\t\treturn;\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n\t}\n}", "target": 1}
{"code": "static inline struct keydata *get_keyptr(void)\n{\n\tstruct keydata *keyptr = &ip_keydata[ip_cnt & 1];\n\tsmp_rmb();\n\treturn keyptr;\n}", "target": 1}
{"code": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}", "target": 1}
{"code": "static u32 swf_get_32(SWFReader *read)\n{\n\tu32 val, res;\n\tval = swf_read_int(read, 32);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\tres<<=8;\n\tres |= ((val>>16)&0xFF);\n\tres<<=8;\n\tres|= ((val>>24)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "bool PrintMsg_Print_Params_IsValid(const PrintMsg_Print_Params& params) {\n  return !params.content_size.IsEmpty() && !params.page_size.IsEmpty() &&\n         !params.printable_area.IsEmpty() && params.document_cookie &&\n         params.desired_dpi && params.max_shrink && params.min_shrink &&\n         params.dpi && (params.margin_top >= 0) && (params.margin_left >= 0) &&\n         params.dpi > kMinDpi && params.document_cookie != 0;\n}", "target": 0}
{"code": "print_arrays_for(char *set)\n{\n  FILE *f;\n  sprintf(buf, \"%s.conf\", set);\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n  printf(\"\\\n\\n\\n\",\n\t set, prog);\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n  fclose(f);\n  return;\n}", "target": 1}
{"code": "static int activate(AVFilterContext *ctx)\n{\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    AudioFWTDNContext *s = ctx->priv;\n    AVFrame *in = NULL;\n    int ret, status;\n    int64_t pts;\n    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);\n    ret = ff_inlink_consume_samples(inlink, s->nb_samples, s->nb_samples, &in);\n    if (ret < 0)\n        return ret;\n    if (ret > 0)\n        return filter_frame(inlink, in);\n    if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {\n        if (status == AVERROR_EOF) {\n            while (s->padd_samples != 0) {\n                ret = filter_frame(inlink, NULL);\n                if (ret < 0)\n                    return ret;\n            }\n            ff_outlink_set_status(outlink, status, pts);\n            return ret;\n        }\n    }\n    FF_FILTER_FORWARD_WANTED(outlink, inlink);\n    return FFERROR_NOT_READY;\n}", "target": 1}
{"code": "smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n{\n\tsr->user_cr = smb_ofile_getcred(ofile);\n\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n}", "target": 1}
{"code": "static void start_request(GDHCPClient *dhcp_client)\n{\n\tdebug(dhcp_client, \"start request (retries %d)\",\n\t\t\t\t\tdhcp_client->retry_times);\n\tif (dhcp_client->retry_times == REQUEST_RETRIES) {\n\t\tif (dhcp_client->no_lease_cb)\n\t\t\tdhcp_client->no_lease_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->no_lease_data);\n\t\treturn;\n\t}\n\tif (dhcp_client->retry_times == 0) {\n\t\tdhcp_client->state = REQUESTING;\n\t\tswitch_listening_mode(dhcp_client, L2);\n\t}\n\tsend_request(dhcp_client);\n\tdhcp_client->timeout = g_timeout_add_seconds_full(G_PRIORITY_HIGH,\n\t\t\t\t\t\t\tREQUEST_TIMEOUT,\n\t\t\t\t\t\t\trequest_timeout,\n\t\t\t\t\t\t\tdhcp_client,\n\t\t\t\t\t\t\tNULL);\n}", "target": 0}
{"code": "GF_Box *reftype_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceTypeBox, GF_ISOM_BOX_TYPE_REFT);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "lexer_compare_identifier_to_current (parser_context_t *context_p,        \n                                     const lexer_lit_location_t *right)  \n{\n  lexer_lit_location_t *left = &context_p->token.lit_location;\n  const uint8_t *left_p;\n  const uint8_t *right_p;\n  size_t count;\n  JERRY_ASSERT (left->length > 0 && right->length > 0);\n  if (left->length != right->length)\n  {\n    return 0;\n  }\n  if (!left->has_escape && !right->has_escape)\n  {\n    return memcmp (left->char_p, right->char_p, left->length) == 0;\n  }\n  left_p = left->char_p;\n  right_p = right->char_p;\n  count = left->length;\n  do\n  {\n    uint8_t utf8_buf[3];\n    size_t utf8_len, offset;\n    if (*left_p != LIT_CHAR_BACKSLASH && *right_p != LIT_CHAR_BACKSLASH)\n    {\n      if (*left_p++ != *right_p++)\n      {\n        return false;\n      }\n      count--;\n      continue;\n    }\n    if (*left_p == LIT_CHAR_BACKSLASH && *right_p == LIT_CHAR_BACKSLASH)\n    {\n      uint16_t left_chr = lexer_hex_to_character (context_p, left_p, 6);\n      if (left_chr != lexer_hex_to_character (context_p, right_p, 6))\n      {\n        return false;\n      }\n      left_p += 6;\n      right_p += 6;\n      count += lit_char_get_utf8_length (left_chr);\n      continue;\n    }\n    if (*right_p == LIT_CHAR_BACKSLASH)\n    {\n      const uint8_t *swap_p = left_p;\n      left_p = right_p;\n      right_p = swap_p;\n    }\n    utf8_len = lit_char_to_utf8_bytes (utf8_buf, lexer_hex_to_character (context_p, left_p, 6));\n    JERRY_ASSERT (utf8_len > 0);\n    count -= utf8_len;\n    offset = 0;\n    do\n    {\n      if (utf8_buf[offset] != *right_p++)\n      {\n        return false;\n      }\n      offset++;\n    }\n    while (offset < utf8_len);\n    left_p += 6;\n  }\n  while (count > 0);\n  return true;\n} ", "target": 0}
{"code": "static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\tcfs_rq->runtime_remaining -= delta_exec;\n\texpire_cfs_rq_runtime(cfs_rq);\n\tif (likely(cfs_rq->runtime_remaining > 0))\n\t\treturn;\n\tif (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))\n\t\tresched_curr(rq_of(cfs_rq));\n}", "target": 1}
{"code": "spnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\tOM_uint32 ret;\n\tret = gss_import_sec_context(minor_status,\n\t\t\t\t    interprocess_token,\n\t\t\t\t    context_handle);\n\treturn (ret);\n}", "target": 1}
{"code": "static int evdev_handle_get_keycode_v2(struct input_dev *dev, void __user *p)\n{\n\tstruct input_keymap_entry ke;\n\tint error;\n\tif (copy_from_user(&ke, p, sizeof(ke)))\n\t\treturn -EFAULT;\n\terror = input_get_keycode(dev, &ke);\n\tif (error)\n\t\treturn error;\n\tif (copy_to_user(p, &ke, sizeof(ke)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "get_one_option(int optid, const struct my_option *opt,\n               char *argument)\n{\n  my_bool add_option= TRUE;\n  switch (optid) {\n  case '?':\n    printf(\"%s  Ver %s Distrib %s, for %s (%s)\\n\",\n           my_progname, VER, MYSQL_SERVER_VERSION, SYSTEM_TYPE, MACHINE_TYPE);\n    puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n    puts(\"MySQL utility for upgrading databases to new MySQL versions.\\n\");\n    my_print_help(my_long_options);\n    exit(0);\n    break;\n  case '#':\n    DBUG_PUSH(argument ? argument : default_dbug_option);\n    add_option= FALSE;\n    debug_check_flag= 1;\n    break;\n  case 'p':\n    if (argument == disabled_my_option)\n      argument= (char*) \"\";\t\t\t\n    tty_password= 1;\n    add_option= FALSE;\n    if (argument)\n    {\n      add_one_option(&ds_args, opt, argument);\n      while (*argument)\n        *argument++= 'x';                       \n      tty_password= 0;\n    }\n    break;\n  case 't':\n    my_stpnmov(opt_tmpdir, argument, sizeof(opt_tmpdir));\n    add_option= FALSE;\n    break;\n  case 'k':                                     \n  case 'v': \n  case 'f': \n  case 's':                                     \n  case OPT_WRITE_BINLOG:                        \n    add_option= FALSE;\n    break;\n  case 'h': \n  case 'W': \n  case 'P': \n  case 'S': \n  case OPT_MYSQL_PROTOCOL: \n  case OPT_SHARED_MEMORY_BASE_NAME: \n  case OPT_PLUGIN_DIR:                          \n  case OPT_DEFAULT_AUTH:                        \n    add_one_option(&conn_args, opt, argument);\n    break;\n  }\n  if (add_option)\n  {\n    add_one_option(&ds_args, opt, argument);\n  }\n  return 0;\n}", "target": 1}
{"code": "is_valid_mbc_string(const UChar* p, const UChar* end)\n{\n  const UChar* end1 = end - 1;\n  while (p < end1) {\n    p += utf16le_mbc_enc_len(p);\n  }\n  if (p != end)\n    return FALSE;\n  else\n    return TRUE;\n}", "target": 0}
{"code": "virSecuritySELinuxMCSGetProcessRange(char **sens,\n                                     int *catMin,\n                                     int *catMax)\n{\n    char *ourSecContext = NULL;\n    context_t ourContext = NULL;\n    char *cat = NULL;\n    char *tmp;\n    const char *contextRange;\n    int ret = -1;\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    if (!(contextRange = context_range_get(ourContext)))\n        contextRange = \"s0\";\n    *sens = g_strdup(contextRange);\n    tmp = strchr(*sens, ':');\n    if (tmp) {\n        *tmp = '\\0';\n        cat = tmp + 1;\n    }\n    if ((tmp = strchr(*sens, '-')))\n        *tmp = '\\0';\n    if (!cat) {\n        *catMin = 0;\n        *catMax = 1023;\n        ret = 0;\n        goto cleanup;\n    }\n    tmp = cat;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMin) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    if (!tmp[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No category range available\"));\n        goto cleanup;\n    }\n    if (tmp[0] != '.') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMax) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(*sens);\n    freecon(ourSecContext);\n    context_free(ourContext);\n    return ret;\n}", "target": 0}
{"code": "static void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t\treturn;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; \n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "int RGWPutObj_ObjStore_S3::get_decrypt_filter(\n    std::unique_ptr<RGWGetObj_Filter>* filter,\n    RGWGetObj_Filter* cb,\n    map<string, bufferlist>& attrs,\n    bufferlist* manifest_bl)\n{\n  std::map<std::string, std::string> crypt_http_responses_unused;\n  int res = 0;\n  std::unique_ptr<BlockCrypt> block_crypt;\n  res = rgw_s3_prepare_decrypt(s, attrs, &block_crypt, crypt_http_responses_unused);\n  if (res == 0) {\n    if (block_crypt != nullptr) {\n      auto f = std::unique_ptr<RGWGetObj_BlockDecrypt>(new RGWGetObj_BlockDecrypt(s->cct, cb, std::move(block_crypt)));\n      if (f != nullptr) {\n        if (manifest_bl != nullptr) {\n          res = f->read_manifest(*manifest_bl);\n          if (res == 0) {\n            *filter = std::move(f);\n          }\n        }\n      }\n    }\n  }\n  return res;\n}", "target": 0}
{"code": "njs_json_pop_parse_state(njs_vm_t *vm, njs_json_parse_t *parse)\n{\n    njs_json_state_t  *state;\n    state = &parse->states[parse->depth - 1];\n    njs_array_destroy(vm, state->keys);\n    state->keys = NULL;\n    if (parse->depth > 1) {\n        parse->depth--;\n        return &parse->states[parse->depth - 1];\n    }\n    return NULL;\n}", "target": 1}
{"code": "int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tpid_t wait_pid;\n\tint wstatus = 0;\n\tif (!fp)\n\t\treturn -1;\n\tdo {\n\t\twait_pid = waitpid(fp->child_pid, &wstatus, 0);\n\t} while (wait_pid < 0 && errno == EINTR);\n\tfclose(fp->f);\n\tfree(fp);\n\tif (wait_pid < 0)\n\t\treturn -1;\n\treturn wstatus;\n}", "target": 0}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}", "target": 1}
{"code": "static const char *screen_units_str(void)\n{\n\tconst char *units_str[] = {N_(\"mil\"), N_(\"mm\"), N_(\"in\")};\n\treturn _(units_str[screen.unit]);\n}", "target": 0}
{"code": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "int server_supports_v2(const char *c, int die_on_error)\n{\n\tint i;\n\tfor (i = 0; i < server_capabilities_v2.argc; i++) {\n\t\tconst char *out;\n\t\tif (skip_prefix(server_capabilities_v2.argv[i], c, &out) &&\n\t\t    (!*out || *out == '='))\n\t\t\treturn 1;\n\t}\n\tif (die_on_error)\n\t\tdie(_(\"server doesn't support '%s'\"), c);\n\treturn 0;\n}", "target": 0}
{"code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n    if (t < 0) {\n        t = 0;\n    }\n    days = t / 86400;\n    sec = t % 86400;\n    wday = (4 + days) % 7;\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n    days = days - (31 + 28) + 719527;\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n    mon = (yday + 31) * 10 / 306;\n    mday = yday - (367 * mon / 12 - 30) + 1;\n    if (yday >= 306) {\n        year++;\n        mon -= 10;\n    } else {\n        mon += 2;\n    }\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 1}
{"code": "static int llc_ui_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t     char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = -EINVAL, opt;\n\tlock_sock(sk);\n\tif (unlikely(level != SOL_LLC || optlen != sizeof(int)))\n\t\tgoto out;\n\trc = get_user(opt, (int __user *)optval);\n\tif (rc)\n\t\tgoto out;\n\trc = -EINVAL;\n\tswitch (optname) {\n\tcase LLC_OPT_RETRY:\n\t\tif (opt > LLC_OPT_MAX_RETRY)\n\t\t\tgoto out;\n\t\tllc->n2 = opt;\n\t\tbreak;\n\tcase LLC_OPT_SIZE:\n\t\tif (opt > LLC_OPT_MAX_SIZE)\n\t\t\tgoto out;\n\t\tllc->n1 = opt;\n\t\tbreak;\n\tcase LLC_OPT_ACK_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_ACK_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->ack_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_P_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_P_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->pf_cycle_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_REJ_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_REJ_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->rej_sent_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_BUSY_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_BUSY_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->busy_state_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_TX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->k = opt;\n\t\tbreak;\n\tcase LLC_OPT_RX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->rw = opt;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 0}
{"code": "NTSTATUS get_ea_value_fsp(TALLOC_CTX *mem_ctx,\n\t\t\t  files_struct *fsp,\n\t\t\t  const char *ea_name,\n\t\t\t  struct ea_struct *pea)\n{\n\tsize_t attr_size = 256;\n\tchar *val = NULL;\n\tssize_t sizeret;\n\tsize_t max_xattr_size = 0;\n\tif (fsp == NULL) {\n\t\treturn NT_STATUS_INVALID_HANDLE;\n\t}\n\tmax_xattr_size = lp_smbd_max_xattr_size(SNUM(fsp->conn));\n again:\n\tval = talloc_realloc(mem_ctx, val, char, attr_size);\n\tif (!val) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tsizeret = SMB_VFS_FGETXATTR(fsp, ea_name, val, attr_size);\n\tif (sizeret == -1 && errno == ERANGE && attr_size < max_xattr_size) {\n\t\tattr_size = max_xattr_size;\n\t\tgoto again;\n\t}\n\tif (sizeret == -1) {\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\tDEBUG(10,(\"get_ea_value: EA %s is of length %u\\n\", ea_name, (unsigned int)sizeret));\n\tdump_data(10, (uint8_t *)val, sizeret);\n\tpea->flags = 0;\n\tif (strnequal(ea_name, \"user.\", 5)) {\n\t\tpea->name = talloc_strdup(mem_ctx, &ea_name[5]);\n\t} else {\n\t\tpea->name = talloc_strdup(mem_ctx, ea_name);\n\t}\n\tif (pea->name == NULL) {\n\t\tTALLOC_FREE(val);\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tpea->value.data = (unsigned char *)val;\n\tpea->value.length = (size_t)sizeret;\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "struct file *get_empty_filp(void)\n{\n\tconst struct cred *cred = current_cred();\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\tpercpu_counter_inc(&nr_files);\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free(f);\n\t\treturn ERR_PTR(error);\n\t}\n\tINIT_LIST_HEAD(&f->f_u.fu_list);\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\teventpoll_init_file(f);\n\treturn f;\nover:\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}", "target": 1}
{"code": "vg_resource_attach_backing(VuGpu *g,\n                           struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_attach_backing ab;\n    int ret;\n    VUGPU_FILL_CMD(ab);\n    virtio_gpu_bswap_32(&ab, sizeof(ab));\n    res = virtio_gpu_find_resource(g, ab.resource_id);\n    if (!res) {\n        g_critical(\"%s: illegal resource specified %d\",\n                   __func__, ab.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n    if (res->iov) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n    ret = vg_create_mapping_iov(g, &ab, cmd, &res->iov);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n    res->iov_cnt = ab.nr_entries;\n}", "target": 0}
{"code": "deltas_head_init(struct deltas_head *list)\n{\n\tlist->array = NULL;\n\tlist->len = 0;\n\tlist->capacity = 0;\n}", "target": 1}
{"code": "tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\tstruct tc_action_ops *a_o;\n\tstruct tc_action a;\n\tint ret = 0;\n\tstruct tcamsg *t = (struct tcamsg *) NLMSG_DATA(cb->nlh);\n\tchar *kind = find_dump_kind(cb->nlh);\n\tif (kind == NULL) {\n\t\tprintk(\"tc_dump_action: action bad kind\\n\");\n\t\treturn 0;\n\t}\n\ta_o = tc_lookup_action_n(kind);\n\tif (a_o == NULL) {\n\t\tprintk(\"failed to find %s\\n\", kind);\n\t\treturn 0;\n\t}\n\tmemset(&a, 0, sizeof(struct tc_action));\n\ta.ops = a_o;\n\tif (a_o->walk == NULL) {\n\t\tprintk(\"tc_dump_action: %s !capable of dumping table\\n\", kind);\n\t\tgoto rtattr_failure;\n\t}\n\tnlh = NLMSG_PUT(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t                cb->nlh->nlmsg_type, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\tret = a_o->walk(skb, cb, RTM_GETACTION, &a);\n\tif (ret < 0)\n\t\tgoto rtattr_failure;\n\tif (ret > 0) {\n\t\tx->rta_len = skb->tail - (u8 *) x;\n\t\tret = skb->len;\n\t} else\n\t\tskb_trim(skb, (u8*)x - skb->data);\n\tnlh->nlmsg_len = skb->tail - b;\n\tif (NETLINK_CB(cb->skb).pid && ret)\n\t\tnlh->nlmsg_flags |= NLM_F_MULTI;\n\tmodule_put(a_o->owner);\n\treturn skb->len;\nrtattr_failure:\nnlmsg_failure:\n\tmodule_put(a_o->owner);\n\tskb_trim(skb, b - skb->data);\n\treturn skb->len;\n}", "target": 1}
{"code": "decode_labeled_prefix6(netdissect_options *ndo,\n                       const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen, plenbytes;\n\tND_TCHECK2(pptr[0], 4);\n\tITEMCHECK(4);\n\tplen = pptr[0]; \n\tif (24 > plen)\n\t\treturn -1;\n        plen-=24; \n\tif (128 < plen)\n\t\treturn -1;\n\titemlen -= 4;\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[4], plenbytes);\n\tmemcpy(&addr, &pptr[4], plenbytes);\n\tif (plen % 8) {\n\t\taddr.s6_addr[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d, label:%u %s\",\n                 ip6addr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 4 + plenbytes;\ntrunc:\n\treturn -2;\nbadtlv:\n\treturn -3;\n}", "target": 0}
{"code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}", "target": 1}
{"code": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\toverrun = timr->it_overrun_last;\n\tunlock_timer(timr, flags);\n\treturn overrun;\n}", "target": 1}
{"code": "blkcpy(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = S[i];\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\t*errsv = 0;\n\tif (!type)\n\t\treturn 0;\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tuid = getuid();\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}", "target": 1}
{"code": "static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\tif (!(rcv->flags & IFF_UP))\n\t\tgoto tx_drop;\n\tif (dev->features & NETIF_F_NO_CSUM)\n\t\tskb->ip_summed = rcv_priv->ip_summed;\n\tlength = skb->len + ETH_HLEN;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\treturn NETDEV_TX_OK;\ntx_drop:\n\tkfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\nrx_drop:\n\tkfree_skb(skb);\n\trcv_stats->rx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "void GLES2DecoderTestBase::DoVertexAttribPointer(\n    GLuint index, GLint size, GLenum type, GLsizei stride, GLuint offset) {\n  EXPECT_CALL(*gl_,\n              VertexAttribPointer(index, size, type, GL_FALSE, stride,\n                                  BufferOffset(offset)))\n      .Times(1)\n      .RetiresOnSaturation();\n  VertexAttribPointer cmd;\n  cmd.Init(index, size, GL_FLOAT, GL_FALSE, stride, offset);\n  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));\n}", "target": 0}
{"code": "int rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_for_dest_args args;\n\tstruct rds_get_mr_args new_args;\n\tif (optlen != sizeof(struct rds_get_mr_for_dest_args))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&args, (struct rds_get_mr_for_dest_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_for_dest_args)))\n\t\treturn -EFAULT;\n\tnew_args.vec = args.vec;\n\tnew_args.cookie_addr = args.cookie_addr;\n\tnew_args.flags = args.flags;\n\treturn __rds_rdma_map(rs, &new_args, NULL, NULL);\n}", "target": 0}
{"code": "smb3_receive_transform(struct TCP_Server_Info *server,\n\t\t       struct mid_q_entry **mids, char **bufs, int *num_mids)\n{\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = server->pdu_size;\n\tstruct smb2_transform_hdr *tr_hdr = (struct smb2_transform_hdr *)buf;\n\tunsigned int orig_len = le32_to_cpu(tr_hdr->OriginalMessageSize);\n\tif (pdu_length < sizeof(struct smb2_transform_hdr) +\n\t\t\t\t\t\tsizeof(struct smb2_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is too small (%u)\\n\",\n\t\t\t pdu_length);\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\tif (pdu_length < orig_len + sizeof(struct smb2_transform_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is broken\\n\");\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server)) {\n\t\treturn receive_encrypted_read(server, &mids[0], num_mids);\n\t}\n\treturn receive_encrypted_standard(server, mids, bufs, num_mids);\n}", "target": 0}
{"code": "static bool ok_inflater_init_fixed_huffman(ok_inflater *inflater) {\n    if (!inflater->fixed_literal_huffman) {\n        ok_inflater_huffman_tree *tree = ok_alloc(inflater, sizeof(ok_inflater_huffman_tree));\n        if (tree) {\n            uint8_t code_length[288];\n            int i;\n            for (i = 0; i < 144; i++) {\n                code_length[i] = 8;\n            }\n            for (i = 144; i < 256; i++) {\n                code_length[i] = 9;\n            }\n            for (i = 256; i < 280; i++) {\n                code_length[i] = 7;\n            }\n            for (i = 280; i < 288; i++) {\n                code_length[i] = 8;\n            }\n            ok_inflater_make_huffman_tree_from_array(tree, code_length,\n                                                     sizeof(code_length) / sizeof(code_length[0]));\n            inflater->fixed_literal_huffman = tree;\n        }\n    }\n    if (!inflater->fixed_distance_huffman) {\n        ok_inflater_huffman_tree *tree = ok_alloc(inflater, sizeof(ok_inflater_huffman_tree));\n        if (tree) {\n            uint8_t distance_code_length[32];\n            for (int i = 0; i < 32; i++) {\n                distance_code_length[i] = 5;\n            }\n            ok_inflater_make_huffman_tree_from_array(tree, distance_code_length, 32);\n            inflater->fixed_distance_huffman = tree;\n        }\n    }\n    return inflater->fixed_literal_huffman && inflater->fixed_distance_huffman;\n}", "target": 0}
{"code": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\tfree(originator);\n\tfree(target);\n\treturn c;\n}", "target": 1}
{"code": "void FileSystemOperation::DidFileExists(\n    const StatusCallback& callback,\n    base::PlatformFileError rv,\n    const base::PlatformFileInfo& file_info,\n    const FilePath& unused) {\n  if (rv == base::PLATFORM_FILE_OK && file_info.is_directory)\n    rv = base::PLATFORM_FILE_ERROR_NOT_A_FILE;\n  callback.Run(rv);\n}", "target": 0}
{"code": "int ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n    ushf *overlay;\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n    ss = source->state;\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds->strm = dest;\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n    ds->pending_buf = (uchf *) overlay;\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n    return Z_OK;\n#endif \n}", "target": 1}
{"code": "    long DataValue::count() const\n    {\n        return size();\n    }", "target": 0}
{"code": "zsetpagedevice(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    int code;\n    if (r_has_type(op, t_dictionary)) {\n        check_dict_read(*op);\n#if 0\t\n        if (!(r_is_local(op)))\n            return_error(gs_error_invalidaccess);\n#endif\t\n        code = zreadonly(i_ctx_p);\n        if (code < 0)\n            return code;\n    } else {\n        check_type(*op, t_null);\n    }\n    istate->pagedevice = *op;\n    pop(1);\n    return 0;\n}", "target": 0}
{"code": "static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tgoto retry_rebind;\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}", "target": 1}
{"code": "FLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, uint32_t samples, FLAC__bool is_last_block)\n{\n\tconst FLAC__byte *buffer;\n\tsize_t bytes;\n\tFLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));\n\tif(!FLAC__bitwriter_get_buffer(encoder->private_->frame, &buffer, &bytes)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\tif(encoder->protected_->verify) {\n\t\tencoder->private_->verify.output.data = buffer;\n\t\tencoder->private_->verify.output.bytes = bytes;\n\t\tif(encoder->private_->verify.state_hint == ENCODER_IN_MAGIC) {\n\t\t\tencoder->private_->verify.needs_magic_hack = true;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__stream_decoder_process_single(encoder->private_->verify.decoder)) {\n\t\t\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\t\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\t\t\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA)\n\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif(write_frame_(encoder, buffer, bytes, samples, is_last_block) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\treturn false;\n\t}\n\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\tFLAC__bitwriter_clear(encoder->private_->frame);\n\tif(samples > 0) {\n\t\tencoder->private_->streaminfo.data.stream_info.min_framesize = flac_min(bytes, encoder->private_->streaminfo.data.stream_info.min_framesize);\n\t\tencoder->private_->streaminfo.data.stream_info.max_framesize = flac_max(bytes, encoder->private_->streaminfo.data.stream_info.max_framesize);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\tjbd2_might_wait_for_commit(journal);\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\tjbd2_journal_wait_updates(journal);\n\twrite_unlock(&journal->j_state_lock);\n\tmutex_lock(&journal->j_barrier);\n}", "target": 1}
{"code": "static void vhost_vsock_common_send_transport_reset(VHostVSockCommon *vvc)\n{\n    VirtQueueElement *elem;\n    VirtQueue *vq = vvc->event_vq;\n    struct virtio_vsock_event event = {\n        .id = cpu_to_le32(VIRTIO_VSOCK_EVENT_TRANSPORT_RESET),\n    };\n    elem = virtqueue_pop(vq, sizeof(VirtQueueElement));\n    if (!elem) {\n        error_report(\"vhost-vsock missed transport reset event\");\n        return;\n    }\n    if (elem->out_num) {\n        error_report(\"invalid vhost-vsock event virtqueue element with \"\n                     \"out buffers\");\n        goto out;\n    }\n    if (iov_from_buf(elem->in_sg, elem->in_num, 0,\n                     &event, sizeof(event)) != sizeof(event)) {\n        error_report(\"vhost-vsock event virtqueue element is too short\");\n        goto out;\n    }\n    virtqueue_push(vq, elem, sizeof(event));\n    virtio_notify(VIRTIO_DEVICE(vvc), vq);\nout:\n    g_free(elem);\n}", "target": 1}
{"code": "Value ExpressionRegex::nextMatch(RegexExecutionState* regexState) const {\n    int execResult = execute(regexState);\n    if (execResult < 0) {\n        return Value(BSONNULL);\n    }\n    StringData input = *(regexState->input);\n    auto verifyBounds = [&input, this](auto startPos, auto limitPos, auto isCapture) {\n        if (startPos == -1 || limitPos == -1) {\n            massert(31304,\n                    str::stream() << \"Unexpected error occurred while executing \" << _opName\n                                  << \". startPos: \" << startPos << \", limitPos: \" << limitPos,\n                    isCapture && startPos == -1 && limitPos == -1);\n            return;\n        }\n        massert(31305,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". startPos: \" << startPos,\n                (startPos >= 0 && static_cast<size_t>(startPos) <= input.size()));\n        massert(31306,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". limitPos: \" << limitPos,\n                (limitPos >= 0 && static_cast<size_t>(limitPos) <= input.size()));\n        massert(31307,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". startPos: \" << startPos << \", limitPos: \" << limitPos,\n                startPos <= limitPos);\n    };\n    verifyBounds(regexState->capturesBuffer[0], regexState->capturesBuffer[1], false);\n    const int matchStartByteIndex = regexState->capturesBuffer[0];\n    StringData matchedStr =\n        input.substr(matchStartByteIndex, regexState->capturesBuffer[1] - matchStartByteIndex);\n    for (int byteIx = regexState->startBytePos; byteIx < matchStartByteIndex;\n         ++(regexState->startCodePointPos)) {\n        byteIx += getCodePointLength(input[byteIx]);\n    }\n    regexState->startBytePos = matchStartByteIndex;\n    std::vector<Value> captures;\n    captures.reserve(regexState->numCaptures);\n    for (int i = 0; i < regexState->numCaptures; ++i) {\n        const int start = regexState->capturesBuffer[2 * (i + 1)];\n        const int limit = regexState->capturesBuffer[2 * (i + 1) + 1];\n        verifyBounds(start, limit, true);\n        captures.push_back(start == -1 && limit == -1 ? Value(BSONNULL)\n                                                      : Value(input.substr(start, limit - start)));\n    }\n    MutableDocument match;\n    match.addField(\"match\", Value(matchedStr));\n    match.addField(\"idx\", Value(regexState->startCodePointPos));\n    match.addField(\"captures\", Value(captures));\n    return match.freezeToValue();\n}", "target": 0}
{"code": "GfxShading *GfxShading::parse(GfxResources *res, Object *obj, OutputDev *out, GfxState *state)\n{\n    GfxShading *shading;\n    Dict *dict;\n    int typeA;\n    Object obj1;\n    if (obj->isDict()) {\n        dict = obj->getDict();\n    } else if (obj->isStream()) {\n        dict = obj->streamGetDict();\n    } else {\n        return nullptr;\n    }\n    obj1 = dict->lookup(\"ShadingType\");\n    if (!obj1.isInt()) {\n        error(errSyntaxWarning, -1, \"Invalid ShadingType in shading dictionary\");\n        return nullptr;\n    }\n    typeA = obj1.getInt();\n    switch (typeA) {\n    case 1:\n        shading = GfxFunctionShading::parse(res, dict, out, state);\n        break;\n    case 2:\n        shading = GfxAxialShading::parse(res, dict, out, state);\n        break;\n    case 3:\n        shading = GfxRadialShading::parse(res, dict, out, state);\n        break;\n    case 4:\n        if (obj->isStream()) {\n            shading = GfxGouraudTriangleShading::parse(res, 4, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 4 shading object\");\n            goto err1;\n        }\n        break;\n    case 5:\n        if (obj->isStream()) {\n            shading = GfxGouraudTriangleShading::parse(res, 5, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 5 shading object\");\n            goto err1;\n        }\n        break;\n    case 6:\n        if (obj->isStream()) {\n            shading = GfxPatchMeshShading::parse(res, 6, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 6 shading object\");\n            goto err1;\n        }\n        break;\n    case 7:\n        if (obj->isStream()) {\n            shading = GfxPatchMeshShading::parse(res, 7, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 7 shading object\");\n            goto err1;\n        }\n        break;\n    default:\n        error(errSyntaxWarning, -1, \"Unimplemented shading type {0:d}\", typeA);\n        goto err1;\n    }\n    return shading;\nerr1:\n    return nullptr;\n}", "target": 0}
{"code": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems;\n\tint error;\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\t\tgoto out;\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\tnsems = sma->sem_nsems;\n\tipc_rcu_getref(sma);\n\trcu_read_unlock();\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tif (un) {\n\t\tkfree(new);\n\t\tgoto success;\n\t}\n\tnew->semadj = (short *) &new[1];\n\tnew->ulp = ulp;\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma);\nout:\n\treturn un;\n}", "target": 1}
{"code": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n}", "target": 1}
{"code": "static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)\n{\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\treturn err;\n}", "target": 0}
{"code": "        int          GetU16BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 1 >= m_nLen)\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            return nRes;\n        }", "target": 1}
{"code": "static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\n{\n  unsigned error = 0;\n  char *key = 0, *str = 0;\n  unsigned i;\n  while(!error) \n  {\n    unsigned length, string2_begin;\n    length = 0;\n    while(length < chunkLength && data[length] != 0) length++;\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); \n    key = (char*)malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); \n    key[length] = 0;\n    for(i = 0; i < length; i++) key[i] = (char)data[i];\n    string2_begin = length + 1; \n    length = chunkLength < string2_begin ? 0 : chunkLength - string2_begin;\n    str = (char*)malloc(length + 1);\n    if(!str) CERROR_BREAK(error, 83); \n    str[length] = 0;\n    for(i = 0; i < length; i++) str[i] = (char)data[string2_begin + i];\n    error = lodepng_add_text(info, key, str);\n    break;\n  }\n  free(key);\n  free(str);\n  return error;\n}", "target": 0}
{"code": "GF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "static void power_pmu_disable(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuhw;\n\tunsigned long flags;\n\tif (!ppmu)\n\t\treturn;\n\tlocal_irq_save(flags);\n\tcpuhw = &__get_cpu_var(cpu_hw_events);\n\tif (!cpuhw->disabled) {\n\t\tcpuhw->disabled = 1;\n\t\tcpuhw->n_added = 0;\n\t\tif (!cpuhw->pmcs_enabled) {\n\t\t\tppc_enable_pmcs();\n\t\t\tcpuhw->pmcs_enabled = 1;\n\t\t}\n\t\tif (cpuhw->mmcr[2] & MMCRA_SAMPLE_ENABLE) {\n\t\t\tmtspr(SPRN_MMCRA,\n\t\t\t      cpuhw->mmcr[2] & ~MMCRA_SAMPLE_ENABLE);\n\t\t\tmb();\n\t\t}\n\t\twrite_mmcr0(cpuhw, mfspr(SPRN_MMCR0) | MMCR0_FC);\n\t\tmb();\n\t}\n\tlocal_irq_restore(flags);\n}", "target": 0}
{"code": "BnGeneratePrimeForRSA(\n\t\t      bigNum          prime,\n\t\t      UINT32          bits,\n\t\t      UINT32          exponent,\n\t\t      RAND_STATE      *rand\n\t\t      )\n{\n    BOOL            found = FALSE;\n    pAssert(prime->allocated >= BITS_TO_CRYPT_WORDS(bits));\n    pAssert((bits % 32) == 0);\n    prime->size = BITS_TO_CRYPT_WORDS(bits);\n    while(!found)\n\t{\n\t    DRBG_Generate(rand, (BYTE *)prime->d, (UINT16)BITS_TO_BYTES(bits));\n\t    RsaAdjustPrimeCandidate(prime);\n\t    found = RsaCheckPrime(prime, exponent, rand) == TPM_RC_SUCCESS;\n\t}\n}", "target": 0}
{"code": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}", "target": 1}
{"code": "get_blk_size(int fd)\n{\n\tstruct stat stat;\n\tint ret;\n\tret = fstat(fd, &stat);\n\treturn ret == -1 ? (uint64_t)-1 : (uint64_t)stat.st_blksize;\n}", "target": 0}
{"code": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempted to set secure setting.\");\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\tconst char *disallowed[] = {\n\t\t\"main_menu_script\", \"shader_path\", \"texture_path\", \"screenshot_path\",\n\t\t\"serverlist_file\", \"serverlist_url\", \"map-dir\", \"contentdb_url\",\n\t};\n\tif (!is_mainmenu) {\n\t\tfor (const char *name2 : disallowed) {\n\t\t\tif (name == name2)\n\t\t\t\tthrow LuaError(\"Attempted to set disallowed setting.\");\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void php_snmp_session_destructor(zend_resource *rsrc) \n{\n\tphp_snmp_session *session = (php_snmp_session *)rsrc->ptr;\n\tnetsnmp_session_free(&session);\n}", "target": 0}
{"code": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "LayoutUnit RenderBox::availableLogicalHeightUsing(const Length& h) const\n{\n    if (h.isFixed())\n        return computeContentBoxLogicalHeight(h.value());\n    if (isRenderView())\n        return isHorizontalWritingMode() ? toRenderView(this)->frameView()->visibleHeight() : toRenderView(this)->frameView()->visibleWidth();\n     if (isTableCell() && (h.isAuto() || h.isPercent()))\n         return overrideHeight() - borderAndPaddingLogicalWidth();\n    if (h.isPercent())\n       return computeContentBoxLogicalHeight(h.calcValue(containingBlock()->availableLogicalHeight()));\n    if (isRenderBlock() && isPositioned() && style()->height().isAuto() && !(style()->top().isAuto() || style()->bottom().isAuto())) {\n        RenderBlock* block = const_cast<RenderBlock*>(toRenderBlock(this));\n        LayoutUnit oldHeight = block->logicalHeight();\n        block->computeLogicalHeight();\n        LayoutUnit newHeight = block->computeContentBoxLogicalHeight(block->contentLogicalHeight());\n        block->setLogicalHeight(oldHeight);\n        return computeContentBoxLogicalHeight(newHeight);\n    }\n    return containingBlock()->availableLogicalHeight();\n}", "target": 1}
{"code": " bool OmniboxViewViews::ShouldShowPlaceholderText() const {\n   return Textfield::ShouldShowPlaceholderText() &&\n         !model()->is_caret_visible() && !model()->is_keyword_selected();\n }", "target": 1}
{"code": "  void ComputeAsyncImpl(OpKernelContext* c, CollectiveExecutor* col_exec,\n                        DoneCallback done) override {\n    auto output_shape = c->input(0).shape();\n    OP_REQUIRES_ASYNC(c, output_shape.dims() > 0,\n                      errors::InvalidArgument(\"input should have rank > 0, \",\n                                              \"recieved \", output_shape.dims()),\n                      done);\n    output_shape.set_dim(\n        0, output_shape.dim_size(0) * col_params_->group.group_size);\n    col_params_->instance.shape = output_shape;\n    if (c->mutable_output(0) == nullptr) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          c, c->allocate_output(0, col_params_->instance.shape, &output), done);\n    }\n    if (!CanProceedWithCompute(c, col_exec, done)) return;\n    auto actual_done = [c, col_params = col_params_, done](const Status& s) {\n      VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync done for collective \"\n              << c->op_kernel().name() << \" device \" << c->device()->name()\n              << \" group \" << col_params->group.group_key << \" instance \"\n              << col_params->instance.instance_key << \" status \" << s;\n      col_params->Unref();\n      OP_REQUIRES_OK_ASYNC(c, s, done);\n      done();\n    };\n    VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync start for collective \"\n            << col_params_->name << \" device \" << c->device()->name()\n            << \" group \" << col_params_->group.group_key << \" instance \"\n            << col_params_->instance.instance_key;\n    col_params_->Ref();\n    col_exec->ExecuteAsync(c, col_params_, GetCollectiveKey(c), actual_done);\n  }", "target": 0}
{"code": "void js_throw(js_State *J)\n{\n\tif (J->trytop > 0) {\n\t\tjs_Value v = *stackidx(J, -1);\n\t\t--J->trytop;\n\t\tJ->E = J->trybuf[J->trytop].E;\n\t\tJ->envtop = J->trybuf[J->trytop].envtop;\n\t\tJ->tracetop = J->trybuf[J->trytop].tracetop;\n\t\tJ->top = J->trybuf[J->trytop].top;\n\t\tJ->bot = J->trybuf[J->trytop].bot;\n\t\tjs_pushvalue(J, v);\n\t\tlongjmp(J->trybuf[J->trytop].buf, 1);\n\t}\n\tif (J->panic)\n\t\tJ->panic(J);\n\tabort();\n}", "target": 0}
{"code": "vg_get_config(VuDev *dev, uint8_t *config, uint32_t len)\n{\n    VuGpu *g = container_of(dev, VuGpu, dev.parent);\n    if (len > sizeof(struct virtio_gpu_config)) {\n        return -1;\n    }\n    if (opt_virgl) {\n        g->virtio_config.num_capsets = vg_virgl_get_num_capsets();\n    }\n    memcpy(config, &g->virtio_config, len);\n    return 0;\n}", "target": 0}
{"code": "void gru_check_context_placement(struct gru_thread_state *gts)\n{\n\tstruct gru_state *gru;\n\tgru = gts->ts_gru;\n\tif (!gru || gts->ts_tgid_owner != current->tgid)\n\t\treturn;\n\tif (!gru_check_chiplet_assignment(gru, gts)) {\n\t\tSTAT(check_context_unload);\n\t\tgru_unload_context(gts, 1);\n\t} else if (gru_retarget_intr(gts)) {\n\t\tSTAT(check_context_retarget_intr);\n\t}\n}", "target": 1}
{"code": "void gf_fs_print_non_connected(GF_FilterSession *fsess)\n{\n\tgf_fs_print_not_connected_filters(fsess, NULL, GF_FALSE);\n}", "target": 0}
{"code": "static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tint ret;\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tif (p->sel.prefixlen_d > 32 || p->sel.prefixlen_s > 32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (p->sel.prefixlen_d > 128 || p->sel.prefixlen_s > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tret = verify_policy_dir(p->dir);\n\tif (ret)\n\t\treturn ret;\n\tif (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "RedVDIReadBuf::~RedVDIReadBuf()\n{\n    dev->priv->num_read_buf--;\n    if (dev->priv->agent_attached) {\n       dev->wakeup();\n    }\n}", "target": 0}
{"code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_reset_classperms_list(cp->classperms);\n}", "target": 1}
{"code": "irc_server_set_prefix_modes_chars (struct t_irc_server *server,\n                                   const char *prefix)\n{\n    char *pos;\n    int i, length_modes, length_chars;\n    if (!server || !prefix)\n        return;\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n    pos = strchr (prefix, ')');\n    if (pos)\n    {\n        server->prefix_modes = weechat_strndup (prefix + 1,\n                                                pos - prefix - 1);\n        if (server->prefix_modes)\n        {\n            pos++;\n            length_modes = strlen (server->prefix_modes);\n            length_chars = strlen (pos);\n            server->prefix_chars = malloc (length_modes + 1);\n            if (server->prefix_chars)\n            {\n                for (i = 0; i < length_modes; i++)\n                {\n                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';\n                }\n                server->prefix_chars[length_modes] = '\\0';\n            }\n            else\n            {\n                free (server->prefix_modes);\n                server->prefix_modes = NULL;\n            }\n        }\n    }\n}", "target": 1}
{"code": "static void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}", "target": 1}
{"code": "static struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\tarea->bitmap = kzalloc(BITS_TO_LONGS(UINSNS_PER_PAGE) * sizeof(long), GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}", "target": 0}
{"code": "nm_wildcard_match_check(const char *str, const char *const *patterns, guint num_patterns)\n{\n    gboolean has_optional     = FALSE;\n    gboolean has_any_optional = FALSE;\n    guint    i;\n    for (i = 0; i < num_patterns; i++) {\n        gboolean    is_inverted;\n        gboolean    is_mandatory;\n        gboolean    match;\n        const char *p;\n        _pattern_parse(patterns[i], &p, &is_inverted, &is_mandatory);\n        match = (fnmatch(p, str, 0) == 0);\n        if (is_inverted)\n            match = !match;\n        if (is_mandatory) {\n            if (!match)\n                return FALSE;\n        } else {\n            has_any_optional = TRUE;\n            if (match)\n                has_optional = TRUE;\n        }\n    }\n    return has_optional || !has_any_optional;\n}", "target": 1}
{"code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tkey = keyring_search_aux(keyring, &ctx);\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 1}
{"code": "static struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}", "target": 0}
{"code": "static bool translation_pre_enabled(struct intel_iommu *iommu)\n{\n\treturn (iommu->flags & VTD_FLAG_TRANS_PRE_ENABLED);\n}", "target": 0}
{"code": "static void nvme_format_bh(void *opaque)\n{\n    NvmeFormatAIOCB *iocb = opaque;\n    NvmeRequest *req = iocb->req;\n    NvmeCtrl *n = nvme_ctrl(req);\n    uint32_t dw10 = le32_to_cpu(req->cmd.cdw10);\n    uint8_t lbaf = dw10 & 0xf;\n    uint8_t pi = (dw10 >> 5) & 0x7;\n    uint16_t status;\n    int i;\n    if (iocb->ret < 0) {\n        goto done;\n    }\n    if (iocb->broadcast) {\n        for (i = iocb->nsid + 1; i <= NVME_MAX_NAMESPACES; i++) {\n            iocb->ns = nvme_ns(n, i);\n            if (iocb->ns) {\n                iocb->nsid = i;\n                break;\n            }\n        }\n    }\n    if (!iocb->ns) {\n        goto done;\n    }\n    status = nvme_format_check(iocb->ns, lbaf, pi);\n    if (status) {\n        req->status = status;\n        goto done;\n    }\n    iocb->ns->status = NVME_FORMAT_IN_PROGRESS;\n    nvme_format_ns_cb(iocb, 0);\n    return;\ndone:\n    qemu_bh_delete(iocb->bh);\n    iocb->bh = NULL;\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n    qemu_aio_unref(iocb);\n}", "target": 0}
{"code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\tdevinfo.version_code = COMEDI_VERSION_CODE;\n\tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n\tif (read_subdev)\n\t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n{\n\tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n\tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n\t\t\t\t\t hashbin_lock_depth++);\n\t}\n\tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\t\twhile (queue ) {\n\t\t\tif (free_func)\n\t\t\t\t(*free_func)(queue);\n\t\t\tqueue = dequeue_first(\n\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n\t\t}\n\t}\n\thashbin->hb_current = NULL;\n\thashbin->magic = ~HB_MAGIC;\n\tif ( hashbin->hb_type & HB_LOCK) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n#ifdef CONFIG_LOCKDEP\n\t\thashbin_lock_depth--;\n#endif\n\t}\n\tkfree(hashbin);\n\treturn 0;\n}", "target": 1}
{"code": "void SSecurityTLS::shutdown()\n{\n  if (session) {\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS) {\n      vlog.error(\"TLS session wasn't terminated gracefully\");\n    }\n  }\n  if (dh_params) {\n    gnutls_dh_params_deinit(dh_params);\n    dh_params = 0;\n  }\n  if (anon_cred) {\n    gnutls_anon_free_server_credentials(anon_cred);\n    anon_cred = 0;\n  }\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n    gnutls_global_deinit();\n  }\n}", "target": 1}
{"code": "_gnutls_x509_encode_and_copy_PKI_params(ASN1_TYPE dst,\n\t\t\t\t\tconst char *dst_name,\n\t\t\t\t\tgnutls_pk_algorithm_t\n\t\t\t\t\tpk_algorithm,\n\t\t\t\t\tgnutls_pk_params_st * params)\n{\n\tconst char *pk;\n\tgnutls_datum_t der = { NULL, 0 };\n\tint result;\n\tchar name[128];\n\tpk = _gnutls_x509_pk_to_oid(pk_algorithm);\n\tif (pk == NULL) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_UNKNOWN_PK_ALGORITHM;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".algorithm.algorithm\");\n\tresult = asn1_write_value(dst, name, pk, 1);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult =\n\t    _gnutls_x509_write_pubkey_params(pk_algorithm, params, &der);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".algorithm.parameters\");\n\tresult = asn1_write_value(dst, name, der.data, der.size);\n\t_gnutls_free_datum(&der);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = _gnutls_x509_write_pubkey(pk_algorithm, params, &der);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".subjectPublicKey\");\n\tresult = asn1_write_value(dst, name, der.data, der.size * 8);\n\t_gnutls_free_datum(&der);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "uint32_t enc_untrusted_qe_get_quote_size(uint32_t *quote_size) {\n  uint32_t result;\n  CHECK_OCALL(ocall_enc_untrusted_qe_get_quote_size(&result, quote_size));\n  return result;\n}", "target": 0}
{"code": "isdn_statstr(void)\n{\n\tstatic char istatbuf[2048];\n\tchar *p;\n\tint i;\n\tsprintf(istatbuf, \"idmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%s \", (dev->drvmap[i] < 0) ? \"-\" : dev->drvid[dev->drvmap[i]]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nchmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->chanmap[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\ndrmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->drvmap[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nusage:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->usage[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nflags:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++) {\n\t\tif (dev->drv[i]) {\n\t\t\tsprintf(p, \"%ld \", dev->drv[i]->online);\n\t\t\tp = istatbuf + strlen(istatbuf);\n\t\t} else {\n\t\t\tsprintf(p, \"? \");\n\t\t\tp = istatbuf + strlen(istatbuf);\n\t\t}\n\t}\n\tsprintf(p, \"\\nphone:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%s \", dev->num[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\n\");\n\treturn istatbuf;\n}", "target": 0}
{"code": "void ACLosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    ULONG  x = m_ulX[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        LONG v;\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        if (m_Coder.Get(zset.S0)) {\n          LONG sz   = 0;\n          bool sign = m_Coder.Get(zset.SS); \n          if (m_Coder.Get((sign)?(zset.SN):(zset.SP))) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            while(m_Coder.Get(mset.X[i])) {\n              m <<= 1;\n              i++;\n            }\n            m >>= 1;\n            sz  = m;\n            while((m >>= 1)) {\n              if (m_Coder.Get(mset.M[i])) {\n                sz |= m;\n              }\n            }\n          }\n          if (sign) {\n            v = -sz - 1;\n          } else {\n            v =  sz + 1;\n          }\n        } else {\n          v = 0;\n        }\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}", "target": 1}
{"code": "user_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member *m)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name,\n\t\tdef_netgroup_tuple ? lhost : NULL,\n\t\tdef_netgroup_tuple ? shost : NULL, pw->pw_name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase USERGROUP:\n\t    if (usergr_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {\n\t\tconst int rc = userlist_matches(parse_tree, pw, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (userpw_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "void ConnectDialog::lookedUp() {\n\tServerResolver *sr = qobject_cast<ServerResolver *>(QObject::sender());\n\tsr->deleteLater();\n\tQString hostname = sr->hostname().toLower();\n\tunsigned short port = sr->port();\n\tUnresolvedServerAddress unresolved(hostname, port);\n\tqsDNSActive.remove(unresolved);\n\tif (sr->records().size() == 0) {\n\t\treturn;\n\t}\n\tQSet<ServerAddress> qs;\n\tforeach (ServerResolverRecord record, sr->records()) {\n\t\tforeach(const HostAddress &ha, record.addresses()) {\n\t\t\tqs.insert(ServerAddress(ha, record.port()));\n\t\t}\n\t}\n\tQSet<ServerItem *> waiting = qhDNSWait[unresolved];\n\tforeach(ServerItem *si, waiting) {\n\t\tforeach (const ServerAddress &addr, qs) {\n\t\t\tqhPings[addr].insert(si);\n\t\t}\n\t\tsi->qlAddresses = qs.toList();\n\t}\n\tqlDNSLookup.removeAll(unresolved);\n\tqhDNSCache.insert(unresolved, qs.toList());\n\tqhDNSWait.remove(unresolved);\n\tforeach(ServerItem *si, waiting) {\n\t\tif (si == qtwServers->currentItem()) {\n\t\t\ton_qtwServers_currentItemChanged(si, si);\n\t\t\tif (si == siAutoConnect)\n\t\t\t\taccept();\n\t\t}\n\t}\n\tif (bAllowPing) {\n\t\tforeach(const ServerAddress &addr, qs) {\n\t\t\tsendPing(addr.host.toAddress(), addr.port);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int update_private_key(const u8 *key, size_t keysize)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tidx = keysize * (opt_key_num-1);\n\tr = sc_update_binary(card, idx, key, keysize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to write private key: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, int aligned)\n{\n\tint buffers = 0, error = 0;\n\tdown_read(&current->mm->mmap_sem);\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\t\terror = -EFAULT;\n\t\tif (copy_from_user_mmap_sem(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (unlikely(!base))\n\t\t\tbreak;\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > PIPE_BUFFERS - buffers)\n\t\t\tnpages = PIPE_BUFFERS - buffers;\n\t\terror = get_user_pages(current, current->mm,\n\t\t\t\t       (unsigned long) base, npages, 0, 0,\n\t\t\t\t       &pages[buffers], NULL);\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\t\tif (len)\n\t\t\tbreak;\n\t\tif (error < npages || buffers == PIPE_BUFFERS)\n\t\t\tbreak;\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\tup_read(&current->mm->mmap_sem);\n\tif (buffers)\n\t\treturn buffers;\n\treturn error;\n}", "target": 1}
{"code": "validate_commit_metadata (GVariant   *commit_data,\n                          const char *ref,\n                          const char *required_metadata,\n                          gsize       required_metadata_size,\n                          GError   **error)\n{\n  g_autoptr(GVariant) commit_metadata = NULL;\n  g_autoptr(GVariant) xa_metadata_v = NULL;\n  const char *xa_metadata = NULL;\n  gsize xa_metadata_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  if (commit_metadata != NULL)\n    {\n      xa_metadata_v = g_variant_lookup_value (commit_metadata,\n                                              \"xa.metadata\",\n                                              G_VARIANT_TYPE_STRING);\n      if (xa_metadata_v)\n        xa_metadata = g_variant_get_string (xa_metadata_v, &xa_metadata_size);\n    }\n  if (xa_metadata == NULL ||\n      xa_metadata_size != required_metadata_size ||\n      memcmp (xa_metadata, required_metadata, xa_metadata_size) != 0)\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                   _(\"Commit metadata for %s not matching expected metadata\"), ref);\n      return FALSE;\n    }\n  return TRUE;\n}", "target": 0}
{"code": "static int snd_usb_accessmusic_boot_quirk(struct usb_device *dev)\n{\n\tint err, actual_length;\n\tstatic const u8 seq[] = { 0x4e, 0x73, 0x52, 0x01 };\n\tvoid *buf = kmemdup(seq, ARRAY_SIZE(seq), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = usb_interrupt_msg(dev, usb_sndintpipe(dev, 0x05), buf,\n\t\t\tARRAY_SIZE(seq), &actual_length, 1000);\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}", "target": 0}
{"code": "void SetLineWidth(double w) {\n    outpos +=\n    sprintf(outpos,\" %12.3f w\",w);\n}", "target": 1}
{"code": "f_kind_of_p(VALUE x, VALUE c)\n{\n    return rb_obj_is_kind_of(x, c);\n}", "target": 0}
{"code": "static int _make_remark(struct pwb_context *ctx,\n\t\t\tint type,\n\t\t\tconst char *text)\n{\n\tint retval = PAM_SUCCESS;\n\tstruct pam_message *pmsg[1], msg[1];\n\tstruct pam_response *resp;\n\tif (ctx->flags & WINBIND_SILENT) {\n\t\treturn PAM_SUCCESS;\n\t}\n\tpmsg[0] = &msg[0];\n\tmsg[0].msg = discard_const_p(char, text);\n\tmsg[0].msg_style = type;\n\tresp = NULL;\n\tretval = converse(ctx->pamh, 1, pmsg, &resp);\n\tif (resp) {\n\t\t_pam_drop_reply(resp, 1);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "void FileSystemOperation::DidWrite(\n    base::PlatformFileError rv,\n    int64 bytes,\n    bool complete) {\n  if (write_callback_.is_null()) {\n    delete this;\n    return;\n  }\n  write_callback_.Run(rv, bytes, complete);\n  if (complete || rv != base::PLATFORM_FILE_OK)\n    delete this;\n}", "target": 0}
{"code": "void SimpleSoftOMXComponent::onSendCommand(\n        OMX_COMMANDTYPE cmd, OMX_U32 param) {\n switch (cmd) {\n case OMX_CommandStateSet:\n {\n            onChangeState((OMX_STATETYPE)param);\n break;\n }\n case OMX_CommandPortEnable:\n case OMX_CommandPortDisable:\n {\n            onPortEnable(param, cmd == OMX_CommandPortEnable);\n break;\n }\n case OMX_CommandFlush:\n {\n            onPortFlush(param, true );\n break;\n }\n default:\n            TRESPASS();\n break;\n }\n}", "target": 0}
{"code": "DNSRequest::DNSRequest(DNS* dns, int rid, const std::string &original) : dnsobj(dns)\n{\n\tres = new unsigned char[sizeof(DNSHeader) * 2];\n\t*res = 0;\n\torig = original;\n\tRequestTimeout* RT = new RequestTimeout(ServerInstance->Config->dns_timeout ? ServerInstance->Config->dns_timeout : 5, this, rid);\n\tServerInstance->Timers->AddTimer(RT); \n}", "target": 0}
{"code": "static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)\n{\n    const xmlChar * numstr;\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        numstr = xmlTextReaderConstValue(reader);\n        if (numstr) {\n            *value = atol((const char *)numstr);\n            if (*value < 0) {\n                cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                return CL_EFORMAT;\n            }\n            return CL_SUCCESS;\n        }\n    }\n    cli_dbgmsg(\"cli_scanxar: No text for XML element\\n\");\n    return CL_EFORMAT;\n}", "target": 1}
{"code": "RsaAdjustPrimeCandidate(\n\t\t\tbigNum          prime,\n\t\t\tSEED_COMPAT_LEVEL seedCompatLevel  \n\t\t\t)\n{\n    switch (seedCompatLevel) {\n    case SEED_COMPAT_LEVEL_ORIGINAL:\n        RsaAdjustPrimeCandidate_PreRev155(prime);\n        break;\n    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:\n        RsaAdjustPrimeCandidate_New(prime);\n        break;\n    default:\n        FAIL(FATAL_ERROR_INTERNAL);\n    }\n}", "target": 1}
{"code": "test_appheader (xd3_stream *stream, int ignore)\n{\n  int i;\n  int ret;\n  char buf[TESTBUFSIZE];\n  char bogus[TESTBUFSIZE];\n  xoff_t ssize, tsize;\n  test_setup ();\n  if ((ret = test_make_inputs (stream, &ssize, &tsize))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"%s -q -f -e -s %s %s %s\", program_name,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_copy_to (program_name, TEST_RECON2_FILE))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"chmod 0700 %s\", TEST_RECON2_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_save_copy (TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_copy_to (TEST_SOURCE_FILE, TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) == 0)\n    {\n      return XD3_INVALID;  \n    }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) != 0)\n    {\n      return ret;\n    }\n  for (i = 0; i < TESTBUFSIZE / 4; ++i)\n    {\n      bogus[2*i] = 'G';\n      bogus[2*i+1] = '/';\n    }\n  bogus[TESTBUFSIZE/2-1] = 0;\n  snprintf_func (buf, TESTBUFSIZE, \n\t\t \"%s -q -f -A=%s -e -s %s %s %s\", program_name, bogus,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf)) == 0) \n    { \n      return XD3_INVALID;  \n    }\n  if (!WIFEXITED(ret))\n    {\n      return XD3_INVALID;  \n    }\n  return 0;\n}", "target": 0}
{"code": "call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t    return NULL;\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n    return qftf_list;\n}", "target": 1}
{"code": "static int nft_delflowtable_hook(struct nft_ctx *ctx,\n\t\t\t\t struct nft_flowtable *flowtable)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tLIST_HEAD(flowtable_del_list);\n\tstruct nft_hook *this, *hook;\n\tstruct nft_trans *trans;\n\tint err;\n\terr = nft_flowtable_parse_hook(ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, false);\n\tif (err < 0)\n\t\treturn err;\n\tlist_for_each_entry(this, &flowtable_hook.list, list) {\n\t\thook = nft_hook_list_find(&flowtable->hook_list, this);\n\t\tif (!hook) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_flowtable_del_hook;\n\t\t}\n\t\tlist_move(&hook->list, &flowtable_del_list);\n\t}\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_DELFLOWTABLE,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (!trans) {\n\t\terr = -ENOMEM;\n\t\tgoto err_flowtable_del_hook;\n\t}\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_flowtable_update(trans) = true;\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tlist_splice(&flowtable_del_list, &nft_trans_flowtable_hooks(trans));\n\tnft_flowtable_hook_release(&flowtable_hook);\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\nerr_flowtable_del_hook:\n\tlist_splice(&flowtable_del_list, &flowtable->hook_list);\n\tnft_flowtable_hook_release(&flowtable_hook);\n\treturn err;\n}", "target": 0}
{"code": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}", "target": 1}
{"code": "print_address_information(address_item *addr, FILE *f, uschar *si, uschar *sc,\n  uschar *se)\n{\nBOOL yield = TRUE;\nuschar *printed = US\"\";\naddress_item *ancestor = addr;\nwhile (ancestor->parent) ancestor = ancestor->parent;\nfprintf(f, \"%s\", CS si);\nif (addr->parent && testflag(addr, af_hide_child))\n  {\n  printed = US\"an undisclosed address\";\n  yield = FALSE;\n  }\nelse if (!testflag(addr, af_pfr) || !addr->parent)\n  printed = addr->address;\nelse\n  {\n  uschar *s = addr->address;\n  uschar *ss;\n  if (addr->address[0] == '>') { ss = US\"mail\"; s++; }\n  else if (addr->address[0] == '|') ss = US\"pipe\";\n  else ss = US\"save\";\n  fprintf(f, \"%s to %s%sgenerated by \", ss, s, sc);\n  printed = addr->parent->address;\n  }\nfprintf(f, \"%s\", CS string_printing(printed));\nif (ancestor != addr)\n  {\n  uschar *original = ancestor->onetime_parent;\n  if (!original) original= ancestor->address;\n  if (strcmpic(original, printed) != 0)\n    fprintf(f, \"%s(%sgenerated from %s)\", sc,\n      ancestor != addr->parent ? \"ultimately \" : \"\",\n      string_printing(original));\n  }\nif (addr->host_used)\n  fprintf(f, \"\\n    host %s [%s]\",\n\t  addr->host_used->name, addr->host_used->address);\nfprintf(f, \"%s\", CS se);\nreturn yield;\n}", "target": 0}
{"code": "bool Item_singlerow_subselect::fix_length_and_dec()\n{\n  if ((max_columns= engine->cols()) == 1)\n  {\n    if (engine->fix_length_and_dec(row= &value))\n      return TRUE;\n  }\n  else\n  {\n    if (!(row= (Item_cache**) current_thd->alloc(sizeof(Item_cache*) *\n                                                 max_columns)) ||\n        engine->fix_length_and_dec(row))\n      return TRUE;\n    value= *row;\n  }\n  unsigned_flag= value->unsigned_flag;\n  if (engine->no_tables())\n    maybe_null= engine->may_be_null();\n  else\n  {\n    for (uint i= 0; i < max_columns; i++)\n      row[i]->maybe_null= TRUE;\n  }\n  return FALSE;\n}", "target": 1}
{"code": "static void ClearMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n  WebPSafeFree(hdr->huffman_image_);\n  WebPSafeFree(hdr->huffman_tables_);\n  VP8LHtreeGroupsFree(hdr->htree_groups_);\n  VP8LColorCacheClear(&hdr->color_cache_);\n  VP8LColorCacheClear(&hdr->saved_color_cache_);\n  InitMetadata(hdr);\n}", "target": 1}
{"code": "void decode_prediction_unit(base_context* ctx,\n                            const slice_segment_header* shdr,\n                            de265_image* img,\n                            const PBMotionCoding& motion,\n                            int xC,int yC, int xB,int yB, int nCS, int nPbW,int nPbH, int partIdx)\n{\n  logtrace(LogMotion,\"decode_prediction_unit POC=%d %d;%d %dx%d\\n\",\n           img->PicOrderCntVal, xC+xB,yC+yB, nPbW,nPbH);\n  PBMotion vi;\n  motion_vectors_and_ref_indices(ctx, shdr, img, motion,\n                                 xC,yC, xB,yB, nCS, nPbW,nPbH, partIdx, &vi);\n  generate_inter_prediction_samples(ctx,shdr, img, xC,yC, xB,yB, nCS, nPbW,nPbH, &vi);\n  img->set_mv_info(xC+xB,yC+yB,nPbW,nPbH, vi);\n}", "target": 0}
{"code": "uint8_t* sldns_str2wire_dname(const char* str, size_t* len)\n{\n\tuint8_t dname[LDNS_MAX_DOMAINLEN+1];\n\t*len = sizeof(dname);\n\tif(sldns_str2wire_dname_buf(str, dname, len) == 0) {\n\t\tuint8_t* r;\n\t\tif(*len > sizeof(dname)) return NULL;\n\t\tr = (uint8_t*)malloc(*len);\n\t\tif(r) return memcpy(r, dname, *len);\n\t}\n\t*len = 0;\n\treturn NULL;\n}", "target": 0}
{"code": "static int nft_delrule(struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\tstruct nft_trans *trans;\n\tint err;\n\ttrans = nft_trans_rule_add(ctx, NFT_MSG_DELRULE, rule);\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\terr = nf_tables_delrule_deactivate(ctx, rule);\n\tif (err < 0) {\n\t\tnft_trans_destroy(trans);\n\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static pyc_object *get_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (tuple size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "snmp_ber_encode_length(unsigned char *out, uint32_t *out_len, uint8_t length)\n{\n  *out-- = length;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "static void vgacon_scrollback_switch(int vc_num)\n{\n\tif (!scrollback_persistent)\n\t\tvc_num = 0;\n\tif (!vgacon_scrollbacks[vc_num].data) {\n\t\tvgacon_scrollback_init(vc_num);\n\t} else {\n\t\tif (scrollback_persistent) {\n\t\t\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\t\t} else {\n\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\t\t\tvgacon_scrollback_reset(vc_num, size);\n\t\t}\n\t}\n}", "target": 1}
{"code": "void LibRaw::fuji_compressed_load_raw()\n{\n  struct fuji_compressed_params common_info;\n  int cur_block;\n  unsigned line_size, *block_sizes;\n  INT64 raw_offset, *raw_block_offsets;\n  init_fuji_compr(&common_info);\n  line_size = sizeof(ushort) * (common_info.line_width + 2);\n  block_sizes = (unsigned *)malloc(\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  merror(block_sizes, \"fuji_compressed_load_raw()\");\n  raw_block_offsets = (INT64 *)malloc(\n      sizeof(INT64) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  merror(raw_block_offsets, \"fuji_compressed_load_raw()\");\n  raw_offset =\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks;\n  if (raw_offset & 0xC)\n    raw_offset += 0x10 - (raw_offset & 0xC);\n  raw_offset += libraw_internal_data.unpacker_data.data_offset;\n  libraw_internal_data.internal_data.input->seek(\n      libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n  libraw_internal_data.internal_data.input->read(\n      block_sizes, 1,\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  raw_block_offsets[0] = raw_offset;\n  for (cur_block = 0;\n       cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks;\n       cur_block++)\n  {\n    unsigned bsize = sgetn(4, (uchar *)(block_sizes + cur_block));\n    block_sizes[cur_block] = bsize;\n  }\n  for (cur_block = 1;\n       cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks;\n       cur_block++)\n    raw_block_offsets[cur_block] =\n        raw_block_offsets[cur_block - 1] + block_sizes[cur_block - 1];\n  fuji_decode_loop(&common_info,\n                   libraw_internal_data.unpacker_data.fuji_total_blocks,\n                   raw_block_offsets, block_sizes);\n  free(block_sizes);\n  free(raw_block_offsets);\n  free(common_info.q_table);\n}", "target": 0}
{"code": "device_drive_detach (Device *device,\n                     char **options,\n                     DBusGMethodInvocation *context)\n{\n  if (!device->priv->device_is_drive)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not a drive\");\n      goto out;\n    }\n  if (!device->priv->drive_can_detach)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not detachable\");\n      goto out;\n    }\n  daemon_local_check_auth (device->priv->daemon,\n                           device,\n                           \"org.freedesktop.udisks.drive-detach\",\n                           \"DriveDetach\",\n                           TRUE,\n                           device_drive_detach_authorized_cb,\n                           context,\n                           1,\n                           g_strdupv (options),\n                           g_strfreev);\n out:\n  return TRUE;\n}", "target": 0}
{"code": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n  rtadv_event (zvrf, RTADV_READ, sock);\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n  return 0;\n}", "target": 1}
{"code": "static void wasm_sec_free(RBinWasmSection *sec) {\n\tif (sec) {\n\t\tfree (sec->name);\n\t\tfree (sec);\n\t}\n}", "target": 0}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 0}
{"code": "int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tsmp_wmb(); \n\tspin_lock(&mm->page_table_lock);\n\tif (!pmd_present(*pmd)) {\t\n\t\tmm->nr_ptes++;\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}", "target": 0}
{"code": "static int decode_fill(AACContext *ac, GetBitContext *gb, int len) {\n    uint8_t buf[256];\n    int i, major, minor;\n    if (len < 13+7*8)\n        goto unknown;\n    get_bits(gb, 13); len -= 13;\n    for(i=0; i+1<sizeof(buf) && len>=8; i++, len-=8)\n        buf[i] = get_bits(gb, 8);\n    buf[i] = 0;\n    if (ac->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(ac->avctx, AV_LOG_DEBUG, \"FILL:%s\\n\", buf);\n    if (sscanf(buf, \"libfaac %d.%d\", &major, &minor) == 2){\n        ac->avctx->internal->skip_samples = 1024;\n    }\nunknown:\n    skip_bits_long(gb, len);\n    return 0;\n}", "target": 0}
{"code": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image)\n{\n  Image\n    *msl_image;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  return(ProcessMSLScript(image_info,&msl_image,&image->exception));\n}", "target": 1}
{"code": "static int switch_listening_mode(GDHCPClient *dhcp_client,\n\t\t\t\t\tListenMode listen_mode)\n{\n\tGIOChannel *listener_channel;\n\tint listener_sockfd;\n\tif (dhcp_client->listen_mode == listen_mode)\n\t\treturn 0;\n\tdebug(dhcp_client, \"switch listening mode (%d ==> %d)\",\n\t\t\t\tdhcp_client->listen_mode, listen_mode);\n\tif (dhcp_client->listen_mode != L_NONE) {\n\t\tif (dhcp_client->listener_watch > 0)\n\t\t\tg_source_remove(dhcp_client->listener_watch);\n\t\tdhcp_client->listen_mode = L_NONE;\n\t\tdhcp_client->listener_sockfd = -1;\n\t\tdhcp_client->listener_watch = 0;\n\t}\n\tif (listen_mode == L_NONE)\n\t\treturn 0;\n\tif (listen_mode == L2)\n\t\tlistener_sockfd = dhcp_l2_socket(dhcp_client->ifindex);\n\telse if (listen_mode == L3) {\n\t\tif (dhcp_client->type == G_DHCP_IPV6)\n\t\t\tlistener_sockfd = dhcp_l3_socket(DHCPV6_CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET6);\n\t\telse\n\t\t\tlistener_sockfd = dhcp_l3_socket(CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET);\n\t} else if (listen_mode == L_ARP)\n\t\tlistener_sockfd = arp_socket(dhcp_client->ifindex);\n\telse\n\t\treturn -EIO;\n\tif (listener_sockfd < 0)\n\t\treturn -EIO;\n\tlistener_channel = g_io_channel_unix_new(listener_sockfd);\n\tif (!listener_channel) {\n\t\tclose(listener_sockfd);\n\t\treturn -EIO;\n\t}\n\tdhcp_client->listen_mode = listen_mode;\n\tdhcp_client->listener_sockfd = listener_sockfd;\n\tg_io_channel_set_close_on_unref(listener_channel, TRUE);\n\tdhcp_client->listener_watch =\n\t\t\tg_io_add_watch_full(listener_channel, G_PRIORITY_HIGH,\n\t\t\t\tG_IO_IN | G_IO_NVAL | G_IO_ERR | G_IO_HUP,\n\t\t\t\t\t\tlistener_event, g_dhcp_client_ref(dhcp_client),\n\t\t\t\t\t\t\t\tlistener_watch_destroy);\n\tg_io_channel_unref(listener_channel);\n\treturn 0;\n}", "target": 0}
{"code": "parse_atxheader(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t level = 0;\n\tsize_t i, end, skip;\n\twhile (level < size && level < 6 && data[level] == '#')\n\t\tlevel++;\n\tfor (i = level; i < size && data[i] == ' '; i++);\n\tfor (end = i; end < size && data[end] != '\\n'; end++);\n\tskip = end;\n\twhile (end && data[end - 1] == '#')\n\t\tend--;\n\twhile (end && data[end - 1] == ' ')\n\t\tend--;\n\tif (end > i) {\n\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tparse_inline(work, rndr, data + i, end - i);\n\t\tif (rndr->cb.header)\n\t\t\trndr->cb.header(ob, work, (int)level, rndr->opaque);\n\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t}\n\treturn skip;\n}", "target": 0}
{"code": "MenuCacheDir* menu_cache_dup_root_dir( MenuCache* cache )\n{\n    MenuCacheDir* dir;\n    MENU_CACHE_LOCK;\n    dir = cache->root_dir;\n    if(G_LIKELY(dir))\n        menu_cache_item_ref(MENU_CACHE_ITEM(dir));\n    MENU_CACHE_UNLOCK;\n    return dir;\n}", "target": 0}
{"code": "void WasmBinaryBuilder::readGlobals() {\n  BYN_TRACE(\"== readGlobals\\n\");\n  size_t num = getU32LEB();\n  BYN_TRACE(\"num: \" << num << std::endl);\n  for (size_t i = 0; i < num; i++) {\n    BYN_TRACE(\"read one\\n\");\n    auto type = getConcreteType();\n    auto mutable_ = getU32LEB();\n    if (mutable_ & ~1) {\n      throwError(\"Global mutability must be 0 or 1\");\n    }\n    auto* init = readExpression();\n    globals.push_back(\n      Builder::makeGlobal(\"global$\" + std::to_string(i),\n                          type,\n                          init,\n                          mutable_ ? Builder::Mutable : Builder::Immutable));\n  }\n}", "target": 0}
{"code": "  Mixin_Call_Obj Parser::parse_include_directive()\n  {\n    lex_identifier(); \n    std::string name(Util::normalize_underscores(lexed));\n    Mixin_Call_Obj call = SASS_MEMORY_NEW(Mixin_Call, pstate, name, {}, {}, {});\n    call->arguments(parse_arguments());\n    bool has_parameters = lex< kwd_using >() != nullptr;\n    if (has_parameters) {\n      if (!peek< exactly<'('> >()) css_error(\"Invalid CSS\", \" after \", \": expected \\\"(\\\", was \");\n    } else {\n      if (peek< exactly<'('> >()) css_error(\"Invalid CSS\", \" after \", \": expected \\\";\\\", was \");\n    }\n    if (has_parameters) call->block_parameters(parse_parameters());\n    if (peek < exactly <'{'> >()) {\n      call->block(parse_block());\n    }\n    else if (has_parameters)  {\n      css_error(\"Invalid CSS\", \" after \", \": expected \\\"{\\\", was \");\n    }\n    return call.detach();\n  }", "target": 0}
{"code": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\tref = references[hash % REF_TABLE_SIZE];\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\t\tref = ref->next;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void vhost_vdpa_config_put(struct vhost_vdpa *v)\n{\n\tif (v->config_ctx)\n\t\teventfd_ctx_put(v->config_ctx);\n}", "target": 1}
{"code": "static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)\n{\n    int s = -1, rv;\n    char _port[6];  \n    struct addrinfo hints, *servinfo, *p;\n    snprintf(_port,6,\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = af;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;    \n    if (bindaddr && !strcmp(\"*\", bindaddr))\n        bindaddr = NULL;\n    if (af == AF_INET6 && bindaddr && !strcmp(\"::*\", bindaddr))\n        bindaddr = NULL;\n    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;\n        goto end;\n    }\n    if (p == NULL) {\n        anetSetError(err, \"unable to bind socket, errno: %d\", errno);\n        goto error;\n    }\nerror:\n    if (s != -1) close(s);\n    s = ANET_ERR;\nend:\n    freeaddrinfo(servinfo);\n    return s;\n}", "target": 1}
{"code": "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n        if (fd < 0)\n                return -EBADF;\n        if (!filename_is_valid(name))\n                return -EINVAL;\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) \n                return -EINVAL;\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}", "target": 1}
{"code": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}", "target": 0}
{"code": "comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface)\n{\n\tiface->get_thumbnail = comics_document_thumbnails_get_thumbnail;\n\tiface->get_dimensions = comics_document_thumbnails_get_dimensions;\n}", "target": 1}
{"code": "poly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = TRUE;\n\tpath->dummy = 0;\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\tPG_RETURN_PATH_P(path);\n}", "target": 0}
{"code": "BuildSendAndCloseSoapResp(struct upnphttp * h,\n                          const char * body, int bodylen)\n{\n\tstatic const char beforebody[] =\n\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n\t\t\"<s:Envelope xmlns:s=\\\"http:\n\t\t\"s:encodingStyle=\\\"http:\n\t\t\"<s:Body>\";\n\tstatic const char afterbody[] =\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\\r\\n\";\n\tint r = BuildHeader_upnphttp(h, 200, \"OK\",  sizeof(beforebody) - 1\n\t                             + sizeof(afterbody) - 1 + bodylen );\n\tif(r >= 0) {\n\t\tmemcpy(h->res_buf + h->res_buflen, beforebody, sizeof(beforebody) - 1);\n\t\th->res_buflen += sizeof(beforebody) - 1;\n\t\tmemcpy(h->res_buf + h->res_buflen, body, bodylen);\n\t\th->res_buflen += bodylen;\n\t\tmemcpy(h->res_buf + h->res_buflen, afterbody, sizeof(afterbody) - 1);\n\t\th->res_buflen += sizeof(afterbody) - 1;\n\t} else {\n\t\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", NULL, 0);\n\t}\n\tSendRespAndClose_upnphttp(h);\n}", "target": 0}
{"code": "static void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\tsvm->vmcb->control.lbr_ctl = 1;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}", "target": 0}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int __execlists_context_alloc(struct intel_context *ce,\n\t\t\t\t     struct intel_engine_cs *engine)\n{\n\tstruct drm_i915_gem_object *ctx_obj;\n\tstruct intel_ring *ring;\n\tstruct i915_vma *vma;\n\tu32 context_size;\n\tint ret;\n\tGEM_BUG_ON(ce->state);\n\tcontext_size = round_up(engine->context_size, I915_GTT_PAGE_SIZE);\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\tcontext_size += I915_GTT_PAGE_SIZE; \n\tctx_obj = i915_gem_object_create_shmem(engine->i915, context_size);\n\tif (IS_ERR(ctx_obj))\n\t\treturn PTR_ERR(ctx_obj);\n\tvma = i915_vma_instance(ctx_obj, &engine->gt->ggtt->vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto error_deref_obj;\n\t}\n\tif (!ce->timeline) {\n\t\tstruct intel_timeline *tl;\n\t\ttl = intel_timeline_create(engine->gt, NULL);\n\t\tif (IS_ERR(tl)) {\n\t\t\tret = PTR_ERR(tl);\n\t\t\tgoto error_deref_obj;\n\t\t}\n\t\tce->timeline = tl;\n\t}\n\tring = intel_engine_create_ring(engine, (unsigned long)ce->ring);\n\tif (IS_ERR(ring)) {\n\t\tret = PTR_ERR(ring);\n\t\tgoto error_deref_obj;\n\t}\n\tret = populate_lr_context(ce, ctx_obj, engine, ring);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Failed to populate LRC: %d\\n\", ret);\n\t\tgoto error_ring_free;\n\t}\n\tce->ring = ring;\n\tce->state = vma;\n\treturn 0;\nerror_ring_free:\n\tintel_ring_put(ring);\nerror_deref_obj:\n\ti915_gem_object_put(ctx_obj);\n\treturn ret;\n}", "target": 0}
{"code": "static inline bool nested_cpu_has_vid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n}", "target": 0}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 1}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 1}
{"code": "OE_INLINE void _handle_oret(\n    oe_sgx_td_t* td,\n    uint16_t func,\n    uint16_t result,\n    uint64_t arg)\n{\n    oe_callsite_t* callsite = td->callsites;\n    if (!callsite)\n        return;\n    td->oret_func = func;\n    td->oret_result = result;\n    td->oret_arg = arg;\n    asm volatile(\"pushq %[rflags] \\n\\t\" \n                 \"popfq \\n\\t\"\n                 \"fldcw %[fcw] \\n\\t\"     \n                 \"ldmxcsr %[mxcsr] \\n\\t\" \n                 : [mxcsr] \"=m\"(callsite->mxcsr),\n                   [fcw] \"=m\"(callsite->fcw),\n                   [rflags] \"=m\"(callsite->rflags)\n                 :\n                 : \"cc\");\n    oe_longjmp(&callsite->jmpbuf, 1);\n}", "target": 1}
{"code": "certstack_create(struct cert_stack **result)\n{\n\tstruct cert_stack *stack;\n\tstack = malloc(sizeof(struct cert_stack));\n\tif (stack == NULL)\n\t\treturn pr_enomem();\n\tstack->x509s = sk_X509_new_null();\n\tif (stack->x509s == NULL) {\n\t\tfree(stack);\n\t\treturn val_crypto_err(\"sk_X509_new_null() returned NULL\");\n\t}\n\tSLIST_INIT(&stack->defers);\n\tSLIST_INIT(&stack->metas);\n\tSLIST_INIT(&stack->levels);\n\t*result = stack;\n\treturn 0;\n}", "target": 1}
{"code": "njs_string_prototype_match(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_str_t             string;\n    njs_int_t             ret;\n    njs_value_t           arguments[2];\n    njs_regexp_pattern_t  *pattern;\n    ret = njs_string_object_validate(vm, njs_argument(args, 0));\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    arguments[1] = args[0];\n    string.start = NULL;\n    string.length = 0;\n    if (nargs > 1) {\n        if (njs_is_regexp(&args[1])) {\n            pattern = njs_regexp_pattern(&args[1]);\n            if (pattern->global) {\n                return njs_string_match_multiple(vm, args, pattern);\n            }\n            arguments[0] = args[1];\n            goto match;\n        }\n        if (!njs_is_string(&args[1])) {\n            if (!njs_is_undefined(&args[1])) {\n                ret = njs_value_to_string(vm, &args[1], &args[1]);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n                njs_string_get(&args[1], &string);\n            }\n        } else {\n            njs_string_get(&args[1], &string);\n        }\n    }\n    ret = njs_regexp_create(vm, &arguments[0], string.start, string.length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\nmatch:\n    return njs_regexp_prototype_exec(vm, arguments, nargs, unused);\n}", "target": 0}
{"code": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        if (size < 4)\n            throw Error(kerCorruptedMetadata);\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if ( o+2 > size )\n            throw Error(kerCorruptedMetadata);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        if ( (o + (count * 10)) > size )\n            throw Error(kerCorruptedMetadata);\n        for (uint16_t i = 0; i < count; ++i) {\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::AutoPtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;\n            default: m = CiffComponent::AutoPtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(m);\n            o += 10;\n        }\n    }  ", "target": 1}
{"code": "pgoff_t hugetlb_basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\treturn (index << compound_order(page_head)) + compound_idx;\n}", "target": 0}
{"code": "static ssize_t revision_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\treturn snprintf(buf, 20, \"%u\\n\", id.device_revision & 0x0F);\n}", "target": 0}
{"code": "comics_document_class_init (ComicsDocumentClass *klass)\n{\n\tGObjectClass    *gobject_class = G_OBJECT_CLASS (klass);\n\tEvDocumentClass *ev_document_class = EV_DOCUMENT_CLASS (klass);\n\tgobject_class->finalize = comics_document_finalize;\n\tev_document_class->load = comics_document_load;\n\tev_document_class->save = comics_document_save;\n\tev_document_class->get_n_pages = comics_document_get_n_pages;\n\tev_document_class->get_page_size = comics_document_get_page_size;\n\tev_document_class->render = comics_document_render;\n}", "target": 0}
{"code": "static int ipv4ll_recv_arp_packet(GDHCPClient *dhcp_client)\n{\n\tint bytes;\n\tstruct ether_arp arp;\n\tuint32_t ip_requested;\n\tint source_conflict;\n\tint target_conflict;\n\tguint timeout_ms;\n\tmemset(&arp, 0, sizeof(arp));\n\tbytes = read(dhcp_client->listener_sockfd, &arp, sizeof(arp));\n\tif (bytes < 0)\n\t\treturn bytes;\n\tif (arp.arp_op != htons(ARPOP_REPLY) &&\n\t\t\tarp.arp_op != htons(ARPOP_REQUEST))\n\t\treturn -EINVAL;\n\tif (memcmp(arp.arp_sha, dhcp_client->mac_address, ETH_ALEN) == 0)\n\t\treturn 0;\n\tip_requested = htonl(dhcp_client->requested_ip);\n\tsource_conflict = !memcmp(arp.arp_spa, &ip_requested,\n\t\t\t\t\t\tsizeof(ip_requested));\n\ttarget_conflict = !memcmp(arp.arp_tpa, &ip_requested,\n\t\t\t\tsizeof(ip_requested));\n\tif (!source_conflict && !target_conflict)\n\t\treturn 0;\n\tdhcp_client->conflicts++;\n\tdebug(dhcp_client, \"IPV4LL conflict detected\");\n\tif (dhcp_client->state == IPV4LL_MONITOR) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\tdhcp_client->state = IPV4LL_DEFEND;\n\t\tdebug(dhcp_client, \"DEFEND mode conflicts : %d\",\n\t\t\tdhcp_client->conflicts);\n\t\tsend_announce_packet(dhcp_client);\n\t\treturn 0;\n\t}\n\tif (dhcp_client->state == IPV4LL_DEFEND) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\telse if (dhcp_client->ipv4ll_lost_cb)\n\t\t\tdhcp_client->ipv4ll_lost_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->ipv4ll_lost_data);\n\t}\n\tipv4ll_stop(dhcp_client);\n\tif (dhcp_client->conflicts < MAX_CONFLICTS)\n\t\ttimeout_ms = __connman_util_random_delay_ms(PROBE_WAIT);\n\telse\n\t\ttimeout_ms = RATE_LIMIT_INTERVAL * 1000;\n\tdhcp_client->retry_times++;\n\tdhcp_client->timeout =\n\t\tg_timeout_add_full(G_PRIORITY_HIGH,\n\t\t\t\ttimeout_ms,\n\t\t\t\tsend_probe_packet,\n\t\t\t\tdhcp_client,\n\t\t\t\tNULL);\n\treturn 0;\n}", "target": 0}
{"code": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 1);\n}", "target": 1}
{"code": "int nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING];\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n  if (!nserv || !line)\n    return 0;\n  if (sscanf(line, \"%s \" ANUM \" \" ANUM \" %c %[^\\n]\", group, &last, &first, &mod, desc) < 4)\n    return 0;\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}", "target": 1}
{"code": "static int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}", "target": 0}
{"code": "rgb2rgba(UINT8 *out, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++) {\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = 255;\n        in++;\n    }\n}", "target": 0}
{"code": "php_apache_sapi_read_post(char *buf, uint count_bytes TSRMLS_DC)\n{\n\tapr_size_t len, tlen=0;\n\tphp_struct *ctx = SG(server_context);\n\trequest_rec *r;\n\tapr_bucket_brigade *brigade;\n\tr = ctx->r;\n\tbrigade = ctx->brigade;\n\tlen = count_bytes;\n\twhile (ap_get_brigade(r->input_filters, brigade, AP_MODE_READBYTES, APR_BLOCK_READ, len) == APR_SUCCESS) {\n\t\tapr_brigade_flatten(brigade, buf, &len);\n\t\tapr_brigade_cleanup(brigade);\n\t\ttlen += len;\n\t\tif (tlen == count_bytes || !len) {\n\t\t\tbreak;\n\t\t}\n\t\tbuf += len;\n\t\tlen = count_bytes - tlen;\n\t}\n\treturn tlen;\n}", "target": 0}
{"code": "comics_document_init (ComicsDocument *comics_document)\n{\n\tcomics_document->archive = NULL;\n\tcomics_document->page_names = NULL;\n\tcomics_document->extract_command = NULL;\n}", "target": 1}
{"code": "static cfg_value_t *cfg_opt_getval(cfg_opt_t *opt, unsigned int index)\n{\n\tcfg_value_t *val = NULL;\n\tif (index != 0 && !is_set(CFGF_LIST, opt->flags) && !is_set(CFGF_MULTI, opt->flags)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif (opt->simple_value.ptr)\n\t\tval = (cfg_value_t *)opt->simple_value.ptr;\n\telse {\n\t\tif (is_set(CFGF_RESET, opt->flags)) {\n\t\t\tcfg_free_value(opt);\n\t\t\topt->flags &= ~CFGF_RESET;\n\t\t}\n\t\tif (index >= opt->nvalues)\n\t\t\tval = cfg_addval(opt);\n\t\telse\n\t\t\tval = opt->values[index];\n\t}\n\treturn val;\n}", "target": 0}
{"code": "int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "pci_get_cfgdata16(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\treturn (*(uint16_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "int xmkstemp(char **tmpname, char *dir)\n{\n\tchar *localtmp;\n\tchar *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\tif (dir != NULL)\n\t\ttmpenv = dir;\n\telse\n\t\ttmpenv = getenv(\"TMPDIR\");\n\tif (tmpenv)\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,\n\t\t\t  program_invocation_short_name);\n\telse\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,\n\t\t\t  program_invocation_short_name);\n\tif (rc < 0)\n\t\treturn -1;\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}\n\t*tmpname = localtmp;\n\treturn fd;\n}", "target": 1}
{"code": "init_ext2_xattr(void)\n{\n\treturn 0;\n}", "target": 1}
{"code": "SWFInput_rewind(SWFInput input)\n{\n\tSWFInput_seek(input, 0, SEEK_SET);\n}", "target": 0}
{"code": "static int string_check(char *buf, const char *buf2)\n{\n  if(strcmp(buf, buf2)) {\n    printf(\"sprintf failed:\\nwe '%s'\\nsystem: '%s'\\n\",\n           buf, buf2);\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t}\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_x86_ops->compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\taccumulate_steal_time(vcpu);\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}", "target": 0}
{"code": "void SavePackage::StopObservation() {\n  DCHECK(download_);\n  DCHECK(download_manager_);\n  download_->RemoveObserver(this);\n  download_ = NULL;\n  download_manager_ = NULL;\n}", "target": 0}
{"code": "void client_reset(t_client *client)\n{\n\tchar *hash;\n\tchar *msg;\n\tchar *cidinfo;\n\tdebug(LOG_DEBUG, \"Resetting client [%s]\", client->mac);\n\tclient->counters.incoming = 0;\n\tclient->counters.outgoing = 0;\n\tclient->counters.last_updated = time(NULL);\n\tclient->session_start = 0;\n\tclient->session_end = 0;\n\thash = safe_calloc(STATUS_BUF);\n\tclient->token = safe_calloc(STATUS_BUF);\n\tsafe_snprintf(client->token, STATUS_BUF, \"%04hx%04hx\", rand16(), rand16());\n\thash_str(hash, STATUS_BUF, client->token);\n\tclient->hid = safe_strdup(hash);\n\tfree(hash);\n\tclient->custom = safe_calloc(MID_BUF);\n\tclient->client_type = safe_calloc(STATUS_BUF);\n\tif (client->cid) {\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t\tclient->cid = safe_calloc(SMALL_BUF);\n\t}\n}", "target": 1}
{"code": "static int ecryptfs_threadfn(void *ignored)\n{\n\tset_freezable();\n\twhile (1)  {\n\t\tstruct ecryptfs_open_req *req;\n\t\twait_event_freezable(\n\t\t\tecryptfs_kthread_ctl.wait,\n\t\t\t(!list_empty(&ecryptfs_kthread_ctl.req_list)\n\t\t\t || kthread_should_stop()));\n\t\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\t\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\t\tgoto out;\n\t\t}\n\t\twhile (!list_empty(&ecryptfs_kthread_ctl.req_list)) {\n\t\t\treq = list_first_entry(&ecryptfs_kthread_ctl.req_list,\n\t\t\t\t\t       struct ecryptfs_open_req,\n\t\t\t\t\t       kthread_ctl_list);\n\t\t\tlist_del(&req->kthread_ctl_list);\n\t\t\t*req->lower_file = dentry_open(&req->path,\n\t\t\t\t(O_RDWR | O_LARGEFILE), current_cred());\n\t\t\tcomplete(&req->done);\n\t\t}\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t}\nout:\n\treturn 0;\n}", "target": 0}
{"code": "void WasmBinaryBuilder::readTableDeclarations() {\n  BYN_TRACE(\"== readTableDeclarations\\n\");\n  auto numTables = getU32LEB();\n  for (size_t i = 0; i < numTables; i++) {\n    auto elemType = getType();\n    if (!elemType.isRef()) {\n      throwError(\"Table type must be a reference type\");\n    }\n    auto table = Builder::makeTable(Name::fromInt(i), elemType);\n    bool is_shared;\n    Type indexType;\n    getResizableLimits(\n      table->initial, table->max, is_shared, indexType, Table::kUnlimitedSize);\n    if (is_shared) {\n      throwError(\"Tables may not be shared\");\n    }\n    if (indexType == Type::i64) {\n      throwError(\"Tables may not be 64-bit\");\n    }\n    tables.push_back(std::move(table));\n  }\n}", "target": 0}
{"code": "static void maybe_add_creds(struct sk_buff *skb, const struct socket *sock,\n\t\t\t    const struct sock *other)\n{\n\tif (UNIXCB(skb).pid)\n\t\treturn;\n\tif (unix_passcred_enabled(sock, other)) {\n\t\tUNIXCB(skb).pid  = get_pid(task_tgid(current));\n\t\tcurrent_uid_gid(&UNIXCB(skb).uid, &UNIXCB(skb).gid);\n\t}\n}", "target": 0}
{"code": "static int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    int rc = 0;\n    size_t len = 0;\n    size_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (session == NULL) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = gnutls_record_recv(*session, buf + len, read_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes.\", rc);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc == GNUTLS_E_INTERRUPTED) {\n            crm_trace(\"EINTR encoutered, retry tls read\");\n        } else if (rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (rc <= 0) {\n            if (rc == 0) {\n                crm_debug(\"EOF encoutered during TLS read\");\n            } else {\n                crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            }\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n\t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n\treturn ret;\n}", "target": 1}
{"code": "static void load_creator_from_buf(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size)\n{\n    int   is_xml;\n    char *c;\n    if (!buf)\n      return;\n    if ((c = strstr(buf, \"/Type\")))\n      while (*c && !isspace(*c))\n        ++c;\n    is_xml = 0;\n    if (c && (*c == 'M'))\n      is_xml = 1;\n    if (is_xml)\n      load_creator_from_xml(xref, buf);\n    else\n      load_creator_from_old_format(fp, xref, buf, buf_size);\n}", "target": 0}
{"code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* const context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &resource));\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features\",\n                                                &bucketized_features_list));\n    std::vector<tensorflow::TTypes<int32>::ConstMatrix> bucketized_features;\n    bucketized_features.reserve(bucketized_features_list.size());\n    ConvertVectorsToMatrices(bucketized_features_list, bucketized_features);\n    const int batch_size = bucketized_features[0].dimension(0);\n    Tensor* output_logits_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"logits\", {batch_size, logits_dimension_},\n                                &output_logits_t));\n    auto output_logits = output_logits_t->matrix<float>();\n    if (resource->num_trees() <= 0) {\n      output_logits.setZero();\n      return;\n    }\n    const int32 last_tree = resource->num_trees() - 1;\n    auto do_work = [&resource, &bucketized_features, &output_logits, last_tree,\n                    this](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        std::vector<float> tree_logits(logits_dimension_, 0.0);\n        int32 tree_id = 0;\n        int32 node_id = 0;\n        while (true) {\n          if (resource->is_leaf(tree_id, node_id)) {\n            const float tree_weight = resource->GetTreeWeight(tree_id);\n            const auto& leaf_logits = resource->node_value(tree_id, node_id);\n            DCHECK_EQ(leaf_logits.size(), logits_dimension_);\n            for (int32 j = 0; j < logits_dimension_; ++j) {\n              tree_logits[j] += tree_weight * leaf_logits[j];\n            }\n            if (tree_id == last_tree) {\n              break;\n            }\n            ++tree_id;\n            node_id = 0;\n          } else {\n            node_id =\n                resource->next_node(tree_id, node_id, i, bucketized_features);\n          }\n        }\n        for (int32 j = 0; j < logits_dimension_; ++j) {\n          output_logits(i, j) = tree_logits[j];\n        }\n      }\n    };\n    const int64 cost = (last_tree + 1) * 10;\n    thread::ThreadPool* const worker_threads =\n        context->device()->tensorflow_cpu_worker_threads()->workers;\n    Shard(worker_threads->NumThreads(), worker_threads, batch_size,\n          cost, do_work);\n  }", "target": 1}
{"code": "con_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) return -ENOMEM;\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); \n\t}\n\tp2[unicode & 0x3f] = fontpos;\n\tp->sum += (fontpos << 20) + unicode;\n\treturn 0;\n}", "target": 1}
{"code": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\tfsnotify_clear_marks_by_group(group);\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\n\treturn 0;\n}", "target": 1}
{"code": "htmlCtxtReset(htmlParserCtxtPtr ctxt)\n{\n    xmlParserInputPtr input;\n    xmlDictPtr dict;\n    if (ctxt == NULL)\n        return;\n    xmlInitParser();\n    dict = ctxt->dict;\n    while ((input = inputPop(ctxt)) != NULL) { \n        xmlFreeInputStream(input);\n    }\n    ctxt->inputNr = 0;\n    ctxt->input = NULL;\n    ctxt->spaceNr = 0;\n    if (ctxt->spaceTab != NULL) {\n\tctxt->spaceTab[0] = -1;\n\tctxt->space = &ctxt->spaceTab[0];\n    } else {\n\tctxt->space = NULL;\n    }\n    ctxt->nodeNr = 0;\n    ctxt->node = NULL;\n    ctxt->nameNr = 0;\n    ctxt->name = NULL;\n    DICT_FREE(ctxt->version);\n    ctxt->version = NULL;\n    DICT_FREE(ctxt->encoding);\n    ctxt->encoding = NULL;\n    DICT_FREE(ctxt->directory);\n    ctxt->directory = NULL;\n    DICT_FREE(ctxt->extSubURI);\n    ctxt->extSubURI = NULL;\n    DICT_FREE(ctxt->extSubSystem);\n    ctxt->extSubSystem = NULL;\n    if (ctxt->myDoc != NULL)\n        xmlFreeDoc(ctxt->myDoc);\n    ctxt->myDoc = NULL;\n    ctxt->standalone = -1;\n    ctxt->hasExternalSubset = 0;\n    ctxt->hasPErefs = 0;\n    ctxt->html = 1;\n    ctxt->external = 0;\n    ctxt->instate = XML_PARSER_START;\n    ctxt->token = 0;\n    ctxt->wellFormed = 1;\n    ctxt->nsWellFormed = 1;\n    ctxt->disableSAX = 0;\n    ctxt->valid = 1;\n    ctxt->vctxt.userData = ctxt;\n    ctxt->vctxt.error = xmlParserValidityError;\n    ctxt->vctxt.warning = xmlParserValidityWarning;\n    ctxt->record_info = 0;\n    ctxt->nbChars = 0;\n    ctxt->checkIndex = 0;\n    ctxt->inSubset = 0;\n    ctxt->errNo = XML_ERR_OK;\n    ctxt->depth = 0;\n    ctxt->charset = XML_CHAR_ENCODING_NONE;\n    ctxt->catalogs = NULL;\n    xmlInitNodeInfoSeq(&ctxt->node_seq);\n    if (ctxt->attsDefault != NULL) {\n        xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);\n        ctxt->attsDefault = NULL;\n    }\n    if (ctxt->attsSpecial != NULL) {\n        xmlHashFree(ctxt->attsSpecial, NULL);\n        ctxt->attsSpecial = NULL;\n    }\n}", "target": 0}
{"code": "get_req_flags(unsigned char **buff_in, OM_uint32 bodysize,\n\t      OM_uint32 *req_flags)\n{\n\tunsigned int len;\n\tif (**buff_in != (CONTEXT | 0x01))\n\t\treturn (0);\n\tif (g_get_tag_and_length(buff_in, (CONTEXT | 0x01),\n\t\t\t\tbodysize, &len) < 0)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING_LENGTH)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING_PADDING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t*req_flags = (OM_uint32) (*(*buff_in)++ >> 1);\n\treturn (0);\n}", "target": 0}
{"code": "void rfc_send_rls(tRFC_MCB* p_mcb, uint8_t dlci, bool is_command,\n uint8_t status) {\n uint8_t* p_data;\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(RFCOMM_CMD_BUF_SIZE);\n  p_buf->offset = L2CAP_MIN_OFFSET + RFCOMM_CTRL_FRAME_LEN;\n  p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n *p_data++ = RFCOMM_EA | RFCOMM_I_CR(is_command) | RFCOMM_MX_RLS;\n *p_data++ = RFCOMM_EA | (RFCOMM_MX_RLS_LEN << 1);\n *p_data++ = RFCOMM_EA | RFCOMM_CR_MASK | (dlci << RFCOMM_SHIFT_DLCI);\n *p_data++ = RFCOMM_RLS_ERROR | status;\n  p_buf->len = RFCOMM_MX_RLS_LEN + 2;\n  rfc_send_buf_uih(p_mcb, RFCOMM_MX_DLCI, p_buf);\n}", "target": 0}
{"code": "void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tif (gf_bs_get_position(state->bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}", "target": 1}
{"code": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\tdesc->len = sizeof(data->verdict);\n\treturn 0;\n}", "target": 1}
{"code": "void PacketReader::copyRecord(unsigned char* dest, uint16_t len)\n{\n  if(d_pos + len > d_content.size())\n    throw std::out_of_range(\"Attempt to copy outside of packet\");\n  memcpy(dest, &d_content.at(d_pos), len);\n  d_pos+=len;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::CopyFromBackingStore(\n    const gfx::Rect& src_subrect,\n    const gfx::Size& accelerated_dst_size,\n    const ReadbackRequestCallback& callback,\n    const SkColorType preferred_color_type) {\n  if (view_) {\n    TRACE_EVENT0(\"browser\",\n        \"RenderWidgetHostImpl::CopyFromBackingStore::FromCompositingSurface\");\n    gfx::Rect accelerated_copy_rect = src_subrect.IsEmpty() ?\n        gfx::Rect(view_->GetViewBounds().size()) : src_subrect;\n    view_->CopyFromCompositingSurface(accelerated_copy_rect,\n                                      accelerated_dst_size, callback,\n                                      preferred_color_type);\n    return;\n  }\n  callback.Run(SkBitmap(), content::READBACK_FAILED);\n}", "target": 0}
{"code": "bool Item_cache_wrapper::is_null()\n{\n  Item *cached_value;\n  DBUG_ENTER(\"Item_cache_wrapper::is_null\");\n  if (!expr_cache)\n  {\n    bool tmp= orig_item->is_null();\n    null_value= orig_item->null_value;\n    DBUG_RETURN(tmp);\n  }\n  if ((cached_value= check_cache()))\n  {\n    bool tmp= cached_value->is_null();\n    null_value= cached_value->null_value;\n    DBUG_RETURN(tmp);\n  }\n  cache();\n  DBUG_RETURN((null_value= expr_value->null_value));\n}", "target": 0}
{"code": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}", "target": 1}
{"code": "minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}", "target": 1}
{"code": "HIDDEN void *zstd_init()\n{\n    ZSTD_CCtx *cctx = ZSTD_createCCtx();\n    if (cctx) {\n        ZSTD_CCtx_setParameter(cctx, ZSTD_c_compressionLevel,\n                               ZSTD_CLEVEL_DEFAULT);\n        ZSTD_CCtx_setParameter(cctx, ZSTD_c_checksumFlag, 1);\n    }\n    return cctx;\n}", "target": 0}
{"code": "xfs_perag_clear_reclaim_tag(\n\tstruct xfs_perag\t*pag)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tlockdep_assert_held(&pag->pag_ici_lock);\n\tif (--pag->pag_ici_reclaimable)\n\t\treturn;\n\tspin_lock(&mp->m_perag_lock);\n\tradix_tree_tag_clear(&mp->m_perag_tree, pag->pag_agno,\n\t\t\t     XFS_ICI_RECLAIM_TAG);\n\tspin_unlock(&mp->m_perag_lock);\n\ttrace_xfs_perag_clear_reclaim(mp, pag->pag_agno, -1, _RET_IP_);\n}", "target": 0}
{"code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\treturn NF_ACCEPT;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}", "target": 1}
{"code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParamRef(flags);\n\t}", "target": 1}
{"code": "struct file_list *flist_for_ndx(int ndx, const char *fatal_error_loc)\n{\n\tstruct file_list *flist = cur_flist;\n\tif (!flist && !(flist = first_flist))\n\t\tgoto not_found;\n\twhile (ndx < flist->ndx_start-1) {\n\t\tif (flist == first_flist)\n\t\t\tgoto not_found;\n\t\tflist = flist->prev;\n\t}\n\twhile (ndx >= flist->ndx_start + flist->used) {\n\t\tif (!(flist = flist->next))\n\t\t\tgoto not_found;\n\t}\n\treturn flist;\n  not_found:\n\tif (fatal_error_loc) {\n\t\tint first, last;\n\t\tif (first_flist) {\n\t\t\tfirst = first_flist->ndx_start - 1;\n\t\t\tlast = first_flist->prev->ndx_start + first_flist->prev->used - 1;\n\t\t} else {\n\t\t\tfirst = 0;\n\t\t\tlast = -1;\n\t\t}\n\t\trprintf(FERROR,\n\t\t\t\"File-list index %d not in %d - %d (%s) [%s]\\n\",\n\t\t\tndx, first, last, fatal_error_loc, who_am_i());\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\tfq->flush_pending_idx ^= 1;\n\tblk_rq_init(q, flush_rq);\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\treturn blk_flush_queue_rq(flush_rq, false);\n}", "target": 1}
{"code": "void _af_print_tracks (AFfilehandle filehandle)\n{\n\tint\ti;\n\tfor (i=0; i<filehandle->trackCount; i++)\n\t{\n\t\t_Track\t*track = &filehandle->tracks[i];\n\t\tprintf(\"track %d\\n\", i);\n\t\tprintf(\" id %d\\n\", track->id);\n\t\tprintf(\" sample format\\n\");\n\t\t_af_print_audioformat(&track->f);\n\t\tprintf(\" virtual format\\n\");\n\t\t_af_print_audioformat(&track->v);\n\t\tprintf(\" total file frames: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->totalfframes);\n\t\tprintf(\" total virtual frames: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->totalvframes);\n\t\tprintf(\" next file frame: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->nextfframe);\n\t\tprintf(\" next virtual frame: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->nextvframe);\n\t\tprintf(\" frames to ignore: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->frames2ignore);\n\t\tprintf(\" data_size: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->data_size);\n\t\tprintf(\" fpos_first_frame: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_first_frame);\n\t\tprintf(\" fpos_next_frame: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_next_frame);\n\t\tprintf(\" fpos_after_data: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_after_data);\n\t\tprintf(\" channel matrix:\");\n\t\t_af_print_channel_matrix(track->channelMatrix,\n\t\t\ttrack->f.channelCount, track->v.channelCount);\n\t\tprintf(\"\\n\");\n\t\tprintf(\" marker count: %d\\n\", track->markerCount);\n\t}\n}", "target": 0}
{"code": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n\t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "void ScanLineInputFile::initialize(const Header& header)\n{\n        _data->header = header;\n        _data->lineOrder = _data->header.lineOrder();\n        const Box2i &dataWindow = _data->header.dataWindow();\n        _data->minX = dataWindow.min.x;\n        _data->maxX = dataWindow.max.x;\n        _data->minY = dataWindow.min.y;\n        _data->maxY = dataWindow.max.y;\n        Compression comp = _data->header.compression();\n        _data->linesInBuffer =\n            numLinesInBuffer (comp);\n        int lineOffsetSize = (dataWindow.max.y - dataWindow.min.y +\n                              _data->linesInBuffer) / _data->linesInBuffer;\n        if (lineOffsetSize > gLargeChunkTableSize)\n        {\n            Int64 pos = _streamData->is->tellg();\n            _streamData->is->seekg(pos + (lineOffsetSize-1)*sizeof(Int64));\n            Int64 temp;\n            OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*_streamData->is, temp);\n            _streamData->is->seekg(pos);\n        }\n        size_t maxBytesPerLine = bytesPerLineTable (_data->header,\n                                                    _data->bytesPerLine);\n        if (maxBytesPerLine*numLinesInBuffer(comp) > INT_MAX)\n        {\n            throw IEX_NAMESPACE::InputExc(\"maximum bytes per scanline exceeds maximum permissible size\");\n        }\n        for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n        {\n            _data->lineBuffers[i] = new LineBuffer (newCompressor(comp,\n                                                 maxBytesPerLine,\n                                                 _data->header));\n        }\n        _data->lineBufferSize = maxBytesPerLine * _data->linesInBuffer;\n        if (!_streamData->is->isMemoryMapped())\n        {\n            for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n            {\n                _data->lineBuffers[i]->buffer = (char *) EXRAllocAligned(_data->lineBufferSize*sizeof(char),16);\n                if (!_data->lineBuffers[i]->buffer)\n                {\n                    throw IEX_NAMESPACE::LogicExc(\"Failed to allocate memory for scanline buffers\");\n                }\n            }\n        }\n        _data->nextLineBufferMinY = _data->minY - 1;\n        offsetInLineBufferTable (_data->bytesPerLine,\n                                 _data->linesInBuffer,\n                                 _data->offsetInLineBuffer);\n        _data->lineOffsets.resize (lineOffsetSize);\n}", "target": 1}
{"code": "fbCombineAtopC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32 d = READ(dest + i);\n        CARD32 s = READ(src + i);\n        CARD32 m = READ(mask + i);\n        CARD32 ad;\n        CARD16 as = d >> 24;\n\tfbCombineMaskC (&s, &m);\n        ad = ~m;\n        FbByteAddMulC(d, ad, s, as);\n        WRITE(dest + i, d);\n    }\n}", "target": 0}
{"code": "void WasmBinaryBuilder::verifyInt64(int64_t x) {\n  int64_t y = getInt64();\n  if (x != y) {\n    throwError(\"surprising value\");\n  }\n}", "target": 0}
{"code": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    NetClientState *nc = qemu_get_queue(n->nic);\n    int queue_pairs = n->multiqueue ? n->max_queue_pairs : 1;\n    int cvq = n->max_ncs - n->max_queue_pairs;\n    if (!get_vhost_net(nc->peer)) {\n        return;\n    }\n    if ((virtio_net_started(n, status) && !nc->peer->link_down) ==\n        !!n->vhost_started) {\n        return;\n    }\n    if (!n->vhost_started) {\n        int r, i;\n        if (n->needs_vnet_hdr_swap) {\n            error_report(\"backend does not support %s vnet headers; \"\n                         \"falling back on userspace virtio\",\n                         virtio_is_big_endian(vdev) ? \"BE\" : \"LE\");\n            return;\n        }\n        for (i = 0;  i < queue_pairs; i++) {\n            NetClientState *qnc = qemu_get_subqueue(n->nic, i);\n            qemu_net_queue_purge(qnc->peer->incoming_queue, qnc);\n            qemu_net_queue_purge(qnc->incoming_queue, qnc->peer);\n        }\n        if (virtio_has_feature(vdev->guest_features, VIRTIO_NET_F_MTU)) {\n            r = vhost_net_set_mtu(get_vhost_net(nc->peer), n->net_conf.mtu);\n            if (r < 0) {\n                error_report(\"%uBytes MTU not supported by the backend\",\n                             n->net_conf.mtu);\n                return;\n            }\n        }\n        n->vhost_started = 1;\n        r = vhost_net_start(vdev, n->nic->ncs, queue_pairs, cvq);\n        if (r < 0) {\n            error_report(\"unable to start vhost net: %d: \"\n                         \"falling back on userspace virtio\", -r);\n            n->vhost_started = 0;\n        }\n    } else {\n        vhost_net_stop(vdev, n->nic->ncs, queue_pairs, cvq);\n        n->vhost_started = 0;\n    }\n}", "target": 0}
{"code": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}", "target": 1}
{"code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}", "target": 1}
{"code": "int vfs_parse_fs_string(struct fs_context *fc, const char *key,\n\t\t\tconst char *value, size_t v_size)\n{\n\tint ret;\n\tstruct fs_parameter param = {\n\t\t.key\t= key,\n\t\t.type\t= fs_value_is_flag,\n\t\t.size\t= v_size,\n\t};\n\tif (value) {\n\t\tparam.string = kmemdup_nul(value, v_size, GFP_KERNEL);\n\t\tif (!param.string)\n\t\t\treturn -ENOMEM;\n\t\tparam.type = fs_value_is_string;\n\t}\n\tret = vfs_parse_fs_param(fc, &param);\n\tkfree(param.string);\n\treturn ret;\n}", "target": 0}
{"code": "static char *stibp_state(void)\n{\n\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}", "target": 1}
{"code": "int http_remove_header2(struct http_msg *msg, struct buffer *buf,\n\t\t\tstruct hdr_idx *idx, struct hdr_ctx *ctx)\n{\n\tint cur_idx = ctx->idx;\n\tchar *sol = ctx->line;\n\tstruct hdr_idx_elem *hdr;\n\tint delta, skip_comma;\n\tif (!cur_idx)\n\t\treturn 0;\n\thdr = &idx->v[cur_idx];\n\tif (sol[ctx->del] == ':' && ctx->val + ctx->vlen + ctx->tws == hdr->len) {\n\t\tdelta = buffer_replace2(buf, sol, sol + hdr->len + hdr->cr + 1, NULL, 0);\n\t\thttp_msg_move_end(msg, delta);\n\t\tidx->used--;\n\t\thdr->len = 0;   \n\t\tidx->v[ctx->prev].next = idx->v[ctx->idx].next;\n\t\tif (idx->tail == ctx->idx)\n\t\t\tidx->tail = ctx->prev;\n\t\tctx->idx = ctx->prev;    \n\t\tctx->line -= idx->v[ctx->idx].len + idx->v[cur_idx].cr + 1;\n\t\tctx->val = idx->v[ctx->idx].len; \n\t\tctx->tws = ctx->vlen = 0;\n\t\treturn ctx->idx;\n\t}\n\tskip_comma = (ctx->val + ctx->vlen + ctx->tws == hdr->len) ? 0 : 1;\n\tdelta = buffer_replace2(buf, sol + ctx->del + skip_comma,\n\t\t\t\tsol + ctx->val + ctx->vlen + ctx->tws + skip_comma,\n\t\t\t\tNULL, 0);\n\thdr->len += delta;\n\thttp_msg_move_end(msg, delta);\n\tctx->val = ctx->del;\n\tctx->tws = ctx->vlen = 0;\n\treturn ctx->idx;\n}", "target": 0}
{"code": "unsigned AccessibilityUIElement::indexOfChild(AccessibilityUIElement* element)\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return 0;\n    Vector<RefPtr<AccessibilityUIElement> > children;\n    getChildren(children);\n    unsigned count = children.size();\n    for (unsigned i = 0; i < count; i++)\n        if (children[i]->isEqual(element))\n            return i;\n    return 0;\n}", "target": 0}
{"code": "zend_object_iterator *spl_filesystem_dir_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object   *dir_object;\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_dir_it_funcs;\n\t\titerator->current = object;\n\t}\n\tzval_add_ref(&object);\n\treturn (zend_object_iterator*)iterator;\n}", "target": 0}
{"code": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}", "target": 1}
{"code": "TRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn strlen(string);\n}", "target": 1}
{"code": "int is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tint result;\n\tunsigned seq;\n\tif (new_dentry == old_dentry)\n\t\treturn 1;\n\tdo {\n\t\tseq = read_seqbegin(&rename_lock);\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = 1;\n\t\telse\n\t\t\tresult = 0;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\treturn result;\n}", "target": 0}
{"code": "PinholeVerification(struct upnphttp * h, char * int_ip, unsigned short int_port)\n{\n\tint n;\n\tchar senderAddr[INET6_ADDRSTRLEN]=\"\";\n\tstruct addrinfo hints, *ai, *p;\n\tstruct in6_addr result_ip;\n\tsyslog(LOG_INFO, \"Checking internal IP@ and port (Security policy purpose)\");\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = AF_UNSPEC;\n\tif (inet_pton(AF_INET6, int_ip, &result_ip) <= 0)\n\t{\n\t\tn = getaddrinfo(int_ip, NULL, &hints, &ai);\n\t\tif(!n && ai->ai_family == AF_INET6)\n\t\t{\n\t\t\tfor(p = ai; p; p = p->ai_next)\n\t\t\t{\n\t\t\t\tinet_ntop(AF_INET6, (struct in6_addr *) p, int_ip, sizeof(struct in6_addr));\n\t\t\t\tresult_ip = *((struct in6_addr *) p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to convert hostname '%s' to ip address\", int_ip);\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\treturn -1;\n\t\t}\n        freeaddrinfo(p);\n\t}\n\tif(inet_ntop(AF_INET6, &(h->clientaddr_v6), senderAddr, INET6_ADDRSTRLEN) == NULL)\n\t{\n\t\tsyslog(LOG_ERR, \"inet_ntop: %m\");\n\t}\n#ifdef DEBUG\n\tprintf(\"\\tPinholeVerification:\\n\\t\\tCompare sender @: %s\\n\\t\\t  to intClient @: %s\\n\", senderAddr, int_ip);\n#endif\n\tif(strcmp(senderAddr, int_ip) != 0)\n\tif(h->clientaddr_v6.s6_addr != result_ip.s6_addr)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole for internal %s and is not authorized to do it\",\n\t\t       senderAddr, int_ip);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\tif (int_port < 1024)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole with port < 1024 and is not authorized to do it\",\n\t\t       senderAddr);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "int wsrep_sst_donate(const std::string &msg, const wsrep::gtid &current_gtid,\n                     const bool bypass) {\n  local_status.set(wsrep::server_state::s_donor);\n  const char *method = msg.data();\n  size_t method_len = strlen(method);\n  const char *data = method + method_len + 1;\n  wsp::env env(NULL);\n  if (env.error()) {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): env var ctor failed: %d\", -env.error());\n    return WSREP_CB_FAILURE;\n  }\n#if 0\n  while (!wsrep_is_SE_initialized()) {\n    sleep(1);\n    THD *applier_thd = static_cast<THD *>(recv_ctx);\n    if (applier_thd->killed == THD::KILL_CONNECTION) return WSREP_CB_FAILURE;\n  }\n#endif\n  int ret;\n  ret = sst_donate_other(method, data, current_gtid, bypass, env());\n  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n}", "target": 1}
{"code": "static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_msnd *chip = dev_id;\n\tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n\t\tu16 wTmp;\n\t\tsnd_msnd_eval_dsp_msg(chip,\n\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n\t}\n\tinb(chip->io + HP_RXL);\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "static int FNAME(sync_page)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\tint i, nr_present = 0;\n\tbool host_writable;\n\tgpa_t first_pte_gpa;\n\tint set_spte_ret = 0;\n\tBUG_ON(sp->role.direct);\n\tfirst_pte_gpa = FNAME(get_level1_sp_gpa)(sp);\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; i++) {\n\t\tunsigned pte_access;\n\t\tpt_element_t gpte;\n\t\tgpa_t pte_gpa;\n\t\tgfn_t gfn;\n\t\tif (!sp->spt[i])\n\t\t\tcontinue;\n\t\tpte_gpa = first_pte_gpa + i * sizeof(pt_element_t);\n\t\tif (kvm_vcpu_read_guest_atomic(vcpu, pte_gpa, &gpte,\n\t\t\t\t\t       sizeof(pt_element_t)))\n\t\t\treturn 0;\n\t\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, &sp->spt[i], gpte)) {\n\t\t\tsmp_wmb();\n\t\t\tvcpu->kvm->tlbs_dirty++;\n\t\t\tcontinue;\n\t\t}\n\t\tgfn = gpte_to_gfn(gpte);\n\t\tpte_access = sp->role.access;\n\t\tpte_access &= FNAME(gpte_access)(gpte);\n\t\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\t\tif (sync_mmio_spte(vcpu, &sp->spt[i], gfn, pte_access,\n\t\t      &nr_present))\n\t\t\tcontinue;\n\t\tif (gfn != sp->gfns[i]) {\n\t\t\tdrop_spte(vcpu->kvm, &sp->spt[i]);\n\t\t\tsmp_wmb();\n\t\t\tvcpu->kvm->tlbs_dirty++;\n\t\t\tcontinue;\n\t\t}\n\t\tnr_present++;\n\t\thost_writable = sp->spt[i] & SPTE_HOST_WRITEABLE;\n\t\tset_spte_ret |= set_spte(vcpu, &sp->spt[i],\n\t\t\t\t\t pte_access, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t gfn, spte_to_pfn(sp->spt[i]),\n\t\t\t\t\t true, false, host_writable);\n\t}\n\tif (set_spte_ret & SET_SPTE_NEED_REMOTE_TLB_FLUSH)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\treturn nr_present;\n}", "target": 0}
{"code": "errorProcessor(XML_Parser parser, const char *s, const char *end,\n               const char **nextPtr) {\n  UNUSED_P(s);\n  UNUSED_P(end);\n  UNUSED_P(nextPtr);\n  return parser->m_errorCode;\n}", "target": 0}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tunsigned int new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\tif (v8086_mode(regs))\n\t\treturn (unsigned long)(sel << 4);\n\tif (user_64bit_mode(regs)) {\n\t\tunsigned long base;\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\tif (!sel)\n\t\treturn -1L;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\treturn get_desc_base(desc);\n}", "target": 1}
{"code": "static unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tint drive = (long)disk->private_data;\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\tif (time_after(jiffies, UDRS->last_checked + UDP->checkfreq)) {\n\t\tif (lock_fdc(drive))\n\t\t\treturn 0;\n\t\tpoll_drive(false, 0);\n\t\tprocess_fd_request();\n\t}\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\treturn 0;\n}", "target": 0}
{"code": "gfx::Rect OverlayWindowViews::GetVideoBounds() {\n  return video_bounds_;\n}", "target": 0}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "int GetDPI(const PrintMsg_Print_Params* print_params) {\n#if defined(OS_MACOSX)\n  return kPointsPerInch;\n#else\n  return static_cast<int>(print_params->dpi);\n#endif  \n}", "target": 0}
{"code": "HttpRequest::maybeCacheable()\n{\n    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))\n        return false;\n    switch (url.getScheme()) {\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_HTTPS:\n        if (!method.respMaybeCacheable())\n            return false;\n        if (!flags.ignoreCc && cache_control && cache_control->hasNoStore())\n            return false;\n        break;\n    case AnyP::PROTO_GOPHER:\n        if (!gopherCachable(this))\n            return false;\n        break;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return false;\n    default:\n        break;\n    }\n    return true;\n}", "target": 1}
{"code": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n\treturn key_validate(key);\n}", "target": 1}
{"code": "nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, openflags, NULL, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (state->inode == dentry->d_inode) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state);\n\t\treturn 1;\n\t}\n\tnfs4_close_sync(&path, state, openflags);\nout_drop:\n\td_drop(dentry);\n\treturn 0;\n}", "target": 1}
{"code": "  explicit ReverseSequenceOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n  }", "target": 1}
{"code": "static void FNAME(update_model)(CommonState *state, s_bucket * const bucket,\n                                const BYTE curval)\n{\n    SPICE_VERIFY(BPC >= 1);\n    spice_return_if_fail (bucket != NULL);\n    const unsigned int bpp = BPC;\n    COUNTER * const pcounters = bucket->pcounters;\n    unsigned int i;\n    unsigned int bestcode;\n    unsigned int bestcodelen;\n    bestcode = bpp - 1;\n    bestcodelen = (pcounters[bestcode] += FNAME(golomb_code_len)(curval, bestcode));\n    for (i = bpp - 2; i < bpp; i--) { \n        const unsigned int ithcodelen = (pcounters[i] += FNAME(golomb_code_len)(curval, i));\n        if (ithcodelen < bestcodelen) {\n            bestcode = i;\n            bestcodelen = ithcodelen;\n        }\n    }\n    bucket->bestcode = bestcode; \n    if (bestcodelen > state->wm_trigger) { \n        for (i = 0; i < bpp; i++) {\n            pcounters[i] >>= 1;\n        }\n    }\n}", "target": 0}
{"code": "ext4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}", "target": 1}
{"code": "    bool operator()(const StatsPartitionKey& a,\n                    const StatsPartitionKey& b) const {\n      if (a.node_id < b.node_id) {\n        return true;\n      }\n      if ((a.node_id == b.node_id) && (a.feature_dim < b.feature_dim)) {\n        return true;\n      }\n      if ((a.node_id == b.node_id) && (a.feature_dim == b.feature_dim) &&\n          (a.bucket_id < b.bucket_id)) {\n        return true;\n      }\n      return false;\n    }", "target": 0}
{"code": "libxlDomainDefNamespaceParse(xmlXPathContextPtr ctxt,\n                             void **data)\n{\n    libxlDomainXmlNsDef *nsdata = NULL;\n    g_autofree xmlNodePtr *nodes = NULL;\n    ssize_t nnodes;\n    size_t i;\n    int ret = -1;\n    if ((nnodes = virXPathNodeSet(\"./xen:commandline/xen:arg\", ctxt, &nodes)) < 0)\n        return -1;\n    if (nnodes == 0)\n        return 0;\n    nsdata = g_new0(libxlDomainXmlNsDef, 1);\n    nsdata->args = g_new0(char *, nnodes + 1);\n    for (i = 0; i < nnodes; i++) {\n        if (!(nsdata->args[nsdata->num_args++] = virXMLPropString(nodes[i], \"value\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No device model command-line argument specified\"));\n            goto cleanup;\n        }\n    }\n    *data = g_steal_pointer(&nsdata);\n    ret = 0;\n cleanup:\n    libxlDomainDefNamespaceFree(nsdata);\n    return ret;\n}", "target": 0}
{"code": "        std::string PngChunk::makeUtf8TxtChunk(const std::string& keyword, const std::string& text, bool compress)\n        {\n            std::string chunkData = keyword;\n            if (compress) {\n                static const char flags[] = {0x00, 0x01, 0x00, 0x00, 0x00};\n                chunkData += std::string(flags, 5) + zlibCompress(text);\n            } else {\n                static const char flags[] = {0x00, 0x00, 0x00, 0x00, 0x00};\n                chunkData += std::string(flags, 5) + text;\n            }\n            byte length[4];\n            ul2Data(length, static_cast<uint32_t>(chunkData.size()), bigEndian);\n            std::string chunkType = \"iTXt\";\n            std::string crcData = chunkType + chunkData;\n            uLong tmp = crc32(0L, Z_NULL, 0);\n            tmp = crc32(tmp, (const Bytef*)crcData.data(), static_cast<uInt>(crcData.size()));\n            byte crc[4];\n            ul2Data(crc, tmp, bigEndian);\n            return std::string((const char*)length, 4) + chunkType + chunkData + std::string((const char*)crc, 4);\n        }  ", "target": 0}
{"code": "int bt_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t    int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err == 0) {\n\t\tsock_recv_cmsgs(msg, sk, skb);\n\t\tif (msg->msg_name && bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\treturn err ? : copied;\n}", "target": 1}
{"code": "void *memslot_get_virt(RedMemSlotInfo *info, QXLPHYSICAL addr, uint32_t add_size,\n                       int group_id)\n{\n    int slot_id;\n    int generation;\n    unsigned long h_virt;\n    MemSlot *slot;\n    if (group_id > info->num_memslots_groups) {\n        spice_critical(\"group_id too big\");\n        return NULL;\n    }\n    slot_id = memslot_get_id(info, addr);\n    if (slot_id > info->num_memslots) {\n        print_memslots(info);\n        spice_critical(\"slot_id %d too big, addr=%\" PRIx64, slot_id, addr);\n        return NULL;\n    }\n    slot = &info->mem_slots[group_id][slot_id];\n    generation = memslot_get_generation(info, addr);\n    if (generation != slot->generation) {\n        print_memslots(info);\n        spice_critical(\"address generation is not valid, group_id %d, slot_id %d, \"\n                       \"gen %d, slot_gen %d\",\n                       group_id, slot_id,\n                       generation, slot->generation);\n        return NULL;\n    }\n    h_virt = __get_clean_virt(info, addr);\n    h_virt += slot->address_delta;\n    if (!memslot_validate_virt(info, h_virt, slot_id, add_size, group_id)) {\n        return NULL;\n    }\n    return (void*)(uintptr_t)h_virt;\n}", "target": 1}
{"code": "void _WM_do_meta_sequenceno(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}", "target": 0}
{"code": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}", "target": 1}
{"code": "char* Elf_(r_bin_elf_get_file_type)(ELFOBJ *bin) {\n\tut32 e_type;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\te_type = (ut32)bin->ehdr.e_type; \n\tswitch (e_type) {\n\tcase ET_NONE: return strdup (\"NONE (None)\");\n\tcase ET_REL:  return strdup (\"REL (Relocatable file)\");\n\tcase ET_EXEC: return strdup (\"EXEC (Executable file)\");\n\tcase ET_DYN:  return strdup (\"DYN (Shared object file)\");\n\tcase ET_CORE: return strdup (\"CORE (Core file)\");\n\t}\n\tif ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC)) {\n\t\treturn r_str_newf (\"Processor Specific: %x\", e_type);\n\t}\n\tif ((e_type >= ET_LOOS) && (e_type <= ET_HIOS)) {\n\t\treturn r_str_newf (\"OS Specific: %x\", e_type);\n\t}\n\treturn r_str_newf (\"<unknown>: %x\", e_type);\n}", "target": 0}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(s->sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(s->sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "FramebufferModel::~FramebufferModel()\n{\n    delete[] m_pixelBuffer;\n}", "target": 1}
{"code": "_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n  do\n    {\n      size_t len = 1;\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n  return cnt;\n}", "target": 1}
{"code": "void PDFiumEngine::OnSingleClick(int page_index, int char_index) {\n  SetSelecting(true);\n  selection_.push_back(PDFiumRange(pages_[page_index], char_index, 0));\n}", "target": 0}
{"code": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "static int update_frag_index(MOVContext *c, int64_t offset)\n{\n    int index, i;\n    MOVFragmentIndexItem * item;\n    MOVFragmentStreamInfo * frag_stream_info;\n    index = search_frag_moof_offset(&c->frag_index, offset);\n    if (index < c->frag_index.nb_items &&\n        c->frag_index.item[index].moof_offset == offset)\n        return index;\n    item = av_fast_realloc(c->frag_index.item,\n                           &c->frag_index.allocated_size,\n                           (c->frag_index.nb_items + 1) *\n                           sizeof(*c->frag_index.item));\n    if (!item)\n        return -1;\n    c->frag_index.item = item;\n    frag_stream_info = av_realloc_array(NULL, c->fc->nb_streams,\n                                        sizeof(*item->stream_info));\n    if (!frag_stream_info)\n        return -1;\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id < 0) {\n            av_free(frag_stream_info);\n            return AVERROR_INVALIDDATA;\n        }\n        frag_stream_info[i].id = c->fc->streams[i]->id;\n        frag_stream_info[i].sidx_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].tfdt_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].next_trun_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].first_tfra_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].index_base = -1;\n        frag_stream_info[i].index_entry = -1;\n        frag_stream_info[i].encryption_index = NULL;\n    }\n    if (index < c->frag_index.nb_items)\n        memmove(c->frag_index.item + index + 1, c->frag_index.item + index,\n                (c->frag_index.nb_items - index) * sizeof(*c->frag_index.item));\n    item = &c->frag_index.item[index];\n    item->headers_read = 0;\n    item->current = 0;\n    item->nb_stream_info = c->fc->nb_streams;\n    item->moof_offset = offset;\n    item->stream_info = frag_stream_info;\n    c->frag_index.nb_items++;\n    return index;\n}", "target": 0}
{"code": "void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify)\n{\n\tminify = dominify;\n\tif (prog->type == AST_LIST)\n\t\tpstmlist(-1, prog);\n\telse {\n\t\tpstm(0, prog);\n\t\tnl();\n\t}\n\tif (minify > 1)\n\t\tputchar('\\n');\n}", "target": 1}
{"code": "void grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf->file && gf->file->device)\n\t\t\tfree (gf->file->device->disk);\n\t\tfree (gf->file);\n\t\tfree (gf);\n\t}\n}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    CHECK_GE(dtypes.size(), size_t{1});\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "void TDStretch::setChannels(int numChannels)\n{\n    assert(numChannels > 0);\n    if (channels == numChannels) return;\n    channels = numChannels;\n    inputBuffer.setChannels(channels);\n    outputBuffer.setChannels(channels);\n    overlapLength=0;\n    setParameters(sampleRate);\n}", "target": 1}
{"code": "void GfxIndexedColorSpace::getGray(const GfxColor *color, GfxGray *gray) const\n{\n    GfxColor color2;\n    base->getGray(mapColorToBase(color, &color2), gray);\n}", "target": 0}
{"code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 0}
{"code": "        bool         CheckRegion(int nPos, int nSize)\n        {\n            return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);\n        }", "target": 1}
{"code": "void LanLinkProvider::newConnection()\n{\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider newConnection\";\n    while (m_server->hasPendingConnections()) {\n        QSslSocket* socket = m_server->nextPendingConnection();\n        configureSocket(socket);\n        connect(socket, &QAbstractSocket::disconnected,\n                socket, &QObject::deleteLater);\n        connect(socket, &QIODevice::readyRead,\n                this, &LanLinkProvider::dataReceived);\n    }\n}", "target": 1}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringRef data      = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "init_ctx_nego(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t      OM_uint32 acc_negState, gss_OID supportedMech,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\tif (supportedMech == GSS_C_NO_OID) {\n\t\t*minor_status = ERR_SPNEGO_NO_MECH_FROM_ACCEPTOR;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (acc_negState == ACCEPT_DEFECTIVE_TOKEN) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (!(is_kerb_mech(supportedMech) &&\n\t      is_kerb_mech(sc->internal_mech)) &&\n\t    !g_OID_equal(supportedMech, sc->internal_mech)) {\n\t\tret = init_ctx_reselect(minor_status, sc,\n\t\t\t\t\tacc_negState, supportedMech,\n\t\t\t\t\tresponseToken, mechListMIC,\n\t\t\t\t\tnegState, tokflag);\n\t} else if (*responseToken == GSS_C_NO_BUFFER) {\n\t\tif (sc->mech_complete) {\n\t\t\t*negState = ACCEPT_COMPLETE;\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\tret = GSS_S_COMPLETE;\n\t\t} else {\n\t\t\t*minor_status = ERR_SPNEGO_NO_TOKEN_FROM_ACCEPTOR;\n\t\t\tmap_errcode(minor_status);\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t} else if ((*responseToken)->length == 0 && sc->mech_complete) {\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t} else if (sc->mech_complete) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\tsc->nego_done = 1;\n\treturn ret;\n}", "target": 0}
{"code": "copy_ciphersuites(gnutls_session_t session,\n\t\t  gnutls_buffer_st * cdata, int add_scsv)\n{\n\tint ret;\n\tuint8_t cipher_suites[MAX_CIPHERSUITE_SIZE + 2]; \n\tint cipher_suites_size;\n\tsize_t init_length = cdata->length;\n\tret =\n\t    _gnutls_supported_ciphersuites(session, cipher_suites,\n\t\t\t\t\t   sizeof(cipher_suites) - 2);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tret =\n\t    _gnutls_remove_unwanted_ciphersuites(session, cipher_suites,\n\t\t\t\t\t\t ret, NULL, 0);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tif (ret == 0)\n\t\treturn\n\t\t    gnutls_assert_val(GNUTLS_E_INSUFFICIENT_CREDENTIALS);\n\tcipher_suites_size = ret;\n\tif (add_scsv) {\n\t\tcipher_suites[cipher_suites_size] = 0x00;\n\t\tcipher_suites[cipher_suites_size + 1] = 0xff;\n\t\tcipher_suites_size += 2;\n\t\tret = _gnutls_ext_sr_send_cs(session);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\t}\n\tret =\n\t    _gnutls_buffer_append_data_prefix(cdata, 16, cipher_suites,\n\t\t\t\t\t      cipher_suites_size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tret = cdata->length - init_length;\n\treturn ret;\n}", "target": 1}
{"code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tattr->size = usize;\n\t}\n\tret = copy_to_user(uattr, attr, usize);\n\tif (ret)\n\t\treturn -EFAULT;\nout:\n\treturn ret;\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}", "target": 1}
{"code": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}", "target": 1}
{"code": "static void mptsas_soft_reset(MPTSASState *s)\n{\n    uint32_t save_mask;\n    trace_mptsas_reset(s);\n    save_mask = s->intr_mask;\n    s->intr_mask = MPI_HIM_DIM | MPI_HIM_RIM;\n    mptsas_update_interrupt(s);\n    qbus_reset_all(BUS(&s->bus));\n    s->intr_status = 0;\n    s->intr_mask = save_mask;\n    s->reply_free_tail = 0;\n    s->reply_free_head = 0;\n    s->reply_post_tail = 0;\n    s->reply_post_head = 0;\n    s->request_post_tail = 0;\n    s->request_post_head = 0;\n    qemu_bh_cancel(s->request_bh);\n    s->state = MPI_IOC_STATE_READY;\n}", "target": 0}
{"code": "void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}", "target": 1}
{"code": "wsrep_cb_status_t wsrep_sst_donate_cb (void* app_ctx, void* recv_ctx,\n                                       const void* msg, size_t msg_len,\n                                       const wsrep_gtid_t* current_gtid,\n                                       const char* state, size_t state_len,\n                                       bool bypass)\n{\n  local_status.set(WSREP_MEMBER_DONOR);\n  const char* method = (char*)msg;\n  size_t method_len  = strlen (method);\n  const char* data   = method + method_len + 1;\n  char uuid_str[37];\n  wsrep_uuid_print (&current_gtid->uuid, uuid_str, sizeof(uuid_str));\n  wsp::env env(NULL);\n  if (env.error())\n  {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): env var ctor failed: %d\", -env.error());\n    return WSREP_CB_FAILURE;\n  }\n  int ret;\n  if ((ret= sst_append_auth_env(env, sst_auth_real)))\n  {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): appending auth env failed: %d\", ret);\n    return WSREP_CB_FAILURE;\n  }\n  if (!strcmp (WSREP_SST_MYSQLDUMP, method))\n  {\n    ret = sst_donate_mysqldump(data, &current_gtid->uuid, uuid_str,\n                               current_gtid->seqno, bypass, env());\n  }\n  else\n  {\n    ret = sst_donate_other(method, data, uuid_str,\n                           current_gtid->seqno, bypass, env());\n  }\n  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n}", "target": 1}
{"code": "static void update_blocked_averages(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq, *pos;\n\tconst struct sched_class *curr_class;\n\tstruct rq_flags rf;\n\tbool done = true;\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n\t\tstruct sched_entity *se;\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\t\tif (cfs_rq_is_decayed(cfs_rq))\n\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\tdone = false;\n\t}\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}", "target": 1}
{"code": "static void jsR_callfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\tscope = jsR_newenvironment(J, jsV_newobject(J, JS_COBJECT, NULL), scope);\n\tjsR_savescope(J, scope);\n\tif (F->arguments) {\n\t\tjs_newobject(J);\n\t\tif (!J->strict) {\n\t\t\tjs_currentfunction(J);\n\t\t\tjs_defproperty(J, -2, \"callee\", JS_DONTENUM);\n\t\t}\n\t\tjs_pushnumber(J, n);\n\t\tjs_defproperty(J, -2, \"length\", JS_DONTENUM);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tjs_copy(J, i + 1);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tjs_initvar(J, \"arguments\", -1);\n\t\tjs_pop(J, 1);\n\t}\n\tfor (i = 0; i < F->numparams; ++i) {\n\t\tif (i < n)\n\t\t\tjs_initvar(J, F->vartab[i], i + 1);\n\t\telse {\n\t\t\tjs_pushundefined(J);\n\t\t\tjs_initvar(J, F->vartab[i], -1);\n\t\t\tjs_pop(J, 1);\n\t\t}\n\t}\n\tjs_pop(J, n);\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; \n\tjs_pushvalue(J, v);\n\tjsR_restorescope(J);\n}", "target": 0}
{"code": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}", "target": 1}
{"code": "RunTerminationHelper(HANDLE console_token, DWORD pid) {\n  WCHAR module_path[MAX_PATH];\n  GetModuleFileNameW(NULL, module_path, _countof(module_path));\n  std::wstring command { module_path };\n  command += L\" --terminate \" + std::to_wstring(pid);\n  STARTUPINFOW startup_info = {};\n  startup_info.cb = sizeof(startup_info);\n  startup_info.lpDesktop = (LPWSTR) L\"winsta0\\\\default\";\n  PROCESS_INFORMATION process_info;\n  if (!CreateProcessAsUserW(console_token,\n        NULL,\n        (LPWSTR) command.c_str(),\n        NULL,\n        NULL,\n        FALSE,\n        CREATE_UNICODE_ENVIRONMENT | DETACHED_PROCESS,\n        NULL,\n        NULL,\n        &startup_info,\n        &process_info)) {\n    return false;\n  }\n  WaitForSingleObject(process_info.hProcess, INFINITE);\n  DWORD exit_code;\n  GetExitCodeProcess(process_info.hProcess, &exit_code);\n  CloseHandle(process_info.hProcess);\n  CloseHandle(process_info.hThread);\n  return exit_code == 0;\n}", "target": 1}
{"code": "static int ion_handle_put_nolock(struct ion_handle *handle)\n{\n\tint ret;\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\treturn ret;\n}", "target": 0}
{"code": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n    trace_usb_xhci_exit();\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n    if (dev->msix_table && dev->msix_pba\n        && dev->msix_entry_used) {\n        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n    }\n    usb_bus_release(&xhci->bus);\n}", "target": 1}
{"code": "reset_in_progress(const struct intel_engine_execlists *execlists)\n{\n\treturn unlikely(!__tasklet_is_enabled(&execlists->tasklet));\n}", "target": 0}
{"code": "static int write_empty_blocks(struct page *page, unsigned from, unsigned to,\n\t\t\t      int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned start, end, next, blksize;\n\tsector_t block = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tint ret;\n\tblksize = 1 << inode->i_blkbits;\n\tnext = end = 0;\n\twhile (next < from) {\n\t\tnext += blksize;\n\t\tblock++;\n\t}\n\tstart = next;\n\tdo {\n\t\tnext += blksize;\n\t\tret = needs_empty_write(block, inode);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tif (ret == 0) {\n\t\t\tif (end) {\n\t\t\t\tret = __block_write_begin(page, start, end - start,\n\t\t\t\t\t\t\t  gfs2_block_map);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tret = empty_write_end(page, start, end, mode);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tend = 0;\n\t\t\t}\n\t\t\tstart = next;\n\t\t}\n\t\telse\n\t\t\tend = next;\n\t\tblock++;\n\t} while (next < to);\n\tif (end) {\n\t\tret = __block_write_begin(page, start, end - start, gfs2_block_map);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = empty_write_end(page, start, end, mode);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n\t\t\t\t   struct tcp_sock_t *sock6)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tfd_set rfds;\n\tstruct timeval tv;\n\tint retval = 0;\n\tint nfds = 0;\n\twhile (retval == 0) {\n\t\tFD_ZERO(&rfds);\n\t\tif (sock) {\n\t\t\tFD_SET(sock->sd, &rfds);\n\t\t\tnfds = sock->sd;\n\t\t}\n\t\tif (sock6) {\n\t\t\tFD_SET(sock6->sd, &rfds);\n\t\t\tif (sock6->sd > nfds)\n\t\t\t\tnfds = sock6->sd;\n\t\t}\n\t\tif (nfds == 0) {\n\t\t\tERR(\"No valid TCP socket supplied.\");\n\t\t\tgoto error;\n\t\t}\n\t\tnfds += 1;\n\t\ttv.tv_sec = 5;\n\t\ttv.tv_usec = 0;\n\t\tretval = select(nfds, &rfds, NULL, NULL, &tv);\n\t\tif (retval == -1) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (sock && FD_ISSET(sock->sd, &rfds)) {\n\t\tconn->sd = accept(sock->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv4\");\n\t} else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {\n\t\tconn->sd = accept(sock6->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv6\");\n\t} else {\n\t\tERR(\"select failed\");\n\t\tgoto error;\n\t}\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 0}
{"code": "init_syntax_once ()\n{\n   register int c;\n   static int done;\n   if (done)\n     return;\n   bzero (re_syntax_table, sizeof re_syntax_table);\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n   re_syntax_table['_'] = Sword;\n   done = 1;\n}", "target": 1}
{"code": "int snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\tif (!card)\n\t\treturn -EINVAL;\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn 0;\n\t}\n\tcard->shutdown = 1;\n\tspin_unlock(&card->files_lock);\n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\tsnd_device_disconnect_all(card);\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n#endif\n\treturn 0;\t\n}", "target": 1}
{"code": "static int mxf_match_uid(const UID key, const UID uid, int len)\n{\n    int i;\n    for (i = 0; i < len; i++) {\n        if (i != 7 && key[i] != uid[i])\n            return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tmmu->invlpg(vcpu, gva, mmu->root.hpa);\n\t\ttlb_flush = true;\n\t}\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd)) {\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\tif (tlb_flush)\n\t\tstatic_call(kvm_x86_flush_tlb_gva)(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}", "target": 1}
{"code": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       n * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int tsize = pipe->ring_size - t;\n\t\t\tif (h > 0)\n\t\t\t\tmemcpy(bufs + tsize, pipe->bufs,\n\t\t\t\t       h * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       tsize * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\thead = n;\n\ttail = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}", "target": 1}
{"code": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\tbprm->mm = NULL;\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\tdo_close_on_exec(current->files);\n\treturn 0;\nout:\n\treturn retval;\n}", "target": 0}
{"code": "input_parse(struct window_pane *wp)\n{\n\tstruct input_ctx\t\t*ictx = wp->ictx;\n\tconst struct input_transition\t*itr;\n\tstruct evbuffer\t\t\t*evb = wp->event->input;\n\tu_char\t\t\t\t*buf;\n\tsize_t\t\t\t\t len, off;\n\tif (EVBUFFER_LENGTH(evb) == 0)\n\t\treturn;\n\twp->window->flags |= WINDOW_ACTIVITY;\n\twp->window->flags &= ~WINDOW_SILENCE;\n\tif (gettimeofday(&wp->window->activity_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tif (wp->mode == NULL)\n\t\tscreen_write_start(&ictx->ctx, wp, &wp->base);\n\telse\n\t\tscreen_write_start(&ictx->ctx, NULL, &wp->base);\n\tictx->wp = wp;\n\tbuf = EVBUFFER_DATA(evb);\n\tlen = EVBUFFER_LENGTH(evb);\n\tnotify_input(wp, evb);\n\toff = 0;\n\twhile (off < len) {\n\t\tictx->ch = buf[off++];\n\t\tlog_debug(\"%s: '%c' %s\", __func__, ictx->ch, ictx->state->name);\n\t\titr = ictx->state->transitions;\n\t\twhile (itr->first != -1 && itr->last != -1) {\n\t\t\tif (ictx->ch >= itr->first && ictx->ch <= itr->last)\n\t\t\t\tbreak;\n\t\t\titr++;\n\t\t}\n\t\tif (itr->first == -1 || itr->last == -1) {\n\t\t\tfatalx(\"No transition from state!\");\n\t\t}\n\t\tif (itr->handler != NULL && itr->handler(ictx) != 0)\n\t\t\tcontinue;\n\t\tif (itr->state != NULL)\n\t\t\tinput_set_state(wp, itr);\n\t\tif (ictx->state != &input_state_ground)\n\t\t\tevbuffer_add(ictx->since_ground, &ictx->ch, 1);\n\t}\n\tscreen_write_stop(&ictx->ctx);\n\tevbuffer_drain(evb, len);\n}", "target": 0}
{"code": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n  cNokogiriXmlRelaxNG = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}", "target": 1}
{"code": "kadm5_ret_t kadm5_decrypt_key(void *server_handle,\n                              kadm5_principal_ent_t entry, krb5_int32\n                              ktype, krb5_int32 stype, krb5_int32\n                              kvno, krb5_keyblock *keyblock,\n                              krb5_keysalt *keysalt, int *kvnop)\n{\n    kadm5_server_handle_t handle = server_handle;\n    krb5_db_entry dbent;\n    krb5_key_data *key_data;\n    krb5_keyblock *mkey_ptr;\n    int ret;\n    CHECK_HANDLE(server_handle);\n    if (entry->n_key_data == 0 || entry->key_data == NULL)\n        return EINVAL;\n    dbent.n_key_data = entry->n_key_data;\n    dbent.key_data = entry->key_data;\n    if ((ret = krb5_dbe_find_enctype(handle->context, &dbent, ktype,\n                                     stype, kvno, &key_data)))\n        return ret;\n    dbent.tl_data = entry->tl_data;\n    if ((ret = krb5_dbe_find_mkey(handle->context, &dbent, &mkey_ptr))) {\n        if (krb5_db_fetch_mkey_list(handle->context, master_princ,\n                                    &master_keyblock) == 0) {\n            if ((ret = krb5_dbe_find_mkey(handle->context, &dbent,\n                                          &mkey_ptr))) {\n                return ret;\n            }\n        } else {\n            return ret;\n        }\n    }\n    if ((ret = krb5_dbe_decrypt_key_data(handle->context, NULL, key_data,\n                                         keyblock, keysalt)))\n        return ret;\n    if (ktype != -1)\n        keyblock->enctype = ktype;\n    if (kvnop)\n        *kvnop = key_data->key_data_kvno;\n    return KADM5_OK;\n}", "target": 0}
{"code": "void LibRaw::derror()\n{\n  if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input) \n    {\n      if (libraw_internal_data.internal_data.input->eof())\n        {\n          if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,\n                                                    libraw_internal_data.internal_data.input->fname(),-1);\n          throw LIBRAW_EXCEPTION_IO_EOF;\n        }\n      else\n        {\n          if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,\n                                                    libraw_internal_data.internal_data.input->fname(),\n                                                    libraw_internal_data.internal_data.input->tell());\n        }\n    }\n  libraw_internal_data.unpacker_data.data_error++;\n}", "target": 0}
{"code": "T2P* t2p_init()\n{\n\tT2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P));\n\tif(t2p==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate %lu bytes of memory for t2p_init\", \n\t\t\t(unsigned long) sizeof(T2P));\n\t\treturn( (T2P*) NULL );\n\t}\n\t_TIFFmemset(t2p, 0x00, sizeof(T2P));\n\tt2p->pdf_majorversion=1;\n\tt2p->pdf_minorversion=1;\n\tt2p->pdf_defaultxres=300.0;\n\tt2p->pdf_defaultyres=300.0;\n\tt2p->pdf_defaultpagewidth=612.0;\n\tt2p->pdf_defaultpagelength=792.0;\n\tt2p->pdf_xrefcount=3; \n\tt2p->tiff_maxdatasize = DEFAULT_MAX_MALLOC;\n\treturn(t2p);\n}", "target": 0}
{"code": "static inline bool mmget_still_valid(struct mm_struct *mm)\n{\n\treturn likely(!mm->core_state);\n}", "target": 0}
{"code": "static void mkiss_put(struct mkiss *ax)\n{\n\tif (refcount_dec_and_test(&ax->refcnt))\n\t\tcomplete(&ax->dead);\n}", "target": 0}
{"code": "        int    ReadDoubleArray(unsigned char *sString, int nLen, double (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n                    continue;\n                }\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n                    bNewItem = false;\n                    nCount++;\n                }\n                sBuffer[nBufPos++] = unChar;\n                if (nBufPos >= c_nNumLimit)\n                    break;\n            }\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n            return nCount;\n        }", "target": 0}
{"code": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SEC_SIZE(h) == len);\n\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n\t    ((char *)buf) + offs, len);\n}", "target": 1}
{"code": "   Read the full structure of a message */\nPHP_FUNCTION(imap_fetchstructure)\n{\n\tzval *streamind;\n\tzend_long msgno, flags = 0;\n\tpils *imap_le_struct;\n\tBODY *body;\n\tint msgindex, argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc, \"rl|l\", &streamind, &msgno, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (flags && ((flags & ~FT_UID) != 0)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"invalid value for the options parameter\");\n\t\tRETURN_FALSE;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (msgno < 1) {\n\t\tRETURN_FALSE;\n\t}\n\tobject_init(return_value);\n\tif ((argc == 3) && (flags & FT_UID)) {\n\t\tmsgindex = mail_msgno(imap_le_struct->imap_stream, msgno);\n\t} else {\n\t\tmsgindex = msgno;\n\t}\n\tPHP_IMAP_CHECK_MSGNO(msgindex);\n\tmail_fetchstructure_full(imap_le_struct->imap_stream, msgno, &body , (argc == 3 ? flags : NIL));\n\tif (!body) {\n\t\tphp_error_docref(NULL, E_WARNING, \"No body information available\");\n\t\tRETURN_FALSE;\n\t}\n\t_php_imap_add_body(return_value, body);", "target": 0}
{"code": "Opal::Call::send_dtmf (const char dtmf)\n{\n  PSafePtr<OpalConnection> connection = get_remote_connection ();\n  if (connection != NULL) {\n    connection->SendUserInputTone (dtmf, 180);\n  }\n}", "target": 0}
{"code": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = true;\n\tmb();\n\treturn 0;\n}", "target": 1}
{"code": "CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)\n{\n  ssize_t i;\n  ssize_t si;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *scratch = data->state.scratch;\n  char *newscratch = NULL;\n  char *oldscratch = NULL;\n  size_t eob_sent;\n  if(!scratch || data->set.crlf) {\n    oldscratch = scratch;\n    scratch = newscratch = malloc(2 * data->set.buffer_size);\n    if(!newscratch) {\n      failf(data, \"Failed to alloc scratch buffer!\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  eob_sent = smtp->eob;\n  for(i = 0, si = 0; i < nread; i++) {\n    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {\n      smtp->eob++;\n      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)\n        smtp->trailing_crlf = TRUE;\n      else\n        smtp->trailing_crlf = FALSE;\n    }\n    else if(smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n      si += smtp->eob - eob_sent;\n      if(SMTP_EOB[0] == data->req.upload_fromhere[i])\n        smtp->eob = 1;\n      else\n        smtp->eob = 0;\n      eob_sent = 0;\n      smtp->trailing_crlf = FALSE;\n    }\n    if(SMTP_EOB_FIND_LEN == smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],\n             SMTP_EOB_REPL_LEN - eob_sent);\n      si += SMTP_EOB_REPL_LEN - eob_sent;\n      smtp->eob = 0;\n      eob_sent = 0;\n    }\n    else if(!smtp->eob)\n      scratch[si++] = data->req.upload_fromhere[i];\n  }\n  if(smtp->eob - eob_sent) {\n    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n    si += smtp->eob - eob_sent;\n  }\n  if(si != nread) {\n    data->req.upload_fromhere = scratch;\n    data->state.scratch = scratch;\n    free(oldscratch);\n    data->req.upload_present = si;\n  }\n  else\n    free(newscratch);\n  return CURLE_OK;\n}", "target": 1}
{"code": "int BN_hex2bn(BIGNUM **bn, const char *a)\n{\n    BIGNUM *ret = NULL;\n    BN_ULONG l = 0;\n    int neg = 0, h, m, i, j, k, c;\n    int num;\n    if ((a == NULL) || (*a == '\\0'))\n        return (0);\n    if (*a == '-') {\n        neg = 1;\n        a++;\n    }\n    for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)\n        continue;\n    if (i > INT_MAX/4)\n        goto err;\n    num = i + neg;\n    if (bn == NULL)\n        return (num);\n    if (*bn == NULL) {\n        if ((ret = BN_new()) == NULL)\n            return (0);\n    } else {\n        ret = *bn;\n        BN_zero(ret);\n    }\n    if (bn_expand(ret, i * 4) == NULL)\n        goto err;\n    j = i;                      \n    m = 0;\n    h = 0;\n    while (j > 0) {\n        m = ((BN_BYTES * 2) <= j) ? (BN_BYTES * 2) : j;\n        l = 0;\n        for (;;) {\n            c = a[j - m];\n            if ((c >= '0') && (c <= '9'))\n                k = c - '0';\n            else if ((c >= 'a') && (c <= 'f'))\n                k = c - 'a' + 10;\n            else if ((c >= 'A') && (c <= 'F'))\n                k = c - 'A' + 10;\n            else\n                k = 0;          \n            l = (l << 4) | k;\n            if (--m <= 0) {\n                ret->d[h++] = l;\n                break;\n            }\n        }\n        j -= (BN_BYTES * 2);\n    }\n    ret->top = h;\n    bn_correct_top(ret);\n    ret->neg = neg;\n    *bn = ret;\n    bn_check_top(ret);\n    return (num);\n err:\n    if (*bn == NULL)\n        BN_free(ret);\n    return (0);\n}", "target": 0}
{"code": "void nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "void scheduler_tick(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr = rq->curr;\n\tsched_clock_tick();\n\traw_spin_lock(&rq->lock);\n\tupdate_rq_clock(rq);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\tupdate_cpu_load_active(rq);\n\tcalc_global_load_tick(rq);\n\traw_spin_unlock(&rq->lock);\n\tperf_event_task_tick();\n#ifdef CONFIG_SMP\n\trq->idle_balance = idle_cpu(cpu);\n\ttrigger_load_balance(rq);\n#endif\n\trq_last_tick_reset(rq);\n}", "target": 0}
{"code": "void read_user_name(char *name)\n{\n  char *str=getenv(\"USER\");\t\t\n  strmake(name,str ? str : \"ODBC\", USERNAME_LENGTH);\n}", "target": 0}
{"code": "void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}", "target": 1}
{"code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "target": 1}
{"code": "MODULE_ENTRY (fill_vtable) (GdkPixbufModule *module)\n{\n\tmodule->begin_load = gdk_pixbuf__bmp_image_begin_load;\n\tmodule->stop_load = gdk_pixbuf__bmp_image_stop_load;\n\tmodule->load_increment = gdk_pixbuf__bmp_image_load_increment;\n\tmodule->save = gdk_pixbuf__bmp_image_save;\n\tmodule->save_to_callback = gdk_pixbuf__bmp_image_save_to_callback;\n}", "target": 0}
{"code": "bgp_attr_cluster_list (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  if (length % 4)\n    {\n      zlog (peer->log, LOG_ERR, \"Bad cluster list length %d\", length);\n      return bgp_attr_malformed (args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 args->total);\n    }\n  (bgp_attr_extra_get (attr))->cluster \n    = cluster_parse ((struct in_addr *)stream_pnt (peer->ibuf), length);\n  stream_forward_getp (peer->ibuf, length);\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_CLUSTER_LIST);\n  return BGP_ATTR_PARSE_PROCEED;\n}", "target": 0}
{"code": "static void mark_reg_unknown(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_reg_state *regs, u32 regno)\n{\n\tif (WARN_ON(regno >= MAX_BPF_REG)) {\n\t\tverbose(env, \"mark_reg_unknown(regs, %u)\\n\", regno);\n\t\tfor (regno = 0; regno < BPF_REG_FP; regno++)\n\t\t\t__mark_reg_not_init(env, regs + regno);\n\t\treturn;\n\t}\n\t__mark_reg_unknown(env, regs + regno);\n}", "target": 0}
{"code": "TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 rowsperstrip;\n\tuint32 stripsperplane;\n\tuint32 stripinplane;\n\tuint16 plane;\n\tuint32 rows;\n\ttmsize_t stripsize;\n\tif (!TIFFCheckRead(tif,0))\n\t\treturn((tmsize_t)(-1));\n\tif (strip>=td->td_nstrips)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\n\t\t    (unsigned long)td->td_nstrips);\n\t\treturn((tmsize_t)(-1));\n\t}\n \trowsperstrip=td->td_rowsperstrip;\n \tif (rowsperstrip>td->td_imagelength)\n \t\trowsperstrip=td->td_imagelength;\n\tstripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip);\n \tstripinplane=(strip%stripsperplane);\n \tplane=(uint16)(strip/stripsperplane);\n \trows=td->td_imagelength-stripinplane*rowsperstrip;\n\tif (rows>rowsperstrip)\n\t\trows=rowsperstrip;\n\tstripsize=TIFFVStripSize(tif,rows);\n\tif (stripsize==0)\n\t\treturn((tmsize_t)(-1));\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= stripsize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,stripsize);\n        (*tif->tif_postdecode)(tif,buf,stripsize);\n        return (stripsize);\n    }\n\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\n\t\tstripsize=size;\n\tif (!TIFFFillStrip(tif,strip))\n\t\treturn((tmsize_t)(-1));\n\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n\t\treturn((tmsize_t)(-1));\n\t(*tif->tif_postdecode)(tif,buf,stripsize);\n\treturn(stripsize);\n}", "target": 1}
{"code": "  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecgsiGMAPLDAP.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }", "target": 1}
{"code": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}", "target": 1}
{"code": "static void check_preempt_wakeup(struct rq *rq, struct task_struct *p)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(curr);\n\tstruct sched_entity *se = &curr->se, *pse = &p->se;\n\tunsigned long gran;\n\tif (unlikely(rt_prio(p->prio))) {\n\t\tupdate_rq_clock(rq);\n\t\tupdate_curr(cfs_rq);\n\t\tresched_task(curr);\n\t\treturn;\n\t}\n\tcfs_rq_of(pse)->next = pse;\n\tif (unlikely(p->policy == SCHED_BATCH))\n\t\treturn;\n\tif (!sched_feat(WAKEUP_PREEMPT))\n\t\treturn;\n\twhile (!is_same_group(se, pse)) {\n\t\tse = parent_entity(se);\n\t\tpse = parent_entity(pse);\n\t}\n\tgran = sysctl_sched_wakeup_granularity;\n\tif (unlikely(se->load.weight > NICE_0_LOAD))\n\t\tgran = calc_delta_fair(gran, &se->load);\n\tif (pse->vruntime + gran < se->vruntime)\n\t\tresched_task(curr);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, OrElemMatchObject) {\n    addIndex(BSON(\"a.b\" << 1), true);\n    runQuery(\n        fromjson(\"{$or: [{a: {$elemMatch: {b: {$lte: 1}}}},\"\n                 \"{a: {$elemMatch: {b: {$gte: 4}}}}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{or: {nodes: [\"\n        \"{fetch: {filter: {a:{$elemMatch:{b:{$gte:4}}}}, node: \"\n        \"{ixscan: {filter: null, pattern: {'a.b': 1}}}}},\"\n        \"{fetch: {filter: {a:{$elemMatch:{b:{$lte:1}}}}, node: \"\n        \"{ixscan: {filter: null, pattern: {'a.b': 1}}}}}]}}\");\n}", "target": 0}
{"code": "long keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   const struct iovec *payload_iov,\n\t\t\t\t   unsigned ioc,\n\t\t\t\t   size_t plen,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tvoid *payload;\n\tlong ret;\n\tbool vm = false;\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\trka = instkey->payload.data;\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (payload_iov) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload) {\n\t\t\tif (plen <= PAGE_SIZE)\n\t\t\t\tgoto error;\n\t\t\tvm = true;\n\t\t\tpayload = vmalloc(plen);\n\t\t\tif (!payload)\n\t\t\t\tgoto error;\n\t\t}\n\t\tret = copy_from_user_iovec(payload, payload_iov, ioc);\n\t\tif (ret < 0)\n\t\t\tgoto error2;\n\t}\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\tkey_put(dest_keyring);\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\nerror2:\n\tif (!vm)\n\t\tkfree(payload);\n\telse\n\t\tvfree(payload);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static __init int vdso_fixup_datapage(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n\tElf32_Sym *sym32;\n#ifdef CONFIG_PPC64\n\tElf64_Sym *sym64;\n       \tsym64 = find_symbol64(v64, \"__kernel_datapage_offset\");\n\tif (sym64 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso64_kbase + sym64->st_value - VDSO64_LBASE)) =\n\t\t(vdso64_pages << PAGE_SHIFT) -\n\t\t(sym64->st_value - VDSO64_LBASE);\n#endif \n\tsym32 = find_symbol32(v32, \"__kernel_datapage_offset\");\n\tif (sym32 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso32_kbase + (sym32->st_value - VDSO32_LBASE))) =\n\t\t(vdso32_pages << PAGE_SHIFT) -\n\t\t(sym32->st_value - VDSO32_LBASE);\n\treturn 0;\n}", "target": 0}
{"code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}", "target": 1}
{"code": "static inline void CheckEventLogging()\n{\n  if (IsLinkedListEmpty(log_cache) != MagickFalse)\n    event_logging=MagickFalse;\n  else\n    {\n      LogInfo\n        *p;\n      ResetLinkedListIterator(log_cache);\n      p=(LogInfo *) GetNextValueInLinkedList(log_cache);\n      event_logging=p->event_mask != NoEvents ? MagickTrue: MagickFalse;\n    }\n}", "target": 1}
{"code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}", "target": 1}
{"code": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\nbox = 0;\nout = 0;\n\treturn -1;\n}", "target": 1}
{"code": "LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem& value) {\n  LIR_Opr result = new_register(type);\n  value.load_item();\n  __ move(value.result(), result);\n  assert(type == T_INT LP64_ONLY( || type == T_LONG ), \"unexpected type\");\n  __ xadd(addr, result, result, LIR_OprFact::illegalOpr);\n  return result;\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, FailGracefullyOnInvalidExpression) {\n    ASSERT_THROWS_CODE(createMatcher(fromjson(\"{$expr: {$anyElementTrue: undefined}}\")),\n                       AssertionException,\n                       17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$and: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$or: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$nor: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n}", "target": 0}
{"code": "void __qdisc_run(struct net_device *dev)\n{\n\tdo {\n\t\tif (!qdisc_restart(dev))\n\t\t\tbreak;\n\t} while (!netif_queue_stopped(dev));\n\tclear_bit(__LINK_STATE_QDISC_RUNNING, &dev->state);\n}", "target": 1}
{"code": "void RenderView::OnCopy() {\n  if (!webview())\n    return;\n  webview()->focusedFrame()->executeCommand(WebString::fromUTF8(\"Copy\"));\n  UserMetricsRecordAction(\"Copy\");\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64_t>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64_t weights_size = weights.size();\n    OP_REQUIRES(ctx, size_t.dims() == 0,\n                errors::InvalidArgument(\"Shape must be rank 0 but is rank \",\n                                        size_t.dims()));\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n    OP_REQUIRES(ctx, splits.size() > 0,\n                errors::InvalidArgument(\"Splits must be non-empty\"));\n    OP_REQUIRES(ctx, splits(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits(0)));\n    OP_REQUIRES(ctx, splits(num_rows) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits(num_rows), \" instead of \", num_values));\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 0}
{"code": "    template<typename t1, typename t2>\n    CImg<intT> get_patchmatch(const CImg<T>& patch_image,\n                              const unsigned int patch_width,\n                              const unsigned int patch_height,\n                              const unsigned int patch_depth,\n                              const unsigned int nb_iterations,\n                              const unsigned int nb_randoms,\n                              const CImg<t1> &guide,\n                              CImg<t2> &matching_score) const {\n      return _patchmatch(patch_image,patch_width,patch_height,patch_depth,\n                         nb_iterations,nb_randoms,\n                         guide,true,matching_score);", "target": 0}
{"code": "static inline QuantumAny ScaleQuantumToAny(const Quantum quantum,\n  const QuantumAny range)\n{\n  return((QuantumAny) (((double) range*quantum)/QuantumRange+0.5));\n}", "target": 1}
{"code": "loop_pop(codegen_scope *s, int val)\n{\n  if (val) {\n    genop_1(s, OP_LOADNIL, cursp());\n  }\n  dispatch_linked(s, s->loop->pc2);\n  s->loop = s->loop->prev;\n  if (val) push();\n}", "target": 0}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "renderCoTable(struct table *tbl, int maxlimit)\n{\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    struct table *t;\n    int i, col, row;\n    int indent, maxwidth;\n    for (i = 0; i < tbl->ntable; i++) {\n\tt = tbl->tables[i].ptr;\n\tcol = tbl->tables[i].col;\n\trow = tbl->tables[i].row;\n\tindent = tbl->tables[i].indent;\n\tinit_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,\n\t\t  get_spec_cell_width(tbl, row, col), indent);\n\tcheck_row(tbl, row);\n\tif (h_env.limit > maxlimit)\n\t    h_env.limit = maxlimit;\n\tif (t->total_width == 0)\n\t    maxwidth = h_env.limit - indent;\n\telse if (t->total_width > 0)\n\t    maxwidth = t->total_width;\n\telse\n\t    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;\n\trenderTable(t, maxwidth, &h_env);\n    }\n}", "target": 1}
{"code": "_gnutls_x509_oid2mac_algorithm (const char *oid)\n{\n  gnutls_mac_algorithm_t ret = 0;\n  GNUTLS_HASH_LOOP (if (strcmp (oid, p->oid) == 0)\n\t\t    {\n\t\t    ret = p->id; break;}\n  );\n  if (ret == 0)\n    return GNUTLS_MAC_UNKNOWN;\n  return ret;\n}", "target": 1}
{"code": "asmlinkage long compat_sys_ppoll(struct pollfd __user *ufds,\n\tunsigned int nfds, struct compat_timespec __user *tsp,\n\tconst compat_sigset_t __user *sigmask, compat_size_t sigsetsize)\n{\n\tcompat_sigset_t ss32;\n\tsigset_t ksigmask, sigsaved;\n\tstruct compat_timespec ts;\n\ts64 timeout = -1;\n\tint ret;\n\tif (tsp) {\n\t\tif (copy_from_user(&ts, tsp, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\t\ttimeout = ROUND_UP(ts.tv_nsec, 1000000000/HZ);\n\t\ttimeout += ts.tv_sec * HZ;\n\t}\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ss32, sigmask, sizeof(ss32)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&ksigmask, &ss32);\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\tret = do_sys_poll(ufds, nfds, &timeout);\n\tif (ret == -EINTR) {\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\tsizeof(sigsaved));\n\t\t\tset_thread_flag(TIF_RESTORE_SIGMASK);\n\t\t}\n\t\tret = -ERESTARTNOHAND;\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\tif (tsp && timeout >= 0) {\n\t\tstruct compat_timespec rts;\n\t\tif (current->personality & STICKY_TIMEOUTS)\n\t\t\tgoto sticky;\n\t\trts.tv_nsec = jiffies_to_usecs(do_div((*(u64*)&timeout), HZ)) *\n\t\t\t\t\t1000;\n\t\trts.tv_sec = timeout;\n\t\tif (compat_timespec_compare(&rts, &ts) >= 0)\n\t\t\trts = ts;\n\t\tif (copy_to_user(tsp, &rts, sizeof(rts))) {\nsticky:\n\t\t\tif (ret == -ERESTARTNOHAND && timeout >= 0)\n\t\t\t\tret = -EINTR;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_BASE + DRAM1_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\tif (dst < prot_start && dst > prot_start - len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "TEST_F(HeaderToMetadataTest, OnMissingWhenHeaderIsPresent) {\n  const std::string config = R\"EOF(\nrequest_rules:\n  - header: x-version\n    on_header_missing:\n      metadata_namespace: envoy.lb\n      key: version\n      value: some_value\n      type: STRING\n)EOF\";\n  initializeFilter(config);\n  Http::TestRequestHeaderMapImpl headers{{\"x-version\", \"\"}};\n  EXPECT_CALL(decoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_, setDynamicMetadata(_, _)).Times(0);\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(headers, false));\n}", "target": 0}
{"code": "process_button(struct parsed_tag *tag)\n{\n    Str tmp = NULL;\n    char *p, *q, *r, *qq = \"\";\n    int qlen, v;\n    if (cur_form_id < 0) {\n       char *s = \"<form_int method=internal action=none>\";\n       tmp = process_form(parse_tag(&s, TRUE));\n    }\n    if (tmp == NULL)\n       tmp = Strnew();\n    p = \"submit\";\n    parsedtag_get_value(tag, ATTR_TYPE, &p);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_VALUE, &q);\n    r = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &r);\n    v = formtype(p);\n    if (v == FORM_UNKNOWN)\n       return NULL;\n    if (!q) {\n       switch (v) {\n       case FORM_INPUT_SUBMIT:\n       case FORM_INPUT_BUTTON:\n           q = \"SUBMIT\";\n           break;\n       case FORM_INPUT_RESET:\n           q = \"RESET\";\n           break;\n       }\n    }\n    if (q) {\n       qq = html_quote(q);\n       qlen = strlen(q);\n    }\n    Strcat(tmp, Sprintf(\"<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" type=\\\"%s\\\" \"\n                       \"name=\\\"%s\\\" value=\\\"%s\\\">\",\n                       cur_hseq++, cur_form_id, html_quote(p),\n                       html_quote(r), qq));\n    return tmp;\n}", "target": 1}
{"code": "Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){\n  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);\n  if( p ){\n    struct SrcList_item *pItem = &pSrc->a[iSrc];\n    p->y.pTab = pItem->pTab;\n    p->iTable = pItem->iCursor;\n    if( p->y.pTab->iPKey==iCol ){\n      p->iColumn = -1;\n    }else{\n      p->iColumn = (ynVar)iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n    }\n  }\n  return p;\n}", "target": 1}
{"code": "int __parse_rtattr_nested_compat(struct rtattr *tb[], int max,\n\t\t\t\t struct rtattr *rta,\n\t\t\t\t int len)\n{\n\tif (RTA_PAYLOAD(rta) < len)\n\t\treturn -1;\n\tif (RTA_PAYLOAD(rta) >= RTA_ALIGN(len) + sizeof(struct rtattr)) {\n\t\trta = RTA_DATA(rta) + RTA_ALIGN(len);\n\t\treturn parse_rtattr_nested(tb, max, rta);\n\t}\n\tmemset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\treturn 0;\n}", "target": 0}
{"code": "list_table_status(MYSQL *mysql,const char *db,const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  end=strxmov(query,\"show table status from `\",db,\"`\",NullS);\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot get status for db: %s, table: %s: %s\\n\",\n\t    my_progname,db,wild ? wild : \"\",mysql_error(mysql));\n    if (mysql_errno(mysql) == ER_PARSE_ERROR)\n      fprintf(stderr,\"This error probably means that your MySQL server doesn't support the\\n\\'show table status' command.\\n\");\n    return 1;\n  }\n  printf(\"Database: %s\",db);\n  if (wild)\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "int wake_up_state(struct task_struct *p, unsigned int state)\n{\n\treturn try_to_wake_up(p, state, 0);\n}", "target": 0}
{"code": "bool DataObjectItem::HasFileSystemId() const {\n  return kind_ == kFileKind && !file_system_id_.IsEmpty();\n}", "target": 0}
{"code": "kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        conf_req_flag = FALSE;\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}", "target": 1}
{"code": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\ttmp = xmalloc(len);\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}", "target": 1}
{"code": "uint32_t read32(uint8_t* arr, int pos,  int swapBytes)\n{\n    if(!swapBytes) {\n        return (arr[pos]   << 24) |\n               (arr[pos+1] << 16) |\n               (arr[pos+2] << 8) |\n                arr[pos+3];\n    }\n    return arr[pos] |\n           (arr[pos+1] << 8) |\n           (arr[pos+2] << 16) |\n           (arr[pos+3] << 24);\n}", "target": 0}
{"code": "int snd_usb_pipe_sanity_check(struct usb_device *dev, unsigned int pipe)\n{\n\tstatic const int pipetypes[4] = {\n\t\tPIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT\n\t};\n\tstruct usb_host_endpoint *ep;\n\tep = usb_pipe_endpoint(dev, pipe);\n\tif (usb_pipetype(pipe) != pipetypes[usb_endpoint_type(&ep->desc)])\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 1}
{"code": "void PpapiPluginProcessHost::OnProcessLaunched() {\n   host_impl_->set_plugin_process_handle(process_->GetHandle());\n }", "target": 0}
{"code": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)\n{\n\tstruct jbg_dec_state decoder;\n\tint decodeStatus = 0;\n\tunsigned char* pImage = NULL;\n\t(void) size, (void) s;\n\tif (isFillOrder(tif, tif->tif_dir.td_fillorder))\n\t{\n\t\tTIFFReverseBits(tif->tif_rawdata, tif->tif_rawdatasize);\n\t}\n\tjbg_dec_init(&decoder);\n#if defined(HAVE_JBG_NEWLEN)\n\tjbg_newlen(tif->tif_rawdata, (size_t)tif->tif_rawdatasize);\n#endif \n\tdecodeStatus = jbg_dec_in(&decoder, (unsigned char*)tif->tif_rawdata,\n\t\t\t\t  (size_t)tif->tif_rawdatasize, NULL);\n\tif (JBG_EOK != decodeStatus)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"JBIG\", \"Error (%d) decoding: %s\",\n\t\t\t     decodeStatus,\n#if defined(JBG_EN)\n\t\t\t     jbg_strerror(decodeStatus, JBG_EN)\n#else\n\t\t\t     jbg_strerror(decodeStatus)\n#endif\n\t\t\t     );\n\t\tjbg_dec_free(&decoder);\n\t\treturn 0;\n\t}\n\tpImage = jbg_dec_getimage(&decoder, 0);\n\t_TIFFmemcpy(buffer, pImage, jbg_dec_getsize(&decoder));\n\tjbg_dec_free(&decoder);\n\treturn 1;\n}", "target": 1}
{"code": "static long btrfs_ioctl_scrub_progress(struct btrfs_fs_info *fs_info,\n\t\t\t\t       void __user *arg)\n{\n\tstruct btrfs_ioctl_scrub_args *sa;\n\tint ret;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\tret = btrfs_scrub_progress(fs_info, sa->devid, &sa->progress);\n\tif (ret == 0 && copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\tkfree(sa);\n\treturn ret;\n}", "target": 0}
{"code": "static void *intel_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  unsigned long attrs)\n{\n\tstruct page *page = NULL;\n\tint order;\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\tif (!iommu_no_mapping(dev))\n\t\tflags &= ~(GFP_DMA | GFP_DMA32);\n\telse if (dev->coherent_dma_mask < dma_get_required_mask(dev)) {\n\t\tif (dev->coherent_dma_mask < DMA_BIT_MASK(32))\n\t\t\tflags |= GFP_DMA;\n\t\telse\n\t\t\tflags |= GFP_DMA32;\n\t}\n\tif (gfpflags_allow_blocking(flags)) {\n\t\tunsigned int count = size >> PAGE_SHIFT;\n\t\tpage = dma_alloc_from_contiguous(dev, count, order,\n\t\t\t\t\t\t flags & __GFP_NOWARN);\n\t\tif (page && iommu_no_mapping(dev) &&\n\t\t    page_to_phys(page) + size > dev->coherent_dma_mask) {\n\t\t\tdma_release_from_contiguous(dev, page, count);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_pages(flags, order);\n\tif (!page)\n\t\treturn NULL;\n\tmemset(page_address(page), 0, size);\n\t*dma_handle = __intel_map_single(dev, page_to_phys(page), size,\n\t\t\t\t\t DMA_BIDIRECTIONAL,\n\t\t\t\t\t dev->coherent_dma_mask);\n\tif (*dma_handle)\n\t\treturn page_address(page);\n\tif (!dma_release_from_contiguous(dev, page, size >> PAGE_SHIFT))\n\t\t__free_pages(page, order);\n\treturn NULL;\n}", "target": 0}
{"code": "static int fsmReadLink(const char *path,\n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}", "target": 0}
{"code": "void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpreempt_disable();\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\tpreempt_enable();\n}", "target": 1}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}", "target": 1}
{"code": "static int formatIPTCfromBuffer(Image *ofile, char *s, ssize_t len)\n{\n  char\n    temp[MaxTextExtent];\n  unsigned int\n    foundiptc,\n    tagsfound;\n  unsigned char\n    recnum,\n    dataset;\n  unsigned char\n    *readable,\n    *str;\n  ssize_t\n    tagindx,\n    taglen;\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n  int\n    c;\n  foundiptc = 0; \n  tagsfound = 0; \n  while (len > 0)\n  {\n    c = *s++; len--;\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return -1;\n        else\n          continue;\n      }\n    c = *s++; len--;\n    if (len < 0) return -1;\n    dataset = (unsigned char) c;\n    c = *s++; len--;\n    if (len < 0) return -1;\n    recnum = (unsigned char) c;\n    for (i=0; i< tagcount; i++)\n      if (tags[i].id == (short) recnum)\n        break;\n    if (i < tagcount)\n      readable=(unsigned char *) tags[i].name;\n    else\n      readable=(unsigned char *) \"\";\n    c=(*s++);\n    len--;\n    if (len < 0)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        s--;\n        len++;\n        taglen=readWordFromBuffer(&s, &len);\n      }\n    if (taglen < 0)\n      return(-1);\n    if (taglen > 65535)\n      return(-1);\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MaxTextExtent),\n      sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      return 0;\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c = *s++; len--;\n      if (len < 0)\n        return(-1);\n      str[tagindx]=(unsigned char) c;\n    }\n    str[taglen]=0;\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MaxTextExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset,(unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MaxTextExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n    tagsfound++;\n  }\n  return ((int) tagsfound);\n}", "target": 1}
{"code": "static int __init memory_tier_init(void)\n{\n\tint ret, node;\n\tstruct memory_tier *memtier;\n\tret = subsys_virtual_register(&memory_tier_subsys, NULL);\n\tif (ret)\n\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);\n#ifdef CONFIG_MIGRATION\n\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),\n\t\t\t\tGFP_KERNEL);\n\tWARN_ON(!node_demotion);\n#endif\n\tmutex_lock(&memory_tier_lock);\n\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n\tif (!default_dram_type)\n\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);\n\tfor_each_node_state(node, N_MEMORY) {\n\t\tmemtier = set_node_memory_tier(node);\n\t\tif (IS_ERR(memtier))\n\t\t\tbreak;\n\t}\n\testablish_demotion_targets();\n\tmutex_unlock(&memory_tier_lock);\n\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);\n\treturn 0;\n}", "target": 1}
{"code": "MenuCacheItem *menu_cache_find_item_by_id(MenuCache *cache, const char *id)\n{\n    MenuCacheItem *item = NULL;\n    MENU_CACHE_LOCK;\n    if (cache && id)\n        item = _scan_by_id(MENU_CACHE_ITEM(cache->root_dir), id);\n    if (item)\n        menu_cache_item_ref(item);\n    MENU_CACHE_UNLOCK;\n    return item;\n}", "target": 0}
{"code": "static struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, size;\n\tint npinned;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\tint ret;\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn ERR_PTR(-EINVAL);\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (WARN_ON_ONCE(npages > INT_MAX))\n\t\treturn ERR_PTR(-EINVAL);\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\tif (!pages)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnpinned = pin_user_pages_fast(uaddr, npages, write ? FOLL_WRITE : 0, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\t*n = npages;\n\tsev->pages_locked = locked;\n\treturn pages;\nerr:\n\tif (npinned > 0)\n\t\tunpin_user_pages(pages, npinned);\n\tkvfree(pages);\n\treturn ERR_PTR(ret);\n}", "target": 0}
{"code": "get_manuf_name_if_known(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    guint manuf_key;\n    guint8 oct;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {\n        return manuf_value->resolved_longname;\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return long_name;\n    }\n    return NULL;\n} ", "target": 1}
{"code": "static bool ok_inflater_literal_tree(ok_inflater *inflater) {\n    bool done = ok_inflater_inflate_huffman_tree(inflater, inflater->literal_huffman,\n                                                 inflater->code_length_huffman,\n                                                 inflater->num_literal_codes);\n    if (done) {\n        inflater->state = OK_INFLATER_STATE_READING_DYNAMIC_DISTANCE_TREE;\n        inflater->huffman_code = -1;\n        inflater->state_count = 0;\n        return true;\n    } else {\n        return false;\n    }\n}", "target": 0}
{"code": "repodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n  if (!*schema)\n    return 0;\t\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}", "target": 1}
{"code": "int is_ntfs_dotgit(const char *name)\n{\n\tint len;\n\tfor (len = 0; ; len++)\n\t\tif (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) {\n\t\t\tif (only_spaces_and_periods(name, len, 4) &&\n\t\t\t\t\t!strncasecmp(name, \".git\", 4))\n\t\t\t\treturn 1;\n\t\t\tif (only_spaces_and_periods(name, len, 5) &&\n\t\t\t\t\t!strncasecmp(name, \"git~1\", 5))\n\t\t\t\treturn 1;\n\t\t\tif (name[len] != '\\\\')\n\t\t\t\treturn 0;\n\t\t\tname += len + 1;\n\t\t\tlen = -1;\n\t\t}\n}", "target": 1}
{"code": "add_y_curve_part(line_list *ll, segment *s0, segment *s1, int dir,\n    gx_flattened_iterator *fi, bool more1, bool step_back, bool monotonic_x)\n{\n    active_line *alp = make_al(ll);\n    int code;\n    if (alp == NULL)\n        return_error(gs_error_VMerror);\n    alp->pseg = (dir == DIR_UP ? s1 : s0);\n    alp->direction = dir;\n    alp->fi = *fi;\n    alp->more_flattened = more1;\n    if (dir != DIR_UP && more1)\n        gx_flattened_iterator__switch_to_backscan(&alp->fi, more1);\n    if (step_back) {\n        do {\n            code = gx_flattened_iterator__prev(&alp->fi);\n            if (code < 0)\n                return code;\n            alp->more_flattened = code;\n            if (compute_dir(ll->fo, alp->fi.ly0, alp->fi.ly1) != 2)\n                break;\n        } while (alp->more_flattened);\n    }\n    code = step_al(alp, false);\n    if (code < 0)\n        return code;\n    alp->monotonic_y = false;\n    alp->monotonic_x = monotonic_x;\n    insert_y_line(ll, alp);\n    return 0;\n}", "target": 0}
{"code": "TEST_F(LoaderTest, PbtxtFormat) {\n  SavedModelBundle bundle;\n  SessionOptions session_options;\n  RunOptions run_options;\n  const string export_dir =\n      io::JoinPath(testing::TensorFlowSrcRoot(), kTestDataPbTxt);\n  TF_ASSERT_OK(LoadSavedModel(session_options, run_options, export_dir,\n                              {kSavedModelTagServe}, &bundle));\n  CheckSavedModelBundle(export_dir, bundle);\n}", "target": 0}
{"code": "  TestHeaderMapImplBase(const HeaderMap& rhs) {\n    HeaderMapImpl::copyFrom(*header_map_, rhs);\n    header_map_->verifyByteSizeInternalForTest();\n  }", "target": 0}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "static PHP_GINIT_FUNCTION(libxml)\n{\n        libxml_globals->stream_context = NULL;\n        libxml_globals->error_buffer.c = NULL;\n        libxml_globals->error_list = NULL;\n }", "target": 1}
{"code": "static size_t push_pipe(struct iov_iter *i, size_t size,\n\t\t\tint *iter_headp, size_t *offp)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int iter_head;\n\tsize_t off;\n\tssize_t left;\n\tif (unlikely(size > i->count))\n\t\tsize = i->count;\n\tif (unlikely(!size))\n\t\treturn 0;\n\tleft = size;\n\tdata_start(i, &iter_head, &off);\n\t*iter_headp = iter_head;\n\t*offp = off;\n\tif (off) {\n\t\tleft -= PAGE_SIZE - off;\n\t\tif (left <= 0) {\n\t\t\tpipe->bufs[iter_head & p_mask].len += size;\n\t\t\treturn size;\n\t\t}\n\t\tpipe->bufs[iter_head & p_mask].len = PAGE_SIZE;\n\t\titer_head++;\n\t}\n\twhile (!pipe_full(iter_head, p_tail, pipe->max_usage)) {\n\t\tstruct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];\n\t\tstruct page *page = alloc_page(GFP_USER);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tbuf->ops = &default_pipe_buf_ops;\n\t\tbuf->page = page;\n\t\tbuf->offset = 0;\n\t\tbuf->len = min_t(ssize_t, left, PAGE_SIZE);\n\t\tleft -= buf->len;\n\t\titer_head++;\n\t\tpipe->head = iter_head;\n\t\tif (left == 0)\n\t\t\treturn size;\n\t}\n\treturn size - left;\n}", "target": 1}
{"code": "PROCESS_THREAD(snmp_process, ev, data)\n{\n  PROCESS_BEGIN();\n  snmp_udp_conn = udp_new(NULL, 0, NULL);\n  udp_bind(snmp_udp_conn, SNMP_SERVER_PORT);\n  LOG_DBG(\"Listening on port %u\\n\", uip_ntohs(snmp_udp_conn->lport));\n  while(1) {\n    PROCESS_YIELD();\n    if(ev == tcpip_event) {\n      if(uip_newdata()) {\n        snmp_process_data();\n      }\n    }\n  } \n  PROCESS_END();\n}", "target": 1}
{"code": "int kill_pid_info_as_uid(int sig, struct siginfo *info, struct pid *pid,\n\t\t      uid_t uid, uid_t euid, u32 secid)\n{\n\tint ret = -EINVAL;\n\tstruct task_struct *p;\n\tconst struct cred *pcred;\n\tif (!valid_signal(sig))\n\t\treturn ret;\n\tread_lock(&tasklist_lock);\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\tpcred = __task_cred(p);\n\tif ((info == SEND_SIG_NOINFO ||\n\t     (!is_si_special(info) && SI_FROMUSER(info))) &&\n\t    euid != pcred->suid && euid != pcred->uid &&\n\t    uid  != pcred->suid && uid  != pcred->uid) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = security_task_kill(p, info, sig, secid);\n\tif (ret)\n\t\tgoto out_unlock;\n\tif (sig && p->sighand) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tret = __send_signal(sig, info, p, 1, 0);\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\nout_unlock:\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}", "target": 0}
{"code": "x509stack_pop(struct cert_stack *stack)\n{\n\tX509 *cert;\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo;\n\tcert = sk_X509_pop(stack->x509s);\n\tif (cert == NULL)\n\t\tpr_crit(\"Attempted to pop empty X509 stack\");\n\tX509_free(cert);\n\tmeta = SLIST_FIRST(&stack->metas);\n\tif (meta == NULL)\n\t\tpr_crit(\"Attempted to pop empty metadata stack\");\n\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\tmeta_destroy(meta);\n\trepo = SLIST_FIRST(&stack->levels);\n\tif (repo == NULL)\n\t\tpr_crit(\"Attempted to pop empty repo level stack\");\n\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n}", "target": 1}
{"code": "resolve_op_from_commit (FlatpakTransaction *self,\n                        FlatpakTransactionOperation *op,\n                        const char *checksum,\n                        GFile *sideload_path,\n                        GVariant *commit_data,\n                        GError **error)\n{\n  g_autoptr(GBytes) metadata_bytes = NULL;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  const char *xa_metadata = NULL;\n  guint64 download_size = 0;\n  guint64 installed_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n  if (xa_metadata == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                               \"No xa.metadata in local commit %s ref %s\",\n                               checksum, flatpak_decomposed_get_ref (op->ref));\n  metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));\n  if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n    op->download_size = GUINT64_FROM_BE (download_size);\n  if (g_variant_lookup (commit_metadata, \"xa.installed-size\", \"t\", &installed_size))\n    op->installed_size = GUINT64_FROM_BE (installed_size);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, \"s\", &op->eol);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, \"s\", &op->eol_rebase);\n  return resolve_op_end (self, op, checksum, sideload_path, metadata_bytes, error);\n}", "target": 0}
{"code": "bool OSD::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t       bool& isvalid, CryptoKey& session_key)\n{\n  AuthAuthorizeHandler *authorize_handler = 0;\n  switch (peer_type) {\n  case CEPH_ENTITY_TYPE_MDS:\n  case CEPH_ENTITY_TYPE_OSD:\n  case CEPH_ENTITY_TYPE_MGR:\n    authorize_handler = authorize_handler_cluster_registry->get_handler(protocol);\n    break;\n  default:\n    authorize_handler = authorize_handler_service_registry->get_handler(protocol);\n  }\n  if (!authorize_handler) {\n    dout(0) << \"No AuthAuthorizeHandler found for protocol \" << protocol << dendl;\n    isvalid = false;\n    return true;\n  }\n  AuthCapsInfo caps_info;\n  EntityName name;\n  uint64_t global_id;\n  uint64_t auid = CEPH_AUTH_UID_DEFAULT;\n  RotatingKeyRing *keys = monc->rotating_secrets.get();\n  if (keys) {\n    isvalid = authorize_handler->verify_authorizer(\n      cct, keys,\n      authorizer_data, authorizer_reply, name, global_id, caps_info, session_key,\n      &auid);\n  } else {\n    dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n    isvalid = false;\n  }\n  if (isvalid) {\n    Session *s = static_cast<Session *>(con->get_priv());\n    if (!s) {\n      s = new Session(cct);\n      con->set_priv(s->get());\n      s->con = con;\n      dout(10) << \" new session \" << s << \" con=\" << s->con << \" addr=\" << s->con->get_peer_addr() << dendl;\n    }\n    s->entity_name = name;\n    if (caps_info.allow_all)\n      s->caps.set_allow_all();\n    s->auid = auid;\n    if (caps_info.caps.length() > 0) {\n      bufferlist::iterator p = caps_info.caps.begin();\n      string str;\n      try {\n\t::decode(str, p);\n      }\n      catch (buffer::error& e) {\n      }\n      bool success = s->caps.parse(str);\n      if (success)\n\tdout(10) << \" session \" << s << \" \" << s->entity_name << \" has caps \" << s->caps << \" '\" << str << \"'\" << dendl;\n      else\n\tdout(10) << \" session \" << s << \" \" << s->entity_name << \" failed to parse caps '\" << str << \"'\" << dendl;\n    }\n    s->put();\n  }\n  return true;\n}", "target": 1}
{"code": "int FrameLoader::numPendingOrLoadingRequests(bool recurse) const\n{\n    if (!recurse)\n        return m_frame->document()->fetcher()->requestCount();\n    int count = 0;\n    for (Frame* frame = m_frame; frame; frame = frame->tree()->traverseNext(m_frame))\n        count += frame->document()->fetcher()->requestCount();\n    return count;\n}", "target": 0}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n}", "target": 1}
{"code": "void usbredirparser_init(struct usbredirparser *parser_pub,\n    const char *version, uint32_t *caps, int caps_len, int flags)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    struct usb_redir_hello_header hello = { { 0 }, };\n    parser->flags = (flags & ~usbredirparser_fl_no_hello);\n    if (parser->callb.alloc_lock_func) {\n        parser->lock = parser->callb.alloc_lock_func();\n    }\n    snprintf(hello.version, sizeof(hello.version), \"%s\", version);\n    if (caps_len > USB_REDIR_CAPS_SIZE) {\n        caps_len = USB_REDIR_CAPS_SIZE;\n    }\n    memcpy(parser->our_caps, caps, caps_len * sizeof(uint32_t));\n    if (!(flags & usbredirparser_fl_usb_host))\n        usbredirparser_caps_set_cap(parser->our_caps,\n                                    usb_redir_cap_device_disconnect_ack);\n    usbredirparser_verify_caps(parser, parser->our_caps, \"our\");\n    if (!(flags & usbredirparser_fl_no_hello))\n        usbredirparser_queue(parser_pub, usb_redir_hello, 0, &hello,\n                             (uint8_t *)parser->our_caps,\n                             USB_REDIR_CAPS_SIZE * sizeof(uint32_t));\n}", "target": 0}
{"code": "static inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}", "target": 1}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "PassRefPtr<Attr> Element::setAttributeNode(Attr* attrNode, ExceptionCode& ec)\n{\n    if (!attrNode) {\n        ec = TYPE_MISMATCH_ERR;\n        return 0;\n    }\n    RefPtr<Attr> oldAttrNode = attrIfExists(attrNode->qualifiedName());\n    if (oldAttrNode.get() == attrNode)\n        return attrNode; \n    if (attrNode->ownerElement()) {\n        ec = INUSE_ATTRIBUTE_ERR;\n        return 0;\n    }\n    synchronizeAllAttributes();\n    UniqueElementData* elementData = ensureUniqueElementData();\n    size_t index = elementData->getAttributeItemIndex(attrNode->qualifiedName());\n    if (index != notFound) {\n        if (oldAttrNode)\n            detachAttrNodeFromElementWithValue(oldAttrNode.get(), elementData->attributeItem(index)->value());\n        else\n            oldAttrNode = Attr::create(document(), attrNode->qualifiedName(), elementData->attributeItem(index)->value());\n    }\n     setAttributeInternal(index, attrNode->qualifiedName(), attrNode->value(), NotInSynchronizationOfLazyAttribute);\n     attrNode->attachToElement(this);\n     ensureAttrNodeListForElement(this)->append(attrNode);\n     return oldAttrNode.release();\n}", "target": 1}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 1}
{"code": "static int neigh_fill_info(struct sk_buff *skb, struct neighbour *n,\n\t\t\t   u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tunsigned long now = jiffies;\n\tunsigned char *b = skb->tail;\n\tstruct nda_cacheinfo ci;\n\tint locked = 0;\n\tu32 probes;\n\tstruct nlmsghdr *nlh = NLMSG_NEW(skb, pid, seq, event,\n\t\t\t\t\t sizeof(struct ndmsg), flags);\n\tstruct ndmsg *ndm = NLMSG_DATA(nlh);\n\tndm->ndm_family\t = n->ops->family;\n\tndm->ndm_flags\t = n->flags;\n\tndm->ndm_type\t = n->type;\n\tndm->ndm_ifindex = n->dev->ifindex;\n\tRTA_PUT(skb, NDA_DST, n->tbl->key_len, n->primary_key);\n\tread_lock_bh(&n->lock);\n\tlocked\t\t = 1;\n\tndm->ndm_state\t = n->nud_state;\n\tif (n->nud_state & NUD_VALID)\n\t\tRTA_PUT(skb, NDA_LLADDR, n->dev->addr_len, n->ha);\n\tci.ndm_used\t = now - n->used;\n\tci.ndm_confirmed = now - n->confirmed;\n\tci.ndm_updated\t = now - n->updated;\n\tci.ndm_refcnt\t = atomic_read(&n->refcnt) - 1;\n\tprobes = atomic_read(&n->probes);\n\tread_unlock_bh(&n->lock);\n\tlocked\t\t = 0;\n\tRTA_PUT(skb, NDA_CACHEINFO, sizeof(ci), &ci);\n\tRTA_PUT(skb, NDA_PROBES, sizeof(probes), &probes);\n\tnlh->nlmsg_len\t = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tif (locked)\n\t\tread_unlock_bh(&n->lock);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err = -EIO;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tsymlink = bh->b_data;\n\t}\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\nout:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}", "target": 1}
{"code": "set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n{\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n    double rounded;\n    if (code == gs_error_undefinedresult) {\n        pdist->x = pdist->y = 0;\n    } else if (code < 0)\n        return code;\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  PixelPacket\n    *color_1,\n    *color_2;\n  ssize_t\n    intensity;\n  color_1=(PixelPacket *) x;\n  color_2=(PixelPacket *) y;\n  intensity=(ssize_t) PixelPacketIntensity(color_1)-\n    (ssize_t) PixelPacketIntensity(color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": "_dbus_printf_string_upper_bound (const char *format,\n                                 va_list     args)\n{\n  char static_buf[1024];\n  int bufsize = sizeof (static_buf);\n  int len;\n  len = vsnprintf (static_buf, bufsize, format, args);\n  if (len == bufsize)\n    {\n      if (vsnprintf (static_buf, 1, format, args) == 1)\n        len = -1;\n    }\n  while (len < 0)\n    {\n      char *buf;\n      bufsize *= 2;\n      buf = dbus_malloc (bufsize);\n      if (buf == NULL)\n        return -1;\n      len = vsnprintf (buf, bufsize, format, args);\n      dbus_free (buf);\n      if (len == bufsize)\n        len = -1;\n    }\n  return len;\n}", "target": 1}
{"code": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldub_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "static int __io_sync_cancel(struct io_uring_task *tctx,\n\t\t\t    struct io_cancel_data *cd, int fd)\n{\n\tstruct io_ring_ctx *ctx = cd->ctx;\n\tif ((cd->flags & IORING_ASYNC_CANCEL_FD) &&\n\t    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) {\n\t\tunsigned long file_ptr;\n\t\tif (unlikely(fd > ctx->nr_user_files))\n\t\t\treturn -EBADF;\n\t\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\t\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\t\tcd->file = (struct file *) (file_ptr & FFS_MASK);\n\t\tif (!cd->file)\n\t\t\treturn -EBADF;\n\t}\n\treturn __io_async_cancel(cd, tctx, 0);\n}", "target": 1}
{"code": "ssh_scp ssh_scp_new(ssh_session session, int mode, const char *location)\n{\n    ssh_scp scp = NULL;\n    if (session == NULL) {\n        goto error;\n    }\n    scp = (ssh_scp)calloc(1, sizeof(struct ssh_scp_struct));\n    if (scp == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n    if ((mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_WRITE &&\n        (mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_READ)\n    {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Invalid mode %d for ssh_scp_new()\", mode);\n        goto error;\n    }\n    scp->location = strdup(location);\n    if (scp->location == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n    scp->session = session;\n    scp->mode = mode & ~SSH_SCP_RECURSIVE;\n    scp->recursive = (mode & SSH_SCP_RECURSIVE) != 0;\n    scp->channel = NULL;\n    scp->state = SSH_SCP_NEW;\n    return scp;\nerror:\n    ssh_scp_free(scp);\n    return NULL;\n}", "target": 1}
{"code": " void HTMLImportsController::Dispose() {\n  for (const auto& loader : loaders_)\n    loader->Dispose();\n  loaders_.clear();\n   if (root_) {\n     root_->Dispose();\n    root_.Clear();\n  }\n}", "target": 1}
{"code": "static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XRSTORS\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XRSTOR\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}", "target": 1}
{"code": "static int n_tty_receive_buf2(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      char *fp, int count)\n{\n\treturn n_tty_receive_buf_common(tty, cp, fp, count, 1);\n}", "target": 0}
{"code": "int BN_is_odd(const BIGNUM *a)\n{\n    return (a->top > 0) && (a->d[0] & 1);\n}", "target": 0}
{"code": "MagickPrivate VirtualPixelMethod SetPixelCacheVirtualMethod(Image *image,\n  const VirtualPixelMethod virtual_pixel_method,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  VirtualPixelMethod\n    method;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  method=cache_info->virtual_pixel_method;\n  cache_info->virtual_pixel_method=virtual_pixel_method;\n  if ((image->columns != 0) && (image->rows != 0))\n    switch (virtual_pixel_method)\n    {\n      case BackgroundVirtualPixelMethod:\n      {\n        if ((image->background_color.alpha_trait != UndefinedPixelTrait) &&\n            (image->alpha_trait == UndefinedPixelTrait))\n          (void) SetCacheAlphaChannel(image,OpaqueAlpha,exception);\n        if ((IsPixelInfoGray(&image->background_color) == MagickFalse) &&\n            (IsGrayColorspace(image->colorspace) != MagickFalse))\n          (void) SetImageColorspace(image,sRGBColorspace,exception);\n        break;\n      }\n      case TransparentVirtualPixelMethod:\n      {\n        if (image->alpha_trait == UndefinedPixelTrait)\n          (void) SetCacheAlphaChannel(image,OpaqueAlpha,exception);\n        break;\n      }\n      default:\n        break;\n    }\n  return(method);\n}", "target": 0}
{"code": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\nerr_out:\n\tkfree(rule_buf);\n\treturn ret;\n}", "target": 1}
{"code": "R_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) {\n#if __UNIX__\n\tint ret, flags;\n#endif\n\tif (!s) {\n\t\treturn false;\n\t}\n#if __UNIX__\n\tflags = fcntl (s->fd, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn false;\n\t}\n\tret = fcntl (s->fd, F_SETFL, block?\n\t\t\t(flags & ~O_NONBLOCK):\n\t\t\t(flags | O_NONBLOCK));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n#elif __WINDOWS__\n\tioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);\n#endif\n\tif (sec > 0 || usec > 0) {\n\t\tstruct timeval tv = {0};\n\t\ttv.tv_sec = sec;\n\t\ttv.tv_usec = usec;\n\t\tif (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "    **/\n    CImg<T>& shift_object3d() {\n      if (_height!=3 || _depth>1 || _spectrum>1)\n        throw CImgInstanceException(_cimg_instance\n                                    \"shift_object3d(): Instance is not a set of 3d vertices.\",\n                                    cimg_instance);\n      CImg<T> xcoords = get_shared_row(0), ycoords = get_shared_row(1), zcoords = get_shared_row(2);\n      float\n        xm, xM = (float)xcoords.max_min(xm),\n        ym, yM = (float)ycoords.max_min(ym),\n        zm, zM = (float)zcoords.max_min(zm);\n      xcoords-=(xm + xM)/2; ycoords-=(ym + yM)/2; zcoords-=(zm + zM)/2;\n      return *this;", "target": 0}
{"code": "update_notification_create(struct update_notification **file)\n{\n\tstruct update_notification *tmp;\n\tstruct deltas_head *list;\n\tint error;\n\ttmp = malloc(sizeof(struct update_notification));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tlist = NULL;\n\terror = deltas_head_create(&list);\n\tif (error) {\n\t\tfree(tmp);\n\t\treturn error;\n\t}\n\ttmp->deltas_list = list;\n\ttmp->uri = NULL;\n\tglobal_data_init(&tmp->global_data);\n\tdoc_data_init(&tmp->snapshot);\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "static int pptp_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *usockaddr_len, int peer)\n{\n\tint len = sizeof(struct sockaddr_pppox);\n\tstruct sockaddr_pppox sp;\n\tmemset(&sp.sa_addr, 0, sizeof(sp.sa_addr));\n\tsp.sa_family    = AF_PPPOX;\n\tsp.sa_protocol  = PX_PROTO_PPTP;\n\tsp.sa_addr.pptp = pppox_sk(sock->sk)->proto.pptp.src_addr;\n\tmemcpy(uaddr, &sp, len);\n\t*usockaddr_len = len;\n\treturn 0;\n}", "target": 0}
{"code": "static void early_init_amd(struct cpuinfo_x86 *c)\n{\n\tearly_init_amd_mc(c);\n\tif (c->x86_power & (1 << 8)) {\n\t\tset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\n\t\tset_cpu_cap(c, X86_FEATURE_NONSTOP_TSC);\n\t\tif (!check_tsc_unstable())\n\t\t\tsched_clock_stable = 1;\n\t}\n#ifdef CONFIG_X86_64\n\tset_cpu_cap(c, X86_FEATURE_SYSCALL32);\n#else\n\tif (c->x86 == 5)\n\t\tif (c->x86_model == 13 || c->x86_model == 9 ||\n\t\t    (c->x86_model == 8 && c->x86_mask >= 8))\n\t\t\tset_cpu_cap(c, X86_FEATURE_K6_MTRR);\n#endif\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_PCI)\n\tif (cpu_has_apic && c->x86 >= 0xf) {\n\t\tunsigned int val;\n\t\tval = read_pci_config(0, 24, 0, 0x68);\n\t\tif ((val & ((1 << 17) | (1 << 18))) == ((1 << 17) | (1 << 18)))\n\t\t\tset_cpu_cap(c, X86_FEATURE_EXTD_APICID);\n\t}\n#endif\n}", "target": 1}
{"code": "EntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}", "target": 1}
{"code": "static void sev_es_sync_from_ghcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tstruct ghcb *ghcb = svm->ghcb;\n\tu64 exit_code;\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs[VCPU_REGS_RAX] = ghcb_get_rax_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RBX] = ghcb_get_rbx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RCX] = ghcb_get_rcx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RDX] = ghcb_get_rdx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RSI] = ghcb_get_rsi_if_valid(ghcb);\n\tsvm->vmcb->save.cpl = ghcb_get_cpl_if_valid(ghcb);\n\tif (ghcb_xcr0_is_valid(ghcb)) {\n\t\tvcpu->arch.xcr0 = ghcb_get_xcr0(ghcb);\n\t\tkvm_update_cpuid_runtime(vcpu);\n\t}\n\texit_code = ghcb_get_sw_exit_code(ghcb);\n\tcontrol->exit_code = lower_32_bits(exit_code);\n\tcontrol->exit_code_hi = upper_32_bits(exit_code);\n\tcontrol->exit_info_1 = ghcb_get_sw_exit_info_1(ghcb);\n\tcontrol->exit_info_2 = ghcb_get_sw_exit_info_2(ghcb);\n\tmemset(ghcb->save.valid_bitmap, 0, sizeof(ghcb->save.valid_bitmap));\n}", "target": 0}
{"code": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_int n;\n  mrb_value val;\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  };\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}", "target": 1}
{"code": "unsigned LibRaw::get4()\n{\n  uchar str[4] = {0xff, 0xff, 0xff, 0xff};\n  fread(str, 1, 4, ifp);\n  return sget4(str);\n}", "target": 0}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static void default_local_infile_end(void *ptr)\n{\n  default_local_infile_data *data= (default_local_infile_data *) ptr;\n  if (data)\t\t\t\t\t\n  {\n    if (data->fd >= 0)\n      my_close(data->fd, MYF(MY_WME));\n    my_free(ptr);\n  }\n}", "target": 0}
{"code": "batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n\tkfree(entry);\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n\t\tkfree_skb(skb_out);\n\t\tskb_out = NULL;\n\t\tgoto free;\n\t}\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\nfree:\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}", "target": 1}
{"code": "USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n{\n    USHORT Res;\n    auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n                                       GetDataLength(), __FUNCTION__);\n    if (ppr.ipStatus != ppresNotIP)\n    {\n        Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));\n        Res = 0;\n    }\n    return Res;\n}", "target": 1}
{"code": "yang_fill_include(struct lys_module *trg, char *value, struct lys_include *inc,\n                  struct unres_schema *unres)\n{\n    const char *str;\n    int rc;\n    int ret = 0;\n    str = lydict_insert_zc(trg->ctx, value);\n    rc = lyp_check_include(trg, str, inc, unres);\n    if (!rc) {\n        memcpy(&trg->inc[trg->inc_size], inc, sizeof *inc);\n        if (yang_check_ext_instance(trg, &trg->inc[trg->inc_size].ext, trg->inc[trg->inc_size].ext_size,\n                                    &trg->inc[trg->inc_size], unres)) {\n            ret = -1;\n        }\n        trg->inc_size++;\n    } else if (rc == -1) {\n        lys_extension_instances_free(trg->ctx, inc->ext, inc->ext_size, NULL);\n        ret = -1;\n    }\n    lydict_remove(trg->ctx, str);\n    return ret;\n}", "target": 0}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": "int MockNetworkTransaction::RestartWithAuth(\n    const AuthCredentials& credentials,\n    const CompletionCallback& callback) {\n  if (!IsReadyToRestartForAuth())\n     return ERR_FAILED;\n   HttpRequestInfo auth_request_info = *request_;\n  auth_request_info.extra_headers.AddHeaderFromString(\"Authorization: Bar\");\n  return StartInternal(&auth_request_info, callback, BoundNetLog());\n}", "target": 1}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "deltas_head_values_set(struct deltas_head *deltas)\n{\n\treturn deltas->len == deltas->capacity;\n}", "target": 1}
{"code": "static size_t hash_str(const void *ptr)\n{\n    const char *str = (const char *)ptr;\n    size_t hash = 5381;\n    size_t c;\n    while((c = (size_t)*str))\n    {\n        hash = ((hash << 5) + hash) + c;\n        str++;\n    }\n    return hash;\n}", "target": 1}
{"code": "flatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}", "target": 1}
{"code": "  static Config::DecodedResourcesWrapper decodeResources(\n      const Protobuf::RepeatedPtrField<envoy::service::discovery::v3::Resource>& resources,\n      const std::string& name_field = \"name\") {\n    Config::DecodedResourcesWrapper decoded_resources;\n    TestOpaqueResourceDecoderImpl<MessageType> resource_decoder(name_field);\n    for (const auto& resource : resources) {\n      decoded_resources.owned_resources_.emplace_back(\n          new Config::DecodedResourceImpl(resource_decoder, resource));\n      decoded_resources.refvec_.emplace_back(*decoded_resources.owned_resources_.back());\n    }\n    return decoded_resources;\n  }", "target": 0}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 1}
{"code": "void Cache::dumpLRULists(bool includeLive) const\n{\n    printf(\"LRU-SP lists in eviction order (Kilobytes decoded, Kilobytes encoded, Access count, Referenced):\\n\");\n    int size = m_allResources.size();\n    for (int i = size - 1; i >= 0; i--) {\n        printf(\"\\n\\nList %d: \", i);\n        CachedResource* current = m_allResources[i].m_tail;\n        while (current) {\n            CachedResource* prev = current->m_prevInAllResourcesList;\n            if (includeLive || !current->referenced())\n                printf(\"(%.1fK, %.1fK, %uA, %dR); \", current->decodedSize() / 1024.0f, current->encodedSize() / 1024.0f, current->accessCount(), current->referenced());\n            current = prev;\n        }\n    }\n}", "target": 0}
{"code": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tint tmp;\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\tuml_exitcode = tmp;\n\treturn count;\n}", "target": 1}
{"code": "TEST(QuantizedUInt8PoolingOpTest, MaxPoolActivationRelu1) {\n  QuantizedPoolingOpModel m(\n      BuiltinOperator_MAX_POOL_2D,\n      {TensorType_UINT8, {1, 2, 4, 1}, -15.9375, 15.9375},\n      2, 2,\n      {TensorType_UINT8, {}, -15.9375, 15.9375}, Padding_VALID, 2, 2,\n      ActivationFunctionType_RELU_N1_TO_1);\n  m.SetInput({\n      -1.7, -6, 2, 4,  \n      -3, -2, -10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({-1.0, 1.0})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({120, 136}));\n  m.SetInput({\n      0, -6, -0.2, -0.4,    \n      -3, -2, 0.75, -0.99,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({0.0, 0.75})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({128, 134}));\n}", "target": 0}
{"code": "static int adjust_tp(struct atm_trafprm *tp, unsigned char aal)\n{\n\tint max_sdu;\n\tif (!tp->traffic_class)\n\t\treturn 0;\n\tswitch (aal) {\n\tcase ATM_AAL0:\n\t\tmax_sdu = ATM_CELL_SIZE-1;\n\t\tbreak;\n\tcase ATM_AAL34:\n\t\tmax_sdu = ATM_MAX_AAL34_PDU;\n\t\tbreak;\n\tdefault:\n\t\tpr_warning(\"AAL problems ... (%d)\\n\", aal);\n\tcase ATM_AAL5:\n\t\tmax_sdu = ATM_MAX_AAL5_PDU;\n\t}\n\tif (!tp->max_sdu)\n\t\ttp->max_sdu = max_sdu;\n\telse if (tp->max_sdu > max_sdu)\n\t\treturn -EINVAL;\n\tif (!tp->max_cdv)\n\t\ttp->max_cdv = ATM_MAX_CDV;\n\treturn 0;\n}", "target": 0}
{"code": "static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\t\tcb->args[0] = 1;\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    CString sModPath, sTmp;\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}", "target": 0}
{"code": "void fib6_run_gc(unsigned long expires, struct net *net)\n{\n\tif (expires != ~0UL) {\n\t\tspin_lock_bh(&fib6_gc_lock);\n\t\tgc_args.timeout = expires ? (int)expires :\n\t\t\tnet->ipv6.sysctl.ip6_rt_gc_interval;\n\t} else {\n\t\tif (!spin_trylock_bh(&fib6_gc_lock)) {\n\t\t\tmod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);\n\t\t\treturn;\n\t\t}\n\t\tgc_args.timeout = net->ipv6.sysctl.ip6_rt_gc_interval;\n\t}\n\tgc_args.more = icmp6_dst_gc();\n\tfib6_clean_all(net, fib6_age, 0, NULL);\n\tif (gc_args.more)\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  round_jiffies(jiffies\n\t\t\t\t\t+ net->ipv6.sysctl.ip6_rt_gc_interval));\n\telse\n\t\tdel_timer(&net->ipv6.ip6_fib_timer);\n\tspin_unlock_bh(&fib6_gc_lock);\n}", "target": 0}
{"code": "void RGWGetObjTags_ObjStore_S3::send_response_data(bufferlist& bl)\n{\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n  s->formatter->open_object_section_in_ns(\"Tagging\", XMLNS_AWS_S3);\n  s->formatter->open_object_section(\"TagSet\");\n  if (has_tags){\n    RGWObjTagSet_S3 tagset;\n    auto iter = bl.cbegin();\n    try {\n      tagset.decode(iter);\n    } catch (buffer::error& err) {\n      ldout(s->cct,0) << \"ERROR: caught buffer::error, couldn't decode TagSet\" << dendl;\n      op_ret= -EIO;\n      return;\n    }\n    tagset.dump_xml(s->formatter);\n  }\n  s->formatter->close_section();\n  s->formatter->close_section();\n  rgw_flush_formatter_and_reset(s, s->formatter);\n}", "target": 0}
{"code": "bool IsIDNComponentInSingleScript(const char16* str, int str_len) {\n  UScriptCode first_script = USCRIPT_INVALID_CODE;\n  bool is_first = true;\n  int i = 0;\n  while (i < str_len) {\n    unsigned code_point;\n    U16_NEXT(str, i, str_len, code_point);\n    UErrorCode err = U_ZERO_ERROR;\n    UScriptCode cur_script = uscript_getScript(code_point, &err);\n    if (err != U_ZERO_ERROR)\n      return false;  \n    cur_script = NormalizeScript(cur_script);\n    if (is_first && cur_script != USCRIPT_COMMON) {\n      first_script = cur_script;\n      is_first = false;\n    } else {\n      if (cur_script != USCRIPT_COMMON && cur_script != first_script)\n        return false;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "int FoFiTrueType::mapNameToGID(char *name) {\n  if (!nameToGID) {\n    return 0;\n  }\n  return nameToGID->lookupInt(name);\n}", "target": 0}
{"code": "void __skb_tstamp_tx(struct sk_buff *orig_skb,\n\t\t     struct skb_shared_hwtstamps *hwtstamps,\n\t\t     struct sock *sk, int tstype)\n{\n\tstruct sk_buff *skb;\n\tbool tsonly;\n\tif (!sk)\n\t\treturn;\n\ttsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY;\n\tif (!skb_may_tx_timestamp(sk, tsonly))\n\t\treturn;\n\tif (tsonly) {\n#ifdef CONFIG_INET\n\t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&\n\t\t    sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tskb = tcp_get_timestamping_opt_stats(sk);\n\t\telse\n#endif\n\t\t\tskb = alloc_skb(0, GFP_ATOMIC);\n\t} else {\n\t\tskb = skb_clone(orig_skb, GFP_ATOMIC);\n\t}\n\tif (!skb)\n\t\treturn;\n\tif (tsonly) {\n\t\tskb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags;\n\t\tskb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey;\n\t}\n\tif (hwtstamps)\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\telse\n\t\tskb->tstamp = ktime_get_real();\n\t__skb_complete_tx_timestamp(skb, sk, tstype);", "target": 1}
{"code": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}", "target": 1}
{"code": "get_stdinput(char *(*fn_readline)(const char *), void(*fn_addhist)(const char *))\n{\nint i;\ngstring * g = NULL;\nif (!fn_readline) { printf(\"> \"); fflush(stdout); }\nfor (i = 0;; i++)\n  {\n  uschar buffer[1024];\n  uschar *p, *ss;\n  #ifdef USE_READLINE\n  char *readline_line = NULL;\n  if (fn_readline != NULL)\n    {\n    if ((readline_line = fn_readline((i > 0)? \"\":\"> \")) == NULL) break;\n    if (*readline_line != 0 && fn_addhist != NULL) fn_addhist(readline_line);\n    p = US readline_line;\n    }\n  else\n  #endif\n    {\n    if (Ufgets(buffer, sizeof(buffer), stdin) == NULL) break;\n    p = buffer;\n    }\n  ss = p + (int)Ustrlen(p);\n  while (ss > p && isspace(ss[-1])) ss--;\n  if (i > 0)\n    {\n    while (p < ss && isspace(*p)) p++;   \n    }\n  g = string_catn(g, p, ss - p);\n  #ifdef USE_READLINE\n  if (fn_readline) free(readline_line);\n  #endif\n  if (ss == p || g->s[g->ptr-1] != '\\\\')\n    break;\n  --g->ptr;\n  (void) string_from_gstring(g);\n  }\nif (!g) printf(\"\\n\");\nreturn string_from_gstring(g);\n}", "target": 0}
{"code": "void FIFOSampleBuffer::setChannels(int numChannels)\n{\n    uint usedBytes;\n    assert(numChannels > 0);\n    usedBytes = channels * samplesInBuffer;\n    channels = (uint)numChannels;\n    samplesInBuffer = usedBytes / channels;\n}", "target": 1}
{"code": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       n * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int tsize = pipe->ring_size - t;\n\t\t\tif (h > 0)\n\t\t\t\tmemcpy(bufs + tsize, pipe->bufs,\n\t\t\t\t       h * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       tsize * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\thead = n;\n\ttail = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}", "target": 1}
{"code": "agoo_http_init() {\n    const char\t**kp = header_keys;\n    memset(&key_cache, 0, sizeof(struct _cache));\n    for (; NULL != *kp; kp++) {\n\tkey_set(*kp);\n    }\n}", "target": 1}
{"code": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n    return nonce->references;\n}", "target": 1}
{"code": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int adpt_reset(struct scsi_cmnd* cmd)\n{\n\tint rc;\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = __adpt_reset(cmd);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\treturn rc;\n}", "target": 1}
{"code": "static int install_permanent_handler(int num_cpus, uintptr_t smbase,\n\t\t\t\t\tsize_t smsize, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = num_cpus,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 1);\n\tprintk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);\n\tif (smm_load_module((void *)smbase, smsize, &smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "de265_error decoder_context::decode(int* more)\n{\n  decoder_context* ctx = this;\n  if (ctx->nal_parser.get_NAL_queue_length() == 0 &&\n      (ctx->nal_parser.is_end_of_stream() || ctx->nal_parser.is_end_of_frame()) &&\n      ctx->image_units.empty()) {\n    ctx->dpb.flush_reorder_buffer();\n    if (more) { *more = ctx->dpb.num_pictures_in_output_queue(); }\n    return DE265_OK;\n  }\n  if (ctx->nal_parser.is_end_of_stream() == false &&\n      ctx->nal_parser.is_end_of_frame() == false &&\n      ctx->nal_parser.get_NAL_queue_length() == 0) {\n    if (more) { *more=1; }\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  if (!ctx->dpb.has_free_dpb_picture(false)) {\n    if (more) *more = 1;\n    return DE265_ERROR_IMAGE_BUFFER_FULL;\n  }\n  de265_error err = DE265_OK;\n  bool did_work = false;\n  if (ctx->nal_parser.get_NAL_queue_length()) { \n    NAL_unit* nal = ctx->nal_parser.pop_from_NAL_queue();\n    assert(nal);\n    err = ctx->decode_NAL(nal);\n    did_work=true;\n  }\n  else if (ctx->nal_parser.is_end_of_frame() == true &&\n      ctx->image_units.empty()) {\n    if (more) { *more=1; }\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  else {\n    err = decode_some(&did_work);\n  }\n  if (more) {\n    *more = (err==DE265_OK && did_work);\n  }\n  return err;\n}", "target": 0}
{"code": "static TPM_RESULT SWTPM_NVRAM_GetFilenameForName(char *filename,        \n                                                 size_t bufsize,\n                                                 uint32_t tpm_number,\n                                                 const char *name,      \n                                                 bool is_tempfile)      \n{\n    TPM_RESULT res = TPM_SUCCESS;\n    int n;\n    const char *suffix = \"\";\n    TPM_DEBUG(\" SWTPM_NVRAM_GetFilenameForName: For name %s\\n\", name);\n    switch (tpmversion) {\n    case TPMLIB_TPM_VERSION_1_2:\n        break;\n    case TPMLIB_TPM_VERSION_2:\n        suffix = \"2\";\n        break;\n    }\n    if (is_tempfile) {\n        n = snprintf(filename, bufsize, \"%s/TMP%s-%02lx.%s\",\n                     state_directory, suffix, (unsigned long)tpm_number, name);\n    } else {\n        n = snprintf(filename, bufsize, \"%s/tpm%s-%02lx.%s\",\n                     state_directory, suffix, (unsigned long)tpm_number, name);\n    }\n    if ((size_t)n > bufsize) {\n        res = TPM_FAIL;\n    }\n    TPM_DEBUG(\"  SWTPM_NVRAM_GetFilenameForName: File name %s\\n\", filename);\n    return res;\n}", "target": 0}
{"code": "find_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"", "target": 1}
{"code": "const char *GetClipboardText(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return glfwGetClipboardString(CORE.Window.handle);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script_string(\"navigator.clipboard.readText() \\\n        .then(text => { document.getElementById('clipboard').innerText = text; console.log('Pasted content: ', text); }) \\\n        .catch(err => { console.error('Failed to read clipboard contents: ', err); });\"\n    );\n    return NULL;\n#endif\n    return NULL;\n}", "target": 1}
{"code": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "int vfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 0);\n\tif (error)\n\t\treturn error;\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (d_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error)\n\t\t\t\tdont_mount(dentry);\n\t\t}\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(dentry->d_inode);\n\t\td_delete(dentry);\n\t}\n\treturn error;\n}", "target": 0}
{"code": "GopherStateData::~GopherStateData()\n{\n    if (entry)\n        entry->unlock(\"gopherState\");\n    if (buf)\n        memFree(buf, MEM_4K_BUF);\n}", "target": 1}
{"code": "static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}", "target": 0}
{"code": "static int tls12_sigalg_allowed(SSL *s, int op, const unsigned char *ptmp)\n\t{\n\tconst tls12_hash_info *hinf = tls12_get_hash_info(ptmp[0]);\n\tif (!hinf || !hinf->mfunc)\n\t\treturn 0;\n\tif (tls12_get_pkey_idx(ptmp[1]) == -1)\n\t\treturn 0;\n\treturn ssl_security(s, op, hinf->secbits, hinf->nid, (void *)ptmp);\n\t}", "target": 0}
{"code": "int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b)\n{\n    int result = -1;\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n     case V_ASN1_OBJECT:\n         result = OBJ_cmp(a->value.object, b->value.object);\n         break;\n     case V_ASN1_NULL:\n         result = 0;             \n         break;\n    case V_ASN1_NEG_ENUMERATED:\n    case V_ASN1_BIT_STRING:\n    case V_ASN1_OCTET_STRING:\n    case V_ASN1_SEQUENCE:\n    case V_ASN1_SET:\n    case V_ASN1_NUMERICSTRING:\n    case V_ASN1_PRINTABLESTRING:\n    case V_ASN1_T61STRING:\n    case V_ASN1_VIDEOTEXSTRING:\n    case V_ASN1_IA5STRING:\n    case V_ASN1_UTCTIME:\n    case V_ASN1_GENERALIZEDTIME:\n    case V_ASN1_GRAPHICSTRING:\n    case V_ASN1_VISIBLESTRING:\n    case V_ASN1_GENERALSTRING:\n    case V_ASN1_UNIVERSALSTRING:\n    case V_ASN1_BMPSTRING:\n    case V_ASN1_UTF8STRING:\n    case V_ASN1_OTHER:\n    default:\n        result = ASN1_STRING_cmp((ASN1_STRING *)a->value.ptr,\n                                 (ASN1_STRING *)b->value.ptr);\n        break;\n    }\n    return result;\n}", "target": 1}
{"code": " void AppCacheGroup::RemoveCache(AppCache* cache) {\n   DCHECK(cache->associated_hosts().empty());\n   if (cache == newest_complete_cache_) {\n    CancelUpdate();\n     AppCache* tmp_cache = newest_complete_cache_;\n     newest_complete_cache_ = nullptr;\n     tmp_cache->set_owning_group(nullptr);  \n   } else {\n     scoped_refptr<AppCacheGroup> protect(this);\n    Caches::iterator it =\n        std::find(old_caches_.begin(), old_caches_.end(), cache);\n    if (it != old_caches_.end()) {\n      AppCache* tmp_cache = *it;\n      old_caches_.erase(it);\n      tmp_cache->set_owning_group(nullptr);  \n    }\n    if (!is_obsolete() && old_caches_.empty() &&\n        !newly_deletable_response_ids_.empty()) {\n      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);\n      newly_deletable_response_ids_.clear();\n    }\n  }\n}", "target": 1}
{"code": "bool ImageIsJPEG( String const& filename ) {\n   try {\n      JpegInput jpeg( filename );\n   } catch( ... ) {\n      return false;\n   }\n   return true;\n}", "target": 1}
{"code": " */\nstatic xmlNodePtr\nxmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                              xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL) {\n        cur = ctxt->context->node;\n        if (cur == NULL)\n            return (NULL);\n        if (cur->type == XML_NAMESPACE_DECL)\n            return (NULL);\n        ctxt->ancestor = cur->parent;\n    }\n    if (cur->type == XML_NAMESPACE_DECL)\n        return(NULL);\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;", "target": 0}
{"code": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n    *passptr = NULL;\n}", "target": 1}
{"code": "struct file *fget(unsigned int fd)\n{\n\treturn __fget(fd, FMODE_PATH, 1);\n}", "target": 0}
{"code": "static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\treturn count;\n}", "target": 1}
{"code": "static void *_clua_allocator(void *ud, void *ptr, size_t osize, size_t nsize)\n{\n    CLua *cl = static_cast<CLua *>(ud);\n    cl->memory_used += nsize - osize;\n    if (nsize > osize && cl->memory_used >= CLUA_MAX_MEMORY_USE * 1024\n        && cl->mixed_call_depth)\n    {\n        return nullptr;\n    }\n    if (!nsize)\n    {\n        free(ptr);\n        return nullptr;\n    }\n    else\n        return realloc(ptr, nsize);\n}", "target": 0}
{"code": "static void do_viewlog(HttpRequest req, HttpResponse res) {\n        if (is_readonly(req)) {\n                send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                return;\n        }\n        do_head(res, \"_viewlog\", \"View log\", 100);\n        if ((Run.flags & Run_Log) && ! (Run.flags & Run_UseSyslog)) {\n                FILE *f = fopen(Run.files.log, \"r\");\n                if (f) {\n                        size_t n;\n                        char buf[512];\n                        StringBuffer_append(res->outputbuffer, \"<br><p><form><textarea cols=120 rows=30 readonly>\");\n                        while ((n = fread(buf, sizeof(char), sizeof(buf) - 1, f)) > 0) {\n                                buf[n] = 0;\n                                StringBuffer_append(res->outputbuffer, \"%s\", buf);\n                        }\n                        fclose(f);\n                        StringBuffer_append(res->outputbuffer, \"</textarea></form>\");\n                } else {\n                        StringBuffer_append(res->outputbuffer, \"Error opening logfile: %s\", STRERROR);\n                }\n        } else {\n                StringBuffer_append(res->outputbuffer,\n                                    \"<b>Cannot view logfile:</b><br>\");\n                if (! (Run.flags & Run_Log))\n                        StringBuffer_append(res->outputbuffer, \"Monit was started without logging\");\n                else\n                        StringBuffer_append(res->outputbuffer, \"Monit uses syslog\");\n        }\n        do_foot(res);\n}", "target": 1}
{"code": "nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(1);\t\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\t*p++ = cpu_to_be32(1);\t\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}", "target": 1}
{"code": "static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_alloc(len, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n      if (jsvHasChildren(parent)) {\n        if (jsvIsArray(parent)) {\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}", "target": 1}
{"code": "test_js (void) {\n    GString *result = g_string_new(\"\");\n    parse_cmd_line(\"js ('x' + 345).toUpperCase()\", result);\n    g_assert_cmpstr(\"X345\", ==, result->str);\n    uzbl.net.useragent = \"Test useragent\";\n    parse_cmd_line(\"js Uzbl.run('print @useragent').toUpperCase();\", result);\n    g_assert_cmpstr(\"TEST USERAGENT\", ==, result->str);\n    g_string_free(result, TRUE);\n}", "target": 1}
{"code": "int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n    uint8_t *start = pkt;\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            case 0x0:\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            case 0x1:\n                return TM_ECODE_FAILED;\n            default:\n                return TM_ECODE_FAILED;\n        }\n    }\n    if (IP_GET_RAW_VER(start) == 6) {\n        IPV6Hdr *thdr = (IPV6Hdr *)start;\n        if (len ==  IPV6_HEADER_LEN +\n                IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n            if (pq != NULL) {\n                int blen = len - (start - pkt);\n                Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n                                                  DECODE_TUNNEL_IPV6, pq);\n                if (tp != NULL) {\n                    PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                    PacketEnqueue(pq,tp);\n                    StatsIncr(tv, dtv->counter_teredo);\n                    return TM_ECODE_OK;\n                }\n            }\n        }\n        return TM_ECODE_FAILED;\n    }\n    return TM_ECODE_FAILED;\n}", "target": 1}
{"code": "static int copy_verifier_state(struct bpf_verifier_state *dst_state,\n\t\t\t       const struct bpf_verifier_state *src)\n{\n\tstruct bpf_func_state *dst;\n\tu32 jmp_sz = sizeof(struct bpf_idx_pair) * src->jmp_history_cnt;\n\tint i, err;\n\tif (dst_state->jmp_history_cnt < src->jmp_history_cnt) {\n\t\tkfree(dst_state->jmp_history);\n\t\tdst_state->jmp_history = kmalloc(jmp_sz, GFP_USER);\n\t\tif (!dst_state->jmp_history)\n\t\t\treturn -ENOMEM;\n\t}\n\tmemcpy(dst_state->jmp_history, src->jmp_history, jmp_sz);\n\tdst_state->jmp_history_cnt = src->jmp_history_cnt;\n\tfor (i = src->curframe + 1; i <= dst_state->curframe; i++) {\n\t\tfree_func_state(dst_state->frame[i]);\n\t\tdst_state->frame[i] = NULL;\n\t}\n\tdst_state->speculative = src->speculative;\n\tdst_state->curframe = src->curframe;\n\tdst_state->active_spin_lock = src->active_spin_lock;\n\tdst_state->branches = src->branches;\n\tdst_state->parent = src->parent;\n\tdst_state->first_insn_idx = src->first_insn_idx;\n\tdst_state->last_insn_idx = src->last_insn_idx;\n\tfor (i = 0; i <= src->curframe; i++) {\n\t\tdst = dst_state->frame[i];\n\t\tif (!dst) {\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\t\t\tif (!dst)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_state->frame[i] = dst;\n\t\t}\n\t\terr = copy_func_state(dst, src->frame[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void HTMLSelectElement::dispatchBlurEvent(Element* newFocusedElement)\n{\n    if (usesMenuList())\n        dispatchChangeEventForMenuList();\n    HTMLFormControlElementWithState::dispatchBlurEvent(newFocusedElement);\n}", "target": 0}
{"code": "int InstanceKlass::find_method_by_name(const Symbol* name, int* end) const {\n  return find_method_by_name(methods(), name, end);\n}", "target": 0}
{"code": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n    unsigned num_sg = *p_num_sg;\n    assert(num_sg <= max_num_sg);\n    while (sz) {\n        hwaddr len = sz;\n        if (num_sg == max_num_sg) {\n            error_report(\"virtio: too many write descriptors in indirect table\");\n            exit(1);\n        }\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}", "target": 1}
{"code": "void Context::onDownstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onDownstreamConnectionClose_) {\n    wasm_->onDownstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) \n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\tumount2(path, MNT_DETACH); \n\t\tgoto domount;\n\t}\n\treturn 0;\ndomount:\n\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}", "target": 1}
{"code": "int dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target)\n{\n\tsvcparam_buffer = dns_add_rr_nested_start(svcparam_buffer, packet, type, DNS_T_HTTPS, domain, ttl);\n\tif (svcparam_buffer == NULL) {\n\t\treturn -1;\n\t}\n\tint target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n\tif (_dns_left_len(&svcparam_buffer->context) < 2 + target_len) {\n\t\treturn -1;\n\t}\n\t_dns_write_short(&svcparam_buffer->context.ptr, priority);\n\tsafe_strncpy((char *)svcparam_buffer->context.ptr, target, target_len);\n\tsvcparam_buffer->context.ptr += target_len;\n\treturn 0;\n}", "target": 1}
{"code": "sysObjectID_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  OID(sysObjectID_oid, 1, 3, 6, 1, 4, 1, 54352);\n  snmp_api_set_oid(varbind, oid, sysObjectID_oid);\n}", "target": 1}
{"code": "static int sanity_check_raw_super(struct super_block *sb,\n\t\t\tstruct f2fs_super_block *raw_super)\n{\n\tunsigned int blocksize;\n\tif (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\tF2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn 1;\n\t}\n\tif (F2FS_BLKSIZE != PAGE_CACHE_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid page_cache_size (%lu), supports only 4KB\\n\",\n\t\t\tPAGE_CACHE_SIZE);\n\t\treturn 1;\n\t}\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid blocksize (%u), supports only 4KB\\n\",\n\t\t\tblocksize);\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "HttpStateData::getMoreRequestBody(MemBuf &buf)\n{\n    if (!flags.chunked_request)\n        return Client::getMoreRequestBody(buf);\n    MemBuf raw;\n    Must(requestBodySource != NULL);\n    if (!requestBodySource->getMoreData(raw))\n        return false; \n    const mb_size_t rawDataSize = raw.contentSize();\n    buf.init(16 + 2 + rawDataSize + 2 + 5, raw.max_capacity);\n    buf.appendf(\"%x\\r\\n\", static_cast<unsigned int>(rawDataSize));\n    buf.append(raw.content(), rawDataSize);\n    buf.append(\"\\r\\n\", 2);\n    Must(rawDataSize > 0); \n    if (receivedWholeRequestBody) {\n        Must(!flags.sentLastChunk);\n        flags.sentLastChunk = true;\n        buf.append(\"0\\r\\n\\r\\n\", 5);\n    }\n    return true;\n}", "target": 0}
{"code": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\tif (slack_runtime <= 0)\n\t\treturn;\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF &&\n\t    cfs_rq->runtime_expires == cfs_b->runtime_expires) {\n\t\tcfs_b->runtime += slack_runtime;\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}", "target": 1}
{"code": "ikev2_vid_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tconst u_char *vid;\n\tint i, len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\tND_PRINT((ndo,\" len=%d vid=\", ntohs(e.len) - 4));\n\tvid = (const u_char *)(ext+1);\n\tlen = ntohs(e.len) - 4;\n\tND_TCHECK2(*vid, len);\n\tfor(i=0; i<len; i++) {\n\t\tif(ND_ISPRINT(vid[i])) ND_PRINT((ndo, \"%c\", vid[i]));\n\t\telse ND_PRINT((ndo, \".\"));\n\t}\n\tif (2 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 1}
{"code": "void rose_start_t2timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t2;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "  bool HasOverflowed() const {\n    StackGuard* stack_guard = isolate_->stack_guard();\n    return (reinterpret_cast<uintptr_t>(this) < stack_guard->climit()) &&\n           stack_guard->IsStackOverflow();\n  }", "target": 1}
{"code": "isdn_ppp_poll(struct file *file, poll_table *wait)\n{\n\tu_int mask;\n\tstruct ippp_buf_queue *bf, *bl;\n\tu_long flags;\n\tstruct ippp_struct *is;\n\tis = file->private_data;\n\tif (is->debug & 0x2)\n\t\tprintk(KERN_DEBUG \"isdn_ppp_poll: minor: %d\\n\",\n\t\t       iminor(file_inode(file)));\n\tpoll_wait(file, &is->wq, wait);\n\tif (!(is->state & IPPP_OPEN)) {\n\t\tif (is->state == IPPP_CLOSEWAIT)\n\t\t\treturn POLLHUP;\n\t\tprintk(KERN_DEBUG \"isdn_ppp: device not open\\n\");\n\t\treturn POLLERR;\n\t}\n\tmask = POLLOUT | POLLWRNORM;\n\tspin_lock_irqsave(&is->buflock, flags);\n\tbl = is->last;\n\tbf = is->first;\n\tif (bf->next != bl || (is->state & IPPP_NOBLOCK)) {\n\t\tis->state &= ~IPPP_NOBLOCK;\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock_irqrestore(&is->buflock, flags);\n\treturn mask;\n}", "target": 0}
{"code": "void rfbClientCleanup(rfbClient* client) {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  int i;\n  for ( i = 0; i < 4; i++ ) {\n    if (client->zlibStreamActive[i] == TRUE ) {\n      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&\n\t  client->zlibStream[i].msg != NULL)\n\trfbClientLog(\"inflateEnd: %s\\n\", client->zlibStream[i].msg);\n    }\n  }\n  if ( client->decompStreamInited == TRUE ) {\n    if (inflateEnd (&client->decompStream) != Z_OK &&\n\tclient->decompStream.msg != NULL)\n      rfbClientLog(\"inflateEnd: %s\\n\", client->decompStream.msg );\n  }\n#endif\n  if (client->ultra_buffer)\n    free(client->ultra_buffer);\n  if (client->raw_buffer)\n    free(client->raw_buffer);\n  FreeTLS(client);\n  while (client->clientData) {\n    rfbClientData* next = client->clientData->next;\n    free(client->clientData);\n    client->clientData = next;\n  }\n  if (client->sock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->sock);\n  if (client->listenSock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->listenSock);\n  free(client->desktopName);\n  free(client->serverHost);\n  if (client->destHost)\n    free(client->destHost);\n  if (client->clientAuthSchemes)\n    free(client->clientAuthSchemes);\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslSecret)\n    free(client->saslSecret);\n#endif \n#ifdef WIN32\n  if(WSACleanup() != 0) {\n      errno=WSAGetLastError();\n      rfbClientErr(\"Could not terminate Windows Sockets: %s\\n\", strerror(errno));\n  }\n#endif\n  free(client);\n}", "target": 1}
{"code": "static int truncate_inline_extent(struct inode *inode,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *found_key,\n\t\t\t\t  const u64 item_end,\n\t\t\t\t  const u64 new_size)\n{\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tint slot = path->slots[0];\n\tstruct btrfs_file_extent_item *fi;\n\tu32 size = (u32)(new_size - found_key->offset);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {\n\t\tloff_t offset = new_size;\n\t\tloff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);\n\t\tbtrfs_release_path(path);\n\t\treturn btrfs_truncate_page(inode, offset, page_end - offset, 0);\n\t}\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\tsize = btrfs_file_extent_calc_inline_size(size);\n\tbtrfs_truncate_item(root, path, size, 1);\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n\treturn 0;\n}", "target": 0}
{"code": "void mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n}", "target": 0}
{"code": "cib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n    timer_expired = TRUE;\n    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n    return TRUE;\n}", "target": 1}
{"code": "int unit_name_to_prefix(const char *n, char **ret) {\n        const char *p;\n        char *s;\n        assert(n);\n        assert(ret);\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n        p = strchr(n, '@');\n        if (!p)\n                p = strrchr(n, '.');\n        assert_se(p);\n        s = strndup(n, p - n);\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 0}
{"code": "static void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tint base;\n\tif (up_flag)\n\t\treturn;\n\tif (value < 10) {\n\t\tbase = 10;\n\t} else {\n\t\tvalue -= 10;\n\t\tbase = 16;\n\t}\n\tif (npadch == -1)\n\t\tnpadch = value;\n\telse\n\t\tnpadch = npadch * base + value;\n}", "target": 1}
{"code": "int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\tmemcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],\n\t\thmacs->shmac_num_idents * sizeof(__u16));\n\tep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +\n\t\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}", "target": 1}
{"code": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\tif (more)\n\t\treturn;\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}", "target": 1}
{"code": "static int vidioc_try_fmt_out(struct file *file, void *priv, struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\tdev = v4l2loopback_getdevice(file);\n\tif (dev->ready_for_capture) {\n\t\tfmt->fmt.pix = dev->pix_format;\n\t} else {\n\t\t__u32 w = fmt->fmt.pix.width;\n\t\t__u32 h = fmt->fmt.pix.height;\n\t\t__u32 pixfmt = fmt->fmt.pix.pixelformat;\n\t\tconst struct v4l2l_format *format = format_by_fourcc(pixfmt);\n\t\tif (w > max_width)\n\t\t\tw = max_width;\n\t\tif (h > max_height)\n\t\t\th = max_height;\n\t\tdprintk(\"trying image %dx%d\\n\", w, h);\n\t\tif (w < 1)\n\t\t\tw = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;\n\t\tif (h < 1)\n\t\t\th = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;\n\t\tif (NULL == format)\n\t\t\tformat = &formats[0];\n\t\tpix_format_set_size(&fmt->fmt.pix, format, w, h);\n\t\tfmt->fmt.pix.pixelformat = format->fourcc;\n\t\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\t\tif (V4L2_FIELD_ANY == fmt->fmt.pix.field)\n\t\t\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\t\tdev->pix_format = fmt->fmt.pix;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "cursor_up(\n    long\tn,\n    int\t\tupd_topline)\t    \n{\n    linenr_T\tlnum;\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\tif (lnum <= 1 || (n >= lnum && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (n >= lnum)\n\t    lnum = 1;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t{\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    while (n--)\n\t    {\n\t\t--lnum;\n\t\tif (lnum <= 1)\n\t\t    break;\n\t\tif (n > 0 || !((State & INSERT) || (fdo_flags & FDO_ALL)))\n\t\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    }\n\t    if (lnum < 1)\n\t\tlnum = 1;\n\t}\n\telse\n#endif\n\t    lnum -= n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n    coladvance(curwin->w_curswant);\n    if (upd_topline)\n\tupdate_topline();\t\n    return OK;\n}", "target": 0}
{"code": "cdf_unpack_header(cdf_header_t *h, char *buf)\n{\n\tsize_t i;\n\tsize_t len = 0;\n\tCDF_UNPACK(h->h_magic);\n\tCDF_UNPACKA(h->h_uuid);\n\tCDF_UNPACK(h->h_revision);\n\tCDF_UNPACK(h->h_version);\n\tCDF_UNPACK(h->h_byte_order);\n\tCDF_UNPACK(h->h_sec_size_p2);\n\tCDF_UNPACK(h->h_short_sec_size_p2);\n\tCDF_UNPACKA(h->h_unused0);\n\tCDF_UNPACK(h->h_num_sectors_in_sat);\n\tCDF_UNPACK(h->h_secid_first_directory);\n\tCDF_UNPACKA(h->h_unused1);\n\tCDF_UNPACK(h->h_min_size_standard_stream);\n\tCDF_UNPACK(h->h_secid_first_sector_in_short_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_short_sat);\n\tCDF_UNPACK(h->h_secid_first_sector_in_master_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tCDF_UNPACK(h->h_master_sat[i]);\n}", "target": 0}
{"code": "static void jsR_setproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Value *value = stackidx(J, -1);\n\tjs_Property *ref;\n\tint k;\n\tint own;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tdouble rawlen = jsV_tonumber(J, value);\n\t\t\tint newlen = jsV_numbertointeger(rawlen);\n\t\t\tif (newlen != rawlen)\n\t\t\t\tjs_rangeerror(J, \"array length\");\n\t\t\tjsV_resizearray(J, obj, newlen);\n\t\t\treturn;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= obj->u.a.length)\n\t\t\t\tobj->u.a.length = k + 1;\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto readonly;\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto readonly;\n\t\tif (!strcmp(name, \"global\")) goto readonly;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto readonly;\n\t\tif (!strcmp(name, \"multiline\")) goto readonly;\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tobj->u.r.last = jsV_tointeger(J, value);\n\t\t\treturn;\n\t\t}\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))\n\t\t\treturn;\n\t}\n\tref = jsV_getpropertyx(J, obj, name, &own);\n\tif (ref && ref->setter) {\n\t\tjs_pushobject(J, ref->setter);\n\t\tjs_pushobject(J, obj);\n\t\tjs_pushvalue(J, *value);\n\t\tjs_call(J, 1);\n\t\tjs_pop(J, 1);\n\t\treturn;\n\t}\n\tif (!ref || !own)\n\t\tref = jsV_setproperty(J, obj, name);\n\tif (ref) {\n\t\tif (!(ref->atts & JS_READONLY))\n\t\t\tref->value = *value;\n\t\telse\n\t\t\tgoto readonly;\n\t}\n\treturn;\nreadonly:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n}", "target": 0}
{"code": "static int _nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n\t\tu64 cookie, struct page **pages, unsigned int count, int plus)\n{\n\tstruct inode\t\t*dir = dentry->d_inode;\n\tstruct nfs4_readdir_arg args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.pages = pages,\n\t\t.pgbase = 0,\n\t\t.count = count,\n\t\t.bitmask = NFS_SERVER(dentry->d_inode)->attr_bitmask,\n\t\t.plus = plus,\n\t};\n\tstruct nfs4_readdir_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READDIR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint\t\t\tstatus;\n\tdprintk(\"%s: dentry = %s/%s, cookie = %Lu\\n\", __func__,\n\t\t\tdentry->d_parent->d_name.name,\n\t\t\tdentry->d_name.name,\n\t\t\t(unsigned long long)cookie);\n\tnfs4_setup_readdir(cookie, NFS_I(dir)->cookieverf, dentry, &args);\n\tres.pgbase = args.pgbase;\n\tstatus = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status >= 0) {\n\t\tmemcpy(NFS_I(dir)->cookieverf, res.verifier.data, NFS4_VERIFIER_SIZE);\n\t\tstatus += args.pgbase;\n\t}\n\tnfs_invalidate_atime(dir);\n\tdprintk(\"%s: returns %d\\n\", __func__, status);\n\treturn status;\n}", "target": 0}
{"code": "int irssi_ssl_handshake(GIOChannel *handle)\n{\n\tGIOSSLChannel *chan = (GIOSSLChannel *)handle;\n\tint ret, err;\n\tX509 *cert;\n\tconst char *errstr;\n\tret = SSL_connect(chan->ssl);\n\tif (ret <= 0) {\n\t\terr = SSL_get_error(chan->ssl, ret);\n\t\tswitch (err) {\n\t\t\tcase SSL_ERROR_WANT_READ:\n\t\t\t\treturn 1;\n\t\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\t\treturn 3;\n\t\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", \"server closed connection\");\n\t\t\t\treturn -1;\n\t\t\tcase SSL_ERROR_SYSCALL:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tif (errstr == NULL && ret == -1)\n\t\t\t\t\terrstr = strerror(errno);\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"server closed connection unexpectedly\");\n\t\t\t\treturn -1;\n\t\t\tdefault:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"unknown SSL error\");\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tcert = SSL_get_peer_certificate(chan->ssl);\n\tif (cert == NULL) {\n\t\tg_warning(\"SSL server supplied no certificate\");\n\t\treturn -1;\n\t}\n\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, cert);\n\tX509_free(cert);\n\treturn ret ? 0 : -1;\n}", "target": 1}
{"code": "RenderViewImpl* RenderViewImpl::Create(\n    int32 opener_id,\n    const RendererPreferences& renderer_prefs,\n    const WebPreferences& webkit_prefs,\n    SharedRenderViewCounter* counter,\n    int32 routing_id,\n    int32 surface_id,\n    int64 session_storage_namespace_id,\n    const string16& frame_name,\n    bool is_renderer_created,\n    bool swapped_out,\n    int32 next_page_id,\n    const WebKit::WebScreenInfo& screen_info,\n    AccessibilityMode accessibility_mode) {\n  DCHECK(routing_id != MSG_ROUTING_NONE);\n  RenderViewImplParams params(\n      opener_id,\n      renderer_prefs,\n      webkit_prefs,\n      counter,\n      routing_id,\n      surface_id,\n      session_storage_namespace_id,\n      frame_name,\n      is_renderer_created,\n      swapped_out,\n      next_page_id,\n      screen_info,\n      accessibility_mode);\n  if (g_create_render_view_impl)\n    return g_create_render_view_impl(&params);\n  return new RenderViewImpl(&params);\n}", "target": 0}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 0}
{"code": "static void _d_rehash(struct dentry * entry)\n{\n\t__d_rehash(entry, d_hash(entry->d_parent, entry->d_name.hash));\n}", "target": 0}
{"code": "unix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror_f(\"path \\\"%s\\\" too long for Unix domain socket\", path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"socket: %.100s\", strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot bind to path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot listen on path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}", "target": 0}
{"code": "static void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}", "target": 0}
{"code": "static int pull_client_data (struct conn_s *connptr, long int length, int iehack)\n{\n        char *buffer;\n        ssize_t len;\n        int ret;\n        buffer =\n            (char *) safemalloc (min (MAXBUFFSIZE, (unsigned long int) length));\n        if (!buffer)\n                return -1;\n        do {\n                len = safe_read (connptr->client_fd, buffer,\n                                 min (MAXBUFFSIZE, (unsigned long int) length));\n                if (len <= 0)\n                        goto ERROR_EXIT;\n                if (!connptr->error_variables) {\n                        if (safe_write (connptr->server_fd, buffer, len) < 0)\n                                goto ERROR_EXIT;\n                }\n                length -= len;\n        } while (length > 0);\n        if (iehack) {\n                ret = socket_nonblocking (connptr->client_fd);\n                if (ret != 0) {\n                        log_message(LOG_ERR, \"Failed to set the client socket \"\n                                    \"to non-blocking: %s\", strerror(errno));\n                        goto ERROR_EXIT;\n                }\n                len = recv (connptr->client_fd, buffer, 2, MSG_PEEK);\n                ret = socket_blocking (connptr->client_fd);\n                if (ret != 0) {\n                        log_message(LOG_ERR, \"Failed to set the client socket \"\n                                    \"to blocking: %s\", strerror(errno));\n                        goto ERROR_EXIT;\n                }\n                if (len < 0 && errno != EAGAIN)\n                        goto ERROR_EXIT;\n                if ((len == 2) && CHECK_CRLF (buffer, len)) {\n                        ssize_t bytes_read;\n                        bytes_read = read (connptr->client_fd, buffer, 2);\n                        if (bytes_read == -1) {\n                                log_message\n                                        (LOG_WARNING,\n                                         \"Could not read two bytes from POST message\");\n                        }\n                }\n        }\n        safefree (buffer);\n        return 0;\nERROR_EXIT:\n        safefree (buffer);\n        return -1;\n}", "target": 0}
{"code": "GF_Err prhd_box_size(GF_Box *s)\n{\n\ts->size += 12;\n\treturn GF_OK;\n}", "target": 0}
{"code": "gen_muldiv(codegen_scope *s, uint8_t op, uint16_t dst)\n{\n  if (no_peephole(s)) {\n  normal:\n    genop_1(s, op, dst);\n    return;\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    mrb_int n, n0;\n    if (addr_pc(s, data.addr) == s->lastlabel || !get_int_operand(s, &data, &n)) {\n      goto normal;\n    }\n    struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n    if (!get_int_operand(s, &data0, &n0) || n == 0) {\n      goto normal;\n    }\n    if (op == OP_MUL) {\n      if (mrb_int_mul_overflow(n0, n, &n)) goto normal;\n    }\n    else { \n      if (n0 == MRB_INT_MIN && n == -1) goto normal;\n      n = n0 / n;\n    }\n    s->pc = addr_pc(s, data0.addr);\n    gen_int(s, dst, n);\n  }\n}", "target": 0}
{"code": "static void free_segment_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_segments; i++) {\n        av_free(pls->segments[i]->key);\n        av_free(pls->segments[i]->url);\n        av_free(pls->segments[i]);\n    }\n    av_freep(&pls->segments);\n    pls->n_segments = 0;\n}", "target": 0}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "rpa_read_buffer(pool_t pool, const unsigned char **data,\n\t\tconst unsigned char *end, unsigned char **buffer)\n{\n\tconst unsigned char *p = *data;\n\tunsigned int len;\n\tif (p > end)\n\t\treturn 0;\n\tlen = *p++;\n\tif (p + len > end)\n\t\treturn 0;\n\t*buffer = p_malloc(pool, len);\n\tmemcpy(*buffer, p, len);\n\t*data += 1 + len;\n\treturn len;\n}", "target": 1}
{"code": "void CharCodeToUnicode::addMapping(CharCode code, char *uStr, int n,\n\t\t\t\t   int offset) {\n  CharCode oldLen, i;\n  Unicode u;\n  char uHex[5];\n  int j;\n  if (code >= mapLen) {\n    oldLen = mapLen;\n    mapLen = (code + 256) & ~255;\n    map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode));\n    for (i = oldLen; i < mapLen; ++i) {\n      map[i] = 0;\n    }\n  }\n  if (n <= 4) {\n    if (sscanf(uStr, \"%x\", &u) != 1) {\n      error(-1, \"Illegal entry in ToUnicode CMap\");\n      return;\n    }\n    map[code] = u + offset;\n  } else {\n    if (sMapLen >= sMapSize) {\n      sMapSize = sMapSize + 16;\n      sMap = (CharCodeToUnicodeString *)\n\t       greallocn(sMap, sMapSize, sizeof(CharCodeToUnicodeString));\n    }\n    map[code] = 0;\n    sMap[sMapLen].c = code;\n    sMap[sMapLen].len = n / 4;\n    for (j = 0; j < sMap[sMapLen].len && j < maxUnicodeString; ++j) {\n      strncpy(uHex, uStr + j*4, 4);\n      uHex[4] = '\\0';\n      if (sscanf(uHex, \"%x\", &sMap[sMapLen].u[j]) != 1) {\n\terror(-1, \"Illegal entry in ToUnicode CMap\");\n      }\n    }\n    sMap[sMapLen].u[sMap[sMapLen].len - 1] += offset;\n    ++sMapLen;\n  }\n}", "target": 1}
{"code": "blockmix_salsa8(__m128i * Bin, __m128i * Bout, __m128i * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[8 * r - 4], 64);\n  for (i = 0; i < r; i++) {\n    blkxor(X, &Bin[i * 8], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 4], X, 64);\n    blkxor(X, &Bin[i * 8 + 4], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[(r + i) * 4], X, 64);\n  }\n}", "target": 1}
{"code": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n    return NULL;\n}", "target": 1}
{"code": "static void FNAME_DECL(compress_row0)(const PIXEL *cur_row, unsigned int width)\n{\n    DECLARE_STATE_VARIABLES;\n    const unsigned int bpc_mask = BPC_MASK;\n    int pos = 0;\n    while ((DEFwmimax > (int)state->wmidx) && (state->wmileft <= width)) {\n        if (state->wmileft) {\n            FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + state->wmileft,\n                                          bppmask[state->wmidx], bpc_mask);\n            width -= state->wmileft;\n            pos += state->wmileft;\n        }\n        state->wmidx++;\n        set_wm_trigger(state);\n        state->wmileft = DEFwminext;\n    }\n    if (width) {\n        FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + width,\n                                      bppmask[state->wmidx], bpc_mask);\n        if (DEFwmimax > (int)state->wmidx) {\n            state->wmileft -= width;\n        }\n    }\n    spice_assert((int)state->wmidx <= DEFwmimax);\n    spice_assert(state->wmidx <= 32);\n    spice_assert(DEFwminext > 0);\n}", "target": 0}
{"code": "Opal::Call::Call (OpalManager& _manager,\n\t\t  Ekiga::ServiceCore& _core,\n\t\t  const std::string& uri)\n  : OpalCall (_manager), Ekiga::Call (), core (_core), remote_uri (uri),\n    call_setup(false), jitter(0), outgoing(false)\n{\n  notification_core = core.get<Ekiga::NotificationCore> (\"notification-core\");\n  re_a_bytes = tr_a_bytes = re_v_bytes = tr_v_bytes = 0.0;\n  last_v_tick = last_a_tick = PTime ();\n  total_a =\n    total_v =\n    lost_a =\n    too_late_a =\n    out_of_order_a =\n    lost_v =\n    too_late_v =\n    out_of_order_v = 0;\n  lost_packets = late_packets = out_of_order_packets = 0.0;\n  re_a_bw = tr_a_bw = re_v_bw = tr_v_bw = 0.0;\n  NoAnswerTimer.SetNotifier (PCREATE_NOTIFIER (OnNoAnswerTimeout));\n}", "target": 0}
{"code": "try_flatedecode(unsigned char *buf, off_t real_len, off_t calculated_len, int fout, cli_ctx *ctx)\n{\n\tint ret = cli_checklimits(\"cli_pdf\", ctx, real_len, 0, 0);\n\tif (ret==CL_CLEAN && flatedecode(buf, real_len, fout, ctx) == CL_SUCCESS)\n\t\treturn CL_CLEAN;\n\tif(real_len == calculated_len) {\n\t\tcli_dbgmsg(\"cli_pdf: Bad compression in flate stream\\n\");\n\t\treturn CL_CLEAN;\n\t}\n\tif(cli_checklimits(\"cli_pdf\", ctx, calculated_len, 0, 0)!=CL_CLEAN)\n\t\treturn CL_CLEAN;\n\tret = flatedecode(buf, calculated_len, fout, ctx);\n\tif(ret == CL_CLEAN)\n\t\treturn CL_CLEAN;\n\tcli_dbgmsg(\"cli_pdf: Bad compressed block length in flate stream\\n\");\n\treturn ret;\n}", "target": 0}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "test_compressed_stream_overflow (xd3_stream *stream, int ignore)\n{\n  int ret;\n  int i;\n  uint8_t *buf;\n  if ((buf = (uint8_t*) malloc (TWO_MEGS_AND_DELTA)) == NULL) { return ENOMEM; }\n  memset (buf, 0, TWO_MEGS_AND_DELTA);\n  for (i = 0; i < (2 << 20); i += 256) \n    {\n      int j;\n      int off = mt_random(& static_mtrand) % 10;\n      for (j = 0; j < 256; j++) \n\t{\n\t  buf[i + j] = j + off;\n\t}\n    }\n  if (SIZEOF_XOFF_T == 4)\n    {\n      ret = test_streaming (stream, buf, buf + (1 << 20), buf + (2 << 20), (1 << 12) + 1);\n      if (ret == XD3_INVALID_INPUT && MSG_IS (\"decoder file offset overflow\"))\n\t{\n\t  ret = 0;\n\t}\n      else\n\t{\n          XPR(NT XD3_LIB_ERRMSG (stream, ret));\n\t  stream->msg = \"expected overflow condition\";\n\t  ret = XD3_INTERNAL;\n\t  goto fail;\n\t}\n    }\n  if ((ret = test_streaming (stream, \n\t\t\t     buf, \n\t\t\t     buf + (1 << 20), \n\t\t\t     buf + (2 << 20), \n\t\t\t     1 << 12))) \n    {\n      goto fail;\n    }\n fail:\n  free (buf);\n  return ret;\n}", "target": 1}
{"code": "lyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                       void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "static int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx;\n\tint s_idx = cb->family;\n\tif (s_idx == 0)\n\t\ts_idx = 1;\n\tfor (idx = 1; idx <= RTNL_FAMILY_MAX; idx++) {\n\t\tint type = cb->nlh->nlmsg_type-RTM_BASE;\n\t\tif (idx < s_idx || idx == PF_PACKET)\n\t\t\tcontinue;\n\t\tif (rtnl_msg_handlers[idx] == NULL ||\n\t\t    rtnl_msg_handlers[idx][type].dumpit == NULL)\n\t\t\tcontinue;\n\t\tif (idx > s_idx) {\n\t\t\tmemset(&cb->args[0], 0, sizeof(cb->args));\n\t\t\tcb->prev_seq = 0;\n\t\t\tcb->seq = 0;\n\t\t}\n\t\tif (rtnl_msg_handlers[idx][type].dumpit(skb, cb))\n\t\t\tbreak;\n\t}\n\tcb->family = idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}", "target": 1}
{"code": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "httpd_compress(isc_httpd_t *httpd) {\n\tz_stream zstr;\n\tisc_region_t r;\n\tint ret;\n\tint inputlen;\n\tinputlen = isc_buffer_usedlength(&httpd->bodybuffer);\n\talloc_compspace(httpd, inputlen);\n\tisc_buffer_region(&httpd->compbuffer, &r);\n\tmemset(&zstr, 0, sizeof(zstr));\n\tzstr.total_in = zstr.avail_in = zstr.total_out = zstr.avail_out =\n\t\tinputlen;\n\tzstr.next_in = isc_buffer_base(&httpd->bodybuffer);\n\tzstr.next_out = r.base;\n\tret = deflateInit(&zstr, Z_DEFAULT_COMPRESSION);\n\tif (ret == Z_OK) {\n\t\tret = deflate(&zstr, Z_FINISH);\n\t}\n\tdeflateEnd(&zstr);\n\tif (ret == Z_STREAM_END) {\n\t\tisc_buffer_add(&httpd->compbuffer, inputlen - zstr.avail_out);\n\t\treturn (ISC_R_SUCCESS);\n\t} else {\n\t\treturn (ISC_R_FAILURE);\n\t}\n}", "target": 0}
{"code": "static int gdAlphaOverlayColor (int src, int dst, int max )\n{\n\tdst = dst << 1;\n\tif( dst > max ) {\n\t\treturn dst + (src << 1) - (dst * src / max) - max;\n\t} else {\n\t\treturn dst * src / max;\n\t}\n}", "target": 0}
{"code": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "_XcursorAddPathElt (char *path, const char *elt, int len)\n{\n    size_t    pathlen = strlen (path);\n    if (path[0] == '\\0' || path[pathlen - 1] != '/')\n    {\n\tstrcat (path, \"/\");\n\tpathlen++;\n    }\n    if (len == -1)\n\tlen = strlen (elt);\n    while (len && elt[0] == '/')\n    {\n\telt++;\n\tlen--;\n    }\n    strncpy (path + pathlen, elt, len);\n    path[pathlen + len] = '\\0';\n}", "target": 0}
{"code": "cmndlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *list, const char *runchroot,\n    struct cmnd_info *info)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static inline int get_b_cbp(MpegEncContext *s, int16_t block[6][64],\n                            int motion_x, int motion_y, int mb_type)\n{\n    int cbp = 0, i;\n    if (s->mpv_flags & FF_MPV_FLAG_CBP_RD) {\n        int score        = 0;\n        const int lambda = s->lambda2 >> (FF_LAMBDA_SHIFT - 6);\n        for (i = 0; i < 6; i++) {\n            if (s->coded_score[i] < 0) {\n                score += s->coded_score[i];\n                cbp   |= 1 << (5 - i);\n            }\n        }\n        if (cbp) {\n            int zero_score = -6;\n            if ((motion_x | motion_y | s->dquant | mb_type) == 0)\n                zero_score -= 4;  \n            zero_score *= lambda;\n            if (zero_score <= score)\n                cbp = 0;\n        }\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0 && ((cbp >> (5 - i)) & 1) == 0) {\n                s->block_last_index[i] = -1;\n                s->bdsp.clear_block(s->block[i]);\n            }\n        }\n    } else {\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0)\n                cbp |= 1 << (5 - i);\n        }\n    }\n    return cbp;\n}", "target": 0}
{"code": "  void *realloc(void *ptr, size_t newsz)\n  {\n    void *ret = ::realloc(ptr, newsz + extra_bytes);\n    forget_ptr(ptr);\n    mem_ptr(ret);\n    return ret;\n  }", "target": 0}
{"code": "static bool imap_client_input_next_cmd(struct client *_client)\n{\n\tstruct imap_client *client = (struct imap_client *)_client;\n\tconst struct imap_arg *args;\n\tbool parsed;\n\tint ret;\n\tif (strcasecmp(client->cmd_name, \"AUTHENTICATE\") == 0) {\n\t\tret = cmd_authenticate(client, &parsed);\n\t\tif (ret == 0 && !parsed)\n\t\t\treturn FALSE;\n\t} else if (strcasecmp(client->cmd_name, \"ID\") == 0) {\n\t\tret = cmd_id(client);\n\t\tif (ret == 0)\n\t\t\treturn FALSE;\n\t\tif (ret < 0)\n\t\t\tret = 1; \n\t} else {\n\t\tret = client_parse_command(client, &args);\n\t\tif (ret < 0)\n\t\t\treturn TRUE;\n\t\tif (ret == 0)\n\t\t\treturn FALSE;\n\t\tret = *client->cmd_tag == '\\0' ? -1 :\n\t\t\tclient_command_execute(client, client->cmd_name, args);\n\t}\n\tclient->cmd_finished = TRUE;\n\tif (ret == -2 && strcasecmp(client->cmd_tag, \"LOGIN\") == 0) {\n\t\tclient_send_reply(&client->common, IMAP_CMD_REPLY_BAD,\n\t\t\t\"First parameter in line is IMAP's command tag, \"\n\t\t\t\"not the command name. Add that before the command, \"\n\t\t\t\"like: a login user pass\");\n\t} else if (ret < 0) {\n\t\tif (!client_invalid_command(client))\n\t\t\treturn FALSE;\n\t}\n\treturn ret != 0 && !client->common.destroyed;\n}", "target": 0}
{"code": "static void coroutine_fn v9fs_mknod(void *opaque)\n{\n    int mode;\n    gid_t gid;\n    int32_t fid;\n    V9fsQID qid;\n    int err = 0;\n    int major, minor;\n    size_t offset = 7;\n    V9fsString name;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdddd\", &fid, &name, &mode,\n                        &major, &minor, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mknod(pdu->tag, pdu->id, fid, mode, major, minor);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, gid,\n                        makedev(major, minor), mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_qid(pdu, &stbuf, &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mknod_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}", "target": 0}
{"code": "rb_reg_fixed_encoding_p(VALUE re)\n{\n    if (FL_TEST(re, KCODE_FIXED))\n        return Qtrue;\n    else\n        return Qfalse;\n}", "target": 0}
{"code": "RootWindow* RootWindowHostLinux::GetRootWindow() {\n  return root_window_;\n}", "target": 0}
{"code": "http_DissectRequest(struct sess *sp)\n{\n\tstruct http_conn *htc;\n\tstruct http *hp;\n\tuint16_t retval;\n\tCHECK_OBJ_NOTNULL(sp, SESS_MAGIC);\n\thtc = sp->htc;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\thp = sp->http;\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\thp->logtag = HTTP_Rx;\n\tretval = http_splitline(sp->wrk, sp->fd, hp, htc,\n\t    HTTP_HDR_REQ, HTTP_HDR_URL, HTTP_HDR_PROTO);\n\tif (retval != 0) {\n\t\tWSPR(sp, SLT_HttpGarbage, htc->rxbuf);\n\t\treturn (retval);\n\t}\n\thttp_ProtoVer(hp);\n\tretval = htc_request_check_host_hdr(hp);\n\tif (retval != 0) {\n\t\tWSP(sp, SLT_Error, \"Duplicated Host header\");\n\t\treturn (retval);\n\t}\n\treturn (retval);\n}", "target": 1}
{"code": "void test_checkout_nasty__git_tilde1(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n#endif\n}", "target": 1}
{"code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\tif (!strlen(text)) return \"empty string\";\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  \n\treturn escaped;\n}", "target": 1}
{"code": "find_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}", "target": 1}
{"code": "static noinline int audit_inode_permission(struct inode *inode,\n\t\t\t\t\t   u32 perms, u32 audited, u32 denied,\n\t\t\t\t\t   int result)\n{\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tint rc;\n\tad.type = LSM_AUDIT_DATA_INODE;\n\tad.u.inode = inode;\n\trc = slow_avc_audit(&selinux_state,\n\t\t\t    current_sid(), isec->sid, isec->sclass, perms,\n\t\t\t    audited, denied, result, &ad);\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t TIFFReadCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n  size_t\n    total;\n  ssize_t\n    remaining;\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  remaining=(MagickOffsetType) profile->length-profile->offset;\n  if (remaining <= 0)\n    return(-1);\n  total=MagickMin(count, (size_t) remaining);\n  (void) memcpy(data,profile->data->datum+profile->offset,total);\n  profile->offset+=total;\n  return(total);\n}", "target": 0}
{"code": "static bool ok_jpg_read_dqt(ok_jpg_decoder *decoder) {\n    ok_jpg *jpg = decoder->jpg;\n    uint8_t buffer[2];\n    if (!ok_read(decoder, buffer, sizeof(buffer))) {\n        return false;\n    }\n    int length = readBE16(buffer) - 2;\n    while (length >= 65) {\n        uint8_t pt = ok_read_uint8(decoder);\n        int Pq = pt >> 4;\n        int Tq = pt & 0x0f;\n        if (Pq == 1) {\n            ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, \"Unsupported JPEG (16-bit q_table)\");\n            return false;\n        }\n        if (Pq != 0 || Tq > 3) {\n            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Invalid JPEG (Pq/Tq)\");\n            return false;\n        }\n        if (!ok_read(decoder, decoder->q_table[Tq], 64)) {\n            return false;\n        }\n        length -= 65;\n    }\n    if (length != 0) {\n        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Invalid DQT segment length\");\n        return false;\n    } else {\n        return true;\n    }\n}", "target": 0}
{"code": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}", "target": 1}
{"code": "trad_enc_update_keys(struct trad_enc_ctx *ctx, uint8_t c)\n{\n\tuint8_t t;\n#define CRC32(c, b) (crc32(c ^ 0xffffffffUL, &b, 1) ^ 0xffffffffUL)\n\tctx->keys[0] = CRC32(ctx->keys[0], c);\n\tctx->keys[1] = (ctx->keys[1] + (ctx->keys[0] & 0xff)) * 134775813L + 1;\n\tt = (ctx->keys[1] >> 24) & 0xff;\n\tctx->keys[2] = CRC32(ctx->keys[2], t);\n#undef CRC32\n}", "target": 0}
{"code": "    uint32_t PsdImage::writeExifData(const ExifData& exifData, BasicIo& out)\n    {\n        uint32_t resLength = 0;\n        byte buf[8];\n        if (exifData.count() > 0) {\n            Blob blob;\n            ByteOrder bo = byteOrder();\n            if (bo == invalidByteOrder) {\n                bo = littleEndian;\n                setByteOrder(bo);\n            }\n            ExifParser::encode(blob, bo, exifData);\n            if (blob.size() > 0) {\n#ifdef DEBUG\n                std::cerr << std::hex << \"write: resourceId: \" << kPhotoshopResourceID_ExifInfo << \"\\n\";\n                std::cerr << std::dec << \"Writing ExifInfo: size: \" << blob.size() << \"\\n\";\n#endif\n                if (out.write(reinterpret_cast<const byte*>(Photoshop::irbId_[0]), 4) != 4) throw Error(kerImageWriteFailed);\n                us2Data(buf, kPhotoshopResourceID_ExifInfo, bigEndian);\n                if (out.write(buf, 2) != 2) throw Error(kerImageWriteFailed);\n                us2Data(buf, 0, bigEndian);                      \n                if (out.write(buf, 2) != 2) throw Error(kerImageWriteFailed);\n                ul2Data(buf, static_cast<uint32_t>(blob.size()), bigEndian);\n                if (out.write(buf, 4) != 4) throw Error(kerImageWriteFailed);\n                if (out.write(&blob[0], static_cast<long>(blob.size())) != static_cast<long>(blob.size())) throw Error(kerImageWriteFailed);\n                resLength += static_cast<long>(blob.size()) + 12;\n                if (blob.size() & 1)    \n                {\n                    buf[0] = 0;\n                    if (out.write(buf, 1) != 1) throw Error(kerImageWriteFailed);\n                    resLength++;\n                }\n            }\n        }\n        return resLength;\n    } ", "target": 0}
{"code": "static void flush_change(H264Context *h)\n{\n    int i, j;\n    h->outputed_poc          = h->next_outputed_poc = INT_MIN;\n    h->prev_interlaced_frame = 1;\n    idr(h);\n    h->prev_frame_num = -1;\n    if (h->cur_pic_ptr) {\n        h->cur_pic_ptr->reference = 0;\n        for (j=i=0; h->delayed_pic[i]; i++)\n            if (h->delayed_pic[i] != h->cur_pic_ptr)\n                h->delayed_pic[j++] = h->delayed_pic[i];\n        h->delayed_pic[j] = NULL;\n    }\n    h->first_field = 0;\n    memset(h->ref_list[0], 0, sizeof(h->ref_list[0]));\n    memset(h->ref_list[1], 0, sizeof(h->ref_list[1]));\n    memset(h->default_ref_list[0], 0, sizeof(h->default_ref_list[0]));\n    memset(h->default_ref_list[1], 0, sizeof(h->default_ref_list[1]));\n    ff_h264_reset_sei(h);\n    h->recovery_frame = -1;\n    h->frame_recovered = 0;\n    h->list_count = 0;\n    h->current_slice = 0;\n    h->mmco_reset = 1;\n}", "target": 0}
{"code": "xfs_inode_free_callback(\n\tstruct rcu_head\t\t*head)\n{\n\tstruct inode\t\t*inode = container_of(head, struct inode, i_rcu);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tswitch (VFS_I(ip)->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t\tbreak;\n\t}\n\tif (ip->i_afp)\n\t\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tif (ip->i_cowfp)\n\t\txfs_idestroy_fork(ip, XFS_COW_FORK);\n\tif (ip->i_itemp) {\n\t\tASSERT(!(ip->i_itemp->ili_item.li_flags & XFS_LI_IN_AIL));\n\t\txfs_inode_item_destroy(ip);\n\t\tip->i_itemp = NULL;\n\t}\n\tkmem_zone_free(xfs_inode_zone, ip);\n}", "target": 0}
{"code": "    bool PamBackend::start(const QString &user) {\n        bool result;\n        QString service = QStringLiteral(\"sddm\");\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n        return result;\n    }", "target": 1}
{"code": "bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\tfree_pages -= (1 << order) - 1;\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n#ifdef CONFIG_CMA\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\tif (!order)\n\t\treturn true;\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, iter_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tret = fn(&kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}", "target": 0}
{"code": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, PAGE_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = join_session_keyring(name);\n error:\n\treturn ret;\n} ", "target": 1}
{"code": "MagickExport void CatchException(ExceptionInfo *exception)\n{\n  register const ExceptionInfo\n    *p;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (exception->exceptions  == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    if ((p->severity >= WarningException) && (p->severity < ErrorException))\n      MagickWarning(p->severity,p->reason,p->description);\n    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))\n      MagickError(p->severity,p->reason,p->description);\n    if (p->severity >= FatalErrorException)\n      MagickFatalError(p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      exception->exceptions);\n  }\n  UnlockSemaphoreInfo(exception->semaphore);\n  ClearMagickException(exception);\n}", "target": 1}
{"code": "static void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {\n  int i,j;\n#define FILL_RECT(BPP) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n  switch(client->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}", "target": 0}
{"code": "static const char *typeString(ut32 n, int *bits) {\n\t*bits = 32;\n\tif (n == 12) { \n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0100000c) { \n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0200000c) { \n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\treturn \"x86\";\n}", "target": 0}
{"code": "static inline struct page *__skb_alloc_pages(gfp_t gfp_mask,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      unsigned int order)\n{\n\tstruct page *page;\n\tgfp_mask |= __GFP_COLD;\n\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\tgfp_mask |= __GFP_MEMALLOC;\n\tpage = alloc_pages_node(NUMA_NO_NODE, gfp_mask, order);\n\tif (skb && page && page->pfmemalloc)\n\t\tskb->pfmemalloc = true;\n\treturn page;\n}", "target": 0}
{"code": "static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "void ax25_fillin_cb(ax25_cb *ax25, ax25_dev *ax25_dev)\n{\n\tax25->ax25_dev = ax25_dev;\n\tif (ax25->ax25_dev != NULL) {\n\t\tax25_fillin_cb_from_dev(ax25, ax25_dev);\n\t\treturn;\n\t}\n\tax25->rtt     = msecs_to_jiffies(AX25_DEF_T1) / 2;\n\tax25->t1      = msecs_to_jiffies(AX25_DEF_T1);\n\tax25->t2      = msecs_to_jiffies(AX25_DEF_T2);\n\tax25->t3      = msecs_to_jiffies(AX25_DEF_T3);\n\tax25->n2      = AX25_DEF_N2;\n\tax25->paclen  = AX25_DEF_PACLEN;\n\tax25->idle    = msecs_to_jiffies(AX25_DEF_IDLE);\n\tax25->backoff = AX25_DEF_BACKOFF;\n\tif (AX25_DEF_AXDEFMODE) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = AX25_DEF_EWINDOW;\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = AX25_DEF_WINDOW;\n\t}\n}", "target": 0}
{"code": "static uint8_t avrcp_handle_displayable_charset(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tuint16_t len = ntohs(pdu->params_len);\n\tif (len < 3) {\n\t\tpdu->params_len = htons(1);\n\t\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\t\treturn AVC_CTYPE_REJECTED;\n\t}\n\tpdu->params_len = 0;\n\treturn AVC_CTYPE_STABLE;\n}", "target": 0}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tbool allow = [&]() {\n\t\t\t\tif (!inherit) {\n\t\t\t\t\tif (key_inner->IsName()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealNamedProperty(context_handle, key_inner.As<Name>()));\n\t\t\t\t\t} else if (key_inner->IsNumber()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealIndexedProperty(context_handle, HandleCast<uint32_t>(key_inner)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}();\n\t\t\tLocal<Value> value = allow ?\n\t\t\t\tUnmaybe(object->Get(context_handle, key_inner)) :\n\t\t\t\tUndefined(Isolate::GetCurrent()).As<Value>();\n\t\t\tret = TransferOut(value, options);\n\t\t}", "target": 1}
{"code": "static ssize_t store_int_with_restart(struct device *s,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t size)\n{\n\tssize_t ret = device_store_int(s, attr, buf, size);\n\tmce_restart();\n\treturn ret;\n}", "target": 1}
{"code": "int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n{\n    STACK_OF(X509_ALGOR) *mdalgs;\n    int ctype_nid = OBJ_obj2nid(p7->type);\n    const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n    if (ctype_nid == NID_pkcs7_signed)\n        mdalgs = p7->d.sign->md_algs;\n    else\n        mdalgs = NULL;\n    flags ^= SMIME_OLDMIME;\n    return SMIME_write_ASN1_ex(bio, (ASN1_VALUE *)p7, data, flags, ctype_nid,\n                               NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7),\n                               ossl_pkcs7_ctx_get0_libctx(ctx),\n                               ossl_pkcs7_ctx_get0_propq(ctx));\n}", "target": 1}
{"code": "TIFFWriteRawTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)\n{\n\tstatic const char module[] = \"TIFFWriteRawTile\";\n\tif (!WRITECHECKTILES(tif, module))\n\t\treturn ((tmsize_t)(-1));\n\tif (tile >= tif->tif_dir.td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Tile %lu out of range, max %lu\",\n\t\t    (unsigned long) tile,\n\t\t    (unsigned long) tif->tif_dir.td_nstrips);\n\t\treturn ((tmsize_t)(-1));\n\t}\n\treturn (TIFFAppendToStrip(tif, tile, (uint8*) data, cc) ?\n\t    cc : (tmsize_t)(-1));\n}", "target": 0}
{"code": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\treturn sprintf(buf, \"%d\\n\", count);\n}", "target": 1}
{"code": "static unsigned long get_unmapped_area_zero(struct file *file,\n\t\t\t\tunsigned long addr, unsigned long len,\n\t\t\t\tunsigned long pgoff, unsigned long flags)\n{\n#ifdef CONFIG_MMU\n\tif (flags & MAP_SHARED) {\n\t\treturn shmem_get_unmapped_area(NULL, addr, len, pgoff, flags);\n\t}\n\treturn current->mm->get_unmapped_area(file, addr, len, pgoff, flags);\n#else\n\treturn -ENOSYS;\n#endif\n}", "target": 0}
{"code": "static int skcipher_check_key(struct socket *sock)\n{\n\tint err = 0;\n\tstruct sock *psk;\n\tstruct alg_sock *pask;\n\tstruct skcipher_tfm *tfm;\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tlock_sock(sk);\n\tif (ask->refcnt)\n\t\tgoto unlock_child;\n\tpsk = ask->parent;\n\tpask = alg_sk(ask->parent);\n\ttfm = pask->private;\n\terr = -ENOKEY;\n\tlock_sock_nested(psk, SINGLE_DEPTH_NESTING);\n\tif (!tfm->has_key)\n\t\tgoto unlock;\n\tif (!pask->refcnt++)\n\t\tsock_hold(psk);\n\task->refcnt = 1;\n\tsock_put(psk);\n\terr = 0;\nunlock:\n\trelease_sock(psk);\nunlock_child:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "    ExifData::iterator ExifData::erase(ExifData::iterator pos)\n    {\n        return exifMetadata_.erase(pos);\n    }", "target": 0}
{"code": "exo_open_find_scheme (const gchar *string)\n{\n  gchar *current_dir;\n  gchar *uri;\n  gchar *path;\n  if (g_path_is_absolute (string))\n    return exo_open_get_path (string);\n  current_dir = g_get_current_dir ();\n  path = g_build_filename (current_dir, string, NULL);\n  g_free (current_dir);\n  if (g_file_test (path, G_FILE_TEST_EXISTS))\n    {\n       uri = exo_open_get_path (path);\n       g_free (path);\n       return uri;\n    }\n  g_free (path);\n  if (g_regex_match_simple (MATCH_PATTERN_EMAIL, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"mailto:\", string, NULL);\n  if (g_regex_match_simple (MATCH_PATTERN_HTTP, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"http:\n  return NULL;\n}", "target": 0}
{"code": "HttpStateData::finishingBrokenPost()\n{\n#if USE_HTTP_VIOLATIONS\n    if (!Config.accessList.brokenPosts) {\n        debugs(11, 5, HERE << \"No brokenPosts list\");\n        return false;\n    }\n    ACLFilledChecklist ch(Config.accessList.brokenPosts, originalRequest(), NULL);\n    ch.al = fwd->al;\n    ch.syncAle(originalRequest(), nullptr);\n    if (!ch.fastCheck().allowed()) {\n        debugs(11, 5, HERE << \"didn't match brokenPosts\");\n        return false;\n    }\n    if (!Comm::IsConnOpen(serverConnection)) {\n        debugs(11, 3, HERE << \"ignoring broken POST for closed \" << serverConnection);\n        assert(closeHandler != NULL);\n        return true; \n    }\n    debugs(11, 3, \"finishingBrokenPost: fixing broken POST\");\n    typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;\n    requestSender = JobCallback(11,5,\n                                Dialer, this, HttpStateData::wroteLast);\n    Comm::Write(serverConnection, \"\\r\\n\", 2, requestSender, NULL);\n    return true;\n#else\n    return false;\n#endif \n}", "target": 0}
{"code": "empty_param_read(iparam_list * plist, const ref * pkey, iparam_loc * ploc)\n{\n    return 1;\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageBmpCtx(im, out, compression);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n\tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n\tload_sp0(tss, next);\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\tsavesegment(fs, fsindex);\n\tsavesegment(gs, gsindex);\n\tload_TLS(next, cpu);\n\tarch_end_context_switch(next_p);\n\tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n\t\tloadsegment(fs, next->fsindex);\n\t\tif (fsindex)\n\t\t\tprev->fs = 0;\n\t}\n\tif (next->fs)\n\t\twrmsrl(MSR_FS_BASE, next->fs);\n\tprev->fsindex = fsindex;\n\tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n\t\tload_gs_index(next->gsindex);\n\t\tif (gsindex)\n\t\t\tprev->gs = 0;\n\t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\tswitch_fpu_finish(next_p, fpu);\n\tprev->usersp = this_cpu_read(old_rsp);\n\tthis_cpu_write(old_rsp, next->usersp);\n\tthis_cpu_write(current_task, next_p);\n\ttask_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);\n\tthis_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);\n\tthis_cpu_write(kernel_stack,\n\t\t  (unsigned long)task_stack_page(next_p) +\n\t\t  THREAD_SIZE - KERNEL_STACK_OFFSET);\n\tif (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||\n\t\t     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))\n\t\t__switch_to_xtra(prev_p, next_p, tss);\n\treturn prev_p;\n}", "target": 1}
{"code": "const void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn NULL;\n#else\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\treturn trak->tfrf;\n#endif\n}", "target": 0}
{"code": "static int inet6_netconf_get_devconf(struct sk_buff *in_skb,\n\t\t\t\t     struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NETCONFA_MAX+1];\n\tstruct netconfmsg *ncm;\n\tstruct sk_buff *skb;\n\tstruct ipv6_devconf *devconf;\n\tstruct inet6_dev *in6_dev;\n\tstruct net_device *dev;\n\tint ifindex;\n\tint err;\n\terr = nlmsg_parse(nlh, sizeof(*ncm), tb, NETCONFA_MAX,\n\t\t\t  devconf_ipv6_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\terr = EINVAL;\n\tif (!tb[NETCONFA_IFINDEX])\n\t\tgoto errout;\n\tifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\n\tswitch (ifindex) {\n\tcase NETCONFA_IFINDEX_ALL:\n\t\tdevconf = net->ipv6.devconf_all;\n\t\tbreak;\n\tcase NETCONFA_IFINDEX_DEFAULT:\n\t\tdevconf = net->ipv6.devconf_dflt;\n\t\tbreak;\n\tdefault:\n\t\tdev = __dev_get_by_index(net, ifindex);\n\t\tif (dev == NULL)\n\t\t\tgoto errout;\n\t\tin6_dev = __in6_dev_get(dev);\n\t\tif (in6_dev == NULL)\n\t\t\tgoto errout;\n\t\tdevconf = &in6_dev->cnf;\n\t\tbreak;\n\t}\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(inet6_netconf_msgsize_devconf(-1), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\terr = inet6_netconf_fill_devconf(skb, ifindex, devconf,\n\t\t\t\t\t NETLINK_CB(in_skb).portid,\n\t\t\t\t\t nlh->nlmsg_seq, RTM_NEWNETCONF, 0,\n\t\t\t\t\t -1);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n}", "target": 0}
{"code": "virSecuritySELinuxRestoreInputLabel(virSecurityManager *mgr,\n                                    virDomainDef *def,\n                                    virDomainInputDef *input)\n{\n    int rc = 0;\n    virSecurityLabelDef *seclabel;\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_INPUT_TYPE_EVDEV:\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, input->source.evdev, true);\n        break;\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        break;\n    }\n    return rc;\n}", "target": 0}
{"code": "void GfxCalRGBColorSpace::getGray(const GfxColor *color, GfxGray *gray) const\n{\n    GfxRGB rgb;\n#ifdef USE_CMS\n    if (transform != nullptr && transform->getTransformPixelType() == PT_GRAY) {\n        unsigned char out[gfxColorMaxComps];\n        double in[gfxColorMaxComps];\n        double X, Y, Z;\n        getXYZ(color, &X, &Y, &Z);\n        in[0] = clip01(X);\n        in[1] = clip01(Y);\n        in[2] = clip01(Z);\n        transform->doTransform(in, out, 1);\n        *gray = byteToCol(out[0]);\n        return;\n    }\n#endif\n    getRGB(color, &rgb);\n    *gray = clip01((GfxColorComp)(0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b + 0.5));\n}", "target": 0}
{"code": "static void init_skiplist(struct fsck_options *options, const char *path)\n{\n\tstatic struct oid_array skiplist = OID_ARRAY_INIT;\n\tint sorted, fd;\n\tchar buffer[GIT_MAX_HEXSZ + 1];\n\tstruct object_id oid;\n\tif (options->skiplist)\n\t\tsorted = options->skiplist->sorted;\n\telse {\n\t\tsorted = 1;\n\t\toptions->skiplist = &skiplist;\n\t}\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tdie(\"Could not open skip list: %s\", path);\n\tfor (;;) {\n\t\tconst char *p;\n\t\tint result = read_in_full(fd, buffer, sizeof(buffer));\n\t\tif (result < 0)\n\t\t\tdie_errno(\"Could not read '%s'\", path);\n\t\tif (!result)\n\t\t\tbreak;\n\t\tif (parse_oid_hex(buffer, &oid, &p) || *p != '\\n')\n\t\t\tdie(\"Invalid SHA-1: %s\", buffer);\n\t\toid_array_append(&skiplist, &oid);\n\t\tif (sorted && skiplist.nr > 1 &&\n\t\t\t\toidcmp(&skiplist.oid[skiplist.nr - 2],\n\t\t\t\t       &oid) > 0)\n\t\t\tsorted = 0;\n\t}\n\tclose(fd);\n\tif (sorted)\n\t\tskiplist.sorted = 1;\n}", "target": 0}
{"code": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !inode_capable(inode, CAP_FOWNER);\n}", "target": 1}
{"code": "static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\n\t\t\t    size_t len, loff_t *pos)\n{\n\tstruct ib_ucm_file *file = filp->private_data;\n\tstruct ib_ucm_cmd_hdr hdr;\n\tssize_t result;\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))\n\t\treturn -EINVAL;\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\tresult = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr),\n\t\t\t\t\thdr.in, hdr.out);\n\tif (!result)\n\t\tresult = len;\n\treturn result;\n}", "target": 0}
{"code": "ble_hs_conn_timer(void)\n{\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 && \\\n    BLE_HS_ATT_SVR_QUEUED_WRITE_TMO == 0\n    return BLE_HS_FOREVER;\n#endif\n    struct ble_hs_conn *conn;\n    ble_npl_time_t now;\n    int32_t next_exp_in;\n    int32_t time_diff;\n    uint16_t conn_handle;\n    for (;;) {\n        conn_handle = BLE_HS_CONN_HANDLE_NONE;\n        next_exp_in = BLE_HS_FOREVER;\n        now = ble_npl_time_get();\n        ble_hs_lock();\n        SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n            if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) != 0\n                if (conn->bhc_rx_chan != NULL) {\n                    time_diff = conn->bhc_rx_timeout - now;\n                    if (time_diff <= 0) {\n                        conn_handle = conn->bhc_handle;\n                        break;\n                    }\n                    if (time_diff < next_exp_in) {\n                        next_exp_in = time_diff;\n                    }\n                }\n#endif\n#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n                time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n                if (time_diff <= 0) {\n                    conn_handle = conn->bhc_handle;\n                    break;\n                }\n                if (time_diff < next_exp_in) {\n                    next_exp_in = time_diff;\n                }\n#endif\n            }\n        }\n        ble_hs_unlock();\n        if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {\n            ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);\n            continue;\n        }\n        return next_exp_in;\n    }\n}", "target": 1}
{"code": "para_macro_process(uschar *p, uschar *q)\n{\nint length = q - p;\nargstr **pp;\nmacrodef *md;\nmacroexe *me;\nfor (md = macrolist; md != NULL; md = md->next)\n  {\n  if (length == md->namelength && Ustrncmp(p, md->name, length) == 0) break;\n  }\nif (md == NULL)\n  {\n  error(23, length, p);\n  (void)fprintf(outfile, \"&\");\n  return p;\n  }\nme = misc_malloc(sizeof(macroexe));\nme->prev = macrocurrent;\nmacrocurrent = me;\nme->macro = md;\nme->nextline = md->lines;\nif (from_type_ptr >= FROM_TYPE_STACKSIZE - 1) error(32);  \nfrom_type[++from_type_ptr] = FROM_MACRO;\nme->args = NULL;\npp = &(me->args);\nwhile (isspace(*(++q)));\nwhile (*q != 0 && *q != ')')\n  {\n  argstr *as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_readitem(q, US\",)\", &length, NULL, 0);\n  q += length;\n  if (*q == ',') while (isspace(*(++q)));\n  }\nif (*q != ')')\n  {\n  error(24, p);\n  (void)fprintf(outfile, \"&\");\n  return p;\n  }\npara_inline_macro++;\nfor (;;)\n  {\n  uschar buffer[INBUFFSIZE];\n  read_process_macroline(macrocurrent->nextline->string, buffer);\n  if (*buffer == '.')\n    {\n    dot_process(buffer);\n    if (macrocurrent != me) break;\n    }\n  else\n    {\n    uschar *qq = buffer + Ustrlen(buffer);\n    while (qq > buffer && isspace(qq[-1])) qq--;\n    *qq = 0;\n    para_process(buffer);\n    }\n  macrocurrent->nextline = macrocurrent->nextline->next;\n  if (macrocurrent->nextline == NULL)\n    {\n    macroexe *temp = macrocurrent;\n    macrocurrent = macrocurrent->prev;\n    macro_free(temp);\n    from_type_ptr--;\n    break;\n    }\n  }\npara_inline_macro--;\nreturn q + 1;\n}", "target": 1}
{"code": "static NTSTATUS smb_unix_read_symlink(connection_struct *conn,\n\t\t\t\tstruct smb_request *req,\n\t\t\t\tstruct smb_filename *smb_fname,\n\t\t\t\tchar *pdata,\n\t\t\t\tunsigned int data_size_in,\n\t\t\t\tunsigned int *pdata_size_out)\n{\n\tNTSTATUS status;\n\tsize_t len = 0;\n\tint link_len = 0;\n\tstruct smb_filename *parent_fname = NULL;\n\tstruct smb_filename *base_name = NULL;\n\tchar *buffer = talloc_array(talloc_tos(), char, PATH_MAX+1);\n\tif (!buffer) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tDBG_DEBUG(\"SMB_QUERY_FILE_UNIX_LINK for file %s\\n\",\n\t\tsmb_fname_str_dbg(smb_fname));\n\tif(!S_ISLNK(smb_fname->st.st_ex_mode)) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn NT_STATUS_DOS(ERRSRV, ERRbadlink);\n\t}\n\tstatus = parent_pathref(talloc_tos(),\n\t\t\t\tconn->cwd_fsp,\n\t\t\t\tsmb_fname,\n\t\t\t\t&parent_fname,\n\t\t\t\t&base_name);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn status;\n\t}\n\tlink_len = SMB_VFS_READLINKAT(conn,\n\t\t\t\tparent_fname->fsp,\n\t\t\t\tbase_name,\n\t\t\t\tbuffer,\n\t\t\t\tPATH_MAX);\n\tTALLOC_FREE(parent_fname);\n\tif (link_len == -1) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\tbuffer[link_len] = 0;\n\tstatus = srvstr_push(pdata,\n\t\t\treq->flags2,\n\t\t\tpdata,\n\t\t\tbuffer,\n\t\t\tdata_size_in,\n\t\t\tSTR_TERMINATE,\n\t\t\t&len);\n\tTALLOC_FREE(buffer);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\t*pdata_size_out = len;\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "void ZlibInStream::removeUnderlying()\n{\n  ptr = end = start;\n  if (!underlying) return;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  underlying = 0;\n}", "target": 1}
{"code": "int nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\tNFS_PROTO(data->inode)->commit_setup(data, &msg);\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}", "target": 0}
{"code": "int touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n}", "target": 1}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                  XML_ACCOUNT_DIRECT);\n}", "target": 0}
{"code": "  explicit UnravelIndexOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}", "target": 1}
{"code": "static int get_filter(struct sss_certmap_ctx *ctx,\n                      struct ldap_mapping_rule *parsed_mapping_rule,\n                      struct sss_cert_content *cert_content,\n                      char **filter)\n{\n    struct ldap_mapping_rule_comp *comp;\n    char *result = NULL;\n    char *expanded = NULL;\n    int ret;\n    result = talloc_strdup(ctx, \"\");\n    if (result == NULL) {\n        return ENOMEM;\n    }\n    for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) {\n        if (comp->type == comp_string) {\n            result = talloc_strdup_append(result, comp->val);\n        } else if (comp->type == comp_template) {\n            ret = expand_template(ctx, comp->parsed_template, cert_content,\n                                  &expanded);\n            if (ret != 0) {\n                CM_DEBUG(ctx, \"Failed to expanded template.\");\n                goto done;\n            }\n            result = talloc_strdup_append(result, expanded);\n            talloc_free(expanded);\n            expanded = NULL;\n            if (result == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else {\n            ret = EINVAL;\n            CM_DEBUG(ctx, \"Unsupported component type.\");\n            goto done;\n        }\n    }\n    ret = 0;\ndone:\n    talloc_free(expanded);\n    if (ret == 0) {\n        *filter = result;\n    } else {\n        talloc_free(result);\n    }\n    return ret;\n}", "target": 1}
{"code": "snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = SNMP_DATA_TYPE_TIME_TICKS;\n  varbind->value.integer = integer;\n}", "target": 1}
{"code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}", "target": 1}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static inline struct rt6_info *ip6_dst_alloc(struct net *net,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct fib6_table *table)\n{\n\tstruct rt6_info *rt = dst_alloc(&net->ipv6.ip6_dst_ops, dev,\n\t\t\t\t\t0, DST_OBSOLETE_FORCE_CHK, flags);\n\tif (rt) {\n\t\tstruct dst_entry *dst = &rt->dst;\n\t\tmemset(dst + 1, 0, sizeof(*rt) - sizeof(*dst));\n\t\trt6_init_peer(rt, table ? &table->tb6_peers : net->ipv6.peers);\n\t\trt->rt6i_genid = rt_genid(net);\n\t\tINIT_LIST_HEAD(&rt->rt6i_siblings);\n\t\trt->rt6i_nsiblings = 0;\n\t}\n\treturn rt;\n}", "target": 0}
{"code": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tbpf_map_inc(map, true);\n\tfdput(f);\n\treturn map;\n}", "target": 1}
{"code": "static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn tfm->seedsize;\n}", "target": 1}
{"code": "static int selinux_netlbl_sock_setsid(struct sock *sk)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\tif (sksec->nlbl_state != NLBL_REQUIRE)\n\t\treturn 0;\n\tsecattr = selinux_netlbl_sock_genattr(sk);\n\tif (secattr == NULL)\n\t\treturn -ENOMEM;\n\trc = netlbl_sock_setattr(sk, secattr);\n\tswitch (rc) {\n\tcase 0:\n\t\tsksec->nlbl_state = NLBL_LABELED;\n\t\tbreak;\n\tcase -EDESTADDRREQ:\n\t\tsksec->nlbl_state = NLBL_REQSKB;\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct hw_perf_event fake_event = event->hw;\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\tif (is_software_event(event))\n\t\treturn 1;\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n}", "target": 1}
{"code": "convert(\n    Imaging imOut, Imaging imIn, const char *mode, ImagingPalette palette, int dither) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (!imIn) {\n        return (Imaging)ImagingError_ModeError();\n    }\n    if (!mode) {\n        if (!imIn->palette) {\n            return (Imaging)ImagingError_ModeError();\n        }\n        mode = imIn->palette->mode;\n    } else {\n        if (!strcmp(imIn->mode, mode)) {\n            return ImagingCopy2(imOut, imIn);\n        }\n    }\n    if (strcmp(imIn->mode, \"P\") == 0 || strcmp(imIn->mode, \"PA\") == 0) {\n        return frompalette(imOut, imIn, mode);\n    }\n    if (strcmp(mode, \"P\") == 0 || strcmp(mode, \"PA\") == 0) {\n        return topalette(imOut, imIn, mode, palette, dither);\n    }\n    if (dither && strcmp(mode, \"1\") == 0) {\n        return tobilevel(imOut, imIn, dither);\n    }\n    convert = NULL;\n    for (y = 0; converters[y].from; y++) {\n        if (!strcmp(imIn->mode, converters[y].from) &&\n            !strcmp(mode, converters[y].to)) {\n            convert = converters[y].convert;\n            break;\n        }\n    }\n    if (!convert) {\n#ifdef notdef\n        return (Imaging)ImagingError_ValueError(\"conversion not supported\");\n#else\n        static char buf[256];\n        sprintf(buf, \"conversion from %s to %s not supported\", imIn->mode, mode);\n        return (Imaging)ImagingError_ValueError(buf);\n#endif\n    }\n    imOut = ImagingNew2Dirty(mode, imOut, imIn);\n    if (!imOut) {\n        return NULL;\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imOut;\n}", "target": 1}
{"code": "static void do_clear(enum clear_what what, bool context)\n{\n    if (context) {\n        if (what & CLEAR_ALLDEFINE) {\n            Context *ctx;\n            list_for_each(ctx, cstk)\n                clear_smacro_table(&ctx->localmac, what);\n        }\n    } else {\n        if (what & CLEAR_ALLDEFINE)\n            clear_smacro_table(&smacros, what);\n        if (what & CLEAR_MMACRO)\n            free_mmacro_table(&mmacros);\n    }\n}", "target": 0}
{"code": "free_Digest(struct _7z_digests *d)\n{\n\tfree(d->defineds);\n\tfree(d->digests);\n}", "target": 0}
{"code": "bool PrintWebViewHelper::CalculateNumberOfPages(blink::WebLocalFrame* frame,\n                                                const blink::WebNode& node,\n                                                int* number_of_pages) {\n  DCHECK(frame);\n  bool fit_to_paper_size = !(PrintingNodeOrPdfFrame(frame, node));\n  if (!InitPrintSettings(fit_to_paper_size)) {\n    notify_browser_of_print_failure_ = false;\n    Send(new PrintHostMsg_ShowInvalidPrinterSettingsError(routing_id()));\n    return false;\n  }\n  const PrintMsg_Print_Params& params = print_pages_params_->params;\n  PrepareFrameAndViewForPrint prepare(params, frame, node, ignore_css_margins_);\n  prepare.StartPrinting();\n  *number_of_pages = prepare.GetExpectedPageCount();\n  return true;\n}", "target": 0}
{"code": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!start)\n\t\treturn true;\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static void oidc_authz_get_claims_and_idtoken(request_rec *r, json_t **claims,\n\t\tjson_t **id_token) {\n\tconst char *s_claims = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_CLAIMS);\n\tif (s_claims != NULL)\n\t\toidc_util_decode_json_object(r, s_claims, claims);\n\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\tif (s_id_token != NULL)\n\t\toidc_util_decode_json_object(r, s_id_token, id_token);\n}", "target": 0}
{"code": "parse_notification(struct rpki_uri *uri, struct update_notification **file)\n{\n\tstruct rdr_notification_ctx ctx;\n\tstruct update_notification *tmp;\n\tchar *dup;\n\tint error;\n\tdup = strdup(uri_get_global(uri));\n\tif (dup == NULL)\n\t\treturn pr_enomem();\n\terror = update_notification_create(&tmp);\n\tif (error)\n\t\treturn error;\n\ttmp->uri = dup;\n\tctx.notification = tmp;\n\terror = relax_ng_parse(uri_get_local(uri), xml_read_notification,\n\t    &ctx);\n\tif (error) {\n\t\tupdate_notification_destroy(tmp);\n\t\treturn error;\n\t}\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \tif (num_clips && clips_ptr) {\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}", "target": 1}
{"code": "xmlCreateMemoryParserCtxt(const char *buffer, int size) {\n    xmlParserCtxtPtr ctxt;\n    xmlParserInputPtr input;\n    xmlParserInputBufferPtr buf;\n    if (buffer == NULL)\n\treturn(NULL);\n    if (size <= 0)\n\treturn(NULL);\n    ctxt = xmlNewParserCtxt();\n    if (ctxt == NULL)\n\treturn(NULL);\n    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n    if (buf == NULL) {\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input = xmlNewInputStream(ctxt);\n    if (input == NULL) {\n\txmlFreeParserInputBuffer(buf);\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input->filename = NULL;\n    input->buf = buf;\n    xmlBufResetInput(input->buf->buffer, input);\n    inputPush(ctxt, input);\n    return(ctxt);\n}", "target": 0}
{"code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n  return clone;\n}", "target": 1}
{"code": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\tif (error)\n\t\treturn error;\n\tspin_lock_bh(&socket_client->lock);\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\tspin_unlock_bh(&socket_client->lock);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\tpacket_len = socket_packet->icmp_len;\n\tkfree(socket_packet);\n\tif (error)\n\t\treturn -EFAULT;\n\treturn packet_len;\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeSourceMapUrl() {\n  BYN_TRACE(\"== writeSourceMapUrl\\n\");\n  auto start = startSection(BinaryConsts::Section::User);\n  writeInlineString(BinaryConsts::UserSections::SourceMapUrl);\n  writeInlineString(sourceMapUrl.c_str());\n  finishSection(start);\n}", "target": 0}
{"code": " long ssl_get_algorithm2(SSL *s)\n        {\n        long alg2 = s->s3->tmp.new_cipher->algorithm2;\n       if (TLS1_get_version(s) >= TLS1_2_VERSION &&\n            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))\n                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;\n        return alg2;\n\t}", "target": 1}
{"code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\tatomic_thread_fence();\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 1}
{"code": "static inline void mpeg4_encode_dc(PutBitContext *s, int level, int n)\n{\n#if 1\n    level += 256;\n    if (n < 4) {\n        put_bits(s, uni_DCtab_lum_len[level], uni_DCtab_lum_bits[level]);\n    } else {\n        put_bits(s, uni_DCtab_chrom_len[level], uni_DCtab_chrom_bits[level]);\n    }\n#else\n    int size, v;\n    size = 0;\n    v    = abs(level);\n    while (v) {\n        v >>= 1;\n        size++;\n    }\n    if (n < 4) {\n        put_bits(s, ff_mpeg4_DCtab_lum[size][1], ff_mpeg4_DCtab_lum[size][0]);\n    } else {\n        put_bits(s, ff_mpeg4_DCtab_chrom[size][1], ff_mpeg4_DCtab_chrom[size][0]);\n    }\n    if (size > 0) {\n        if (level < 0)\n            level = (-level) ^ ((1 << size) - 1);\n        put_bits(s, size, level);\n        if (size > 8)\n            put_bits(s, 1, 1);\n    }\n#endif\n}", "target": 0}
{"code": "void LibRaw::adjust_bl()\n{\n  int clear_repeat=0;\n   if (O.user_black >= 0) \n     {\n       C.black = O.user_black;\n       clear_repeat = 1;\n     }\n   for(int i=0; i<4; i++)\n     if(O.user_cblack[i]>-1000000)\n       {\n         C.cblack[i] = O.user_cblack[i];\n         clear_repeat  = 1;\n       }\n   if(clear_repeat)\n     C.cblack[4]=C.cblack[5]=0;\n   if (imgdata.idata.filters > 1000 && (C.cblack[4]+1)/2 == 1 && (C.cblack[5]+1)/2 == 1) \n   {\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[c] += C.cblack[6 + c/2 % C.cblack[4] * C.cblack[5] + c%2 % C.cblack[5]];\n\t   C.cblack[4]=C.cblack[5]=0;\n   }\n   else if(imgdata.idata.filters <= 1000 && C.cblack[4]==1 && C.cblack[5]==1) \n   {\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[c] += C.cblack[6];\n\t   C.cblack[4]=C.cblack[5]=0;\n   }\n  int i = C.cblack[3];\n  int c;\n  for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c];\n  for(c=0;c<4;c++) C.cblack[c] -= i; \n  C.black += i;\n  if(C.cblack[4] && C.cblack[5])\n    {\n      i = C.cblack[6];\n      for(c=1; c<C.cblack[4]*C.cblack[5]; c++)\n        if(i>C.cblack[6+c]) i = C.cblack[6+c];\n      int nonz=0;\n      for(c=0; c<C.cblack[4]*C.cblack[5]; c++)\n        {\n          C.cblack[6+c]-=i;\n          if(C.cblack[6+c])nonz++;\n        }\n      C.black +=i;\n      if(!nonz)\n        C.cblack[4] = C.cblack[5] = 0;\n    }\n  for(c=0;c<4;c++) C.cblack[c] += C.black; \n}", "target": 0}
{"code": "monitor_allowed_key(u_char *blob, u_int bloblen)\n{\n\tif (key_blob == NULL || key_bloblen != bloblen ||\n\t    memcmp(key_blob, blob, key_bloblen))\n\t\treturn (0);\n\treturn (1);\n}", "target": 0}
{"code": "acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,\n\t\t     struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct buffer *req = s->req;\n\tstruct http_txn *txn = &s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tif (!s || !req)\n\t\treturn 0;\n\tif (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {\n\t\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\t\treturn 1;\n\t}\n\tif (unlikely(req->lr > req->data &&\n\t    (req->r < req->lr || req->r > req->data + req->size - global.tune.maxrewrite)) &&\n\t    (req->l <= req->size - global.tune.maxrewrite))\n\t\thttp_buffer_heavy_realign(req, msg);\n\tif (likely(req->lr < req->r))\n\t\thttp_msg_analyzer(req, msg, &txn->hdr_idx);\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY)) {\n\t\tif ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {\n\t\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\t\treturn 1;\n\t\t}\n\t\ttest->flags |= ACL_TEST_F_MAY_CHANGE;\n\t\treturn 0;\n\t}\n\tif (unlikely(req->lr > req->data &&\n\t    (req->r < req->lr || req->l > req->size - global.tune.maxrewrite ||\n\t     req->r > req->data + req->size - global.tune.maxrewrite))) {\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\t\treturn 1;\n\t}\n\ttxn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);\n\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\ts->flags |= SN_REDIRECTABLE;\n\tif (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {\n\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\treturn 1;\n\t}\n\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\treturn 1;\n}", "target": 0}
{"code": "static int nft_set_desc_concat_parse(const struct nlattr *attr,\n\t\t\t\t     struct nft_set_desc *desc)\n{\n\tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n\tu32 len;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n\t\t\t\t\t  nft_concat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_SET_FIELD_LEN])\n\t\treturn -EINVAL;\n\tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n\tif (len * BITS_PER_BYTE / 32 > NFT_REG32_COUNT)\n\t\treturn -E2BIG;\n\tdesc->field_len[desc->field_count++] = len;\n\treturn 0;\n}", "target": 1}
{"code": "int nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\t__net_timestamp(skb);\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\treturn nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\n}", "target": 1}
{"code": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tBUG_ON(new->thread_keyring);\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "void RemoteFsDevice::saveProperties(const DeviceOptions &newOpts, const Details &nd)\n{\n    bool connected=isConnected();\n    if (configured && (!connected || opts==newOpts) && (connected || details==nd)) {\n        return;\n    }\n    bool isLocal=details.isLocalFile();\n    if (connected) {\n        if (!configured) {\n            details.configured=configured=true;\n            details.save();\n        }\n        if (opts.useCache!=newOpts.useCache) {\n            if (opts.useCache) {\n                saveCache();\n            } else if (opts.useCache && !newOpts.useCache) {\n                removeCache();\n            }\n        }\n        opts=newOpts;\n        writeOpts(settingsFileName(), opts, true);\n    }\n    if (!connected || isLocal) {\n        Details newDetails=nd;\n        Details oldDetails=details;\n        bool newName=!oldDetails.name.isEmpty() && oldDetails.name!=newDetails.name;\n        bool newDir=oldDetails.url.path()!=newDetails.url.path();\n        if (isLocal && newDir && opts.useCache) {\n            removeCache();\n        }\n        details=newDetails;\n        details.configured=configured=true;\n        details.save();\n        if (newName) {\n            if (!details.isLocalFile()) {\n                QString oldMount=mountPoint(oldDetails, false);\n                if (!oldMount.isEmpty() && QDir(oldMount).exists()) {\n                    ::rmdir(QFile::encodeName(oldMount).constData());\n                }\n            }\n            setData(details.name);\n            renamed(oldDetails.name, details.name);\n            deviceId=createUdi(details.name);\n            emit udiChanged();\n            m_itemData=details.name;\n            setStatusMessage(QString());\n        }\n        if (isLocal && newDir && scanned) {\n            rescan(true);\n        }\n    }\n    emit configurationChanged();\n}", "target": 0}
{"code": "static MagickBooleanType ForwardQuadrantSwap(const size_t width,\n  const size_t height,double *source_pixels,double *forward_pixels)\n{\n  MagickBooleanType\n    status;\n  register ssize_t\n    x;\n  ssize_t\n    center,\n    y;\n  center=(ssize_t) (width/2L)+1L;\n  status=RollFourier((size_t) center,height,0L,(ssize_t) height/2L,\n    source_pixels);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[y*width+x+width/2L]=source_pixels[y*center+x];\n  for (y=1; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[(height-y)*width+width/2L-x-1L]=\n        source_pixels[y*center+x+1L];\n  for (x=0L; x < (ssize_t) (width/2L); x++)\n    forward_pixels[width/2L-x-1L]=source_pixels[x+1L];\n  return(MagickTrue);\n}", "target": 0}
{"code": "void diff_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(old_mode)\n\t\t\t&& S_ISGITLINK(new_mode))\n\t\treturn;\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF)) {\n\t\tunsigned tmp;\n\t\tconst unsigned char *tmp_c;\n\t\ttmp = old_mode; old_mode = new_mode; new_mode = tmp;\n\t\ttmp_c = old_sha1; old_sha1 = new_sha1; new_sha1 = tmp_c;\n\t}\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\tfill_filespec(one, old_sha1, old_mode);\n\tfill_filespec(two, new_sha1, new_mode);\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}", "target": 1}
{"code": "GF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;", "target": 0}
{"code": "compile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen, ambig;\n  OnigEncoding enc = reg->enc;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n  sn = NSTR(node);\n  if (sn->end <= sn->s)\n    return 0;\n  end = sn->end;\n  ambig = NSTRING_IS_AMBIG(node);\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg, ambig);\n      if (r) return r;\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n    p += len;\n  }\n  return add_compile_string(prev, prev_len, slen, reg, ambig);\n}", "target": 1}
{"code": "void cql_server::response::serialize(const event::schema_change& event, uint8_t version)\n{\n    if (version >= 3) {\n        write_string(to_string(event.change));\n        write_string(to_string(event.target));\n        write_string(event.keyspace);\n        switch (event.target) {\n        case event::schema_change::target_type::KEYSPACE:\n            break;\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::TABLE:\n            write_string(event.arguments[0]);\n            break;\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(event.arguments[0]);\n            write_string_list(std::vector<sstring>(event.arguments.begin() + 1, event.arguments.end()));\n            break;\n        }\n    } else {\n        switch (event.target) {\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(to_string(event::schema_change::change_type::UPDATED));\n            write_string(event.keyspace);\n            write_string(\"\");\n            break;\n        case event::schema_change::target_type::TABLE:\n        case event::schema_change::target_type::KEYSPACE:\n            write_string(to_string(event.change));\n            write_string(event.keyspace);\n            if (event.target == event::schema_change::target_type::TABLE) {\n                write_string(event.arguments[0]);\n            } else {\n                write_string(\"\");\n            }\n        }\n    }\n}", "target": 0}
{"code": "cdf_read_short_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_dir_t *dir, cdf_stream_t *scn,\n    const cdf_directory_t **root)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\t*root = NULL;\n\tfor (i = 0; i < dir->dir_len; i++)\n\t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)\n\t\t\tbreak;\n\tif (i == dir->dir_len)\n\t\tgoto out;\n\td = &dir->dir_tab[i];\n\t*root = d;\n\tif (d->d_stream_first_sector < 0)\n\t\tgoto out;\n\treturn\tcdf_read_long_sector_chain(info, h, sat,\n\t    d->d_stream_first_sector, d->d_size, scn);\nout:\n\tscn->sst_tab = NULL;\n\tscn->sst_len = 0;\n\tscn->sst_dirlen = 0;\n\treturn 0;\n}", "target": 0}
{"code": "PHP_FUNCTION(snmp_set_valueretrieval)\n{\n\tzend_long method;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &method) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (method >= 0 && method <= (SNMP_VALUE_LIBRARY|SNMP_VALUE_PLAIN|SNMP_VALUE_OBJECT)) {\n\t\t\tSNMP_G(valueretrieval) = method;\n\t\t\tRETURN_TRUE;\n\t} else {\n\t\tphp_error_docref(NULL, E_WARNING, \"Unknown SNMP value retrieval method '%pd'\", method);\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0}
{"code": "int htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -ETIMEDOUT;\n\t}\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 1}
{"code": "xmlParseCheckTransition(xmlParserCtxtPtr ctxt, const char *chunk, int size) {\n    if ((ctxt == NULL) || (chunk == NULL) || (size < 0))\n        return(-1);\n    if (ctxt->instate == XML_PARSER_START_TAG) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->progressive == XML_PARSER_COMMENT) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->instate == XML_PARSER_CDATA_SECTION) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->progressive == XML_PARSER_PI) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->instate == XML_PARSER_END_TAG) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if ((ctxt->progressive == XML_PARSER_DTD) ||\n        (ctxt->instate == XML_PARSER_DTD)) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    return(1);\n}", "target": 0}
{"code": "spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "    static bool is4ByteType(uint16_t type)\n    {\n        return isLongType(type)\n            || isRationalType(type)\n            ;\n    }", "target": 0}
{"code": "void FAST_FUNC udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt)\n{\n\tunsigned len;\n\tuint8_t *optionptr = packet->options;\n\tunsigned end = udhcp_end_option(optionptr);\n\tlen = OPT_DATA + addopt[OPT_LEN];\n\tif (end + len + 1 >= DHCP_OPTIONS_BUFSIZE) {\n\t\tbb_error_msg(\"option 0x%02x did not fit into the packet\",\n\t\t\t\taddopt[OPT_CODE]);\n\t\treturn;\n\t}\n\tlog_option(\"Adding option\", addopt);\n\tmemcpy(optionptr + end, addopt, len);\n\toptionptr[end + len] = DHCP_END;\n}", "target": 0}
{"code": "spnego_gss_inquire_names_for_mech(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tgss_OID\t\tmechanism,\n\t\t\t\tgss_OID_set\t*name_types)\n{\n\tOM_uint32   major, minor;\n\tdsyslog(\"Entering inquire_names_for_mech\\n\");\n\tif ((mechanism != GSS_C_NULL_OID) &&\n\t    !g_OID_equal(gss_mech_spnego, mechanism)) {\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tmajor = gss_create_empty_oid_set(minor_status, name_types);\n\tif (major == GSS_S_COMPLETE) {\n\t\tif (((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_USER_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_MACHINE_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_STRING_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE)) {\n\t\t\tmajor = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\tname_types);\n\t\t}\n\t\tif (major != GSS_S_COMPLETE)\n\t\t\t(void) gss_release_oid_set(&minor, name_types);\n\t}\n\tdsyslog(\"Leaving inquire_names_for_mech\\n\");\n\treturn (major);\n}", "target": 0}
{"code": "static int bus_socket_make_message(sd_bus *bus, size_t size) {\n        sd_bus_message *t;\n        void *b;\n        int r;\n        assert(bus);\n        assert(bus->rbuffer_size >= size);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n        if (bus->rbuffer_size > size) {\n                b = memdup((const uint8_t*) bus->rbuffer + size,\n                           bus->rbuffer_size - size);\n                if (!b)\n                        return -ENOMEM;\n        } else\n                b = NULL;\n        r = bus_message_from_malloc(bus,\n                                    bus->rbuffer, size,\n                                    bus->fds, bus->n_fds,\n                                    NULL,\n                                    &t);\n        if (r < 0) {\n                free(b);\n                return r;\n        }\n        bus->rbuffer = b;\n        bus->rbuffer_size -= size;\n        bus->fds = NULL;\n        bus->n_fds = 0;\n        bus->rqueue[bus->rqueue_size++] = t;\n        return 1;\n}", "target": 1}
{"code": "_asn1_delete_list (void)\n{\n  list_type *listElement;\n  while (firstElement)\n    {\n      listElement = firstElement;\n      firstElement = firstElement->next;\n      free (listElement);\n    }\n}", "target": 0}
{"code": "strncat_from_utf8_libarchive2(struct archive_string *as,\n    const void *_p, size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tint n;\n\tchar *p;\n\tchar *end;\n\tuint32_t unicode;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\t(void)sc; \n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {\n\t\twchar_t wc;\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\twc = L'?';\n\t\t} else\n\t\t\twc = (wchar_t)unicode;\n\t\ts += n;\n\t\tlen -= n;\n#if HAVE_WCRTOMB\n\t\tn = (int)wcrtomb(p, wc, &shift_state);\n#else\n\t\tn = (int)wctomb(p, wc);\n#endif\n\t\tif (n == -1)\n\t\t\treturn (-1);\n\t\tp += n;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (0);\n}", "target": 1}
{"code": " bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n  if (render_view_host_->IsSwappedOut()) {\n    if (!SwappedOutMessages::CanHandleWhileSwappedOut(msg)) {\n      if (msg.is_sync()) {\n        IPC::Message* reply = IPC::SyncMessage::GenerateReply(&msg);\n        reply->set_reply_error();\n        Send(reply);\n      }\n      return true;\n    }\n  }\n   if (delegate_->OnMessageReceived(this, msg))\n     return true;\n  if (cross_process_frame_connector_ &&\n      cross_process_frame_connector_->OnMessageReceived(msg))\n    return true;\n  bool handled = true;\n  bool msg_is_ok = true;\n  IPC_BEGIN_MESSAGE_MAP_EX(RenderFrameHostImpl, msg, msg_is_ok)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartProvisionalLoadForFrame,\n                        OnDidStartProvisionalLoadForFrame)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n                        OnDidFailProvisionalLoadWithError)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidRedirectProvisionalLoad,\n                        OnDidRedirectProvisionalLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailLoadWithError,\n                        OnDidFailLoadWithError)\n    IPC_MESSAGE_HANDLER_GENERIC(FrameHostMsg_DidCommitProvisionalLoad,\n                                OnNavigate(msg))\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartLoading, OnDidStartLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStopLoading, OnDidStopLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_OpenURL, OnOpenURL)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_BeforeUnload_ACK, OnBeforeUnloadACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SwapOut_ACK, OnSwapOutACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ContextMenu, OnContextMenu)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_JavaScriptExecuteResponse,\n                        OnJavaScriptExecuteResponse)\n  IPC_END_MESSAGE_MAP_EX()\n  if (!msg_is_ok) {\n    RecordAction(base::UserMetricsAction(\"BadMessageTerminate_RFH\"));\n    GetProcess()->ReceivedBadMessage();\n  }\n  return handled;\n}", "target": 0}
{"code": "ospf_make_md5_digest (struct ospf_interface *oi, struct ospf_packet *op)\n{\n  struct ospf_header *ospfh;\n  unsigned char digest[OSPF_AUTH_MD5_SIZE];\n  MD5_CTX ctx;\n  void *ibuf;\n  u_int32_t t;\n  struct crypt_key *ck;\n  const u_int8_t *auth_key;\n  ibuf = STREAM_DATA (op->s);\n  ospfh = (struct ospf_header *) ibuf;\n  if (ntohs (ospfh->auth_type) != OSPF_AUTH_CRYPTOGRAPHIC)\n    return 0;\n  t = (time(NULL) & 0xFFFFFFFF);\n  if (t > oi->crypt_seqnum)\n    oi->crypt_seqnum = t;\n  else\n    oi->crypt_seqnum++;\n  ospfh->u.crypt.crypt_seqnum = htonl (oi->crypt_seqnum); \n  if (list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))\n    auth_key = (const u_int8_t *) \"\";\n  else\n    {\n      ck = listgetdata (listtail(OSPF_IF_PARAM (oi, auth_crypt)));\n      auth_key = ck->auth_key;\n    }\n  memset(&ctx, 0, sizeof(ctx));\n  MD5Init(&ctx);\n  MD5Update(&ctx, ibuf, ntohs (ospfh->length));\n  MD5Update(&ctx, auth_key, OSPF_AUTH_MD5_SIZE);\n  MD5Final(digest, &ctx);\n  stream_put (op->s, digest, OSPF_AUTH_MD5_SIZE);\n  op->length = ntohs (ospfh->length) + OSPF_AUTH_MD5_SIZE;\n  if (stream_get_endp(op->s) != op->length)\n    zlog_warn(\"ospf_make_md5_digest: length mismatch stream %lu ospf_packet %u\",\n\t      (u_long)stream_get_endp(op->s), op->length);\n  return OSPF_AUTH_MD5_SIZE;\n}", "target": 0}
{"code": "_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  char *last_elem, *wp;\n  last_elem = wp = result;\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n  *wp = '\\0';\n  return result;\n}", "target": 1}
{"code": "int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info)\n{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t  type->policy, NULL);\n\tif (err < 0)\n\t\tgoto err_nla_parse;\n\tinfo->attr = nla;\n\tinfo->ops = type->inner_ops;\n\treturn 0;\nerr_nla_parse:\n\treturn err;\n}", "target": 1}
{"code": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"%p\\n\", sock);\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &llcp_rawsock_ops;\n\telse\n\t\tsock->ops = &llcp_sock_ops;\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_convert)\n{\n\tzval *pgsql_link, *values;\n\tchar *table_name;\n\tsize_t table_name_len;\n\tzend_ulong option = 0;\n\tPGconn *pg_link;\n\tint id = -1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(),\n\t\t\t\t\t\t\t  \"rsa|l\", &pgsql_link, &table_name, &table_name_len, &values, &option) == FAILURE) {\n\t\treturn;\n\t}\n\tif (option & ~PGSQL_CONV_OPTS) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Invalid option is specified\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!table_name_len) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Table name is invalid\");\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE2(pg_link, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tif (php_pgsql_flush_query(pg_link)) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Detected unhandled result(s) in connection\");\n\t}\n\tarray_init(return_value);\n\tif (php_pgsql_convert(pg_link, table_name, values, return_value, option) == FAILURE) {\n\t\tzval_dtor(return_value);\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0}
{"code": "        int          GetS8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            if ( nRes & 0x80 )\n                nRes |= ~0xff;\n            return nRes;\n        }", "target": 1}
{"code": "int get_compat_itimerspec(struct itimerspec *dst,\n\t\t\t  const struct compat_itimerspec __user *src)\n{\n\tif (__compat_get_timespec(&dst->it_interval, &src->it_interval) ||\n\t    __compat_get_timespec(&dst->it_value, &src->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "void RGWPutObj_ObjStore_S3::send_response()\n{\n  if (op_ret) {\n    set_req_state_err(s, op_ret);\n    dump_errno(s);\n  } else {\n    if (s->cct->_conf->rgw_s3_success_create_obj_status) {\n      op_ret = get_success_retcode(\n\ts->cct->_conf->rgw_s3_success_create_obj_status);\n      set_req_state_err(s, op_ret);\n    }\n    if (copy_source.empty()) {\n      dump_errno(s);\n      dump_etag(s, etag);\n      dump_content_length(s, 0);\n      dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n      for (auto &it : crypt_http_responses)\n        dump_header(s, it.first, it.second);\n    } else {\n      dump_errno(s);\n      dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n      end_header(s, this, \"application/xml\");\n      dump_start(s);\n      struct tm tmp;\n      utime_t ut(mtime);\n      time_t secs = (time_t)ut.sec();\n      gmtime_r(&secs, &tmp);\n      char buf[TIME_BUF_SIZE];\n      s->formatter->open_object_section_in_ns(\"CopyPartResult\",\n          \"http:\n      if (strftime(buf, sizeof(buf), \"%Y-%m-%dT%T.000Z\", &tmp) > 0) {\n        s->formatter->dump_string(\"LastModified\", buf);\n      }\n      s->formatter->dump_string(\"ETag\", etag);\n      s->formatter->close_section();\n      rgw_flush_formatter_and_reset(s, s->formatter);\n      return;\n    }\n  }\n  if (append) {\n    if (op_ret == 0 || op_ret == -ERR_POSITION_NOT_EQUAL_TO_LENGTH) {\n      dump_header(s, \"x-rgw-next-append-position\", cur_accounted_size);\n    }\n  }\n  if (s->system_request && !real_clock::is_zero(mtime)) {\n    dump_epoch_header(s, \"Rgwx-Mtime\", mtime);\n  }\n  end_header(s, this);\n}", "target": 0}
{"code": "static int check_stack_write_var_off(struct bpf_verifier_env *env,\n\t\t\t\t     struct bpf_func_state *state,\n\t\t\t\t     int ptr_regno, int off, int size,\n\t\t\t\t     int value_regno, int insn_idx)\n{\n\tstruct bpf_func_state *cur; \n\tint min_off, max_off;\n\tint i, err;\n\tstruct bpf_reg_state *ptr_reg = NULL, *value_reg = NULL;\n\tbool writing_zero = false;\n\tbool zero_used = false;\n\tcur = env->cur_state->frame[env->cur_state->curframe];\n\tptr_reg = &cur->regs[ptr_regno];\n\tmin_off = ptr_reg->smin_value + off;\n\tmax_off = ptr_reg->smax_value + off + size;\n\tif (value_regno >= 0)\n\t\tvalue_reg = &cur->regs[value_regno];\n\tif (value_reg && register_is_null(value_reg))\n\t\twriting_zero = true;\n\terr = grow_stack_state(state, round_up(-min_off, BPF_REG_SIZE));\n\tif (err)\n\t\treturn err;\n\tfor (i = min_off; i < max_off; i++) {\n\t\tu8 new_type, *stype;\n\t\tint slot, spi;\n\t\tslot = -i - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n\t\tif (!env->allow_ptr_leaks\n\t\t\t\t&& *stype != NOT_INIT\n\t\t\t\t&& *stype != SCALAR_VALUE) {\n\t\t\tverbose(env, \"spilled ptr in range of var-offset stack write; insn %d, ptr off: %d\",\n\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstate->stack[spi].spilled_ptr.type = NOT_INIT;\n\t\tnew_type = STACK_MISC;\n\t\tif (writing_zero && *stype == STACK_ZERO) {\n\t\t\tnew_type = STACK_ZERO;\n\t\t\tzero_used = true;\n\t\t}\n\t\tif (*stype == STACK_INVALID && !env->allow_uninit_stack) {\n\t\t\tverbose(env, \"uninit stack in range of var-offset write prohibited for !root; insn %d, off: %d\",\n\t\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*stype = new_type;\n\t}\n\tif (zero_used) {\n\t\terr = mark_chain_precision(env, value_regno);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void perf_event_comm_event(struct perf_comm_event *comm_event)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tchar comm[TASK_COMM_LEN];\n\tunsigned int size;\n\tstruct pmu *pmu;\n\tint ctxn;\n\tmemset(comm, 0, sizeof(comm));\n\tstrlcpy(comm, comm_event->task->comm, sizeof(comm));\n\tsize = ALIGN(strlen(comm)+1, sizeof(u64));\n\tcomm_event->comm = comm;\n\tcomm_event->comm_size = size;\n\tcomm_event->event_id.header.size = sizeof(comm_event->event_id) + size;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tgoto next;\n\t\tperf_event_comm_ctx(&cpuctx->ctx, comm_event);\n\t\tctxn = pmu->task_ctx_nr;\n\t\tif (ctxn < 0)\n\t\t\tgoto next;\n\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\tif (ctx)\n\t\t\tperf_event_comm_ctx(ctx, comm_event);\nnext:\n\t\tput_cpu_ptr(pmu->pmu_cpu_context);\n\t}\n\trcu_read_unlock();\n}", "target": 0}
{"code": "static UINT ExtractRunLengthRegularFgBg(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\trunLength = (*pbOrderHdr) & g_MaskRegularRunLength;\n\tif (runLength == 0)\n\t{\n\t\tif (!buffer_within_range(pbOrderHdr, 1, pbEnd))\n\t\t{\n\t\t\t*advance = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trunLength = *(pbOrderHdr + 1) + 1;\n\t\t(*advance)++;\n\t}\n\telse\n\t\trunLength = runLength * 8;\n\treturn runLength;\n}", "target": 1}
{"code": "static int selinux_key_permission(key_ref_t key_ref,\n\t\t\t\t  const struct cred *cred,\n\t\t\t\t  unsigned perm)\n{\n\tstruct key *key;\n\tstruct key_security_struct *ksec;\n\tu32 sid;\n\tif (perm == 0)\n\t\treturn 0;\n\tsid = cred_sid(cred);\n\tkey = key_ref_to_ptr(key_ref);\n\tksec = key->security;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, ksec->sid, SECCLASS_KEY, perm, NULL);\n}", "target": 0}
{"code": "static void put_prev_entity(struct cfs_rq *cfs_rq, struct sched_entity *prev)\n{\n\tif (prev->on_rq)\n\t\tupdate_curr(cfs_rq);\n\tcheck_spread(cfs_rq, prev);\n\tif (prev->on_rq) {\n\t\tupdate_stats_wait_start(cfs_rq, prev);\n\t\t__enqueue_entity(cfs_rq, prev);\n\t}\n\tcfs_rq->curr = NULL;\n}", "target": 0}
{"code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}", "target": 1}
{"code": "static zend_long firebird_handle_doer(pdo_dbh_t *dbh, const char *sql, size_t sql_len) \n{\n\tpdo_firebird_db_handle *H = (pdo_firebird_db_handle *)dbh->driver_data;\n\tisc_stmt_handle stmt = PDO_FIREBIRD_HANDLE_INITIALIZER;\n\tstatic char const info_count[] = { isc_info_sql_records };\n\tchar result[64];\n\tint ret = 0;\n\tXSQLDA in_sqlda, out_sqlda;\n\tin_sqlda.version = out_sqlda.version = PDO_FB_SQLDA_VERSION;\n\tin_sqlda.sqld = out_sqlda.sqld = 0;\n\tout_sqlda.sqln = 1;\n\tif (!firebird_alloc_prepare_stmt(dbh, sql, sql_len, &out_sqlda, &stmt, 0)) {\n\t\treturn -1;\n\t}\n\tif (isc_dsql_execute2(H->isc_status, &H->tr, &stmt, PDO_FB_SQLDA_VERSION, &in_sqlda, &out_sqlda)) {\n\t\tRECORD_ERROR(dbh);\n\t\tret = -1;\n\t\tgoto free_statement;\n\t}\n\tif (isc_dsql_sql_info(H->isc_status, &stmt, sizeof(info_count), const_cast(info_count),\n\t\t\tsizeof(result),\tresult)) {\n\t\tRECORD_ERROR(dbh);\n\t\tret = -1;\n\t\tgoto free_statement;\n\t}\n\tif (result[0] == isc_info_sql_records) {\n\t\tunsigned i = 3, result_size = isc_vax_integer(&result[1],2);\n\t\twhile (result[i] != isc_info_end && i < result_size) {\n\t\t\tshort len = (short)isc_vax_integer(&result[i+1],2);\n\t\t\tif (result[i] != isc_info_req_select_count) {\n\t\t\t\tret += isc_vax_integer(&result[i+3],len);\n\t\t\t}\n\t\t\ti += len+3;\n\t\t}\n\t}\n\tif (dbh->auto_commit && isc_commit_retaining(H->isc_status, &H->tr)) {\n\t\tRECORD_ERROR(dbh);\n\t}\nfree_statement:\n\tif (isc_dsql_free_statement(H->isc_status, &stmt, DSQL_drop)) {\n\t\tRECORD_ERROR(dbh);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static const gchar* fcwwn_name_res_str(const address* addr)\n{\n    const guint8 *addrp = (const guint8*)addr->data;\n    int fmt;\n    guint8 oui[6];\n    fmt = (addrp[0] & 0xF0) >> 4;\n    switch (fmt) {\n    case FC_NH_NAA_IEEE:\n    case FC_NH_NAA_IEEE_E:\n        memcpy (oui, &addrp[2], 6);\n        return get_manuf_name(oui);\n    case FC_NH_NAA_IEEE_R:\n        oui[0] = ((addrp[0] & 0x0F) << 4) | ((addrp[1] & 0xF0) >> 4);\n        oui[1] = ((addrp[1] & 0x0F) << 4) | ((addrp[2] & 0xF0) >> 4);\n        oui[2] = ((addrp[2] & 0x0F) << 4) | ((addrp[3] & 0xF0) >> 4);\n        oui[3] = ((addrp[3] & 0x0F) << 4) | ((addrp[4] & 0xF0) >> 4);\n        oui[4] = ((addrp[4] & 0x0F) << 4) | ((addrp[5] & 0xF0) >> 4);\n        oui[5] = ((addrp[5] & 0x0F) << 4) | ((addrp[6] & 0xF0) >> 4);\n        return get_manuf_name(oui);\n    }\n    return \"\";\n}", "target": 1}
{"code": "AirPDcapRsnaPwd2PskStep(\n    const guint8 *ppBytes,\n    const guint ppLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n{\n    UCHAR digest[MAX_SSID_LENGTH+4];  \n    UCHAR digest1[SHA1_DIGEST_LEN];\n    INT i, j;\n    if (ssidLength > MAX_SSID_LENGTH) {\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    memset(digest, 0, sizeof digest);\n    memset(digest1, 0, sizeof digest1);\n    memcpy(digest, ssid, ssidLength);\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\n    sha1_hmac(ppBytes, ppLength, digest, (guint32) ssidLength+4, digest1);\n    memcpy(output, digest1, SHA1_DIGEST_LEN);\n    for (i = 1; i < iterations; i++) {\n        sha1_hmac(ppBytes, ppLength, digest1, SHA1_DIGEST_LEN, digest);\n        memcpy(digest1, digest, SHA1_DIGEST_LEN);\n        for (j = 0; j < SHA1_DIGEST_LEN; j++) {\n            output[j] ^= digest[j];\n        }\n    }\n    return AIRPDCAP_RET_SUCCESS;\n}", "target": 0}
{"code": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\treturn ip_local_out(skb);\n}", "target": 1}
{"code": "static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\topl3_set_instr(dev, voice, info->pgm_num);\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}", "target": 1}
{"code": "    bool replaceHostInUri( std::string& uri, const char* szHost, const char* szPort ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            return false ;\n        }\n        url->url_host = szHost ;\n        url->url_port = szPort ;\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, 1, url, params, comment) ;\n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }", "target": 1}
{"code": "bool Curl_meets_timecondition(struct Curl_easy *data, time_t timeofdoc)\n{\n  if((timeofdoc == 0) || (data->set.timevalue == 0))\n    return TRUE;\n  switch(data->set.timecondition) {\n  case CURL_TIMECOND_IFMODSINCE:\n  default:\n    if(timeofdoc <= data->set.timevalue) {\n      infof(data,\n            \"The requested document is not new enough\");\n      data->info.timecond = TRUE;\n      return FALSE;\n    }\n    break;\n  case CURL_TIMECOND_IFUNMODSINCE:\n    if(timeofdoc >= data->set.timevalue) {\n      infof(data,\n            \"The requested document is not old enough\");\n      data->info.timecond = TRUE;\n      return FALSE;\n    }\n    break;\n  }\n  return TRUE;\n}", "target": 0}
{"code": "build_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "target": 1}
{"code": "void Clipboard::WriteWebSmartPaste() {\n  InsertMapping(kMimeTypeWebkitSmartPaste, NULL, 0);\n}", "target": 0}
{"code": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 1}
{"code": "int sctp_ulpq_tail_data(struct sctp_ulpq *ulpq, struct sctp_chunk *chunk,\n\t\t\tgfp_t gfp)\n{\n\tstruct sk_buff_head temp;\n\tsctp_data_chunk_t *hdr;\n\tstruct sctp_ulpevent *event;\n\thdr = (sctp_data_chunk_t *) chunk->chunk_hdr;\n\tevent = sctp_ulpevent_make_rcvmsg(chunk->asoc, chunk, gfp);\n\tif (!event)\n\t\treturn -ENOMEM;\n\tevent = sctp_ulpq_reasm(ulpq, event);\n\tif ((event) && (event->msg_flags & MSG_EOR)){\n\t\tskb_queue_head_init(&temp);\n\t\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\t\tevent = sctp_ulpq_order(ulpq, event);\n\t}\n\tif (event)\n\t\tsctp_ulpq_tail_event(ulpq, event);\n\treturn 0;\n}", "target": 0}
{"code": "static inline struct sk_buff *__skb_dequeue(struct sk_buff_head *list)\n{\n\tstruct sk_buff *skb = skb_peek(list);\n\tif (skb)\n\t\t__skb_unlink(skb, list);\n\treturn skb;\n}", "target": 0}
{"code": "iasecc_init_amos_or_sagem(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned int flags;\n\tint rv = 0;\n\tLOG_FUNC_CALLED(ctx);\n\tflags = IASECC_CARD_DEFAULT_FLAGS;\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0x10001);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0x10001);\n\tcard->caps = IASECC_CARD_DEFAULT_CAPS;\n\tif (card->type == SC_CARD_TYPE_IASECC_MI)   {\n\t\trv = iasecc_mi_match(card);\n\t\tif (rv)\n\t\t\tcard->type = SC_CARD_TYPE_IASECC_MI2;\n\t\telse\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\trv = iasecc_parse_ef_atr(card);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)   {\n\t\trv = iasecc_select_mf(card, NULL);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\t\trv = iasecc_parse_ef_atr(card);\n\t}\n\tLOG_TEST_RET(ctx, rv, \"IASECC: ATR parse failed\");\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}", "target": 0}
{"code": "void SSH_Access::LogSSHMessage()\n{\n   const char *b;\n   int s;\n   pty_recv_buf->Get(&b,&s);\n   const char *eol=find_char(b,s,'\\n');\n   if(!eol)\n   {\n      if(pty_recv_buf->Eof())\n      {\n\t if(s>0)\n\t    LogRecv(4,b);\n\t LogError(0,_(\"Peer closed connection\"));\n      }\n      if(pty_recv_buf->Error())\n\t LogError(4,\"pty read: %s\",pty_recv_buf->ErrorText());\n      if(pty_recv_buf->Eof() || pty_recv_buf->Error()) {\n\t if(last_ssh_message && time_t(now)-last_ssh_message_time<4)\n\t    LogError(0,\"%s\",last_ssh_message.get());\n\t Disconnect(last_ssh_message);\n      }\n      return;\n   }\n   s=eol-b+1;\n   int chomp_cr=(s>=2 && b[s-2]=='\\r');\n   last_ssh_message.nset(b,s-1-chomp_cr);\n   last_ssh_message_time=now;\n   pty_recv_buf->Skip(s);\n   LogRecv(4,last_ssh_message);\n   if(last_ssh_message.begins_with(\"ssh: \"))\n      last_ssh_message.set(last_ssh_message+5);\n   if(!received_greeting && last_ssh_message.eq(greeting))\n      received_greeting=true;\n}", "target": 0}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct skcipher_tfm *tfm;\n\tstruct crypto_ablkcipher *skcipher;\n\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n\tif (!tfm)\n\t\treturn ERR_PTR(-ENOMEM);\n\tskcipher = crypto_alloc_ablkcipher(name, type, mask);\n\tif (IS_ERR(skcipher)) {\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(skcipher);\n\t}\n\ttfm->skcipher = skcipher;\n\treturn tfm;\n}", "target": 0}
{"code": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromLocalPort(port);\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}", "target": 1}
{"code": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n    return retval;\n}                               ", "target": 1}
{"code": "static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)\n{\n  unsigned result = 0;\n  size_t i;\n  for(i = nbits - 1; i < nbits; i--)\n  {\n    result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;\n  }\n  return result;\n}", "target": 0}
{"code": "static int test_ifdefine_section(cmd_parms *cmd, const char *arg)\n{\n    return ap_exists_config_define(arg);\n}", "target": 0}
{"code": "static void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st)\n{\n\tstruct blkif_response  resp;\n\tunsigned long     flags;\n\tunion blkif_back_rings *blk_rings;\n\tint notify;\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n\tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n\tblk_rings = &ring->blk_rings;\n\tswitch (ring->blkif->blk_protocol) {\n\tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tblk_rings->common.rsp_prod_pvt++;\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n\tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}", "target": 1}
{"code": "static PyObject *convert_slist(struct curl_slist *slist, int free_flags)\n{\n    PyObject *ret = NULL;\n    struct curl_slist *slist_start = slist;\n    ret = PyList_New((Py_ssize_t)0);\n    if (ret == NULL) goto error;\n    for ( ; slist != NULL; slist = slist->next) {\n        PyObject *v = NULL;\n        if (slist->data == NULL) {\n            v = Py_None; Py_INCREF(v);\n        } else {\n            v = PyText_FromString(slist->data);\n        }\n        if (v == NULL || PyList_Append(ret, v) != 0) {\n            Py_XDECREF(v);\n            goto error;\n        }\n        Py_DECREF(v);\n    }\n    if ((free_flags & 1) && slist_start)\n        curl_slist_free_all(slist_start);\n    return ret;\nerror:\n    Py_XDECREF(ret);\n    if ((free_flags & 2) && slist_start)\n        curl_slist_free_all(slist_start);\n    return NULL;\n}", "target": 0}
{"code": "static void flush_busy_ctxs(struct blk_mq_hw_ctx *hctx, struct list_head *list)\n{\n\tstruct blk_mq_ctx *ctx;\n\tint i;\n\tfor (i = 0; i < hctx->ctx_map.size; i++) {\n\t\tstruct blk_align_bitmap *bm = &hctx->ctx_map.map[i];\n\t\tunsigned int off, bit;\n\t\tif (!bm->word)\n\t\t\tcontinue;\n\t\tbit = 0;\n\t\toff = i * hctx->ctx_map.bits_per_word;\n\t\tdo {\n\t\t\tbit = find_next_bit(&bm->word, bm->depth, bit);\n\t\t\tif (bit >= bm->depth)\n\t\t\t\tbreak;\n\t\t\tctx = hctx->ctxs[bit + off];\n\t\t\tclear_bit(bit, &bm->word);\n\t\t\tspin_lock(&ctx->lock);\n\t\t\tlist_splice_tail_init(&ctx->rq_list, list);\n\t\t\tspin_unlock(&ctx->lock);\n\t\t\tbit++;\n\t\t} while (1);\n\t}\n}", "target": 0}
{"code": "static inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\tdentry->d_inode = inode;\n\tsmp_wmb();\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tWRITE_ONCE(dentry->d_flags, flags);\n}", "target": 0}
{"code": "static int fuse_get_user_pages(struct fuse_req *req, const char __user *buf,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = *nbytesp;\n\tunsigned long user_addr = (unsigned long) buf;\n\tunsigned offset = user_addr & ~PAGE_MASK;\n\tint npages;\n\tif (segment_eq(get_fs(), KERNEL_DS)) {\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\t\treturn 0;\n\t}\n\tnbytes = min_t(size_t, nbytes, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n\tnpages = (nbytes + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tnpages = clamp(npages, 1, FUSE_MAX_PAGES_PER_REQ);\n\tdown_read(&current->mm->mmap_sem);\n\tnpages = get_user_pages(current, current->mm, user_addr, npages, !write,\n\t\t\t\t0, req->pages, NULL);\n\tup_read(&current->mm->mmap_sem);\n\tif (npages < 0)\n\t\treturn npages;\n\treq->num_pages = npages;\n\treq->page_offset = offset;\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\tnbytes = (req->num_pages << PAGE_SHIFT) - req->page_offset;\n\t*nbytesp = min(*nbytesp, nbytes);\n\treturn 0;\n}", "target": 0}
{"code": "void ConnectDialogEdit::on_qbFill_clicked() {\n\tQ_ASSERT(m_si);\n\tqwInlineNotice->hide();\n\tadjustSize();\n\tqleName->setText(m_si->qsName);\n\tqleServer->setText(m_si->qsHostname);\n\tqleUsername->setText(m_si->qsUsername);\n\tqlePort->setText(QString::number(m_si->usPort));\n\tqlePassword->setText(m_si->qsPassword);\n\tdelete m_si;\n\tm_si = NULL;\n}", "target": 0}
{"code": "static void fuse_lib_init(void *data, struct fuse_conn_info *conn)\n{\n    struct fuse *f = (struct fuse *) data;\n    struct fuse_context_i *c = fuse_get_context_internal();\n    memset(c, 0, sizeof(*c));\n    c->ctx.fuse = f;\n    fuse_fs_init(f->fs, conn);\n}", "target": 0}
{"code": "static char *exif_get_sectionlist(int sectionlist)\n{\n\tint i, len, ml = 0;\n\tchar *sections;\n\tfor(i=0; i<SECTION_COUNT; i++) {\n\t\tml += strlen(exif_get_sectionname(i))+2;\n\t}\n\tsections = safe_emalloc(ml, 1, 1);\n\tsections[0] = '\\0';\n\tlen = 0;\n\tfor(i=0; i<SECTION_COUNT; i++) {\n\t\tif (sectionlist&(1<<i)) {\n\t\t\tsnprintf(sections+len, ml-len, \"%s, \", exif_get_sectionname(i));\n\t\t\tlen = strlen(sections);\n\t\t}\n\t}\n\tif (len>2)\n\t\tsections[len-2] = '\\0';\n\treturn sections;\n}", "target": 0}
{"code": "void RenderLayerCompositor::frameViewDidScroll()\n{\n    FrameView* frameView = m_renderView->frameView();\n    IntPoint scrollPosition = frameView->scrollPosition();\n    if (!m_scrollLayer)\n        return;\n    bool scrollingCoordinatorHandlesOffset = false;\n    if (ScrollingCoordinator* scrollingCoordinator = this->scrollingCoordinator()) {\n        if (Settings* settings = m_renderView->document().settings()) {\n            if (isMainFrame() || settings->compositedScrollingForFramesEnabled())\n                scrollingCoordinatorHandlesOffset = scrollingCoordinator->scrollableAreaScrollLayerDidChange(frameView);\n        }\n    }\n    if (scrollingCoordinatorHandlesOffset)\n        m_scrollLayer->setPosition(-frameView->minimumScrollPosition());\n    else\n        m_scrollLayer->setPosition(-scrollPosition);\n    blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n        ScrolledMainFrameBucket,\n        AcceleratedFixedRootBackgroundHistogramMax);\n     if (!m_renderView->rootBackgroundIsEntirelyFixed())\n         return;\n     blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n         !!fixedRootBackgroundLayer()\n             ? ScrolledMainFrameWithAcceleratedFixedRootBackground\n            : ScrolledMainFrameWithUnacceleratedFixedRootBackground,\n        AcceleratedFixedRootBackgroundHistogramMax);\n}", "target": 1}
{"code": "void BrowserTitlebar::UpdateThrobber(TabContents* tab_contents) {\n  DCHECK(app_mode_favicon_);\n  if (tab_contents && tab_contents->is_loading()) {\n    GdkPixbuf* icon_pixbuf =\n        throbber_.GetNextFrame(tab_contents->waiting_for_response());\n    gtk_image_set_from_pixbuf(GTK_IMAGE(app_mode_favicon_), icon_pixbuf);\n  } else {\n    ResourceBundle& rb = ResourceBundle::GetSharedInstance();\n    if (browser_window_->browser()->type() == Browser::TYPE_APP) {\n      SkBitmap icon = browser_window_->browser()->GetCurrentPageIcon();\n      if (icon.empty()) {\n        gtk_image_set_from_pixbuf(GTK_IMAGE(app_mode_favicon_),\n            rb.GetPixbufNamed(IDR_PRODUCT_LOGO_16));\n      } else {\n        GdkPixbuf* icon_pixbuf = gfx::GdkPixbufFromSkBitmap(&icon);\n        gtk_image_set_from_pixbuf(GTK_IMAGE(app_mode_favicon_), icon_pixbuf);\n        g_object_unref(icon_pixbuf);\n      }\n    } else {\n      gtk_image_set_from_pixbuf(GTK_IMAGE(app_mode_favicon_),\n          rb.GetPixbufNamed(IDR_PRODUCT_LOGO_16));\n    }\n    throbber_.Reset();\n  }\n}", "target": 0}
{"code": "static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)\n{\n    FILE *fp = fopen(dest_filename, \"w\");\n    if (!fp)\n        return false;\n    unsigned fd = 0;\n    while (fd <= 99999) \n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    fclose(fp);\n    return true;\n}", "target": 1}
{"code": "pch_normalize (enum diff format)\n{\n  lin old = 1;\n  lin new = p_ptrn_lines + 1;\n  while (p_Char[new] == '=' || p_Char[new] == '\\n')\n    new++;\n  if (format == UNI_DIFF)\n    {\n      for (; old <= p_ptrn_lines; old++)\n\tif (p_Char[old] == '!')\n\t  p_Char[old] = '-';\n      for (; new <= p_end; new++)\n\tif (p_Char[new] == '!')\n\t  p_Char[new] = '+';\n    }\n  else\n    {\n      while (old <= p_ptrn_lines)\n\t{\n\t  if (p_Char[old] == '-')\n\t    {\n\t      if (new <= p_end && p_Char[new] == '+')\n\t\t{\n\t\t  do\n\t\t    {\n\t\t      p_Char[old] = '!';\n\t\t      old++;\n\t\t    }\n\t\t  while (old <= p_ptrn_lines && p_Char[old] == '-');\n\t\t  do\n\t\t    {\n\t\t      p_Char[new] = '!';\n\t\t      new++;\n\t\t    }\n\t\t  while (new <= p_end && p_Char[new] == '+');\n\t\t}\n\t      else\n\t\t{\n\t\t  do\n\t\t    old++;\n\t\t  while (old <= p_ptrn_lines && p_Char[old] == '-');\n\t\t}\n\t    }\n\t  else if (new <= p_end && p_Char[new] == '+')\n\t    {\n\t      do\n\t\tnew++;\n\t      while (new <= p_end && p_Char[new] == '+');\n\t    }\n\t  else\n\t    {\n\t      old++;\n\t      new++;\n\t    }\n\t}\n    }\n}", "target": 0}
{"code": "nosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct client *client = file->private_data;\n\tspinlock_t *client_list_lock = &client->lynx->client_list_lock;\n\tstruct nosy_stats stats;\n\tswitch (cmd) {\n\tcase NOSY_IOC_GET_STATS:\n\t\tspin_lock_irq(client_list_lock);\n\t\tstats.total_packet_count = client->buffer.total_packet_count;\n\t\tstats.lost_packet_count  = client->buffer.lost_packet_count;\n\t\tspin_unlock_irq(client_list_lock);\n\t\tif (copy_to_user((void __user *) arg, &stats, sizeof stats))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\treturn 0;\n\tcase NOSY_IOC_START:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_add_tail(&client->link, &client->lynx->client_list);\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tcase NOSY_IOC_STOP:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_del_init(&client->link);\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tcase NOSY_IOC_FILTER:\n\t\tspin_lock_irq(client_list_lock);\n\t\tclient->tcode_mask = arg;\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "static int btrfs_add_system_chunk(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *key,\n\t\t\t   struct btrfs_chunk *chunk, int item_size)\n{\n\tstruct btrfs_super_block *super_copy = fs_info->super_copy;\n\tstruct btrfs_disk_key disk_key;\n\tu32 array_size;\n\tu8 *ptr;\n\tmutex_lock(&fs_info->chunk_mutex);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\tif (array_size + item_size + sizeof(disk_key)\n\t\t\t> BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) {\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\treturn -EFBIG;\n\t}\n\tptr = super_copy->sys_chunk_array + array_size;\n\tbtrfs_cpu_key_to_disk(&disk_key, key);\n\tmemcpy(ptr, &disk_key, sizeof(disk_key));\n\tptr += sizeof(disk_key);\n\tmemcpy(ptr, chunk, item_size);\n\titem_size += sizeof(disk_key);\n\tbtrfs_set_super_sys_array_size(super_copy, array_size + item_size);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "bool Browser::PreHandleGestureEvent(content::WebContents* source,\n                                    const blink::WebGestureEvent& event) {\n  if (app_name() == DevToolsWindow::kDevToolsApp)\n    return event.type == blink::WebGestureEvent::GesturePinchBegin ||\n           event.type == blink::WebGestureEvent::GesturePinchUpdate ||\n           event.type == blink::WebGestureEvent::GesturePinchEnd;\n  return false;\n}", "target": 0}
{"code": "static int register_queue_kobjects(struct net_device *dev)\n{\n\tint error = 0, txq = 0, rxq = 0, real_rx = 0, real_tx = 0;\n#ifdef CONFIG_SYSFS\n\tdev->queues_kset = kset_create_and_add(\"queues\",\n\t\t\t\t\t       NULL, &dev->dev.kobj);\n\tif (!dev->queues_kset)\n\t\treturn -ENOMEM;\n\treal_rx = dev->real_num_rx_queues;\n#endif\n\treal_tx = dev->real_num_tx_queues;\n\terror = net_rx_queue_update_kobjects(dev, 0, real_rx);\n\tif (error)\n\t\tgoto error;\n\trxq = real_rx;\n\terror = netdev_queue_update_kobjects(dev, 0, real_tx);\n\tif (error)\n\t\tgoto error;\n\ttxq = real_tx;\n\treturn 0;\nerror:\n\tnetdev_queue_update_kobjects(dev, txq, 0);\n\tnet_rx_queue_update_kobjects(dev, rxq, 0);\n\treturn error;", "target": 1}
{"code": "ncp_read_kernel(struct ncp_server *server, const char *file_id,\n\t     __u32 offset, __u16 to_read, char *target, int *bytes_read)\n{\n\tconst char *source;\n\tint result;\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\tif ((result = ncp_request(server, 72)) != 0) {\n\t\tgoto out;\n\t}\n\t*bytes_read = ncp_reply_be16(server, 0);\n\tsource = ncp_reply_data(server, 2 + (offset & 1));\n\tmemcpy(target, source, *bytes_read);\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}", "target": 1}
{"code": "void Statement::Work_AfterPrepare(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<PrepareBaton> baton(static_cast<PrepareBaton*>(data));\n    Statement* stmt = baton->stmt;\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n    if (stmt->status != SQLITE_OK) {\n        Error(baton.get());\n        stmt->Finalize_();\n    }\n    else {\n        stmt->prepared = true;\n        if (!baton->callback.IsEmpty() && baton->callback.Value().IsFunction()) {\n            Napi::Function cb = baton->callback.Value();\n            Napi::Value argv[] = { env.Null() };\n            TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n        }\n    }\n    STATEMENT_END();\n}", "target": 0}
{"code": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tif (!timr->it_interval)\n\t\treturn;\n\ttimr->it_overrun += (unsigned int) hrtimer_forward(timer,\n\t\t\t\t\t\ttimer->base->get_time(),\n\t\t\t\t\t\ttimr->it_interval);\n\thrtimer_restart(timer);\n}", "target": 1}
{"code": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "Status OpLevelCostEstimator::PredictAvgPool(const OpContext& op_context,\n                                            NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * dims.kx * dims.ky;\n  node_costs->num_compute_ops = ops;\n  int64_t input_size;\n  if (dims.ky >= dims.sy) {\n    input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  } else {  \n    const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype()));\n    input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz;\n  }\n  node_costs->num_input_bytes_accessed = {input_size};\n  const int64_t output_size =\n      CalculateOutputSize(op_info, &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if ((EncCP1254_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'I')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? DOTLESS_i : 'i';\n      else\n        code = ENC_CP1254_TO_LOWER_CASE(code);\n    }\n    else if (code == 0x83 || code == 0xAA || code == 0xBA || code == 0xB5)\n      ;\n    else if ((EncCP1254_CtypeTable[code] & BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'i')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? I_WITH_DOT_ABOVE : 'I';\n      else if (code == DOTLESS_i)\n\tcode = 'I';\n      else if (code == 0x9A || code == 0x9C || code == 0x9E)\n\tcode -= 0x10;\n      else if (code == 0xFF)\n\tcode -= 0x60;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "GF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int count_fuse_fs(void)\n{\n\tstruct mntent *entp;\n\tint count = 0;\n\tconst char *mtab = _PATH_MOUNTED;\n\tFILE *fp = setmntent(mtab, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname, mtab,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\twhile ((entp = getmntent(fp)) != NULL) {\n\t\tif (strcmp(entp->mnt_type, \"fuse\") == 0 ||\n\t\t    strncmp(entp->mnt_type, \"fuse.\", 5) == 0)\n\t\t\tcount ++;\n\t}\n\tendmntent(fp);\n\treturn count;\n}", "target": 0}
{"code": "static void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}", "target": 0}
{"code": "find_next_quote(\n    char_u\t*line,\n    int\t\tcol,\n    int\t\tquotechar,\n    char_u\t*escape)\t\n{\n    int\t\tc;\n    for (;;)\n    {\n\tc = line[col];\n\tif (c == NUL)\n\t    return -1;\n\telse if (escape != NULL && vim_strchr(escape, c))\n\t    ++col;\n\telse if (c == quotechar)\n\t    break;\n\tif (has_mbyte)\n\t    col += (*mb_ptr2len)(line + col);\n\telse\n\t    ++col;\n    }\n    return col;\n}", "target": 1}
{"code": "yang_read_deviate_units(struct ly_ctx *ctx, struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    const char **stritem;\n    int j;\n    if (dev_target->nodetype == LYS_LEAFLIST) {\n        stritem = &((struct lys_node_leaflist *)dev_target)->units;\n    } else if (dev_target->nodetype == LYS_LEAF) {\n        stritem = &((struct lys_node_leaf *)dev_target)->units;\n    } else {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"units\\\" property.\");\n        goto error;\n    }\n    if (deviate->mod == LY_DEVIATE_DEL) {\n        if (!ly_strequal(*stritem, deviate->units, 1)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, deviate->units, \"units\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n            goto error;\n        }\n        lydict_remove(ctx, *stritem);\n        *stritem = NULL;\n        j = -1;\n        while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_UNITS)) != -1) {\n            lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n            --j;\n        }\n    } else {\n        if (deviate->mod == LY_DEVIATE_ADD) {\n            if (*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n                goto error;\n            }\n        } else { \n            if (!*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Replacing a property that does not exist.\");\n                goto error;\n            }\n        }\n        lydict_remove(ctx, *stritem);\n        *stritem = lydict_insert(ctx, deviate->units, 0);\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "snmp_ber_decode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint8_t *buf_end, type;\n  uint8_t len, j;\n  div_t first;\n  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n    return 0;\n  }\n  if(type != BER_DATA_TYPE_OBJECT_IDENTIFIER) {\n    return 0;\n  }\n  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n    return 0;\n  }\n  buf_end = snmp_packet->in + len;\n  if(snmp_packet->used == 0) {\n    return 0;\n  }\n  snmp_packet->used--;\n  first = div(*snmp_packet->in++, 40);\n  oid->length = 0;\n  oid->data[oid->length++] = (uint32_t)first.quot;\n  oid->data[oid->length++] = (uint32_t)first.rem;\n  while(snmp_packet->in != buf_end) {\n    if(oid->length >= SNMP_MSG_OID_MAX_LEN) {\n      return 0;\n    }\n    if(snmp_packet->used == 0) {\n      return 0;\n    }\n    oid->data[oid->length] = (uint32_t)(*snmp_packet->in & 0x7F);\n    for(j = 0; j < 4; j++) {\n      snmp_packet->used--;\n      if((*snmp_packet->in++ & 0x80) == 0) {\n        break;\n      }\n      if(snmp_packet->used == 0) {\n        return 0;\n      }\n      oid->data[oid->length] <<= 7;\n      oid->data[oid->length] |= (*snmp_packet->in & 0x7F);\n    }\n    oid->length++;\n  }\n  return 1;\n}", "target": 0}
{"code": "R_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\tfree (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; \n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}", "target": 1}
{"code": "void ThreadWatcher::OnPingMessage(const BrowserThread::ID& thread_id,\n                                  const base::Closure& callback_task) {\n  DCHECK(BrowserThread::CurrentlyOn(thread_id));\n  WatchDogThread::PostTask(FROM_HERE, callback_task);\n}", "target": 0}
{"code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 row = 0;\n\t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns; s++) {\n\t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n\t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n\t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}", "target": 1}
{"code": "static handler_t mod_wstunnel_check_extension(request_st * const r, void *p_d) {\n    plugin_data *p = p_d;\n    handler_t rc;\n    if (NULL != r->handler_module)\n        return HANDLER_GO_ON;\n  if (r->http_version > HTTP_VERSION_1_1) {\n    if (!r->h2_connect_ext)\n        return HANDLER_GO_ON;\n  }\n  else {\n    if (r->http_method != HTTP_METHOD_GET)\n        return HANDLER_GO_ON;\n    if (r->http_version != HTTP_VERSION_1_1)\n        return HANDLER_GO_ON;\n    const buffer *vb;\n    vb = http_header_request_get(r, HTTP_HEADER_UPGRADE, CONST_STR_LEN(\"Upgrade\"));\n    if (NULL == vb\n        || !http_header_str_contains_token(BUF_PTR_LEN(vb), CONST_STR_LEN(\"websocket\")))\n        return HANDLER_GO_ON;\n    vb = http_header_request_get(r, HTTP_HEADER_CONNECTION, CONST_STR_LEN(\"Connection\"));\n    if (NULL == vb\n        || !http_header_str_contains_token(BUF_PTR_LEN(vb), CONST_STR_LEN(\"upgrade\")))\n        return HANDLER_GO_ON;\n  }\n    mod_wstunnel_patch_config(r, p);\n    if (NULL == p->conf.gw.exts) return HANDLER_GO_ON;\n    rc = gw_check_extension(r, (gw_plugin_data *)p, 1, sizeof(handler_ctx));\n    return (HANDLER_GO_ON == rc && r->handler_module == p->self)\n      ? wstunnel_handler_setup(r, p)\n      : rc;\n}", "target": 0}
{"code": "mono_method_get_last_managed (void)\n{\n\tMonoMethod *m = NULL;\n\tstack_walk (last_managed, FALSE, &m);\n\treturn m;\n}", "target": 0}
{"code": "int nfs4_destroy_clientid(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint ret = 0;\n\tif (clp->cl_mvops->minor_version < 1)\n\t\tgoto out;\n\tif (clp->cl_exchange_flags == 0)\n\t\tgoto out;\n\tif (clp->cl_preserve_clid)\n\t\tgoto out;\n\tcred = nfs4_get_exchange_id_cred(clp);\n\tret = nfs4_proc_destroy_clientid(clp, cred);\n\tif (cred)\n\t\tput_rpccred(cred);\n\tswitch (ret) {\n\tcase 0:\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclp->cl_exchange_flags = 0;\n\t}\nout:\n\treturn ret;\n}", "target": 0}
{"code": "MagickExport LinkedListInfo *GetLocaleOptions(const char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    path[MagickPathExtent];\n  const char\n    *element;\n  LinkedListInfo\n    *messages,\n    *paths;\n  StringInfo\n    *xml;\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MagickPathExtent);\n  messages=NewLinkedList(0);\n  paths=GetConfigurePaths(filename,exception);\n  if (paths != (LinkedListInfo *) NULL)\n    {\n      ResetLinkedListIterator(paths);\n      element=(const char *) GetNextValueInLinkedList(paths);\n      while (element != (const char *) NULL)\n      {\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s%s\",element,\n          filename);\n        (void) LogMagickEvent(LocaleEvent,GetMagickModule(),\n          \"Searching for locale file: \\\"%s\\\"\",path);\n        xml=ConfigureFileToStringInfo(path);\n        if (xml != (StringInfo *) NULL)\n          (void) AppendValueToLinkedList(messages,xml);\n        element=(const char *) GetNextValueInLinkedList(paths);\n      }\n      paths=DestroyLinkedList(paths,RelinquishMagickMemory);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    char\n      *blob;\n    blob=(char *) NTResourceToBlob(filename);\n    if (blob != (char *) NULL)\n      {\n        xml=AcquireStringInfo(0);\n        SetStringInfoLength(xml,strlen(blob)+1);\n        SetStringInfoDatum(xml,(const unsigned char *) blob);\n        blob=(char *) RelinquishMagickMemory(blob);\n        SetStringInfoPath(xml,filename);\n        (void) AppendValueToLinkedList(messages,xml);\n      }\n  }\n#endif\n  ResetLinkedListIterator(messages);\n  return(messages);\n}", "target": 0}
{"code": "static int decode_sequence(struct xdr_stream *xdr,\n\t\t\t   struct nfs4_sequence_res *res,\n\t\t\t   struct rpc_rqst *rqstp)\n{\n#if defined(CONFIG_NFS_V4_1)\n\tstruct nfs4_sessionid id;\n\tu32 dummy;\n\tint status;\n\t__be32 *p;\n\tif (!res->sr_session)\n\t\treturn 0;\n\tstatus = decode_op_hdr(xdr, OP_SEQUENCE);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &id);\n\tif (unlikely(status))\n\t\tgoto out_err;\n\tstatus = -EREMOTEIO;\n\tif (memcmp(id.data, res->sr_session->sess_id.data,\n\t\t   NFS4_MAX_SESSIONID_LEN)) {\n\t\tdprintk(\"%s Invalid session id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tp = xdr_inline_decode(xdr, 20);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot->seq_nr) {\n\t\tdprintk(\"%s Invalid sequence number\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot - res->sr_session->fc_slot_table.slots) {\n\t\tdprintk(\"%s Invalid slot id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tdummy = be32_to_cpup(p++);\n\tdummy = be32_to_cpup(p++);\n\tres->sr_status_flags = be32_to_cpup(p);\n\tstatus = 0;\nout_err:\n\tres->sr_status = status;\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\tstatus = -EIO;\n\tgoto out_err;\n#else  \n\treturn 0;\n#endif \n}", "target": 0}
{"code": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 1}
{"code": "__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(sb))))\n\t\treturn;\n\ttrace_ext4_error(sb, function, line);\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\text4_unlock_group(sb, grp);\n\text4_commit_super(sb, 1);\n\text4_handle_error(sb);\n\text4_lock_group(sb, grp);\n\treturn;\n}", "target": 0}
{"code": "void smp_send_pair_rsp(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  p_cb->local_i_key &= p_cb->peer_i_key;\n  p_cb->local_r_key &= p_cb->peer_r_key;\n if (smp_send_cmd(SMP_OPCODE_PAIRING_RSP, p_cb)) {\n if (p_cb->selected_association_model == SMP_MODEL_SEC_CONN_OOB)\n      smp_use_oob_private_key(p_cb, NULL);\n else\n      smp_decide_association_model(p_cb, NULL);\n }\n}", "target": 0}
{"code": "static int rtnl_group_dellink(const struct net *net, int group)\n{\n\tstruct net_device *dev, *aux;\n\tLIST_HEAD(list_kill);\n\tbool found = false;\n\tif (!group)\n\t\treturn -EPERM;\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\tconst struct rtnl_link_ops *ops;\n\t\t\tfound = true;\n\t\t\tops = dev->rtnl_link_ops;\n\t\t\tif (!ops || !ops->dellink)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -ENODEV;\n\tfor_each_netdev_safe(net, dev, aux) {\n\t\tif (dev->group == group) {\n\t\t\tconst struct rtnl_link_ops *ops;\n\t\t\tops = dev->rtnl_link_ops;\n\t\t\tops->dellink(dev, &list_kill);\n\t\t}\n\t}\n\tunregister_netdevice_many(&list_kill);\n\treturn 0;\n}", "target": 0}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "njs_string_decode_base64_core(njs_vm_t *vm, njs_value_t *value,\n    const njs_str_t *src, njs_bool_t url)\n{\n    size_t     length;\n    const u_char *basis;\n    njs_str_t  dst;\n    basis = (url) ? njs_basis64url : njs_basis64;\n    length = njs_decode_base64_length_core(src, basis, &dst.length);\n    if (njs_slow_path(dst.length == 0)) {\n        vm->retval = njs_string_empty;\n        return NJS_OK;\n    }\n    dst.start = njs_string_alloc(vm, value, dst.length, length);\n    if (njs_slow_path(dst.start == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_decode_base64_core(&dst, src, basis);\n    return NJS_OK;\n}", "target": 0}
{"code": "pcx_write_rle(const byte * from, const byte * end, int step, gp_file * file)\n{\t\t\t\t\n#define MAX_RUN_COUNT 15\n    int max_run = step * MAX_RUN_COUNT;\n    while (from < end) {\n        byte data = *from;\n        from += step;\n        if (data != *from || from == end) {\n            if (data >= 0xc0)\n                gp_fputc(0xc1, file);\n        } else {\n            const byte *start = from;\n            while ((from < end) && (*from == data))\n                from += step;\n            while (from - start >= max_run) {\n                gp_fputc(0xc0 + MAX_RUN_COUNT, file);\n                gp_fputc(data, file);\n                start += max_run;\n            }\n            if (from > start || data >= 0xc0)\n                gp_fputc((from - start) / step + 0xc1, file);\n        }\n        gp_fputc(data, file);\n    }\n#undef MAX_RUN_COUNT\n}", "target": 1}
{"code": "static int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep) {\n\t\tdev_err(&sdev->udev->dev, \"no such endpoint?, %d\\n\",\n\t\t\tepnum);\n\t\tBUG();\n\t}\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\tdev_err(&sdev->udev->dev, \"get pipe, epnum %d\\n\", epnum);\n\treturn 0;\n}", "target": 1}
{"code": "static void snd_timer_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *ti;\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->card && timer->card->shutdown)\n\t\t\tcontinue;\n\t\tswitch (timer->tmr_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tsnd_iprintf(buffer, \"G%i: \", timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\t\tsnd_iprintf(buffer, \"C%i-%i: \",\n\t\t\t\t    timer->card->number, timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tsnd_iprintf(buffer, \"P%i-%i-%i: \", timer->card->number,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"?%i-%i-%i-%i: \", timer->tmr_class,\n\t\t\t\t    timer->card ? timer->card->number : -1,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t}\n\t\tsnd_iprintf(buffer, \"%s :\", timer->name);\n\t\tif (timer->hw.resolution)\n\t\t\tsnd_iprintf(buffer, \" %lu.%03luus (%lu ticks)\",\n\t\t\t\t    timer->hw.resolution / 1000,\n\t\t\t\t    timer->hw.resolution % 1000,\n\t\t\t\t    timer->hw.ticks);\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tsnd_iprintf(buffer, \" SLAVE\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tlist_for_each_entry(ti, &timer->open_list_head, open_list)\n\t\t\tsnd_iprintf(buffer, \"  Client %s : %s\\n\",\n\t\t\t\t    ti->owner ? ti->owner : \"unknown\",\n\t\t\t\t    ti->flags & (SNDRV_TIMER_IFLG_START |\n\t\t\t\t\t\t SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\t    ? \"running\" : \"stopped\");\n\t}\n\tmutex_unlock(&register_mutex);\n}", "target": 0}
{"code": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.load_eoi_exitmap_pending = true;\n\telse\n\t\tkvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);\n}", "target": 1}
{"code": "static int nl80211_parse_key_new(struct nlattr *key, struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested(tb, NL80211_KEY_MAX, key,\n\t\t\t\t   nl80211_key_policy);\n\tif (err)\n\t\treturn err;\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\tif (tb[NL80211_KEY_TYPE]) {\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\t\tif (k->type < 0 || k->type >= NUM_NL80211_KEYTYPES)\n\t\t\treturn -EINVAL;\n\t}\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\terr = nla_parse_nested(kdt, NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t       tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t       nl80211_key_default_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ServerApp::help()\n{\n#if WINAPI_XWINDOWS\n#  define WINAPI_ARGS \\\n    \" [--display <display>] [--no-xinitthreads]\"\n#  define WINAPI_INFO \\\n    \"      --display <display>  connect to the X server at <display>\\n\" \\\n    \"      --no-xinitthreads    do not call XInitThreads()\\n\" \\\n    \"      --screen-change-script <path>\\n\" \\\n    \"                           full path to script to run on screen change\\n\" \\\n    \"                           first argument is the new screen name\\n\"\n#else\n#  define WINAPI_ARGS \"\"\n#  define WINAPI_INFO \"\"\n#endif\n    barrier::fs::path profile_path = argsBase().m_profileDirectory;\n    if (profile_path.empty()) {\n        profile_path = barrier::DataDirectories::profile();\n    }\n    auto usr_config_path = (profile_path / barrier::fs::u8path(USR_CONFIG_NAME)).u8string();\n    auto sys_config_path = (barrier::DataDirectories::systemconfig() /\n                            barrier::fs::u8path(SYS_CONFIG_NAME)).u8string();\n    std::ostringstream buffer;\n    buffer << \"Start the barrier server component.\\n\"\n           << \"\\n\"\n           << \"Usage: \" << args().m_exename\n           << \" [--address <address>]\"\n           << \" [--config <pathname>]\"\n           << WINAPI_ARGS << HELP_SYS_ARGS << HELP_COMMON_ARGS << \"\\n\"\n           << \"\\n\"\n           << \"Options:\\n\"\n           << \"  -a, --address <address>  listen for clients on the given address.\\n\"\n           << \"  -c, --config <pathname>  use the named configuration file instead.\\n\"\n           << HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\"\n           << \"Default options are marked with a *\\n\"\n           << \"\\n\"\n           << \"The argument for --address is of the form: [<hostname>][:<port>].  The\\n\"\n           << \"hostname must be the address or hostname of an interface on the system.\\n\"\n           << \"Placing brackets around an IPv6 address is required when also specifying \\n\"\n           << \"a port number and optional otherwise. The default is to listen on all\\n\"\n           << \"interfaces using port number \" << kDefaultPort << \".\\n\"\n           << \"\\n\"\n           << \"If no configuration file pathname is provided then the first of the\\n\"\n           << \"following to load successfully sets the configuration:\\n\"\n           << \"  \" << usr_config_path << \"\\n\"\n           << \"  \" << sys_config_path << \"\\n\";\n    LOG((CLOG_PRINT \"%s\", buffer.str().c_str()));\n}", "target": 1}
{"code": "writeRandomBytes_arc4random(void * target, size_t count) {\n  size_t bytesWrittenTotal = 0;\n  while (bytesWrittenTotal < count) {\n    const uint32_t random32 = arc4random();\n    size_t i = 0;\n    for (; (i < sizeof(random32)) && (bytesWrittenTotal < count);\n        i++, bytesWrittenTotal++) {\n      const uint8_t random8 = (uint8_t)(random32 >> (i * 8));\n      ((uint8_t *)target)[bytesWrittenTotal] = random8;\n    }\n  }\n}", "target": 0}
{"code": "find_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n    if (thp == NULL) {\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}", "target": 1}
{"code": "bool InstanceKlass::has_nestmate_access_to(InstanceKlass* k, TRAPS) {\n  assert(this != k, \"this should be handled by higher-level code\");\n  Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();\n  InstanceKlass* cur_host = nest_host(icce, CHECK_false);\n  if (cur_host == NULL) {\n    return false;\n  }\n  Klass* k_nest_host = k->nest_host(icce, CHECK_false);\n  if (k_nest_host == NULL) {\n    return false;\n  }\n  bool access = (cur_host == k_nest_host);\n  if (log_is_enabled(Trace, class, nestmates)) {\n    ResourceMark rm(THREAD);\n    log_trace(class, nestmates)(\"Class %s does %shave nestmate access to %s\",\n                                this->external_name(),\n                                access ? \"\" : \"NOT \",\n                                k->external_name());\n  }\n  return access;\n}", "target": 0}
{"code": "static void rxfilter_notify(NetClientState *nc)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    if (nc->rxfilter_notify_enabled) {\n        char *path = object_get_canonical_path(OBJECT(n->qdev));\n        qapi_event_send_nic_rx_filter_changed(!!n->netclient_name,\n                                              n->netclient_name, path);\n        g_free(path);\n        nc->rxfilter_notify_enabled = 0;\n    }\n}", "target": 0}
{"code": "local block_state deflate_fast(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    IPos hash_head;       \n    int bflush;           \n    for (;;) {\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; \n        }\n        hash_head = NIL;\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n            s->match_length = longest_match (s, hash_head);\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->match_start, s->match_length);\n            _tr_tally_dist(s, s->strstart - s->match_start,\n                           s->match_length - MIN_MATCH, bflush);\n            s->lookahead -= s->match_length;\n#ifndef FASTEST\n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) {\n                s->match_length--; \n                do {\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                } while (--s->match_length != 0);\n                s->strstart++;\n            } else\n#endif\n            {\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window[s->strstart];\n                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n            }\n        } else {\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit (s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "static int em_popa(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RDI;\n\twhile (reg >= VCPU_REGS_RAX) {\n\t\tif (reg == VCPU_REGS_RSP) {\n\t\t\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP],\n\t\t\t\t\t\t\tctxt->op_bytes);\n\t\t\t--reg;\n\t\t}\n\t\trc = emulate_pop(ctxt, &ctxt->regs[reg], ctxt->op_bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tbreak;\n\t\t--reg;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "    template<typename t, typename tc>\n    CImg<T>& draw_axis(const int x, const CImg<t>& values_y,\n                       const tc *const color, const float opacity=1,\n                       const unsigned int pattern=~0U, const unsigned int font_height=13,\n                       const bool allow_zero=true) {\n      if (is_empty()) return *this;\n      int siz = (int)values_y.size() - 1;\n      CImg<charT> txt(32);\n      CImg<T> label;\n      if (siz<=0) { \n        draw_line(x,0,x,_height - 1,color,opacity,pattern);\n        if (!siz) {\n          cimg_snprintf(txt,txt._width,\"%g\",(double)*values_y);\n          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);\n          const int\n            _yt = (height() - label.height())/2,\n            yt = _yt<0?0:_yt + label.height()>=height()?height() - 1-label.height():_yt,\n            _xt = x - 2 - label.width(),\n            xt = _xt>=0?_xt:x + 3;\n          draw_point(x - 1,height()/2,color,opacity).draw_point(x + 1,height()/2,color,opacity);\n          if (allow_zero || *txt!='0' || txt[1]!=0)\n            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);\n        }\n      } else { \n        if (values_y[0]<values_y[siz]) draw_arrow(x,0,x,_height - 1,color,opacity,30,5,pattern);\n        else draw_arrow(x,_height - 1,x,0,color,opacity,30,5,pattern);\n        cimg_foroff(values_y,y) {\n          cimg_snprintf(txt,txt._width,\"%g\",(double)values_y(y));\n          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);\n          const int\n            yi = (int)(y*(_height - 1)/siz),\n            _yt = yi - label.height()/2,\n            yt = _yt<0?0:_yt + label.height()>=height()?height() - 1-label.height():_yt,\n            _xt = x - 2 - label.width(),\n            xt = _xt>=0?_xt:x + 3;\n          draw_point(x - 1,yi,color,opacity).draw_point(x + 1,yi,color,opacity);\n          if (allow_zero || *txt!='0' || txt[1]!=0)\n            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);\n        }\n      }\n      return *this;", "target": 0}
{"code": "void RenderWidgetHostViewAura::OnDisplayBoundsChanged(\n    const gfx::Display& display) {\n  gfx::Screen* screen = gfx::Screen::GetScreenFor(window_);\n  if (display.id() == screen->GetDisplayNearestWindow(window_).id()) {\n    UpdateScreenInfo(window_);\n    current_cursor_.SetDisplayInfo(display);\n    UpdateCursorIfOverSelf();\n  }\n}", "target": 0}
{"code": "void PDPClient::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "static void set_env( char* penv, const char* name )\n{\n    if( penv && *penv )\n        g_setenv( name, penv, TRUE);\n    else\n        g_unsetenv( name );\n}", "target": 0}
{"code": "GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\tif (!nb_pack) nb_pack = 1;\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}", "target": 1}
{"code": "Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}", "target": 1}
{"code": "PHP_FUNCTION(enchant_broker_request_dict)\n{\n\tzval *broker;\n\tenchant_broker *pbroker;\n\tenchant_dict *dict;\n\tEnchantDict *d;\n\tchar *tag;\n\tint taglen;\n\tint pos;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &broker, &tag, &taglen) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_ENCHANT_GET_BROKER;\n\tif (taglen == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Tag cannot be empty\");\n\t\tRETURN_FALSE;\n\t}\n\td = enchant_broker_request_dict(pbroker->pbroker, (const char *)tag);\n\tif (d) {\n\t\tif (pbroker->dictcnt) {\n\t\t\tpbroker->dict = (enchant_dict **)erealloc(pbroker->dict, sizeof(enchant_dict *) * pbroker->dictcnt);\n\t\t\tpos = pbroker->dictcnt++;\n\t\t} else {\n\t\t\tpbroker->dict = (enchant_dict **)emalloc(sizeof(enchant_dict *));\n\t\t\tpos = 0;\n\t\t\tpbroker->dictcnt++;\n\t\t}\n\t\tdict = pbroker->dict[pos] = (enchant_dict *)emalloc(sizeof(enchant_dict));\n\t\tdict->id = pos;\n\t\tdict->pbroker = pbroker;\n\t\tdict->pdict = d;\n\t\tdict->prev = pos ? pbroker->dict[pos-1] : NULL;\n\t\tdict->next = NULL;\n\t\tpbroker->dict[pos] = dict;\n\t\tif (pos) {\n\t\t\tpbroker->dict[pos-1]->next = dict;\n\t\t}\n\t\tdict->rsrc_id = ZEND_REGISTER_RESOURCE(return_value, dict, le_enchant_dict);\n\t\tzend_list_addref(pbroker->rsrc_id);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!new)\n\t\tgoto out;\n\tnew->ldr_bits = 8;\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask  &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}", "target": 1}
{"code": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length / 2; i++) {\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, 4); \n    s->has_trns = 1;\n    return 0;\n}", "target": 1}
{"code": "static int digi_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint i;\n\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n\t\tif (!serial->port[i]->read_urb) {\n\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!serial->port[i]->write_urb) {\n\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 0}
{"code": "process_bitmap_updates(STREAM s)\n{\n\tuint16 num_updates;\n\tint i;\n\tin_uint16_le(s, num_updates);\t\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tprocess_bitmap_data(s);\n\t}\n}", "target": 0}
{"code": "static PyObject *checkPassword(PyObject *self, PyObject *args)\n{\n    const char *user = NULL;\n    const char *pswd = NULL;\n    const char *service = NULL;\n    const char *default_realm = NULL;\n    int result = 0;\n    if (!PyArg_ParseTuple(args, \"ssss\", &user, &pswd, &service, &default_realm))\n        return NULL;\n    result = authenticate_user_krb5pwd(user, pswd, service, default_realm);\n    if (result)\n        return Py_INCREF(Py_True), Py_True;\n    else\n        return NULL;\n}", "target": 1}
{"code": "static void dma_pte_free_pagetable(struct dmar_domain *domain,\n\t\t\t\t   unsigned long start_pfn,\n\t\t\t\t   unsigned long last_pfn,\n\t\t\t\t   int retain_level)\n{\n\tBUG_ON(!domain_pfn_supported(domain, start_pfn));\n\tBUG_ON(!domain_pfn_supported(domain, last_pfn));\n\tBUG_ON(start_pfn > last_pfn);\n\tdma_pte_clear_range(domain, start_pfn, last_pfn);\n\tdma_pte_free_level(domain, agaw_to_level(domain->agaw), retain_level,\n\t\t\t   domain->pgd, 0, start_pfn, last_pfn);\n\tif (start_pfn == 0 && last_pfn == DOMAIN_MAX_PFN(domain->gaw)) {\n\t\tfree_pgtable_page(domain->pgd);\n\t\tdomain->pgd = NULL;\n\t}\n}", "target": 0}
{"code": "findNextBorderPixel(l_int32    w,\n                    l_int32    h,\n                    l_uint32  *data,\n                    l_int32    wpl,\n                    l_int32    px,\n                    l_int32    py,\n                    l_int32   *pqpos,\n                    l_int32   *pnpx,\n                    l_int32   *pnpy)\n{\nl_int32    qpos, i, pos, npx, npy, val;\nl_uint32  *line;\n    qpos = *pqpos;\n    for (i = 1; i < 8; i++) {\n        pos = (qpos + i) % 8;\n        npx = px + xpostab[pos];\n        npy = py + ypostab[pos];\n        line = data + npy * wpl;\n        val = GET_DATA_BIT(line, npx);\n        if (val) {\n            *pnpx = npx;\n            *pnpy = npy;\n            *pqpos = qpostab[pos];\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 1}
{"code": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){\n    explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));\n    SAFE_FREE(cipher->aes_key);\n}", "target": 1}
{"code": "PLIST_API void plist_from_bin(const char *plist_bin, uint32_t length, plist_t * plist)\n{\n    char *trailer = NULL;\n    uint8_t offset_size = 0;\n    uint8_t dict_size = 0;\n    uint64_t num_objects = 0;\n    uint64_t root_object = 0;\n    uint64_t offset_table_index = 0;\n    char *offset_table = NULL;\n    if (!(length >= BPLIST_MAGIC_SIZE + BPLIST_VERSION_SIZE + BPLIST_TRL_SIZE))\n        return;\n    if (memcmp(plist_bin, BPLIST_MAGIC, BPLIST_MAGIC_SIZE) != 0)\n        return;\n    if (memcmp(plist_bin + BPLIST_MAGIC_SIZE, BPLIST_VERSION, BPLIST_VERSION_SIZE) != 0)\n        return;\n    trailer = (char *) (plist_bin + (length - BPLIST_TRL_SIZE));\n    offset_size = trailer[BPLIST_TRL_OFFSIZE_IDX];\n    dict_size = trailer[BPLIST_TRL_PARMSIZE_IDX];\n    num_objects = be64dec(trailer + BPLIST_TRL_NUMOBJ_IDX);\n    root_object = be64dec(trailer + BPLIST_TRL_ROOTOBJ_IDX);\n    offset_table_index = be64dec(trailer + BPLIST_TRL_OFFTAB_IDX);\n    offset_table = (char *) (plist_bin + offset_table_index);\n    if (num_objects == 0)\n        return;\n    if (root_object >= num_objects)\n        return;\n    if (offset_table < plist_bin || offset_table >= plist_bin + length)\n        return;\n    if (offset_table + num_objects * offset_size >= plist_bin + length)\n        return;\n    if (sizeof(uint32_t) * num_objects < num_objects)\n        return;\n    struct bplist_data bplist;\n    bplist.data = plist_bin;\n    bplist.size = length;\n    bplist.num_objects = num_objects;\n    bplist.dict_size = dict_size;\n    bplist.offset_size = offset_size;\n    bplist.offset_table = offset_table;\n    bplist.level = 0;\n    bplist.used_indexes = (uint32_t*)malloc(sizeof(uint32_t) * num_objects);\n    if (!bplist.used_indexes)\n        return;\n    *plist = parse_bin_node_at_index(&bplist, root_object);\n    free(bplist.used_indexes);\n}", "target": 1}
{"code": "GlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n: _glyph_loader(new Loader(face, bool(face_options & gr_face_dumbRendering))),\n  _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n        ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n  _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n        ? grzeroalloc<GlyphBox *>(_glyph_loader->num_glyphs()) : 0),\n  _num_glyphs(_glyphs ? _glyph_loader->num_glyphs() : 0),\n  _num_attrs(_glyphs ? _glyph_loader->num_attrs() : 0),\n  _upem(_glyphs ? _glyph_loader->units_per_em() : 0)\n{\n    if ((face_options & gr_face_preloadGlyphs) && _glyph_loader && _glyphs)\n    {\n        int numsubs = 0;\n        GlyphFace * const glyphs = new GlyphFace [_num_glyphs];\n        if (!glyphs)\n            return;\n        _glyphs[0] = _glyph_loader->read_glyph(0, glyphs[0], &numsubs);\n        const GlyphFace * loaded = _glyphs[0];\n        for (uint16 gid = 1; loaded && gid != _num_glyphs; ++gid)\n            _glyphs[gid] = loaded = _glyph_loader->read_glyph(gid, glyphs[gid], &numsubs);\n        if (!loaded)\n        {\n            _glyphs[0] = 0;\n            delete [] glyphs;\n        }\n        else if (numsubs > 0 && _boxes)\n        {\n            GlyphBox * boxes = (GlyphBox *)gralloc<char>(_num_glyphs * sizeof(GlyphBox) + numsubs * 8 * sizeof(float));\n            GlyphBox * currbox = boxes;\n            for (uint16 gid = 0; currbox && gid != _num_glyphs; ++gid)\n            {\n                _boxes[gid] = currbox;\n                currbox = _glyph_loader->read_box(gid, currbox, *_glyphs[gid]);\n            }\n            if (!currbox)\n            {\n                free(boxes);\n                _boxes[0] = 0;\n            }\n        }\n        delete _glyph_loader;\n        _glyph_loader = 0;\n    }\n    if (_glyphs && glyph(0) == 0)\n    {\n        free(_glyphs);\n        _glyphs = 0;\n        if (_boxes)\n        {\n            free(_boxes);\n            _boxes = 0;\n        }\n        _num_glyphs = _num_attrs = _upem = 0;\n    }\n}", "target": 1}
{"code": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    assert(s->cirrus_blt_width > 0);\n    assert(s->cirrus_blt_height > 0);\n    if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                              s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    if (blit_region_is_unsafe(s, s->cirrus_blt_srcpitch,\n                              s->cirrus_blt_srcaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    return false;\n}", "target": 1}
{"code": "key_set(const char *key) {\n    int\t\tlen = (int)strlen(key);\n    int64_t\th = calc_hash(key, &len);\n    Slot\t*bucket = get_bucketp(h);\n    Slot\ts;\n    if (NULL != (s = (Slot)AGOO_MALLOC(sizeof(struct _slot)))) {\n\ts->hash = h;\n\ts->klen = len;\n\ts->key = key;\n\ts->next = *bucket;\n\t*bucket = s;\n    }\n}", "target": 1}
{"code": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}", "target": 1}
{"code": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}", "target": 1}
{"code": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n#ifdef CONFIG_PREEMPTION\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}", "target": 0}
{"code": "snmpDecodePacket(SnmpRequest * rq)\n{\n    struct snmp_pdu *PDU;\n    u_char *Community;\n    u_char *buf = rq->buf;\n    int len = rq->len;\n    allow_t allow = ACCESS_DENIED;\n    if (!Config.accessList.snmp) {\n        debugs(49, DBG_IMPORTANT, \"WARNING: snmp_access not configured. agent query DENIED from : \" << rq->from);\n        return;\n    }\n    debugs(49, 5, HERE << \"Called.\");\n    PDU = snmp_pdu_create(0);\n    rq->session.Version = SNMP_VERSION_1;\n    Community = snmp_parse(&rq->session, PDU, buf, len);\n    if (Community) {\n        ACLFilledChecklist checklist(Config.accessList.snmp, NULL, NULL);\n        checklist.src_addr = rq->from;\n        checklist.snmp_community = (char *) Community;\n        allow = checklist.fastCheck();\n        if (allow == ACCESS_ALLOWED && (snmp_coexist_V2toV1(PDU))) {\n            rq->community = Community;\n            rq->PDU = PDU;\n            debugs(49, 5, \"snmpAgentParse: reqid=[\" << PDU->reqid << \"]\");\n            snmpConstructReponse(rq);\n        } else {\n            debugs(49, DBG_IMPORTANT, \"WARNING: SNMP agent query DENIED from : \" << rq->from);\n        }\n        xfree(Community);\n    } else {\n        debugs(49, DBG_IMPORTANT, \"WARNING: Failed SNMP agent query from : \" << rq->from);\n        snmp_free_pdu(PDU);\n    }\n}", "target": 1}
{"code": "DEATH_TEST(LteOp, InvalidEooOperand, \"Invariant failure _rhs\") {\n    BSONObj operand;\n    LTEMatchExpression lte(\"\", operand.firstElement());\n}", "target": 0}
{"code": "static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\n{\n\tstruct property *prop;\n\tchar *name;\n\tchar *value;\n\tprop = kzalloc(sizeof(*prop), GFP_KERNEL);\n\tif (!prop)\n\t\treturn NULL;\n\tname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\n\tprop->name = kstrdup(name, GFP_KERNEL);\n\tprop->length = be32_to_cpu(ccwa->prop_length);\n\tvalue = (char *)ccwa + be32_to_cpu(ccwa->prop_offset);\n\tprop->value = kmemdup(value, prop->length, GFP_KERNEL);\n\tif (!prop->value) {\n\t\tdlpar_free_cc_property(prop);\n\t\treturn NULL;\n\t}\n\treturn prop;\n}", "target": 1}
{"code": "static int komeda_wb_connector_add(struct komeda_kms_dev *kms,\n\t\t\t\t   struct komeda_crtc *kcrtc)\n{\n\tstruct komeda_dev *mdev = kms->base.dev_private;\n\tstruct komeda_wb_connector *kwb_conn;\n\tstruct drm_writeback_connector *wb_conn;\n\tu32 *formats, n_formats = 0;\n\tint err;\n\tif (!kcrtc->master->wb_layer)\n\t\treturn 0;\n\tkwb_conn = kzalloc(sizeof(*kwb_conn), GFP_KERNEL);\n\tif (!kwb_conn)\n\t\treturn -ENOMEM;\n\tkwb_conn->wb_layer = kcrtc->master->wb_layer;\n\twb_conn = &kwb_conn->base;\n\twb_conn->encoder.possible_crtcs = BIT(drm_crtc_index(&kcrtc->base));\n\tformats = komeda_get_layer_fourcc_list(&mdev->fmt_tbl,\n\t\t\t\t\t       kwb_conn->wb_layer->layer_type,\n\t\t\t\t\t       &n_formats);\n\terr = drm_writeback_connector_init(&kms->base, wb_conn,\n\t\t\t\t\t   &komeda_wb_connector_funcs,\n\t\t\t\t\t   &komeda_wb_encoder_helper_funcs,\n\t\t\t\t\t   formats, n_formats);\n\tkomeda_put_fourcc_list(formats);\n\tif (err)\n\t\treturn err;\n\tdrm_connector_helper_add(&wb_conn->base, &komeda_wb_conn_helper_funcs);\n\tkcrtc->wb_conn = kwb_conn;\n\treturn 0;\n}", "target": 1}
{"code": "static CURLcode cookie_output(struct Curl_easy *data,\n                              struct CookieInfo *c, const char *filename)\n{\n  struct Cookie *co;\n  FILE *out = NULL;\n  bool use_stdout = FALSE;\n  char *tempstore = NULL;\n  CURLcode error = CURLE_OK;\n  if(!c)\n    return CURLE_OK;\n  remove_expired(c);\n  if(!strcmp(\"-\", filename)) {\n    out = stdout;\n    use_stdout = TRUE;\n  }\n  else {\n    error = Curl_fopen(data, filename, &out, &tempstore);\n    if(error)\n      goto error;\n  }\n  fputs(\"# Netscape HTTP Cookie File\\n\"\n        \"# https:\n        \"# This file was generated by libcurl! Edit at your own risk.\\n\\n\",\n        out);\n  if(c->numcookies) {\n    unsigned int i;\n    size_t nvalid = 0;\n    struct Cookie **array;\n    array = calloc(1, sizeof(struct Cookie *) * c->numcookies);\n    if(!array) {\n      error = CURLE_OUT_OF_MEMORY;\n      goto error;\n    }\n    for(i = 0; i < COOKIE_HASH_SIZE; i++) {\n      for(co = c->cookies[i]; co; co = co->next) {\n        if(!co->domain)\n          continue;\n        array[nvalid++] = co;\n      }\n    }\n    qsort(array, nvalid, sizeof(struct Cookie *), cookie_sort_ct);\n    for(i = 0; i < nvalid; i++) {\n      char *format_ptr = get_netscape_format(array[i]);\n      if(!format_ptr) {\n        free(array);\n        error = CURLE_OUT_OF_MEMORY;\n        goto error;\n      }\n      fprintf(out, \"%s\\n\", format_ptr);\n      free(format_ptr);\n    }\n    free(array);\n  }\n  if(!use_stdout) {\n    fclose(out);\n    out = NULL;\n    if(tempstore && Curl_rename(tempstore, filename)) {\n      unlink(tempstore);\n      error = CURLE_WRITE_ERROR;\n      goto error;\n    }\n  }\n  free(tempstore);\n  return CURLE_OK;\nerror:\n  if(out && !use_stdout)\n    fclose(out);\n  free(tempstore);\n  return error;\n}", "target": 0}
{"code": "static xmlParserCtxtPtr createMemoryParser(xmlSAXHandlerPtr handlers, void* userData, const char* chunk)\n{\n    if (!didInit) {\n        xmlInitParser();\n        xmlRegisterInputCallbacks(matchFunc, openFunc, readFunc, closeFunc);\n        xmlRegisterOutputCallbacks(matchFunc, openFunc, writeFunc, closeFunc);\n        libxmlLoaderThread = currentThread();\n        didInit = true;\n    }\n    xmlParserCtxtPtr parser = xmlCreateMemoryParserCtxt(chunk, xmlStrlen((const xmlChar*)chunk));\n    if (!parser)\n        return 0;\n    memcpy(parser->sax, handlers, sizeof(xmlSAXHandler));\n    xmlCtxtUseOptions(parser, XML_PARSE_NODICT | XML_PARSE_NOENT);\n    parser->sax2 = 1;\n    parser->instate = XML_PARSER_CONTENT; \n    parser->depth = 0;\n    parser->str_xml = xmlDictLookup(parser->dict, BAD_CAST \"xml\", 3);\n    parser->str_xmlns = xmlDictLookup(parser->dict, BAD_CAST \"xmlns\", 5);\n    parser->str_xml_ns = xmlDictLookup(parser->dict, XML_XML_NAMESPACE, 36);\n    parser->_private = userData;\n    return parser;\n}", "target": 0}
{"code": "htc_request_check_host_hdr(struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "webSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    if (wsctx && wsctx->readbuflen)\n      return TRUE;\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}", "target": 1}
{"code": "void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec *itp)\n{\n\tunion cpu_time_count now;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tint clear_dead;\n\tsample_to_timespec(timer->it_clock,\n\t\t\t   timer->it.cpu.incr, &itp->it_interval);\n\tif (timer->it.cpu.expires.sched == 0) {\t\n\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\treturn;\n\t}\n\tif (unlikely(p == NULL)) {\n\tdead:\n\t\tsample_to_timespec(timer->it_clock, timer->it.cpu.expires,\n\t\t\t\t   &itp->it_value);\n\t\treturn;\n\t}\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t\tclear_dead = p->exit_state;\n\t} else {\n\t\tread_lock(&tasklist_lock);\n\t\tif (unlikely(p->signal == NULL)) {\n\t\t\tput_task_struct(p);\n\t\t\ttimer->it.cpu.task = NULL;\n\t\t\ttimer->it.cpu.expires.sched = 0;\n\t\t\tread_unlock(&tasklist_lock);\n\t\t\tgoto dead;\n\t\t} else {\n\t\t\tcpu_clock_sample_group(timer->it_clock, p, &now);\n\t\t\tclear_dead = (unlikely(p->exit_state) &&\n\t\t\t\t      thread_group_empty(p));\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\tif (timer->it.cpu.incr.sched == 0 &&\n\t\t    cpu_time_before(timer->it_clock,\n\t\t\t\t    timer->it.cpu.expires, now)) {\n\t\t\ttimer->it.cpu.expires.sched = 0;\n\t\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\t\treturn;\n\t\t}\n\t\tbump_cpu_timer(timer, now);\n\t}\n\tif (unlikely(clear_dead)) {\n\t\tclear_dead_task(timer, now);\n\t\tgoto dead;\n\t}\n\tif (cpu_time_before(timer->it_clock, now, timer->it.cpu.expires)) {\n\t\tsample_to_timespec(timer->it_clock,\n\t\t\t\t   cpu_time_sub(timer->it_clock,\n\t\t\t\t\t\ttimer->it.cpu.expires, now),\n\t\t\t\t   &itp->it_value);\n\t} else {\n\t\titp->it_value.tv_nsec = 1;\n\t\titp->it_value.tv_sec = 0;\n\t}\n}", "target": 0}
{"code": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\t*len = sizeof(*addr);\n\treturn 0;\n}", "target": 1}
{"code": "static void construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\tkenter(\"%p\", dest_keyring);\n\tif (dest_keyring) {\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n}", "target": 1}
{"code": "static int pfifo_fast_init(struct Qdisc *qdisc, struct nlattr *opt)\n{\n\tint prio;\n\tstruct sk_buff_head *list = qdisc_priv(qdisc);\n\tfor (prio = 0; prio < PFIFO_FAST_BANDS; prio++)\n\t\tskb_queue_head_init(list + prio);\n\treturn 0;\n}", "target": 0}
{"code": "   Get status info from a mailbox */\nPHP_FUNCTION(imap_status)\n{\n\tzval *streamind;\n\tzend_string *mbx;\n\tzend_long flags;\n\tpils *imap_le_struct;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rSl\", &streamind, &mbx, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tobject_init(return_value);\n\tif (mail_status(imap_le_struct->imap_stream, ZSTR_VAL(mbx), flags)) {\n\t\tadd_property_long(return_value, \"flags\", IMAPG(status_flags));\n\t\tif (IMAPG(status_flags) & SA_MESSAGES) {\n\t\t\tadd_property_long(return_value, \"messages\", IMAPG(status_messages));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_RECENT) {\n\t\t\tadd_property_long(return_value, \"recent\", IMAPG(status_recent));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UNSEEN) {\n\t\t\tadd_property_long(return_value, \"unseen\", IMAPG(status_unseen));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UIDNEXT) {\n\t\t\tadd_property_long(return_value, \"uidnext\", IMAPG(status_uidnext));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UIDVALIDITY) {\n\t\t\tadd_property_long(return_value, \"uidvalidity\", IMAPG(status_uidvalidity));\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 0}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\tmmu_notifier_release(mm);\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\tarch_exit_mmap(mm);\n\tvma = mm->mmap;\n\tif (!vma)\t\n\t\treturn;\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tunmap_vmas(&tlb, vma, 0, -1);\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}", "target": 1}
{"code": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}", "target": 1}
{"code": "struct vfsmount *lookup_mnt(struct path *path)\n{\n\tstruct mount *child_mnt;\n\tstruct vfsmount *m;\n\tunsigned seq;\n\trcu_read_lock();\n\tdo {\n\t\tseq = read_seqbegin(&mount_lock);\n\t\tchild_mnt = __lookup_mnt(path->mnt, path->dentry);\n\t\tm = child_mnt ? &child_mnt->mnt : NULL;\n\t} while (!legitimize_mnt(m, seq));\n\trcu_read_unlock();\n\treturn m;\n}", "target": 0}
{"code": "static inline void ok_png_premultiply(uint8_t *dst) {\n    const uint8_t a = dst[3];\n    if (a == 0) {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    } else if (a < 255) {\n        dst[0] = (a * dst[0] + 127) / 255;\n        dst[1] = (a * dst[1] + 127) / 255;\n        dst[2] = (a * dst[2] + 127) / 255;\n    }\n}", "target": 0}
{"code": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        if (size < 4)\n            throw Error(kerCorruptedMetadata);\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if ( o+2 > size )\n            throw Error(kerCorruptedMetadata);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        if ( (o + (count * 10)) > size )\n            throw Error(kerCorruptedMetadata);\n        for (uint16_t i = 0; i < count; ++i) {\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::UniquePtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::UniquePtr(new CiffDirectory); break;\n            default: m = CiffComponent::UniquePtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(std::move(m));\n            o += 10;\n        }\n    }  ", "target": 1}
{"code": "void bootp_input(struct mbuf *m)\n{\n    struct bootp_t *bp = mtod_check(m, sizeof(struct bootp_t));\n    if (bp && bp->bp_op == BOOTP_REQUEST) {\n        bootp_reply(m->slirp, bp, m_end(m));\n    }\n}", "target": 0}
{"code": "static void send(node_t *node, node_t *child, byte *fout) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout);\n\t}\n\tif (child) {\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}", "target": 1}
{"code": "comics_regex_quote (const gchar *unquoted_string)\n{\n\tconst gchar *p;\n\tGString *dest;\n\tdest = g_string_new (\"'\");\n\tp = unquoted_string;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\t\tcase ('*'):\n\t\t\tcase ('?'):\n\t\t\tcase ('['):\n\t\t\t\tg_string_append (dest, \"[\");\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tg_string_append (dest, \"]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\\\'):\n\t\t\t\tg_string_append (dest, \"[\\\\\\\\]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\''):\n\t\t\t\tg_string_append (dest, \"'\\\\''\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n\tg_string_append_c (dest, '\\'');\n\treturn g_string_free (dest, FALSE);\n}", "target": 1}
{"code": "void zend_accel_shared_protect(int mode)\n{\n#ifdef HAVE_MPROTECT\n\tint i;\n\tif (mode) {\n\t\tmode = PROT_READ;\n\t} else {\n\t\tmode = PROT_READ|PROT_WRITE;\n\t}\n\tfor (i = 0; i < ZSMMG(shared_segments_count); i++) {\n\t\tmprotect(ZSMMG(shared_segments)[i]->p, ZSMMG(shared_segments)[i]->size, mode);\n\t}\n#endif\n}", "target": 0}
{"code": "DLLIMPORT int cfg_opt_nprint_var(cfg_opt_t *opt, unsigned int index, FILE *fp)\n{\n\tconst char *str;\n\tif (!opt || !fp) {\n\t\terrno = EINVAL;\n\t\treturn CFG_FAIL;\n\t}\n\tswitch (opt->type) {\n\tcase CFGT_INT:\n\t\tfprintf(fp, \"%ld\", cfg_opt_getnint(opt, index));\n\t\tbreak;\n\tcase CFGT_FLOAT:\n\t\tfprintf(fp, \"%f\", cfg_opt_getnfloat(opt, index));\n\t\tbreak;\n\tcase CFGT_STR:\n\t\tstr = cfg_opt_getnstr(opt, index);\n\t\tfprintf(fp, \"\\\"\");\n\t\twhile (str && *str) {\n\t\t\tif (*str == '\"')\n\t\t\t\tfprintf(fp, \"\\\\\\\"\");\n\t\t\telse if (*str == '\\\\')\n\t\t\t\tfprintf(fp, \"\\\\\\\\\");\n\t\t\telse\n\t\t\t\tfprintf(fp, \"%c\", *str);\n\t\t\tstr++;\n\t\t}\n\t\tfprintf(fp, \"\\\"\");\n\t\tbreak;\n\tcase CFGT_BOOL:\n\t\tfprintf(fp, \"%s\", cfg_opt_getnbool(opt, index) ? \"true\" : \"false\");\n\t\tbreak;\n\tcase CFGT_NONE:\n\tcase CFGT_SEC:\n\tcase CFGT_FUNC:\n\tcase CFGT_PTR:\n\tcase CFGT_COMMENT:\n\t\tbreak;\n\t}\n\treturn CFG_SUCCESS;\n}", "target": 0}
{"code": "void SetColor(double c, double m, double y, double k,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f K\",c,m,y,k);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f k\",c,m,y,k);\n    }\n}", "target": 1}
{"code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\tif (tsk != current)\n\t\treturn;\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}", "target": 1}
{"code": "unsigned int inet6_hash_frag(__be32 id, const struct in6_addr *saddr,\n\t\t\t     const struct in6_addr *daddr, u32 rnd)\n{\n\tu32 a, b, c;\n\ta = (__force u32)saddr->s6_addr32[0];\n\tb = (__force u32)saddr->s6_addr32[1];\n\tc = (__force u32)saddr->s6_addr32[2];\n\ta += JHASH_GOLDEN_RATIO;\n\tb += JHASH_GOLDEN_RATIO;\n\tc += rnd;\n\t__jhash_mix(a, b, c);\n\ta += (__force u32)saddr->s6_addr32[3];\n\tb += (__force u32)daddr->s6_addr32[0];\n\tc += (__force u32)daddr->s6_addr32[1];\n\t__jhash_mix(a, b, c);\n\ta += (__force u32)daddr->s6_addr32[2];\n\tb += (__force u32)daddr->s6_addr32[3];\n\tc += (__force u32)id;\n\t__jhash_mix(a, b, c);\n\treturn c & (INETFRAGS_HASHSZ - 1);\n}", "target": 0}
{"code": "static int rm_rf_inner_child(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev,\n                bool allow_recursion) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                if (!allow_recursion)\n                        return -EISDIR;\n                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 0}
{"code": "static void _gnutls_handshake_internal_state_init(gnutls_session_t session)\n{\n\tsession->internals.adv_version_major = 0;\n\tsession->internals.adv_version_minor = 0;\n\tsession->internals.direction = 0;\n\tsession->internals.last_handshake_in = -1;\n\tsession->internals.last_handshake_out = -1;\n\tsession->internals.resumable = RESUME_TRUE;\n\tsession->internals.handshake_large_loops = 0;\n\tsession->internals.dtls.hsk_read_seq = 0;\n\tsession->internals.dtls.hsk_write_seq = 0;\n}", "target": 1}
{"code": "static void dump_thread32(struct pt_regs * regs, struct user32 * dump)\n{\n\tu32 fs,gs;\n\tdump->magic = CMAGIC;\n\tdump->start_code = 0;\n\tdump->start_stack = regs->rsp & ~(PAGE_SIZE - 1);\n\tdump->u_tsize = ((unsigned long) current->mm->end_code) >> PAGE_SHIFT;\n\tdump->u_dsize = ((unsigned long) (current->mm->brk + (PAGE_SIZE-1))) >> PAGE_SHIFT;\n\tdump->u_dsize -= dump->u_tsize;\n\tdump->u_ssize = 0;\n\tdump->u_debugreg[0] = current->thread.debugreg0;  \n\tdump->u_debugreg[1] = current->thread.debugreg1;  \n\tdump->u_debugreg[2] = current->thread.debugreg2;  \n\tdump->u_debugreg[3] = current->thread.debugreg3;  \n\tdump->u_debugreg[4] = 0;  \n\tdump->u_debugreg[5] = 0;  \n\tdump->u_debugreg[6] = current->thread.debugreg6;  \n\tdump->u_debugreg[7] = current->thread.debugreg7;  \n\tif (dump->start_stack < 0xc0000000)\n\t\tdump->u_ssize = ((unsigned long) (0xc0000000 - dump->start_stack)) >> PAGE_SHIFT;\n\tdump->regs.ebx = regs->rbx;\n\tdump->regs.ecx = regs->rcx;\n\tdump->regs.edx = regs->rdx;\n\tdump->regs.esi = regs->rsi;\n\tdump->regs.edi = regs->rdi;\n\tdump->regs.ebp = regs->rbp;\n\tdump->regs.eax = regs->rax;\n\tdump->regs.ds = current->thread.ds;\n\tdump->regs.es = current->thread.es;\n\tasm(\"movl %%fs,%0\" : \"=r\" (fs)); dump->regs.fs = fs;\n\tasm(\"movl %%gs,%0\" : \"=r\" (gs)); dump->regs.gs = gs; \n\tdump->regs.orig_eax = regs->orig_rax;\n\tdump->regs.eip = regs->rip;\n\tdump->regs.cs = regs->cs;\n\tdump->regs.eflags = regs->eflags;\n\tdump->regs.esp = regs->rsp;\n\tdump->regs.ss = regs->ss;\n#if 1 \n\tdump->u_fpvalid = 0;\n#else\n\tdump->u_fpvalid = dump_fpu (regs, &dump->i387);\n#endif\n}", "target": 0}
{"code": "concat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n  to->len = i;\n  if (p >= end)\n    to->reach_end = 1;\n}", "target": 1}
{"code": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n  if (rc == IDN2_OK)\n    {\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n      free(output_u8);\n    }\n  return rc;\n}", "target": 1}
{"code": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tint i, len;\n\tsize_t len_sent = 0;\n\tconst char __user *p;\n\tchar *buf;\n\tp = (const char __user *)current->mm->arg_start;\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tfor (i = 0; i < context->execve.argc; i++) {\n\t\tlen = audit_log_single_execve_arg(context, ab, i,\n\t\t\t\t\t\t  &len_sent, p, buf);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tp += len;\n\t}\n\tkfree(buf);\n}", "target": 1}
{"code": "int sctp_auth_recv_cid(sctp_cid_t chunk, const struct sctp_association *asoc)\n{\n\tif (!sctp_auth_enable || !asoc)\n\t\treturn 0;\n\treturn __sctp_auth_cid(chunk,\n\t\t\t      (struct sctp_chunks_param *)asoc->c.auth_chunks);\n}", "target": 0}
{"code": "TEST_F(SecretManagerImplTest, DeprecatedSanMatcher) {\n  envoy::extensions::transport_sockets::tls::v3::Secret secret_config;\n  const std::string yaml =\n      R\"EOF(\n      name: \"abc.com\"\n      validation_context:\n        trusted_ca: { filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\" }\n        allow_expired_certificate: true\n        match_subject_alt_names:\n          exact: \"example.foo\"\n      )EOF\";\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml), secret_config);\n  std::unique_ptr<SecretManager> secret_manager(new SecretManagerImpl(config_tracker_));\n  secret_manager->addStaticSecret(secret_config);\n  ASSERT_EQ(secret_manager->findStaticCertificateValidationContextProvider(\"undefined\"), nullptr);\n  ASSERT_NE(secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\"), nullptr);\n  Ssl::CertificateValidationContextConfigImpl cvc_config(\n      *secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\")->secret(), *api_);\n  EXPECT_EQ(cvc_config.subjectAltNameMatchers().size(), 4);\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[0].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n            cvc_config.subjectAltNameMatchers()[0].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[1].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n            cvc_config.subjectAltNameMatchers()[1].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[2].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n            cvc_config.subjectAltNameMatchers()[2].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[3].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS,\n            cvc_config.subjectAltNameMatchers()[3].san_type());\n}", "target": 0}
{"code": "static u8 vgacon_build_attr(struct vc_data *c, u8 color,\n\t\t\t    enum vc_intensity intensity,\n\t\t\t    bool blink, bool underline, bool reverse,\n\t\t\t    bool italic)\n{\n\tu8 attr = color;\n\tif (vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF0) | c->vc_itcolor;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf0) | c->vc_ulcolor;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | c->vc_halfcolor;\n\t}\n\tif (reverse)\n\t\tattr =\n\t\t    ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) &\n\t\t\t\t       0x77);\n\tif (blink)\n\t\tattr ^= 0x80;\n\tif (intensity == VCI_BOLD)\n\t\tattr ^= 0x08;\n\tif (!vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF8) | 0x02;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf8) | 0x01;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | 0x08;\n\t}\n\treturn attr;\n}", "target": 0}
{"code": "void* ipc_rcu_alloc(int size)\n{\n\tvoid* out;\n\tif (rcu_use_vmalloc(size)) {\n\t\tout = vmalloc(HDRLEN_VMALLOC + size);\n\t\tif (out) {\n\t\t\tout += HDRLEN_VMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t} else {\n\t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n\t\tif (out) {\n\t\t\tout += HDRLEN_KMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t}\n\treturn out;\n}", "target": 1}
{"code": "            Status readCString( StringData* out ) {\n                const void* x = memchr( _buffer + _position, 0, _maxLength - _position );\n                if ( !x )\n                    return makeError(\"no end of c-string\", _idElem);\n                uint64_t len = static_cast<uint64_t>( static_cast<const char*>(x) - ( _buffer + _position ) );\n                StringData data( _buffer + _position, len );\n                _position += len + 1;\n                if ( out ) {\n                    *out = data;\n                }\n                return Status::OK();\n            }", "target": 0}
{"code": "void tcp_rcv_space_adjust(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint time;\n\tint space;\n\tif (tp->rcvq_space.time == 0)\n\t\tgoto new_measure;\n\ttime = tcp_time_stamp - tp->rcvq_space.time;\n\tif (time < (tp->rcv_rtt_est.rtt >> 3) || tp->rcv_rtt_est.rtt == 0)\n\t\treturn;\n\tspace = 2 * (tp->copied_seq - tp->rcvq_space.seq);\n\tspace = max(tp->rcvq_space.space, space);\n\tif (tp->rcvq_space.space != space) {\n\t\tint rcvmem;\n\t\ttp->rcvq_space.space = space;\n\t\tif (sysctl_tcp_moderate_rcvbuf &&\n\t\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\t\tint new_clamp = space;\n\t\t\tspace /= tp->advmss;\n\t\t\tif (!space)\n\t\t\t\tspace = 1;\n\t\t\trcvmem = SKB_TRUESIZE(tp->advmss + MAX_TCP_HEADER);\n\t\t\twhile (tcp_win_from_space(rcvmem) < tp->advmss)\n\t\t\t\trcvmem += 128;\n\t\t\tspace *= rcvmem;\n\t\t\tspace = min(space, sysctl_tcp_rmem[2]);\n\t\t\tif (space > sk->sk_rcvbuf) {\n\t\t\t\tsk->sk_rcvbuf = space;\n\t\t\t\ttp->window_clamp = new_clamp;\n\t\t\t}\n\t\t}\n\t}\nnew_measure:\n\ttp->rcvq_space.seq = tp->copied_seq;\n\ttp->rcvq_space.time = tcp_time_stamp;\n}", "target": 0}
{"code": "ztype(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    ref tnref;\n    int code = array_get(imemory, op, (long)r_btype(op - 1), &tnref);\n    if (code < 0)\n        return code;\n    if (!r_has_type(&tnref, t_name)) {\n         check_op(2);\n         {                       \n            if (op[-1].value.pstruct != 0x00) {\n             const char *sname =\n                 gs_struct_type_name_string(gs_object_type(imemory,\n                                                           op[-1].value.pstruct));\n            int code = name_ref(imemory, (const byte *)sname, strlen(sname),\n                                (ref *) (op - 1), 0);\n            if (code < 0)\n                return code;\n            } else\n                return_error(gs_error_stackunderflow);\n        }\n        r_set_attrs(op - 1, a_executable);\n    } else {\n        ref_assign(op - 1, &tnref);\n    }\n    pop(1);\n    return 0;\n}", "target": 1}
{"code": "xfs_attr3_leaf_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tif ((xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\t\t  XFS_ATTR3_LEAF_CRC_OFF)) ||\n\t    !xfs_attr3_leaf_verify(bp)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, bp->b_addr);\n\t\txfs_buf_ioerror(bp, EFSCORRUPTED);\n\t}\n}", "target": 0}
{"code": "mm_zfree(struct mm_master *mm, void *address)\n{\n\tmm_free(mm, address);\n}", "target": 1}
{"code": "const char* NavigatorServiceWorker::supplementName()\n{\n     return \"NavigatorServiceWorker\";\n }", "target": 0}
{"code": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}", "target": 1}
{"code": "void file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tif (likely(!(file->f_mode & FMODE_WRITE)))\n\t\treturn;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tlg_local_lock(&files_lglock);\n\t__file_sb_list_add(file, sb);\n\tlg_local_unlock(&files_lglock);\n}", "target": 1}
{"code": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "_XimEncodeSavedPreeditValue(\n    Xic\t\t\t  ic,\n    XIMResourceList\t  res,\n    XPointer\t\t  value)\n{\n    int\t\t\t  list_ret;\n    XFontStruct\t\t**struct_list;\n    char\t\t**name_list;\n    char\t\t *tmp;\n    int\t\t\t  len;\n    register int\t  i;\n    if (res->xrm_name == XrmStringToQuark(XNFontSet)) {\n\tif (!value)\n\t    return False;\n\tif (ic->private.proto.preedit_font)\n\t    Xfree(ic->private.proto.preedit_font);\n\tlist_ret = XFontsOfFontSet((XFontSet)value,\n\t\t\t\t\t\t&struct_list, &name_list);\n\tfor(i = 0, len = 0; i < list_ret; i++) {\n\t    len += (strlen(name_list[i]) + sizeof(char));\n\t}\n\tif(!(tmp = Xmalloc(len + 1))) {\n\t    ic->private.proto.preedit_font = NULL;\n\t    return False;\n\t}\n\ttmp[0] = '\\0';\n\tfor(i = 0; i < list_ret; i++) {\n\t    strcat(tmp, name_list[i]);\n\t    strcat(tmp, \",\");\n\t}\n\ttmp[len - 1] = 0;\n\tic->private.proto.preedit_font        = tmp;\n\tic->private.proto.preedit_font_length = len - 1;\n    }\n    return True;\n}", "target": 0}
{"code": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tint l2 = 22 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = mkdir_p(dest, 0755);\n\t\tif (ret < 0) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}", "target": 1}
{"code": "static int may_delete(struct inode *dir,struct dentry *victim,int isdir)\n{\n\tint error;\n\tif (!victim->d_inode)\n\t\treturn -ENOENT;\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||\n\t    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!S_ISDIR(victim->d_inode->i_mode))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (S_ISDIR(victim->d_inode->i_mode))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}", "target": 0}
{"code": "ebt_basic_match(const struct ebt_entry *e, const struct sk_buff *skb,\n                const struct net_device *in, const struct net_device *out)\n{\n\tconst struct ethhdr *h = eth_hdr(skb);\n\tconst struct net_bridge_port *p;\n\t__be16 ethproto;\n\tint verdict, i;\n\tif (vlan_tx_tag_present(skb))\n\t\tethproto = htons(ETH_P_8021Q);\n\telse\n\t\tethproto = h->h_proto;\n\tif (e->bitmask & EBT_802_3) {\n\t\tif (FWINV2(ntohs(ethproto) >= 1536, EBT_IPROTO))\n\t\t\treturn 1;\n\t} else if (!(e->bitmask & EBT_NOPROTO) &&\n\t   FWINV2(e->ethproto != ethproto, EBT_IPROTO))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->in, in), EBT_IIN))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->out, out), EBT_IOUT))\n\t\treturn 1;\n\tif (in && (p = br_port_get_rcu(in)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_in, p->br->dev), EBT_ILOGICALIN))\n\t\treturn 1;\n\tif (out && (p = br_port_get_rcu(out)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_out, p->br->dev), EBT_ILOGICALOUT))\n\t\treturn 1;\n\tif (e->bitmask & EBT_SOURCEMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_source[i] ^ e->sourcemac[i]) &\n\t\t\t   e->sourcemsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_ISOURCE) )\n\t\t\treturn 1;\n\t}\n\tif (e->bitmask & EBT_DESTMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_dest[i] ^ e->destmac[i]) &\n\t\t\t   e->destmsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_IDEST) )\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}", "target": 0}
{"code": "FrameLoader::FrameLoader(Frame* frame, FrameLoaderClient* client)\n    : m_frame(frame)\n    , m_client(client)\n    , m_history(frame)\n    , m_notifer(frame)\n    , m_icon(adoptPtr(new IconController(frame)))\n    , m_mixedContentChecker(frame)\n    , m_state(FrameStateProvisional)\n    , m_loadType(FrameLoadTypeStandard)\n    , m_inStopAllLoaders(false)\n    , m_isComplete(false)\n    , m_containsPlugins(false)\n    , m_checkTimer(this, &FrameLoader::checkTimerFired)\n    , m_shouldCallCheckCompleted(false)\n    , m_opener(0)\n    , m_didAccessInitialDocument(false)\n    , m_didAccessInitialDocumentTimer(this, &FrameLoader::didAccessInitialDocumentTimerFired)\n    , m_suppressOpenerInNewFrame(false)\n    , m_startingClientRedirect(false)\n    , m_forcedSandboxFlags(SandboxNone)\n{\n}", "target": 0}
{"code": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 1}
{"code": "init_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\tstate->empty = 1;\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt*sizeof(struct posix_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "p11_rpc_buffer_get_byte_array (p11_buffer *buf,\n                               size_t *offset,\n                               const unsigned char **data,\n                               size_t *length)\n{\n\tsize_t off = *offset;\n\tuint32_t len;\n\tif (!p11_rpc_buffer_get_uint32 (buf, &off, &len))\n\t\treturn false;\n\tif (len == 0xffffffff) {\n\t\t*offset = off;\n\t\tif (data)\n\t\t\t*data = NULL;\n\t\tif (length)\n\t\t\t*length = 0;\n\t\treturn true;\n\t} else if (len >= 0x7fffffff) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\tif (buf->len < len || *offset > buf->len - len) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\tif (data)\n\t\t*data = (unsigned char *)buf->data + off;\n\tif (length)\n\t\t*length = len;\n\t*offset = off + len;\n\treturn true;\n}", "target": 1}
{"code": "void PacketReader::getDnsrecordheader(struct dnsrecordheader &ah)\n{\n  unsigned int n;\n  unsigned char *p=reinterpret_cast<unsigned char*>(&ah);\n  for(n=0; n < sizeof(dnsrecordheader); ++n) \n    p[n]=d_content.at(d_pos++);\n  ah.d_type=ntohs(ah.d_type);\n  ah.d_class=ntohs(ah.d_class);\n  ah.d_clen=ntohs(ah.d_clen);\n  ah.d_ttl=ntohl(ah.d_ttl);\n  d_startrecordpos=d_pos; \n  d_recordlen=ah.d_clen;\n}", "target": 0}
{"code": "char* _multi_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return NULL;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 2 );\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 0}
{"code": "                void writeMetadata()\n                {\n                }", "target": 0}
{"code": "handle_fn_f7 (GsdXrandrManager *mgr, guint32 timestamp)\n{\n        GsdXrandrManagerPrivate *priv = mgr->priv;\n        GnomeRRScreen *screen = priv->rw_screen;\n        GnomeRRConfig *current;\n        GError *error;\n        g_debug (\"Handling fn-f7\");\n        error = NULL;\n        if (!gnome_rr_screen_refresh (screen, &error) && error) {\n                char *str;\n                str = g_strdup_printf (_(\"Could not refresh the screen information: %s\"), error->message);\n                g_error_free (error);\n                error_message (mgr, str, NULL, _(\"Trying to switch the monitor configuration anyway.\"));\n                g_free (str);\n        }\n        if (!priv->fn_f7_configs)\n                generate_fn_f7_configs (mgr);\n        current = gnome_rr_config_new_current (screen);\n        if (priv->fn_f7_configs &&\n            (!gnome_rr_config_match (current, priv->fn_f7_configs[0]) ||\n             !gnome_rr_config_equal (current, priv->fn_f7_configs[mgr->priv->current_fn_f7_config]))) {\n                    generate_fn_f7_configs (mgr);\n            }\n        gnome_rr_config_free (current);\n        if (priv->fn_f7_configs) {\n                mgr->priv->current_fn_f7_config++;\n                if (priv->fn_f7_configs[mgr->priv->current_fn_f7_config] == NULL)\n                        mgr->priv->current_fn_f7_config = 0;\n                g_debug (\"cycling to next configuration (%d)\", mgr->priv->current_fn_f7_config);\n                print_configuration (priv->fn_f7_configs[mgr->priv->current_fn_f7_config], \"new config\");\n                g_debug (\"applying\");\n                error = NULL;\n                if (!gnome_rr_config_apply_with_time (priv->fn_f7_configs[mgr->priv->current_fn_f7_config], screen, timestamp, &error)) {\n                        error_message (mgr, _(\"Could not switch the monitor configuration\"), error, NULL);\n                        g_error_free (error);\n                }\n        }\n        else {\n                g_debug (\"no configurations generated\");\n        }\n        g_debug (\"done handling fn-f7\");\n}", "target": 0}
{"code": "static RBinElfSymbol *Elf_(r_bin_elf_get_phdr_imports)(ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->phdr_imports) {\n\t\treturn bin->phdr_imports;\n\t}\n\tbin->phdr_imports = get_symbols_from_phdr (bin, R_BIN_ELF_IMPORTS);\n\treturn bin->phdr_imports;\n}", "target": 0}
{"code": "rfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"%s: client not 8 bits per pixel\\n\",\n                \"rfbSetClientColourMapBGR233\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    scme->type = rfbSetColourMapEntries;\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n    len = sz_rfbSetColourMapEntriesMsg;\n    i = 0;\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 / 7);\n                rgb[i++] = Swap16IfLE(g * 65535 / 7);\n                rgb[i++] = Swap16IfLE(b * 65535 / 3);\n            }\n        }\n    }\n    len += 256 * 3 * 2;\n    if (rfbWriteExact(cl, buf, len) < 0) {\n        rfbLogPerror(\"rfbSetClientColourMapBGR233: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tkfree(clt);\n}", "target": 1}
{"code": "static int umocktypes_copy_FLOW_HANDLE(FLOW_HANDLE* destination, const FLOW_HANDLE* source)\n{\n    int result = 0;\n    *(destination) = *(source);\n    return result;\n}", "target": 0}
{"code": "static void __mcheck_cpu_init_generic(void)\n{\n\tenum mcp_flags m_fl = 0;\n\tmce_banks_t all_banks;\n\tu64 cap;\n\tif (!mca_cfg.bootlog)\n\t\tm_fl = MCP_DONTLOG;\n\tbitmap_fill(all_banks, MAX_NR_BANKS);\n\tmachine_check_poll(MCP_UC | m_fl, &all_banks);\n\tcr4_set_bits(X86_CR4_MCE);\n\trdmsrl(MSR_IA32_MCG_CAP, cap);\n\tif (cap & MCG_CTL_P)\n\t\twrmsr(MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);\n}", "target": 0}
{"code": "static inline void __clear_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n\t__clear_bit(fd / BITS_PER_LONG, fdt->full_fds_bits);\n}", "target": 0}
{"code": "void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}", "target": 1}
{"code": "static int get_manuf_info(struct edgeport_serial *serial, __u8 *buffer)\n{\n\tint status;\n\tint start_address;\n\tstruct ti_i2c_desc *rom_desc;\n\tstruct edge_ti_manuf_descriptor *desc;\n\tstruct device *dev = &serial->serial->dev->dev;\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc)\n\t\treturn -ENOMEM;\n\tstart_address = get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\n\t\t\t\t\t\t\t\trom_desc);\n\tif (!start_address) {\n\t\tdev_dbg(dev, \"%s - Edge Descriptor not found in I2C\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto exit;\n\t}\n\tstatus = read_rom(serial, start_address+sizeof(struct ti_i2c_desc),\n\t\t\t\t\tle16_to_cpu(rom_desc->Size), buffer);\n\tif (status)\n\t\tgoto exit;\n\tstatus = valid_csum(rom_desc, buffer);\n\tdesc = (struct edge_ti_manuf_descriptor *)buffer;\n\tdev_dbg(dev, \"%s - IonConfig      0x%x\\n\", __func__, desc->IonConfig);\n\tdev_dbg(dev, \"%s - Version          %d\\n\", __func__, desc->Version);\n\tdev_dbg(dev, \"%s - Cpu/Board      0x%x\\n\", __func__, desc->CpuRev_BoardRev);\n\tdev_dbg(dev, \"%s - NumPorts         %d\\n\", __func__, desc->NumPorts);\n\tdev_dbg(dev, \"%s - NumVirtualPorts  %d\\n\", __func__, desc->NumVirtualPorts);\n\tdev_dbg(dev, \"%s - TotalPorts       %d\\n\", __func__, desc->TotalPorts);\nexit:\n\tkfree(rom_desc);\n\treturn status;\n}", "target": 0}
{"code": "static struct bio_map_data *bio_alloc_map_data(struct iov_iter *data,\n\t\t\t\t\t       gfp_t gfp_mask)\n{\n\tstruct bio_map_data *bmd;\n\tif (data->nr_segs > UIO_MAXIOV)\n\t\treturn NULL;\n\tbmd = kmalloc(struct_size(bmd, iov, data->nr_segs), gfp_mask);\n\tif (!bmd)\n\t\treturn NULL;\n\tmemcpy(bmd->iov, data->iov, sizeof(struct iovec) * data->nr_segs);\n\tbmd->iter = *data;\n\tbmd->iter.iov = bmd->iov;\n\treturn bmd;\n}", "target": 0}
{"code": "static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}", "target": 1}
{"code": "static Status ValidateStrides(const T& strides) {\n  for (size_t i = 0; i < strides.size(); ++i) {\n    if (strides[i] <= 0) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field for dimension \", i,\n          \" must be positive but is \", strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "void MultiplySum(const size_t xsize,\n                 const pixel_type* const JXL_RESTRICT row_in,\n                 const pixel_type* const JXL_RESTRICT row_in_Y,\n                 const float factor, float* const JXL_RESTRICT row_out) {\n  const HWY_FULL(float) df;\n  const Rebind<pixel_type, HWY_FULL(float)> di;  \n  const auto factor_v = Set(df, factor);\n  for (size_t x = 0; x < xsize; x += Lanes(di)) {\n    const auto in = Load(di, row_in + x) + Load(di, row_in_Y + x);\n    const auto out = ConvertTo(df, in) * factor_v;\n    Store(out, df, row_out + x);\n  }\n}", "target": 0}
{"code": "static int mmap_kmem(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned long pfn;\n\tpfn = __pa((u64)vma->vm_pgoff << PAGE_SHIFT) >> PAGE_SHIFT;\n\tif (!pfn_valid(pfn))\n\t\treturn -EIO;\n\tvma->vm_pgoff = pfn;\n\treturn mmap_mem(file, vma);\n}", "target": 0}
{"code": "static struct per_transfer *del_per_transfer(struct per_transfer *per)\n{\n  struct per_transfer *n;\n  struct per_transfer *p;\n  DEBUGASSERT(transfers);\n  DEBUGASSERT(transfersl);\n  DEBUGASSERT(per);\n  n = per->next;\n  p = per->prev;\n  if(p)\n    p->next = n;\n  else\n    transfers = n;\n  if(n)\n    n->prev = p;\n  else\n    transfersl = p;\n  free(per);\n  return n;\n}", "target": 0}
{"code": "repodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n  if (!*schema)\n    return 0;\t\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}", "target": 1}
{"code": "bool allow_svhandler_flash_range(size_t start, size_t end) {\n  if (start > end) return false;\n  if (start < FLASH_ORIGIN || end > FLASH_END) return false;\n  bool startAllowed = false;\n  bool endAllowed = false;\n  for (const FlashSector* s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (allow_svhandler_flash_sector(s)) {\n      if (!startAllowed &&\n          start + 1 > start &&\n          do_memory_ranges_overlap(start, start + 1, s->start, s->start + s->len)) {\n        startAllowed = true;\n      }\n      if (!endAllowed &&\n          end - 1 < end &&\n          do_memory_ranges_overlap(end - 1, end, s->start, s->start + s->len)) {\n        endAllowed = true;\n      }\n    } else {\n      if (do_memory_ranges_overlap(start, end, s->start, s->start + s->len)) return false;\n    }\n  }\n  if (!startAllowed || !endAllowed) return false;\n  return true;\n}", "target": 0}
{"code": "const char* menu_cache_item_get_file_basename( MenuCacheItem* item )\n{\n    return item->file_name;\n}", "target": 0}
{"code": "check_vim9_unlet(char_u *name)\n{\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}", "target": 1}
{"code": "bool ping_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\tskb_push(skb, skb->data - (u8 *)icmph);\n\tsk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));\n\tif (sk) {\n\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tif (skb2)\n\t\t\tping_queue_rcv_skb(sk, skb2);\n\t\tsock_put(sk);\n\t\treturn true;\n\t}\n\tpr_debug(\"no socket, dropping\\n\");\n\treturn false;\n}", "target": 0}
{"code": "php_apache_server_startup(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)\n{\n\tvoid *data = NULL;\n\tconst char *userdata_key = \"apache2hook_post_config\";\n\tapr_pool_userdata_get(&data, userdata_key, s->process->pool);\n\tif (data == NULL) {\n\t\tapr_pool_userdata_set((const void *)1, userdata_key, apr_pool_cleanup_null, s->process->pool);\n\t\treturn OK;\n\t}\n\tif (apache2_php_ini_path_override) {\n\t\tapache2_sapi_module.php_ini_path_override = apache2_php_ini_path_override;\n\t}\n#ifdef ZTS\n\ttsrm_startup(1, 1, 0, NULL);\n#endif\n\tsapi_startup(&apache2_sapi_module);\n\tapache2_sapi_module.startup(&apache2_sapi_module);\n\tapr_pool_cleanup_register(pconf, NULL, php_apache_server_shutdown, apr_pool_cleanup_null);\n\tphp_apache_add_version(pconf);\n\treturn OK;\n}", "target": 0}
{"code": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret)\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 1}
{"code": "static MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n  size_t\n    length,\n    row_size;\n  ssize_t\n    count,\n    y;\n  unsigned char\n    *compact_pixels,\n    *pixels;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RLE compressed\");\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < sizes[y])\n      length=(size_t) sizes[y];\n  if (length > row_size + 256) \n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"InvalidLength\",\n        image->filename);\n    }\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels));\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n    count=ReadBlob(image,(size_t) sizes[y],compact_pixels);\n    if (count != (ssize_t) sizes[y])\n      break;\n    count=DecodePSDPixels((size_t) sizes[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n    status=ReadPSDChannelPixels(image,psd_info->channels,y,type,pixels,\n      exception);\n    if (status == MagickFalse)\n      break;\n  }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);\n        comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size;\n        return true;\n    }", "target": 1}
{"code": "static ssize_t module_xz_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\tstatic const u8 signature[] = { 0xfd, '7', 'z', 'X', 'Z', 0 };\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\tsize_t new_size = 0;\n\tssize_t retval;\n\tif (size < sizeof(signature) ||\n\t    memcmp(buf, signature, sizeof(signature))) {\n\t\tpr_err(\"not an xz compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\txz_buf.in_size = size;\n\txz_buf.in = buf;\n\txz_buf.in_pos = 0;\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\txz_buf.out = kmap_local_page(page);\n\t\txz_buf.out_pos = 0;\n\t\txz_buf.out_size = PAGE_SIZE;\n\t\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\t\tkunmap_local(xz_buf.out);\n\t\tnew_size += xz_buf.out_pos;\n\t} while (xz_buf.out_pos == PAGE_SIZE && xz_ret == XZ_OK);\n\tif (xz_ret != XZ_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", xz_ret);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tretval = new_size;\n out:\n\txz_dec_end(xz_dec);\n\treturn retval;\n}", "target": 1}
{"code": "decode_labeled_vpn_clnp_prefix(netdissect_options *ndo,\n                               const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t addr[19];\n\tu_int plen;\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \n\tif ((24+64) > plen)\n\t\treturn -1;\n        plen-=(24+64); \n\tif (152 < plen)\n\t\treturn -1;\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 isonsap_string(ndo, addr,(plen + 7) / 8),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 12 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 0}
{"code": "void CheckAuthTest::TestValidToken(const std::string &auth_token,\n                                   const std::string &user_info) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([auth_token](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + auth_token;\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(auth_token)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .Times(2)\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1OpenIdUrl);\n        std::string body(kOpenIdContent);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1PubkeyUrl);\n        std::string body(kPubkey);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n  std::cout << \"need be replaced: \" << user_info << std::endl;\n  EXPECT_CALL(*raw_request_,\n              AddHeaderToBackend(kEndpointApiUserInfo, user_info))\n      .WillOnce(Return(utils::Status::OK));\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}", "target": 1}
{"code": "static int file_cb(\n\tconst git_diff_delta *delta,\n\tfloat progress,\n\tvoid *payload)\n{\n\tstruct diff_data *diff_data = payload;\n\tGIT_UNUSED(progress);\n\tif (delta->old_file.path)\n\t\tdiff_data->old_path = git__strdup(delta->old_file.path);\n\tif (delta->new_file.path)\n\t\tdiff_data->new_path = git__strdup(delta->new_file.path);\n\tgit_oid_cpy(&diff_data->old_id, &delta->old_file.id);\n\tgit_oid_cpy(&diff_data->new_id, &delta->new_file.id);\n\treturn 0;\n}", "target": 0}
{"code": "GF_Box *gf_isom_clone_config_box(GF_Box *box)\n{\n\tu8 *data=NULL;\n\tu32 size=0;\n\tGF_Err e;\n\tGF_Box *clone=NULL;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_size(box);\n\tif (!e)\n\t\te = gf_isom_box_write(box, bs);\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\tif (!e) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t\te = gf_isom_box_parse(&clone, bs);\n\t\tgf_bs_del(bs);\n\t}\n\tif (data)\n\t\tgf_free(data);\n\tif (e) {\n\t\tif (clone)\n\t\t\tgf_isom_box_del(clone);\n\t\tclone = NULL;\n\t}\n\treturn clone;\n}", "target": 0}
{"code": "_gnutls_x509_decode_string(unsigned int etype,\n\t\t\t   const uint8_t * der, size_t der_size,\n\t\t\t   gnutls_datum_t * output, unsigned allow_ber)\n{\n\tint ret;\n\tuint8_t *str;\n\tunsigned int str_size, len;\n\tgnutls_datum_t td;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tret =\n\t\t    asn1_decode_simple_ber(etype, der, der_size, &str, &str_size, NULL);\n\telse\n#endif\n\t\tret =\n\t\t    asn1_decode_simple_der(etype, der, der_size, (const uint8_t**)&str, &str_size);\n\tif (ret != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(ret);\n\t\treturn ret;\n\t}\n\ttd.size = str_size;\n\ttd.data = gnutls_malloc(str_size + 1);\n\tif (td.data == NULL)\n\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\tmemcpy(td.data, str, str_size);\n\ttd.data[str_size] = 0;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tfree(str);\n#endif\n\tret = make_printable_string(etype, &td, output);\n\tif (ret == GNUTLS_E_INVALID_REQUEST) {\t\n\t\toutput->data = td.data;\n\t\toutput->size = td.size;\n\t\tret = 0;\n\t} else if (ret <= 0) {\n\t\t_gnutls_free_datum(&td);\n\t}\n\tif (etype != ASN1_ETYPE_OCTET_STRING) {\n\t\tif (output->data)\n\t\t\tlen = strlen((void *) output->data);\n\t\telse\n\t\t\tlen = 0;\n\t\tif (len != (size_t) output->size) {\n\t\t\t_gnutls_free_datum(output);\n\t\t\tret = gnutls_assert_val(GNUTLS_E_ASN1_DER_ERROR);\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int em_grp45(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tswitch (ctxt->modrm_reg) {\n\tcase 2:  {\n\t\tlong int old_eip;\n\t\told_eip = ctxt->_eip;\n\t\tctxt->_eip = ctxt->src.val;\n\t\tctxt->src.val = old_eip;\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\tcase 4: \n\t\tctxt->_eip = ctxt->src.val;\n\t\tbreak;\n\tcase 5: \n\t\trc = em_jmp_far(ctxt);\n\t\tbreak;\n\tcase 6:\t\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "display_debug_links (struct dwarf_section *  section,\n\t\t     void *                  file ATTRIBUTE_UNUSED)\n{\n  const unsigned char * filename;\n  unsigned int          filelen;\n  introduce (section, false);\n  filename =  section->start;\n  filelen = strnlen ((const char *) filename, section->size);\n  if (filelen == section->size)\n    {\n      warn (_(\"The debuglink filename is corrupt/missing\\n\"));\n      return 0;\n    }\n  printf (_(\"  Separate debug info file: %s\\n\"), filename);\n  if (startswith (section->name, \".gnu_debuglink\"))\n    {\n      unsigned int          crc32;\n      unsigned int          crc_offset;\n      crc_offset = filelen + 1;\n      crc_offset = (crc_offset + 3) & ~3;\n      if (crc_offset + 4 > section->size)\n\t{\n\t  warn (_(\"CRC offset missing/truncated\\n\"));\n\t  return 0;\n\t}\n      crc32 = byte_get (filename + crc_offset, 4);\n      printf (_(\"  CRC value: %#x\\n\"), crc32);\n      if (crc_offset + 4 < section->size)\n\t{\n\t  warn (_(\"There are %#lx extraneous bytes at the end of the section\\n\"),\n\t\t(long)(section->size - (crc_offset + 4)));\n\t  return 0;\n\t}\n    }\n  else \n    {\n      const unsigned char * build_id = section->start + filelen + 1;\n      bfd_size_type         build_id_len = section->size - (filelen + 1);\n      bfd_size_type         printed;\n      if (build_id_len < 0x14)\n\t{\n\t  warn (_(\"Build-ID is too short (%#lx bytes)\\n\"), (long) build_id_len);\n\t  return 0;\n\t}\n      printed = printf (_(\"  Build-ID (%#lx bytes):\"), (long) build_id_len);\n      display_data (printed, build_id, build_id_len);\n      putchar ('\\n');\n    }\n  putchar ('\\n');\n  return 1;\n}", "target": 0}
{"code": "unsigned FAST_FUNC udhcp_option_idx(const char *name)\n{\n\tint n = index_in_strings(dhcp_option_strings, name);\n\tif (n >= 0)\n\t\treturn n;\n\t{\n\t\tchar buf[sizeof(dhcp_option_strings)];\n\t\tchar *d = buf;\n\t\tconst char *s = dhcp_option_strings;\n\t\twhile (s < dhcp_option_strings + sizeof(dhcp_option_strings) - 2) {\n\t\t\t*d++ = (*s == '\\0' ? ' ' : *s);\n\t\t\ts++;\n\t\t}\n\t\t*d = '\\0';\n\t\tbb_error_msg_and_die(\"unknown option '%s', known options: %s\", name, buf);\n\t}\n}", "target": 0}
{"code": "void HTMLSelectElement::recalcListItems(bool updateSelectedStates) const\n{\n    m_listItems.clear();\n    m_shouldRecalcListItems = false;\n    HTMLOptionElement* foundSelected = 0;\n    HTMLOptionElement* firstOption = 0;\n    for (Element* currentElement = ElementTraversal::firstWithin(*this); currentElement; ) {\n        if (!currentElement->isHTMLElement()) {\n            currentElement = ElementTraversal::nextSkippingChildren(*currentElement, this);\n            continue;\n        }\n        HTMLElement& current = toHTMLElement(*currentElement);\n        if (current.hasTagName(optgroupTag)) {\n            m_listItems.append(&current);\n            if (Element* nextElement = ElementTraversal::firstWithin(current)) {\n                currentElement = nextElement;\n                continue;\n            }\n        }\n        if (current.hasTagName(optionTag)) {\n            m_listItems.append(&current);\n            if (updateSelectedStates && !m_multiple) {\n                HTMLOptionElement& option = toHTMLOptionElement(current);\n                if (!firstOption)\n                    firstOption = &option;\n                if (option.selected()) {\n                    if (foundSelected)\n                        foundSelected->setSelectedState(false);\n                    foundSelected = &option;\n                } else if (m_size <= 1 && !foundSelected && !option.isDisabledFormControl()) {\n                    foundSelected = &option;\n                    foundSelected->setSelectedState(true);\n                }\n            }\n        }\n        if (current.hasTagName(hrTag))\n            m_listItems.append(&current);\n        currentElement = ElementTraversal::nextSkippingChildren(*currentElement, this);\n    }\n    if (!foundSelected && m_size <= 1 && firstOption && !firstOption->selected())\n        firstOption->setSelectedState(true);\n}", "target": 0}
{"code": "skip_string(char_u *p)\n{\n    int\t    i;\n    for ( ; ; ++p)\n    {\n\tif (p[0] == '\\'')\t\t    \n\t{\n\t    if (p[1] == NUL)\t\t    \n\t\tbreak;\n\t    i = 2;\n\t    if (p[1] == '\\\\' && p[2] != NUL)    \n\t    {\n\t\t++i;\n\t\twhile (vim_isdigit(p[i - 1]))   \n\t\t    ++i;\n\t    }\n\t    if (p[i] == '\\'')\t\t    \n\t    {\n\t\tp += i;\n\t\tcontinue;\n\t    }\n\t}\n\telse if (p[0] == '\"')\t\t    \n\t{\n\t    for (++p; p[0]; ++p)\n\t    {\n\t\tif (p[0] == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t\telse if (p[0] == '\"')\t    \n\t\t    break;\n\t    }\n\t    if (p[0] == '\"')\n\t\tcontinue; \n\t}\n\telse if (p[0] == 'R' && p[1] == '\"')\n\t{\n\t    char_u *delim = p + 2;\n\t    char_u *paren = vim_strchr(delim, '(');\n\t    if (paren != NULL)\n\t    {\n\t\tsize_t delim_len = paren - delim;\n\t\tfor (p += 3; *p; ++p)\n\t\t    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0\n\t\t\t    && p[delim_len + 1] == '\"')\n\t\t    {\n\t\t\tp += delim_len + 1;\n\t\t\tbreak;\n\t\t    }\n\t\tif (p[0] == '\"')\n\t\t    continue; \n\t    }\n\t}\n\tbreak;\t\t\t\t    \n    }\n    if (!*p)\n\t--p;\t\t\t\t    \n    return p;\n}", "target": 1}
{"code": "check_tty(const char *tty)\n{\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (strncmp(tty, \"/dev/\", 5) != 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\tif (strlen(tty) == 0) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}", "target": 1}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int pit_get_out(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\treturn out;\n}", "target": 0}
{"code": "static inline void kvm_memslot_delete(struct kvm_memslots *slots,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tstruct kvm_memory_slot *mslots = slots->memslots;\n\tint i;\n\tif (WARN_ON(slots->id_to_index[memslot->id] == -1))\n\t\treturn;\n\tslots->used_slots--;\n\tfor (i = slots->id_to_index[memslot->id]; i < slots->used_slots; i++) {\n\t\tmslots[i] = mslots[i + 1];\n\t\tslots->id_to_index[mslots[i].id] = i;\n\t}\n\tmslots[i] = *memslot;\n\tslots->id_to_index[memslot->id] = -1;\n}", "target": 1}
{"code": "bool chopOffDotted(string &domain)\n{\n  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot == string::npos)\n    return false;\n  if(fdot==domain.size()-1) \n    domain=\".\";\n  else  {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain);\n  }\n  return true;\n}", "target": 1}
{"code": "connection *connection_accept(server *srv, server_socket *srv_socket) {\n\tint cnt;\n\tsock_addr cnt_addr;\n\tsize_t cnt_len = sizeof(cnt_addr); \n\tif (srv->conns.used >= srv->max_conns) {\n\t\treturn NULL;\n\t}\n\tcnt = fdevent_accept_listenfd(srv_socket->fd, (struct sockaddr *) &cnt_addr, &cnt_len);\n\tif (-1 == cnt) {\n\t\tswitch (errno) {\n\t\tcase EAGAIN:\n#if EWOULDBLOCK != EAGAIN\n\t\tcase EWOULDBLOCK:\n#endif\n\t\tcase EINTR:\n\t\tcase ECONNABORTED: \n\t\t\tbreak;\n\t\tcase EMFILE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_perror(srv->errh, __FILE__, __LINE__, \"accept failed\");\n\t\t}\n\t\treturn NULL;\n\t} else {\n\t\tif (sock_addr_get_family(&cnt_addr) != AF_UNIX) {\n\t\t\tnetwork_accept_tcp_nagle_disable(cnt);\n\t\t}\n\t\treturn connection_accepted(srv, srv_socket, &cnt_addr, cnt);\n\t}\n}", "target": 0}
{"code": "static void *m_start(struct seq_file *seq, loff_t *ppos, struct uid_gid_map *map)\n{\n\tstruct uid_gid_extent *extent = NULL;\n\tloff_t pos = *ppos;\n\tif (pos < map->nr_extents)\n\t\textent = &map->extent[pos];\n\treturn extent;\n}", "target": 0}
{"code": "DECLARESepPutFunc(putRGBseparate8bittile)\n{\n    (void) img; (void) x; (void) y; (void) a;\n    while (h-- > 0) {\n\tUNROLL8(w, NOP, *cp++ = PACK(*r++, *g++, *b++));\n\tSKEW(r, g, b, fromskew);\n\tcp += toskew;\n    }\n}", "target": 0}
{"code": "const char* RtmpProtocol::handle_C2(const char *data, size_t len) {\n    if (len < C1_HANDSHARK_SIZE) {\n        return nullptr;\n    }\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_rtmp(data, len);\n    };\n    return handle_rtmp(data + C1_HANDSHARK_SIZE, len - C1_HANDSHARK_SIZE);\n}", "target": 0}
{"code": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"sock=%p\\n\", sock);\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}", "target": 1}
{"code": "static int proc_pid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer,\n#ifdef CONFIG_TASK_XACCT\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n#endif\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n#ifdef CONFIG_TASK_XACCT\n\t\t\t(unsigned long long)task->rchar,\n\t\t\t(unsigned long long)task->wchar,\n\t\t\t(unsigned long long)task->syscr,\n\t\t\t(unsigned long long)task->syscw,\n#endif\n\t\t\t(unsigned long long)task->ioac.read_bytes,\n\t\t\t(unsigned long long)task->ioac.write_bytes,\n\t\t\t(unsigned long long)task->ioac.cancelled_write_bytes);\n}", "target": 0}
{"code": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\tASSERT(apic != NULL);\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n\t\treturn 0;\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\treturn tmcct;\n}", "target": 1}
{"code": "static void openssl_thread_setup(void)\n{\n    int i;\n    if (CRYPTO_get_locking_callback() != NULL) {\n        red_dump_openssl_errors();\n        return;\n    }\n    lock_cs = (pthread_mutex_t*) OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));\n    for (i = 0; i < CRYPTO_num_locks(); i++) {\n        pthread_mutex_init(&(lock_cs[i]), NULL);\n    }\n    CRYPTO_THREADID_set_callback(pthreads_thread_id);\n    CRYPTO_set_locking_callback(pthreads_locking_callback);\n}", "target": 0}
{"code": "static int adpt_bios_param(struct scsi_device *sdev, struct block_device *dev,\n\t\tsector_t capacity, int geom[])\n{\n\tint heads=-1;\n\tint sectors=-1;\n\tint cylinders=-1;\n\tif (capacity < 0x2000 ) {\t\n\t\theads = 18;\n\t\tsectors = 2;\n\t} \n\telse if (capacity < 0x20000) {\n\t\theads = 64;\n\t\tsectors = 32;\n\t}\n\telse if (capacity < 0x40000) {\n\t\theads = 65;\n\t\tsectors = 63;\n\t}\n\telse if (capacity < 0x80000) {\n\t\theads = 128;\n\t\tsectors = 63;\n\t}\n\telse {\n\t\theads = 255;\n\t\tsectors = 63;\n\t}\n\tcylinders = sector_div(capacity, heads * sectors);\n\tif(sdev->type == 5) {  \n\t\theads = 252;\n\t\tsectors = 63;\n\t\tcylinders = 1111;\n\t}\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\tPDEBUG(\"adpt_bios_param: exit\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\tif (WARN_ON(!info))\n\t\treturn;\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\tif (!list_empty(&info->eoi_list))\n\t\tlateeoi_list_del(info);\n\tlist_del(&info->list);\n\tset_info_for_irq(irq, NULL);\n\tWARN_ON(info->refcnt > 0);\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\tkfree(info);\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\tirq_free_desc(irq);\n}", "target": 0}
{"code": "escape_attach (int argc, char **argv, compose_env_t *env)\n{\n  const char *encoding = default_encoding;\n  const char *content_type = default_content_type;\n  switch (argc)\n    {\n    case 4:\n      encoding = argv[3];\n    case 3:\n      content_type = argv[2];\n    case 2:\n      return attlist_attach_file (&env->attlist,\n\t\t\t\t  -1, argv[1], argv[1], argv[1],\n\t\t\t\t  content_type, encoding);\n    default:\n      return escape_check_args (argc, argv, 2, 4);\n    }\n  return 1;\n}", "target": 0}
{"code": "rdr_notification_ctx_init(struct rdr_notification_ctx *ctx)\n{\n\tdeltas_parsed_init(&ctx->deltas);\n\treturn 0;\n}", "target": 1}
{"code": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\tif (line == NULL)\n\t\treturn (0);\n\tif (*line != '<')\n\t\treturn (0);\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options *opt;\n\tstruct inet_request_sock *req_inet;\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\tcipso_v4_delopt(&req_inet->opt);\n}", "target": 1}
{"code": "static int get_vmx_mem_address(struct kvm_vcpu *vcpu,\n\t\t\t\t unsigned long exit_qualification,\n\t\t\t\t u32 vmx_instruction_info, gva_t *ret)\n{\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\t*ret = vmx_get_segment_base(vcpu, seg_reg);\n\tif (base_is_valid)\n\t\t*ret += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\t*ret += kvm_register_read(vcpu, index_reg)<<scaling;\n\t*ret += exit_qualification; \n\tif (addr_size == 1) \n\t\t*ret &= 0xffffffff;\n\treturn 0;\n}", "target": 0}
{"code": "static void cac_free_private_data(cac_private_data_t *priv)\n{\n\tfree(priv->cac_id);\n\tfree(priv->cache_buf);\n\tfree(priv->aca_path);\n\tlist_destroy(&priv->pki_list);\n\tlist_destroy(&priv->general_list);\n\tfree(priv);\n\treturn;\n}", "target": 0}
{"code": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\tsk_setup_caps(newsk, dst);\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\treturn newsk;\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1}
{"code": "static void unzzip_cat_file(ZZIP_DIR* disk, char* name, FILE* out)\n{\n    ZZIP_FILE* file = zzip_file_open (disk, name, 0);\n    if (file) \n    {\n\tchar buffer[1024]; int len;\n\twhile ((len = zzip_file_read (file, buffer, 1024))) \n\t{\n\t    fwrite (buffer, 1, len, out);\n\t}\n\tzzip_file_close (file);\n    }\n}", "target": 1}
{"code": "convert_protocol_address(struct sockaddr* saddr, unsigned int saddrlen)\n{\n    PyObject *res_obj = NULL;\n    switch (saddr->sa_family)\n    {\n    case AF_INET:\n        {\n            struct sockaddr_in* sin = (struct sockaddr_in*)saddr;\n            char *addr_str = (char *)PyMem_Malloc(INET_ADDRSTRLEN);\n            if (addr_str == NULL) {\n                PyErr_SetString(ErrorObject, \"Out of memory\");\n                goto error;\n            }\n            if (inet_ntop(saddr->sa_family, &sin->sin_addr, addr_str, INET_ADDRSTRLEN) == NULL) {\n                PyErr_SetFromErrno(ErrorObject);\n                PyMem_Free(addr_str);\n                goto error;\n            }\n            res_obj = Py_BuildValue(\"(si)\", addr_str, ntohs(sin->sin_port));\n            PyMem_Free(addr_str);\n       }\n        break;\n    case AF_INET6:\n        {\n            struct sockaddr_in6* sin6 = (struct sockaddr_in6*)saddr;\n            char *addr_str = (char *)PyMem_Malloc(INET6_ADDRSTRLEN);\n            if (addr_str == NULL) {\n                PyErr_SetString(ErrorObject, \"Out of memory\");\n                goto error;\n            }\n            if (inet_ntop(saddr->sa_family, &sin6->sin6_addr, addr_str, INET6_ADDRSTRLEN) == NULL) {\n                PyErr_SetFromErrno(ErrorObject);\n                PyMem_Free(addr_str);\n                goto error;\n            }\n            res_obj = Py_BuildValue(\"(si)\", addr_str, ntohs(sin6->sin6_port));\n            PyMem_Free(addr_str);\n        }\n        break;\n    default:\n        PyErr_SetString(ErrorObject, \"Unsupported address family.\");\n    }\nerror:\n    return res_obj;\n}", "target": 0}
{"code": "parse_memory(VALUE klass, VALUE data, VALUE encoding)\n{\n  htmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = htmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                    (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  if (RTEST(encoding)) {\n    xmlCharEncodingHandlerPtr enc = xmlFindCharEncodingHandler(StringValueCStr(encoding));\n    if (enc != NULL) {\n      xmlSwitchToEncoding(ctxt, enc);\n      if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n        rb_raise(rb_eRuntimeError, \"Unsupported encoding %s\",\n                 StringValueCStr(encoding));\n      }\n    }\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)\n{\n    void **p = ptr;\n    if (min_size < *size)\n        return 0;\n    min_size = FFMAX(17 * min_size / 16 + 32, min_size);\n    av_free(*p);\n    *p = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);\n    if (!*p)\n        min_size = 0;\n    *size = min_size;\n    return 1;\n}", "target": 0}
{"code": "storageConnectGetCapabilities(virConnectPtr conn)\n{\n    if (virConnectGetCapabilitiesEnsureACL(conn) < 0)\n        return NULL;\n    return virCapabilitiesFormatXML(driver->caps);\n}", "target": 0}
{"code": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}", "target": 1}
{"code": "GtkWidget* MenuGtk::BuildMenuItemWithImage(const std::string& label,\n                                           const SkBitmap& icon) {\n  std::string converted_label = ConvertAcceleratorsFromWindowsStyle(label);\n  GtkWidget* menu_item =\n      gtk_image_menu_item_new_with_mnemonic(converted_label.c_str());\n  GdkPixbuf* pixbuf = gfx::GdkPixbufFromSkBitmap(&icon);\n  gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item),\n                                gtk_image_new_from_pixbuf(pixbuf));\n  g_object_unref(pixbuf);\n  if (delegate_->AlwaysShowImages())\n    gtk_util::SetAlwaysShowImage(menu_item);\n  return menu_item;\n}", "target": 0}
{"code": "SSL_SESSION *SSL_SESSION_dup(const SSL_SESSION *src)\n{\n    return ssl_session_dup(src, 1);\n}", "target": 1}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(LocalFileHeader) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), local_file_header_signature, sizeof(local_file_header_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&minimum_version), buffer.data() + sizeof(local_file_header_signature), fields_size);\n        name = buffer.data() + sizeof(local_file_header_signature) + fields_size;\n        extra_data = name + name_length;\n        compressed_data = extra_data + extra_data_length;\n        return true;\n    }", "target": 1}
{"code": "static int mpeg4_update_thread_context(AVCodecContext *dst,\n                                       const AVCodecContext *src)\n{\n    Mpeg4DecContext *s = dst->priv_data;\n    const Mpeg4DecContext *s1 = src->priv_data;\n    int ret = ff_mpeg_update_thread_context(dst, src);\n    if (ret < 0)\n        return ret;\n    memcpy(((uint8_t*)s) + sizeof(MpegEncContext), ((uint8_t*)s1) + sizeof(MpegEncContext), sizeof(Mpeg4DecContext) - sizeof(MpegEncContext));\n    return 0;\n}", "target": 0}
{"code": "static void n_tty_close(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\tvfree(ldata);\n\ttty->disc_data = NULL;\n}", "target": 0}
{"code": "static void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tbool isolated_pageblocks;\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\twhile (count) {\n\t\tstruct page *page;\n\t\tstruct list_head *list;\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\t\tdo {\n\t\t\tint mt;\t\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\tmt = get_pcppage_migratetype(page);\n\t\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t\tif (unlikely(isolated_pageblocks))\n\t\t\t\tmt = get_pageblock_migratetype(page);\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\t\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\tspin_unlock(&zone->lock);\n}", "target": 0}
{"code": "static void pdf_run_BDC(fz_context *ctx, pdf_processor *proc, const char *tag, pdf_obj *raw, pdf_obj *cooked)\n{\n}", "target": 0}
{"code": "  CookieHashMethod(const std::string& key, const std::string& path,\n                   const absl::optional<std::chrono::seconds>& ttl, bool terminal,\n                   const CookieAttributeRefVector attributes)\n      : HashMethodImplBase(terminal), key_(key), path_(path), ttl_(ttl), attributes_(attributes) {}", "target": 1}
{"code": "dump_threads(void)\n{\n\tFILE *fp;\n\tchar time_buf[26];\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *file_name;\n\tfile_name = make_file_name(\"/tmp/thread_dump.dat\",\n\t\t\t\t\t\"vrrp\",\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\tglobal_data->instance_name);\n\tfp = fopen(file_name, \"a\");\n\tFREE(file_name);\n\tset_time_now();\n\tctime_r(&time_now.tv_sec, time_buf);\n\tfprintf(fp, \"\\n%.19s.%6.6ld: Thread dump\\n\", time_buf, time_now.tv_usec);\n\tdump_thread_data(master, fp);\n\tfprintf(fp, \"alloc = %lu\\n\", master->alloc);\n\tfprintf(fp, \"\\n\");\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tctime_r(&vrrp->sands.tv_sec, time_buf);\n\t\tfprintf(fp, \"VRRP instance %s, sands %.19s.%6.6lu, status %s\\n\", vrrp->iname, time_buf, vrrp->sands.tv_usec,\n\t\t\t\tvrrp->state == VRRP_STATE_INIT ? \"INIT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_BACK ? \"BACKUP\" :\n\t\t\t\tvrrp->state == VRRP_STATE_MAST ? \"MASTER\" :\n\t\t\t\tvrrp->state == VRRP_STATE_FAULT ? \"FAULT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_STOP ? \"STOP\" :\n\t\t\t\tvrrp->state == VRRP_DISPATCHER ? \"DISPATCHER\" : \"unknown\");\n\t}\n\tfclose(fp);\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<_cimg_Ttfloat> get_solve(const CImg<t>& A) const {\n      return CImg<_cimg_Ttfloat>(*this,false).solve(A);", "target": 0}
{"code": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tint size = NLMSG_LENGTH(len);\n\tnlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = pid;\n\tnlh->nlmsg_seq = seq;\n\treturn nlh;\n}", "target": 1}
{"code": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = to_hv_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}", "target": 1}
{"code": "set_range(bitstr_t *bits, int low, int high, int start, int stop, int step) {\n\tDebug(DPARS|DEXT, (\"set_range(?,%d,%d,%d,%d,%d)\\n\",\n\t\t\t   low, high, start, stop, step))\n\tif (start < low || stop > high)\n\t\treturn (EOF);\n\tstart -= low;\n\tstop -= low;\n\tif (step == 1) {\n\t\tbit_nset(bits, start, stop);\n\t} else {\n\t\tfor (int i = start; i <= stop; i += step)\n\t\t\tbit_set(bits, i);\n\t}\n\treturn (OK);\n}", "target": 1}
{"code": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}", "target": 1}
{"code": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n    SafeStringValue(path);\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n    if (status < 0) {\n\tint e = errno;\n\tclose(fd);\n\trsock_syserr_fail_path(e, \"connect(2)\", path);\n    }\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    int e = errno;\n\t    close(fd);\n\t    rsock_syserr_fail_path(e, \"listen(2)\", path);\n\t}\n    }\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n    return sock;\n}", "target": 1}
{"code": "static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (!host->reg_va09)\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}", "target": 1}
{"code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp++;\t\t\t\t\n\targs->offset = ntohl(*p++);\t\n\tp++;\t\t\t\t\n\tlen = args->len = ntohl(*p++);\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static u8 adpt_read_blink_led(adpt_hba* host)\n{\n\tif (host->FwDebugBLEDflag_P) {\n\t\tif( readb(host->FwDebugBLEDflag_P) == 0xbc ){\n\t\t\treturn readb(host->FwDebugBLEDvalue_P);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  if (input == nullptr) {\n    VLOG(1) << \"node = \" << node.name() << \" input = \" << node.input(0);\n    return false;\n  }\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static ssize_t driver_override_show(struct device *_dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\treturn sprintf(buf, \"%s\\n\", dev->driver_override);\n}", "target": 1}
{"code": "comics_document_thumbnails_get_thumbnail (EvDocumentThumbnails *document,\n\t\t\t\t\t  EvRenderContext      *rc,\n\t\t\t\t\t  gboolean              border)\n{\n\tGdkPixbuf *thumbnail;\n\tthumbnail = comics_document_render_pixbuf (EV_DOCUMENT (document), rc);\n\tif (border) {\n\t      GdkPixbuf *tmp_pixbuf = thumbnail;\n\t      thumbnail = ev_document_misc_get_thumbnail_frame (-1, -1, tmp_pixbuf);\n\t      g_object_unref (tmp_pixbuf);\n\t}\n\treturn thumbnail;\n}", "target": 1}
{"code": "static void phys_map_node_reserve(PhysPageMap *map, unsigned nodes)\n{\n    if (map->nodes_nb + nodes > map->nodes_nb_alloc) {\n        map->nodes_nb_alloc = MAX(map->nodes_nb_alloc * 2, 16);\n        map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, map->nodes_nb + nodes);\n        map->nodes = g_renew(Node, map->nodes, map->nodes_nb_alloc);\n    }\n}", "target": 0}
{"code": "WandExport double *DrawGetStrokeDashArray(const DrawingWand *wand,\n  size_t *number_elements)\n{\n  double\n    *dasharray;\n  register const double\n    *p;\n  register double\n    *q;\n  register ssize_t\n    i;\n  size_t\n    n;\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  assert(number_elements != (size_t *) NULL);\n  n=0;\n  p=CurrentContext->dash_pattern;\n  if (p != (const double *) NULL)\n    while (fabs(*p++) >= MagickEpsilon)\n      n++;\n  *number_elements=n;\n  dasharray=(double *) NULL;\n  if (n != 0)\n    {\n      dasharray=(double *) AcquireQuantumMemory((size_t) n+1UL,\n        sizeof(*dasharray));\n      p=CurrentContext->dash_pattern;\n      q=dasharray;\n      for (i=0; i < (ssize_t) n; i++)\n        *q++=(*p++);\n      *q=0.0;\n    }\n  return(dasharray);\n}", "target": 1}
{"code": "static int vmx_set_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_msr_entry *msr;\n\tu64 host_tsc;\n\tint ret = 0;\n\tswitch (msr_index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_EFER:\n\t\tvmx_load_host_state(vmx);\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t\tbreak;\n\tcase MSR_FS_BASE:\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_TIME_STAMP_COUNTER:\n\t\trdtscll(host_tsc);\n\t\tguest_write_tsc(data, host_tsc);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tpr_unimpl(vcpu, \"unimplemented perfctr wrmsr: 0x%x data 0x%llx\\n\", msr_index, data);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tvmx_load_host_state(vmx);\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tmsr->data = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\treturn err;\n}", "target": 1}
{"code": "test_append_uri_pathel(void)\n{\n  unsigned i;\n  static const struct {\n    const char *original_url;\n    const char *input;\n    bool escaped;\n    const char *expected_result;\n  } test_array[] = {\n    { \"http:\n  };\n  for (i = 0; i < countof(test_array); ++i)\n    {\n      struct growable dest;\n      const char *p = test_array[i].input;\n      memset (&dest, 0, sizeof (dest));\n      append_string (test_array[i].original_url, &dest);\n      append_uri_pathel (p, p + strlen(p), test_array[i].escaped, &dest);\n      mu_assert (\"test_append_uri_pathel: wrong result\",\n                 strcmp (dest.base, test_array[i].expected_result) == 0);\n      xfree (dest.base);\n    }\n  return NULL;\n}", "target": 0}
{"code": "static void vnc_client_cache_addr(VncState *client)\n{\n    Error *err = NULL;\n    client->info = g_malloc0(sizeof(*client->info));\n    vnc_init_basic_info_from_remote_addr(client->sioc,\n                                         qapi_VncClientInfo_base(client->info),\n                                         &err);\n    client->info->websocket = client->websocket;\n    if (err) {\n        qapi_free_VncClientInfo(client->info);\n        client->info = NULL;\n        error_free(err);\n    }\n}", "target": 0}
{"code": "stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\t\treset_globals();\n\t\treturn e;\n\t}\n}", "target": 1}
{"code": "MenuCacheItem *menu_cache_find_child_by_name(MenuCacheDir *dir, const char *name)\n{\n    GSList *child;\n    MenuCacheItem *item = NULL;\n    if (MENU_CACHE_ITEM(dir)->type != MENU_CACHE_TYPE_DIR || name == NULL)\n        return NULL;\n    MENU_CACHE_LOCK;\n    for (child = dir->children; child; child = child->next)\n        if (g_strcmp0(MENU_CACHE_ITEM(child->data)->name, name) == 0)\n        {\n            item = menu_cache_item_ref(child->data);\n            break;\n        }\n    MENU_CACHE_UNLOCK;\n    return item;\n}", "target": 0}
{"code": "void RenderView::printPage(WebFrame* frame) {\n  DCHECK(frame);\n  Print(frame, true);\n}", "target": 0}
{"code": "int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint r = 1;\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\tif (!is_long_mode(vcpu)) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}", "target": 0}
{"code": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}", "target": 1}
{"code": "uint STDCALL mysql_thread_safe(void)\n{\n  return 1;\n}", "target": 0}
{"code": "      explicit JpegOutput( String const& filename ) {\n         if( FileHasExtension( filename )) {\n            outfile_ = std::fopen(filename.c_str(), \"wb\");\n         } else {\n            outfile_ = std::fopen( FileAddExtension( filename, \"jpg\" ).c_str(), \"wb\" );\n         }\n         if( outfile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open file for writing\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            DIP_THROW_RUNTIME( \"Error writing JPEG file.\" );\n         }\n         jpeg_create_compress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_dest( &cinfo_, outfile_ );\n      }", "target": 1}
{"code": "cib_remote_auth(xmlNode *login)\n{\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        return FALSE;\n    }\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        return FALSE;\n    }\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        return FALSE;\n    }\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n    if (!user || !pass) {\n        crm_err(\"missing auth credentials\");\n        return FALSE;\n    }\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        return FALSE;\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "PGTYPEStimestamp_from_asc(char *str, char **endptr)\n{\n\ttimestamp\tresult;\n#ifdef HAVE_INT64_TIMESTAMP\n\tint64\t\tnoresult = 0;\n#else\n\tdouble\t\tnoresult = 0.0;\n#endif\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, 0) != 0)\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\t\treturn (noresult);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\t\tcase DTK_INVALID:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t\tdefault:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "static int checksum_setup(struct net_device *dev, struct sk_buff *skb)\n{\n\tbool recalculate_partial_csum = false;\n\tif (skb->ip_summed != CHECKSUM_PARTIAL && skb_is_gso(skb)) {\n\t\tstruct netfront_info *np = netdev_priv(dev);\n\t\tatomic_inc(&np->rx_gso_checksum_fixup);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\trecalculate_partial_csum = true;\n\t}\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn 0;\n\treturn skb_checksum_setup(skb, recalculate_partial_csum);\n}", "target": 0}
{"code": "static struct tipc_node *tipc_node_find_by_id(struct net *net, u8 *id)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_node *n;\n\tbool found = false;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(n, &tn->node_list, list) {\n\t\tread_lock_bh(&n->lock);\n\t\tif (!memcmp(id, n->peer_id, 16) &&\n\t\t    kref_get_unless_zero(&n->kref))\n\t\t\tfound = true;\n\t\tread_unlock_bh(&n->lock);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn found ? n : NULL;\n}", "target": 0}
{"code": "static void init_macros(void)\n{\n}", "target": 0}
{"code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n    return sRet + \"/\";\n}", "target": 1}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  return len;\n}", "target": 1}
{"code": "die(uschar *s1, uschar *s2)\n{\nif (s1)\n  {\n  write_syslog(LOG_CRIT, s1);\n  if (debug_file) debug_printf(\"%s\\n\", s1);\n  if (log_stderr && log_stderr != debug_file)\n    fprintf(log_stderr, \"%s\\n\", s1);\n  }\nif (f.receive_call_bombout) receive_bomb_out(NULL, s2);  \nif (smtp_input) smtp_closedown(s2);\nexim_exit(EXIT_FAILURE, NULL);\n}", "target": 0}
{"code": "static int __tail_onwire_len(int front_len, int middle_len, int data_len,\n\t\t\t     bool secure)\n{\n\tBUG_ON(front_len < 0 || front_len > CEPH_MSG_MAX_FRONT_LEN ||\n\t       middle_len < 0 || middle_len > CEPH_MSG_MAX_MIDDLE_LEN ||\n\t       data_len < 0 || data_len > CEPH_MSG_MAX_DATA_LEN);\n\tif (!front_len && !middle_len && !data_len)\n\t\treturn 0;\n\tif (!secure)\n\t\treturn front_len + middle_len + data_len +\n\t\t       CEPH_EPILOGUE_PLAIN_LEN;\n\treturn padded_len(front_len) + padded_len(middle_len) +\n\t       padded_len(data_len) + CEPH_EPILOGUE_SECURE_LEN;\n}", "target": 0}
{"code": "static int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}", "target": 1}
{"code": "ex_put(exarg_T *eap)\n{\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}", "target": 1}
{"code": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\tif (inode_capable(inode, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n\treturn do_dentry_open(file, inode, NULL, cred);\n}", "target": 1}
{"code": "  void SetInput(std::initializer_list<float> data) {\n    QuantizeAndPopulate<uint8_t>(input_, data);\n  }", "target": 0}
{"code": "  virtual void ConnectToCellularNetwork(const CellularNetwork* network) {\n    DCHECK(network);\n    if (!EnsureCrosLoaded())\n      return;\n    if (network && ConnectToNetwork(network->service_path().c_str(), NULL)) {\n      CellularNetwork* cellular = GetWirelessNetworkByPath(\n          cellular_networks_, network->service_path());\n      if (cellular) {\n        cellular->set_connecting(true);\n        cellular_ = cellular;\n      }\n      NotifyNetworkManagerChanged();\n    }\n  }", "target": 0}
{"code": "ssh_packet_set_compress_hooks(struct ssh *ssh, void *ctx,\n    void *(*allocfunc)(void *, u_int, u_int),\n    void (*freefunc)(void *, void *))\n{\n\tssh->state->compression_out_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_out_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_out_stream.opaque = ctx;\n\tssh->state->compression_in_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_in_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_in_stream.opaque = ctx;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\tretval = sctp_make_reconf(asoc, outlen + inlen);\n\tif (!retval)\n\t\treturn NULL;\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\treturn retval;\n}", "target": 1}
{"code": "static void _WM_CheckEventMemoryPool(struct _mdi *mdi) {\n    if ((mdi->event_count + 1) >= mdi->events_size) {\n        mdi->events_size += MEM_CHUNK;\n        mdi->events = realloc(mdi->events,\n                              (mdi->events_size * sizeof(struct _event)));\n    }\n}", "target": 0}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4151 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "static int ipip6_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\tiph = ip_hdr(skb);\n\tread_lock(&ipip6_lock);\n\tif ((tunnel = ipip6_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\t\tiph->saddr, iph->daddr)) != NULL) {\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tIPCB(skb)->flags = 0;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tif ((tunnel->dev->priv_flags & IFF_ISATAP) &&\n\t\t    !isatap_chksrc(skb, iph, tunnel)) {\n\t\t\ttunnel->stat.rx_errors++;\n\t\t\tread_unlock(&ipip6_lock);\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\ttunnel->stat.rx_packets++;\n\t\ttunnel->stat.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tdst_release(skb->dst);\n\t\tskb->dst = NULL;\n\t\tnf_reset(skb);\n\t\tipip6_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\tread_unlock(&ipip6_lock);\n\t\treturn 0;\n\t}\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\tkfree_skb(skb);\n\tread_unlock(&ipip6_lock);\nout:\n\treturn 0;\n}", "target": 1}
{"code": "static void ldapsrv_process_call_trigger(struct tevent_req *req,\n\t\t\t\t\t void *private_data)\n{\n\tstruct ldapsrv_process_call_state *state =\n\t\ttevent_req_data(req,\n\t\tstruct ldapsrv_process_call_state);\n\tstruct ldapsrv_connection *conn = state->call->conn;\n\tNTSTATUS status;\n\tif (conn->deferred_expire_disconnect != NULL) {\n\t\ttevent_req_done(req);\n\t\treturn;\n\t}\n\tstatus = ldapsrv_do_call(state->call);\n\tif (NT_STATUS_EQUAL(status, NT_STATUS_NETWORK_SESSION_EXPIRED)) {\n\t\tint defer_msec = lpcfg_parm_int(\n\t\t\tconn->lp_ctx,\n\t\t\tNULL,\n\t\t\t\"ldap_server\",\n\t\t\t\"delay_expire_disconnect\",\n\t\t\t0);\n\t\tconn->deferred_expire_disconnect = tevent_wakeup_send(\n\t\t\tconn,\n\t\t\tconn->connection->event.ctx,\n\t\t\ttimeval_current_ofs_msec(defer_msec));\n\t\tif (tevent_req_nomem(conn->deferred_expire_disconnect, req)) {\n\t\t\treturn;\n\t\t}\n\t\ttevent_req_set_callback(\n\t\t\tconn->deferred_expire_disconnect,\n\t\t\tldapsrv_disconnect_ticket_expired,\n\t\t\tconn);\n\t\ttevent_req_done(req);\n\t\treturn;\n\t}\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\ttevent_req_nterror(req, status);\n\t\treturn;\n\t}\n\ttevent_req_done(req);\n}", "target": 0}
{"code": "Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}", "target": 1}
{"code": "smb2_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease *buf;\n\tbuf = kzalloc(sizeof(struct create_lease), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tmemcpy(&buf->lcontext.LeaseKey, lease_key, SMB2_LEASE_KEY_SIZE);\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}", "target": 0}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "juniper_mfr_print(netdissect_options *ndo,\n                  const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        memset(&l2info, 0, sizeof(l2info));\n        l2info.pictype = DLT_JUNIPER_MFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie_len == 0) {\n            mfr_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        }\n        if (l2info.cookie_len == AS_PIC_COOKIE_LEN) {\n            switch(l2info.proto) {\n            case JUNIPER_LSQ_L3_PROTO_IPV4:\n                ip_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_IPV6:\n                ip6_print(ndo, p,l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_MPLS:\n                mpls_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_ISO:\n                isoclns_print(ndo, p, l2info.length, l2info.caplen);\n                return l2info.header_len;\n            default:\n                break;\n            }\n            return l2info.header_len;\n        }\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLCSAP_ISONS<<8 | LLCSAP_ISONS):\n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "static int is_branch32_taken(struct bpf_reg_state *reg, u32 val, u8 opcode)\n{\n\tstruct tnum subreg = tnum_subreg(reg->var_off);\n\ts32 sval = (s32)val;\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !!tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JNE:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JSET:\n\t\tif ((~subreg.mask & subreg.value) & val)\n\t\t\treturn 1;\n\t\tif (!((subreg.mask | subreg.value) & val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\tif (reg->u32_min_value > val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value <= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGT:\n\t\tif (reg->s32_min_value > sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value <= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLT:\n\t\tif (reg->u32_max_value < val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value >= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLT:\n\t\tif (reg->s32_max_value < sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value >= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\tif (reg->u32_min_value >= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value < val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGE:\n\t\tif (reg->s32_min_value >= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value < sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLE:\n\t\tif (reg->u32_max_value <= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value > val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLE:\n\t\tif (reg->s32_max_value <= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value > sval)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "static inline int rtnetlink_fill_iwinfo(struct sk_buff *\tskb,\n\t\t\t\t\tstruct net_device *\tdev,\n\t\t\t\t\tint\t\t\ttype,\n\t\t\t\t\tchar *\t\t\tevent,\n\t\t\t\t\tint\t\t\tevent_len)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tnlh = NLMSG_PUT(skb, 0, 0, type, sizeof(*r));\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev->flags;\n\tr->ifi_change = 0;\t\n\tRTA_PUT(skb, IFLA_WIRELESS,\n\t\tevent_len, event);\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "    const CImgList<T>& save_gzip_external(const char *const filename) const {\n      if (!filename)\n        throw CImgIOException(_cimglist_instance\n                              \"save_gzip_external(): Specified filename is (null).\",\n                              cimglist_instance);\n      CImg<charT> command(1024), filename_tmp(256), body(256);\n      const char\n        *ext = cimg::split_filename(filename,body),\n        *ext2 = cimg::split_filename(body,0);\n      std::FILE *file;\n      do {\n        if (!cimg::strcasecmp(ext,\"gz\")) {\n          if (*ext2) cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.%s\",\n                                   cimg::temporary_path(),cimg_file_separator,cimg::filenamerand(),ext2);\n          else cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.cimg\",\n                             cimg::temporary_path(),cimg_file_separator,cimg::filenamerand());\n        } else {\n          if (*ext) cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.%s\",\n                                  cimg::temporary_path(),cimg_file_separator,cimg::filenamerand(),ext);\n          else cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.cimg\",\n                             cimg::temporary_path(),cimg_file_separator,cimg::filenamerand());\n        }\n        if ((file=std_fopen(filename_tmp,\"rb\"))!=0) cimg::fclose(file);\n      } while (file);\n      if (is_saveable(body)) {\n        save(filename_tmp);\n        cimg_snprintf(command,command._width,\"%s -c \\\"%s\\\" > \\\"%s\\\"\",\n                      cimg::gzip_path(),\n                      CImg<charT>::string(filename_tmp)._system_strescape().data(),\n                      CImg<charT>::string(filename)._system_strescape().data());\n        cimg::system(command);\n        file = std_fopen(filename,\"rb\");\n        if (!file)\n          throw CImgIOException(_cimglist_instance\n                                \"save_gzip_external(): Failed to save file '%s' with external command 'gzip'.\",\n                                cimglist_instance,\n                                filename);\n        else cimg::fclose(file);\n        std::remove(filename_tmp);\n      } else {\n        CImg<charT> nfilename(1024);\n        cimglist_for(*this,l) {\n          cimg::number_filename(body,l,6,nfilename);\n          if (*ext) cimg_sprintf(nfilename._data + std::strlen(nfilename),\".%s\",ext);\n          _data[l].save_gzip_external(nfilename);", "target": 0}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\treturn 0;\n}", "target": 1}
{"code": "static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", 3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     \n        filter.tensor<T, 5>(),                           \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "initialize(int argc, VALUE argv[], VALUE self)\n{\n    ffi_cif * cif;\n    ffi_type **arg_types;\n    ffi_status result;\n    VALUE ptr, args, ret_type, abi, kwds;\n    long i;\n    rb_scan_args(argc, argv, \"31:\", &ptr, &args, &ret_type, &abi, &kwds);\n    if(NIL_P(abi)) abi = INT2NUM(FFI_DEFAULT_ABI);\n    Check_Type(args, T_ARRAY);\n    Check_Max_Args(\"args\", RARRAY_LENINT(args));\n    rb_iv_set(self, \"@ptr\", ptr);\n    rb_iv_set(self, \"@args\", args);\n    rb_iv_set(self, \"@return_type\", ret_type);\n    rb_iv_set(self, \"@abi\", abi);\n    if (!NIL_P(kwds)) rb_hash_foreach(kwds, parse_keyword_arg_i, self);\n    TypedData_Get_Struct(self, ffi_cif, &function_data_type, cif);\n    arg_types = xcalloc(RARRAY_LEN(args) + 1, sizeof(ffi_type *));\n    for (i = 0; i < RARRAY_LEN(args); i++) {\n\tint type = NUM2INT(RARRAY_AREF(args, i));\n\targ_types[i] = INT2FFI_TYPE(type);\n    }\n    arg_types[RARRAY_LEN(args)] = NULL;\n    result = ffi_prep_cif (\n\t    cif,\n\t    NUM2INT(abi),\n\t    RARRAY_LENINT(args),\n\t    INT2FFI_TYPE(NUM2INT(ret_type)),\n\t    arg_types);\n    if (result)\n\trb_raise(rb_eRuntimeError, \"error creating CIF %d\", result);\n    return self;\n}", "target": 1}
{"code": "mm_compare(struct mm_share *a, struct mm_share *b)\n{\n\tptrdiff_t diff = (char *)a->address - (char *)b->address;\n\tif (diff == 0)\n\t\treturn (0);\n\telse if (diff < 0)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}", "target": 1}
{"code": "void FreeMenuItem(const PP_Flash_MenuItem* menu_item) {\n  if (menu_item->name)\n    delete [] menu_item->name;\n  if (menu_item->submenu)\n    FreeMenu(menu_item->submenu);\n}", "target": 0}
{"code": "int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tstruct cp_control cpc;\n\tint err = 0;\n\tif (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\tcpc.trimmed = 0;\n\tif (end <= MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\"Found FS corruption, run fsck to fix.\");\n\t\tgoto out;\n\t}\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));\n\tfor (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {\n\t\tcpc.trim_start = start_segno;\n\t\tif (sbi->discard_blks == 0)\n\t\t\tbreak;\n\t\telse if (sbi->discard_blks < BATCHED_TRIM_BLOCKS(sbi))\n\t\t\tcpc.trim_end = end_segno;\n\t\telse\n\t\t\tcpc.trim_end = min_t(unsigned int,\n\t\t\t\trounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1, end_segno);\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\terr = write_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t\tif (err)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tmark_discard_range_all(sbi);\n\tf2fs_wait_discard_bios(sbi);\nout:\n\trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n\treturn err;\n}", "target": 1}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool TextAutosizer::processSubtree(RenderObject* layoutRoot)\n{\n    if (!m_document->settings() || !m_document->settings()->textAutosizingEnabled() || layoutRoot->view()->printing() || !m_document->page())\n        return false;\n    Frame* mainFrame = m_document->page()->mainFrame();\n    TextAutosizingWindowInfo windowInfo;\n     windowInfo.windowSize = m_document->settings()->textAutosizingWindowSizeOverride();\n     if (windowInfo.windowSize.isEmpty()) {\n         bool includeScrollbars = !InspectorInstrumentation::shouldApplyScreenWidthOverride(mainFrame);\n        windowInfo.windowSize = mainFrame->view()->visibleContentRect(includeScrollbars).size(); \n     }\n    windowInfo.minLayoutSize = mainFrame->view()->layoutSize();\n    for (Frame* frame = m_document->frame(); frame; frame = frame->tree()->parent()) {\n        if (!frame->view()->isInChildFrameWithFrameFlattening())\n            windowInfo.minLayoutSize = windowInfo.minLayoutSize.shrunkTo(frame->view()->layoutSize());\n    }\n    RenderBlock* container = layoutRoot->isRenderBlock() ? toRenderBlock(layoutRoot) : layoutRoot->containingBlock();\n    while (container && !isAutosizingContainer(container))\n        container = container->containingBlock();\n    RenderBlock* cluster = container;\n    while (cluster && (!isAutosizingContainer(cluster) || !isAutosizingCluster(cluster)))\n        cluster = cluster->containingBlock();\n    processCluster(cluster, container, layoutRoot, windowInfo);\n    return true;\n}", "target": 1}
{"code": "int test(char *URL)\n{\n  int errors = 0;\n  (void)URL; \n  errors += test_weird_arguments();\n  errors += test_unsigned_short_formatting();\n  errors += test_signed_short_formatting();\n  errors += test_unsigned_int_formatting();\n  errors += test_signed_int_formatting();\n  errors += test_unsigned_long_formatting();\n  errors += test_signed_long_formatting();\n  errors += test_curl_off_t_formatting();\n  errors += test_string_formatting();\n  errors += test_float_formatting();\n  if(errors)\n    return TEST_ERR_MAJOR_BAD;\n  else\n    return 0;\n}", "target": 0}
{"code": "void wake_q_add(struct wake_q_head *head, struct task_struct *task)\n{\n\tstruct wake_q_node *node = &task->wake_q;\n\tif (cmpxchg(&node->next, NULL, WAKE_Q_TAIL))\n\t\treturn;\n\tget_task_struct(task);\n\t*head->lastp = node;\n\thead->lastp = &node->next;\n}", "target": 0}
{"code": "BIGNUM *BN_dup(const BIGNUM *a)\n{\n    BIGNUM *t;\n    if (a == NULL)\n        return NULL;\n    bn_check_top(a);\n    t = BN_get_flags(a, BN_FLG_SECURE) ? BN_secure_new() : BN_new();\n    if (t == NULL)\n        return NULL;\n    if (!BN_copy(t, a)) {\n        BN_free(t);\n        return NULL;\n    }\n    bn_check_top(t);\n    return t;\n}", "target": 0}
{"code": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n}", "target": 1}
{"code": "ECPKPARAMETERS *ec_asn1_group2pkparameters(const EC_GROUP *group,\n                                           ECPKPARAMETERS *params)\n{\n    int ok = 1, tmp;\n    ECPKPARAMETERS *ret = params;\n    if (ret == NULL) {\n        if ((ret = ECPKPARAMETERS_new()) == NULL) {\n            ECerr(EC_F_EC_ASN1_GROUP2PKPARAMETERS, ERR_R_MALLOC_FAILURE);\n            return NULL;\n        }\n    } else {\n        if (ret->type == 0 && ret->value.named_curve)\n            ASN1_OBJECT_free(ret->value.named_curve);\n        else if (ret->type == 1 && ret->value.parameters)\n            ECPARAMETERS_free(ret->value.parameters);\n    }\n    if (EC_GROUP_get_asn1_flag(group)) {\n        tmp = EC_GROUP_get_curve_name(group);\n        if (tmp) {\n            ret->type = 0;\n            if ((ret->value.named_curve = OBJ_nid2obj(tmp)) == NULL)\n                ok = 0;\n        } else\n            ok = 0;\n    } else {\n        ret->type = 1;\n        if ((ret->value.parameters =\n             ec_asn1_group2parameters(group, NULL)) == NULL)\n            ok = 0;\n    }\n    if (!ok) {\n        ECPKPARAMETERS_free(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,\n\t\t\t     struct snd_rawmidi_params * params)\n{\n\tchar *newbuf;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\tsnd_rawmidi_drain_input(substream);\n\tif (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->avail_min < 1 || params->avail_min > params->buffer_size) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->buffer_size != runtime->buffer_size) {\n\t\tnewbuf = krealloc(runtime->buffer, params->buffer_size,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\truntime->buffer = newbuf;\n\t\truntime->buffer_size = params->buffer_size;\n\t}\n\truntime->avail_min = params->avail_min;\n\treturn 0;\n}", "target": 1}
{"code": "static void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n  const char\n    *p,\n    *tags;\n  Image\n   *image;\n  register ssize_t\n    i;\n  size_t\n    count;\n  TIFFFieldInfo\n    *ignore;\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n    p=q;\n    count++;\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  if (ignore == (TIFFFieldInfo *) NULL)\n    return;\n  memset(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n    p=q;\n    i++;\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}", "target": 0}
{"code": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}", "target": 1}
{"code": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\tspin_unlock(q->lock_ptr);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "int tipc_node_get_mtu(struct net *net, u32 addr, u32 sel, bool connected)\n{\n\tstruct tipc_node *n;\n\tint bearer_id;\n\tunsigned int mtu = MAX_MSG_SIZE;\n\tn = tipc_node_find(net, addr);\n\tif (unlikely(!n))\n\t\treturn mtu;\n\tif (n->peer_net && connected) {\n\t\ttipc_node_put(n);\n\t\treturn mtu;\n\t}\n\tbearer_id = n->active_links[sel & 1];\n\tif (likely(bearer_id != INVALID_BEARER_ID))\n\t\tmtu = n->links[bearer_id].mtu;\n\ttipc_node_put(n);\n\treturn mtu;\n}", "target": 0}
{"code": "static void kvm_get_wallclock(struct timespec *now)\n{\n\tstruct pvclock_vcpu_time_info *vcpu_time;\n\tint low, high;\n\tint cpu;\n\tlow = (int)__pa_symbol(&wall_clock);\n\thigh = ((u64)__pa_symbol(&wall_clock) >> 32);\n\tnative_write_msr(msr_kvm_wall_clock, low, high);\n\tcpu = get_cpu();\n\tvcpu_time = &hv_clock[cpu].pvti;\n\tpvclock_read_wallclock(&wall_clock, vcpu_time, now);\n\tput_cpu();\n}", "target": 0}
{"code": "static void can_can_gw_rcv(struct sk_buff *skb, void *data)\n{\n\tstruct cgw_job *gwj = (struct cgw_job *)data;\n\tstruct can_frame *cf;\n\tstruct sk_buff *nskb;\n\tint modidx = 0;\n#define cgw_hops(skb) ((skb)->csum_start)\n\tBUG_ON(skb->ip_summed != CHECKSUM_UNNECESSARY);\n\tif (cgw_hops(skb) >= max_hops) {\n\t\tgwj->deleted_frames++;\n\t\treturn;\n\t}\n\tif (!(gwj->dst.dev->flags & IFF_UP)) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\tif (!(gwj->flags & CGW_FLAGS_CAN_IIF_TX_OK) &&\n\t    can_skb_prv(skb)->ifindex == gwj->dst.dev->ifindex)\n\t\treturn;\n\tif (gwj->mod.modfunc[0])\n\t\tnskb = skb_copy(skb, GFP_ATOMIC);\n\telse\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!nskb) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\tcgw_hops(nskb) = cgw_hops(skb) + 1;\n\tif (gwj->limit_hops && cgw_hops(nskb) == 1)\n\t\tcgw_hops(nskb) = max_hops - gwj->limit_hops + 1;\n\tnskb->dev = gwj->dst.dev;\n\tcf = (struct can_frame *)nskb->data;\n\twhile (modidx < MAX_MODFUNCTIONS && gwj->mod.modfunc[modidx])\n\t\t(*gwj->mod.modfunc[modidx++])(cf, &gwj->mod);\n\tif (modidx) {\n\t\tif (gwj->mod.csumfunc.crc8)\n\t\t\t(*gwj->mod.csumfunc.crc8)(cf, &gwj->mod.csum.crc8);\n\t\tif (gwj->mod.csumfunc.xor)\n\t\t\t(*gwj->mod.csumfunc.xor)(cf, &gwj->mod.csum.xor);\n\t}\n\tif (!(gwj->flags & CGW_FLAGS_CAN_SRC_TSTAMP))\n\t\tnskb->tstamp = 0;\n\tif (can_send(nskb, gwj->flags & CGW_FLAGS_CAN_ECHO))\n\t\tgwj->dropped_frames++;\n\telse\n\t\tgwj->handled_frames++;\n}", "target": 1}
{"code": "void bio_trim(struct bio *bio, int offset, int size)\n{\n\tsize <<= 9;\n\tif (offset == 0 && size == bio->bi_iter.bi_size)\n\t\treturn;\n\tbio_clear_flag(bio, BIO_SEG_VALID);\n\tbio_advance(bio, offset << 9);\n\tbio->bi_iter.bi_size = size;\n\tif (bio_integrity(bio))\n\t\tbio_integrity_trim(bio);\n}", "target": 0}
{"code": "static void ide_atapi_cmd_reply(IDEState *s, int size, int max_size)\n{\n    if (size > max_size)\n        size = max_size;\n    s->lba = -1; \n    s->packet_transfer_size = size;\n    s->io_buffer_size = size;    \n    s->elementary_transfer_size = 0;\n    s->io_buffer_index = 0;\n    if (s->atapi_dma) {\n        bdrv_acct_start(s->bs, &s->acct, size, BDRV_ACCT_READ);\n        s->status = READY_STAT | SEEK_STAT | DRQ_STAT;\n        s->bus->dma->ops->start_dma(s->bus->dma, s,\n                                   ide_atapi_cmd_read_dma_cb);\n    } else {\n        s->status = READY_STAT | SEEK_STAT;\n        ide_atapi_cmd_reply_end(s);\n    }\n}", "target": 0}
{"code": "vrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}", "target": 1}
{"code": "__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n \tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n \tload_sp0(tss, next);\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n \tsavesegment(fs, fsindex);\n \tsavesegment(gs, gsindex);\n \tload_TLS(next, cpu);\n \tarch_end_context_switch(next_p);\n \tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n \t\tloadsegment(fs, next->fsindex);\n \t\tif (fsindex)\n \t\t\tprev->fs = 0;\n \t}\n \tif (next->fs)\n \t\twrmsrl(MSR_FS_BASE, next->fs);\n \tprev->fsindex = fsindex;\n \tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n \t\tload_gs_index(next->gsindex);\n \t\tif (gsindex)\n \t\t\tprev->gs = 0;\n \t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\tswitch_fpu_finish(next_p, fpu);\n\tprev->usersp = this_cpu_read(old_rsp);\n\tthis_cpu_write(old_rsp, next->usersp);\n\tthis_cpu_write(current_task, next_p);\n\ttask_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);\n\tthis_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);\n\tthis_cpu_write(kernel_stack,\n\t\t  (unsigned long)task_stack_page(next_p) +\n\t\t  THREAD_SIZE - KERNEL_STACK_OFFSET);\n\tif (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||\n\t\t     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))\n\t\t__switch_to_xtra(prev_p, next_p, tss);\n\treturn prev_p;\n}", "target": 1}
{"code": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}", "target": 0}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "mm_append_debug(Buffer *m)\n{\n\tif (auth_debug_init && buffer_len(&auth_debug)) {\n\t\tdebug3(\"%s: Appending debug messages for child\", __func__);\n\t\tbuffer_append(m, buffer_ptr(&auth_debug),\n\t\t    buffer_len(&auth_debug));\n\t\tbuffer_clear(&auth_debug);\n\t}\n}", "target": 0}
{"code": "int ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n                               HeaderString&& value) {\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    stats_.headers_cb_no_stream_.inc();\n    return 0;\n  }\n  stream->saveHeader(std::move(name), std::move(value));\n  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {\n    stats_.header_overflow_.inc();\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  } else {\n    return 0;\n  }\n}", "target": 1}
{"code": "static int allocDynamic(dynamicPtr *dp, int initialSize, void *data)\n{\n\tif(data == NULL) {\n\t\tdp->logicalSize = 0;\n\t\tdp->dataGood = FALSE;\n\t\tdp->data = gdMalloc(initialSize);\n\t} else {\n\t\tdp->logicalSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->data = data;\n\t}\n\tif(dp->data != NULL) {\n\t\tdp->realSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->pos = 0;\n\t\treturn TRUE;\n\t} else {\n\t\tdp->realSize = 0;\n\t\treturn FALSE;\n\t}\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}", "target": 1}
{"code": "static int adpt_system_info(void __user *buffer)\n{\n\tsysInfo_S si;\n\tmemset(&si, 0, sizeof(si));\n\tsi.osType = OS_LINUX;\n\tsi.osMajorVersion = 0;\n\tsi.osMinorVersion = 0;\n\tsi.osRevision = 0;\n\tsi.busType = SI_PCI_BUS;\n\tsi.processorFamily = DPTI_sig.dsProcessorFamily;\n#if defined __i386__\n\tadpt_i386_info(&si);\n#elif defined (__ia64__)\n\tadpt_ia64_info(&si);\n#elif defined(__sparc__)\n\tadpt_sparc_info(&si);\n#elif defined (__alpha__)\n\tadpt_alpha_info(&si);\n#else\n\tsi.processorType = 0xff ;\n#endif\n\tif (copy_to_user(buffer, &si, sizeof(si))){\n\t\tprintk(KERN_WARNING\"dpti: Could not copy buffer TO user\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\tif (rt)\n\t\treturn 0;\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\t\tsk->sk_route_caps = 0;\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)\n{\n\tsg_io_hdr_t *hp = &srp->header;\n\tint err = 0, err2;\n\tint len;\n\tif (in_compat_syscall()) {\n\t\tif (count < sizeof(struct compat_sg_io_hdr)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t} else if (count < SZ_SG_IO_HDR) {\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\thp->sb_len_wr = 0;\n\tif ((hp->mx_sb_len > 0) && hp->sbp) {\n\t\tif ((CHECK_CONDITION & hp->masked_status) ||\n\t\t    (DRIVER_SENSE & hp->driver_status)) {\n\t\t\tint sb_len = SCSI_SENSE_BUFFERSIZE;\n\t\t\tsb_len = (hp->mx_sb_len > sb_len) ? sb_len : hp->mx_sb_len;\n\t\t\tlen = 8 + (int) srp->sense_b[7];\t\n\t\t\tlen = (len > sb_len) ? sb_len : len;\n\t\t\tif (copy_to_user(hp->sbp, srp->sense_b, len)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\thp->sb_len_wr = len;\n\t\t}\n\t}\n\tif (hp->masked_status || hp->host_status || hp->driver_status)\n\t\thp->info |= SG_INFO_CHECK;\n\terr = put_sg_io_hdr(hp, buf);\nerr_out:\n\terr2 = sg_finish_rem_req(srp);\n\tsg_remove_request(sfp, srp);\n\treturn err ? : err2 ? : count;\n}", "target": 0}
{"code": "int tcp_ctl(struct socket *so)\n{\n    Slirp *slirp = so->slirp;\n    struct sbuf *sb = &so->so_snd;\n    struct gfwd_list *ex_ptr;\n    DEBUG_CALL(\"tcp_ctl\");\n    DEBUG_ARG(\"so = %p\", so);\n    if (so->so_faddr.s_addr != slirp->vhost_addr.s_addr) {\n        for (ex_ptr = slirp->guestfwd_list; ex_ptr; ex_ptr = ex_ptr->ex_next) {\n            if (ex_ptr->ex_fport == so->so_fport &&\n                so->so_faddr.s_addr == ex_ptr->ex_addr.s_addr) {\n                if (ex_ptr->write_cb) {\n                    so->s = -1;\n                    so->guestfwd = ex_ptr;\n                    return 1;\n                }\n                DEBUG_MISC(\" executing %s\", ex_ptr->ex_exec);\n                if (ex_ptr->ex_unix)\n                    return open_unix(so, ex_ptr->ex_unix);\n                else\n                    return fork_exec(so, ex_ptr->ex_exec);\n            }\n        }\n    }\n    sb->sb_cc =\n        snprintf(sb->sb_wptr, sb->sb_datalen - (sb->sb_wptr - sb->sb_data),\n                 \"Error: No application configured.\\r\\n\");\n    sb->sb_wptr += sb->sb_cc;\n    return 0;\n}", "target": 0}
{"code": "FontData::FontData(ByteArray* ba) {\n  Init(ba);\n}", "target": 0}
{"code": "    setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n      san_matchers_ = san_matchers;\n      return *this;\n    }", "target": 1}
{"code": "static CURLUcode decode_host(char *hostname, char **outp)\n{\n  char *per = NULL;\n  if(hostname[0] != '[')\n    per = strchr(hostname, '%');\n  if(!per) {\n    *outp = strdup(hostname);\n    if(!*outp)\n      return CURLUE_OUT_OF_MEMORY;\n  }\n  else {\n    size_t dlen;\n    CURLcode result = Curl_urldecode(hostname, 0, outp, &dlen, REJECT_CTRL);\n    if(result)\n      return CURLUE_BAD_HOSTNAME;\n  }\n  return CURLUE_OK;\n}", "target": 0}
{"code": "static inline unsigned long intel_iommu_get_pts(struct device *dev)\n{\n\tint pts, max_pasid;\n\tmax_pasid = intel_pasid_get_dev_max_id(dev);\n\tpts = find_first_bit((unsigned long *)&max_pasid, MAX_NR_PASID_BITS);\n\tif (pts < 5)\n\t\treturn 0;\n\treturn pts - 5;\n}", "target": 0}
{"code": "void __netdev_watchdog_up(struct net_device *dev)\n{\n\tif (dev->tx_timeout) {\n\t\tif (dev->watchdog_timeo <= 0)\n\t\t\tdev->watchdog_timeo = 5*HZ;\n\t\tif (!mod_timer(&dev->watchdog_timer,\n\t\t\t       round_jiffies(jiffies + dev->watchdog_timeo)))\n\t\t\tdev_hold(dev);\n\t}\n}", "target": 0}
{"code": "static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n{\n  register int ch;\n  register unsigned int val;\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n  return val;\n}", "target": 1}
{"code": "int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tprintf(\"error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}", "target": 1}
{"code": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}", "target": 1}
{"code": "png_crc_error(png_structp png_ptr)\n{\n   png_byte crc_bytes[4];\n   png_uint_32 crc;\n   int need_crc = 1;\n   if (png_ptr->chunk_name[0] & 0x20)                     \n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n         need_crc = 0;\n   }\n   else                                                    \n   {\n      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)\n         need_crc = 0;\n   }\n   png_read_data(png_ptr, crc_bytes, 4);\n   if (need_crc)\n   {\n      crc = png_get_uint_32(crc_bytes);\n      return ((int)(crc != png_ptr->crc));\n   }\n   else\n      return (0);\n}", "target": 0}
{"code": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}", "target": 1}
{"code": "int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,\n\t\t\t   sector_t block)\n{\n\tstruct mb2_cache_entry *entry, *dup;\n\tstruct hlist_bl_node *dup_node;\n\tstruct hlist_bl_head *head;\n\tentry = kmem_cache_alloc(mb2_entry_cache, mask);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&entry->e_lru_list);\n\tatomic_set(&entry->e_refcnt, 1);\n\tentry->e_key = key;\n\tentry->e_block = block;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\tentry->e_hash_list_head = head;\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {\n\t\tif (dup->e_key == key && dup->e_block == block) {\n\t\t\thlist_bl_unlock(head);\n\t\t\tkmem_cache_free(mb2_entry_cache, entry);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\thlist_bl_add_head(&entry->e_hash_list, head);\n\thlist_bl_unlock(head);\n\tspin_lock(&cache->c_lru_list_lock);\n\tlist_add_tail(&entry->e_lru_list, &cache->c_lru_list);\n\tatomic_inc(&entry->e_refcnt);\n\tcache->c_entry_count++;\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn 0;\n}", "target": 0}
{"code": "storageConnectStoragePoolEventDeregisterAny(virConnectPtr conn,\n                                            int callbackID)\n{\n    if (virConnectStoragePoolEventDeregisterAnyEnsureACL(conn) < 0)\n        return -1;\n    if (virObjectEventStateDeregisterID(conn,\n                                        driver->storageEventState,\n                                        callbackID, true) < 0)\n        return -1;\n    return 0;\n}", "target": 0}
{"code": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n    length = strlen (filename);\n    if (length > 0)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}", "target": 1}
{"code": "process_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int nentries = 0;\n\tdebug2_f(\"entering\");\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}", "target": 1}
{"code": "static void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\tvmx->nested.vmxon = false;\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tnested_free_all_saved_vmcss(vmx);\n}", "target": 0}
{"code": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\tif (!sel)\n\t\treturn 0;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\treturn limit;\n}", "target": 1}
{"code": "static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)\n{\n    node->isVisited = false;\n    node->childIndex = 0;\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n        tr_variantInitDict(&node->sorted, n);\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted.val.l.vals[i] = *tmp[i].val;\n        }\n        node->sorted.val.l.count = n;\n        tr_free(tmp);\n        node->v = &node->sorted;\n    }\n    else\n    {\n        node->v = v;\n    }\n}", "target": 1}
{"code": "static int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\treturn -1;\n\t    } else {\n\t\treturn 0;\n\t    }\n\t}\n\ts = p + strspn(p, \" \\n\\t\");\n\tif (*s && (*s != '#')) {\n\t    os = s;\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                \n\t    }\n\t    s = os;\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              \n\t\tused += strlen(os);\n\t\tp = s;                  \n\t    } else {\n\t\tused += strlen(os);\n\t\tbreak;                  \n\t    }\n\t} else {\n\t}\n    }\n    return used;\n}", "target": 0}
{"code": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\treturn do_send_specific(tgid, pid, sig, &info);\n}", "target": 1}
{"code": "read_channel_data (PSDchannel     *channel,\n                   const guint16   bps,\n                   const guint16   compression,\n                   const guint16  *rle_pack_len,\n                   FILE           *f,\n                   GError        **error)\n{\n  gchar    *raw_data;\n  gchar    *src;\n  gchar    *dst;\n  guint32   readline_len;\n  gint      i;\n  if (bps == 1)\n    readline_len = ((channel->columns + 7) >> 3);\n  else\n    readline_len = (channel->columns * bps >> 3);\n  IFDBG(3) g_debug (\"raw data size %d x %d = %d\", readline_len,\n                    channel->rows, readline_len * channel->rows);\n  raw_data = g_malloc (readline_len * channel->rows);\n  switch (compression)\n    {\n      case PSD_COMP_RAW:\n        if (fread (raw_data, readline_len, channel->rows, f) < 1)\n          {\n            psd_set_error (feof (f), errno, error);\n            return -1;\n          }\n        break;\n      case PSD_COMP_RLE:\n        for (i = 0; i < channel->rows; ++i)\n          {\n            src = g_malloc (rle_pack_len[i]);\n            dst = g_malloc (readline_len);\n            if (fread (src, rle_pack_len[i], 1, f) < 1)\n              {\n                psd_set_error (feof (f), errno, error);\n                return -1;\n              }\n            decode_packbits (src, dst, rle_pack_len[i], readline_len);\n            g_free (src);\n            memcpy (raw_data + i * readline_len, dst, readline_len);\n            g_free (dst);\n          }\n        break;\n    }\n  switch (bps)\n    {\n      case 16:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_16_bit (raw_data, channel->data, (channel->rows * channel->columns) << 1);\n        break;\n      case 8:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        memcpy (channel->data, raw_data, (channel->rows * channel->columns));\n        break;\n      case 1:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_1_bit (raw_data, channel->data, channel->rows, channel->columns);\n        break;\n    }\n  g_free (raw_data);\n  return 1;\n}", "target": 1}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}", "target": 1}
{"code": "resolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n        if (!list->child) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if (check_key(list, i, keys_str, len)) {\n            return -1;\n        }\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n        if (list->keys[i]->dflt) {\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n    return EXIT_SUCCESS;\n}", "target": 1}
{"code": "spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 0}
{"code": "    bool empty() const { return result_.empty(); }", "target": 0}
{"code": "MagickExport MagickBooleanType DrawClipPath(Image *image,\n  const DrawInfo *draw_info,const char *name,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n  Image\n    *clip_mask;\n  const char\n    *value;\n  DrawInfo\n    *clone_info;\n  MagickStatusType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s\",name);\n  value=GetImageArtifact(image,filename);\n  if (value == (const char *) NULL)\n    return(MagickFalse);\n  clip_mask=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  (void) QueryColorCompliance(\"#0000\",AllCompliance,\n    &clip_mask->background_color,exception);\n  clip_mask->background_color.alpha=(Quantum) TransparentAlpha;\n  (void) SetImageBackgroundColor(clip_mask,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin clip-path %s\",\n      draw_info->clip_mask);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,value);\n  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  clone_info->clip_mask=(char *) NULL;\n  status=NegateImage(clip_mask,MagickFalse,exception);\n  (void) SetImageMask(image,ReadPixelMask,clip_mask,exception);\n  clip_mask=DestroyImage(clip_mask);\n  status&=DrawImage(image,clone_info,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end clip-path\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 1}
{"code": "static void kvm_io_bus_destroy(struct kvm_io_bus *bus)\n{\n\tint i;\n\tfor (i = 0; i < bus->dev_count; i++) {\n\t\tstruct kvm_io_device *pos = bus->devs[i];\n\t\tkvm_iodevice_destructor(pos);\n\t}\n\tkfree(bus);\n}", "target": 0}
{"code": "xmlValidateNmtokensValue(const xmlChar *value) {\n    return(xmlValidateNmtokensValueInternal(NULL, value));\n}", "target": 0}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **conffile, const char **envfile, int *readenv,\n\t    const char **user_envfile, int *user_readenv)\n{\n    int ctrl=0;\n    *user_envfile = DEFAULT_USER_ENVFILE;\n    *envfile = DEFAULT_ETC_ENVFILE;\n    *readenv = DEFAULT_READ_ENVFILE;\n    *user_readenv = DEFAULT_USER_READ_ENVFILE;\n    *conffile = DEFAULT_CONF_FILE;\n    for (; argc-- > 0; ++argv) {\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strncmp(*argv,\"conffile=\",9)) {\n\t  if ((*argv)[9] == '\\0') {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"conffile= specification missing argument - ignored\");\n\t  } else {\n\t    *conffile = 9+*argv;\n\t    D((\"new Configuration File: %s\", *conffile));\n\t  }\n\t} else if (!strncmp(*argv,\"envfile=\",8)) {\n\t  if ((*argv)[8] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *envfile = 8+*argv;\n\t    D((\"new Env File: %s\", *envfile));\n\t  }\n\t} else if (!strncmp(*argv,\"user_envfile=\",13)) {\n\t  if ((*argv)[13] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"user_envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *user_envfile = 13+*argv;\n\t    D((\"new User Env File: %s\", *user_envfile));\n\t  }\n\t} else if (!strncmp(*argv,\"readenv=\",8))\n\t  *readenv = atoi(8+*argv);\n\telse if (!strncmp(*argv,\"user_readenv=\",13))\n\t  *user_readenv = atoi(13+*argv);\n\telse\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n    return ctrl;\n}", "target": 0}
{"code": "std::string CanonicalizeHost(const std::wstring& host,\n                             url_canon::CanonHostInfo* host_info) {\n  std::string converted_host;\n  WideToUTF8(host.c_str(), host.length(), &converted_host);\n  return CanonicalizeHost(converted_host, host_info);\n}", "target": 0}
{"code": "ahcp_time_print(netdissect_options *ndo,\n                const u_char *cp, uint8_t len)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tif (len != 4)\n\t\tgoto invalid;\n\tt = GET_BE_U_4(cp);\n\tif (NULL == (tm = gmtime(&t)))\n\t\tND_PRINT(\": gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\": strftime() error\");\n\telse\n\t\tND_PRINT(\": %s UTC\", buf);\n\treturn;\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}", "target": 1}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 19;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }", "target": 1}
{"code": "calculateNumTiles (int *numTiles,\n\t\t   int numLevels,\n\t\t   int min, int max,\n\t\t   int size,\n\t\t   LevelRoundingMode rmode)\n{\n    for (int i = 0; i < numLevels; i++)\n    {\n        int l = levelSize (min, max, i, rmode);\n        if (l > std::numeric_limits<int>::max() - size + 1)\n            throw IEX_NAMESPACE::ArgExc (\"Invalid size.\");\n        numTiles[i] = (l + size - 1) / size;\n    }\n}", "target": 1}
{"code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n\telse\n\t\tci->hcd = hcd;\n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\treturn ret;\n}", "target": 0}
{"code": "ZEND_API zend_extension *zend_get_extension(const char *extension_name)\n{\n\tzend_llist_element *element;\n\tfor (element = zend_extensions.head; element; element = element->next) {\n\t\tzend_extension *extension = (zend_extension *) element->data;\n\t\tif (!strcmp(extension->name, extension_name)) {\n\t\t\treturn extension;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)\n{\n\tunsigned char *tmp = skb_tail_pointer(skb);\n\tSKB_LINEAR_ASSERT(skb);\n\tskb->tail += len;\n\tskb->len  += len;\n\treturn tmp;\n}", "target": 0}
{"code": "icc_conv_color(fz_context *ctx, fz_color_converter *cc, float *dstv, const float *srcv)\n{\n\tconst fz_colorspace *dsts = cc->ds;\n\tint src_n = cc->n;\n\tint dst_n = dsts->n;\n\tfz_icclink *link = (fz_icclink *)cc->link;\n\tint i;\n\tunsigned short dstv_s[FZ_MAX_COLORS];\n\tunsigned short srcv_s[FZ_MAX_COLORS];\n\tif (link == NULL)\n\t{\n\t\tdstv[0] = 0;\n\t\tdstv[1] = 0;\n\t\tdstv[2] = 0;\n\t\tdstv[3] = 1 - srcv[0];\n\t}\n\telse if (link->is_identity)\n\t{\n\t\tfor (i = 0; i < src_n; i++)\n\t\t\tdstv[i] = srcv[i];\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < src_n; i++)\n\t\t\tsrcv_s[i] = srcv[i] * 65535;\n\t\tfz_cmm_transform_color(ctx, link, dstv_s, srcv_s);\n\t\tfor (i = 0; i < dst_n; i++)\n\t\t\tdstv[i] = fz_clamp((float) dstv_s[i] / 65535.0f, 0, 1);\n\t}\n}", "target": 0}
{"code": "gdk_pixbuf__tiff_image_load (FILE *f, GError **error)\n{\n        TIFF *tiff;\n        int fd;\n        GdkPixbuf *pixbuf;\n        g_return_val_if_fail (f != NULL, NULL);\n        tiff_set_handlers ();\n        fd = fileno (f);\n        lseek (fd, 0, SEEK_SET);\n        tiff = TIFFFdOpen (fd, \"libpixbuf-tiff\", \"r\");\n        if (!tiff) {\n                g_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"Failed to open TIFF image\"));\n                return NULL;\n        }\n        pixbuf = tiff_image_parse (tiff, NULL, error);\n        TIFFClose (tiff);\n        return pixbuf;\n}", "target": 0}
{"code": "int sock_present2network(const char *address, struct sockaddr_storage *sockaddr, int addr_family, char *errbuf, int errbuflen)\n{\n\tstruct addrinfo *addrinfo;\n\tstruct addrinfo hints;\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = addr_family;\n\tif (sock_initaddress(address, \"22222\" , &hints, &addrinfo, errbuf, errbuflen) == -1)\n\t\treturn 0;\n\tif (addrinfo->ai_family == PF_INET)\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in));\n\telse\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in6));\n\tif (addrinfo->ai_next != NULL)\n\t{\n\t\tfreeaddrinfo(addrinfo);\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"More than one socket requested; using the first one returned\");\n\t\treturn -2;\n\t}\n\tfreeaddrinfo(addrinfo);\n\treturn -1;\n}", "target": 1}
{"code": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int x509_get_basic_constraints( unsigned char **p,\n                                       const unsigned char *end,\n                                       int *ca_istrue,\n                                       int *max_pathlen )\n{\n    int ret;\n    size_t len;\n    *ca_istrue = 0; \n    *max_pathlen = 0; \n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n    if( *p == end )\n        return( 0 );\n    if( ( ret = mbedtls_asn1_get_bool( p, end, ca_istrue ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            ret = mbedtls_asn1_get_int( p, end, ca_istrue );\n        if( ret != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n        if( *ca_istrue != 0 )\n            *ca_istrue = 1;\n    }\n    if( *p == end )\n        return( 0 );\n    if( ( ret = mbedtls_asn1_get_int( p, end, max_pathlen ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    (*max_pathlen)++;\n    return( 0 );\n}", "target": 0}
{"code": "grub_username_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  grub_printf (\"\\b\");\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\t{\n\t  buf[cur_len++] = key;\n\t  grub_printf (\"%c\", key);\n\t}\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "static inline uint8_t ok_read_uint8(ok_jpg_decoder *decoder) {\n    if (decoder->input_buffer_start == decoder->input_buffer_end) {\n        size_t len = decoder->input.read(decoder->input_user_data, decoder->input_buffer,\n                                         sizeof(decoder->input_buffer));\n        decoder->input_buffer_start = decoder->input_buffer;\n        decoder->input_buffer_end = decoder->input_buffer + len;\n        if (len == 0) {\n            return 0;\n        }\n    }\n    return *decoder->input_buffer_start++;\n}", "target": 0}
{"code": "static void rekey_seq_generator(struct work_struct *work)\n{\n\tstruct keydata *keyptr = &ip_keydata[1 ^ (ip_cnt & 1)];\n\tget_random_bytes(keyptr->secret, sizeof(keyptr->secret));\n\tkeyptr->count = (ip_cnt & COUNT_MASK) << HASH_BITS;\n\tsmp_wmb();\n\tip_cnt++;\n\tschedule_delayed_work(&rekey_work,\n\t\t\t      round_jiffies_relative(REKEY_INTERVAL));\n}", "target": 1}
{"code": "    TimeValue* TimeValue::clone_() const\n    {\n        return new TimeValue(*this);\n    }", "target": 0}
{"code": "int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tstruct sk_buff *skb;\n\tunsigned long time_left;\n\tint ret = 0;\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, headroom);\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\tmutex_lock(&wmi->op_mutex);\n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\n\tif (ret)\n\t\tgoto out;\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\treturn -ETIMEDOUT;\n\t}\n\tmutex_unlock(&wmi->op_mutex);\n\treturn 0;\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 1}
{"code": "nf_tables_delrule_deactivate(struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\tif (nft_rule_is_active_next(ctx->net, rule)) {\n\t\tnft_rule_deactivate_next(ctx->net, rule);\n\t\tctx->chain->use--;\n\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}", "target": 0}
{"code": "scrollback_get_filename (session *sess)\n{\n\tchar *net, *chan, *buf, *ret = NULL;\n\tnet = server_get_network (sess->server, FALSE);\n\tif (!net)\n\t\treturn NULL;\n\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, \"\");\n\tmkdir_p (buf);\n\tg_free (buf);\n\tchan = log_create_filename (sess->channel);\n\tif (chan[0])\n\t\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, chan);\n\telse\n\t\tbuf = NULL;\n\tg_free (chan);\n\tif (buf)\n\t{\n\t\tret = g_filename_from_utf8 (buf, -1, NULL, NULL, NULL);\n\t\tg_free (buf);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static inline void DetectRunPrefilterPkt(\n    ThreadVars *tv,\n    DetectEngineCtx *de_ctx,\n    DetectEngineThreadCtx *det_ctx,\n    Packet *p,\n    DetectRunScratchpad *scratch\n)\n{\n    DetectPrefilterSetNonPrefilterList(p, det_ctx, scratch);\n    PacketCreateMask(p, &scratch->pkt_mask, scratch->alproto, scratch->app_decoder_events);\n    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_NONMPMLIST);\n    det_ctx->non_pf_id_cnt = 0;\n    if (likely(det_ctx->non_pf_store_cnt > 0)) {\n        DetectPrefilterBuildNonPrefilterList(det_ctx, scratch->pkt_mask, scratch->alproto);\n    }\n    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_NONMPMLIST);\n    Prefilter(det_ctx, scratch->sgh, p, scratch->flow_flags);\n    if (det_ctx->non_pf_store_cnt || det_ctx->pmq.rule_id_array_cnt) {\n        PACKET_PROFILING_DETECT_START(p, PROF_DETECT_PF_SORT2);\n        DetectPrefilterMergeSort(de_ctx, det_ctx);\n        PACKET_PROFILING_DETECT_END(p, PROF_DETECT_PF_SORT2);\n    }\n#ifdef PROFILING\n    if (tv) {\n        StatsAddUI64(tv, det_ctx->counter_mpm_list,\n                             (uint64_t)det_ctx->pmq.rule_id_array_cnt);\n        StatsAddUI64(tv, det_ctx->counter_nonmpm_list,\n                             (uint64_t)det_ctx->non_pf_store_cnt);\n        StatsAddUI64(tv, det_ctx->counter_fnonmpm_list,\n                             (uint64_t)det_ctx->non_pf_id_cnt);\n    }\n#endif\n}", "target": 0}
{"code": "void TightDecoder::FilterGradient(const rdr::U8* inbuf,\n                                  const PixelFormat& pf, PIXEL_T* outbuf,\n                                  int stride, const Rect& r)\n{\n  int x, y, c;\n  static rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  static rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);\n    for (c = 0; c < 3; c++)\n      pix[c] += prevRow[c];\n    memcpy(thisRow, pix, sizeof(pix));\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 255) {\n          est[c] = 255;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n      }\n      pf.rgbFromBuffer(pix, &inbuf[y*rectWidth+x], 1);\n      for (c = 0; c < 3; c++)\n        pix[c] += est[c];\n      memcpy(&thisRow[x*3], pix, sizeof(pix));\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 0}
{"code": "int gnutls_x509_ext_export_subject_key_id(const gnutls_datum_t * id,\n\t\t\t\t       gnutls_datum_t * ext)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint ret, result;\n\tresult =\n\t    asn1_create_element(_gnutls_get_pkix(),\n\t\t\t\t\"PKIX1.SubjectKeyIdentifier\", &c2);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_write_value(c2, \"\", id->data, id->size);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tret = _gnutls_x509_der_encode(c2, \"\", ext, 0);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tret = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\tref->ref++;\n}", "target": 1}
{"code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n        methnum = ap_method_number_of(method);\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n             methnum = ap_method_register(cmd->pool,\n                                          apr_pstrdup(cmd->pool, method));\n         }\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n    limited = tog ? ~limited : limited;\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n    cmd->limited &= limited;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n    cmd->limited = old_limited;\n    return errmsg;\n}", "target": 1}
{"code": "static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\tif (edit && !edit->dead_leaf) {\n\t\tkey_payload_reserve(keyring,\n\t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}", "target": 1}
{"code": "static void record_init(node_t * n)\n{\n    field_t *info;\n    pointf ul, sz;\n    int flip, len;\n    char *textbuf;\t\t\n    int sides = BOTTOM | RIGHT | TOP | LEFT;\n    flip = NOT(GD_realflip(agraphof(n)));\n    reclblp = ND_label(n)->text;\n    len = strlen(reclblp);\n    len = MAX(len, 1);\n    textbuf = N_NEW(len + 1, char);\n    if (!(info = parse_reclbl(n, flip, TRUE, textbuf))) {\n\tagerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\n\treclblp = \"\\\\N\";\n\tinfo = parse_reclbl(n, flip, TRUE, textbuf);\n    }\n    free(textbuf);\n    size_reclbl(n, info);\n    sz.x = POINTS(ND_width(n));\n    sz.y = POINTS(ND_height(n));\n    if (mapbool(late_string(n, N_fixed, \"false\"))) {\n\tif ((sz.x < info->size.x) || (sz.y < info->size.y)) {\n\t}\n    } else {\n\tsz.x = MAX(info->size.x, sz.x);\n\tsz.y = MAX(info->size.y, sz.y);\n    }\n    resize_reclbl(info, sz, mapbool(late_string(n, N_nojustify, \"false\")));\n    ul = pointfof(-sz.x / 2., sz.y / 2.);\t\n    pos_reclbl(info, ul, sides);\n    ND_width(n) = PS2INCH(info->size.x);\n    ND_height(n) = PS2INCH(info->size.y + 1);\t\n    ND_shape_info(n) = (void *) info;\n}", "target": 1}
{"code": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}", "target": 1}
{"code": "bool extract_sockaddr(struct pool *pool, char *url)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\turl_begin = strstr(url, \"\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\tif (url_len < 1)\n\t\treturn false;\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\tif (port_len)\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\telse\n\t\tstrcpy(port, \"80\");\n\tfree(pool->stratum_port);\n\tpool->stratum_port = strdup(port);\n\tfree(pool->sockaddr_url);\n\tpool->sockaddr_url = strdup(url_address);\n\treturn true;\n}", "target": 1}
{"code": "snmp_mib_find_next(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, oid) > 0) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "option_handler (assuan_context_t ctx, const char *key, const char *value)\n{\n  ctrl_t ctrl = assuan_get_pointer (ctx);\n  if (!strcmp (key, \"event-signal\"))\n    {\n#ifdef HAVE_W32_SYSTEM\n      if (!*value)\n        return gpg_error (GPG_ERR_ASS_PARAMETER);\n      ctrl->server_local->event_signal = strtoul (value, NULL, 16);\n#else\n      int i = *value? atoi (value) : -1;\n      if (i < 0)\n        return gpg_error (GPG_ERR_ASS_PARAMETER);\n      ctrl->server_local->event_signal = i;\n#endif\n    }\n return 0;\n}", "target": 0}
{"code": "SPL_API int spl_hash_verify_pos(spl_array_object * intern TSRMLS_DC) \n{\n\tHashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\treturn spl_hash_verify_pos_ex(intern, ht TSRMLS_CC);\n}", "target": 0}
{"code": "new_httpd(isc_httpdmgr_t *httpdmgr, isc_nmhandle_t *handle) {\n\tisc_httpd_t *httpd = NULL;\n\tchar *headerdata = NULL;\n\tREQUIRE(VALID_HTTPDMGR(httpdmgr));\n\thttpd = isc_nmhandle_getdata(handle);\n\tif (httpd == NULL) {\n\t\thttpd = isc_nmhandle_getextra(handle);\n\t\t*httpd = (isc_httpd_t){ .handle = NULL };\n\t\thttpdmgr_attach(httpdmgr, &httpd->mgr);\n\t}\n\tif (httpd->handle == NULL) {\n\t\tisc_nmhandle_setdata(handle, httpd, httpd_reset, httpd_put);\n\t\thttpd->handle = handle;\n\t} else {\n\t\tINSIST(httpd->handle == handle);\n\t}\n\theaderdata = isc_mem_get(httpdmgr->mctx, HTTP_SENDGROW);\n\tisc_buffer_init(&httpd->headerbuffer, headerdata, HTTP_SENDGROW);\n\tisc_buffer_clear(&httpd->headerbuffer);\n\tisc_buffer_initnull(&httpd->compbuffer);\n\tisc_buffer_clear(&httpd->compbuffer);\n\tisc_buffer_initnull(&httpd->bodybuffer);\n\tISC_LINK_INIT(httpd, link);\n\thttpd->magic = HTTPD_MAGIC;\n\thttpd->state = RECV;\n\tLOCK(&httpdmgr->lock);\n\tISC_LIST_APPEND(httpdmgr->running, httpd, link);\n\tUNLOCK(&httpdmgr->lock);\n\tisc_nmhandle_attach(httpd->handle, &httpd->readhandle);\n\tisc_nm_read(handle, httpd_request, httpdmgr);\n}", "target": 0}
{"code": "static size_t\nphp_mysqlnd_change_auth_response_write(MYSQLND_CONN_DATA * conn, void * _packet)\n{\n\tMYSQLND_PACKET_CHANGE_AUTH_RESPONSE *packet= (MYSQLND_PACKET_CHANGE_AUTH_RESPONSE *) _packet;\n\tMYSQLND_ERROR_INFO * error_info = conn->error_info;\n\tMYSQLND_PFC * pfc = conn->protocol_frame_codec;\n\tMYSQLND_VIO * vio = conn->vio;\n\tMYSQLND_STATS * stats = conn->stats;\n\tMYSQLND_CONNECTION_STATE * connection_state = &conn->state;\n\tzend_uchar * const buffer = pfc->cmd_buffer.length >= packet->auth_data_len? pfc->cmd_buffer.buffer : mnd_emalloc(packet->auth_data_len);\n\tzend_uchar * p = buffer + MYSQLND_HEADER_SIZE; \n\tDBG_ENTER(\"php_mysqlnd_change_auth_response_write\");\n\tif (packet->auth_data_len) {\n\t\tmemcpy(p, packet->auth_data, packet->auth_data_len);\n\t\tp+= packet->auth_data_len;\n\t}\n\t{\n\t\tconst size_t sent = pfc->data->m.send(pfc, vio, buffer, p - buffer - MYSQLND_HEADER_SIZE, stats, error_info);\n\t\tif (buffer != pfc->cmd_buffer.buffer) {\n\t\t\tmnd_efree(buffer);\n\t\t}\n\t\tif (!sent) {\n\t\t\tSET_CONNECTION_STATE(connection_state, CONN_QUIT_SENT);\n\t\t}\n\t\tDBG_RETURN(sent);\n\t}", "target": 1}
{"code": "static void unmask_payload(handler_ctx *hctx) {\n    buffer * const b = hctx->frame.payload;\n    for (size_t i = 0, used = buffer_clen(b); i < used; ++i) {\n        b->ptr[i] ^= hctx->frame.ctl.mask[hctx->frame.ctl.mask_cnt];\n        hctx->frame.ctl.mask_cnt = (hctx->frame.ctl.mask_cnt + 1) % 4;\n    }\n}", "target": 0}
{"code": "void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\ttcp_set_state(sk, TCP_ESTABLISHED);\n\tif (skb) {\n\t\ticsk->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\t\tsecurity_inet_conn_established(sk, skb);\n\t}\n\ticsk->icsk_af_ops->rebuild_header(sk);\n\ttcp_init_metrics(sk);\n\ttcp_init_congestion_control(sk);\n\ttp->lsndtime = tcp_time_stamp;\n\ttcp_init_buffer_space(sk);\n\tif (sock_flag(sk, SOCK_KEEPOPEN))\n\t\tinet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));\n\tif (!tp->rx_opt.snd_wscale)\n\t\t__tcp_fast_path_on(tp, tp->snd_wnd);\n\telse\n\t\ttp->pred_flags = 0;\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t}\n}", "target": 0}
{"code": "void PDPServer::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "vhost_user_set_vring_kick(struct virtio_net **pdev, struct VhostUserMsg *pmsg)\n{\n\tstruct vhost_vring_file file;\n\tstruct vhost_virtqueue *vq;\n\tstruct virtio_net *dev = *pdev;\n\tfile.index = pmsg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\tif (pmsg->payload.u64 & VHOST_USER_VRING_NOFD_MASK)\n\t\tfile.fd = VIRTIO_INVALID_EVENTFD;\n\telse\n\t\tfile.fd = pmsg->fds[0];\n\tRTE_LOG(INFO, VHOST_CONFIG,\n\t\t\"vring kick idx:%d file:%d\\n\", file.index, file.fd);\n\tdev = translate_ring_addresses(dev, file.index);\n\tif (!dev)\n\t\treturn;\n\t*pdev = dev;\n\tvq = dev->virtqueue[file.index];\n\tif (!(dev->features & (1ULL << VHOST_USER_F_PROTOCOL_FEATURES)))\n\t\tvq->enabled = 1;\n\tif (vq->kickfd >= 0)\n\t\tclose(vq->kickfd);\n\tvq->kickfd = file.fd;\n}", "target": 0}
{"code": "void ssl_set_client_disabled(SSL *s)\n\t{\n\tCERT *c = s->cert;\n\tconst unsigned char *sigalgs;\n\tsize_t i, sigalgslen;\n\tint have_rsa = 0, have_dsa = 0, have_ecdsa = 0;\n\tc->mask_a = 0;\n\tc->mask_k = 0;\n\tif (!SSL_CLIENT_USE_TLS1_2_CIPHERS(s))\n\t\tc->mask_ssl = SSL_TLSV1_2;\n\telse\n\t\tc->mask_ssl = 0;\n\tsigalgslen = tls12_get_psigalgs(s, &sigalgs);\n\tfor (i = 0; i < sigalgslen; i += 2, sigalgs += 2)\n\t\t{\n\t\tswitch(sigalgs[1])\n\t\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tcase TLSEXT_signature_rsa:\n\t\t\thave_rsa = 1;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tcase TLSEXT_signature_dsa:\n\t\t\thave_dsa = 1;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tcase TLSEXT_signature_ecdsa:\n\t\t\thave_ecdsa = 1;\n\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t}\n\tif (!have_rsa)\n\t\t{\n\t\tc->mask_a |= SSL_aRSA;\n\t\tc->mask_k |= SSL_kDHr|SSL_kECDHr;\n\t\t}\n\tif (!have_dsa)\n\t\t{\n\t\tc->mask_a |= SSL_aDSS;\n\t\tc->mask_k |= SSL_kDHd;\n\t\t}\n\tif (!have_ecdsa)\n\t\t{\n\t\tc->mask_a |= SSL_aECDSA;\n\t\tc->mask_k |= SSL_kECDHe;\n\t\t}\n#ifndef OPENSSL_NO_KRB5\n\tif (!kssl_tgt_is_available(s->kssl_ctx))\n\t\t{\n\t\tc->mask_a |= SSL_aKRB5;\n\t\tc->mask_k |= SSL_kKRB5;\n\t\t}\n#endif\n#ifndef OPENSSL_NO_PSK\n\tif (!s->psk_client_callback)\n\t\t{\n\t\tc->mask_a |= SSL_aPSK;\n\t\tc->mask_k |= SSL_kPSK;\n\t\t}\n#endif \n\tc->valid = 1;\n\t}", "target": 0}
{"code": "daemon_linux_lvm2_lv_remove (Daemon *daemon,\n                             const gchar *group_uuid,\n                             const gchar *uuid,\n                             gchar **options,\n                             DBusGMethodInvocation *context)\n{\n  daemon_local_check_auth (daemon,\n                           NULL,\n                           \"org.freedesktop.udisks.linux-lvm2\",\n                           \"LinuxLvm2LVRemove\",\n                           TRUE,\n                           daemon_linux_lvm2_lv_remove_authorized_cb,\n                           context,\n                           3,\n                           g_strdup (group_uuid),\n                           g_free,\n                           g_strdup (uuid),\n                           g_free,\n                           g_strdupv (options),\n                           g_strfreev);\n  return TRUE;\n}", "target": 0}
{"code": "match_named_captures_iter(const OnigUChar *name, const OnigUChar *name_end,\n\tint back_num, int *back_refs, OnigRegex regex, void *arg) {\n    struct MEMO *memo = MEMO_CAST(arg);\n    VALUE hash = memo->v1;\n    VALUE match = memo->v2;\n    VALUE key = rb_enc_str_new((const char *)name, name_end-name, regex->enc);\n    VALUE value;\n    int i;\n    int found = 0;\n    for (i = 0; i < back_num; i++) {\n\tvalue = rb_reg_nth_match(back_refs[i], match);\n\tif (RTEST(value)) {\n\t    rb_hash_aset(hash, key, value);\n\t    found = 1;\n\t}\n    }\n    if (found == 0) {\n\trb_hash_aset(hash, key, Qnil);\n    }\n    return 0;\n}", "target": 0}
{"code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}", "target": 1}
{"code": "bool timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tstruct rb_node **p = &head->head.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct timerqueue_node  *ptr;\n\tWARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));\n\twhile (*p) {\n\t\tparent = *p;\n\t\tptr = rb_entry(parent, struct timerqueue_node, node);\n\t\tif (node->expires < ptr->expires)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\trb_link_node(&node->node, parent, p);\n\trb_insert_color(&node->node, &head->head);\n\tif (!head->next || node->expires < head->next->expires) {\n\t\thead->next = node;\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static NTSTATUS ldapsrv_DelRequest(struct ldapsrv_call *call)\n{\n\tstruct ldap_DelRequest *req = &call->request->r.DelRequest;\n\tstruct ldap_Result *del_result;\n\tstruct ldapsrv_reply *del_reply;\n\tTALLOC_CTX *local_ctx;\n\tstruct ldb_context *samdb = call->conn->ldb;\n\tstruct ldb_dn *dn;\n\tconst char *errstr = NULL;\n\tint result = LDAP_SUCCESS;\n\tint ldb_ret;\n\tstruct ldb_result *res = NULL;\n\tDEBUG(10, (\"DelRequest\"));\n\tDEBUGADD(10, (\" dn: %s\\n\", req->dn));\n\tlocal_ctx = talloc_named(call, 0, \"DelRequest local memory context\");\n\tNT_STATUS_HAVE_NO_MEMORY(local_ctx);\n\tdn = ldb_dn_new(local_ctx, samdb, req->dn);\n\tNT_STATUS_HAVE_NO_MEMORY(dn);\n\tDEBUG(10, (\"DelRequest: dn: [%s]\\n\", req->dn));\n\tdel_reply = ldapsrv_init_reply(call, LDAP_TAG_DelResponse);\n\tNT_STATUS_HAVE_NO_MEMORY(del_reply);\n\tif (result == LDAP_SUCCESS) {\n\t\tres = talloc_zero(local_ctx, struct ldb_result);\n\t\tNT_STATUS_HAVE_NO_MEMORY(res);\n\t\tldb_ret = ldapsrv_del_with_controls(call, dn, call->request->controls, res);\n\t\tresult = map_ldb_error(local_ctx, ldb_ret, ldb_errstring(samdb),\n\t\t\t\t       &errstr);\n\t}\n\tdel_result = &del_reply->msg->r.DelResponse;\n\tdel_result->dn = NULL;\n\tif ((res != NULL) && (res->refs != NULL)) {\n\t\tdel_result->resultcode = map_ldb_error(local_ctx,\n\t\t\t\t\t\t       LDB_ERR_REFERRAL, NULL,\n\t\t\t\t\t\t       &errstr);\n\t\tdel_result->errormessage = (errstr?talloc_strdup(del_reply,errstr):NULL);\n\t\tdel_result->referral = talloc_strdup(call, *res->refs);\n\t} else {\n\t\tdel_result->resultcode = result;\n\t\tdel_result->errormessage = (errstr?talloc_strdup(del_reply,errstr):NULL);\n\t\tdel_result->referral = NULL;\n\t}\n\ttalloc_free(local_ctx);\n\treturn ldapsrv_queue_reply(call, del_reply);\n}", "target": 0}
{"code": "static void virtio_blk_handle_write(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n{\n    BlockRequest *blkreq;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    trace_virtio_blk_handle_write(req, sector, req->qiov.size / 512);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    if (mrb->num_writes == 32) {\n        virtio_submit_multiwrite(req->dev->bs, mrb);\n    }\n    blkreq = &mrb->blkreq[mrb->num_writes];\n    blkreq->sector = sector;\n    blkreq->nb_sectors = req->qiov.size / BDRV_SECTOR_SIZE;\n    blkreq->qiov = &req->qiov;\n    blkreq->cb = virtio_blk_rw_complete;\n    blkreq->opaque = req;\n    blkreq->error = 0;\n    mrb->num_writes++;\n}", "target": 1}
{"code": "  SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)\n      : is_subgraph_in_use_(is_subgraph_in_use) {\n    if (*is_subgraph_in_use_) {\n      TF_LITE_KERNEL_LOG(\n          context,\n          \"Subgraph is already in use. Using an interpreter or a subgraph in \"\n          \"multiple threads is not supported. Recursion in the graph is not \"\n          \"supported.\");\n      status_ = kTfLiteError;\n    } else {\n      *is_subgraph_in_use_ = true;\n    }\n  }", "target": 0}
{"code": "static void mce_start_timer(struct timer_list *t)\n{\n\tunsigned long iv = check_interval * HZ;\n\tif (mca_cfg.ignore_ce || !iv)\n\t\treturn;\n\tthis_cpu_write(mce_next_interval, iv);\n\t__start_timer(t, iv);\n}", "target": 0}
{"code": "static int vt_disallocate(unsigned int vc_num)\n{\n\tstruct vc_data *vc = NULL;\n\tint ret = 0;\n\tconsole_lock();\n\tif (vt_busy(vc_num))\n\t\tret = -EBUSY;\n\telse if (vc_num)\n\t\tvc = vc_deallocate(vc_num);\n\tconsole_unlock();\n\tif (vc && vc_num >= MIN_NR_CONSOLES) {\n\t\ttty_port_destroy(&vc->port);\n\t\tkfree(vc);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "  void NotifyNetworkChanged(Network* network) {\n    DCHECK(network);\n    NetworkObserverMap::const_iterator iter = network_observers_.find(\n        network->service_path());\n    if (iter != network_observers_.end()) {\n      FOR_EACH_OBSERVER(NetworkObserver,\n                        *(iter->second),\n                        OnNetworkChanged(this, network));\n    } else {\n      NOTREACHED() <<\n          \"There weren't supposed to be any property change observers of \" <<\n           network->service_path();\n    }\n  }", "target": 0}
{"code": "pa2l(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 4) {\n        *out++ = L(&palette[in[0] * 4]) / 1000;\n    }\n}", "target": 0}
{"code": "void rsi_mac80211_detach(struct rsi_hw *adapter)\n{\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tenum nl80211_band band;\n\tif (hw) {\n\t\tieee80211_stop_queues(hw);\n\t\tieee80211_unregister_hw(hw);\n\t\tieee80211_free_hw(hw);\n\t}\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\t\t\t&adapter->sbands[band];\n\t\tkfree(sband->channels);\n\t}\n#ifdef CONFIG_RSI_DEBUGFS\n\trsi_remove_dbgfs(adapter);\n\tkfree(adapter->dfsentry);\n#endif\n}", "target": 1}
{"code": "static int addrconf_ifid_ieee1394(u8 *eui, struct net_device *dev)\n{\n\tunion fwnet_hwaddr *ha;\n\tif (dev->addr_len != FWNET_ALEN)\n\t\treturn -1;\n\tha = (union fwnet_hwaddr *)dev->dev_addr;\n\tmemcpy(eui, &ha->uc.uniq_id, sizeof(ha->uc.uniq_id));\n\teui[0] ^= 2;\n\treturn 0;\n}", "target": 0}
{"code": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tswitch (status) {\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e->client);\n}", "target": 1}
{"code": "static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream)) {\n        stream->rtmp->http_status = http_status;\n    }\n}", "target": 1}
{"code": "static inline void sem_getref(struct sem_array *sma)\n{\n\tspin_lock(&(sma)->sem_perm.lock);\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "pthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\tEnterCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "static int compat_getdrvstat(int drive, bool poll,\n\t\t\t    struct compat_floppy_drive_struct __user *arg)\n{\n\tstruct compat_floppy_drive_struct v;\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_struct));\n\tmutex_lock(&floppy_mutex);\n\tif (poll) {\n\t\tif (lock_fdc(drive))\n\t\t\tgoto Eintr;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\tgoto Eintr;\n\t\tprocess_fd_request();\n\t}\n\tv.spinup_date = UDRS->spinup_date;\n\tv.select_date = UDRS->select_date;\n\tv.first_read_date = UDRS->first_read_date;\n\tv.probed_format = UDRS->probed_format;\n\tv.track = UDRS->track;\n\tv.maxblock = UDRS->maxblock;\n\tv.maxtrack = UDRS->maxtrack;\n\tv.generation = UDRS->generation;\n\tv.keep_data = UDRS->keep_data;\n\tv.fd_ref = UDRS->fd_ref;\n\tv.fd_device = UDRS->fd_device;\n\tv.last_checked = UDRS->last_checked;\n\tv.dmabuf = (uintptr_t)UDRS->dmabuf;\n\tv.bufblocks = UDRS->bufblocks;\n\tmutex_unlock(&floppy_mutex);\n\tif (copy_from_user(arg, &v, sizeof(struct compat_floppy_drive_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\nEintr:\n\tmutex_unlock(&floppy_mutex);\n\treturn -EINTR;\n}", "target": 0}
{"code": "accountingReportStats(XML_Parser originParser, const char *epilog) {\n  const XML_Parser rootParser = getRootParserOf(originParser, NULL);\n  assert(! rootParser->m_parentParser);\n  if (rootParser->m_accounting.debugLevel < 1) {\n    return;\n  }\n  const float amplificationFactor\n      = accountingGetCurrentAmplification(rootParser);\n  fprintf(stderr,\n          \"expat: Accounting(%p): Direct \" EXPAT_FMT_ULL(\n              \"10\") \", indirect \" EXPAT_FMT_ULL(\"10\") \", amplification %8.2f%s\",\n          (void *)rootParser, rootParser->m_accounting.countBytesDirect,\n          rootParser->m_accounting.countBytesIndirect,\n          (double)amplificationFactor, epilog);\n}", "target": 0}
{"code": "  explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    int64 signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }", "target": 0}
{"code": "write_os2_header (j_decompress_ptr cinfo, bmp_dest_ptr dest)\n{\n  char bmpfileheader[14];\n  char bmpcoreheader[12];\n  long headersize, bfSize;\n  int bits_per_pixel, cmap_entries;\n  if (cinfo->out_color_space == JCS_RGB ||\n      (cinfo->out_color_space >= JCS_EXT_RGB &&\n       cinfo->out_color_space <= JCS_EXT_ARGB)) {\n    if (cinfo->quantize_colors) {\n      bits_per_pixel = 8;\n      cmap_entries = 256;\n    } else {\n      bits_per_pixel = 24;\n      cmap_entries = 0;\n    }\n  } else if (cinfo->out_color_space == JCS_RGB565 ||\n             cinfo->out_color_space == JCS_CMYK) {\n    bits_per_pixel = 24;\n    cmap_entries   = 0;\n  } else {\n    bits_per_pixel = 8;\n    cmap_entries = 256;\n  }\n  headersize = 14 + 12 + cmap_entries * 3; \n  bfSize = headersize + (long) dest->row_width * (long) cinfo->output_height;\n  MEMZERO(bmpfileheader, sizeof(bmpfileheader));\n  MEMZERO(bmpcoreheader, sizeof(bmpcoreheader));\n  bmpfileheader[0] = 0x42;      \n  bmpfileheader[1] = 0x4D;\n  PUT_4B(bmpfileheader, 2, bfSize); \n  PUT_4B(bmpfileheader, 10, headersize); \n  PUT_2B(bmpcoreheader, 0, 12); \n  PUT_2B(bmpcoreheader, 4, cinfo->output_width); \n  PUT_2B(bmpcoreheader, 6, cinfo->output_height); \n  PUT_2B(bmpcoreheader, 8, 1);  \n  PUT_2B(bmpcoreheader, 10, bits_per_pixel); \n  if (JFWRITE(dest->pub.output_file, bmpfileheader, 14) != (size_t) 14)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (JFWRITE(dest->pub.output_file, bmpcoreheader, 12) != (size_t) 12)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (cmap_entries > 0)\n    write_colormap(cinfo, dest, cmap_entries, 3);\n}", "target": 0}
{"code": "void _WM_do_control_channel_pan(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].pan = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}", "target": 0}
{"code": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)\n{\n\tif (tl1 > l2)\n\t\treturn 0;\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)\n{\n    worker_score *ws;\n    apr_off_t bytes;\n    if (!sb)\n        return;\n    ws = &ap_scoreboard_image->servers[sb->child_num][sb->thread_num];\n    if (pfn_ap_logio_get_last_bytes != NULL) {\n        bytes = pfn_ap_logio_get_last_bytes(r->connection);\n    }\n    else if (r->method_number == M_GET && r->method[0] == 'H') {\n        bytes = 0;\n    }\n    else {\n        bytes = r->bytes_sent;\n    }\n#ifdef HAVE_TIMES\n    times(&ws->times);\n#endif\n    ws->access_count++;\n    ws->my_access_count++;\n    ws->conn_count++;\n    ws->bytes_served += bytes;\n    ws->my_bytes_served += bytes;\n    ws->conn_bytes += bytes;\n}", "target": 1}
{"code": "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)\n{\n\tGIOChannel *handle, *ssl_handle;\n\thandle = net_connect_ip(ip, port, my_ip);\n\tif (handle == NULL)\n\t\treturn NULL;\n\tssl_handle  = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);\n\tif (ssl_handle == NULL)\n\t\tg_io_channel_unref(handle);\n\treturn ssl_handle;\n}", "target": 1}
{"code": "void LibRaw::layer_thumb(){}", "target": 0}
{"code": "static inline void crst_table_init(unsigned long *crst, unsigned long entry)\n{\n\tclear_table(crst, entry, sizeof(unsigned long)*2048);\n}", "target": 0}
{"code": "    inline bool match(const EndpointSecurityAttributesMask remoteMask,\n        const PluginEndpointSecurityAttributesMask remotePluginMask) const\n    {\n        return security_mask_matches(mask(), remoteMask) &&\n            security_mask_matches(plugin_endpoint_attributes, remotePluginMask);\n    }", "target": 1}
{"code": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\ttrap = lock_rename(new_dir, old_dir);\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}", "target": 1}
{"code": "void FrameLoader::clientRedirectCancelledOrFinished(bool cancelWithLoadInProgress)\n{\n    m_client->dispatchDidCancelClientRedirect();\n    if (!cancelWithLoadInProgress)\n        m_quickRedirectComing = false;\n    m_sentRedirectNotification = false;\n}", "target": 0}
{"code": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}", "target": 1}
{"code": "static GF_MovieFragmentBox *gf_isom_get_moof(GF_ISOFile *file, u32 moof_index)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tmoof_index--;\n\t\t\tif (!moof_index) return (GF_MovieFragmentBox *) a;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static unsigned char ttyio_in(int timeout)\n{\n\tstruct spk_ldisc_data *ldisc_data = speakup_tty->disc_data;\n\tchar rv;\n\tif (wait_for_completion_timeout(&ldisc_data->completion,\n\t\t\t\t\tusecs_to_jiffies(timeout)) == 0) {\n\t\tif (timeout)\n\t\t\tpr_warn(\"spk_ttyio: timeout (%d)  while waiting for input\\n\",\n\t\t\t\ttimeout);\n\t\treturn 0xff;\n\t}\n\trv = ldisc_data->buf;\n\tmb();\n\tldisc_data->buf_free = true;\n\ttty_schedule_flip(speakup_tty->port);\n\treturn rv;\n}", "target": 0}
{"code": "Locked_tables_list::unlock_locked_tables(THD *thd)\n{\n  DBUG_ASSERT(!thd->in_sub_stmt &&\n              !(thd->state_flags & Open_tables_state::BACKUPS_AVAIL));\n  if (thd->locked_tables_mode != LTM_LOCK_TABLES)\n    return;\n  for (TABLE_LIST *table_list= m_locked_tables;\n       table_list; table_list= table_list->next_global)\n  {\n    if (table_list->table)                    \n      table_list->table->pos_in_locked_tables= NULL;\n  }\n  thd->leave_locked_tables_mode();\n  TRANSACT_TRACKER(clear_trx_state(thd, TX_LOCKED_TABLES));\n  DBUG_ASSERT(thd->transaction.stmt.is_empty());\n  close_thread_tables(thd);\n  reset();\n}", "target": 0}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "int remove_file(struct augeas *aug, struct tree *tree) {\n    char *path = NULL;\n    const char *filename = NULL;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    char *augsave = NULL, *augorig = NULL, *augorig_canon = NULL;\n    int r;\n    path = path_of_tree(tree);\n    if (path == NULL) {\n        err_status = \"path_of_tree\";\n        goto error;\n    }\n    filename = path + strlen(AUGEAS_META_FILES);\n    if ((augorig = strappend(aug->root, filename + 1)) == NULL) {\n        err_status = \"root_file\";\n        goto error;\n    }\n    augorig_canon = canonicalize_file_name(augorig);\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            goto done;\n        } else {\n            err_status = \"canon_augorig\";\n            goto error;\n        }\n    }\n    r = file_saved_event(aug, path + strlen(AUGEAS_META_TREE));\n    if (r < 0) {\n        err_status = \"saved_event\";\n        goto error;\n    }\n    if (aug->flags & AUG_SAVE_NOOP)\n        goto done;\n    if (aug->flags & AUG_SAVE_BACKUP) {\n        r = asprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig_canon);\n        if (r == -1) {\n            augsave = NULL;\n                goto error;\n        }\n        r = clone_file(augorig_canon, augsave, &err_status, 1, 1);\n        if (r != 0) {\n            dyn_err_status = strappend(err_status, \"_augsave\");\n            goto error;\n        }\n    } else {\n        r = unlink(augorig_canon);\n        if (r < 0) {\n            err_status = \"unlink_orig\";\n            goto error;\n        }\n    }\n    tree_unlink(tree);\n done:\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    return 0;\n error:\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, NULL, NULL);\n    }\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    free(dyn_err_status);\n    return -1;\n}", "target": 0}
{"code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\treturn pfn;\n}", "target": 1}
{"code": "vte_terminal_find_charcell (VteTerminal *terminal, glong col, glong row)\n{\n\tVteRowData *rowdata;\n\tVteCell *ret = NULL;\n\tVteScreen *screen;\n\tg_assert(VTE_IS_TERMINAL(terminal));\n\tscreen = terminal->pvt->screen;\n\tif (_vte_ring_contains (screen->row_data, row)) {\n\t\trowdata = _vte_ring_index_writable (screen->row_data, row);\n\t\tret = _vte_row_data_get_writable (rowdata, col);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int wait_phy_eeprom_ready(struct usbnet *dev, int phy)\n{\n\tint i;\n\tfor (i = 0; i < SR_SHARE_TIMEOUT; i++) {\n\t\tu8 tmp = 0;\n\t\tint ret;\n\t\tudelay(1);\n\t\tret = sr_read_reg(dev, SR_EPCR, &tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!(tmp & EPCR_ERRE))\n\t\t\treturn 0;\n\t}\n\tnetdev_err(dev->net, \"%s write timed out!\\n\", phy ? \"phy\" : \"eeprom\");\n\treturn -EIO;\n}", "target": 0}
{"code": "TIFFOpenW(const wchar_t* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpenW\";\n\tthandle_t fd;\n\tint m;\n\tDWORD dwMode;\n\tint mbsize;\n\tchar *mbname;\n\tTIFF *tif;\n\tm = _TIFFgetMode(mode, module);\n\tswitch(m) {\n\t\tcase O_RDONLY:\t\t\tdwMode = OPEN_EXISTING; break;\n\t\tcase O_RDWR:\t\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_CREAT:\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_TRUNC:\t\tdwMode = CREATE_ALWAYS; break;\n\t\tcase O_RDWR|O_CREAT|O_TRUNC:\tdwMode = CREATE_ALWAYS; break;\n\t\tdefault:\t\t\treturn ((TIFF*)0);\n\t}\n\tfd = (thandle_t)CreateFileW(name,\n\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE),\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode,\n\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\n\t\tNULL);\n\tif (fd == INVALID_HANDLE_VALUE) {\n\t\tTIFFErrorExt(0, module, \"%S: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\tmbname = NULL;\n\tmbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);\n\tif (mbsize > 0) {\n\t\tmbname = (char *)_TIFFmalloc(mbsize);\n\t\tif (!mbname) {\n\t\t\tTIFFErrorExt(0, module,\n\t\t\t\"Can't allocate space for filename conversion buffer\");\n\t\t\treturn ((TIFF*)0);\n\t\t}\n\t\tWideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,\n\t\t\t\t    NULL, NULL);\n\t}\n\ttif = TIFFFdOpen((int)fd,    \n\t\t\t (mbname != NULL) ? mbname : \"<unknown>\", mode);\n\tif(!tif)\n\t\tCloseHandle(fd);\n\t_TIFFfree(mbname);\n\treturn tif;\n}", "target": 0}
{"code": "xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    return(ret);\n}", "target": 1}
{"code": "Fraction::Fraction(int32_t num,int32_t den)\n{\n  int32_t g = gcd(num, den);\n  if (num == std::numeric_limits<int32_t>::min() && g == -1) {\n    num++;\n  }\n  if (den == std::numeric_limits<int32_t>::min() && g == -1) {\n    den++;\n  }\n  numerator = num / g;\n  denominator = den / g;\n  while (denominator > MAX_FRACTION_DENOMINATOR) {\n    numerator >>= 1;\n    denominator >>= 1;\n  }\n}", "target": 1}
{"code": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data( 0);\n    }\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 0}
{"code": "static void bluetooth_client_finalize(GObject *object)\n{\n\tBluetoothClient *client = BLUETOOTH_CLIENT (object);\n\tBluetoothClientPrivate *priv = BLUETOOTH_CLIENT_GET_PRIVATE (client);\n\tif (priv->cancellable != NULL) {\n\t\tg_cancellable_cancel (priv->cancellable);\n\t\tg_clear_object (&priv->cancellable);\n\t}\n\tg_clear_object (&priv->manager);\n\tg_object_unref (priv->store);\n\tg_clear_pointer (&priv->default_adapter, gtk_tree_row_reference_free);\n\tG_OBJECT_CLASS(bluetooth_client_parent_class)->finalize (object);\n}", "target": 0}
{"code": "int udp_sendpage(struct sock *sk, struct page *page, int offset,\n\t\t size_t size, int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tint ret;\n\tif (flags & MSG_SENDPAGE_NOTLAST)\n\t\tflags |= MSG_MORE;\n\tif (!up->pending) {\n\t\tstruct msghdr msg = {\t.msg_flags = flags|MSG_MORE };\n\t\tret = udp_sendmsg(sk, &msg, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tlock_sock(sk);\n\tif (unlikely(!up->pending)) {\n\t\trelease_sock(sk);\n\t\tnet_dbg_ratelimited(\"udp cork app bug 3\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = ip_append_page(sk, &inet->cork.fl.u.ip4,\n\t\t\t     page, offset, size, flags);\n\tif (ret == -EOPNOTSUPP) {\n\t\trelease_sock(sk);\n\t\treturn sock_no_sendpage(sk->sk_socket, page, offset,\n\t\t\t\t\tsize, flags);\n\t}\n\tif (ret < 0) {\n\t\tudp_flush_pending_frames(sk);\n\t\tgoto out;\n\t}\n\tup->len += size;\n\tif (!(up->corkflag || (flags&MSG_MORE)))\n\t\tret = udp_push_pending_frames(sk);\n\tif (!ret)\n\t\tret = size;\nout:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 0}
{"code": "static unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tstruct sock *sk = tun->sk;\n\tunsigned int mask = 0;\n\tif (!tun)\n\t\treturn POLLERR;\n\tDBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n\tpoll_wait(file, &tun->socket.wait, wait);\n\tif (!skb_queue_empty(&tun->readq))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = POLLERR;\n\ttun_put(tun);\n\treturn mask;\n}", "target": 1}
{"code": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n\tconst struct user_desc *info;\n\tint i;\n\tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n\t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n\telse\n\t\tinfo = infobuf;\n\tfor (i = 0; i < count / sizeof(struct user_desc); i++)\n\t\tif (!tls_desc_okay(info + i))\n\t\t\treturn -EINVAL;\n\tset_tls_desc(target,\n\t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n\t\t     info, count / sizeof(struct user_desc));\n\treturn 0;\n}", "target": 0}
{"code": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "    DataLocId CiffComponent::dataLocation(uint16_t tag)\n    {\n        switch (tag & 0xc000) {\n        case 0x0000: return valueData;\n        case 0x4000: return directoryData;\n        default: throw Error(kerCorruptedMetadata);\n        }\n    } ", "target": 0}
{"code": "static void _cmd_window_show_opt(const char *data, int right)\n{\n\tMAIN_WINDOW_REC *parent;\n\tWINDOW_REC *window;\n\tif (*data == '\\0') cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS);\n\tif (is_numeric(data, '\\0')) {\n\t\twindow = window_find_refnum(atoi(data));\n\t\tif (window == NULL) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_REFNUM_NOT_FOUND, data);\n\t\t}\n\t} else {\n\t\twindow = window_find_item(active_win->active_server, data);\n\t}\n\tif (window == NULL || is_window_visible(window))\n\t\treturn;\n\tif (WINDOW_GUI(window)->sticky) {\n\t\tif (!settings_get_bool(\"autounstick_windows\")) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_CANT_SHOW_STICKY_WINDOWS);\n\t\t\treturn;\n\t\t}\n\t}\n\tparent = mainwindow_create(right);\n\tparent->active = window;\n\tgui_window_reparent(window, parent);\n\tif (settings_get_bool(\"autostick_split_windows\"))\n\t\tgui_window_set_sticky(window);\n\tactive_mainwin = NULL;\n\twindow_set_active(window);\n}", "target": 1}
{"code": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n    u32in();\n    u32in();\n    mp4config.frame.ents = u32in();\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n        mp4config.frame.data[cnt + 1] = ofs;\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n    return size;\n}", "target": 1}
{"code": "static int sr9700_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct sk_buff *sr_skb;\n\tint len;\n\tif (unlikely(skb->len < SR_RX_OVERHEAD)) {\n\t\tnetdev_err(dev->net, \"unexpected tiny rx frame\\n\");\n\t\treturn 0;\n\t}\n\twhile (skb->len > SR_RX_OVERHEAD) {\n\t\tif (skb->data[0] != 0x40)\n\t\t\treturn 0;\n\t\tlen = (skb->data[1] | (skb->data[2] << 8)) - 4;\n\t\tif (len > ETH_FRAME_LEN || len > skb->len)\n\t\t\treturn 0;\n\t\tif (skb->len == (len + SR_RX_OVERHEAD))\t{\n\t\t\tskb_pull(skb, 3);\n\t\t\tskb->len = len;\n\t\t\tskb_set_tail_pointer(skb, len);\n\t\t\tskb->truesize = len + sizeof(struct sk_buff);\n\t\t\treturn 2;\n\t\t}\n\t\tsr_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!sr_skb)\n\t\t\treturn 0;\n\t\tsr_skb->len = len;\n\t\tsr_skb->data = skb->data + 3;\n\t\tskb_set_tail_pointer(sr_skb, len);\n\t\tsr_skb->truesize = len + sizeof(struct sk_buff);\n\t\tusbnet_skb_return(dev, sr_skb);\n\t\tskb_pull(skb, len + SR_RX_OVERHEAD);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "bgp_attr_get_as_size(netdissect_options *ndo,\n                     uint8_t bgpa_type, const u_char *pptr, int len)\n{\n    const u_char *tptr = pptr;\n    if (bgpa_type == BGPTYPE_AS4_PATH) {\n        return 4;\n    }\n    while (tptr < pptr + len) {\n        ND_TCHECK(tptr[0]);\n        if (tptr[0] < BGP_AS_SEG_TYPE_MIN || tptr[0] > BGP_AS_SEG_TYPE_MAX) {\n            goto trunc;\n        }\n        ND_TCHECK(tptr[1]);\n        tptr += 2 + tptr[1] * 2;\n    }\n    if (tptr == pptr + len) {\n        return 2;\n    }\ntrunc:\n   return 4;\n}", "target": 0}
{"code": "static void virtio_net_announce(NetClientState *nc)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    if (n->announce_timer.round) {\n        return;\n    }\n    if (virtio_vdev_has_feature(vdev, VIRTIO_NET_F_GUEST_ANNOUNCE) &&\n        virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)) {\n            virtio_net_announce_notify(n);\n    }\n}", "target": 0}
{"code": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n    }\n    if (data_end - data < 3)\n        return -1;\n    data++;\n    for (;;) {\n        int size = bytestream_get_be16(&data);\n        if (!size)\n            break;\n        if (size < 0 || size >= data_end - data)\n            return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n            return -1;\n        data += len;\n    }\n    return -1;\n}", "target": 1}
{"code": "static inline unsigned long do_div_llr(const long long dividend,\n\t\t\t\t       const long divisor, long *remainder)\n{\n\tu64 result = dividend;\n\t*(remainder) = do_div(result, divisor);\n\treturn (unsigned long) result;\n}", "target": 1}
{"code": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= user_match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\tsprintf(description, \"%x\", target_id);\n\tauthkey_ref = search_process_keyrings(&ctx);\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\nerror:\n\treturn authkey;\n}", "target": 1}
{"code": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}", "target": 1}
{"code": "nwfilterConnectNumOfNWFilters(virConnectPtr conn)\n{\n    if (virConnectNumOfNWFiltersEnsureACL(conn) < 0)\n        return -1;\n    return virNWFilterObjListNumOfNWFilters(driver->nwfilters, conn,\n                                        virConnectNumOfNWFiltersCheckACL);\n}", "target": 1}
{"code": "tiff12_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    gx_device_tiff *const tfdev = (gx_device_tiff *)pdev;\n    int code;\n    if (gdev_prn_file_is_new(pdev)) {\n        tfdev->tif = tiff_from_filep(pdev, pdev->dname, file, tfdev->BigEndian, tfdev->UseBigTIFF);\n        if (!tfdev->tif)\n            return_error(gs_error_invalidfileaccess);\n    }\n    code = gdev_tiff_begin_page(tfdev, file);\n    if (code < 0)\n        return code;\n    TIFFSetField(tfdev->tif, TIFFTAG_BITSPERSAMPLE, 4);\n    tiff_set_rgb_fields(tfdev);\n    TIFFCheckpointDirectory(tfdev->tif);\n    {\n        int y;\n        int size = gdev_prn_raster(pdev);\n        byte *data = gs_alloc_bytes(pdev->memory, size, \"tiff12_print_page\");\n        if (data == 0)\n            return_error(gs_error_VMerror);\n        memset(data, 0, size);\n        for (y = 0; y < pdev->height; ++y) {\n            const byte *src;\n            byte *dest;\n            int x;\n            code = gdev_prn_copy_scan_lines(pdev, y, data, size);\n            if (code < 0)\n                break;\n            for (src = data, dest = data, x = 0; x < size;\n                 src += 6, dest += 3, x += 6\n                ) {\n                dest[0] = (src[0] & 0xf0) | (src[1] >> 4);\n                dest[1] = (src[2] & 0xf0) | (src[3] >> 4);\n                dest[2] = (src[4] & 0xf0) | (src[5] >> 4);\n            }\n            TIFFWriteScanline(tfdev->tif, data, y, 0);\n        }\n        gs_free_object(pdev->memory, data, \"tiff12_print_page\");\n        TIFFWriteDirectory(tfdev->tif);\n    }\n    return code;\n}", "target": 1}
{"code": "static int __vhost_add_used_n(struct vhost_virtqueue *vq,\n\t\t\t    struct vring_used_elem *heads,\n\t\t\t    unsigned count)\n{\n\tstruct vring_used_elem __user *used;\n\tu16 old, new;\n\tint start;\n\tstart = vq->last_used_idx % vq->num;\n\tused = vq->used->ring + start;\n\tif (__copy_to_user(used, heads, count * sizeof *used)) {\n\t\tvq_err(vq, \"Failed to write used\");\n\t\treturn -EFAULT;\n\t}\n\tif (unlikely(vq->log_used)) {\n\t\tsmp_wmb();\n\t\tlog_write(vq->log_base,\n\t\t\t  vq->log_addr +\n\t\t\t   ((void __user *)used - (void __user *)vq->used),\n\t\t\t  count * sizeof *used);\n\t}\n\told = vq->last_used_idx;\n\tnew = (vq->last_used_idx += count);\n\tif (unlikely((u16)(new - vq->signalled_used) < (u16)(new - old)))\n\t\tvq->signalled_used_valid = false;\n\treturn 0;\n}", "target": 0}
{"code": "xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if (value == NULL) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif \n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}", "target": 1}
{"code": "void HTTPSession::onCertificate(uint16_t certId,\n                                std::unique_ptr<IOBuf> authenticator) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE on\" << *this << \", certId=\" << certId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  bool isValid = false;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::UPSTREAM,\n          certId,\n          std::move(authenticator));\n    } else {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::DOWNSTREAM,\n          certId,\n          std::move(authenticator));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (isValid) {\n    VLOG(4) << \"Successfully validated the authenticator provided by the peer.\";\n  } else {\n    VLOG(4) << \"Failed to validate the authenticator provided by the peer\";\n  }\n}", "target": 0}
{"code": "static inline void nft_reg_store64(u32 *dreg, u64 val)\n{\n\tput_unaligned(val, (u64 *)dreg);\n}", "target": 1}
{"code": "struct key *rxrpc_get_null_key(const char *keyname)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key *key;\n\tint ret;\n\tkey = key_alloc(&key_type_rxrpc, keyname,\n\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\tKEY_POS_SEARCH, KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key))\n\t\treturn key;\n\tret = key_instantiate_and_link(key, NULL, 0, NULL, NULL);\n\tif (ret < 0) {\n\t\tkey_revoke(key);\n\t\tkey_put(key);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn key;\n}", "target": 0}
{"code": "void mark_progress(struct st_command* command __attribute__((unused)),\n                   int line)\n{\n  static ulonglong progress_start= 0; \n  DYNAMIC_STRING ds_progress;\n  char buf[32], *end;\n  ulonglong timer= timer_now();\n  if (!progress_start)\n    progress_start= timer;\n  timer-= progress_start;\n  if (init_dynamic_string(&ds_progress, \"\", 256, 256))\n    die(\"Out of memory\");\n  end= longlong10_to_str(timer, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  end= int10_to_str(line, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  dynstr_append(&ds_progress, cur_file->file_name);\n  dynstr_append_mem(&ds_progress, \":\", 1);\n  end= int10_to_str(cur_file->lineno, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\n\", 1);\n  progress_file.write(&ds_progress);\n  dynstr_free(&ds_progress);\n}", "target": 0}
{"code": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void calc_group_buffer(TMP_TABLE_PARAM *param, ORDER *group)\n{\n  uint key_length=0, parts=0, null_parts=0;\n  for (; group ; group=group->next)\n  {\n    Item *group_item= *group->item;\n    Field *field= group_item->get_tmp_table_field();\n    if (field)\n    {\n      enum_field_types type;\n      if ((type= field->type()) == MYSQL_TYPE_BLOB)\n\tkey_length+=MAX_BLOB_WIDTH;\t\t\n      else if (type == MYSQL_TYPE_VARCHAR || type == MYSQL_TYPE_VAR_STRING)\n        key_length+= field->field_length + HA_KEY_BLOB_LENGTH;\n      else if (type == MYSQL_TYPE_BIT)\n      {\n        key_length+= 8;                         \n      }\n      else\n\tkey_length+= field->pack_length();\n    }\n    else\n    { \n      switch (group_item->cmp_type()) {\n      case REAL_RESULT:\n        key_length+= sizeof(double);\n        break;\n      case INT_RESULT:\n        key_length+= sizeof(longlong);\n        break;\n      case DECIMAL_RESULT:\n        key_length+= my_decimal_get_binary_size(group_item->max_length - \n                                                (group_item->decimals ? 1 : 0),\n                                                group_item->decimals);\n        break;\n      case TIME_RESULT:\n      {\n        key_length+= 8;\n        break;\n      }\n      case STRING_RESULT:\n      {\n        enum enum_field_types type= group_item->field_type();\n        if (type == MYSQL_TYPE_BLOB)\n          key_length+= MAX_BLOB_WIDTH;\t\t\n        else\n        {\n          key_length+= group_item->max_length + HA_KEY_BLOB_LENGTH;\n        }\n        break;\n      }\n      default:\n        DBUG_ASSERT(0);\n        my_error(ER_OUT_OF_RESOURCES, MYF(ME_FATAL));\n      }\n    }\n    parts++;\n    if (group_item->maybe_null)\n      null_parts++;\n  }\n  param->group_length= key_length + null_parts;\n  param->group_parts= parts;\n  param->group_null_parts= null_parts;\n}", "target": 0}
{"code": "merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n                         output_buf + *out_row_ctr);\n  (*out_row_ctr)++;\n  (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}", "target": 1}
{"code": "static u32 udp6_portaddr_hash(const struct net *net,\n\t\t\t      const struct in6_addr *addr6,\n\t\t\t      unsigned int port)\n{\n\tunsigned int hash, mix = net_hash_mix(net);\n\tif (ipv6_addr_any(addr6))\n\t\thash = jhash_1word(0, mix);\n\telse if (ipv6_addr_v4mapped(addr6))\n\t\thash = jhash_1word((__force u32)addr6->s6_addr32[3], mix);\n\telse\n\t\thash = jhash2((__force u32 *)addr6->s6_addr32, 4, mix);\n\treturn hash ^ port;\n}", "target": 0}
{"code": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\ttmp = !!tmp; \n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\treturn count;\n}", "target": 1}
{"code": "static ssize_t remove_slot_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tint rc;\n\tchar *end;\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\tmemcpy(drc_name, buf, nbytes);\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\trc = dlpar_remove_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\treturn nbytes;\n}", "target": 1}
{"code": "njs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n    };\n    vm->retval = *types[value->type];\n    return sizeof(njs_vmcode_2addr_t);\n}", "target": 1}
{"code": "static void print_liveness(struct bpf_verifier_env *env,\n\t\t\t   enum bpf_reg_liveness live)\n{\n\tif (live & (REG_LIVE_READ | REG_LIVE_WRITTEN | REG_LIVE_DONE))\n\t    verbose(env, \"_\");\n\tif (live & REG_LIVE_READ)\n\t\tverbose(env, \"r\");\n\tif (live & REG_LIVE_WRITTEN)\n\t\tverbose(env, \"w\");\n\tif (live & REG_LIVE_DONE)\n\t\tverbose(env, \"D\");\n}", "target": 0}
{"code": "sg_release(struct inode *inode, struct file *filp)\n{\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp, \"sg_release\\n\"));\n\tmutex_lock(&sdp->open_rel_lock);\n\tscsi_autopm_put_device(sdp->device);\n\tkref_put(&sfp->f_ref, sg_remove_sfp);\n\tsdp->open_cnt--;\n\tif (sdp->exclude) {\n\t\tsdp->exclude = false;\n\t\twake_up_interruptible_all(&sdp->open_wait);\n\t} else if (0 == sdp->open_cnt) {\n\t\twake_up_interruptible(&sdp->open_wait);\n\t}\n\tmutex_unlock(&sdp->open_rel_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static int FNAME(cmpxchg_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t       pt_element_t __user *ptep_user, unsigned index,\n\t\t\t       pt_element_t orig_pte, pt_element_t new_pte)\n{\n\tint npages;\n\tpt_element_t ret;\n\tpt_element_t *table;\n\tstruct page *page;\n\tnpages = get_user_pages_fast((unsigned long)ptep_user, 1, FOLL_WRITE, &page);\n\tif (likely(npages == 1)) {\n\t\ttable = kmap_atomic(page);\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tkunmap_atomic(table);\n\t\tkvm_release_page_dirty(page);\n\t} else {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned long vaddr = (unsigned long)ptep_user & PAGE_MASK;\n\t\tunsigned long pfn;\n\t\tunsigned long paddr;\n\t\tmmap_read_lock(current->mm);\n\t\tvma = find_vma_intersection(current->mm, vaddr, vaddr + PAGE_SIZE);\n\t\tif (!vma || !(vma->vm_flags & VM_PFNMAP)) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tpfn = ((vaddr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\t\tpaddr = pfn << PAGE_SHIFT;\n\t\ttable = memremap(paddr, PAGE_SIZE, MEMREMAP_WB);\n\t\tif (!table) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tmemunmap(table);\n\t\tmmap_read_unlock(current->mm);\n\t}\n\treturn (ret != orig_pte);\n}", "target": 1}
{"code": "static int update_alu_sanitation_state(struct bpf_insn_aux_data *aux,\n\t\t\t\t       u32 alu_state, u32 alu_limit)\n{\n\tif (aux->alu_state &&\n\t    (aux->alu_state != alu_state ||\n\t     aux->alu_limit != alu_limit))\n\t\treturn -EACCES;\n\taux->alu_state = alu_state;\n\taux->alu_limit = alu_limit;\n\treturn 0;\n}", "target": 0}
{"code": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}", "target": 1}
{"code": "static int zipfileComparePath(const char *zA, const char *zB, int nB){\n  int nA = (int)strlen(zA);\n  if( zA[nA-1]=='/' ) nA--;\n  if( zB[nB-1]=='/' ) nB--;\n  if( nA==nB && memcmp(zA, zB, nA)==0 ) return 0;\n  return 1;\n}", "target": 0}
{"code": "void vrend_renderer_context_create_internal(uint32_t handle, uint32_t nlen,\n                                            const char *debug_name)\n{\n   struct vrend_decode_ctx *dctx;\n   if (handle >= VREND_MAX_CTX)\n      return;\n   dctx = malloc(sizeof(struct vrend_decode_ctx));\n   if (!dctx)\n      return;\n   dctx->grctx = vrend_create_context(handle, nlen, debug_name);\n   if (!dctx->grctx) {\n      free(dctx);\n      return;\n   }\n   dctx->ds = &dctx->ids;\n   dec_ctx[handle] = dctx;\n}", "target": 1}
{"code": "static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)\n{\n\tu8 *buffer;\n\tint err;\n\tbuffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tbuffer[0] = 0;\n\tbuffer[1] = !!loaded;\n\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD, buffer,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD_REQ_LEN);\n\tkfree(buffer);\n\treturn err;\n}", "target": 1}
{"code": "hb_set_invert (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->invert ();\n}", "target": 1}
{"code": "int ipmi_validate_addr(struct ipmi_addr *addr, int len)\n{\n\tif (len < sizeof(struct ipmi_system_interface_addr))\n\t\treturn -EINVAL;\n\tif (addr->addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE) {\n\t\tif (addr->channel != IPMI_BMC_CHANNEL)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif ((addr->channel == IPMI_BMC_CHANNEL)\n\t    || (addr->channel >= IPMI_MAX_CHANNELS)\n\t    || (addr->channel < 0))\n\t\treturn -EINVAL;\n\tif (is_ipmb_addr(addr) || is_ipmb_bcast_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_ipmb_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif (is_lan_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_lan_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\tDBG(\"\");\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\tset_discovery_discoverable(adapter, l ? true : false);\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\ttrigger_start_discovery(adapter, 0);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "LCN ntfs_attr_vcn_to_lcn(ntfs_attr *na, const VCN vcn)\n{\n\tLCN lcn;\n\tBOOL is_retry = FALSE;\n\tif (!na || !NAttrNonResident(na) || vcn < 0)\n\t\treturn (LCN)LCN_EINVAL;\n\tntfs_log_trace(\"Entering for inode 0x%llx, attr 0x%x.\\n\", (unsigned long\n\t\t\tlong)na->ni->mft_no, le32_to_cpu(na->type));\nretry:\n\tlcn = ntfs_rl_vcn_to_lcn(na->rl, vcn);\n\tif (lcn >= 0)\n\t\treturn lcn;\n\tif (!is_retry && !ntfs_attr_map_runlist(na, vcn)) {\n\t\tis_retry = TRUE;\n\t\tgoto retry;\n\t}\n\tif (!is_retry || lcn == (LCN)LCN_RL_NOT_MAPPED)\n\t\treturn (LCN)LCN_EIO;\n\treturn lcn;\n}", "target": 0}
{"code": "static void sp_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &sp_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->mtu\t\t= SIXP_MTU;\n\tdev->hard_header_len\t= AX25_MAX_HEADER_LEN;\n\tdev->header_ops \t= &ax25_header_ops;\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_AX25;\n\tdev->tx_queue_len\t= 10;\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\tdev->flags\t\t= 0;\n}", "target": 1}
{"code": "static inline void ConvertXYZToRGB(const double X,const double Y,const double Z,\n  double *red,double *green,double *blue)\n{\n  double\n    b,\n    g,\n    r;\n  assert(red != (double *) NULL);\n  assert(green != (double *) NULL);\n  assert(blue != (double *) NULL);\n  r=3.2404542*X-1.5371385*Y-0.4985314*Z;\n  g=(-0.9692660)*X+1.8760108*Y+0.0415560*Z;\n  b=0.0556434*X-0.2040259*Y+1.0572252*Z;\n  *red=EncodePixelGamma(QuantumRange*r);\n  *green=EncodePixelGamma(QuantumRange*g);\n  *blue=EncodePixelGamma(QuantumRange*b);\n}", "target": 0}
{"code": "static void decode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])\n{\n    int x, y, p;\n    int16_t *sample[4][2];\n    int lbd    = s->avctx->bits_per_raw_sample <= 8;\n    int bits   = s->avctx->bits_per_raw_sample > 0 ? s->avctx->bits_per_raw_sample : 8;\n    int offset = 1 << bits;\n    for (x = 0; x < 4; x++) {\n        sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;\n        sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;\n    }\n    s->run_index = 0;\n    memset(s->sample_buffer, 0, 8 * (w + 6) * sizeof(*s->sample_buffer));\n    for (y = 0; y < h; y++) {\n        for (p = 0; p < 3 + s->transparency; p++) {\n            int16_t *temp = sample[p][0]; \n            sample[p][0] = sample[p][1];\n            sample[p][1] = temp;\n            sample[p][1][-1]= sample[p][0][0  ];\n            sample[p][0][ w]= sample[p][0][w-1];\n            if (lbd && s->slice_coding_mode == 0)\n                decode_line(s, w, sample[p], (p + 1)/2, 9);\n            else\n                decode_line(s, w, sample[p], (p + 1)/2, bits + (s->slice_coding_mode != 1));\n        }\n        for (x = 0; x < w; x++) {\n            int g = sample[0][1][x];\n            int b = sample[1][1][x];\n            int r = sample[2][1][x];\n            int a = sample[3][1][x];\n            if (s->slice_coding_mode != 1) {\n                b -= offset;\n                r -= offset;\n                g -= (b * s->slice_rct_by_coef + r * s->slice_rct_ry_coef) >> 2;\n                b += g;\n                r += g;\n            }\n            if (lbd)\n                *((uint32_t*)(src[0] + x*4 + stride[0]*y)) = b + (g<<8) + (r<<16) + (a<<24);\n            else {\n                *((uint16_t*)(src[0] + x*2 + stride[0]*y)) = b;\n                *((uint16_t*)(src[1] + x*2 + stride[1]*y)) = g;\n                *((uint16_t*)(src[2] + x*2 + stride[2]*y)) = r;\n            }\n        }\n    }\n}", "target": 0}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}", "target": 1}
{"code": "Eina_Bool ewk_view_setting_caret_browsing_set(Evas_Object* ewkView, Eina_Bool enable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    enable = !!enable;\n    if (priv->settings.caretBrowsing != enable) {\n        priv->pageSettings->setCaretBrowsingEnabled(enable);\n        priv->settings.caretBrowsing = enable;\n    }\n    return true;\n}", "target": 0}
{"code": "int32_t cli_bcapi_extract_new(struct cli_bc_ctx *ctx, int32_t id)\n{\n    cli_ctx *cctx;\n    int res = -1;\n    cli_event_count(EV, BCEV_EXTRACTED);\n    cli_dbgmsg(\"previous tempfile had %u bytes\\n\", ctx->written);\n    if (!ctx->written)\n\treturn 0;\n    if (ctx->ctx && cli_updatelimits(ctx->ctx, ctx->written))\n\treturn -1;\n    ctx->written = 0;\n    lseek(ctx->outfd, 0, SEEK_SET);\n    cli_dbgmsg(\"bytecode: scanning extracted file %s\\n\", ctx->tempfile);\n    cctx = (cli_ctx*)ctx->ctx;\n    if (cctx) {\n\tcli_file_t current = cctx->container_type;\n\tif (ctx->containertype != CL_TYPE_ANY)\n\t    cctx->container_type = ctx->containertype;\n\tres = cli_magic_scandesc(ctx->outfd, cctx);\n\tcctx->container_type = current;\n\tif (res == CL_VIRUS) {\n\t    if (cctx->virname)\n\t\tctx->virname = *cctx->virname;\n\t    ctx->found = 1;\n\t}\n    }\n    if ((cctx && cctx->engine->keeptmp) ||\n\t(ftruncate(ctx->outfd, 0) == -1)) {\n\tclose(ctx->outfd);\n\tif (!(cctx && cctx->engine->keeptmp) && ctx->tempfile)\n\t    cli_unlink(ctx->tempfile);\n\tfree(ctx->tempfile);\n\tctx->tempfile = NULL;\n\tctx->outfd = 0;\n    }\n    cli_dbgmsg(\"bytecode: extracting new file with id %u\\n\", id);\n    return res;\n}", "target": 1}
{"code": "static int ExecuteHelp( SQLHDBC hDbc, char *szSQL, char cDelimiter, int bColumnNames, int bHTMLTable )\n{\n    char            szTable[250]                        = \"\";\n    SQLHSTMT        hStmt;\n    SQLTCHAR        szSepLine[32001];   \n    SQLLEN          nRows               = 0;\n    szSepLine[ 0 ] = 0;\n    if ( SQLAllocStmt( hDbc, &hStmt ) != SQL_SUCCESS )\n    {\n        if ( bVerbose ) DumpODBCLog( hEnv, hDbc, 0 );\n        fprintf( stderr, \"[ISQL]ERROR: Could not SQLAllocStmt\\n\" );\n        return 0;\n    }\n    if ( iniElement( szSQL, ' ', '\\0', 1, szTable, sizeof(szTable) ) == INI_SUCCESS )\n    {\n        SQLWCHAR tname[ 1024 ];\n        ansi_to_unicode( szTable, tname );\n        if ( SQLColumns( hStmt, NULL, 0, NULL, 0, tname, SQL_NTS, NULL, 0 ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLColumns\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n    else\n    {\n        if ( SQLTables( hStmt, NULL, 0, NULL, 0, NULL, 0, NULL, 0 ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLTables\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n    if ( bHTMLTable )\n        WriteHeaderHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        UWriteHeaderNormal( hStmt, szSepLine );\n    else if ( cDelimiter && bColumnNames )\n        WriteHeaderDelimited( hStmt, cDelimiter );\n    if ( bHTMLTable )\n        WriteBodyHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        nRows = WriteBodyNormal( hStmt );\n    else\n        WriteBodyDelimited( hStmt, cDelimiter );\n    if ( bHTMLTable )\n        WriteFooterHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        UWriteFooterNormal( hStmt, szSepLine, nRows );\n    SQLFreeStmt( hStmt, SQL_DROP );\n    return 1;\n}", "target": 0}
{"code": "static inline void get_conn_text(const conn *c, const int af,\n                char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af,\n                    &((struct sockaddr_in *)sock_addr)->sin_addr,\n                    addr_text,\n                    sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n        case AF_INET6:\n            addr_text[0] = '[';\n            addr_text[1] = '\\0';\n            if (inet_ntop(af,\n                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,\n                    addr_text + 1,\n                    sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n        case AF_UNIX:\n            strncpy(addr_text,\n                    ((struct sockaddr_un *)sock_addr)->sun_path,\n                    sizeof(addr_text) - 1);\n            addr_text[sizeof(addr_text)-1] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n    if (strlen(addr_text) < 2) {\n        sprintf(addr_text, \"<AF %d>\", af);\n    }\n    if (port) {\n        sprintf(addr, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        sprintf(addr, \"%s:%s\", protoname, addr_text);\n    }\n}", "target": 1}
{"code": "static RBinWasmElementEntry *parse_element_entry(RBinWasmObj *bin, ut64 bound, ut32 index) {\n\tRBuffer *b = bin->buf;\n\tRBinWasmElementEntry *elem = R_NEW0 (RBinWasmElementEntry);\n\tif (elem) {\n\t\telem->sec_i = index;\n\t\telem->file_offset = r_buf_tell (b);\n\t\tif (!consume_u32_r (b, bound, &elem->index)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_init_expr_r (b, bound, R_BIN_WASM_END_OF_CODE, NULL)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_u32_r (b, bound, &elem->num_elem)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tut32 j = 0;\n\t\twhile (r_buf_tell (b) <= bound && j < elem->num_elem) {\n\t\t\tif (!consume_u32_r (b, bound, NULL)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t}\n\treturn elem;\nbeach:\n\tfree (elem);\n\treturn NULL;\n}", "target": 0}
{"code": "rdp_enum_bmpcache2(void)\n{\n\tSTREAM s;\n\tHASH_KEY keylist[BMPCACHE2_NUM_PSTCELLS];\n\tuint32 num_keys, offset, count, flags;\n\toffset = 0;\n\tnum_keys = pstcache_enumerate(2, keylist);\n\twhile (offset < num_keys)\n\t{\n\t\tcount = MIN(num_keys - offset, 169);\n\t\ts = rdp_init_data(24 + count * sizeof(HASH_KEY));\n\t\tflags = 0;\n\t\tif (offset == 0)\n\t\t\tflags |= PDU_FLAG_FIRST;\n\t\tif (num_keys - offset <= 169)\n\t\t\tflags |= PDU_FLAG_LAST;\n\t\tout_uint32_le(s, 0);\n\t\tout_uint16_le(s, count);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, num_keys);\n\t\tout_uint32_le(s, 0);\n\t\tout_uint32_le(s, flags);\n\t\tout_uint8a(s, keylist[offset], count * sizeof(HASH_KEY));\n\t\ts_mark_end(s);\n\t\trdp_send_data(s, 0x2b);\n\t\toffset += 169;\n\t}\n}", "target": 0}
{"code": "spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}", "target": 1}
{"code": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tr = -ENOMEM;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\tif (svm_sev_enabled()) {\n\t\tr = -ENOMEM;\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto err_1;\n\t}\n\tper_cpu(svm_data, cpu) = sd;\n\treturn 0;\nerr_1:\n\tkfree(sd);\n\treturn r;\n}", "target": 1}
{"code": "int nsim_bpf(struct net_device *dev, struct netdev_bpf *bpf)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tint err;\n\tASSERT_RTNL();\n\tswitch (bpf->command) {\n\tcase XDP_SETUP_PROG:\n\t\terr = nsim_setup_prog_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp);\n\tcase XDP_SETUP_PROG_HW:\n\t\terr = nsim_setup_prog_hw_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp_hw);\n\tcase BPF_OFFLOAD_MAP_ALLOC:\n\t\tif (!ns->bpf_map_accept)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn nsim_bpf_map_alloc(ns, bpf->offmap);\n\tcase BPF_OFFLOAD_MAP_FREE:\n\t\tnsim_bpf_map_free(bpf->offmap);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "int git_treebuilder_create(git_treebuilder **builder_p, const git_tree *source)\n{\n\tgit_treebuilder *bld;\n\tsize_t i, source_entries = DEFAULT_TREE_SIZE;\n\tassert(builder_p);\n\tbld = git__calloc(1, sizeof(git_treebuilder));\n\tGITERR_CHECK_ALLOC(bld);\n\tif (source != NULL)\n\t\tsource_entries = source->entries.length;\n\tif (git_vector_init(&bld->entries, source_entries, entry_sort_cmp) < 0)\n\t\tgoto on_error;\n\tif (source != NULL) {\n\t\tgit_tree_entry *entry_src;\n\t\tgit_vector_foreach(&source->entries, i, entry_src) {\n\t\t\tif (append_entry(\n\t\t\t\tbld, entry_src->filename,\n\t\t\t\t&entry_src->oid,\n\t\t\t\tentry_src->attr) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\t*builder_p = bld;\n\treturn 0;\non_error:\n\tgit_treebuilder_free(bld);\n\treturn -1;\n}", "target": 0}
{"code": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}", "target": 1}
{"code": "static int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n    stellaris_enet_reset(s);\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n                    stellaris_enet_save, stellaris_enet_load, s);\n    return 0;\n}", "target": 1}
{"code": "zzip_dir_fdopen_ext_io(int fd, zzip_error_t * errcode_p,\n                       zzip_strings_t * ext, const zzip_plugin_io_t io)\n{\n    zzip_error_t rv;\n    ZZIP_DIR *dir;\n    if ((dir = zzip_dir_alloc_ext_io(ext, io)) == NULL)\n        { rv = ZZIP_OUTOFMEM; goto error; }\n    dir->fd = fd;\n    if ((rv = __zzip_dir_parse(dir)))\n        goto error;\n    dir->hdr = dir->hdr0;\n    dir->refcount |= 0x10000000;\n    if (errcode_p)\n        *errcode_p = rv;\n    return dir;\n  error:\n    if (dir)\n        zzip_dir_free(dir);\n    if (errcode_p)\n        *errcode_p = rv;\n    return NULL;\n}", "target": 0}
{"code": "static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds out;\n\t\tmemset(&out, 0, sizeof(out));\n\t\tipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);\n\t\tout.shm_segsz\t= in->shm_segsz;\n\t\tout.shm_atime\t= in->shm_atime;\n\t\tout.shm_dtime\t= in->shm_dtime;\n\t\tout.shm_ctime\t= in->shm_ctime;\n\t\tout.shm_cpid\t= in->shm_cpid;\n\t\tout.shm_lpid\t= in->shm_lpid;\n\t\tout.shm_nattch\t= in->shm_nattch;\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "int __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL);\n}", "target": 1}
{"code": "const char *who_am_i(void)\n{\n\tif (am_starting_up)\n\t\treturn am_server ? \"server\" : \"client\";\n\treturn am_sender ? \"sender\"\n\t     : am_generator ? \"generator\"\n\t     : am_receiver ? \"receiver\"\n\t     : \"Receiver\"; \n}", "target": 0}
{"code": "static WERROR dcesrv_DnssrvComplexOperation(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct DnssrvComplexOperation *r)\n{\n\tstruct dnsserver_state *dsstate;\n\tstruct dnsserver_zone *z;\n\tWERROR ret;\n\tZERO_STRUCTP(r->out.pdwTypeOut);\n\tZERO_STRUCTP(r->out.ppDataOut);\n\tif ((dsstate = dnsserver_connect(dce_call)) == NULL) {\n\t\treturn WERR_DNS_ERROR_DS_UNAVAILABLE;\n\t}\n\tif (r->in.pszZone == NULL) {\n\t\tret = dnsserver_complex_operate_server(dsstate, mem_ctx,\n\t\t\t\t\t\t\tr->in.pszOperation,\n\t\t\t\t\t\t\tDNS_CLIENT_VERSION_W2K,\n\t\t\t\t\t\t\tr->in.dwTypeIn,\n\t\t\t\t\t\t\t&r->in.pDataIn,\n\t\t\t\t\t\t\tr->out.pdwTypeOut,\n\t\t\t\t\t\t\tr->out.ppDataOut);\n\t} else {\n\t\tz = dnsserver_find_zone(dsstate->zones, r->in.pszZone);\n\t\tif (z == NULL) {\n\t\t\treturn WERR_DNS_ERROR_ZONE_DOES_NOT_EXIST;\n\t\t}\n\t\tret = dnsserver_complex_operate_zone(dsstate, mem_ctx, z,\n\t\t\t\t\t\t\tr->in.pszOperation,\n\t\t\t\t\t\t\tDNS_CLIENT_VERSION_W2K,\n\t\t\t\t\t\t\tr->in.dwTypeIn,\n\t\t\t\t\t\t\t&r->in.pDataIn,\n\t\t\t\t\t\t\tr->out.pdwTypeOut,\n\t\t\t\t\t\t\tr->out.ppDataOut);\n\t}\n\tif (W_ERROR_EQUAL(ret, WERR_CALL_NOT_IMPLEMENTED)) {\n\t\tNDR_PRINT_FUNCTION_DEBUG(DnssrvComplexOperation, NDR_IN, r);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "buflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  \n{\n    char_u\t*match;\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n    return match;\n}", "target": 1}
{"code": "static void mctp_serial_uninit(struct net_device *ndev)\n{\n\tstruct mctp_serial *dev = netdev_priv(ndev);\n\tcancel_work_sync(&dev->tx_work);\n}", "target": 0}
{"code": "\tvirtual const char *name() const { return \"sign\"; }", "target": 0}
{"code": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\t__pipe_lock(pipe);\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}", "target": 0}
{"code": "static ssize_t read_kmem(struct file *file, char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\tssize_t low_count, read, sz;\n\tchar *kbuf; \n\tint err = 0;\n\tread = 0;\n\tif (p < (unsigned long) high_memory) {\n\t\tlow_count = count;\n\t\tif (count > (unsigned long)high_memory - p)\n\t\t\tlow_count = (unsigned long)high_memory - p;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t\tif (p < PAGE_SIZE && low_count > 0) {\n\t\t\tsz = size_inside_page(p, low_count);\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tread += sz;\n\t\t\tlow_count -= sz;\n\t\t\tcount -= sz;\n\t\t}\n#endif\n\t\twhile (low_count > 0) {\n\t\t\tsz = size_inside_page(p, low_count);\n\t\t\tkbuf = xlate_dev_kmem_ptr((void *)p);\n\t\t\tif (!virt_addr_valid(kbuf))\n\t\t\t\treturn -ENXIO;\n\t\t\tif (copy_to_user(buf, kbuf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tread += sz;\n\t\t\tlow_count -= sz;\n\t\t\tcount -= sz;\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tkbuf = (char *)__get_free_page(GFP_KERNEL);\n\t\tif (!kbuf)\n\t\t\treturn -ENOMEM;\n\t\twhile (count > 0) {\n\t\t\tsz = size_inside_page(p, count);\n\t\t\tif (!is_vmalloc_or_module_addr((void *)p)) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsz = vread(kbuf, (char *)p, sz);\n\t\t\tif (!sz)\n\t\t\t\tbreak;\n\t\t\tif (copy_to_user(buf, kbuf, sz)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= sz;\n\t\t\tbuf += sz;\n\t\t\tread += sz;\n\t\t\tp += sz;\n\t\t}\n\t\tfree_page((unsigned long)kbuf);\n\t}\n\t*ppos = p;\n\treturn read ? read : err;\n}", "target": 0}
{"code": "ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b;\n\tint r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (state->compression_in_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n\t\t    sizeof(state->compression_in_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tif (state->compression_out_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n\t\t    sizeof(state->compression_out_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "init_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "int ff_init_buffer_info(AVCodecContext *avctx, AVFrame *frame)\n{\n    if (avctx->internal->pkt) {\n        frame->pkt_pts = avctx->internal->pkt->pts;\n        av_frame_set_pkt_pos     (frame, avctx->internal->pkt->pos);\n        av_frame_set_pkt_duration(frame, avctx->internal->pkt->duration);\n        av_frame_set_pkt_size    (frame, avctx->internal->pkt->size);\n    } else {\n        frame->pkt_pts = AV_NOPTS_VALUE;\n        av_frame_set_pkt_pos     (frame, -1);\n        av_frame_set_pkt_duration(frame, 0);\n        av_frame_set_pkt_size    (frame, -1);\n    }\n    frame->reordered_opaque = avctx->reordered_opaque;\n    switch (avctx->codec->type) {\n    case AVMEDIA_TYPE_VIDEO:\n        frame->format              = avctx->pix_fmt;\n        if (!frame->sample_aspect_ratio.num)\n            frame->sample_aspect_ratio = avctx->sample_aspect_ratio;\n        if (av_frame_get_colorspace(frame) == AVCOL_SPC_UNSPECIFIED)\n            av_frame_set_colorspace(frame, avctx->colorspace);\n        if (av_frame_get_color_range(frame) == AVCOL_RANGE_UNSPECIFIED)\n            av_frame_set_color_range(frame, avctx->color_range);\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        if (!frame->sample_rate)\n            frame->sample_rate    = avctx->sample_rate;\n        if (frame->format < 0)\n            frame->format         = avctx->sample_fmt;\n        if (!frame->channel_layout) {\n            if (avctx->channel_layout) {\n                 if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=\n                     avctx->channels) {\n                     av_log(avctx, AV_LOG_ERROR, \"Inconsistent channel \"\n                            \"configuration.\\n\");\n                     return AVERROR(EINVAL);\n                 }\n                frame->channel_layout = avctx->channel_layout;\n            } else {\n                if (avctx->channels > FF_SANE_NB_CHANNELS) {\n                    av_log(avctx, AV_LOG_ERROR, \"Too many channels: %d.\\n\",\n                           avctx->channels);\n                    return AVERROR(ENOSYS);\n                }\n            }\n        }\n        av_frame_set_channels(frame, avctx->channels);\n        break;\n    }\n    return 0;\n}", "target": 0}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tfmode_t fmode,\n\t\t\t\t\tint flags,\n\t\t\t\t\tstruct iattr *sattr,\n\t\t\t\t\tstruct rpc_cred *cred,\n\t\t\t\t\tstruct nfs4_threshold **ctx_th)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tfmode &= FMODE_READ|FMODE_WRITE|FMODE_EXEC;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, dentry, fmode, flags, sattr, cred,\n\t\t\t\t       &res, ctx_th);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 0}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n        dyn_table_size = 0;\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 0}
{"code": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "    bool wc2mb(UINT cp, std::string& str)\n    {\n        if (str.empty())\n            return true;\n        if (str.size() & 1) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Size \" << str.size() << \" of input string is not even.\\n\";\n#endif\n            return false;\n        }\n        int len = WideCharToMultiByte(cp, 0, (LPCWSTR)str.data(), (int)str.size() / 2, 0, 0, 0, 0);\n        if (len == 0) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Failed to determine required size of output buffer.\\n\";\n#endif\n            return false;\n        }\n        std::vector<std::string::value_type> out;\n        out.reserve(len);\n        int ret = WideCharToMultiByte(cp, 0, (LPCWSTR)str.data(), (int)str.size() / 2, (LPSTR)out.data(), len, 0, 0);\n        if (ret == 0) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Failed to convert the input string to a multi byte string.\\n\";\n#endif\n            return false;\n        }\n        str.assign(out.data(), static_cast<size_t>(len));\n        return true;\n    }", "target": 0}
{"code": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\t*num_xfrms = pols[0]->xfrm_nr;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\tfor (i = 0; i < refs.count; ++i) {\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\t\tgit_reference_free(ref);\n\t}\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}", "target": 0}
{"code": "int compat_dccp_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int optlen)\n{\n\tif (level != SOL_DCCP)\n\t\treturn inet_csk_compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t  optval, optlen);\n\treturn do_dccp_setsockopt(sk, level, optname, optval, optlen);\n}", "target": 0}
{"code": "std::string Utf16ToUtf8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 1}
{"code": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  mutt_message(_(\"Logging in...\"));\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n  if (!rc)\n  {\n    mutt_clear_error(); \n    return IMAP_AUTH_SUCCESS;\n  }\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 1}
{"code": "    int RafImage::pixelWidth() const\n    {\n        Exiv2::ExifData::const_iterator widthIter = exifData_.findKey(Exiv2::ExifKey(\"Exif.Photo.PixelXDimension\"));\n        if (widthIter != exifData_.end() && widthIter->count() > 0) {\n            return widthIter->toLong();\n        }\n        return 0;\n    }", "target": 0}
{"code": "static char *ptr_to_id(char *buf, char *end, void *ptr, struct printf_spec spec)\n{\n\tunsigned long hashval;\n\tif (unlikely(!have_filled_random_ptr_key)) {\n\t\tspec.field_width = 2 * sizeof(ptr);\n\t\treturn string(buf, end, \"(ptrval)\", spec);\n\t}\n#ifdef CONFIG_64BIT\n\thashval = (unsigned long)siphash_1u64((u64)ptr, &ptr_key);\n\thashval = hashval & 0xffffffff;\n#else\n\thashval = (unsigned long)siphash_1u32((u32)ptr, &ptr_key);\n#endif\n\treturn pointer_string(buf, end, (const void *)hashval, spec);\n}", "target": 1}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "pf_remove_divert_state(struct pf_state_key *sk)\n{\n\tstruct pf_state_item\t*si;\n\tPF_ASSERT_UNLOCKED();\n\tPF_LOCK();\n\tPF_STATE_ENTER_WRITE();\n\tTAILQ_FOREACH(si, &sk->sk_states, si_entry) {\n\t\tstruct pf_state *sist = si->si_st;\n\t\tif (sk == sist->key[PF_SK_STACK] && sist->rule.ptr &&\n\t\t    (sist->rule.ptr->divert.type == PF_DIVERT_TO ||\n\t\t     sist->rule.ptr->divert.type == PF_DIVERT_REPLY)) {\n\t\t\tif (sist->key[PF_SK_STACK]->proto == IPPROTO_TCP &&\n\t\t\t    sist->key[PF_SK_WIRE] != sist->key[PF_SK_STACK]) {\n\t\t\t\tif (sist->src.state < TCPS_FIN_WAIT_2 ||\n\t\t\t\t    sist->dst.state < TCPS_FIN_WAIT_2) {\n\t\t\t\t\tpf_set_protostate(sist, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_TIME_WAIT);\n\t\t\t\t\tsist->timeout = PFTM_TCP_CLOSED;\n\t\t\t\t\tsist->expire = getuptime();\n\t\t\t\t}\n\t\t\t\tsist->state_flags |= PFSTATE_INP_UNLINKED;\n\t\t\t} else\n\t\t\t\tpf_remove_state(sist);\n\t\t\tbreak;\n\t\t}\n\t}\n\tPF_STATE_EXIT_WRITE();\n\tPF_UNLOCK();\n}", "target": 1}
{"code": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\task->private = ctx;\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\tsk->sk_destruct = skcipher_sock_destruct;\n\treturn 0;\n}", "target": 1}
{"code": "static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}", "target": 1}
{"code": "bool ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return false;\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return false;\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return false;\n  }\n  CHECK_EQ(1, outputs.size());\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return false;\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return false;\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return false;\n  }\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n  return shape.IsCompatibleWith(new_dims);\n}", "target": 1}
{"code": "find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, \n\t\t                         FE_REALLY_INTERNAL | flags ));\n}", "target": 1}
{"code": "static int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tint len, i, rc = 0;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (strcmp(addr->sx25_addr.x25_addr, null_x25_address.x25_addr)) {\n\t\tlen = strlen(addr->sx25_addr.x25_addr);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!isdigit(addr->sx25_addr.x25_addr[i])) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\tx25_sk(sk)->source_addr = addr->sx25_addr;\n\t\tx25_insert_socket(sk);\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\trelease_sock(sk);\n\tSOCK_DEBUG(sk, \"x25_bind: socket is bound\\n\");\nout:\n\treturn rc;\n}", "target": 0}
{"code": "ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext, u_int item_len _U_,\n\t\tconst u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\treturn NULL;\n}", "target": 0}
{"code": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\treturn id;\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "static Jsi_RC DebugAddCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash)\n        interp->breakpointHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    int argc = Jsi_ValueGetLength(interp, args);\n    jsi_BreakPoint *bptr, bp = {};\n    Jsi_Number vnum;\n    if (argc>1 && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, 1), &bp.temp) != JSI_OK) \n        return Jsi_LogError(\"bad boolean\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueGetNumber(interp, v, &vnum) == JSI_OK) {\n        bp.line = (int)vnum;\n        bp.file = interp->curFile;\n    } else {\n        const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n        const char *cp;\n        if (isdigit(val[0])) {\n            if (Jsi_GetInt(interp, val, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            bp.file = interp->curFile;\n        } else if ((cp = Jsi_Strchr(val, ':'))) {\n            if (Jsi_GetInt(interp, cp+1, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            Jsi_DString dStr = {};\n            Jsi_DSAppendLen(&dStr, val, cp-val);\n            bp.file = Jsi_KeyAdd(interp, Jsi_DSValue(&dStr));\n            Jsi_DSFree(&dStr);\n        } else {\n            bp.func = Jsi_KeyAdd(interp, val);\n        }\n    }\n    if (bp.line<=0 && !bp.func) \n        return Jsi_LogError(\"bad number\");\n    char nbuf[100];\n    bp.id = ++interp->debugOpts.breakIdx;\n    bp.enabled = 1;\n    snprintf(nbuf, sizeof(nbuf), \"%d\", bp.id);\n    bptr = (jsi_BreakPoint*)Jsi_Malloc(sizeof(*bptr));\n    *bptr = bp;\n    Jsi_HashSet(interp->breakpointHash, (void*)nbuf, bptr);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)bp.id);\n    return JSI_OK;\n}", "target": 1}
{"code": "extractDirName(const StaticString &path) {\n\tchar *path_copy = strdup(path.c_str());\n\tchar *result = dirname(path_copy);\n\tstring result_string(result);\n\tfree(path_copy);\n\treturn result_string;\n}", "target": 0}
{"code": "  void GetCachedOrigins(StorageType type, std::set<GURL>* origins) {\n    ASSERT_TRUE(origins != NULL);\n    origins->clear();\n    quota_manager_->GetCachedOrigins(type, origins);\n  }", "target": 0}
{"code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "target": 1}
{"code": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup\");\n\treturn 0;\n}", "target": 1}
{"code": "shiftAnchorPosition(AnchorList *al, HmarkerList *hl, int line, int pos,\n\t\t    int shift)\n{\n    Anchor *a;\n    size_t b, e, s = 0;\n    int cmp;\n    if (al == NULL || al->nanchor == 0)\n\treturn;\n    s = al->nanchor / 2;\n    for (b = 0, e = al->nanchor - 1; b <= e; s = (b + e + 1) / 2) {\n\ta = &al->anchors[s];\n\tcmp = onAnchor(a, line, pos);\n\tif (cmp == 0)\n\t    break;\n\telse if (cmp > 0)\n\t    b = s + 1;\n\telse if (s == 0)\n\t    break;\n\telse\n\t    e = s - 1;\n    }\n    for (; s < al->nanchor; s++) {\n\ta = &al->anchors[s];\n\tif (a->start.line > line)\n\t    break;\n\tif (a->start.pos > pos) {\n\t    a->start.pos += shift;\n\t    if (hl->marks[a->hseq].line == line)\n\t\thl->marks[a->hseq].pos = a->start.pos;\n\t}\n\tif (a->end.pos >= pos)\n\t    a->end.pos += shift;\n    }\n}", "target": 1}
{"code": "size_t ring_buffer_page_len(void *page)\n{\n\treturn local_read(&((struct buffer_data_page *)page)->commit)\n\t\t+ BUF_PAGE_HDR_SIZE;\n}", "target": 0}
{"code": "make_outerjoin_info(JOIN *join)\n{\n  DBUG_ENTER(\"make_outerjoin_info\");\n  JOIN_TAB *tab;\n  for (tab= first_linear_tab(join, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab; \n       tab= next_linear_tab(join, tab, WITH_BUSH_ROOTS))\n  {\n    if (tab->bush_children)\n    {\n      if (setup_sj_materialization_part1(tab))\n        DBUG_RETURN(TRUE);\n      tab->table->reginfo.join_tab= tab;\n    }\n  }\n  for (tab= first_linear_tab(join, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab; \n       tab= next_linear_tab(join, tab, WITH_BUSH_ROOTS))\n  {\n    TABLE *table= tab->table;\n    TABLE_LIST *tbl= table->pos_in_table_list;\n    TABLE_LIST *embedding= tbl->embedding;\n    if (tbl->outer_join & (JOIN_TYPE_LEFT | JOIN_TYPE_RIGHT))\n    {\n      tab->last_inner= tab->first_inner= tab;\n      tab->on_expr_ref= &tbl->on_expr;\n      tab->cond_equal= tbl->cond_equal;\n      if (embedding && !embedding->is_active_sjm())\n        tab->first_upper= embedding->nested_join->first_nested;\n    }\n    else if (!embedding)\n      tab->table->reginfo.not_exists_optimize= 0;\n    for ( ; embedding ; embedding= embedding->embedding)\n    {\n      if (embedding->is_active_sjm())\n      {\n        break;\n      }\n      if (!(embedding->on_expr && embedding->outer_join))\n      {\n        tab->table->reginfo.not_exists_optimize= 0;\n        continue;\n      }\n      NESTED_JOIN *nested_join= embedding->nested_join;\n      if (!nested_join->counter)\n      {\n        nested_join->first_nested= tab;\n        tab->on_expr_ref= &embedding->on_expr;\n        tab->cond_equal= tbl->cond_equal;\n        if (embedding->embedding)\n          tab->first_upper= embedding->embedding->nested_join->first_nested;\n      }\n      if (!tab->first_inner)  \n        tab->first_inner= nested_join->first_nested;\n      if (++nested_join->counter < nested_join->n_tables)\n        break;\n      nested_join->first_nested->last_inner= tab;\n    }\n  }\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)\n{\n\tint ret;\n\tsigset_t sigsaved;\n\tif (unlikely(vcpu->arch.target < 0))\n\t\treturn -ENOEXEC;\n\tret = kvm_vcpu_first_run_init(vcpu);\n\tif (ret)\n\t\treturn ret;\n\tif (run->exit_reason == KVM_EXIT_MMIO) {\n\t\tret = kvm_handle_mmio_return(vcpu, vcpu->run);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\tret = 1;\n\trun->exit_reason = KVM_EXIT_UNKNOWN;\n\twhile (ret > 0) {\n\t\tcond_resched();\n\t\tupdate_vttbr(vcpu->kvm);\n\t\tif (vcpu->arch.pause)\n\t\t\tvcpu_pause(vcpu);\n\t\tkvm_vgic_flush_hwstate(vcpu);\n\t\tkvm_timer_flush_hwstate(vcpu);\n\t\tlocal_irq_disable();\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\trun->exit_reason = KVM_EXIT_INTR;\n\t\t}\n\t\tif (ret <= 0 || need_new_vmid_gen(vcpu->kvm)) {\n\t\t\tlocal_irq_enable();\n\t\t\tkvm_timer_sync_hwstate(vcpu);\n\t\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_kvm_entry(*vcpu_pc(vcpu));\n\t\tkvm_guest_enter();\n\t\tvcpu->mode = IN_GUEST_MODE;\n\t\tret = kvm_call_hyp(__kvm_vcpu_run, vcpu);\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tvcpu->arch.last_pcpu = smp_processor_id();\n\t\tkvm_guest_exit();\n\t\ttrace_kvm_exit(*vcpu_pc(vcpu));\n\t\tlocal_irq_enable();\n\t\tkvm_timer_sync_hwstate(vcpu);\n\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\tret = handle_exit(vcpu, run, ret);\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\treturn ret;\n}", "target": 1}
{"code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }", "target": 1}
{"code": "static inline pmd_t pmd_mknuma(pmd_t pmd)\n{\n\treturn pmd;\n}", "target": 0}
{"code": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n\tstruct rtable *rt;\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\treturn 0;\n}", "target": 1}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"xreader-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 1}
{"code": "static ssize_t show_rxbuf(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", NET_RX_RING_SIZE);\n}", "target": 0}
{"code": "    bool load_face(Face & face, unsigned int options)\n    {\n#ifdef GRAPHITE2_TELEMETRY\n        telemetry::category _misc_cat(face.tele.misc);\n#endif\n        Face::Table silf(face, Tag::Silf, 0x00050000);\n        if (silf)   options &= ~gr_face_dumbRendering;\n        else if (!(options &  gr_face_dumbRendering))\n            return false;\n        if (!face.readGlyphs(options))\n            return false;\n        if (silf)\n        {\n            if (!face.readFeatures() || !face.readGraphite(silf))\n            {\n#if !defined GRAPHITE2_NTRACING\n                if (global_log)\n                {\n                    *global_log << json::object\n                        << \"type\" << \"fontload\"\n                        << \"failure\" << face.error()\n                        << \"context\" << face.error_context()\n                    << json::close;\n                }\n#endif\n                return false;\n            }\n            else\n                return true;\n        }\n        else\n            return options & gr_face_dumbRendering;\n    }", "target": 1}
{"code": "resolve_fstab_device (guestfs_h *g, const char *spec, Hash_table *md_map)\n{\n  char *device = NULL;\n  char *type, *slice, *disk, *part;\n  int r;\n  if (STRPREFIX (spec, \"/dev/mapper/\") && guestfs_exists (g, spec) > 0) {\n    device = guestfs_lvm_canonical_lv_name (g, spec);\n  }\n  else if (match3 (g, spec, re_xdev, &type, &disk, &part)) {\n    r = resolve_fstab_device_xdev (g, type, disk, part, &device);\n    free (type);\n    free (disk);\n    free (part);\n    if (r == -1)\n      return NULL;\n  }\n  else if (match2 (g, spec, re_cciss, &disk, &part)) {\n    r = resolve_fstab_device_cciss (g, disk, part, &device);\n    free (disk);\n    free (part);\n    if (r == -1)\n      return NULL;\n  }\n  else if (md_map && (disk = match1 (g, spec, re_mdN)) != NULL) {\n    mdadm_app entry;\n    entry.mdadm = disk;\n    mdadm_app *app = hash_lookup (md_map, &entry);\n    if (app) device = safe_strdup (g, app->app);\n    free (disk);\n  }\n  else if (match3 (g, spec, re_freebsd, &disk, &slice, &part)) {\n    int disk_i = guestfs___parse_unsigned_int (g, disk);\n    int slice_i = guestfs___parse_unsigned_int (g, slice);\n    int part_i = part[0] - 'a' ;\n    free (disk);\n    free (slice);\n    free (part);\n    if (disk_i != -1 && disk_i <= 26 &&\n        slice_i > 0 && slice_i <= 1  &&\n        part_i >= 0 && part_i < 26) {\n      device = safe_asprintf (g, \"/dev/sd%c%d\", disk_i + 'a', part_i + 5);\n    }\n  }\n  else if ((part = match1 (g, spec, re_diskbyid)) != NULL) {\n    r = resolve_fstab_device_diskbyid (g, part, &device);\n    free (part);\n    if (r == -1)\n      return NULL;\n  }\n  if (device == NULL)\n    device = safe_strdup (g, spec);\n  return device;\n}", "target": 0}
{"code": "int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\tpvclock_update_vm_gtod_copy(kvm);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);\n\treturn 0;\n}", "target": 0}
{"code": "_SSL_match_hostname (const char *cert_hostname, const char *hostname)\n{\n\tconst char *cert_domain, *domain, *next_dot;\n\tif (g_ascii_strcasecmp (cert_hostname, hostname) == 0)\n\t\treturn 0;\n\tif (cert_hostname[0] == '*')\n\t{\n\t\tcert_domain = &cert_hostname[1];\n\t\tif (cert_domain[0] == '\\0')\n\t\t\treturn -1;\n\t\tif (cert_domain[0] != '.')\n\t\t\treturn -1;\n\t\tif (cert_domain[1] == '.')\n\t\t\treturn -1;\n\t\tnext_dot = strchr (&cert_domain[1], '.');\n\t\tif (next_dot == NULL)\n\t\t\treturn -1;\n\t\tif (next_dot[1] == '.')\n\t\t\treturn -1;\n\t\tdomain = strchr (hostname, '.');\n\t\tif (domain == NULL || strlen(domain) == 1)\n\t\t\treturn -1;\n\t\tif (g_ascii_strcasecmp (cert_domain, domain) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "void RGWListMultipart_ObjStore_S3::send_response()\n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this, \"application/xml\", CHUNKED_TRANSFER_ENCODING);\n  if (op_ret == 0) {\n    dump_start(s);\n    s->formatter->open_object_section_in_ns(\"ListPartsResult\", XMLNS_AWS_S3);\n    map<uint32_t, RGWUploadPartInfo>::iterator iter;\n    map<uint32_t, RGWUploadPartInfo>::reverse_iterator test_iter;\n    int cur_max = 0;\n    iter = parts.begin();\n    test_iter = parts.rbegin();\n    if (test_iter != parts.rend()) {\n      cur_max = test_iter->first;\n    }\n    if (!s->bucket_tenant.empty())\n      s->formatter->dump_string(\"Tenant\", s->bucket_tenant);\n    s->formatter->dump_string(\"Bucket\", s->bucket_name);\n    s->formatter->dump_string(\"Key\", s->object.name);\n    s->formatter->dump_string(\"UploadId\", upload_id);\n    s->formatter->dump_string(\"StorageClass\", \"STANDARD\");\n    s->formatter->dump_int(\"PartNumberMarker\", marker);\n    s->formatter->dump_int(\"NextPartNumberMarker\", cur_max);\n    s->formatter->dump_int(\"MaxParts\", max_parts);\n    s->formatter->dump_string(\"IsTruncated\", (truncated ? \"true\" : \"false\"));\n    ACLOwner& owner = policy.get_owner();\n    dump_owner(s, owner.get_id(), owner.get_display_name());\n    for (; iter != parts.end(); ++iter) {\n      RGWUploadPartInfo& info = iter->second;\n      s->formatter->open_object_section(\"Part\");\n      dump_time(s, \"LastModified\", &info.modified);\n      s->formatter->dump_unsigned(\"PartNumber\", info.num);\n      s->formatter->dump_format(\"ETag\", \"\\\"%s\\\"\", info.etag.c_str());\n      s->formatter->dump_unsigned(\"Size\", info.accounted_size);\n      s->formatter->close_section();\n    }\n    s->formatter->close_section();\n    rgw_flush_formatter_and_reset(s, s->formatter);\n  }\n}", "target": 0}
{"code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 1}
{"code": "static void test_simple()\n{\n    json_set_alloc_funcs(my_malloc, my_free);\n    create_and_free_complex_object();\n    if(malloc_called != 20 || free_called != 20)\n        fail(\"Custom allocation failed\");\n}", "target": 1}
{"code": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;", "target": 1}
{"code": "bool SimplifiedBackwardsTextIterator::handleTextNode()\n{\n    m_lastTextNode = m_node;\n    int startOffset;\n    int offsetInNode;\n    RenderText* renderer = handleFirstLetter(startOffset, offsetInNode);\n    if (!renderer)\n        return true;\n    String text = renderer->text();\n    if (!renderer->firstTextBox() && text.length() > 0)\n        return true;\n    m_positionEndOffset = m_offset;\n    m_offset = startOffset + offsetInNode;\n    m_positionNode = m_node;\n    m_positionStartOffset = m_offset;\n    ASSERT(0 <= m_positionStartOffset - offsetInNode && m_positionStartOffset - offsetInNode <= static_cast<int>(text.length()));\n    ASSERT(1 <= m_positionEndOffset - offsetInNode && m_positionEndOffset - offsetInNode <= static_cast<int>(text.length()));\n    ASSERT(m_positionStartOffset <= m_positionEndOffset);\n     m_textLength = m_positionEndOffset - m_positionStartOffset;\n     m_textCharacters = text.characters() + (m_positionStartOffset - offsetInNode);\n     ASSERT(m_textCharacters >= text.characters());\n    ASSERT(m_textCharacters + m_textLength <= text.characters() + static_cast<int>(text.length()));\n     m_lastCharacter = text[m_positionEndOffset - 1];\n    return !m_shouldHandleFirstLetter;\n}", "target": 1}
{"code": "static int decode_attr_maxname(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *maxname)\n{\n\t__be32 *p;\n\tint status = 0;\n\t*maxname = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXNAME - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXNAME)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\t*maxname = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXNAME;\n\t}\n\tdprintk(\"%s: maxname=%u\\n\", __func__, *maxname);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "static ssize_t ext4_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tloff_t offset = iocb->ki_pos;\n\tssize_t ret;\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tif (ext4_encrypted_inode(inode) && S_ISREG(inode->i_mode))\n\t\treturn 0;\n#endif\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\tif (WARN_ON_ONCE(IS_DAX(inode)))\n\t\treturn 0;\n\ttrace_ext4_direct_IO_enter(inode, offset, count, iov_iter_rw(iter));\n\tif (iov_iter_rw(iter) == READ)\n\t\tret = ext4_direct_IO_read(iocb, iter);\n\telse\n\t\tret = ext4_direct_IO_write(iocb, iter);\n\ttrace_ext4_direct_IO_exit(inode, offset, count, iov_iter_rw(iter), ret);\n\treturn ret;\n}", "target": 0}
{"code": "static int decode_attr_fsid(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_fsid *fsid)\n{\n\t__be32 *p;\n\tint ret = 0;\n\tfsid->major = 0;\n\tfsid->minor = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FSID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FSID)) {\n\t\tp = xdr_inline_decode(xdr, 16);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\tp = xdr_decode_hyper(p, &fsid->major);\n\t\txdr_decode_hyper(p, &fsid->minor);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FSID;\n\t\tret = NFS_ATTR_FATTR_FSID;\n\t}\n\tdprintk(\"%s: fsid=(0x%Lx/0x%Lx)\\n\", __func__,\n\t\t\t(unsigned long long)fsid->major,\n\t\t\t(unsigned long long)fsid->minor);\n\treturn ret;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "static int chdir_to_parent(char *copy, const char **lastp)\n{\n\tchar *tmp;\n\tconst char *parent;\n\tchar buf[65536];\n\tint res;\n\ttmp = strrchr(copy, '/');\n\tif (tmp == NULL || tmp[1] == '\\0') {\n\t\tfprintf(stderr, \"%s: internal error: invalid abs path: <%s>\\n\",\n\t\t\tprogname, copy);\n\t\treturn -1;\n\t}\n\tif (tmp != copy) {\n\t\t*tmp = '\\0';\n\t\tparent = copy;\n\t\t*lastp = tmp + 1;\n\t} else if (tmp[1] != '\\0') {\n\t\t*lastp = tmp + 1;\n\t\tparent = \"/\";\n\t} else {\n\t\t*lastp = \".\";\n\t\tparent = \"/\";\n\t}\n\tres = chdir(parent);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to chdir to %s: %s\\n\",\n\t\t\tprogname, parent, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getcwd(buf, sizeof(buf)) == NULL) {\n\t\tfprintf(stderr, \"%s: failed to obtain current directory: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (strcmp(buf, parent) != 0) {\n\t\tfprintf(stderr, \"%s: mountpoint moved (%s -> %s)\\n\", progname,\n\t\t\tparent, buf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}", "target": 1}
{"code": "static void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    end = (start + len) & (target_ulong)(-1);\n    if (start > end) {\n        return;\n    }\n    tb_invalidate_phys_range(uc, start, end);\n}", "target": 1}
{"code": "int check_directory(struct dir *dir)\n{\n\tint i;\n\tstruct dir_ent *ent;\n\tif(dir->dir_count < 2)\n\t\treturn TRUE;\n\tfor(ent = dir->dirs, i = 0; i < dir->dir_count - 1; ent = ent->next, i++)\n\t\tif(strcmp(ent->name, ent->next->name) >= 0)\n\t\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "void html_url_path(const char *txt)\n{\n\tconst char *t = txt;\n\twhile (t && *t) {\n\t\tunsigned char c = *t;\n\t\tconst char *e = url_escape_table[c];\n\t\tif (e && c != '+' && c != '&') {\n\t\t\thtml_raw(txt, t - txt);\n\t\t\thtml(e);\n\t\t\ttxt = t + 1;\n\t\t}\n\t\tt++;\n\t}\n\tif (t != txt)\n\t\thtml(txt);\n}", "target": 0}
{"code": "BOOL lmtp_transport_entry(transport_instance *tblock, address_item *addr) {return FALSE;}", "target": 0}
{"code": "static int nf_tables_set_notify(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_set *set,\n\t\t\t\tint event, gfp_t gfp_flags)\n{\n\tstruct sk_buff *skb;\n\tu32 portid = ctx->portid;\n\tint err;\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn 0;\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(NLMSG_GOODSIZE, gfp_flags);\n\tif (skb == NULL)\n\t\tgoto err;\n\terr = nf_tables_fill_set(skb, ctx, set, event, 0);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\terr = nfnetlink_send(skb, ctx->net, portid, NFNLGRP_NFTABLES,\n\t\t\t     ctx->report, gfp_flags);\nerr:\n\tif (err < 0)\n\t\tnfnetlink_set_err(ctx->net, portid, NFNLGRP_NFTABLES, err);\n\treturn err;\n}", "target": 0}
{"code": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}", "target": 1}
{"code": "static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\t*nr_segs = *len;\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\t*len = ret;\n\treturn 0;\n}", "target": 1}
{"code": "vmod_append(VRT_CTX, VCL_HEADER hdr, VCL_STRANDS s)\n{\n\tstruct http *hp;\n\tstruct strands st[1];\n\tconst char *p[s->n + 2];\n\tconst char *b;\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tp[0] = hdr->what + 1;\n\tp[1] = \" \";\n\tAN(memcpy(p + 2, s->p, s->n * sizeof *s->p));\n\tst->n = s->n + 2;\n\tst->p = p;\n\tb = VRT_StrandsWS(ctx->ws, NULL, st);\n\thp = VRT_selecthttp(ctx, hdr->where);\n\thttp_SetHeader(hp, b);\n}", "target": 1}
{"code": "void RGWCORSRule::format_exp_headers(string& s) {\n  s = \"\";\n  for(list<string>::iterator it = exposable_hdrs.begin();\n      it != exposable_hdrs.end(); ++it) {\n      if (s.length() > 0)\n        s.append(\",\");\n      s.append((*it));\n  }\n}", "target": 1}
{"code": "static int http_read_header(URLContext *h, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    char line[MAX_URL_SIZE];\n    int err = 0;\n    s->chunksize = -1;\n    for (;;) {\n        if ((err = http_get_line(s, line, sizeof(line))) < 0)\n            return err;\n        av_log(h, AV_LOG_TRACE, \"header='%s'\\n\", line);\n        err = process_line(h, line, s->line_count, new_location);\n        if (err < 0)\n            return err;\n        if (err == 0)\n            break;\n        s->line_count++;\n    }\n    if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)\n        h->is_streamed = 1; \n    cookie_string(s->cookie_dict, &s->cookies);\n    av_dict_free(&s->cookie_dict);\n    return err;\n}", "target": 1}
{"code": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int remaining = s->icy_metaint - s->icy_data_read;\n    if (remaining < 0)\n        return AVERROR_INVALIDDATA;\n    if (!remaining) {\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n    return FFMIN(size, remaining);\n}", "target": 1}
{"code": "static int find_length(struct pdf_struct *pdf,\n\t\t       struct pdf_obj *obj,\n\t\t       const char *start, off_t len)\n{\n    int length;\n    const char *q;\n    q = cli_memstr(start, len, \"/Length\", 7);\n    if (!q)\n\treturn 0;\n    q++;\n    len -= q - start;\n    start = pdf_nextobject(q, len);\n    if (!start)\n\treturn 0;\n    q = start;\n    length = atoi(q);\n    while (isdigit(*q)) q++;\n    if (*q == ' ') {\n\tint genid;\n\tq++;\n\tgenid = atoi(q);\n\twhile(isdigit(*q)) q++;\n\tif (q[0] == ' ' && q[1] == 'R') {\n\t    cli_dbgmsg(\"cli_pdf: length is in indirect object %u %u\\n\", length, genid);\n\t    obj = find_obj(pdf, obj, (length << 8) | (genid&0xff));\n\t    if (!obj) {\n\t\tcli_dbgmsg(\"cli_pdf: indirect object not found\\n\");\n\t\treturn 0;\n\t    }\n\t    q = pdf_nextobject(pdf->map+obj->start, pdf->size - obj->start);\n\t    length = atoi(q);\n\t}\n    }\n    if (start - pdf->map + length+5 > pdf->size) {\n\tlength = pdf->size - (start - pdf->map)-5;\n    }\n    return length;\n}", "target": 0}
{"code": "static void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    *olen = 0;\n    if( ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n        return;\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding renegotiation extension\" ) );\n    if( end < p || (size_t)( end - p ) < 5 + ssl->verify_data_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n    *p++ = 0x00;\n    *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;\n    *p++ = ssl->verify_data_len & 0xFF;\n    memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n    *olen = 5 + ssl->verify_data_len;\n}", "target": 0}
{"code": "static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\tgroup->max_events = max_events;\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.user = user;\n\tgroup->inotify_data.fa = NULL;\n\treturn group;\n}", "target": 1}
{"code": "decode_string(CBORDecoderObject *self, uint8_t subtype)\n{\n    uint64_t length = 0;\n    bool indefinite = true;\n    PyObject *ret;\n    char length_hex[17];\n    if (decode_length(self, subtype, &length, &indefinite) == -1)\n        return NULL;\n    if (length > (uint64_t)PY_SSIZE_T_MAX - (uint64_t)PyBytesObject_SIZE) {\n        sprintf(length_hex, \"%llX\", length);\n        PyErr_Format(\n                _CBOR2_CBORDecodeValueError,\n                \"excessive string size 0x%s\", length_hex);\n        return NULL;\n    }\n    if (indefinite)\n        ret = decode_indefinite_strings(self);\n    else\n        ret = decode_definite_string(self, (Py_ssize_t)length);\n    set_shareable(self, ret);\n    return ret;\n}", "target": 1}
{"code": "static Bigint * Balloc(int k)\n{\n\tint x;\n\tBigint *rv;\n\t_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex);\n\tif ((rv = freelist[k])) {\n\t\tfreelist[k] = rv->next;\n\t} else {\n\t\tx = 1 << k;\n\t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long));\n\t\trv->k = k;\n\t\trv->maxwds = x;\n\t}\n\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\trv->sign = rv->wds = 0;\n\treturn rv;\n}", "target": 1}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "void RenderView::SetContentSettings(const ContentSettings& settings) {\n  current_content_settings_ = settings;\n}", "target": 0}
{"code": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnd->flags &= ~LOOKUP_PARENT;\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n\tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n\t\treturn 1;\n\tfollow_mount(path);\n\terror = 0;\nout:\n\tterminate_walk(nd);\n\treturn error;\n}", "target": 1}
{"code": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n     case blink::WebBackForwardCommit:\n       if (!provisional_entry_)\n         return;\n      current_entry_.reset(provisional_entry_.release());\n       if (HistoryEntry::HistoryNode* node =\n               current_entry_->GetHistoryNodeForFrame(frame)) {\n         node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}", "target": 1}
{"code": "format_versions_list(config_line_t *ln)\n{\n  smartlist_t *versions;\n  char *result;\n  versions = smartlist_new();\n  for ( ; ln; ln = ln->next) {\n    smartlist_split_string(versions, ln->value, \",\",\n                           SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);\n  }\n  sort_version_list(versions, 1);\n  result = smartlist_join_strings(versions,\",\",0,NULL);\n  SMARTLIST_FOREACH(versions,char *,s,tor_free(s));\n  smartlist_free(versions);\n  return result;\n}", "target": 0}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t ifalias_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tconst struct net_device *netdev = to_net_dev(dev);\n\tchar tmp[IFALIASZ];\n\tssize_t ret = 0;\n\tret = dev_get_alias(netdev, tmp, sizeof(tmp));\n\tif (ret > 0)\n\t\tret = sprintf(buf, \"%s\\n\", tmp);\n\treturn ret;", "target": 0}
{"code": "hash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\treturn hash;\n}", "target": 1}
{"code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = Z_SPLDLLIST_P(getThis());\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\t\tindex = spl_offset_convert_to_long(zindex);\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\t\tif (element != NULL) {\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} ", "target": 1}
{"code": "ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\tconst u_char *inblob, *outblob;\n\tsize_t inl, outl;\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n\t\tgoto out;\n\tif (inl == 0)\n\t\tstate->compression_in_started = 0;\n\telse if (inl != sizeof(state->compression_in_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_in_started = 1;\n\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n\t}\n\tif (outl == 0)\n\t\tstate->compression_out_started = 0;\n\telse if (outl != sizeof(state->compression_out_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_out_started = 1;\n\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "static int cenc_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret;\n    int bytes_of_protected_data;\n    if (!sc->cenc.aes_ctr) {\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n    if (!sample->subsample_count) {\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    }\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n        bytes_of_protected_data = sample->subsamples[i].bytes_of_protected_data;\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, bytes_of_protected_data);\n        input += bytes_of_protected_data;\n        size -= bytes_of_protected_data;\n    }\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"code": "int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)\n{\n    EVP_PKEY *pkey;\n    ASN1_IA5STRING *chal;\n    ASN1_OBJECT *spkioid;\n    int i, n;\n    char *s;\n    BIO_printf(out, \"Netscape SPKI:\\n\");\n    X509_PUBKEY_get0_param(&spkioid, NULL, NULL, NULL, spki->spkac->pubkey);\n    i = OBJ_obj2nid(spkioid);\n    BIO_printf(out, \"  Public Key Algorithm: %s\\n\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    pkey = X509_PUBKEY_get(spki->spkac->pubkey);\n    if (!pkey)\n        BIO_printf(out, \"  Unable to load public key\\n\");\n    else {\n        EVP_PKEY_print_public(out, pkey, 4, NULL);\n        EVP_PKEY_free(pkey);\n    }\n    chal = spki->spkac->challenge;\n    if (chal->length)\n        BIO_printf(out, \"  Challenge String: %s\\n\", chal->data);\n    i = OBJ_obj2nid(spki->sig_algor.algorithm);\n    BIO_printf(out, \"  Signature Algorithm: %s\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    n = spki->signature->length;\n    s = (char *)spki->signature->data;\n    for (i = 0; i < n; i++) {\n        if ((i % 18) == 0)\n            BIO_write(out, \"\\n      \", 7);\n        BIO_printf(out, \"%02x%s\", (unsigned char)s[i],\n                   ((i + 1) == n) ? \"\" : \":\");\n    }\n    BIO_write(out, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "static void dtls1_set_handshake_header(SSL *s, int htype, unsigned long len)\n{\n    unsigned char *p = (unsigned char *)s->init_buf->data;\n    dtls1_set_message_header(s, p, htype, len, 0, len);\n    s->init_num = (int)len + DTLS1_HM_HEADER_LENGTH;\n    s->init_off = 0;\n    dtls1_buffer_message(s, 0);\n}", "target": 0}
{"code": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n      return;\n   }\n   ctx_params.shared = true;\n   ctx_params.major_ver = VREND_GL_VER_MAJOR;\n   ctx_params.minor_ver = VREND_GL_VER_MINOR;\n   blit_ctx->gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; \n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}", "target": 1}
{"code": "        unsigned int GetU32BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            return nRes;\n        }", "target": 1}
{"code": "struct rad_packet_t *rad_packet_alloc(int code)\n{\n\tstruct rad_packet_t *pack;\n\tpack = mempool_alloc(packet_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(pack, 0, sizeof(*pack));\n\tpack->code = code;\n\tpack->len = 20;\n\tpack->id = 1;\n\tINIT_LIST_HEAD(&pack->attrs);\n\treturn pack;\n}", "target": 0}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n    trigger_modechanged();\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n    setmouse();\n#ifdef FEAT_CONCEAL\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t\n#ifdef FEAT_CLIPBOARD\n    clip_star.vmode = NUL;\n#endif\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}", "target": 1}
{"code": "static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tint ret;\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\tif ((*flags & FOLL_POPULATE) &&\n\t\t\t(stack_guard_page_start(vma, address) ||\n\t\t\t stack_guard_page_end(vma, address + PAGE_SIZE)))\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tif (ret & VM_FAULT_OOM)\n\t\t\treturn -ENOMEM;\n\t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\n\t\t\treturn *flags & FOLL_HWPOISON ? -EHWPOISON : -EFAULT;\n\t\tif (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))\n\t\t\treturn -EFAULT;\n\t\tBUG();\n\t}\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking)\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags &= ~FOLL_WRITE;\n\treturn 0;\n}", "target": 1}
{"code": "static void _ewk_view_smart_changed(Ewk_View_Smart_Data* smartData)\n{\n    if (smartData->changed.any)\n        return;\n    smartData->changed.any = true;\n    evas_object_smart_changed(smartData->self);\n}", "target": 0}
{"code": "int lxc_safe_long(const char *numstr, long int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno == ERANGE && (sli == LONG_MAX || sli == LONG_MIN))\n\t\treturn -ERANGE;\n\tif (errno != 0 && sli == 0)\n\t\treturn -EINVAL;\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\t*converted = sli;\n\treturn 0;\n}", "target": 0}
{"code": "    void Jp2Image::writeMetadata()\n    {\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n        doWriteMetadata(*tempIo); \n        io_->close();\n        io_->transfer(*tempIo); \n    } ", "target": 0}
{"code": "archive_strncat_l(struct archive_string *as, const void *_p, size_t n,\n    struct archive_string_conv *sc)\n{\n\tconst void *s;\n\tsize_t length;\n\tint i, r = 0, r2;\n\tif (_p == NULL || n == 0) {\n\t\tint tn = 1;\n\t\tif (sc != NULL && (sc->flag & SCONV_TO_UTF16))\n\t\t\ttn = 2;\n\t\tif (archive_string_ensure(as, as->length + tn) == NULL)\n\t\t\treturn (-1);\n\t\tas->s[as->length] = 0;\n\t\tif (tn == 2)\n\t\t\tas->s[as->length+1] = 0;\n\t\treturn (0);\n\t}\n\tif (sc == NULL) {\n\t\tlength = mbsnbytes(_p, n);\n\t\tif (archive_string_append(as, _p, length) == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\tif (sc->flag & SCONV_FROM_UTF16)\n\t\tlength = utf16nbytes(_p, n);\n\telse\n\t\tlength = mbsnbytes(_p, n);\n\ts = _p;\n\ti = 0;\n\tif (sc->nconverter > 1) {\n\t\tsc->utftmp.length = 0;\n\t\tr2 = sc->converter[0](&(sc->utftmp), s, length, sc);\n\t\tif (r2 != 0 && errno == ENOMEM)\n\t\t\treturn (r2);\n\t\tif (r > r2)\n\t\t\tr = r2;\n\t\ts = sc->utftmp.s;\n\t\tlength = sc->utftmp.length;\n\t\t++i;\n\t}\n\tr2 = sc->converter[i](as, s, length, sc);\n\tif (r > r2)\n\t\tr = r2;\n\treturn (r);\n}", "target": 1}
{"code": "PyImaging_MapBuffer(PyObject* self, PyObject* args)\n{\n    Py_ssize_t y, size;\n    Imaging im;\n    PyObject* target;\n    Py_buffer view;\n    char* mode;\n    char* codec;\n    PyObject* bbox;\n    Py_ssize_t offset;\n    int xsize, ysize;\n    int stride;\n    int ystep;\n    if (!PyArg_ParseTuple(args, \"O(ii)sOn(sii)\", &target, &xsize, &ysize,\n                          &codec, &bbox, &offset, &mode, &stride, &ystep))\n        return NULL;\n    if (!PyImaging_CheckBuffer(target)) {\n        PyErr_SetString(PyExc_TypeError, \"expected string or buffer\");\n        return NULL;\n    }\n    if (stride <= 0) {\n        if (!strcmp(mode, \"L\") || !strcmp(mode, \"P\"))\n            stride = xsize;\n        else if (!strncmp(mode, \"I;16\", 4))\n            stride = xsize * 2;\n        else\n            stride = xsize * 4;\n    }\n    size = (Py_ssize_t) ysize * stride;\n    if (PyImaging_GetBuffer(target, &view) < 0)\n        return NULL;\n    if (view.len < 0) {\n        PyErr_SetString(PyExc_ValueError, \"buffer has negative size\");\n        return NULL;\n    }\n    if (offset + size > view.len) {\n        PyErr_SetString(PyExc_ValueError, \"buffer is not large enough\");\n        return NULL;\n    }\n    im = ImagingNewPrologueSubtype(\n        mode, xsize, ysize, sizeof(ImagingBufferInstance)\n        );\n    if (!im)\n        return NULL;\n    if (ystep > 0)\n        for (y = 0; y < ysize; y++)\n            im->image[y] = (char*)view.buf + offset + y * stride;\n    else\n        for (y = 0; y < ysize; y++)\n            im->image[ysize-y-1] = (char*)view.buf + offset + y * stride;\n    im->destroy = mapping_destroy_buffer;\n    Py_INCREF(target);\n    ((ImagingBufferInstance*) im)->target = target;\n    ((ImagingBufferInstance*) im)->view = view;\n    if (!ImagingNewEpilogue(im))\n        return NULL;\n    return PyImagingNew(im);\n}", "target": 1}
{"code": "void gdImageSetThickness (gdImagePtr im, int thickness)\n{\n\tim->thick = thickness;\n}", "target": 0}
{"code": "void http_return_srv_error(struct session *s, struct stream_interface *si)\n{\n\tint err_type = si->err_type;\n\tif (err_type & SI_ET_QUEUE_ABRT)\n\t\thttp_server_error(s, si, SN_ERR_CLICL, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_ABRT)\n\t\thttp_server_error(s, si, SN_ERR_CLICL, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_QUEUE_TO)\n\t\thttp_server_error(s, si, SN_ERR_SRVTO, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_QUEUE_ERR)\n\t\thttp_server_error(s, si, SN_ERR_SRVCL, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_TO)\n\t\thttp_server_error(s, si, SN_ERR_SRVTO, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_ERR)\n\t\thttp_server_error(s, si, SN_ERR_SRVCL, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse \n\t\thttp_server_error(s, si, SN_ERR_INTERNAL, SN_FINST_C,\n\t\t\t\t  500, http_error_message(s, HTTP_ERR_500));\n}", "target": 0}
{"code": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\tif (!asoc->temp) {\n\t\tlist_del(&asoc->asocs);\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\tasoc->base.dead = true;\n\tsctp_outq_free(&asoc->outqueue);\n\tsctp_ulpq_free(&asoc->ulpq);\n\tsctp_inq_free(&asoc->base.inqueue);\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\tsctp_ssnmap_free(asoc->ssnmap);\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\tasoc->peer.transport_count = 0;\n\tsctp_asconf_queue_teardown(asoc);\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}", "target": 1}
{"code": "sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    bool force)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(0);\n}", "target": 1}
{"code": "static boolean str_fill_input_buffer(j_decompress_ptr cinfo)\n{\n    int c;\n    struct str_src_mgr *src = (struct str_src_mgr *)cinfo->src;\n    if (src->index == 0) {\n        c = 0xFF;\n        src->index++;\n    } else if (src->index == 1) {\n        c = 0xD8;\n        src->index++;\n    } else\n        c = src->str->getChar();\n    if (c != EOF) {\n        src->buffer = c;\n        src->pub.next_input_byte = &src->buffer;\n        src->pub.bytes_in_buffer = 1;\n        return TRUE;\n    } else\n        return FALSE;\n}", "target": 0}
{"code": "static int vidioc_s_std(struct file *file, void *private_data, v4l2_std_id *_std)\n{\n\tv4l2_std_id req_std = 0, supported_std = 0;\n\tconst v4l2_std_id all_std = V4L2_STD_ALL, no_std = 0;\n\tif (_std) {\n\t\treq_std = *_std;\n\t\t*_std = all_std;\n\t}\n\tsupported_std = (all_std & req_std);\n\tif (no_std == supported_std)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "current_attribute (GMarkupParseContext *context)\n{\n  g_assert (context->cur_attr >= 0);\n  return context->attr_names[context->cur_attr]->str;\n}", "target": 0}
{"code": "static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static void vcc_sock_destruct(struct sock *sk)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc))\n\t\tprintk(KERN_DEBUG \"%s: rmem leakage (%d bytes) detected.\\n\",\n\t\t       __func__, atomic_read(&sk->sk_rmem_alloc));\n\tif (atomic_read(&sk->sk_wmem_alloc))\n\t\tprintk(KERN_DEBUG \"%s: wmem leakage (%d bytes) detected.\\n\",\n\t\t       __func__, atomic_read(&sk->sk_wmem_alloc));\n}", "target": 0}
{"code": "string DebugString(gtl::ArraySlice<NodeDef> instantiated_func_nodes) {\n  std::vector<const NodeDef*> ptrs;\n  for (const NodeDef& n : instantiated_func_nodes) {\n    ptrs.push_back(&n);\n  }\n  return Print(ptrs);\n}", "target": 0}
{"code": "manuf_name_lookup(const guint8 *addr)\n{\n    guint32       manuf_key;\n    guint8       oct;\n    hashmanuf_t  *manuf_value;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL) {\n        return manuf_value;\n    }\n    if ((manuf_key & 0x00010000) != 0) {\n        manuf_key &= 0x00FEFFFF;\n        manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n        if (manuf_value != NULL) {\n            return manuf_value;\n        }\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return manuf_hash_new_entry(addr, short_name, long_name);\n    }\n    return manuf_hash_new_entry(addr, NULL, NULL);\n} ", "target": 1}
{"code": "static struct fdtable *close_files(struct files_struct * files)\n{\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tunsigned int i, j = 0;\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\treturn fdt;\n}", "target": 0}
{"code": "ppp_input(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct channel *pch = chan->ppp;\n\tint proto;\n\tif (!pch || skb->len == 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tproto = PPP_PROTO(skb);\n\tread_lock_bh(&pch->upl);\n\tif (!pch->ppp || proto >= 0xc000 || proto == PPP_CCPFRAG) {\n\t\tskb_queue_tail(&pch->file.rq, skb);\n\t\twhile (pch->file.rq.qlen > PPP_MAX_RQLEN\n\t\t       && (skb = skb_dequeue(&pch->file.rq)))\n\t\t\tkfree_skb(skb);\n\t\twake_up_interruptible(&pch->file.rwait);\n\t} else {\n\t\tppp_do_recv(pch->ppp, skb, pch);\n\t}\n\tread_unlock_bh(&pch->upl);\n}", "target": 0}
{"code": "static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);", "target": 1}
{"code": "output_title_label_after_expose_event_cb (GtkWidget *widget, GdkEventExpose *event, gpointer data)\n{\n        g_assert (GTK_IS_LABEL (widget));\n        widget->state = GTK_STATE_INSENSITIVE;\n        return FALSE;\n}", "target": 0}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\treturn (1);\n}", "target": 1}
{"code": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}", "target": 1}
{"code": "static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = ax25_sk(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\t*uaddr_len = sizeof (struct full_sockaddr_ax25);\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "ZEND_API void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle, const zend_object_handlers *handlers TSRMLS_DC) \n{\n\tstruct _store_object *obj;\n\tint failure = 0;\n\tif (!EG(objects_store).object_buckets) {\n\t\treturn;\n\t}\n\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\tif (EG(objects_store).object_buckets[handle].valid) {\n\t\tif (obj->refcount == 1) {\n\t\t\tif (!EG(objects_store).object_buckets[handle].destructor_called) {\n\t\t\t\tEG(objects_store).object_buckets[handle].destructor_called = 1;\n\t\t\t\tif (obj->dtor) {\n\t\t\t\t\tif (handlers && !obj->handlers) {\n\t\t\t\t\t\tobj->handlers = handlers;\n\t\t\t\t\t}\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->dtor(obj->object, handle TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\t\t\tif (obj->refcount == 1) {\n\t\t\t\tGC_REMOVE_ZOBJ_FROM_BUFFER(obj);\n\t\t\t\tif (obj->free_storage) {\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->free_storage(obj->object TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST();\n\t\t\t}\n\t\t}\n\t}\n\tobj->refcount--;\n#if ZEND_DEBUG_OBJECTS\n\tif (obj->refcount == 0) {\n\t\tfprintf(stderr, \"Deallocated object id #%d\\n\", handle);\n\t} else {\n\t\tfprintf(stderr, \"Decreased refcount of object id #%d\\n\", handle);\n\t}\n#endif\n\tif (failure) {\n\t\tzend_bailout();\n\t}\n}", "target": 1}
{"code": "static int dump_suid_policy()\n{\n    int c;\n    int suid_dump_policy = 0;\n    const char *filename = \"/proc/sys/fs/suid_dumpable\";\n    FILE *f  = fopen(filename, \"r\");\n    if (!f)\n    {\n        log(\"Can't open %s\", filename);\n        return suid_dump_policy;\n    }\n    c = fgetc(f);\n    fclose(f);\n    if (c != EOF)\n        suid_dump_policy = c - '0';\n    return suid_dump_policy;\n}", "target": 0}
{"code": "static int test_x509_time(int idx)\n{\n    ASN1_TIME *t = NULL;\n    int result, rv = 0;\n    if (x509_format_tests[idx].set_string) {\n        t = ASN1_TIME_new();\n        if (t == NULL) {\n            TEST_info(\"test_x509_time(%d) failed: internal error\\n\", idx);\n            return 0;\n        }\n    }\n    result = ASN1_TIME_set_string_X509(t, x509_format_tests[idx].data);\n    if (!TEST_int_eq(result, x509_format_tests[idx].expected)) {\n        TEST_info(\"test_x509_time(%d) failed: expected %d, got %d\\n\",\n                idx, x509_format_tests[idx].expected, result);\n        goto out;\n    }\n    if (t != NULL && x509_format_tests[idx].expected_type != -1) {\n        if (!TEST_int_eq(t->type, x509_format_tests[idx].expected_type)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_type %d, got %d\\n\",\n                    idx, x509_format_tests[idx].expected_type, t->type);\n            goto out;\n        }\n    }\n    if (t != NULL && x509_format_tests[idx].expected_string) {\n        if (!TEST_str_eq((const char *)t->data,\n                    x509_format_tests[idx].expected_string)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_string %s, got %s\\n\",\n                    idx, x509_format_tests[idx].expected_string, t->data);\n            goto out;\n        }\n    }\n    rv = 1;\nout:\n    if (t != NULL)\n        ASN1_TIME_free(t);\n    return rv;\n}", "target": 1}
{"code": "static void fill_model_structures(SPICE_GNUC_UNUSED Encoder *encoder, FamilyStat *family_stat,\n                                  unsigned int rep_first, unsigned int first_size,\n                                  unsigned int rep_next, unsigned int mul_size,\n                                  unsigned int levels, unsigned int ncounters,\n                                  unsigned int nbuckets, unsigned int n_buckets_ptrs)\n{\n    unsigned int\n    bsize,\n    bstart,\n    bend = 0,\n    repcntr,\n    bnumber;\n    COUNTER * free_counter = family_stat->counters;\n    bnumber = 0;\n    repcntr = rep_first + 1;    \n    bsize = first_size;\n    do { \n        if (bnumber) {\n            bstart = bend + 1;\n        } else {\n            bstart = 0;\n        }\n        if (!--repcntr) {\n            repcntr = rep_next;\n            bsize *= mul_size;\n        }\n        bend = bstart + bsize - 1;\n        if (bend + bsize >= levels) {\n            bend = levels - 1;\n        }\n        family_stat->buckets_buf[bnumber].pcounters = free_counter;\n        free_counter += ncounters;\n        spice_assert(bstart < n_buckets_ptrs);\n        {\n            unsigned int i;\n            spice_assert(bend < n_buckets_ptrs);\n            for (i = bstart; i <= bend; i++) {\n                family_stat->buckets_ptrs[i] = family_stat->buckets_buf + bnumber;\n            }\n        }\n        bnumber++;\n    } while (bend < levels - 1);\n    spice_assert(free_counter - family_stat->counters == (ptrdiff_t)(nbuckets * ncounters));\n}", "target": 0}
{"code": "static int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tint delegation_type = 0;\n\tint status;\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}", "target": 1}
{"code": "rdpdr_handle_ok(int device, int handle)\n{\n\tswitch (g_rdpdr_device[device].device_type)\n\t{\n\t\tcase DEVICE_TYPE_PARALLEL:\n\t\tcase DEVICE_TYPE_SERIAL:\n\t\tcase DEVICE_TYPE_PRINTER:\n\t\tcase DEVICE_TYPE_SCARD:\n\t\t\tif (g_rdpdr_device[device].handle != handle)\n\t\t\t\treturn False;\n\t\t\tbreak;\n\t\tcase DEVICE_TYPE_DISK:\n\t\t\tif (g_fileinfo[handle].device_id != device)\n\t\t\t\treturn False;\n\t\t\tbreak;\n\t}\n\treturn True;\n}", "target": 0}
{"code": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "string Print(const FunctionDef& fdef) {\n  string out;\n  const OpDef& sig = fdef.signature();\n  strings::StrAppend(&out, \"\\n\", sig.name());\n  if (sig.attr_size() > 0) {\n    strings::StrAppend(&out, \"[\");\n    for (int i = 0; i < sig.attr_size(); ++i) {\n      const auto& a = sig.attr(i);\n      if (i > 0) strings::StrAppend(&out, \", \");\n      if (a.type() == \"type\") {\n        strings::StrAppend(&out, a.name(), \":\", Print(a.allowed_values()));\n      } else {\n        strings::StrAppend(&out, a.name(), \":\", a.type());\n      }\n    }\n    strings::StrAppend(&out, \"]\");\n  }\n  strings::StrAppend(&out, \"(\");\n  for (int i = 0; i < sig.input_arg_size(); ++i) {\n    if (i > 0) strings::StrAppend(&out, \", \");\n    strings::StrAppend(&out, Print(sig.input_arg(i)));\n  }\n  strings::StrAppend(&out, \") -> (\");\n  for (int i = 0; i < sig.output_arg_size(); ++i) {\n    if (i > 0) strings::StrAppend(&out, \", \");\n    strings::StrAppend(&out, Print(sig.output_arg(i)));\n  }\n  strings::StrAppend(&out, \") {\\n\");\n  for (const auto& n : fdef.node_def()) {\n    strings::StrAppend(&out, \"  \", Print(n), \"\\n\");\n  }\n  for (const auto& cr : fdef.control_ret()) {\n    strings::StrAppend(&out, \"  @return \", cr.first, \" = \", cr.second, \"\\n\");\n  }\n  for (const auto& r : fdef.ret()) {\n    strings::StrAppend(&out, \"  return \", r.first, \" = \", r.second, \"\\n\");\n  }\n  strings::StrAppend(&out, \"}\\n\");\n  return out;\n}", "target": 0}
{"code": "snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length)\n{\n  uint32_t i;\n  str += length - 1;\n  for(i = 0; i < length; ++i) {\n    (*out_len)++;\n    *out-- = (uint8_t)*str--;\n  }\n  out = snmp_ber_encode_length(out, out_len, length);\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING);\n  return out;\n}", "target": 1}
{"code": "int git_config_perm(const char *var, const char *value)\n{\n\tif (value) {\n\t\tint i;\n\t\tif (!strcmp(value, \"umask\"))\n\t\t\treturn PERM_UMASK;\n\t\tif (!strcmp(value, \"group\"))\n\t\t\treturn PERM_GROUP;\n\t\tif (!strcmp(value, \"all\") ||\n\t\t    !strcmp(value, \"world\") ||\n\t\t    !strcmp(value, \"everybody\"))\n\t\t\treturn PERM_EVERYBODY;\n\t\ti = atoi(value);\n\t\tif (i > 1)\n\t\t\treturn i;\n\t}\n\treturn git_config_bool(var, value);\n}", "target": 0}
{"code": "void luaC_fix (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(g->allgc == o);  \n  white2gray(o);  \n  setage(o, G_OLD);  \n  g->allgc = o->next;  \n  o->next = g->fixedgc;  \n  g->fixedgc = o;\n}", "target": 0}
{"code": "    GopherStateData(FwdState *aFwd) :\n        entry(aFwd->entry),\n        conversion(NORMAL),\n        HTML_header_added(0),\n        HTML_pre(0),\n        type_id(GOPHER_FILE ),\n        overflowed(false),\n        cso_recno(0),\n        len(0),\n        buf(nullptr),\n        fwd(aFwd)\n    {\n        *request = 0;\n        buf = (char *)memAllocate(MEM_4K_BUF);\n        entry->lock(\"gopherState\");\n        *replybuf = 0;\n    }", "target": 1}
{"code": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}", "target": 1}
{"code": "static bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\trand = get_random_int();\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = 0;\n\t\tstate->rand = rand;\n\t\tret = true;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "cif_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\tint line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int lnum;\n        byte *in = (byte *)gs_malloc(pdev->memory, line_size, 1, \"cif_print_page(in)\");\n        char *s;\n        int scanline, scanbyte;\n        int length, start; \n        if (in == 0)\n                return_error(gs_error_VMerror);\n        if ((s = strchr(pdev->fname, '.')) == NULL)\n                length = strlen(pdev->fname) + 1;\n        else\n                length = s - pdev->fname;\n        s = (char *)gs_malloc(pdev->memory, length, sizeof(char), \"cif_print_page(s)\");\n        strncpy(s, pdev->fname, length);\n        *(s + length) = '\\0';\n        gp_fprintf(prn_stream, \"DS1 25 1;\\n9 %s;\\nLCP;\\n\", s);\n        gs_free(pdev->memory, s, length, 1, \"cif_print_page(s)\");\n   for (lnum = 0; lnum < pdev->height; lnum++) {\n      gdev_prn_copy_scan_lines(pdev, lnum, in, line_size);\n      length = 0;\n      for (scanline = 0; scanline < line_size; scanline++)\n#ifdef TILE\t\t\t\n         for (scanbyte = 0; scanbyte < 8; scanbyte++)\n            if (((in[scanline] >> scanbyte) & 1) != 0)\n               gp_fprintf(prn_stream, \"B4 4 %d %d;\\n\",\n                  (scanline * 8 + (7 - scanbyte)) * 4,\n                  (pdev->height - lnum) * 4);\n#else\t\t\t\t\n         for (scanbyte = 7; scanbyte >= 0; scanbyte--)\n            if (((in[scanline] >> scanbyte) & 1) != 0) {\n               if (length == 0)\n                  start = (scanline * 8 + (7 - scanbyte));\n               length++;\n            } else {\n               if (length != 0)\n                  gp_fprintf(prn_stream, \"B%d 4 %d %d;\\n\", length * 4,\n                           start * 4 + length * 2,\n                           (pdev->height - lnum) * 4);\n               length = 0;\n            }\n#endif\n   }\n        gp_fprintf(prn_stream, \"DF;\\nC1;\\nE\\n\");\n        gs_free(pdev->memory, in, line_size, 1, \"cif_print_page(in)\");\n        return 0;\n}", "target": 1}
{"code": "static ssize_t set_bank(struct device *s, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t size)\n{\n\tu64 new;\n\tif (kstrtou64(buf, 0, &new) < 0)\n\t\treturn -EINVAL;\n\tattr_to_bank(attr)->ctl = new;\n\tmce_restart();\n\treturn size;\n}", "target": 0}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\twrite_lock_bh(&ping_table.lock);\n\tif (sk_hashed(sk)) {\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n}", "target": 0}
{"code": "static int fib6_remove_prefsrc(struct rt6_info *rt, void *arg)\n{\n\tstruct net_device *dev = ((struct arg_dev_net_ip *)arg)->dev;\n\tstruct net *net = ((struct arg_dev_net_ip *)arg)->net;\n\tstruct in6_addr *addr = ((struct arg_dev_net_ip *)arg)->addr;\n\tif (((void *)rt->dst.dev == dev || !dev) &&\n\t    rt != net->ipv6.ip6_null_entry &&\n\t    ipv6_addr_equal(addr, &rt->rt6i_prefsrc.addr)) {\n\t\trt->rt6i_prefsrc.plen = 0;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int PackLinuxElf32::canUnpack()\n{\n    if (super::canUnpack()) {\n        return true;\n    }\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf32help1(fi);\n    }\n    return false;\n}", "target": 1}
{"code": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n\t\tgoto no_delegation_unlock;\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n\t\tret = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "    static void _distance_scan(const unsigned int len,\n                               const longT *const g,\n                               longT (*const sep)(const longT, const longT, const longT *const),\n                               longT (*const f)(const longT, const longT, const longT *const),\n                               longT *const s,\n                               longT *const t,\n                               longT *const dt) {\n      longT q = s[0] = t[0] = 0;\n      for (int u = 1; u<(int)len; ++u) { \n        while ((q>=0) && f(t[q],s[q],g)>f(t[q],u,g)) { --q; }\n        if (q<0) { q = 0; s[0] = u; }\n        else { const longT w = 1 + sep(s[q], u, g); if (w<(longT)len) { ++q; s[q] = u; t[q] = w; }}\n      }\n      for (int u = (int)len - 1; u>=0; --u) { dt[u] = f(u,s[q],g); if (u==t[q]) --q; } ", "target": 0}
{"code": "m_wnum1(union DateData *x)\n{\n    return m_wnumx(x, 1);\n}", "target": 0}
{"code": "static void tcp_new_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tcp_should_expand_sndbuf(sk)) {\n\t\ttcp_sndbuf_expand(sk);\n\t\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\t}\n\tsk->sk_write_space(sk);\n}", "target": 0}
{"code": "OFCondition DcmSCP::listen()\n{\n  dcmEnableAutomaticInputDataCorrection.set( OFFalse );\n  OFCondition cond = EC_Normal;\n  if( !dcmDataDict.isDictionaryLoaded() )\n    DCMNET_WARN(\"No data dictionary loaded, check environment variable: \" << DCM_DICT_ENVIRONMENT_VARIABLE);\n#ifndef DISABLE_PORT_PERMISSION_CHECK\n#ifdef HAVE_GETEUID\n  if( m_cfg->getPort() < 1024 && geteuid() != 0 )\n  {\n    DCMNET_ERROR(\"No privileges to open this network port (\" << m_cfg->getPort() << \")\");\n    return NET_EC_InsufficientPortPrivileges;\n  }\n#endif\n#endif\n  T_ASC_Network *network = NULL;\n  cond = ASC_initializeNetwork( NET_ACCEPTOR, OFstatic_cast(int, m_cfg->getPort()), m_cfg->getACSETimeout(), &network );\n  if( cond.bad() )\n    return cond;\n#if defined(HAVE_SETUID) && defined(HAVE_GETUID)\n  setuid( getuid() );\n#endif\n  while( cond.good() && !stopAfterCurrentAssociation() )\n  {\n    cond = waitForAssociationRQ(network);\n  }\n  cond = ASC_dropNetwork( &network );\n  network = NULL;\n  return cond;\n}", "target": 1}
{"code": "static void part_write_body(const struct message_part *part,\n\t\t\t    string_t *str, bool extended)\n{\n\tconst struct message_part_data *data = part->data;\n\tbool text;\n\ti_assert(part->data != NULL);\n\tif ((part->flags & MESSAGE_PART_FLAG_MESSAGE_RFC822) != 0) {\n\t\tstr_append(str, \"\\\"message\\\" \\\"rfc822\\\"\");\n\t\ttext = FALSE;\n\t} else {\n\t\tif (data->content_type == NULL) {\n\t\t\ttext = TRUE;\n\t\t\tstr_append(str, \"\\\"text\\\" \\\"plain\\\"\");\n\t\t} else {\n\t\t\ttext = (strcasecmp(data->content_type, \"text\") == 0);\n\t\t\timap_append_string(str, data->content_type);\n\t\t\tstr_append_c(str, ' ');\n\t\t\timap_append_string(str, data->content_subtype);\n\t\t}\n\t}\n\tstr_append_c(str, ' ');\n\tparams_write(data->content_type_params,\n\t\tdata->content_type_params_count, str, text);\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_id);\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_description);\n\tstr_append_c(str, ' ');\n\tif (data->content_transfer_encoding != NULL)\n\t\timap_append_string(str, data->content_transfer_encoding);\n\telse\n\t\tstr_append(str, \"\\\"7bit\\\"\");\n\tstr_printfa(str, \" %\"PRIuUOFF_T, part->body_size.virtual_size);\n\tif (text) {\n\t\tstr_printfa(str, \" %u\", part->body_size.lines);\n\t} else if ((part->flags & MESSAGE_PART_FLAG_MESSAGE_RFC822) != 0) {\n\t\tconst struct message_part_data *child_data;\n\t\ti_assert(part->children != NULL);\n\t\ti_assert(part->children->next == NULL);\n\t\tchild_data = part->children->data;\n\t\tstr_append(str, \" (\");\n\t\timap_envelope_write(child_data->envelope, str);\n\t\tstr_append(str, \") \");\n\t\tpart_write_bodystructure_siblings(part->children, str, extended);\n\t\tstr_printfa(str, \" %u\", part->body_size.lines);\n\t}\n\tif (!extended)\n\t\treturn;\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_md5);\n\tpart_write_bodystructure_common(data, str);\n}", "target": 1}
{"code": "Status FunctionCallFrame::ConsumeRetvals(std::vector<Tensor>* rets,\n                                         bool allow_dead_tensors) {\n  rets->clear();\n  rets->reserve(rets_.size());\n  for (size_t i = 0; i < rets_.size(); ++i) {\n    if (rets_[i].has_val) {\n      rets->emplace_back(std::move(rets_[i].val));\n    } else if (allow_dead_tensors) {\n      rets->emplace_back();\n    } else {\n      return errors::Internal(\"Retval[\", i, \"] does not have value\");\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\tspin_lock(&hb->lock);\n\treturn hb;\n}", "target": 1}
{"code": "static void logi_dj_recv_destroy_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t\tstruct dj_report *dj_report)\n{\n\tstruct dj_device *dj_dev;\n\tunsigned long flags;\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tdj_dev = djrcv_dev->paired_dj_devices[dj_report->device_index];\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\tif (dj_dev != NULL) {\n\t\thid_destroy_device(dj_dev->hdev);\n\t\tkfree(dj_dev);\n\t} else {\n\t\tdev_err(&djrcv_dev->hdev->dev, \"%s: can't destroy a NULL device\\n\",\n\t\t\t__func__);\n\t}\n}", "target": 0}
{"code": "static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){\n  int i;\n  WhereConst *pConst;\n  if( pExpr->op!=TK_COLUMN ) return WRC_Continue;\n  if( ExprHasProperty(pExpr, EP_FixedCol) ) return WRC_Continue;\n  pConst = pWalker->u.pConst;\n  for(i=0; i<pConst->nConst; i++){\n    Expr *pColumn = pConst->apExpr[i*2];\n    if( pColumn==pExpr ) continue;\n    if( pColumn->iTable!=pExpr->iTable ) continue;\n    if( pColumn->iColumn!=pExpr->iColumn ) continue;\n    pConst->nChng++;\n    ExprClearProperty(pExpr, EP_Leaf);\n    ExprSetProperty(pExpr, EP_FixedCol);\n    assert( pExpr->pLeft==0 );\n    pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);\n    break;\n  }\n  return WRC_Prune;\n}", "target": 1}
{"code": "int GamutSampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)\n{\n    GAMUTCHAIN*  t = (GAMUTCHAIN* ) Cargo;\n    cmsCIELab LabIn1, LabOut1;\n    cmsCIELab LabIn2, LabOut2;\n    cmsUInt16Number Proof[cmsMAXCHANNELS], Proof2[cmsMAXCHANNELS];\n    cmsFloat64Number dE1, dE2, ErrorRatio;\n    ErrorRatio = 1.0;\n    cmsDoTransform(t -> hInput, In, &LabIn1, 1);\n    cmsDoTransform(t -> hForward, &LabIn1, Proof, 1);\n    cmsDoTransform(t -> hReverse, Proof, &LabOut1, 1);\n    memmove(&LabIn2, &LabOut1, sizeof(cmsCIELab));\n    cmsDoTransform(t -> hForward, &LabOut1, Proof2, 1);\n    cmsDoTransform(t -> hReverse, Proof2, &LabOut2, 1);\n    dE1 = cmsDeltaE(&LabIn1, &LabOut1);\n    dE2 = cmsDeltaE(&LabIn2, &LabOut2);\n    if (dE1 < t->Thereshold && dE2 < t->Thereshold)\n        Out[0] = 0;\n    else {\n        if (dE1 < t->Thereshold && dE2 > t->Thereshold)\n            Out[0] = 0;\n        else\n            if (dE1 > t->Thereshold && dE2 < t->Thereshold)\n                Out[0] = (cmsUInt16Number) _cmsQuickFloor((dE1 - t->Thereshold) + .5);\n            else  {\n                if (dE2 == 0.0)\n                    ErrorRatio = dE1;\n                else\n                    ErrorRatio = dE1 / dE2;\n                if (ErrorRatio > t->Thereshold)\n                    Out[0] = (cmsUInt16Number)  _cmsQuickFloor((ErrorRatio - t->Thereshold) + .5);\n                else\n                    Out[0] = 0;\n            }\n    }\n    return TRUE;\n}", "target": 0}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\nout:\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 1}
{"code": "int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {\n  Cursor c(buf.front());\n  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {\n    auto b = c.read<char>();\n    if (b == '\\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {\n      return i;\n    } else if (terminatorType_ != TerminatorType::NEWLINE &&\n               b == '\\r' && !c.isAtEnd() && c.read<char>() == '\\n') {\n      return i;\n    }\n  }\n  return -1;\n}", "target": 1}
{"code": "static int test_signed_mod_replace_ba(int n)\n{\n    BIGNUM *a = NULL, *b = NULL, *c = NULL, *d = NULL;\n    int st = 0;\n    if (!TEST_ptr(a = set_signed_bn(signed_mod_tests[n].n))\n            || !TEST_ptr(b = set_signed_bn(signed_mod_tests[n].divisor))\n            || !TEST_ptr(c = set_signed_bn(signed_mod_tests[n].result))\n            || !TEST_ptr(d = set_signed_bn(signed_mod_tests[n].remainder)))\n        goto err;\n    if (TEST_true(BN_div(b, a, a, b, ctx))\n            && TEST_BN_eq(b, c)\n            && TEST_BN_eq(a, d))\n        st = 1;\n err:\n    BN_free(a);\n    BN_free(b);\n    BN_free(c);\n    BN_free(d);\n    return st;\n}", "target": 0}
{"code": "option_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}", "target": 1}
{"code": "  void createDebugInfo() override {\n    llvm_unreachable(\"Accessing debug info from a lazy module\");\n  }", "target": 1}
{"code": "int nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx)\n{\n\tconst struct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_CONNECTIVITY);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->value = GETVAL32H(buf, 4);\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "static bool dir_is_in_dump_location(const char *dump_dir_name)\n{\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dump_dir_name, g_settings_dump_location, len) == 0\n     && dump_dir_name[len] == '/'\n     && !strstr(dump_dir_name + len, \"/.\")\n    ) {\n        return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "static bool mnt_ns_loop(struct dentry *dentry)\n{\n\tstruct mnt_namespace *mnt_ns;\n\tif (!is_mnt_ns_file(dentry))\n\t\treturn false;\n\tmnt_ns = get_proc_ns(dentry->d_inode)->ns;\n\treturn current->nsproxy->mnt_ns->seq >= mnt_ns->seq;\n}", "target": 0}
{"code": "void RestAuthHandler::shutdownExecute(bool isFinalized) noexcept {\n  try {\n    if (_isValid) {\n      events::LoggedIn(*_request, _username);\n    } else {\n      events::CredentialsBad(*_request, _username);\n    }\n  } catch (...) {\n  }\n  RestVocbaseBaseHandler::shutdownExecute(isFinalized);\n}", "target": 1}
{"code": "static void settings_changed(struct btd_adapter *adapter, uint32_t settings)\n{\n\tuint32_t changed_mask;\n\tchanged_mask = adapter->current_settings ^ settings;\n\tadapter->current_settings = settings;\n\tadapter->pending_settings &= ~changed_mask;\n\tDBG(\"Changed settings: 0x%08x\", changed_mask);\n\tDBG(\"Pending settings: 0x%08x\", adapter->pending_settings);\n\tif (changed_mask & MGMT_SETTING_POWERED) {\n\t        g_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\t\tif (adapter->current_settings & MGMT_SETTING_POWERED) {\n\t\t\tadapter_start(adapter);\n\t\t} else {\n\t\t\tadapter_stop(adapter);\n\t\t\tif (powering_down) {\n\t\t\t\tadapter_remaining--;\n\t\t\t\tif (!adapter_remaining)\n\t\t\t\t\tbtd_exit();\n\t\t\t}\n\t\t}\n\t}\n\tif ((changed_mask & MGMT_SETTING_LE) &&\n\t\t\t\tbtd_adapter_get_powered(adapter) &&\n\t\t\t\t(adapter->current_settings & MGMT_SETTING_LE))\n\t\ttrigger_passive_scanning(adapter);\n\tif (changed_mask & MGMT_SETTING_DISCOVERABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discoverable\");\n\t\tstore_adapter_info(adapter);\n\t\tbtd_adv_manager_refresh(adapter->adv_manager);\n\t}\n\tif (changed_mask & MGMT_SETTING_BONDABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Pairable\");\n\t\ttrigger_pairable_timeout(adapter);\n\t}\n}", "target": 1}
{"code": "mark_trusted_task_done (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n    g_object_unref (job->file);\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n    finalize_common ((CommonJob *) job);\n}", "target": 1}
{"code": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\treturn threads;\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1}
{"code": "t1mac_output_ascii(char *s, int len)\n{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}", "target": 1}
{"code": "int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n    PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n    if (mk_security_check_url(sr->uri) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    return MK_PLUGIN_RET_NOT_ME;\n}", "target": 1}
{"code": "exit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}", "target": 0}
{"code": "GBool Splash::pathAllOutside(SplashPath *path) {\n  SplashCoord xMin1, yMin1, xMax1, yMax1;\n  SplashCoord xMin2, yMin2, xMax2, yMax2;\n  SplashCoord x, y;\n  int xMinI, yMinI, xMaxI, yMaxI;\n  int i;\n  xMin1 = xMax1 = path->pts[0].x;\n  yMin1 = yMax1 = path->pts[0].y;\n  for (i = 1; i < path->length; ++i) {\n    if (path->pts[i].x < xMin1) {\n      xMin1 = path->pts[i].x;\n    } else if (path->pts[i].x > xMax1) {\n      xMax1 = path->pts[i].x;\n    }\n    if (path->pts[i].y < yMin1) {\n      yMin1 = path->pts[i].y;\n    } else if (path->pts[i].y > yMax1) {\n      yMax1 = path->pts[i].y;\n    }\n  }\n  transform(state->matrix, xMin1, yMin1, &x, &y);\n  xMin2 = xMax2 = x;\n  yMin2 = yMax2 = y;\n  transform(state->matrix, xMin1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMin1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  xMinI = splashFloor(xMin2);\n  yMinI = splashFloor(yMin2);\n  xMaxI = splashFloor(xMax2);\n  yMaxI = splashFloor(yMax2);\n  return state->clip->testRect(xMinI, yMinI, xMaxI, yMaxI) ==\n         splashClipAllOutside;\n}", "target": 0}
{"code": "static void CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}", "target": 0}
{"code": "static int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_debug(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\t*skip_dentries = i;\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "static void gen8_logical_ring_enable_irq(struct intel_engine_cs *engine)\n{\n\tENGINE_WRITE(engine, RING_IMR,\n\t\t     ~(engine->irq_enable_mask | engine->irq_keep_mask));\n\tENGINE_POSTING_READ(engine, RING_IMR);\n}", "target": 0}
{"code": "static unsigned rb_calculate_event_length(unsigned length)\n{\n\tstruct ring_buffer_event event; \n\tif (!length)\n\t\tlength++;\n\tif (length > RB_MAX_SMALL_DATA || RB_FORCE_8BYTE_ALIGNMENT)\n\t\tlength += sizeof(event.array[0]);\n\tlength += RB_EVNT_HDR_SIZE;\n\tlength = ALIGN(length, RB_ARCH_ALIGNMENT);\n\tif (length == RB_LEN_TIME_EXTEND + RB_ALIGNMENT)\n\t\tlength += RB_ALIGNMENT;\n\treturn length;\n}", "target": 0}
{"code": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\treturn mount_entry_on_generic(mntent, path);\n}", "target": 1}
{"code": "remove_unless_decomposed_in_hash (gpointer key,\n                                  gpointer value,\n                                  gpointer user_data)\n{\n  GHashTable *table = user_data;\n  const FlatpakDecomposed *d = key;\n  return !g_hash_table_contains (table, d);\n}", "target": 0}
{"code": "canonicalize_path (const char *path, char **pcanonical)\n{\n  char *canonical = 0;\n  assert (path && *path);\n  assert (pcanonical);\n  canonical = MALLOC (char, 1+ LT_STRLEN (path));\n  if (!canonical)\n    return 1;\n  {\n    size_t dest = 0;\n    size_t src;\n    for (src = 0; path[src] != LT_EOS_CHAR; ++src)\n      {\n\tif (path[src] == LT_PATHSEP_CHAR)\n\t  {\n\t    if ((dest == 0)\n\t\t|| (path[1+ src] == LT_PATHSEP_CHAR)\n\t\t|| (path[1+ src] == LT_EOS_CHAR))\n\t      continue;\n\t  }\n\tif ((path[src] != '/')\n#if defined(LT_DIRSEP_CHAR)\n\t    && (path[src] != LT_DIRSEP_CHAR)\n#endif\n\t    )\n\t  {\n\t    canonical[dest++] = path[src];\n\t  }\n\telse if ((path[1+ src] != LT_PATHSEP_CHAR)\n\t\t && (path[1+ src] != LT_EOS_CHAR)\n#if defined(LT_DIRSEP_CHAR)\n\t\t && (path[1+ src] != LT_DIRSEP_CHAR)\n#endif\n\t\t && (path[1+ src] != '/'))\n\t  {\n\t    canonical[dest++] = '/';\n\t  }\n      }\n    canonical[dest] = LT_EOS_CHAR;\n  }\n  *pcanonical = canonical;\n  return 0;\n}", "target": 0}
{"code": "void WasmBinaryWriter::writeLateUserSections() {\n  for (auto& section : wasm->userSections) {\n    if (section.name != BinaryConsts::UserSections::Dylink) {\n      writeUserSection(section);\n    }\n  }\n}", "target": 0}
{"code": "getHostName() {\n\tlong hostNameMax = HOST_NAME_MAX;\n\tif (hostNameMax < 255) {\n\t\thostNameMax = 255;\n\t}\n\tstring buf(hostNameMax + 1, '\\0');\n\tif (gethostname(&buf[0], hostNameMax + 1) == 0) {\n\t\tbuf[hostNameMax] = '\\0';\n\t\treturn string(buf.c_str());\n\t} else {\n\t\tint e = errno;\n\t\tthrow SystemException(\"Unable to query the system's host name\", e);\n\t}\n}", "target": 0}
{"code": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tes->s_free_inodes_count =\n\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tsb->s_dirt = 0;\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb, es);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}", "target": 0}
{"code": "longlong Item_ref_null_helper::val_int()\n{\n  DBUG_ASSERT(fixed == 1);\n  longlong tmp= (*ref)->val_int_result();\n  owner->was_null|= null_value= (*ref)->null_value;\n  return tmp;\n}", "target": 0}
{"code": "spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "  virtual bool wifi_available() const {\n    return available_devices_ & (1 << TYPE_WIFI);\n  }", "target": 0}
{"code": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\tif (tpg && lun) {\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}", "target": 1}
{"code": "evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen)\n{\n\tsize_t need = buf->misalign + buf->off + datlen;\n\tsize_t oldoff = buf->off;\n\tif (buf->totallen < need) {\n\t\tif (evbuffer_expand(buf, datlen) == -1)\n\t\t\treturn (-1);\n\t}\n\tmemcpy(buf->buffer + buf->off, data, datlen);\n\tbuf->off += datlen;\n\tif (datlen && buf->cb != NULL)\n\t\t(*buf->cb)(buf, oldoff, buf->off, buf->cbarg);\n\treturn (0);\n}", "target": 1}
{"code": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ net_hash_mix(net),\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}", "target": 1}
{"code": "static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\topendata->o_arg.open_flags = openflags;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, openflags);\n\t*res = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "static void manager_invoke_notify_message(Manager *m, Unit *u, pid_t pid, const char *buf, size_t n, FDSet *fds) {\n        _cleanup_strv_free_ char **tags = NULL;\n        assert(m);\n        assert(u);\n        assert(buf);\n        assert(n > 0);\n        tags = strv_split(buf, \"\\n\\r\");\n        if (!tags) {\n                log_oom();\n                return;\n        }\n        if (UNIT_VTABLE(u)->notify_message)\n                UNIT_VTABLE(u)->notify_message(u, pid, tags, fds);\n        else\n                log_unit_debug(u, \"Got notification message for unit. Ignoring.\");\n}", "target": 1}
{"code": "lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n    return EXIT_FAILURE;\n}", "target": 1}
{"code": "getSystemTempDir() {\n\tconst char *temp_dir = getenv(\"PASSENGER_TEMP_DIR\");\n\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\ttemp_dir = getenv(\"PASSENGER_TMPDIR\");\n\t\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\t\ttemp_dir = \"/tmp\";\n\t\t}\n\t}\n\treturn temp_dir;\n}", "target": 0}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}", "target": 1}
{"code": "static void ptirq_free_irte(const struct ptirq_remapping_info *entry)\n{\n\tstruct intr_source intr_src;\n\tif (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {\n\t\tif (entry->intr_type == PTDEV_INTR_MSI) {\n\t\t\tintr_src.is_msi = true;\n\t\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\t} else {\n\t\t\tintr_src.is_msi = false;\n\t\t\tintr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);\n\t\t}\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\t}\n}", "target": 1}
{"code": "static inline int sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent)\n{\n\tint err = 0;\n\tsco_conn_lock(conn);\n\tif (conn->sk)\n\t\terr = -EBUSY;\n\telse\n\t\t__sco_chan_add(conn, sk, parent);\n\tsco_conn_unlock(conn);\n\treturn err;\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::ProcessAckedTouchEvent(\n    const TouchEventWithLatencyInfo& touch, InputEventAckState ack_result) {\n  ScopedVector<ui::TouchEvent> events;\n  if (!MakeUITouchEventsFromWebTouchEvents(touch, &events,\n                                           SCREEN_COORDINATES))\n    return;\n  aura::WindowEventDispatcher* dispatcher = window_->GetDispatcher();\n  if (!dispatcher)\n    return;\n  ui::EventResult result = (ack_result ==\n      INPUT_EVENT_ACK_STATE_CONSUMED) ? ui::ER_HANDLED : ui::ER_UNHANDLED;\n  for (ScopedVector<ui::TouchEvent>::iterator iter = events.begin(),\n      end = events.end(); iter != end; ++iter) {\n    dispatcher->ProcessedTouchEvent((*iter), window_, result);\n  }\n}", "target": 0}
{"code": "static int xen_net_read_mac(struct xenbus_device *dev, u8 mac[])\n{\n\tchar *s, *e, *macstr;\n\tint i;\n\tmacstr = s = xenbus_read(XBT_NIL, dev->nodename, \"mac\", NULL);\n\tif (IS_ERR(macstr))\n\t\treturn PTR_ERR(macstr);\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tmac[i] = simple_strtoul(s, &e, 16);\n\t\tif ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\\0' : ':'))) {\n\t\t\tkfree(macstr);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\ts = e+1;\n\t}\n\tkfree(macstr);\n\treturn 0;\n}", "target": 0}
{"code": "static struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\tfor (;;) {\n\t\tif (can_open_cached(state, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, open_mode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, open_mode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(stateid.data, delegation->stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\t\tif (update_open_stateid(state, NULL, &stateid, open_mode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}", "target": 1}
{"code": "BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       \n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, bitmapData->codecID); \n\tStream_Write_UINT16(s, bitmapData->width);  \n\tStream_Write_UINT16(s, bitmapData->height); \n\tStream_Write_UINT32(s, bitmapData->length); \n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}", "target": 1}
{"code": "static void do_free_publickey(struct rsa_public_key *s)\n{\n\tif (s) {\n\t\tcrypto_bignum_free(s->n);\n\t\tcrypto_bignum_free(s->e);\n\t}\n}", "target": 1}
{"code": "static int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n      if (len != data_size)\n\t{\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n      p = data + 2;\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\t  DECR_LENGTH_RET (data_size, len, 0);\n\t  server_names++;\n\t  p += len;\n\t}\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\t  switch (type)\n\t    {\n\t    case 0:\t\t\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\t  p += len;\n\t}\n    }\n  return 0;\n}", "target": 1}
{"code": "int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct pid_namespace *pid = dentry->d_sb->s_fs_info;\n\tgeneric_fillattr(inode, stat);\n\trcu_read_lock();\n\tstat->uid = 0;\n\tstat->gid = 0;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif (!has_pid_permissions(pid, task, 2)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}", "target": 0}
{"code": "static int ssl_verify_server_cert(Vio *vio, const char* server_hostname, const char **errptr)\n{\n  SSL *ssl;\n  X509 *server_cert;\n  char *cp1, *cp2;\n  char *buf;\n  DBUG_ENTER(\"ssl_verify_server_cert\");\n  DBUG_PRINT(\"enter\", (\"server_hostname: %s\", server_hostname));\n  if (!(ssl= (SSL*)vio->ssl_arg))\n  {\n    *errptr= \"No SSL pointer found\";\n    DBUG_RETURN(1);\n  }\n  if (!server_hostname)\n  {\n    *errptr= \"No server hostname supplied\";\n    DBUG_RETURN(1);\n  }\n  if (!(server_cert= SSL_get_peer_certificate(ssl)))\n  {\n    *errptr= \"Could not get server certificate\";\n    DBUG_RETURN(1);\n  }\n  if (X509_V_OK != SSL_get_verify_result(ssl))\n  {\n    *errptr= \"Failed to verify the server certificate\";\n    X509_free(server_cert);\n    DBUG_RETURN(1);\n  }\n  buf= X509_NAME_oneline(X509_get_subject_name(server_cert), 0, 0);\n  X509_free (server_cert);\n  if (!buf)\n  {\n    *errptr= \"Out of memory\";\n    DBUG_RETURN(1);\n  }\n  DBUG_PRINT(\"info\", (\"hostname in cert: %s\", buf));\n  cp1= strstr(buf, \"/CN=\");\n  if (cp1)\n  {\n    cp1+= 4; \n    cp2= strchr(cp1, '/');\n    if (cp2)\n      *cp2= '\\0';\n    DBUG_PRINT(\"info\", (\"Server hostname in cert: %s\", cp1));\n    if (!strcmp(cp1, server_hostname))\n    {\n      free(buf);\n      DBUG_RETURN(0);\n    }\n  }\n  *errptr= \"SSL certificate validation failure\";\n  free(buf);\n  DBUG_RETURN(1);\n}", "target": 1}
{"code": "static int rxrpc_preparse_s(struct key_preparsed_payload *prep)\n{\n\tstruct crypto_blkcipher *ci;\n\t_enter(\"%zu\", prep->datalen);\n\tif (prep->datalen != 8)\n\t\treturn -EINVAL;\n\tmemcpy(&prep->type_data, prep->data, 8);\n\tci = crypto_alloc_blkcipher(\"pcbc(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(ci)) {\n\t\t_leave(\" = %ld\", PTR_ERR(ci));\n\t\treturn PTR_ERR(ci);\n\t}\n\tif (crypto_blkcipher_setkey(ci, prep->data, 8) < 0)\n\t\tBUG();\n\tprep->payload[0] = ci;\n\t_leave(\" = 0\");\n\treturn 0;\n}", "target": 0}
{"code": "ExecuteSoapAction(struct upnphttp * h, const char * action, int n)\n{\n\tchar * p;\n\tchar * p2;\n\tint i, len, methodlen;\n\tchar namespace[256];\n\tp = strchr(action, '#');\n\tif(p && (p - action) < n) {\n\t\tfor(i = 0; i < ((int)sizeof(namespace) - 1) && (action + i) < p; i++)\n\t\t\tnamespace[i] = action[i];\n\t\tnamespace[i] = '\\0';\n\t\tp++;\n\t\tp2 = strchr(p, '\"');\n\t\tif(p2 && (p2 - action) <= n)\n\t\t\tmethodlen = p2 - p;\n\t\telse\n\t\t\tmethodlen = n - (p - action);\n\t\tfor(i = 0; soapMethods[i].methodName; i++) {\n\t\t\tlen = strlen(soapMethods[i].methodName);\n\t\t\tif((len == methodlen) && memcmp(p, soapMethods[i].methodName, len) == 0) {\n#ifdef DEBUG\n\t\t\t\tsyslog(LOG_DEBUG, \"Remote Call of SoapMethod '%s' %s\",\n\t\t\t\t       soapMethods[i].methodName, namespace);\n#endif \n\t\t\t\tsoapMethods[i].methodImpl(h, soapMethods[i].methodName, namespace);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsyslog(LOG_NOTICE, \"SoapMethod: Unknown: %.*s %s\", methodlen, p, namespace);\n\t} else {\n\t\tsyslog(LOG_NOTICE, \"cannot parse SoapAction\");\n\t}\n\tSoapError(h, 401, \"Invalid Action\");\n}", "target": 0}
{"code": "    constexpr uint32_t Nikon3MnHeader::sizeOfSignature()\n    {\n        return sizeof(signature_);\n    }", "target": 0}
{"code": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}", "target": 1}
{"code": "void ff_h264_free_tables(H264Context *h, int free_rbsp)\n{\n    int i;\n    H264Context *hx;\n    av_freep(&h->intra4x4_pred_mode);\n    av_freep(&h->chroma_pred_mode_table);\n    av_freep(&h->cbp_table);\n    av_freep(&h->mvd_table[0]);\n    av_freep(&h->mvd_table[1]);\n    av_freep(&h->direct_table);\n    av_freep(&h->non_zero_count);\n    av_freep(&h->slice_table_base);\n    h->slice_table = NULL;\n    av_freep(&h->list_counts);\n    av_freep(&h->mb2b_xy);\n    av_freep(&h->mb2br_xy);\n    av_buffer_pool_uninit(&h->qscale_table_pool);\n    av_buffer_pool_uninit(&h->mb_type_pool);\n    av_buffer_pool_uninit(&h->motion_val_pool);\n    av_buffer_pool_uninit(&h->ref_index_pool);\n     if (free_rbsp && h->DPB) {\n         for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n             ff_h264_unref_picture(h, &h->DPB[i]);\n         av_freep(&h->DPB);\n     } else if (h->DPB) {\n         for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n            h->DPB[i].needs_realloc = 1;\n    }\n    h->cur_pic_ptr = NULL;\n    for (i = 0; i < H264_MAX_THREADS; i++) {\n        hx = h->thread_context[i];\n        if (!hx)\n            continue;\n        av_freep(&hx->top_borders[1]);\n        av_freep(&hx->top_borders[0]);\n        av_freep(&hx->bipred_scratchpad);\n        av_freep(&hx->edge_emu_buffer);\n        av_freep(&hx->dc_val_base);\n        av_freep(&hx->er.mb_index2xy);\n        av_freep(&hx->er.error_status_table);\n        av_freep(&hx->er.er_temp_buffer);\n        av_freep(&hx->er.mbintra_table);\n        av_freep(&hx->er.mbskip_table);\n        if (free_rbsp) {\n            av_freep(&hx->rbsp_buffer[1]);\n            av_freep(&hx->rbsp_buffer[0]);\n            hx->rbsp_buffer_size[0] = 0;\n            hx->rbsp_buffer_size[1] = 0;\n        }\n        if (i)\n            av_freep(&h->thread_context[i]);\n    }\n}", "target": 1}
{"code": "    std::string Iptcdatum::recordName() const\n    {\n        return key_.get() == 0 ? \"\" : key_->recordName();\n    }", "target": 0}
{"code": "static void virtio_blk_handle_read(VirtIOBlockReq *req)\n{\n    BlockDriverAIOCB *acb;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov,\n                         req->qiov.size / BDRV_SECTOR_SIZE,\n                         virtio_blk_rw_complete, req);\n    if (!acb) {\n        virtio_blk_rw_complete(req, -EIO);\n    }\n}", "target": 1}
{"code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\t(*header)->os_type = RAW_DATA(header, 23);\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int addrconf_ifid_eui64(u8 *eui, struct net_device *dev)\n{\n\tif (dev->addr_len != IEEE802154_ADDR_LEN)\n\t\treturn -1;\n\tmemcpy(eui, dev->dev_addr, 8);\n\teui[0] ^= 2;\n\treturn 0;\n}", "target": 0}
{"code": "static void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  LIST *pruned_list= 0;\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n    }\n    else\n    {\n      pruned_list= list_add(pruned_list, element);\n    }\n  }\n  mysql->stmts= pruned_list;\n}", "target": 1}
{"code": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n    free(ptr);\n    return nullptr;\n}", "target": 1}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 0}
{"code": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}", "target": 1}
{"code": "exif_data_save_data_entry (ExifData *data, ExifEntry *e,\n\t\t\t   unsigned char **d, unsigned int *ds,\n\t\t\t   unsigned int offset)\n{\n\tunsigned int doff, s;\n\tunsigned int ts;\n\tif (!data || !data->priv) \n\t\treturn;\n\texif_set_short (*d + 6 + offset + 0,\n\t\t\tdata->priv->order, (ExifShort) e->tag);\n\texif_set_short (*d + 6 + offset + 2,\n\t\t\tdata->priv->order, (ExifShort) e->format);\n\tif (!(data->priv->options & EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE)) {\n\t\tif ((e->tag == EXIF_TAG_MAKER_NOTE) && data->priv->md) {\n\t\t\texif_mem_free (data->priv->mem, e->data);\n\t\t\te->data = NULL;\n\t\t\te->size = 0;\n\t\t\texif_mnote_data_set_offset (data->priv->md, *ds - 6);\n\t\t\texif_mnote_data_save (data->priv->md, &e->data, &e->size);\n\t\t\te->components = e->size;\n\t\t\tif (exif_format_get_size (e->format) != 1) {\n\t\t\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\t\t}\n\t\t}\n\t}\n\texif_set_long  (*d + 6 + offset + 4,\n\t\t\tdata->priv->order, e->components);\n\ts = exif_format_get_size (e->format) * e->components;\n\tif (s > 4) {\n\t\tunsigned char *t;\n\t\tdoff = *ds - 6;\n\t\tts = *ds + s;\n\t\tif (s & 1)\n\t\t\tts++;\n\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\tif (!t) {\n\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t\t  \treturn;\n\t\t}\n\t\t*d = t;\n\t\t*ds = ts;\n\t\texif_set_long (*d + 6 + offset + 8, data->priv->order, doff);\n\t\tif (s & 1) \n\t\t\t*(*d + *ds - 1) = '\\0';\n\t} else\n\t\tdoff = offset + 8;\n\tif (e->data) {\n\t\tmemcpy (*d + 6 + doff, e->data, s);\n\t} else {\n\t\tmemset (*d + 6 + doff, 0, s);\n\t}\n\tif (s < 4) \n\t\tmemset (*d + 6 + doff + s, 0, (4 - s));\n}", "target": 1}
{"code": "void pushGenericCommand(client *c, int where) {\n    int j, pushed = 0;\n    for (j = 2; j < c->argc; j++) {\n        if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {\n            addReplyError(c, \"Element too large\");\n            return;\n        }\n    }\n    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);\n    if (lobj && lobj->type != OBJ_LIST) {\n        addReply(c,shared.wrongtypeerr);\n        return;\n    }\n    for (j = 2; j < c->argc; j++) {\n        if (!lobj) {\n            lobj = createQuicklistObject();\n            quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,\n                                server.list_compress_depth);\n            dbAdd(c->db,c->argv[1],lobj);\n        }\n        listTypePush(lobj,c->argv[j],where);\n        pushed++;\n    }\n    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));\n    if (pushed) {\n        char *event = (where == LIST_HEAD) ? \"lpush\" : \"rpush\";\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);\n    }\n    server.dirty += pushed;\n}", "target": 0}
{"code": "int nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_ENABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->enable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_ENABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "user_local_get_object_path (User *user)\n{\n        return user->object_path;\n}", "target": 0}
{"code": "void print_2fun(FILE* outfile, LibRaw& MyCoolRawProcessor, std::string& fn)\n{\n\tfprintf(outfile, \"\n\tif (C.cam_mul[0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'As shot' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %.3f\", C.cam_mul[c]);\n\t}\n\tif (C.WB_Coeffs[LIBRAW_WBI_Auto][0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'Camera Auto' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %d\", C.WB_Coeffs[LIBRAW_WBI_Auto][c]);\n\t}\n\tif (C.WB_Coeffs[LIBRAW_WBI_Measured][0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'Camera Measured' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %d\", C.WB_Coeffs[LIBRAW_WBI_Measured][c]);\n\t}\n\tfprintf(outfile, \"\\n\\n\");\n}", "target": 0}
{"code": "        EDP* getEDP() { return &edp_; }", "target": 1}
{"code": "static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static void setup_private_mount(const char *snap_name)\n{\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tchar tmpdir[MAX_BUF] = { 0 };\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"/tmp/snap.%s_XXXXXX\", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie(\"cannot create temporary directory essential for private /tmp\");\n\t}\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"%s/tmp\", d);\n\tfree(d);\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie(\"cannot create temporary directory for private /tmp\");\n\t}\n\tumask(old_mask);\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie(\"cannot get current working directory\");\n\tif (chdir(\"/\") != 0)\n\t\tdie(\"cannot change directory to '/'\");\n\tsc_do_mount(tmpdir, \"/tmp\", NULL, MS_BIND, NULL);\n\tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n\tif (chown(\"/tmp/\", uid, gid) < 0) {\n\t\tdie(\"cannot change ownership of /tmp\");\n\t}\n\tif (chdir(pwd) != 0)\n\t\tdie(\"cannot change current working directory to the original directory\");\n\tfree(pwd);\n}", "target": 1}
{"code": "zzip_dir_close(ZZIP_DIR * dir)\n{\n    dir->refcount &= ~0x10000000;       \n    return zzip_dir_free(dir);\n}", "target": 0}
{"code": "static int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto exit;\n\t\t}\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "struct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\tpr_debug(\"No device found\\n\");\n\treturn NULL;\n}", "target": 1}
{"code": " PPB_URLLoader_Impl::~PPB_URLLoader_Impl() {\n }", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (in_synth->alive && speakup_tty && speakup_tty->ops->write) {\n\t\tint ret = speakup_tty->ops->write(speakup_tty, &ch, 1);\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"%s: I/O error, deactivating speakup\\n\",\n\t\t\t\tin_synth->long_name);\n\t\t\tin_synth->alive = 0;\n\t\t\tspeakup_start_ttys();\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tmutex_unlock(&speakup_tty_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\tinfo->addr = port->addr;\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\treturn 0;\n}", "target": 1}
{"code": "ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}", "target": 1}
{"code": "static int __packet_get_status(struct packet_sock *po, void *frame)\n{\n\tunion {\n\t\tstruct tpacket_hdr *h1;\n\t\tstruct tpacket2_hdr *h2;\n\t\tvoid *raw;\n\t} h;\n\tsmp_rmb();\n\th.raw = frame;\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\tflush_dcache_page(pgv_to_page(&h.h1->tp_status));\n\t\treturn h.h1->tp_status;\n\tcase TPACKET_V2:\n\t\tflush_dcache_page(pgv_to_page(&h.h2->tp_status));\n\t\treturn h.h2->tp_status;\n\tcase TPACKET_V3:\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported.\\n\");\n\t\tBUG();\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "static authz_status oidc_handle_unauthorized_user24(request_rec *r) {\n\toidc_debug(r, \"enter\");\n\toidc_cfg *c = ap_get_module_config(r->server->module_config, &auth_openidc_module);\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\t\t\t\t  OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_debug(r, \"setting environment variable %s to \\\"%s\\\" for usage in mod_headers\", OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\tapr_table_set(r->subprocess_env, OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\treturn AUTHZ_DENIED;\n\t}\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\t\tcase OIDC_UNAUTZ_RETURN403:\n\t\tcase OIDC_UNAUTZ_RETURN401:\n\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t}\n\toidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n\tconst char *location = oidc_util_hdr_out_location_get(r);\n\tif (location != NULL) {\n\t\toidc_debug(r, \"send HTML refresh with authorization redirect: %s\", location);\n\t\tchar *html_head =\n\t\t\t\tapr_psprintf(r->pool, \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=%s\\\">\", location);\n\t\toidc_util_html_send(r, \"Stepup Authentication\", html_head, NULL, NULL,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t\tr->header_only = 1;\n\t}\n\treturn AUTHZ_DENIED;\n}", "target": 0}
{"code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\treturn datagrams;\n}", "target": 1}
{"code": "parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}", "target": 1}
{"code": "sysDescr_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, CONTIKI_VERSION_STRING);\n}", "target": 1}
{"code": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off, gdb_num;\n\tint err;\n\t__u16 bg_flags = 0;\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n} ", "target": 0}
{"code": "win_free_lsize(win_T *wp)\n{\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}", "target": 0}
{"code": "void *TrustedPrimitives::UntrustedLocalMemcpy(void *dest, const void *src,\n                                              size_t size) noexcept {\n  return memcpy(dest, src, size);\n}", "target": 0}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "newVar_N2(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops1=getString(pop());\n\t\tchar *pops2=getName  (pop());\n\t\twhile ( strlen(v->p.String)+ 3 + strlen(pops1)+ strlen(pops2) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops2);\n\t\tstrcat(v->p.String,\":\");\n\t\tstrcat(v->p.String,pops1);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}", "target": 0}
{"code": "do_curl_clear(CurlObject *self)\n{\n#ifdef WITH_THREAD\n    assert(pycurl_get_thread_state(self) == NULL);\n#endif\n    util_curl_xdecref(self, PYCURL_MEMGROUP_ALL, self->handle);\n    return 0;\n}", "target": 0}
{"code": "ospf_router_lsa_links_examin\n(\n  struct router_lsa_link * link,\n  u_int16_t linkbytes,\n  const u_int16_t num_links\n)\n{\n  unsigned counted_links = 0, thislinklen;\n  while (linkbytes)\n  {\n    thislinklen = OSPF_ROUTER_LSA_LINK_SIZE + 4 * link->m[0].tos_count;\n    if (thislinklen > linkbytes)\n    {\n      if (IS_DEBUG_OSPF_PACKET (0, RECV))\n        zlog_debug (\"%s: length error in link block #%u\", __func__, counted_links);\n      return MSG_NG;\n    }\n    link = (struct router_lsa_link *)((caddr_t) link + thislinklen);\n    linkbytes -= thislinklen;\n    counted_links++;\n  }\n  if (counted_links != num_links)\n  {\n    if (IS_DEBUG_OSPF_PACKET (0, RECV))\n      zlog_debug (\"%s: %u link blocks declared, %u present\",\n                  __func__, num_links, counted_links);\n    return MSG_NG;\n  }\n  return MSG_OK;\n}", "target": 0}
{"code": "register_commands (assuan_context_t ctx)\n{\n  static struct {\n    const char *name;\n    assuan_handler_t handler;\n    const char * const help;\n  } table[] = {\n    { \"SERIALNO\",     cmd_serialno, hlp_serialno },\n    { \"LEARN\",        cmd_learn,    hlp_learn },\n    { \"READCERT\",     cmd_readcert, hlp_readcert },\n    { \"READKEY\",      cmd_readkey,  hlp_readkey },\n    { \"SETDATA\",      cmd_setdata,  hlp_setdata },\n    { \"PKSIGN\",       cmd_pksign,   hlp_pksign },\n    { \"PKAUTH\",       cmd_pkauth,   hlp_pkauth },\n    { \"PKDECRYPT\",    cmd_pkdecrypt,hlp_pkdecrypt },\n    { \"INPUT\",        NULL },\n    { \"OUTPUT\",       NULL },\n    { \"GETATTR\",      cmd_getattr,  hlp_getattr },\n    { \"SETATTR\",      cmd_setattr,  hlp_setattr },\n    { \"WRITECERT\",    cmd_writecert,hlp_writecert },\n    { \"WRITEKEY\",     cmd_writekey, hlp_writekey },\n    { \"GENKEY\",       cmd_genkey,   hlp_genkey },\n    { \"RANDOM\",       cmd_random,   hlp_random },\n    { \"PASSWD\",       cmd_passwd,   hlp_passwd },\n    { \"CHECKPIN\",     cmd_checkpin, hlp_checkpin },\n    { \"LOCK\",         cmd_lock,     hlp_lock },\n    { \"UNLOCK\",       cmd_unlock,   hlp_unlock },\n    { \"GETINFO\",      cmd_getinfo,  hlp_getinfo },\n    { \"RESTART\",      cmd_restart,  hlp_restart },\n    { \"DISCONNECT\",   cmd_disconnect,hlp_disconnect },\n    { \"APDU\",         cmd_apdu,     hlp_apdu },\n    { \"KILLSCD\",      cmd_killscd,  hlp_killscd },\n    { NULL }\n  };\n  int i, rc;\n  for (i=0; table[i].name; i++)\n    {\n      rc = assuan_register_command (ctx, table[i].name, table[i].handler,\n                                    table[i].help);\n      if (rc)\n        return rc;\n    }\n  assuan_set_hello_line (ctx, \"GNU Privacy Guard's Smartcard server ready\");\n  assuan_register_reset_notify (ctx, reset_notify);\n  assuan_register_option_handler (ctx, option_handler);\n  return 0;\n}", "target": 0}
{"code": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 1}
{"code": "GF_Err mdia_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 cookie = gf_bs_get_cookie(bs);\n\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\te = gf_isom_box_array_read(s, bs, mdia_on_child_box);\n\tgf_bs_set_cookie(bs, cookie);\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\tif (!sk)\n\t\treturn 0;\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\tlock_sock(sk);\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\tif (op->ifindex) {\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\t\tbcm_remove_op(op);\n\t}\n#if IS_ENABLED(CONFIG_PROC_FS)\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif \n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}", "target": 1}
{"code": "inline Result ClientImpl::Delete(const std::string &path,\n                                 const Headers &headers, const char *body,\n                                 size_t content_length,\n                                 const std::string &content_type) {\n  Request req;\n  req.method = \"DELETE\";\n  req.headers = headers;\n  req.path = path;\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n  req.body.assign(body, content_length);\n  return send_(std::move(req));\n}", "target": 1}
{"code": "void device_init()\n{\n    hw_init(LOW_FREQUENCY);\n    if (! tsc_sensor_exists())\n    {\n        _NFC_status = nfc_init();\n    }\n    if (_NFC_status == NFC_IS_ACTIVE)\n    {\n        printf1(TAG_NFC, \"Have NFC\\r\\n\");\n        isLowFreq = 1;\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n    else\n    {\n        printf1(TAG_NFC, \"Have NO NFC\\r\\n\");\n        hw_init(HIGH_FREQUENCY);\n        isLowFreq = 0;\n        device_init_button();\n    }\n    usbhid_init();\n    ctaphid_init();\n    ctap_init();\n    device_migrate();\n#if BOOT_TO_DFU\n    flash_option_bytes_init(1);\n#else\n    flash_option_bytes_init(0);\n#endif\n}", "target": 1}
{"code": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "TranslateInfoBarDelegate* TranslateManager::GetTranslateInfoBarDelegate(\n    TabContents* tab) {\n  for (int i = 0; i < tab->infobar_delegate_count(); ++i) {\n    TranslateInfoBarDelegate* delegate =\n        tab->GetInfoBarDelegateAt(i)->AsTranslateInfoBarDelegate();\n    if (delegate)\n      return delegate;\n  }\n  return NULL;\n}", "target": 0}
{"code": "static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)\n{\n\tstruct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;\n\tsize_t ret;\n\tret = BZ2_bzread(self->bz_file, buf, count);\n\tif (ret == 0) {\n\t\tstream->eof = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}", "target": 1}
{"code": "ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)\n{\n    ngx_int_t                  overwrite;\n    ngx_str_t                  uri, args;\n    ngx_table_elt_t           *location;\n    ngx_http_core_loc_conf_t  *clcf;\n    overwrite = err_page->overwrite;\n    if (overwrite && overwrite != NGX_HTTP_OK) {\n        r->expect_tested = 1;\n    }\n    if (overwrite >= 0) {\n        r->err_status = overwrite;\n    }\n    if (ngx_http_complex_value(r, &err_page->value, &uri) != NGX_OK) {\n        return NGX_ERROR;\n    }\n    if (uri.len && uri.data[0] == '/') {\n        if (err_page->value.lengths) {\n            ngx_http_split_args(r, &uri, &args);\n        } else {\n            args = err_page->args;\n        }\n        if (r->method != NGX_HTTP_HEAD) {\n            r->method = NGX_HTTP_GET;\n            r->method_name = ngx_http_core_get_method;\n        }\n        return ngx_http_internal_redirect(r, &uri, &args);\n    }\n    if (uri.len && uri.data[0] == '@') {\n        return ngx_http_named_location(r, &uri);\n    }\n    location = ngx_list_push(&r->headers_out.headers);\n    if (location == NULL) {\n        return NGX_ERROR;\n    }\n    if (overwrite != NGX_HTTP_MOVED_PERMANENTLY\n        && overwrite != NGX_HTTP_MOVED_TEMPORARILY\n        && overwrite != NGX_HTTP_SEE_OTHER\n        && overwrite != NGX_HTTP_TEMPORARY_REDIRECT\n        && overwrite != NGX_HTTP_PERMANENT_REDIRECT)\n    {\n        r->err_status = NGX_HTTP_MOVED_TEMPORARILY;\n    }\n    location->hash = 1;\n    ngx_str_set(&location->key, \"Location\");\n    location->value = uri;\n    ngx_http_clear_location(r);\n    r->headers_out.location = location;\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n    if (clcf->msie_refresh && r->headers_in.msie) {\n        return ngx_http_send_refresh(r);\n    }\n    return ngx_http_send_special_response(r, clcf, r->err_status\n                                                   - NGX_HTTP_MOVED_PERMANENTLY\n                                                   + NGX_HTTP_OFF_3XX);\n}", "target": 1}
{"code": "void LibRaw::convert_to_rgb_loop(float out_cam[3][4]) {}", "target": 0}
{"code": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}", "target": 1}
{"code": "R_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\tfree (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; \n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}", "target": 1}
{"code": "int gnutls_x509_ext_import_subject_alt_names(const gnutls_datum_t * ext,\n\t\t\t\t\t  gnutls_subject_alt_names_t sans,\n\t\t\t\t\t  unsigned int flags)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint result, ret;\n\tunsigned int i;\n\tgnutls_datum_t san, othername_oid;\n\tunsigned type;\n\tresult =\n\t    asn1_create_element(_gnutls_get_pkix(), \"PKIX1.GeneralNames\", &c2);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_der_decoding(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\ti = 0;\n\tdo {\n\t\tsan.data = NULL;\n\t\tsan.size = 0;\n\t\tothername_oid.data = NULL;\n\t\tret = _gnutls_parse_general_name2(c2, \"\", i, &san, &type, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (type == GNUTLS_SAN_OTHERNAME) {\n\t\t\tret =\n\t\t\t    _gnutls_parse_general_name2(c2, \"\", i,\n\t\t\t\t\t\t\t&othername_oid,\n\t\t\t\t\t\t\tNULL, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} else if (san.size == 0 || san.data == NULL) {\n\t\t\tret = gnutls_assert_val(GNUTLS_E_X509_UNKNOWN_SAN);\n\t\t\tbreak;\n\t\t}\n\t\tret = subject_alt_names_set(&sans->names, &sans->size,\n\t\t\t\t\t    type, &san,\n\t\t\t\t\t    (char *)othername_oid.data);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\ti++;\n\t} while (ret >= 0);\n\tsans->size = i;\n\tif (ret < 0 && ret != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\tgnutls_free(san.data);\n\t\tgnutls_free(othername_oid.data);\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tret = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "  String_Schema_Obj Parser::parse_css_variable_value(bool top_level)\n  {\n    String_Schema_Obj schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    String_Schema_Obj tok;\n    if (!(tok = parse_css_variable_value_token(top_level))) {\n      return {};\n    }\n    schema->concat(tok);\n    while ((tok = parse_css_variable_value_token(top_level))) {\n      schema->concat(tok);\n    }\n    return schema.detach();\n  }", "target": 1}
{"code": "SV*\nPerl_reg_named_buff_nextkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY;\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv = RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        while ( (temphe = hv_iternext_flags(hv, 0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n\t\treturn newSVhek(HeKEY_hek(temphe));\n            }\n        }\n    }\n    return NULL;", "target": 0}
{"code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n  if (!p_env) return NULL;\n  if (p_env->b_cdtext_error) return NULL;\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n      if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n        p_env->b_cdtext_error = true;\n        free(p_env->cdtext);\n        p_env->cdtext = NULL;\n      }\n      free(p_cdtext_data);\n    }\n  }\n  return p_env->cdtext;\n}", "target": 1}
{"code": "zzip_get_default_ext(void)\n{\n    static zzip_strings_t ext[] = {\n       \".zip\", \".ZIP\", \n#     ifdef ZZIP_USE_ZIPLIKES\n       \".pk3\", \".PK3\", \n       \".jar\", \".JAR\", \n#      endif\n        0\n    };\n    return ext;\n}", "target": 0}
{"code": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "process_mic(OM_uint32 *minor_status, gss_buffer_t mic_in,\n\t    spnego_gss_ctx_id_t sc, gss_buffer_t *mic_out,\n\t    OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_qop_t qop_state;\n\tgss_buffer_desc tmpmic = GSS_C_EMPTY_BUFFER;\n\tret = GSS_S_FAILURE;\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tret = gss_verify_mic(minor_status, sc->ctx_handle,\n\t\t\t\t     &sc->DER_mechTypes,\n\t\t\t\t     mic_in, &qop_state);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\t*negState = REJECT;\n\t\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\tsc->mic_reqd = 1;\n\t\tsc->mic_rcvd = 1;\n\t}\n\tif (sc->mic_reqd && !sc->mic_sent) {\n\t\tret = gss_get_mic(minor_status, sc->ctx_handle,\n\t\t\t\t  GSS_C_QOP_DEFAULT,\n\t\t\t\t  &sc->DER_mechTypes,\n\t\t\t\t  &tmpmic);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\t*mic_out = malloc(sizeof(gss_buffer_desc));\n\t\tif (*mic_out == GSS_C_NO_BUFFER) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t\t**mic_out = tmpmic;\n\t\tsc->mic_sent = 1;\n\t}\n\treturn GSS_S_COMPLETE;\n}", "target": 0}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    if (dtypes.size() < size_t{1}) {\n      return errors::Internal(\"Expected a list of at least one dtype\");\n    }\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((uint)(++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 0}
{"code": "static int snd_usb_cm6206_boot_quirk(struct usb_device *dev)\n{\n\tint err  = 0, reg;\n\tint val[] = {0x2004, 0x3000, 0xf800, 0x143f, 0x0000, 0x3000};\n\tfor (reg = 0; reg < ARRAY_SIZE(val); reg++) {\n\t\terr = snd_usb_cm106_write_int_reg(dev, reg, val[reg]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "void RenderView::didAcceptAutocompleteSuggestion(\n    const WebKit::WebInputElement& user_element) {\n#if defined(WEBKIT_BUG_41283_IS_FIXED)\n  bool result = password_autocomplete_manager_.FillPassword(user_element);\n  DCHECK(result);\n#endif\n}", "target": 0}
{"code": "pad_compress_skb(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *new_skb;\n\tint len;\n\tint new_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + ppp->dev->hard_header_len;\n\tint compressor_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + PPP_HDRLEN;\n\tnew_skb = alloc_skb(new_skb_size, GFP_ATOMIC);\n\tif (!new_skb) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"PPP: no memory (comp pkt)\\n\");\n\t\treturn NULL;\n\t}\n\tif (ppp->dev->hard_header_len > PPP_HDRLEN)\n\t\tskb_reserve(new_skb,\n\t\t\t    ppp->dev->hard_header_len - PPP_HDRLEN);\n\tlen = ppp->xcomp->compress(ppp->xc_state, skb->data - 2,\n\t\t\t\t   new_skb->data, skb->len + 2,\n\t\t\t\t   compressor_skb_size);\n\tif (len > 0 && (ppp->flags & SC_CCP_UP)) {\n\t\tkfree_skb(skb);\n\t\tskb = new_skb;\n\t\tskb_put(skb, len);\n\t\tskb_pull(skb, 2);\t\n\t} else if (len == 0) {\n\t\tkfree_skb(new_skb);\n\t\tnew_skb = skb;\n\t} else {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"ppp: compressor dropped pkt\\n\");\n\t\tkfree_skb(skb);\n\t\tkfree_skb(new_skb);\n\t\tnew_skb = NULL;\n\t}\n\treturn new_skb;\n}", "target": 0}
{"code": "static int linear_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct linear_c *lc = (struct linear_c *) ti->private;\n\treturn __blkdev_driver_ioctl(lc->dev->bdev, lc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink))\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "static int __init lp_setup (char *str)\n{\n\tstatic int parport_ptr;\n\tint x;\n\tif (get_option(&str, &x)) {\n\t\tif (x == 0) {\n\t\t\tparport_nr[0] = LP_PARPORT_OFF;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"warning: 'lp=0x%x' is deprecated, ignored\\n\", x);\n\t\t\treturn 0;\n\t\t}\n\t} else if (!strncmp(str, \"parport\", 7)) {\n\t\tint n = simple_strtoul(str+7, NULL, 10);\n\t\tif (parport_ptr < LP_NO)\n\t\t\tparport_nr[parport_ptr++] = n;\n\t\telse\n\t\t\tprintk(KERN_INFO \"lp: too many ports, %s ignored.\\n\",\n\t\t\t       str);\n\t} else if (!strcmp(str, \"auto\")) {\n\t\tparport_nr[0] = LP_PARPORT_AUTO;\n\t} else if (!strcmp(str, \"none\")) {\n\t\tparport_nr[parport_ptr++] = LP_PARPORT_NONE;\n\t} else if (!strcmp(str, \"reset\")) {\n\t\treset = 1;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\tmsg->msg_namelen = 0;\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\tkfree_skb(skb);\nend:\n\treturn err;\n}", "target": 1}
{"code": "void in6_dev_finish_destroy(struct inet6_dev *idev)\n{\n\tstruct net_device *dev = idev->dev;\n\tWARN_ON(!list_empty(&idev->addr_list));\n\tWARN_ON(idev->mc_list != NULL);\n\tWARN_ON(timer_pending(&idev->rs_timer));\n#ifdef NET_REFCNT_DEBUG\n\tpr_debug(\"%s: %s\\n\", __func__, dev ? dev->name : \"NIL\");\n#endif\n\tdev_put(dev);\n\tif (!idev->dead) {\n\t\tpr_warn(\"Freeing alive inet6 device %p\\n\", idev);\n\t\treturn;\n\t}\n\tsnmp6_free_dev(idev);\n\tkfree_rcu(idev, rcu);\n}", "target": 0}
{"code": "void Texture::Copy(const gfx::Size& size) {\n  DCHECK_NE(id_, 0u);\n  ScopedGLErrorSuppressor suppressor(decoder_);\n  ScopedTexture2DBinder binder(decoder_, id_);\n  glCopyTexImage2D(GL_TEXTURE_2D,\n                   0,  \n                   GL_RGBA,\n                   0, 0,\n                   size.width(),\n                   size.height(),\n                   0);  \n}", "target": 0}
{"code": "static struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_hdr(skb);\n\tstruct sk_buff *pp = NULL;\n\tstruct udphdr *uh2;\n\tstruct sk_buff *p;\n\tif (!uh->check) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\tskb_gro_pull(skb, sizeof(struct udphdr));\n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\t\tuh2 = udp_hdr(p);\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (uh->len > uh2->len || skb_gro_receive(p, skb) ||\n\t\t    uh->len != uh2->len ||\n\t\t    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)\n\t\t\tpp = p;\n\t\treturn pp;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC\n{\n\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, no*size);\n\treturn nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags);\n}", "target": 1}
{"code": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tint need_size = (int) ((char *) offset - memory + size);\n\tif (need_size < 0 || need_size > total_size) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "String UnbufferedAsioTlsStream::GetVerifyError() const\n{\n\treturn m_VerifyError;\n}", "target": 1}
{"code": "plugin_init (Ekiga::KickStart& kickstart)\n{\n#ifdef DEBUG\n  gchar* path = g_build_path (G_DIR_SEPARATOR_S,\n\t\t\t      g_get_tmp_dir (), \"ekiga_debug_plugins\", NULL);\n  plugin_parse_directory (kickstart, path);\n  g_free (path);\n#else\n  plugin_parse_directory (kickstart,\n\t\t\t  EKIGA_PLUGIN_DIR);\n#endif\n}", "target": 1}
{"code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\tprev = vma->vm_prev;\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock_write(vma->anon_vma);\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}", "target": 1}
{"code": "void RendererSchedulerImpl::OnShutdownTaskQueue(\n    const scoped_refptr<MainThreadTaskQueue>& task_queue) {\n  if (main_thread_only().was_shutdown)\n    return;\n  if (task_queue_throttler_)\n    task_queue_throttler_->ShutdownTaskQueue(task_queue.get());\n  if (task_runners_.erase(task_queue)) {\n    switch (task_queue->queue_class()) {\n       case MainThreadTaskQueue::QueueClass::kTimer:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().timer_task_cost_estimator);\n       case MainThreadTaskQueue::QueueClass::kLoading:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().loading_task_cost_estimator);\n       default:\n         break;\n     }\n  }\n}", "target": 1}
{"code": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}", "target": 1}
{"code": "sg_vma_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tSg_fd *sfp;\n\tunsigned long offset, len, sa;\n\tSg_scatter_hold *rsv_schp;\n\tint k, length;\n\tif ((NULL == vma) || (!(sfp = (Sg_fd *) vma->vm_private_data)))\n\t\treturn VM_FAULT_SIGBUS;\n\trsv_schp = &sfp->reserve;\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tif (offset >= rsv_schp->bufflen)\n\t\treturn VM_FAULT_SIGBUS;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t      \"sg_vma_fault: offset=%lu, scatg=%d\\n\",\n\t\t\t\t      offset, rsv_schp->k_use_sg));\n\tsa = vma->vm_start;\n\tlength = 1 << (PAGE_SHIFT + rsv_schp->page_order);\n\tfor (k = 0; k < rsv_schp->k_use_sg && sa < vma->vm_end; k++) {\n\t\tlen = vma->vm_end - sa;\n\t\tlen = (len < length) ? len : length;\n\t\tif (offset < len) {\n\t\t\tstruct page *page = nth_page(rsv_schp->pages[k],\n\t\t\t\t\t\t     offset >> PAGE_SHIFT);\n\t\t\tget_page(page);\t\n\t\t\tvmf->page = page;\n\t\t\treturn 0; \n\t\t}\n\t\tsa += len;\n\t\toffset -= len;\n\t}\n\treturn VM_FAULT_SIGBUS;\n}", "target": 0}
{"code": "int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)\n{\n\tstruct mosquitto_client_msg *tail;\n\tif(!context) return MOSQ_ERR_INVAL;\n\t*stored = NULL;\n\tDL_FOREACH(context->msgs_in.inflight, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\tDL_FOREACH(context->msgs_in.queued, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void decompTest(tjhandle handle, unsigned char *jpegBuf,\n\tunsigned long jpegSize, int w, int h, int pf, char *basename, int subsamp,\n\tint flags)\n{\n\tint i, n=0;\n\ttjscalingfactor *sf=tjGetScalingFactors(&n);\n\tif(!sf || !n) _throwtj();\n\tfor(i=0; i<n; i++)\n\t{\n\t\tif(subsamp==TJSAMP_444 || subsamp==TJSAMP_GRAY ||\n\t\t\t(subsamp==TJSAMP_411 && sf[i].num==1 &&\n\t\t\t\t(sf[i].denom==2 || sf[i].denom==1)) ||\n\t\t\t(subsamp!=TJSAMP_411 && sf[i].num==1 &&\n\t\t\t\t(sf[i].denom==4 || sf[i].denom==2 || sf[i].denom==1)))\n\t\t\t_decompTest(handle, jpegBuf, jpegSize, w, h, pf, basename, subsamp,\n\t\t\t\tflags, sf[i]);\n\t}\n\tbailout:\n\treturn;\n}", "target": 0}
{"code": "static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "static inline int qdisc_restart(struct net_device *dev)\n{\n\tstruct Qdisc *q = dev->qdisc;\n\tstruct sk_buff *skb;\n\tint ret = NETDEV_TX_BUSY;\n\tif (unlikely((skb = dev_dequeue_skb(dev, q)) == NULL))\n\t\treturn 0;\n\tspin_unlock(&dev->queue_lock);\n\tHARD_TX_LOCK(dev, smp_processor_id());\n\tif (!netif_subqueue_stopped(dev, skb))\n\t\tret = dev_hard_start_xmit(skb, dev);\n\tHARD_TX_UNLOCK(dev);\n\tspin_lock(&dev->queue_lock);\n\tq = dev->qdisc;\n\tswitch (ret) {\n\tcase NETDEV_TX_OK:\n\t\tret = qdisc_qlen(q);\n\t\tbreak;\n\tcase NETDEV_TX_LOCKED:\n\t\tret = handle_dev_cpu_collision(skb, dev, q);\n\t\tbreak;\n\tdefault:\n\t\tif (unlikely (ret != NETDEV_TX_BUSY && net_ratelimit()))\n\t\t\tprintk(KERN_WARNING \"BUG %s code %d qlen %d\\n\",\n\t\t\t       dev->name, ret, q->q.qlen);\n\t\tret = dev_requeue_skb(skb, dev, q);\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int ioapic_mmio_read(struct kvm_io_device *this, gpa_t addr, int len,\n\t\t\t    void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\tioapic_debug(\"addr %lx\\n\", (unsigned long)addr);\n\tASSERT(!(addr & 0xf));\t\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic, addr, len);\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int dns_stream_complete(DnsStream *s, int error) {\n        assert(s);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n        if (s->complete)\n                s->complete(s, error);\n        else \n                dns_stream_unref(s);\n        return 0;\n}", "target": 1}
{"code": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}", "target": 1}
{"code": "static inline void SMTPTransactionComplete(SMTPState *state)\n{\n    DEBUG_VALIDATE_BUG_ON(state->curr_tx == NULL);\n    if (state->curr_tx)\n        state->curr_tx->done = 1;\n}", "target": 1}
{"code": "int crxParamInit(CrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n  if (!paramBuf)\n    return -1;\n  *param = (CrxBandParam *)paramBuf;\n  paramBuf += sizeof(CrxBandParam);\n  (*param)->paramData = (int32_t *)paramBuf;\n  (*param)->nonProgrData =\n      progrDataSize ? (*param)->paramData + paramLength : 0;\n  (*param)->subbandWidth = subbandWidth;\n  (*param)->subbandHeight = subbandHeight;\n  (*param)->roundedBits = 0;\n  (*param)->curLine = 0;\n  (*param)->roundedBitsMask = roundedBitsMask;\n  (*param)->supportsPartial = supportsPartial;\n  (*param)->bitStream.bitData = 0;\n  (*param)->bitStream.bitsLeft = 0;\n  (*param)->bitStream.mdatSize = subbandDataSize;\n  (*param)->bitStream.curPos = 0;\n  (*param)->bitStream.curBufSize = 0;\n  (*param)->bitStream.curBufOffset = subbandMdatOffset;\n  (*param)->bitStream.input = input;\n  crxFillBuffer(&(*param)->bitStream);\n  return 0;\n}", "target": 1}
{"code": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\treturn present;\n}", "target": 1}
{"code": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}", "target": 1}
{"code": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}", "target": 1}
{"code": "void ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n   JpegOutput jpeg( filename );\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );\n   jpeg.cinfo().density_unit = 2; \n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); \n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}", "target": 1}
{"code": "fbFetchPixel_a4r4g4b4 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32  pixel = READ((CARD16 *) bits + offset);\n    CARD32  a,r,g,b;\n    a = ((pixel & 0xf000) | ((pixel & 0xf000) >> 4)) << 16;\n    r = ((pixel & 0x0f00) | ((pixel & 0x0f00) >> 4)) << 12;\n    g = ((pixel & 0x00f0) | ((pixel & 0x00f0) >> 4)) << 8;\n    b = ((pixel & 0x000f) | ((pixel & 0x000f) << 4));\n    return (a | r | g | b);\n}", "target": 0}
{"code": "static int scantag(const char* in, char* buffer, int* lenp) {\n    int len;\n    for (len = 0; len < 128; len++) {\n        const char c = *in++;\n        switch (c) {\n        case '\\0':\n            return 0;\n        case '<':\n            return 0;\n        case '>':\n            buffer[len] = '\\0';\n            *lenp = len+1;\n            return 1;\n        default:\n            break;\n        }\n        buffer[len] = c;\n    }\n    return 0;\n}", "target": 0}
{"code": "static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {\n        const char *v;\n        assert(handle);\n        assert(key);\n        v = pam_getenv(handle, key);\n        if (!isempty(v))\n                return v;\n        v = getenv(key);\n        if (!isempty(v))\n                return v;\n        return fallback;\n}", "target": 1}
{"code": "rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)\n{\n\tstruct list_head *tail_page, *to_remove, *next_page;\n\tstruct buffer_page *to_remove_page, *tmp_iter_page;\n\tstruct buffer_page *last_page, *first_page;\n\tunsigned long nr_removed;\n\tunsigned long head_bit;\n\tint page_entries;\n\thead_bit = 0;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\ttail_page = &cpu_buffer->tail_page->list;\n\tif (cpu_buffer->tail_page == cpu_buffer->reader_page)\n\t\ttail_page = rb_list_head(tail_page->next);\n\tto_remove = tail_page;\n\tfirst_page = list_entry(rb_list_head(to_remove->next),\n\t\t\t\tstruct buffer_page, list);\n\tfor (nr_removed = 0; nr_removed < nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->next;\n\t\thead_bit |= (unsigned long)to_remove & RB_PAGE_HEAD;\n\t}\n\tnext_page = rb_list_head(to_remove)->next;\n\ttail_page->next = (struct list_head *)((unsigned long)next_page |\n\t\t\t\t\t\thead_bit);\n\tnext_page = rb_list_head(next_page);\n\tnext_page->prev = tail_page;\n\tcpu_buffer->pages = next_page;\n\tif (head_bit)\n\t\tcpu_buffer->head_page = list_entry(next_page,\n\t\t\t\t\t\tstruct buffer_page, list);\n\tcpu_buffer->read = 0;\n\tatomic_dec(&cpu_buffer->record_disabled);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tRB_WARN_ON(cpu_buffer, list_empty(cpu_buffer->pages));\n\tlast_page = list_entry(rb_list_head(to_remove), struct buffer_page,\n\t\t\t\tlist);\n\ttmp_iter_page = first_page;\n\tdo {\n\t\tcond_resched();\n\t\tto_remove_page = tmp_iter_page;\n\t\trb_inc_page(&tmp_iter_page);\n\t\tpage_entries = rb_page_entries(to_remove_page);\n\t\tif (page_entries) {\n\t\t\tlocal_add(page_entries, &cpu_buffer->overrun);\n\t\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\t}\n\t\tfree_buffer_page(to_remove_page);\n\t\tnr_removed--;\n\t} while (to_remove_page != last_page);\n\tRB_WARN_ON(cpu_buffer, nr_removed);\n\treturn nr_removed == 0;\n}", "target": 0}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\t\tdown_write(&mm->mmap_sem);\n\t\tVM_WARN_ON(!mmget_still_valid(mm));\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "LibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR *sFile)\n    : LibRaw_buffer_datastream(NULL, 0), hMap_(0), pView_(NULL)\n{\n  HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING,\n                            FILE_ATTRIBUTE_NORMAL, 0);\n  if (hFile == INVALID_HANDLE_VALUE)\n    throw std::runtime_error(\"failed to open the file\");\n  try\n  {\n    Open(hFile);\n  }\n  catch (...)\n  {\n    CloseHandle(hFile);\n    throw;\n  }\n  CloseHandle(hFile); \n  reconstruct_base();\n}", "target": 0}
{"code": "int mempool_releasebuffer(MemoryPoolHandle handle, void *buf,\n                          size_t released_buffer_size) {\n  struct mempool *pool = (struct mempool *)handle;\n  struct memory_pool_element *pool_item = (struct memory_pool_element *)buf;\n  char *log_msg_fmt =\n      \"mempool(%p): mempool_releasebuffer called for invalid \"\n      \"released_buffer_size(%zu), current pool manages only \"\n      \"mempool_item_size(%zu)\";\n  char log_msg[300];\n  if ((pool == NULL) || (pool_item == NULL)) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n  if (pool->mempool_item_size != released_buffer_size) {\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               released_buffer_size, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_FATAL, log_msg);\n      return S3_MEMPOOL_INVALID_ARG;\n    }\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n  if ((pool->flags & ZEROED_BUFFER) != 0) {\n    memset(pool_item, 0, pool->mempool_item_size);\n  }\n  pool_item->next = pool->free_list;\n  pool->free_list = pool_item;\n  pool->free_bufs_in_pool++;\n  pool_item = NULL;\n  pool->number_of_bufs_shared--;\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n  }\n  return 0;\n}", "target": 0}
{"code": "get_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\treturn extensions;\n}", "target": 1}
{"code": "RSAES_PKCS1v1_5Encode(\n\t\t      TPM2B       *padded,        \n\t\t      TPM2B       *message,       \n\t\t      RAND_STATE  *rand\n\t\t      )\n{\n    UINT32      ps = padded->size - message->size - 3;\n    if(message->size > padded->size - 11)\n\treturn TPM_RC_VALUE;\n    memcpy(&padded->buffer[padded->size - message->size], message->buffer,\n\t   message->size);\n    padded->buffer[0] = 0;\n    padded->buffer[1] = 2;\n    DRBG_Generate(rand, &padded->buffer[2], (UINT16)ps);\n    padded->buffer[2 + ps] = 0;\n    for(ps++; ps > 1; ps--)\n\t{\n\t    if(padded->buffer[ps] == 0)\n\t\tpadded->buffer[ps] = 0x55;  \n\t}\n    return TPM_RC_SUCCESS;\n}", "target": 0}
{"code": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\tblkif->st_ds_req++;\n\txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}", "target": 1}
{"code": "static void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "bool lua_datum::is_number() const\n{\n    LUA_CHECK_TYPE(lua_isnumber);\n}", "target": 0}
{"code": "int blkid_probe_is_covered_by_pt(blkid_probe pr,\n\t\t\t\t uint64_t offset, uint64_t size)\n{\n\tblkid_probe prc = NULL;\n\tblkid_partlist ls = NULL;\n\tuint64_t start, end;\n\tint nparts, i, rc = 0;\n\tDBG(LOWPROBE, ul_debug(\n\t\t\"=> checking if off=%\"PRIu64\" size=%\"PRIu64\" covered by PT\",\n\t\toffset, size));\n\tif (pr->flags & BLKID_FL_NOSCAN_DEV)\n\t\tgoto done;\n\tprc = blkid_clone_probe(pr);\n\tif (!prc)\n\t\tgoto done;\n\tls = blkid_probe_get_partitions(prc);\n\tif (!ls)\n\t\tgoto done;\n\tnparts = blkid_partlist_numof_partitions(ls);\n\tif (!nparts)\n\t\tgoto done;\n\tend = (offset + size) >> 9;\n\tstart = offset >> 9;\n\tfor (i = 0; i < nparts; i++) {\n\t\tblkid_partition par = &ls->parts[i];\n\t\tif (par->start + par->size > (pr->size >> 9)) {\n\t\t\tDBG(LOWPROBE, ul_debug(\"partition #%d overflows \"\n\t\t\t\t\"device (off=%\" PRId64 \" size=%\" PRId64 \")\",\n\t\t\t\tpar->partno, par->start, par->size));\n\t\t\tgoto done;\n\t\t}\n\t}\n\tfor (i = 0; i < nparts; i++) {\n\t\tblkid_partition par = &ls->parts[i];\n\t\tif (start >= par->start && end <= par->start + par->size) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tblkid_free_probe(prc);\n\tDBG(LOWPROBE, ul_debug(\"<= %s covered by PT\", rc ? \"IS\" : \"NOT\"));\n\treturn rc;\n}", "target": 0}
{"code": "void PCM::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tif (m_track->totalfframes != -1 &&\n\t\tm_track->nextfframe + framesToRead > m_track->totalfframes)\n\t{\n\t\tframesToRead = m_track->totalfframes - m_track->nextfframe;\n\t}\n\tssize_t bytesRead = read(m_outChunk->buffer, m_bytesPerFrame * framesToRead);\n\tAFframecount framesRead = bytesRead >= 0 ? bytesRead / m_bytesPerFrame : 0;\n\tCHNK(printf(\"reading %\" AF_FRAMECOUNT_PRINT_FMT \" frames from pcm file \"\n\t\t\"(got %\" AF_FRAMECOUNT_PRINT_FMT \")\\n\",\n\t\tframesToRead, framesRead));\n\tm_track->nextfframe += framesRead;\n\tm_track->fpos_next_frame += (framesRead>0) ? framesRead * m_bytesPerFrame : 0;\n\tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n\tif (framesRead != framesToRead && m_track->totalfframes != -1)\n\t{\n\t\tif (m_track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ,\n\t\t\t\t\"file missing data -- read %d frames, \"\n\t\t\t\t\"should be %d\",\n\t\t\t\tm_track->nextfframe,\n\t\t\t\tm_track->totalfframes);\n\t\t\tm_track->filemodhappy = false;\n\t\t}\n\t}\n\tm_outChunk->frameCount = framesRead;\n}", "target": 0}
{"code": "GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "  Compound_Selector_Obj Parser::parse_compound_selector()\n  {\n    Compound_Selector_Obj seq = SASS_MEMORY_NEW(Compound_Selector, pstate);\n    seq->media_block(last_media_block);\n    lex< css_whitespace >();\n    while (true)\n    {\n      lex< delimited_by< slash_star, star_slash, false > >(false);\n      if (match < re_pseudo_selector >())\n      {\n        seq->append(parse_simple_selector());\n      }\n      else if (lex< exactly<'&'> >(false))\n      {\n        if (!allow_parent) error(\"Parent selectors aren't allowed here.\");\n        seq->has_parent_reference(true);\n        seq->append(SASS_MEMORY_NEW(Parent_Selector, pstate));\n        if (seq->length() > 1) {\n          ParserState state(pstate);\n          Simple_Selector_Obj cur = (*seq)[seq->length()-1];\n          Simple_Selector_Obj prev = (*seq)[seq->length()-2];\n          std::string sel(prev->to_string({ NESTED, 5 }));\n          std::string found(cur->to_string({ NESTED, 5 }));\n          if (lex < identifier >()) { found += std::string(lexed); }\n          error(\"Invalid CSS after \\\"\" + sel + \"\\\": expected \\\"{\\\", was \\\"\" + found + \"\\\"\\n\\n\"\n            \"\\\"\" + found + \"\\\" may only be used at the beginning of a compound selector.\", state);\n        }\n      }\n      else if (lex< re_type_selector >(false))\n      {\n        seq->append(SASS_MEMORY_NEW(Type_Selector, pstate, lexed));\n      }\n      else if (peek< spaces >()) break;\n      else if (peek< end_of_file >()) { break; }\n      else if (peek_css < class_char < selector_combinator_ops > >()) break;\n      else if (peek_css < class_char < complex_selector_delims > >()) break;\n      else {\n        Simple_Selector_Obj sel = parse_simple_selector();\n        if (!sel) return {};\n        seq->append(sel);\n      }\n    }\n    if (seq && !peek_css<alternatives<end_of_file,exactly<'{'>>>()) {\n      seq->has_line_break(peek_newline());\n    }\n    return seq;\n  }", "target": 0}
{"code": "static int nf_tables_bind_check_setelem(const struct nft_ctx *ctx,\n\t\t\t\t\tconst struct nft_set *set,\n\t\t\t\t\tconst struct nft_set_iter *iter,\n\t\t\t\t\tconst struct nft_set_elem *elem)\n{\n\tenum nft_registers dreg;\n\tdreg = nft_type_to_reg(set->dtype);\n\treturn nft_validate_data_load(ctx, dreg, &elem->data,\n\t\t\t\t      set->dtype == NFT_DATA_VERDICT ?\n\t\t\t\t      NFT_DATA_VERDICT : NFT_DATA_VALUE);\n}", "target": 0}
{"code": "libxlDomainCreateChannelPTY(virDomainDef *def, libxl_ctx *ctx)\n{\n    libxl_device_channel *x_channels;\n    virDomainChrDef *chr;\n    size_t i;\n    int nchannels;\n    x_channels = libxl_device_channel_list(ctx, def->id, &nchannels);\n    if (!x_channels)\n        return;\n    for (i = 0; i < def->nchannels; i++) {\n        libxl_channelinfo channelinfo;\n        int ret;\n        chr = def->channels[i];\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_PTY)\n            continue;\n        ret = libxl_device_channel_getinfo(ctx, def->id, &x_channels[i],\n                                           &channelinfo);\n        if (!ret && channelinfo.u.pty.path &&\n            *channelinfo.u.pty.path != '\\0') {\n                VIR_FREE(chr->source->data.file.path);\n                chr->source->data.file.path = g_strdup(channelinfo.u.pty.path);\n            }\n    }\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n}", "target": 0}
{"code": "static long vsock_dev_ioctl(struct file *filp,\n\t\t\t    unsigned int cmd, unsigned long arg)\n{\n\treturn vsock_dev_do_ioctl(filp, cmd, (void __user *)arg);\n}", "target": 0}
{"code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n        }\n    }\n    if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n    }\n    buffer_string_set_length(b, j);\n    return qs;\n}", "target": 1}
{"code": "vte_sequence_handler_UP (VteTerminal *terminal, GValueArray *params)\n{\n\tvte_sequence_handler_multiple(terminal, params, vte_sequence_handler_up);\n}", "target": 0}
{"code": "int JOIN::init_join_caches()\n{\n  JOIN_TAB *tab;\n  for (tab= first_linear_tab(this, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab;\n       tab= next_linear_tab(this, tab, WITH_BUSH_ROOTS))\n  {\n    TABLE *table= tab->table;\n    if (table->file->keyread_enabled())\n    {\n      if (!(table->file->index_flags(table->file->keyread, 0, 1) & HA_CLUSTERED_INDEX))\n        table->mark_index_columns(table->file->keyread, table->read_set);\n    }\n    else if ((tab->read_first_record == join_read_first ||\n              tab->read_first_record == join_read_last) &&\n             !tab->filesort && table->covering_keys.is_set(tab->index) &&\n             !table->no_keyread)\n    {\n      table->prepare_for_keyread(tab->index, table->read_set);\n    }\n    if (tab->cache && tab->cache->init(select_options & SELECT_DESCRIBE))\n      revise_cache_usage(tab);\n    else\n      tab->remove_redundant_bnl_scan_conds();\n  }\n  return 0;\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\tstatus = table->DeleteSecurityContext(phContext);\n\treturn status;\n}", "target": 1}
{"code": "void getconsxy(struct vc_data *vc, unsigned char *p)\n{\n\tp[0] = min(vc->vc_x, 0xFFu);\n\tp[1] = min(vc->vc_y, 0xFFu);\n}", "target": 0}
{"code": "void PngImg::InitStorage_() {\n    rowPtrs_.resize(info_.height, nullptr);\n    data_ = new png_byte[info_.height * info_.rowbytes];\n    for(size_t i = 0; i < info_.height; ++i) {\n        rowPtrs_[i] = data_ + i * info_.rowbytes;\n    }\n}", "target": 1}
{"code": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\ttss_invalidate_io_bitmap(tss);\n\t\treturn;\n\t}\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\trefresh_tss_limit();\n}", "target": 1}
{"code": "void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 0}
{"code": "av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}", "target": 1}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void vgacon_flush_scrollback(struct vc_data *c)\n{\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tvgacon_scrollback_reset(c->vc_num, size);\n}", "target": 1}
{"code": "void http_capture_bad_message(struct error_snapshot *es, struct session *s,\n                              struct buffer *buf, struct http_msg *msg,\n\t\t\t      int state, struct proxy *other_end)\n{\n\tif (buf->r <= (buf->data + msg->som)) { \n\t\tint len1 = buf->size - msg->som;\n\t\tes->len = buf->r - (buf->data + msg->som) + buf->size;\n\t\tmemcpy(es->buf, buf->data + msg->som, MIN(len1, sizeof(es->buf)));\n\t\tif (es->len > len1 && len1 < sizeof(es->buf))\n\t\t\tmemcpy(es->buf + len1, buf->data, MIN(es->len, sizeof(es->buf)) - len1);\n\t}\n\telse {\n\t\tes->len = buf->r - (buf->data + msg->som);\n\t\tmemcpy(es->buf, buf->data + msg->som, MIN(es->len, sizeof(es->buf)));\n\t}\n\tif (msg->err_pos >= 0)\n\t\tes->pos  = msg->err_pos - msg->som;\n\telse if (buf->lr >= (buf->data + msg->som))\n\t\tes->pos  = buf->lr - (buf->data + msg->som);\n\telse\n\t\tes->pos  = buf->lr - (buf->data + msg->som) + buf->size;\n\tes->when = date; \n\tes->sid  = s->uniq_id;\n\tes->srv  = s->srv;\n\tes->oe   = other_end;\n\tes->src  = s->cli_addr;\n\tes->state = state;\n\tes->flags = buf->flags;\n\tes->ev_id = error_snapshot_id++;\n}", "target": 0}
{"code": "add_compile_string(UChar* s, int mb_len, OnigDistance byte_len,\n                   regex_t* reg, int ignore_case)\n{\n  int op = select_str_opcode(mb_len, byte_len, ignore_case);\n  add_opcode(reg, op);\n  if (op == OP_EXACTMBN)\n    add_length(reg, mb_len);\n  if (IS_NEED_STR_LEN_OP_EXACT(op)) {\n    if (op == OP_EXACTN_IC)\n      add_length(reg, byte_len);\n    else\n      add_length(reg, byte_len / mb_len);\n  }\n  add_bytes(reg, s, byte_len);\n  return 0;\n}", "target": 0}
{"code": "  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }", "target": 1}
{"code": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\text2_xattr_put_super(sb);\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}", "target": 1}
{"code": "void PDPSimple::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->tlm_ != nullptr)\n    {\n        mp_builtin->tlm_->assign_remote_endpoints(pdata);\n    }\n}", "target": 1}
{"code": "ikev2_sa_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext1,\n\t\tu_int osa_length, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth)\n{\n\tconst struct isakmp_gen *ext;\n\tstruct isakmp_gen e;\n\tu_int sa_length;\n\tconst u_char *cp;\n\tint i;\n\tint pcount;\n\tu_char np;\n\tu_int item_len;\n\tND_TCHECK(*ext1);\n\tUNALIGNED_MEMCPY(&e, ext1, sizeof(e));\n\tikev2_pay_print(ndo, \"sa\", e.critical);\n\tosa_length= ntohs(e.len);\n\tsa_length = osa_length - 4;\n\tND_PRINT((ndo,\" len=%d\", sa_length));\n\tcp = (const u_char *)(ext1 + 1);\n\tpcount = 0;\n\tfor (np = ISAKMP_NPTYPE_P; np != 0; np = e.np) {\n\t\tpcount++;\n\t\text = (const struct isakmp_gen *)cp;\n\t\tif (sa_length < sizeof(*ext))\n\t\t\tgoto toolong;\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\titem_len = ntohs(e.len);\n\t\tif (item_len <= 4)\n\t\t\tgoto trunc;\n\t\tif (sa_length < item_len)\n\t\t\tgoto toolong;\n\t\tND_TCHECK2(*cp, item_len);\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tif (np == ISAKMP_NPTYPE_P) {\n\t\t\tcp = ikev2_p_print(ndo, np, pcount, ext, item_len,\n\t\t\t\t\t   ep, depth);\n\t\t\tif (cp == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s\", NPSTR(np)));\n\t\t\tcp += item_len;\n\t\t}\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tsa_length -= item_len;\n\t}\n\treturn cp;\ntoolong:\n\tcp += sa_length;\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "void undefer_input(__G)\n    __GDEF\n{\n    if (G.incnt > 0)\n        G.csize += G.incnt;\n    if (G.incnt_leftover > 0) {\n        G.incnt = G.incnt_leftover + (int)G.csize;\n        G.inptr = G.inptr_leftover - (int)G.csize;\n        G.incnt_leftover = 0;\n    } else if (G.incnt < 0)\n        G.incnt = 0;\n} ", "target": 1}
{"code": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n}", "target": 1}
{"code": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n{\n\tva_list va;\n\tchar *message = NULL;\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\tefree(message);\n\tva_end(va);\n}", "target": 1}
{"code": "void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n\tacpi_custom_method_init();\n}", "target": 1}
{"code": "static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n{\n\tuint64_t val = 0;\n\tuint16_t year = le32_to_cpu(timestamp->year);\n\tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n\tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n\tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n\tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n\tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n\tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n\tval |= ((uint64_t) year) << (6*8);\n\treturn val;\n}", "target": 1}
{"code": "PGTYPESinterval_from_asc(char *str, char **endptr)\n{\n\tinterval   *result = NULL;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\tfsec = 0;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\t(DecodeInterval(field, ftype, nf, &dtype, tm, &fsec) != 0 &&\n\t\t DecodeISO8601Interval(str, &dtype, tm, &fsec) != 0))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tresult = (interval *) pgtypes_alloc(sizeof(interval));\n\tif (!result)\n\t\treturn NULL;\n\tif (dtype != DTK_DELTA)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\tif (tm2interval(tm, fsec, result) != 0)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "  virtual void requestInit() {\n    m_use_error = false;\n    m_errors.reset();\n    xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }", "target": 1}
{"code": "unsigned long ossl_lh_strcasehash(const char *c)\n{\n    unsigned long ret = 0;\n    long n;\n    unsigned long v;\n    int r;\n    if (c == NULL || *c == '\\0')\n        return ret;\n    for (n = 0x100; *c != '\\0'; n += 0x100) {\n        v = n | ossl_tolower(*c);\n        r = (int)((v >> 2) ^ v) & 0x0f;\n        ret = (ret << r) | (unsigned long)((uint64_t)ret >> (32 - r));\n        ret &= 0xFFFFFFFFL;\n        ret ^= v * v;\n        c++;\n    }\n    return (ret >> 16) ^ ret;\n}", "target": 0}
{"code": "mysql_stmt_row_tell(MYSQL_STMT *stmt)\n{\n  DBUG_ENTER(\"mysql_stmt_row_tell\");\n  DBUG_RETURN(stmt->data_cursor);\n}", "target": 0}
{"code": "static inline void *freelist_dereference(const struct kmem_cache *s,\n\t\t\t\t\t void *ptr_addr)\n{\n\treturn freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr),\n\t\t\t    (unsigned long)ptr_addr);\n}", "target": 0}
{"code": "GF_Err gf_isom_wma_enum_tag(GF_ISOFile *mov, u32 idx, char **out_tag, const u8 **data, u32 *data_len, u32 *version, u32 *data_type)\n{\n\tGF_XtraBox *xtra;\n\tGF_XtraTag *tag;\n\t*out_tag = NULL;\n\t*data = NULL;\n\t*data_len = 0;\n\t*version = 0;\n\t*data_type = 0;\n\txtra = (GF_XtraBox *) gf_isom_get_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_URL_ERROR;\n\ttag = gf_list_get(xtra->tags, idx);\n\tif (!tag) return GF_NOT_FOUND;\n\t*out_tag = tag->name;\n\t*data_len = tag->prop_size;\n\t*data = tag->prop_value;\n\t*version = tag->flags;\n\t*data_type = tag->prop_type;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int adpt_queue_lck(struct scsi_cmnd *cmd)\n{\n\tadpt_hba* pHba = NULL;\n\tstruct adpt_device* pDev = NULL;\t\n\tif ((cmd->cmnd[0] == REQUEST_SENSE) && (cmd->sense_buffer[0] != 0)) {\n\t\tcmd->result = (DID_OK << 16);\n\t\tscsi_done(cmd);\n\t\treturn 0;\n\t}\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tif (!pHba) {\n\t\treturn FAILED;\n\t}\n\trmb();\n\tif ((pHba->state) & DPTI_STATE_RESET)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\tif((pDev = (struct adpt_device*) (cmd->device->hostdata)) == NULL) {\n\t\tif ((pDev = adpt_find_device(pHba, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun)) == NULL) {\n\t\t\tcmd->result = (DID_NO_CONNECT << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tcmd->device->hostdata = pDev;\n\t}\n\tpDev->pScsi_dev = cmd->device;\n\tif (pDev->state & DPTI_DEV_RESET ) {\n\t\treturn FAILED;\n\t}\n\treturn adpt_scsi_to_i2o(pHba, cmd, pDev);\n}", "target": 1}
{"code": "static void handle_irq_for_port(evtchn_port_t port)\n{\n\tint irq;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq != -1)\n\t\tgeneric_handle_irq(irq);\n}", "target": 1}
{"code": "FILE *mingw_fopen (const char *filename, const char *otype)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfopen(wfilename, wotype);\n\tif (!file && GetLastError() == ERROR_INVALID_NAME)\n\t\terrno = ENOENT;\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}", "target": 0}
{"code": "Opal::Call::transfer (std::string uri)\n{\n  PSafePtr<OpalConnection> connection = get_remote_connection ();\n  if (connection != NULL)\n    connection->TransferConnection (uri);\n}", "target": 0}
{"code": "int git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\t\ti++;\n\t}\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\treturn git_pkt_buffer_flush(buf);\n}", "target": 0}
{"code": "int kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\tinit_emulate_ctxt(vcpu);\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\tctxt->eip = ctxt->_eip;\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = 0;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\treturn EMULATE_DONE;\n}", "target": 0}
{"code": "do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)\n{\n\tstruct sched_param lparam;\n\tstruct task_struct *p;\n\tint retval;\n\tif (!param || pid < 0)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&lparam, param, sizeof(struct sched_param)))\n\t\treturn -EFAULT;\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setscheduler(p, policy, &lparam);\n\trcu_read_unlock();\n\treturn retval;\n}", "target": 0}
{"code": "static int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}", "target": 1}
{"code": "  scoped_refptr<TransportSocketParams> GetTcpParams() {\n    if (GetParam() != HTTP)\n      return scoped_refptr<TransportSocketParams>();\n    return ignored_transport_socket_params_;\n  }", "target": 0}
{"code": "    int MemIo::seek(int64 offset, Position pos )\n    {\n        int64 newIdx = 0;\n        switch (pos) {\n            case BasicIo::cur:\n                newIdx = p_->idx_ + offset;\n                break;\n            case BasicIo::beg:\n                newIdx = offset;\n                break;\n            case BasicIo::end:\n                newIdx = p_->size_ + offset;\n                break;\n        }\n        if (newIdx < 0)\n            return 1;\n        p_->idx_ = static_cast<long>(newIdx);   \n        p_->eof_ = false;\n        return 0;\n    }", "target": 1}
{"code": "void CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    ParaNdis_CheckSumVerifyFlat(IpHeader,\n                                EthPayloadLength,\n                                pcrIpChecksum | pcrFixIPChecksum,\n                                __FUNCTION__);\n}", "target": 1}
{"code": "ShelfDelegate* Shell::GetShelfDelegate() {\n  if (!shelf_delegate_) {\n    shelf_model_.reset(new ShelfModel);\n    shelf_item_delegate_manager_.reset(\n        new ShelfItemDelegateManager(shelf_model_.get()));\n    shelf_delegate_.reset(delegate_->CreateShelfDelegate(shelf_model_.get()));\n    scoped_ptr<ShelfItemDelegate> controller(new AppListShelfItemDelegate);\n    int app_list_index = shelf_model_->GetItemIndexForType(TYPE_APP_LIST);\n    DCHECK_GE(app_list_index, 0);\n    ShelfID app_list_id = shelf_model_->items()[app_list_index].id;\n    DCHECK(app_list_id);\n    shelf_item_delegate_manager_->SetShelfItemDelegate(app_list_id,\n                                                       std::move(controller));\n    shelf_window_watcher_.reset(new ShelfWindowWatcher(\n        shelf_model_.get(), shelf_item_delegate_manager_.get()));\n  }\n  return shelf_delegate_.get();\n}", "target": 0}
{"code": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 2;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tint l2 = 33 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc/%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc/%s/%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}", "target": 1}
{"code": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\treturn security_ptrace_access_check(task, mode);\n}", "target": 1}
{"code": "static inline void pmd_populate(struct mm_struct *mm,\n\t\t\t\tpmd_t *pmd, pgtable_t pte)\n{\n\tpmd_val(*pmd) = _SEGMENT_ENTRY + __pa(pte);\n}", "target": 0}
{"code": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "Server::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n    Must(io.conn->fd == clientConnection->fd);\n    if (io.flag && pipeline.front())\n        pipeline.front()->initiateClose(\"write failure\");\n    afterClientWrite(io.size); \n    writeSomeData(); \n}", "target": 1}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; \n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}", "target": 1}
{"code": "static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\n\t\t\tstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\n{\n\tstruct activation_params_nfca_poll_iso_dep *nfca_poll;\n\tstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\tnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\n\t\tnfca_poll->rats_res_len = *data++;\n\t\tpr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);\n\t\tif (nfca_poll->rats_res_len > 0) {\n\t\t\tmemcpy(nfca_poll->rats_res,\n\t\t\t       data, nfca_poll->rats_res_len);\n\t\t}\n\t\tbreak;\n\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\tnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\n\t\tnfcb_poll->attrib_res_len = *data++;\n\t\tpr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);\n\t\tif (nfcb_poll->attrib_res_len > 0) {\n\t\t\tmemcpy(nfcb_poll->attrib_res,\n\t\t\t       data, nfcb_poll->attrib_res_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\treturn NCI_STATUS_OK;\n}", "target": 1}
{"code": "int sldns_str2wire_tsigerror_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tsldns_lookup_table *lt = sldns_lookup_by_name(sldns_tsig_errors, str);\n\tif(*len < 2)\n\t\treturn LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL;\n\tif(lt) {\n\t\tsldns_write_uint16(rd, (uint16_t)lt->id);\n\t\t*len = 2;\n\t} else {\n\t\treturn sldns_str2wire_int16_buf(str, rd, len);\n\t}\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tpipe_buf_get(ipipe, ibuf);\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\treturn ret;\n}", "target": 1}
{"code": "ff_layout_ntop6_noscopeid(const struct sockaddr *sap, char *buf,\n\t\t\t  const int buflen)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tconst struct in6_addr *addr = &sin6->sin6_addr;\n\tif (ipv6_addr_any(addr))\n\t\treturn snprintf(buf, buflen, \"::\");\n\tif (ipv6_addr_loopback(addr))\n\t\treturn snprintf(buf, buflen, \"::1\");\n\tif (ipv6_addr_v4mapped(addr))\n\t\treturn snprintf(buf, buflen, \"::ffff:%pI4\",\n\t\t\t\t\t&addr->s6_addr32[3]);\n\treturn snprintf(buf, buflen, \"%pI6c\", addr);\n}", "target": 0}
{"code": "GF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\tif (stsz->sampleSize) {\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}", "target": 1}
{"code": "mptctl_eventquery (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventquery\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventquery() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventquery called.\\n\",\n\t    ioc->name));\n\tkarg.eventEntries = MPTCTL_EVENT_LOG_SIZE;\n\tkarg.eventTypes = ioc->eventTypes;\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}", "target": 1}
{"code": "static struct nft_stats __percpu *nft_stats_alloc(const struct nlattr *attr)\n{\n\tstruct nlattr *tb[NFTA_COUNTER_MAX+1];\n\tstruct nft_stats __percpu *newstats;\n\tstruct nft_stats *stats;\n\tint err;\n\terr = nla_parse_nested(tb, NFTA_COUNTER_MAX, attr, nft_counter_policy);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\tif (!tb[NFTA_COUNTER_BYTES] || !tb[NFTA_COUNTER_PACKETS])\n\t\treturn ERR_PTR(-EINVAL);\n\tnewstats = netdev_alloc_pcpu_stats(struct nft_stats);\n\tif (newstats == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstats = this_cpu_ptr(newstats);\n\tstats->bytes = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_BYTES]));\n\tstats->pkts = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_PACKETS]));\n\treturn newstats;\n}", "target": 0}
{"code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "static int sg_proc_seq_show_debug(struct seq_file *s, void *v)\n{\n\tstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\n\tSg_device *sdp;\n\tunsigned long iflags;\n\tif (it && (0 == it->index))\n\t\tseq_printf(s, \"max_active_device=%d  def_reserved_size=%d\\n\",\n\t\t\t   (int)it->max, sg_big_buff);\n\tread_lock_irqsave(&sg_index_lock, iflags);\n\tsdp = it ? sg_lookup_dev(it->index) : NULL;\n\tif (NULL == sdp)\n\t\tgoto skip;\n\tread_lock(&sdp->sfd_lock);\n\tif (!list_empty(&sdp->sfds)) {\n\t\tseq_printf(s, \" >>> device=%s \", sdp->disk->disk_name);\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\tseq_puts(s, \"detaching pending close \");\n\t\telse if (sdp->device) {\n\t\t\tstruct scsi_device *scsidp = sdp->device;\n\t\t\tseq_printf(s, \"%d:%d:%d:%llu   em=%d\",\n\t\t\t\t   scsidp->host->host_no,\n\t\t\t\t   scsidp->channel, scsidp->id,\n\t\t\t\t   scsidp->lun,\n\t\t\t\t   scsidp->host->hostt->emulated);\n\t\t}\n\t\tseq_printf(s, \" sg_tablesize=%d excl=%d open_cnt=%d\\n\",\n\t\t\t   sdp->sg_tablesize, sdp->exclude, sdp->open_cnt);\n\t\tsg_proc_debug_helper(s, sdp);\n\t}\n\tread_unlock(&sdp->sfd_lock);\nskip:\n\tread_unlock_irqrestore(&sg_index_lock, iflags);\n\treturn 0;\n}", "target": 0}
{"code": "gif_main_loop (GifContext *context)\n{\n\tgint retval = 0;\n\tdo {\n\t\tswitch (context->state) {\n\t\tcase GIF_START:\n                        LOG(\"start\\n\");\n\t\t\tretval = gif_init (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_COLORMAP:\n                        LOG(\"get_colormap\\n\");\n\t\t\tretval = gif_get_colormap (context);\n\t\t\tif (retval == 0)\n\t\t\t\tcontext->state = GIF_GET_NEXT_STEP;\n\t\t\tbreak;\n\t\tcase GIF_GET_NEXT_STEP:\n                        LOG(\"next_step\\n\");\n\t\t\tretval = gif_get_next_step (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_FRAME_INFO:\n                        LOG(\"frame_info\\n\");\n\t\t\tretval = gif_get_frame_info (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_EXTENSION:\n                        LOG(\"get_extension\\n\");\n\t\t\tretval = gif_get_extension (context);\n\t\t\tif (retval == 0)\n\t\t\t\tcontext->state = GIF_GET_NEXT_STEP;\n\t\t\tbreak;\n\t\tcase GIF_GET_COLORMAP2:\n                        LOG(\"get_colormap2\\n\");\n\t\t\tretval = gif_get_colormap2 (context);\n\t\t\tif (retval == 0)\n\t\t\t\tgif_set_prepare_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_PREPARE_LZW:\n                        LOG(\"prepare_lzw\\n\");\n\t\t\tretval = gif_prepare_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_LZW_FILL_BUFFER:\n                        LOG(\"fill_buffer\\n\");\n\t\t\tretval = gif_lzw_fill_buffer (context);\n\t\t\tbreak;\n\t\tcase GIF_LZW_CLEAR_CODE:\n                        LOG(\"clear_code\\n\");\n\t\t\tretval = gif_lzw_clear_code (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_LZW:\n                        LOG(\"get_lzw\\n\");\n\t\t\tretval = gif_get_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_DONE:\n                        LOG(\"done\\n\");\n\t\tdefault:\n\t\t\tretval = 0;\n\t\t\tgoto done;\n\t\t};\n\t} while ((retval == 0) || (retval == -3));\n done:\n\treturn retval;\n}", "target": 0}
{"code": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}", "target": 1}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "make_absent_engine(Node** node, int pre_save_right_id, Node* absent,\n                   Node* step_one, int lower, int upper, int possessive,\n                   int is_range_cutter, ScanEnv* env)\n{\n  int r;\n  int i;\n  int id;\n  Node* x;\n  Node* ns[4];\n  for (i = 0; i < 4; i++) ns[i] = NULL_NODE;\n  ns[1] = absent;\n  ns[3] = step_one; \n  r = node_new_save_gimmick(&ns[0], SAVE_S, env);\n  if (r != 0) goto err;\n  id = GIMMICK_(ns[0])->id;\n  r = node_new_update_var_gimmick(&ns[2], UPDATE_VAR_RIGHT_RANGE_FROM_S_STACK,\n                                  id, env);\n  if (r != 0) goto err;\n  r = node_new_fail(&ns[3], env);\n  if (r != 0) goto err;\n  x = make_list(4, ns);\n  if (IS_NULL(x)) goto err0;\n  ns[0] = x;\n  ns[1] = step_one;\n  ns[2] = ns[3] = NULL_NODE;\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n  ns[0] = x;\n  x = node_new_quantifier(lower, upper, 0);\n  if (IS_NULL(x)) goto err0;\n  NODE_BODY(x) = ns[0];\n  ns[0] = x;\n  if (possessive != 0) {\n    x = node_new_enclosure(ENCLOSURE_STOP_BACKTRACK);\n    if (IS_NULL(x)) goto err0;\n    NODE_BODY(x) = ns[0];\n    ns[0] = x;\n  }\n  r = node_new_update_var_gimmick(&ns[1], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  pre_save_right_id, env);\n  if (r != 0) goto err;\n  r = node_new_fail(&ns[2], env);\n  if (r != 0) goto err;\n  x = make_list(2, ns + 1);\n  if (IS_NULL(x)) goto err0;\n  ns[1] = x; ns[2] = NULL_NODE;\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n  if (is_range_cutter != 0)\n    NODE_STATUS_ADD(x, NST_SUPER);\n  *node = x;\n  return ONIG_NORMAL;\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  for (i = 0; i < 4; i++) onig_node_free(ns[i]);\n  return r;\n}", "target": 0}
{"code": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n}", "target": 1}
{"code": "static inline void constructBidiRunsForSegment(InlineBidiResolver& topResolver, BidiRunList<BidiRun>& bidiRuns, const InlineIterator& endOfRuns, VisualDirectionOverride override, bool previousLineBrokeCleanly)\n{\n    ASSERT(&topResolver.runs() == &bidiRuns);\n    ASSERT(topResolver.position() != endOfRuns);\n    RenderObject* currentRoot = topResolver.position().root();\n    topResolver.createBidiRunsForLine(endOfRuns, override, previousLineBrokeCleanly);\n    while (!topResolver.isolatedRuns().isEmpty()) {\n        BidiRun* isolatedRun = topResolver.isolatedRuns().last();\n        topResolver.isolatedRuns().removeLast();\n        RenderObject* startObj = isolatedRun->object();\n        RenderInline* isolatedInline = toRenderInline(containingIsolate(startObj, currentRoot));\n         InlineBidiResolver isolatedResolver;\n         EUnicodeBidi unicodeBidi = isolatedInline->style()->unicodeBidi();\n        TextDirection direction = isolatedInline->style()->direction();\n        if (unicodeBidi == Plaintext)\n            direction = determinePlaintextDirectionality(isolatedInline, startObj);\n        else {\n            ASSERT(unicodeBidi == Isolate || unicodeBidi == IsolateOverride);\n            direction = isolatedInline->style()->direction();\n        }\n        isolatedResolver.setStatus(statusWithDirection(direction, isOverride(unicodeBidi)));\n        setupResolverToResumeInIsolate(isolatedResolver, isolatedInline, startObj);\n        InlineIterator iter = InlineIterator(isolatedInline, startObj, isolatedRun->m_start);\n        isolatedResolver.setPositionIgnoringNestedIsolates(iter);\n        isolatedResolver.createBidiRunsForLine(endOfRuns, NoVisualOverride, previousLineBrokeCleanly);\n        if (isolatedResolver.runs().runCount())\n            bidiRuns.replaceRunWithRuns(isolatedRun, isolatedResolver.runs());\n        if (!isolatedResolver.isolatedRuns().isEmpty()) {\n            topResolver.isolatedRuns().append(isolatedResolver.isolatedRuns());\n            isolatedResolver.isolatedRuns().clear();\n            currentRoot = isolatedInline;\n        }\n    }\n}", "target": 1}
{"code": "static int is_integer(char *string)\n{\n  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {\n    while (*++string && isdigit(*string))\n      ;                                           \n    if (!*string)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": " void acpi_ns_terminate(void)\n {\n \tacpi_status status;\n \tACPI_FUNCTION_TRACE(ns_terminate);\n#ifdef ACPI_EXEC_APP\n\t{\n\t\tunion acpi_operand_object *prev;\n\t\tunion acpi_operand_object *next;\n\t\tnext = acpi_gbl_module_code_list;\n\t\twhile (next) {\n\t\t\tprev = next;\n\t\t\tnext = next->method.mutex;\n\t\t\tprev->method.mutex = NULL;\t\n\t\t\tacpi_ut_remove_reference(prev);\n\t\t}\n \t}\n#endif\n\tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\tacpi_ns_delete_node(acpi_gbl_root_node);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));\n\treturn_VOID;\n}", "target": 1}
{"code": "TEST_F(RaggedRangeOpTest, RangeSizeOverflow) {\n  BuildRaggedRangeGraph<float>();\n  AddInputFromArray<float>(TensorShape({2}), {1.1, 0.1});    \n  AddInputFromArray<float>(TensorShape({2}), {10.0, 1e10});  \n  AddInputFromArray<float>(TensorShape({2}), {1, 1e-10});    \n  EXPECT_EQ(absl::StrCat(\"Requires ((limit - start) / delta) <= \",\n                         std::numeric_limits<int64_t>::max()),\n            RunOpKernel().error_message());\n}", "target": 0}
{"code": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}", "target": 1}
{"code": "static uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}", "target": 1}
{"code": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stl_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "static void dup_xol_work(struct callback_head *work)\n{\n\tif (current->flags & PF_EXITING)\n\t\treturn;\n\tif (!__create_xol_area(current->utask->dup_xol_addr) &&\n\t\t\t!fatal_signal_pending(current))\n\t\tuprobe_warn(current, \"dup xol area\");\n}", "target": 0}
{"code": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "int perf_config(config_fn_t fn, void *data)\n{\n\tint ret = 0, found = 0;\n\tchar *repo_config = NULL;\n\tconst char *home = NULL;\n\tif (config_exclusive_filename)\n\t\treturn perf_config_from_file(fn, config_exclusive_filename, data);\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\n\t\tret += perf_config_from_file(fn, perf_etc_perfconfig(),\n\t\t\t\t\t    data);\n\t\tfound += 1;\n\t}\n\thome = getenv(\"HOME\");\n\tif (perf_config_global() && home) {\n\t\tchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\n\t\tif (!access(user_config, R_OK)) {\n\t\t\tret += perf_config_from_file(fn, user_config, data);\n\t\t\tfound += 1;\n\t\t}\n\t\tfree(user_config);\n\t}\n\trepo_config = perf_pathdup(\"config\");\n\tif (!access(repo_config, R_OK)) {\n\t\tret += perf_config_from_file(fn, repo_config, data);\n\t\tfound += 1;\n\t}\n\tfree(repo_config);\n\tif (found == 0)\n\t\treturn -1;\n\treturn ret;\n}", "target": 1}
{"code": "int nfc_dev_up(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->rfkill && rfkill_blocked(dev->rfkill)) {\n\t\trc = -ERFKILL;\n\t\tgoto error;\n\t}\n\tif (dev->fw_download_in_progress) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_up)\n\t\trc = dev->ops->dev_up(dev);\n\tif (!rc)\n\t\tdev->dev_up = true;\n\tif (dev->ops->discover_se && dev->ops->discover_se(dev))\n\t\tpr_err(\"SE discovery failed\\n\");\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "int phar_is_tar(char *buf, char *fname) \n{\n\ttar_header *header = (tar_header *) buf;\n\tphp_uint32 checksum = phar_tar_number(header->checksum, sizeof(header->checksum));\n\tphp_uint32 ret;\n\tchar save[sizeof(header->checksum)], *bname;\n\tif (!strncmp(buf, \"<?php\", sizeof(\"<?php\")-1)) {\n\t\treturn 0;\n\t}\n\tmemcpy(save, header->checksum, sizeof(header->checksum));\n\tmemset(header->checksum, ' ', sizeof(header->checksum));\n\tret = (checksum == phar_tar_checksum(buf, 512));\n\tmemcpy(header->checksum, save, sizeof(header->checksum));\n\tif ((bname = strrchr(fname, PHP_DIR_SEPARATOR))) {\n\t\tfname = bname;\n\t}\n\tif (!ret && (bname = strstr(fname, \".tar\")) && (bname[4] == '\\0' || bname[4] == '.')) {\n\t\treturn 1;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "void IndexedDBDatabase::SetIndexKeys(\n    IndexedDBTransaction* transaction,\n    int64_t object_store_id,\n    std::unique_ptr<IndexedDBKey> primary_key,\n    const std::vector<IndexedDBIndexKeys>& index_keys) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::SetIndexKeys\", \"txn.id\", transaction->id());\n  DCHECK_EQ(transaction->mode(),\n            blink::mojom::IDBTransactionMode::VersionChange);\n  IndexedDBBackingStore::RecordIdentifier record_identifier;\n  bool found = false;\n  Status s = backing_store_->KeyExistsInObjectStore(\n      transaction->BackingStoreTransaction(), metadata_.id, object_store_id,\n      *primary_key, &record_identifier, &found);\n  if (!s.ok()) {\n    ReportErrorWithDetails(s, \"Internal error setting index keys.\");\n    return;\n  }\n  if (!found) {\n    transaction->Abort(IndexedDBDatabaseError(\n        blink::kWebIDBDatabaseExceptionUnknownError,\n        \"Internal error setting index keys for object store.\"));\n    return;\n  }\n  std::vector<std::unique_ptr<IndexWriter>> index_writers;\n  base::string16 error_message;\n  bool obeys_constraints = false;\n  DCHECK(metadata_.object_stores.find(object_store_id) !=\n         metadata_.object_stores.end());\n  const IndexedDBObjectStoreMetadata& object_store_metadata =\n      metadata_.object_stores[object_store_id];\n  bool backing_store_success = MakeIndexWriters(transaction,\n                                                backing_store_.get(),\n                                                id(),\n                                                object_store_metadata,\n                                                *primary_key,\n                                                false,\n                                                index_keys,\n                                                &index_writers,\n                                                &error_message,\n                                                &obeys_constraints);\n  if (!backing_store_success) {\n    transaction->Abort(IndexedDBDatabaseError(\n        blink::kWebIDBDatabaseExceptionUnknownError,\n        \"Internal error: backing store error updating index keys.\"));\n    return;\n  }\n  if (!obeys_constraints) {\n    transaction->Abort(IndexedDBDatabaseError(\n        blink::kWebIDBDatabaseExceptionConstraintError, error_message));\n    return;\n  }\n  for (const auto& writer : index_writers) {\n    writer->WriteIndexKeys(record_identifier, backing_store_.get(),\n                           transaction->BackingStoreTransaction(), id(),\n                           object_store_id);\n  }\n}", "target": 0}
{"code": "decodenetnum(\n\tconst char *num,\n\tsockaddr_u *netnum\n\t)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint err;\n\tu_short port;\n\tconst char *cp;\n\tconst char *port_str;\n\tchar *pp;\n\tchar *np;\n\tchar name[80];\n\tREQUIRE(num != NULL);\n\tREQUIRE(strlen(num) < sizeof(name));\n\tport_str = NULL;\n\tif ('[' != num[0]) {\n\t\tpp = strchr(num, ':');\n\t\tif (NULL == pp)\n\t\t\tcp = num;\t\n\t\telse if (NULL != strchr(pp + 1, ':'))\n\t\t\tcp = num;\t\n\t\telse {\t\t\t\n\t\t\tstrlcpy(name, num, sizeof(name));\n\t\t\tcp = name;\n\t\t\tpp = strchr(cp, ':');\n\t\t\t*pp = '\\0';\n\t\t\tport_str = pp + 1;\n\t\t}\n\t} else {\n\t\tcp = num + 1;\n\t\tnp = name; \n\t\twhile (*cp && ']' != *cp)\n\t\t\t*np++ = *cp++;\n\t\t*np = 0;\n\t\tif (']' == cp[0] && ':' == cp[1] && '\\0' != cp[2])\n\t\t\tport_str = &cp[2];\n\t\tcp = name; \n\t}\n\tZERO(hints);\n\thints.ai_flags = Z_AI_NUMERICHOST;\n\terr = getaddrinfo(cp, \"ntp\", &hints, &ai);\n\tif (err != 0)\n\t\treturn 0;\n\tINSIST(ai->ai_addrlen <= sizeof(*netnum));\n\tZERO(*netnum);\n\tmemcpy(netnum, ai->ai_addr, ai->ai_addrlen);\n\tfreeaddrinfo(ai);\n\tif (NULL == port_str || 1 != sscanf(port_str, \"%hu\", &port))\n\t\tport = NTP_PORT;\n\tSET_PORT(netnum, port);\n\treturn 1;\n}", "target": 1}
{"code": "deltas_head_cleanup(struct deltas_head *list)\n{\n\tsize_t i;\n\tfor (i = 0; i < list->capacity; i++)\n\t\tdelta_head_destroy(list->array[i]);\n\tif (list->array)\n\t\tfree(list->array);\n}", "target": 1}
{"code": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n    virObjectLock(vm);\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n    qemuMonitorUnregister(mon);\n    qemuDomainDestroyNamespace(driver, vm);\n cleanup:\n    virObjectUnlock(vm);\n}", "target": 1}
{"code": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}", "target": 1}
{"code": "static int bufp_alloc(USBRedirDevice *dev, uint8_t *data, uint16_t len,\n    uint8_t status, uint8_t ep, void *free_on_destroy)\n{\n    struct buf_packet *bufp;\n    if (!dev->endpoint[EP2I(ep)].bufpq_dropping_packets &&\n        dev->endpoint[EP2I(ep)].bufpq_size >\n            2 * dev->endpoint[EP2I(ep)].bufpq_target_size) {\n        DPRINTF(\"bufpq overflow, dropping packets ep %02X\\n\", ep);\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 1;\n    }\n    if (dev->endpoint[EP2I(ep)].bufpq_dropping_packets) {\n        if (dev->endpoint[EP2I(ep)].bufpq_size >\n                dev->endpoint[EP2I(ep)].bufpq_target_size) {\n            free(data);\n            return -1;\n        }\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;\n    }\n    bufp = g_new(struct buf_packet, 1);\n    bufp->data   = data;\n    bufp->len    = len;\n    bufp->offset = 0;\n    bufp->status = status;\n    bufp->free_on_destroy = free_on_destroy;\n    QTAILQ_INSERT_TAIL(&dev->endpoint[EP2I(ep)].bufpq, bufp, next);\n    dev->endpoint[EP2I(ep)].bufpq_size++;\n    return 0;\n}", "target": 1}
{"code": "virNodeDeviceGetMdevTypesCaps(const char *sysfspath,\n                              virMediatedDeviceTypePtr **mdev_types,\n                              size_t *nmdev_types)\n{\n    virMediatedDeviceTypePtr *types = NULL;\n    size_t ntypes = 0;\n    size_t i;\n    for (i = 0; i < *nmdev_types; i++)\n       virMediatedDeviceTypeFree(*mdev_types[i]);\n    VIR_FREE(*mdev_types);\n    *nmdev_types = 0;\n    if (virMediatedDeviceGetMdevTypes(sysfspath, &types, &ntypes) < 0)\n        return -1;\n    *mdev_types = g_steal_pointer(&types);\n    *nmdev_types = ntypes;\n    return 0;\n}", "target": 1}
{"code": "static u16 swf_get_16(SWFReader *read)\n{\n\tu16 val, res;\n\tval = swf_read_int(read, 16);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "int register_power_pmu(struct power_pmu *pmu)\n{\n\tif (ppmu)\n\t\treturn -EBUSY;\t\t\n\tppmu = pmu;\n\tpr_info(\"%s performance monitor hardware support registered\\n\",\n\t\tpmu->name);\n#ifdef MSR_HV\n\tif (mfmsr() & MSR_HV)\n\t\tfreeze_events_kernel = MMCR0_FCHV;\n#endif \n\tperf_pmu_register(&power_pmu, \"cpu\", PERF_TYPE_RAW);\n\tperf_cpu_notifier(power_pmu_notifier);\n\treturn 0;\n}", "target": 0}
{"code": "devzvol_create(struct vnode *dvp, char *nm, struct vattr *vap, vcexcl_t excl,\n    int mode, struct vnode **vpp, struct cred *cred, int flag,\n    caller_context_t *ct, vsecattr_t *vsecp)\n{\n\tint error;\n\tstruct vnode *vp;\n\t*vpp = NULL;\n\terror = devzvol_lookup(dvp, nm, &vp, NULL, 0, NULL, cred, ct, NULL,\n\t    NULL);\n\tif (error == 0) {\n\t\tif (excl == EXCL)\n\t\t\terror = EEXIST;\n\t\telse if (vp->v_type == VDIR && (mode & VWRITE))\n\t\t\terror = EISDIR;\n\t\telse\n\t\t\terror = VOP_ACCESS(vp, mode, 0, cred, ct);\n\t\tif (error) {\n\t\t\tVN_RELE(vp);\n\t\t} else\n\t\t\t*vpp = vp;\n\t} else if (error == ENOENT) {\n\t\terror = EROFS;\n\t}\n\treturn (error);\n}", "target": 0}
{"code": "Item_ref::Item_ref(TABLE_LIST *view_arg, Item **item,\n                   const char *field_name_arg, bool alias_name_used_arg)\n  :Item_ident(view_arg, field_name_arg),\n   result_field(NULL), ref(item), reference_trough_name(0)\n{\n  alias_name_used= alias_name_used_arg;\n  if ((set_properties_only= (ref && *ref && (*ref)->fixed)))\n    set_properties();\n}", "target": 0}
{"code": "sasl_handle_login(struct sasl_session *const restrict p, struct user *const u, struct myuser *mu)\n{\n\tbool was_killed = false;\n\tif (! mu)\n\t{\n\t\tif (! *p->authzeid)\n\t\t{\n\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an authzeid (BUG)\",\n\t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\t\t\treturn false;\n\t\t}\n\t\tif (! (mu = myuser_find_uid(p->authzeid)))\n\t\t{\n\t\t\tif (*p->authzid)\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",\n\t\t\t\t                                      p->authzid);\n\t\t\telse\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account dropped; login cancelled\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (u->myuser && u->myuser != mu)\n\t{\n\t\tif (is_soper(u->myuser))\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_ADMIN, \"DESOPER: \\2%s\\2 as \\2%s\\2\",\n\t\t\t                                                 u->nick, entity(u->myuser)->name);\n\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGOUT\");\n\t\tif (! (was_killed = ircd_on_logout(u, entity(u->myuser)->name)))\n\t\t{\n\t\t\tmowgli_node_t *n;\n\t\t\tMOWGLI_ITER_FOREACH(n, u->myuser->logins.head)\n\t\t\t{\n\t\t\t\tif (n->data == u)\n\t\t\t\t{\n\t\t\t\t\t(void) mowgli_node_delete(n, &u->myuser->logins);\n\t\t\t\t\t(void) mowgli_node_free(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu->myuser = NULL;\n\t\t}\n\t}\n\tif (! was_killed)\n\t{\n\t\tif (u->myuser != mu)\n\t\t{\n\t\t\t(void) myuser_login(saslsvs, u, mu, false);\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGIN (%s)\", p->mechptr->name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmu->lastlogin = CURRTIME;\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"REAUTHENTICATE (%s)\", p->mechptr->name);\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "finish_pam(void)\n{\n\tfatal_remove_cleanup(sshpam_cleanup, NULL);\n\tsshpam_cleanup(NULL);\n}", "target": 0}
{"code": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}", "target": 1}
{"code": "SampleEncrypter::Create(const AP4_UI08* key, const AP4_UI08* iv, SampleEncrypter*& encrypter) {\n    encrypter = NULL;\n    AP4_BlockCipher* block_cipher = NULL;\n    AP4_Result result = AP4_DefaultBlockCipherFactory::Instance.CreateCipher(AP4_BlockCipher::AES_128,\n                                                                             AP4_BlockCipher::ENCRYPT,\n                                                                             AP4_BlockCipher::CBC,\n                                                                             NULL,\n                                                                             key,\n                                                                             16,\n                                                                             block_cipher);\n    if (AP4_FAILED(result)) return result;\n    AP4_CbcStreamCipher* stream_cipher = new AP4_CbcStreamCipher(block_cipher);\n    encrypter = new SampleEncrypter(stream_cipher, iv);\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "init_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n\t{\n\t  return U2FH_MEMORY_ERROR;\n\t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}", "target": 1}
{"code": "static void WriteBinaryGltfStream(std::ostream &stream,\n                                  const std::string &content,\n                                  const std::vector<unsigned char> &binBuffer) {\n  const std::string header = \"glTF\";\n  const int version = 2;\n  const uint32_t content_size = uint32_t(content.size());\n  const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n  const uint32_t length =\n      12 + 8 + content_size + content_padding_size +\n      (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);\n  stream.write(header.c_str(), std::streamsize(header.size()));\n  stream.write(reinterpret_cast<const char *>(&version), sizeof(version));\n  stream.write(reinterpret_cast<const char *>(&length), sizeof(length));\n  const uint32_t model_length = uint32_t(content.size()) + content_padding_size;\n  const uint32_t model_format = 0x4E4F534A;\n  stream.write(reinterpret_cast<const char *>(&model_length),\n               sizeof(model_length));\n  stream.write(reinterpret_cast<const char *>(&model_format),\n               sizeof(model_format));\n  stream.write(content.c_str(), std::streamsize(content.size()));\n  if (content_padding_size > 0) {\n    const std::string padding = std::string(size_t(content_padding_size), ' ');\n    stream.write(padding.c_str(), std::streamsize(padding.size()));\n  }\n  if (binBuffer.size() > 0) {\n    const uint32_t bin_length = uint32_t(binBuffer.size()) + bin_padding_size;\n    const uint32_t bin_format = 0x004e4942;\n    stream.write(reinterpret_cast<const char *>(&bin_length),\n                 sizeof(bin_length));\n    stream.write(reinterpret_cast<const char *>(&bin_format),\n                 sizeof(bin_format));\n    stream.write(reinterpret_cast<const char *>(binBuffer.data()),\n                 std::streamsize(binBuffer.size()));\n    if (bin_padding_size > 0) {\n      const std::vector<unsigned char> padding =\n          std::vector<unsigned char>(size_t(bin_padding_size), 0);\n      stream.write(reinterpret_cast<const char *>(padding.data()),\n                   std::streamsize(padding.size()));\n    }\n  }\n}", "target": 1}
{"code": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\treturn ptr;\n}", "target": 1}
{"code": "epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}", "target": 1}
{"code": "static void kiss_unesc(struct mkiss *ax, unsigned char s)\n{\n\tswitch (s) {\n\tcase END:\n\t\tif (test_bit(AXF_KEEPTEST, &ax->flags))\n\t\t\tclear_bit(AXF_KEEPTEST, &ax->flags);\n\t\tif (!test_and_clear_bit(AXF_ERROR, &ax->flags) && (ax->rcount > 2))\n\t\t\tax_bump(ax);\n\t\tclear_bit(AXF_ESCAPE, &ax->flags);\n\t\tax->rcount = 0;\n\t\treturn;\n\tcase ESC:\n\t\tset_bit(AXF_ESCAPE, &ax->flags);\n\t\treturn;\n\tcase ESC_ESC:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = ESC;\n\t\tbreak;\n\tcase ESC_END:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = END;\n\t\tbreak;\n\t}\n\tspin_lock_bh(&ax->buflock);\n\tif (!test_bit(AXF_ERROR, &ax->flags)) {\n\t\tif (ax->rcount < ax->buffsize) {\n\t\t\tax->rbuff[ax->rcount++] = s;\n\t\t\tspin_unlock_bh(&ax->buflock);\n\t\t\treturn;\n\t\t}\n\t\tax->dev->stats.rx_over_errors++;\n\t\tset_bit(AXF_ERROR, &ax->flags);\n\t}\n\tspin_unlock_bh(&ax->buflock);\n}", "target": 0}
{"code": "static inline unsigned int unix_hash_fold(__wsum n)\n{\n\tunsigned int hash = (__force unsigned int)csum_fold(n);\n\thash ^= hash>>8;\n\treturn hash&(UNIX_HASH_SIZE-1);\n}", "target": 0}
{"code": "static char *oidc_cache_get_hashed_key(request_rec *r, const char *passphrase,\n\t\tconst char *key) {\n\tchar *input = apr_psprintf(r->pool, \"%s:%s\", passphrase, key);\n\tchar *output = NULL;\n\tif (oidc_util_hash_string_and_base64url_encode(r, OIDC_JOSE_ALG_SHA256,\n\t\t\tinput, &output) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\treturn NULL;\n\t}\n\treturn output;\n}", "target": 1}
{"code": "void nfs4_close_state(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 0);\n}", "target": 1}
{"code": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "void Polygon::Insert( sal_uInt16 nPos, const Point& rPt )\n{\n    ImplMakeUnique();\n    if( nPos >= mpImplPolygon->mnPoints )\n        nPos = mpImplPolygon->mnPoints;\n    mpImplPolygon->ImplSplit( nPos, 1 );\n    mpImplPolygon->mpPointAry[ nPos ] = rPt;\n}", "target": 1}
{"code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 1}
{"code": "static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)\n{\n    CPUState *cs = CPU(cpu);\n     CPUX86State *env = &cpu->env;\n     VAPICHandlers *handlers;\n     uint8_t opcode[2];\n    uint32_t imm32;\n     target_ulong current_pc = 0;\n     target_ulong current_cs_base = 0;\n     uint32_t current_flags = 0;\n    if (smp_cpus == 1) {\n        handlers = &s->rom_state.up;\n    } else {\n        handlers = &s->rom_state.mp;\n    }\n    if (!kvm_enabled()) {\n        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                             &current_flags);\n    }\n    pause_all_vcpus();\n    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);\n    switch (opcode[0]) {\n    case 0x89: \n        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  \n        patch_call(s, cpu, ip + 1, handlers->set_tpr);\n        break;\n    case 0x8b: \n        patch_byte(cpu, ip, 0x90);\n        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);\n        break;\n    case 0xa1: \n        patch_call(s, cpu, ip, handlers->get_tpr[0]);\n        break;\n    case 0xa3: \n        patch_call(s, cpu, ip, handlers->set_tpr_eax);\n        break;\n    case 0xc7: \n        patch_byte(cpu, ip, 0x68);  \n        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);\n        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);\n        patch_call(s, cpu, ip + 5, handlers->set_tpr);\n        break;\n    case 0xff: \n        patch_byte(cpu, ip, 0x50); \n        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);\n        break;\n    default:\n        abort();\n    }\n    resume_all_vcpus();\n    if (!kvm_enabled()) {\n        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);\n        cpu_resume_from_signal(cs, NULL);\n    }\n}", "target": 1}
{"code": "static av_cold int decode_init(AVCodecContext *avctx)\n{\n    AnsiContext *s = avctx->priv_data;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    s->frame = av_frame_alloc();\n    if (!s->frame)\n        return AVERROR(ENOMEM);\n    s->font        = avpriv_vga16_font;\n    s->font_height = 16;\n    s->fg          = DEFAULT_FG_COLOR;\n    s->bg          = DEFAULT_BG_COLOR;\n    if (!avctx->width || !avctx->height)\n        ff_set_dimensions(avctx, 80 << 3, 25 << 4);\n    return 0;\n}", "target": 0}
{"code": "TEST_F(EncryptedRecordTest, TestAllPaddingHandshake) {\n  addToQueue(\"17030100050123456789\");\n  EXPECT_CALL(*readAead_, _decrypt(_, _, 0))\n      .WillOnce(Invoke([](std::unique_ptr<IOBuf>& buf, const IOBuf*, uint64_t) {\n        expectSame(buf, \"0123456789\");\n        return getBuf(\"16000000\");\n      }));\n  EXPECT_NO_THROW(read_.read(queue_));\n}", "target": 1}
{"code": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}", "target": 1}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static int php_jpg_get16(void *value)\n{\n\treturn (((uchar *)value)[0] << 8) | ((uchar *)value)[1];\n}", "target": 0}
{"code": "jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:\n\treturn 0;\n}", "target": 1}
{"code": "comics_document_save (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\treturn ev_xfer_uri_simple (comics_document->archive, uri, error);\n}", "target": 1}
{"code": "cql_server::unadvertise_connection(shared_ptr<generic_server::connection> raw_conn) {\n    --_stats.connections;\n    if (auto conn = dynamic_pointer_cast<connection>(raw_conn)) {\n        const auto ip = conn->get_client_state().get_client_address().addr();\n        const auto port = conn->get_client_state().get_client_port();\n        clogger.trace(\"Advertising disconnection of CQL client {}:{}\", ip, port);\n    }\n    return make_ready_future<>();\n}", "target": 0}
{"code": "static u32 *gen8_emit_fini_breadcrumb_rcs(struct i915_request *request, u32 *cs)\n{\n\tcs = gen8_emit_pipe_control(cs,\n\t\t\t\t    PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH |\n\t\t\t\t    PIPE_CONTROL_DEPTH_CACHE_FLUSH |\n\t\t\t\t    PIPE_CONTROL_DC_FLUSH_ENABLE,\n\t\t\t\t    0);\n\tcs = gen8_emit_ggtt_write_rcs(cs,\n\t\t\t\t      request->fence.seqno,\n\t\t\t\t      i915_request_active_timeline(request)->hwsp_offset,\n\t\t\t\t      PIPE_CONTROL_FLUSH_ENABLE |\n\t\t\t\t      PIPE_CONTROL_CS_STALL);\n\treturn gen8_emit_fini_breadcrumb_footer(request, cs);\n}", "target": 0}
{"code": "int go7007_snd_init(struct go7007 *go)\n{\n\tstatic int dev;\n\tstruct go7007_snd *gosnd;\n\tint ret;\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\tgosnd = kmalloc(sizeof(struct go7007_snd), GFP_KERNEL);\n\tif (gosnd == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&gosnd->lock);\n\tgosnd->hw_ptr = gosnd->w_idx = gosnd->avail = 0;\n\tgosnd->capturing = 0;\n\tret = snd_card_new(go->dev, index[dev], id[dev], THIS_MODULE, 0,\n\t\t\t   &gosnd->card);\n\tif (ret < 0) {\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tret = snd_device_new(gosnd->card, SNDRV_DEV_LOWLEVEL, go,\n\t\t\t&go7007_snd_device_ops);\n\tif (ret < 0) {\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tret = snd_pcm_new(gosnd->card, \"go7007\", 0, 0, 1, &gosnd->pcm);\n\tif (ret < 0) {\n\t\tsnd_card_free(gosnd->card);\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tstrscpy(gosnd->card->driver, \"go7007\", sizeof(gosnd->card->driver));\n\tstrscpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->shortname));\n\tstrscpy(gosnd->card->longname, gosnd->card->shortname,\n\t\tsizeof(gosnd->card->longname));\n\tgosnd->pcm->private_data = go;\n\tsnd_pcm_set_ops(gosnd->pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&go7007_snd_capture_ops);\n\tret = snd_card_register(gosnd->card);\n\tif (ret < 0) {\n\t\tsnd_card_free(gosnd->card);\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tgosnd->substream = NULL;\n\tgo->snd_context = gosnd;\n\tv4l2_device_get(&go->v4l2_dev);\n\t++dev;\n\treturn 0;\n}", "target": 1}
{"code": "archive_read_support_format_zip_streamable(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct zip *zip;\n\tint r;\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_zip\");\n\tzip = (struct zip *)calloc(1, sizeof(*zip));\n\tif (zip == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate zip data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->process_mac_extensions = 0;\n\tzip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\tzip->crc32func = real_crc32;\n\tr = __archive_read_register_format(a,\n\t    zip,\n\t    \"zip\",\n\t    archive_read_format_zip_streamable_bid,\n\t    archive_read_format_zip_options,\n\t    archive_read_format_zip_streamable_read_header,\n\t    archive_read_format_zip_read_data,\n\t    archive_read_format_zip_read_data_skip_streamable,\n\t    NULL,\n\t    archive_read_format_zip_cleanup,\n\t    archive_read_support_format_zip_capabilities_streamable,\n\t    archive_read_format_zip_has_encrypted_entries);\n\tif (r != ARCHIVE_OK)\n\t\tfree(zip);\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static bool parse_namemap(RBuffer *b, ut64 bound, RIDStorage *map, ut32 *count) {\n\tsize_t i;\n\tif (!consume_u32_r (b, bound, count)) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < *count; i++) {\n\t\tut32 idx;\n\t\tif (!consume_u32_r (b, bound, &idx)) {\n\t\t\treturn false;\n\t\t}\n\t\tchar *name = NULL;\n\t\tif (!consume_encoded_name_new (b, bound, NULL, &name)) {\n\t\t\tR_FREE (name);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_id_storage_add (map, name, &idx)) {\n\t\t\tR_FREE (name);\n\t\t\treturn false;\n\t\t};\n\t}\n\treturn true;\n}", "target": 0}
{"code": "void jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"', boxinfo->name,\n\t  '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}", "target": 1}
{"code": "static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tint err;\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\tspin_lock(&nm_i->nid_list_lock);\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\tif (err) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tstruct inode *inode;\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\terror = ERR_PTR(-ENOENT);\n\tinode = NULL;\n\tif (!task)\n\t\tgoto out_no_task;\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}", "target": 0}
{"code": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}", "target": 1}
{"code": "atoi_err(const char *nptr, int *val)\n{\n\tconst char *errstr = NULL;\n\tlong long num;\n\tif (nptr == NULL || *nptr == '\\0')\n\t\treturn \"missing\";\n\tnum = strtonum(nptr, 0, INT_MAX, &errstr);\n\tif (errstr == NULL)\n\t\t*val = (int)num;\n\treturn errstr;\n}", "target": 0}
{"code": "static int _gnutls_verify_crl2(gnutls_x509_crl_t crl,\n\t\t\t       const gnutls_x509_crt_t * trusted_cas,\n\t\t\t       int tcas_size, unsigned int flags,\n\t\t\t       unsigned int *output)\n{\n    gnutls_datum_t crl_signed_data = { NULL, 0 };\n    gnutls_datum_t crl_signature = { NULL, 0 };\n    gnutls_x509_crt_t issuer;\n    int ret, result;\n    if (output)\n\t*output = 0;\n    if (tcas_size >= 1)\n\tissuer = find_crl_issuer(crl, trusted_cas, tcas_size);\n    else {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_SIGNER_NOT_FOUND | GNUTLS_CERT_INVALID;\n\treturn 0;\n    }\n    if (issuer == NULL) {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_SIGNER_NOT_FOUND | GNUTLS_CERT_INVALID;\n\treturn 0;\n    }\n    if (!(flags & GNUTLS_VERIFY_DISABLE_CA_SIGN)) {\n\tif (gnutls_x509_crt_get_ca_status(issuer, NULL) != 1) {\n\t    gnutls_assert();\n\t    if (output)\n\t\t*output |= GNUTLS_CERT_SIGNER_NOT_CA | GNUTLS_CERT_INVALID;\n\t    return 0;\n\t}\n    }\n    result =\n\t_gnutls_x509_get_signed_data(crl->crl, \"tbsCertList\",\n\t\t\t\t     &crl_signed_data);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto cleanup;\n    }\n    result =\n\t_gnutls_x509_get_signature(crl->crl, \"signature\", &crl_signature);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto cleanup;\n    }\n    ret =\n\t_gnutls_x509_verify_signature(&crl_signed_data, &crl_signature,\n\t\t\t\t      issuer);\n    if (ret < 0) {\n\tgnutls_assert();\n    } else if (ret == 0) {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_INVALID;\n\tret = 0;\n    }\n    result = ret;\n  cleanup:\n    _gnutls_free_datum(&crl_signed_data);\n    _gnutls_free_datum(&crl_signature);\n    return result;\n}", "target": 0}
{"code": "        std::string getExiv2ConfigPath()\n        {\n            std::string homedir;\n            std::string inifile;\n#if defined(_MSC_VER) || defined(__MINGW__)\n            char path[MAX_PATH];\n            if (SUCCEEDED(SHGetFolderPathA(nullptr, CSIDL_PROFILE, nullptr, 0, path))) {\n                homedir = std::string(path);\n                inifile = \"exiv2.ini\"      ;\n            }\n#else\n            struct passwd* pw = getpwuid(getuid());\n            homedir = std::string(pw?pw->pw_dir:\"\");\n            inifile = std::string(\".exiv2\");\n#endif\n            return homedir + EXV_SEPARATOR_CHR + inifile;\n        }", "target": 0}
{"code": "int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = __ceph_setattr(inode, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\tret = __ceph_setxattr(inode, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\t__ceph_setattr(inode, &newattrs);\n\t\t}\n\t\tgoto out_free;\n\t}\n\tceph_set_cached_acl(inode, type, acl);\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "void InstanceKlass::release_C_heap_structures_internal() {\n  Klass::release_C_heap_structures();\n  if (_oop_map_cache != NULL) {\n    delete _oop_map_cache;\n    _oop_map_cache = NULL;\n  }\n  JNIid::deallocate(jni_ids());\n  set_jni_ids(NULL);\n  jmethodID* jmeths = methods_jmethod_ids_acquire();\n  if (jmeths != (jmethodID*)NULL) {\n    release_set_methods_jmethod_ids(NULL);\n    FreeHeap(jmeths);\n  }\n  assert(_dep_context == NULL,\n         \"dependencies should already be cleaned\");\n#if INCLUDE_JVMTI\n  if (breakpoints() != 0x0) {\n    methods_do(clear_all_breakpoints);\n    assert(breakpoints() == 0x0, \"should have cleared breakpoints\");\n  }\n  if (_cached_class_file != NULL) {\n    os::free(_cached_class_file);\n    _cached_class_file = NULL;\n  }\n#endif\n  FREE_C_HEAP_ARRAY(char, _source_debug_extension);\n}", "target": 0}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\terror = git_stream_connect(t->io);\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n \tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n \t    git_stream_is_encrypted(t->io)) {\n \t\tgit_cert *cert;\n\t\tint is_valid;\n \t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n \t\t\treturn error;\n \t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n \t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n \t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "static void do_client_disconnect(void)\n{\n    if (client_connected) {\n        udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0,\n                               NULL, 0);\n        client_connected = false;\n    }\n}", "target": 1}
{"code": "void _reset_fxsave_state()\n{\n    static OE_ALIGNED(OE_FXSAVE_ALIGNMENT) const uint64_t\n        _initial_fxstate[OE_FXSAVE_AREA_SIZE / sizeof(uint64_t)] = {\n            0x037F, 0, 0, 0xFFFF00001F80,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n        };\n    asm volatile(\"fxrstor %[fx_state] \\n\\t\"\n                 :\n                 : [fx_state] \"m\"(_initial_fxstate)\n                 :);\n}", "target": 1}
{"code": "static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tif (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))\n\t\treturn;\n\tif (cfs_rq->runtime_remaining < 0)\n\t\treturn;\n\tif (cfs_rq->expires_seq == cfs_b->expires_seq) {\n\t\tcfs_rq->runtime_expires += TICK_NSEC;\n\t} else {\n\t\tcfs_rq->runtime_remaining = 0;\n\t}\n}", "target": 1}
{"code": "static const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    const char *portstr, *part;\n    char *scheme;\n    int port;\n    if (err != NULL) {\n        return err;\n    }\n    if (apr_fnmatch_test(arg))\n        return apr_pstrcat(cmd->temp_pool, \"Invalid ServerName \\\"\", arg,\n                \"\\\" use ServerAlias to set multiple server names.\", NULL);\n    part = ap_strstr_c(arg, \":\n    if (part) {\n      scheme = apr_pstrndup(cmd->pool, arg, part - arg);\n      ap_str_tolower(scheme);\n      cmd->server->server_scheme = (const char *)scheme;\n      part += 3;\n    } else {\n      part = arg;\n    }\n    portstr = ap_strchr_c(part, ':');\n    if (portstr) {\n        cmd->server->server_hostname = apr_pstrndup(cmd->pool, part,\n                                                    portstr - part);\n        portstr++;\n        port = atoi(portstr);\n        if (port <= 0 || port >= 65536) { \n            return apr_pstrcat(cmd->temp_pool, \"The port number \\\"\", arg,\n                          \"\\\" is outside the appropriate range \"\n                          \"(i.e., 1..65535).\", NULL);\n        }\n    }\n    else {\n        cmd->server->server_hostname = apr_pstrdup(cmd->pool, part);\n        port = 0;\n    }\n    cmd->server->port = port;\n    return NULL;\n}", "target": 0}
{"code": "bits_set(unsigned int *selector, size_t selsize, int *bits)\n{\nfor(; *bits != -1; ++bits)\n  BIT_SET(selector, selsize, *bits);\n}", "target": 0}
{"code": "TEST_F(LuaHeaderMapWrapperTest, ModifyAfterIteration) {\n  const std::string SCRIPT{R\"EOF(\n    function callMe(object)\n      for key, value in pairs(object) do\n        testPrint(string.format(\"'%s' '%s'\", key, value))\n      end\n      object:add(\"hello\", \"world\")\n      for key, value in pairs(object) do\n        testPrint(string.format(\"'%s' '%s'\", key, value))\n      end\n    end\n  )EOF\"};\n  InSequence s;\n  setup(SCRIPT);\n  Http::TestRequestHeaderMapImpl headers{{\"foo\", \"bar\"}};\n  HeaderMapWrapper::create(coroutine_->luaState(), headers, []() { return true; });\n  EXPECT_CALL(printer_, testPrint(\"'foo' 'bar'\"));\n  EXPECT_CALL(printer_, testPrint(\"'foo' 'bar'\"));\n  EXPECT_CALL(printer_, testPrint(\"'hello' 'world'\"));\n  start(\"callMe\");\n}", "target": 0}
{"code": "snmp_api_set_oid(snmp_varbind_t *varbind, uint32_t *oid, uint32_t *ret_oid)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OID;\n  varbind->value.oid = ret_oid;\n}", "target": 1}
{"code": "static uint32_t dp8393x_wt(dp8393xState *s)\n{\n    return s->regs[SONIC_WT1] << 16 | s->regs[SONIC_WT0];\n}", "target": 0}
{"code": "grub_password_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\tbuf[cur_len++] = key;\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\tunmask_evtchn(evtchn);\n}", "target": 1}
{"code": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n    u32in();\n    u32in();\n    mp4config.frame.ents = u32in();\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n        mp4config.frame.data[cnt + 1] = ofs;\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n    return size;\n}", "target": 1}
{"code": "lsof_parse (const char *stdout,\n            GPtrArray *processes)\n{\n  int n;\n  char **tokens;\n  tokens = g_strsplit (stdout, \"\\n\", 0);\n  for (n = 0; tokens[n] != NULL; n++)\n    {\n      pid_t pid;\n      uid_t uid;\n      char *command_line;\n      GValue elem =\n        { 0 };\n      if (strlen (tokens[n]) == 0)\n        continue;\n      pid = strtol (tokens[n], NULL, 0);\n      uid = get_uid_for_pid (pid);\n      command_line = get_command_line_for_pid (pid);\n      g_value_init (&elem, LSOF_DATA_STRUCT_TYPE);\n      g_value_take_boxed (&elem, dbus_g_type_specialized_construct (LSOF_DATA_STRUCT_TYPE));\n      dbus_g_type_struct_set (&elem, 0, pid, 1, uid, 2, command_line != NULL ? command_line : \"\", G_MAXUINT);\n      g_ptr_array_add (processes, g_value_get_boxed (&elem));\n      g_free (command_line);\n    }\n  g_strfreev (tokens);\n}", "target": 0}
{"code": "static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\tret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input,\n                           const TfLiteTensor* positions,\n                           TfLiteTensor* output) {\n  DynamicBuffer buffer;\n  const PositionT* indexes = GetTensorData<PositionT>(positions);\n  bool indices_has_only_positive_elements = true;\n  const size_t num_indices = positions->bytes / sizeof(PositionT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indexes[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  const PositionT num_strings = GetStringCount(input);\n  const int num_indexes = NumElements(positions);\n  for (int i = 0; i < num_indexes; ++i) {\n    const PositionT pos = indexes[i];\n    TF_LITE_ENSURE(context, pos < num_strings);\n    const auto string_ref = GetString(input, pos);\n    buffer.AddString(string_ref.str, string_ref.len);\n  }\n  buffer.WriteToTensor(output, nullptr);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static bool tailmatch(const char *cooke_domain, const char *hostname)\n{\n  size_t cookie_domain_len = strlen(cooke_domain);\n  size_t hostname_len = strlen(hostname);\n  if(hostname_len < cookie_domain_len)\n    return FALSE;\n  if(!strcasecompare(cooke_domain, hostname + hostname_len-cookie_domain_len))\n    return FALSE;\n  if(hostname_len == cookie_domain_len)\n    return TRUE;\n  if('.' == *(hostname + hostname_len - cookie_domain_len - 1))\n    return TRUE;\n  return FALSE;\n}", "target": 0}
{"code": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n  real_tty_path += 5;\t\t\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n  return result;\n}", "target": 1}
{"code": "make_clone_setup (GnomeRRScreen *screen)\n{\n        GnomeRRConfig *result;\n        int width, height;\n        int i;\n        if (!get_clone_size (screen, &width, &height))\n                return NULL;\n        result = gnome_rr_config_new_current (screen);\n        for (i = 0; result->outputs[i] != NULL; ++i) {\n                GnomeOutputInfo *info = result->outputs[i];\n                info->on = FALSE;\n                if (info->connected) {\n                        GnomeRROutput *output =\n                                gnome_rr_screen_get_output_by_name (screen, info->name);\n                        GnomeRRMode **modes = gnome_rr_output_list_modes (output);\n                        int j;\n                        int best_rate = 0;\n                        for (j = 0; modes[j] != NULL; ++j) {\n                                GnomeRRMode *mode = modes[j];\n                                int w, h;\n                                w = gnome_rr_mode_get_width (mode);\n                                h = gnome_rr_mode_get_height (mode);\n                                if (w == width && h == height) {\n                                        int r = gnome_rr_mode_get_freq (mode);\n                                        if (r > best_rate)\n                                                best_rate = r;\n                                }\n                        }\n                        if (best_rate > 0) {\n                                info->on = TRUE;\n                                info->width = width;\n                                info->height = height;\n                                info->rate = best_rate;\n                                info->rotation = GNOME_RR_ROTATION_0;\n                                info->x = 0;\n                                info->y = 0;\n                        }\n                }\n        }\n        print_configuration (result, \"clone setup\");\n        return result;\n}", "target": 0}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 1}
{"code": "char *_q_makeword(char *str, char stop)\n{\n    char *word;\n    int  len, i;\n    for (len = 0; ((str[len] != stop) && (str[len])); len++);\n    word = (char *)malloc(sizeof(char) * (len + 1));\n    for (i = 0; i < len; i++) word[i] = str[i];\n    word[i] = '\\0';\n    if (str[len])len++;\n    for (i = len; str[i]; i++) str[i - len] = str[i];\n    str[i - len] = '\\0';\n    return word;\n}", "target": 0}
{"code": "static int verify_ee(const gnutls_datum_t *raw_crt, gnutls_certificate_type_t crt_type,\n\t\t dane_cert_type_t ctype, dane_match_type_t match, gnutls_datum_t * data,\n\t\t unsigned int *verify)\n{\ngnutls_datum_t pubkey = {NULL, 0};\nint ret;\n\tif (ctype == DANE_CERT_X509 && crt_type == GNUTLS_CRT_X509) {\n\t\tif (!matches(raw_crt, data, match)) {\n\t\t        gnutls_assert();\n\t\t\t*verify |= DANE_VERIFY_CERT_DIFFERS;\n                }\n\t} else if (ctype == DANE_CERT_PK && crt_type == GNUTLS_CRT_X509) {\n\t\tret = crt_to_pubkey(raw_crt, &pubkey);\n\t\tif (ret < 0) {\n        \t        gnutls_assert();\n\t\t\tgoto cleanup;\n                }\n\t\tif (!matches(&pubkey, data, match)) {\n\t\t        gnutls_assert();\n\t\t\t*verify |= DANE_VERIFY_CERT_DIFFERS;\n                }\n\t} else {\n\t\tret = gnutls_assert_val(DANE_E_UNKNOWN_DANE_DATA);\n\t\tgoto cleanup;\n\t}\n\tret = 0;\ncleanup:\n\tfree(pubkey.data);\n\treturn ret;\n}", "target": 0}
{"code": "_mibindex_add( const char *dirname, int i )\n{\n    const int old_mibindex_max = _mibindex_max;\n    DEBUGMSGTL((\"mibindex\", \"add: %s (%d)\\n\", dirname, i ));\n    if ( i == -1 )\n        i = _mibindex++;\n    if ( i >= _mibindex_max ) {\n        _mibindex_max = i + 10;\n        _mibindexes = realloc(_mibindexes,\n                              _mibindex_max * sizeof(_mibindexes[0]));\n        netsnmp_assert(_mibindexes);\n        memset(_mibindexes + old_mibindex_max, 0,\n               (_mibindex_max - old_mibindex_max) * sizeof(_mibindexes[0]));\n    }\n    _mibindexes[ i ] = strdup( dirname );\n    if ( i >= _mibindex )\n        _mibindex = i+1;\n    DEBUGMSGTL((\"mibindex\", \"add: %d/%d/%d\\n\", i, _mibindex, _mibindex_max ));\n    return i;\n}", "target": 1}
{"code": "parseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d,\n                  typename TTypes<T, 3>::ConstTensor gradient,\n                  typename TTypes<T, 3>::ConstTensor input,\n                  const Tensor* input_min_tensor,\n                  const Tensor* input_max_tensor,\n                  typename TTypes<T, 3>::Tensor input_backprop,\n                  typename TTypes<T>::Flat input_min_backprop,\n                  typename TTypes<T>::Flat input_max_backprop) {\n    QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "static struct sock *unix_create1(struct net *net, struct socket *sock, int kern)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\tatomic_long_inc(&unix_nr_socks);\n\tif (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())\n\t\tgoto out;\n\tsk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\tsock_init_data(sock, sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= net->unx.sysctl_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_long_set(&u->inflight, 0);\n\tINIT_LIST_HEAD(&u->link);\n\tmutex_init(&u->readlock); \n\tinit_waitqueue_head(&u->peer_wait);\n\tinit_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);\n\tunix_insert_socket(unix_sockets_unbound(sk), sk);\nout:\n\tif (sk == NULL)\n\t\tatomic_long_dec(&unix_nr_socks);\n\telse {\n\t\tlocal_bh_disable();\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t\tlocal_bh_enable();\n\t}\n\treturn sk;\n}", "target": 0}
{"code": "  Definition_Obj Parser::parse_definition(Definition::Type which_type)\n  {\n    std::string which_str(lexed);\n    if (!lex< identifier >()) error(\"invalid name in \" + which_str + \" definition\");\n    std::string name(Util::normalize_underscores(lexed));\n    if (which_type == Definition::FUNCTION && (name == \"and\" || name == \"or\" || name == \"not\"))\n    { error(\"Invalid function name \\\"\" + name + \"\\\".\"); }\n    ParserState source_position_of_def = pstate;\n    Parameters_Obj params = parse_parameters();\n    if (which_type == Definition::MIXIN) stack.push_back(Scope::Mixin);\n    else stack.push_back(Scope::Function);\n    Block_Obj body = parse_block();\n    stack.pop_back();\n    return SASS_MEMORY_NEW(Definition, source_position_of_def, name, params, body, which_type);\n  }", "target": 0}
{"code": "_eddsa_hash (const struct ecc_modulo *m,\n\t     mp_limb_t *rp, size_t digest_size, const uint8_t *digest)\n{\n  mp_size_t nlimbs = (8*digest_size + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;\n  mpn_set_base256_le (rp, nlimbs, digest, digest_size);\n  if (nlimbs > 2*m->size)\n    {\n      mp_limb_t hi = rp[2*m->size];\n      assert (nlimbs == 2*m->size + 1);\n      hi = mpn_addmul_1 (rp + m->size, m->B, m->size, hi);\n      assert (hi <= 1);\n      hi = mpn_cnd_add_n (hi, rp + m->size, rp + m->size, m->B, m->size);\n      assert (hi == 0);\n    }\n  m->mod (m, rp, rp);\n}", "target": 1}
{"code": "parse_GROUP(char *arg, const struct ofpact_parse_params *pp)\n{\n    return str_to_u32(arg, &ofpact_put_GROUP(pp->ofpacts)->group_id);\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_set_error_verbosity)\n{\n\tzval *pgsql_link = NULL;\n\tzend_long verbosity;\n\tint id = -1, argc = ZEND_NUM_ARGS();\n\tPGconn *pgsql;\n\tif (argc == 1) {\n\t\tif (zend_parse_parameters(argc, \"l\", &verbosity) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tid = FETCH_DEFAULT_LINK();\n\t\tCHECK_DEFAULT_LINK(id);\n\t} else {\n\t\tif (zend_parse_parameters(argc, \"rl\", &pgsql_link, &verbosity) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (pgsql_link == NULL && id == -1) {\n\t\tRETURN_FALSE;\n\t}\t\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tif (verbosity & (PQERRORS_TERSE|PQERRORS_DEFAULT|PQERRORS_VERBOSE)) {\n\t\tRETURN_LONG(PQsetErrorVerbosity(pgsql, verbosity));\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0}
{"code": "   Return current UNIX timestamp */\nPHP_FUNCTION(time)\n{\n\tRETURN_LONG((long)time(NULL));", "target": 0}
{"code": "static void kvm_mmu_notifier_invalidate_page(struct mmu_notifier *mn,\n\t\t\t\t\t     struct mm_struct *mm,\n\t\t\t\t\t     unsigned long address)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tint need_tlb_flush, idx;\n\tidx = srcu_read_lock(&kvm->srcu);\n\tspin_lock(&kvm->mmu_lock);\n\tkvm->mmu_notifier_seq++;\n\tneed_tlb_flush = kvm_unmap_hva(kvm, address) | kvm->tlbs_dirty;\n\tspin_unlock(&kvm->mmu_lock);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tif (need_tlb_flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}", "target": 0}
{"code": "static void nvme_mmio_write(void *opaque, hwaddr addr, uint64_t data,\n                            unsigned size)\n{\n    NvmeCtrl *n = (NvmeCtrl *)opaque;\n    trace_pci_nvme_mmio_write(addr, data, size);\n    if (addr < sizeof(n->bar)) {\n        nvme_write_bar(n, addr, data, size);\n    } else {\n        nvme_process_db(n, addr, data);\n    }\n}", "target": 0}
{"code": "static int rm_sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){\n    RMDemuxContext *rm = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint32_t state=0xFFFFFFFF;\n    while(!avio_feof(pb)){\n        int len, num, i;\n        int mlti_id;\n        *pos= avio_tell(pb) - 3;\n        if(rm->remaining_len > 0){\n            num= rm->current_stream;\n            mlti_id = 0;\n            len= rm->remaining_len;\n            *timestamp = AV_NOPTS_VALUE;\n            *flags= 0;\n        }else{\n            state= (state<<8) + avio_r8(pb);\n            if(state == MKBETAG('I', 'N', 'D', 'X')){\n                int n_pkts, expected_len;\n                len = avio_rb32(pb);\n                avio_skip(pb, 2);\n                n_pkts = avio_rb32(pb);\n                expected_len = 20 + n_pkts * 14;\n                if (len == 20)\n                    len = expected_len;\n                else if (len != expected_len)\n                    av_log(s, AV_LOG_WARNING,\n                           \"Index size %d (%d pkts) is wrong, should be %d.\\n\",\n                           len, n_pkts, expected_len);\n                len -= 14; \n                if(len<0)\n                    continue;\n                goto skip;\n            } else if (state == MKBETAG('D','A','T','A')) {\n                av_log(s, AV_LOG_WARNING,\n                       \"DATA tag in middle of chunk, file may be broken.\\n\");\n            }\n            if(state > (unsigned)0xFFFF || state <= 12)\n                continue;\n            len=state - 12;\n            state= 0xFFFFFFFF;\n            num = avio_rb16(pb);\n            *timestamp = avio_rb32(pb);\n            mlti_id = (avio_r8(pb)>>1)-1<<16;\n            mlti_id = FFMAX(mlti_id, 0);\n            *flags = avio_r8(pb); \n        }\n        for(i=0;i<s->nb_streams;i++) {\n            st = s->streams[i];\n            if (mlti_id + num == st->id)\n                break;\n        }\n        if (i == s->nb_streams) {\nskip:\n            avio_skip(pb, len);\n            rm->remaining_len = 0;\n            continue;\n        }\n        *stream_index= i;\n        return len;\n    }\n    return -1;\n}", "target": 0}
{"code": "static MXFPackage* mxf_resolve_source_package(MXFContext *mxf, UID package_uid)\n{\n    MXFPackage *package = NULL;\n    int i;\n    for (i = 0; i < mxf->packages_count; i++) {\n        package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], SourcePackage);\n        if (!package)\n            continue;\n        if (!memcmp(package->package_uid, package_uid, 16))\n            return package;\n    }\n    return NULL;\n}", "target": 0}
{"code": "int emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->eflags &= ~(EFLG_IF | EFLG_TF | EFLG_AC);\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tops->get_idt(ctxt, &dt);\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->_eip = eip;\n\treturn rc;\n}", "target": 0}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg{};\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 0}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "static void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; \n\tvmcs_write32(sf->ar_bytes, ar);\n}", "target": 0}
{"code": "MagickExport Quantum *QueueAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  const int\n    id = GetOpenMPThreadId();\n  Quantum\n    *magick_restrict pixels;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    {\n      pixels=cache_info->methods.queue_authentic_pixels_handler(image,x,y,\n        columns,rows,exception);\n      return(pixels);\n    }\n  assert(id < (int) cache_info->number_threads);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}", "target": 0}
{"code": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}", "target": 1}
{"code": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\tsk_mem_reclaim(sk);\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}", "target": 1}
{"code": "struct page *alloc_huge_page_nodemask(struct hstate *h, int preferred_nid,\n\t\tnodemask_t *nmask, gfp_t gfp_mask)\n{\n\tspin_lock_irq(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0) {\n\t\tstruct page *page;\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, preferred_nid, nmask);\n\t\tif (page) {\n\t\t\tspin_unlock_irq(&hugetlb_lock);\n\t\t\treturn page;\n\t\t}\n\t}\n\tspin_unlock_irq(&hugetlb_lock);\n\treturn alloc_migrate_huge_page(h, gfp_mask, preferred_nid, nmask);\n}", "target": 0}
{"code": "trigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%i\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}", "target": 0}
{"code": "write_VD_terminator(struct archive_write *a)\n{\n\tunsigned char *bp;\n\tbp = wb_buffptr(a) -1;\n\tset_VD_bp(bp, VDT_TERMINATOR, 1);\n\tset_unused_field_bp(bp, 8, LOGICAL_BLOCK_SIZE);\n\treturn (wb_consume(a, LOGICAL_BLOCK_SIZE));\n}", "target": 0}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}", "target": 0}
{"code": "bool UnbufferedAsioTlsStream::IsVerifyOK() const\n{\n\treturn m_VerifyOK;\n}", "target": 1}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "  explicit QuantizeAndDequantizeV2Op(OpKernelConstruction* ctx)\n      : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    string round_mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"round_mode\", &round_mode_string));\n    OP_REQUIRES(\n        ctx,\n        (round_mode_string == \"HALF_UP\" || round_mode_string == \"HALF_TO_EVEN\"),\n        errors::InvalidArgument(\"Round mode string must be \"\n                                \"'HALF_UP' or \"\n                                \"'HALF_TO_EVEN', is '\" +\n                                round_mode_string + \"'\"));\n    if (round_mode_string == \"HALF_UP\") {\n      round_mode_ = ROUND_HALF_UP;\n    } else if (round_mode_string == \"HALF_TO_EVEN\") {\n      round_mode_ = ROUND_HALF_TO_EVEN;\n    }\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n  }", "target": 1}
{"code": "      DSA_Verification_Operation(const DSA_PublicKey& dsa,\n                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {}", "target": 1}
{"code": "_pdfioDictSetValue(\n    pdfio_dict_t   *dict,\t\t\n    const char     *key,\t\t\n    _pdfio_value_t *value)\t\t\n{\n  _pdfio_pair_t\t*pair;\t\t\t\n  PDFIO_DEBUG(\"_pdfioDictSetValue(dict=%p, key=\\\"%s\\\", value=%p)\\n\", dict, key, (void *)value);\n  if (dict->num_pairs > 0)\n  {\n    _pdfio_pair_t\tpkey;\t\t\n    pkey.key = key;\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Replacing existing value.\\n\");\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n      pair->value = *value;\n      return (true);\n    }\n  }\n  if (dict->num_pairs >= dict->alloc_pairs)\n  {\n    _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));\n    if (!temp)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Out of memory.\\n\");\n      return (false);\n    }\n    dict->pairs       = temp;\n    dict->alloc_pairs += 8;\n  }\n  pair = dict->pairs + dict->num_pairs;\n  dict->num_pairs ++;\n  pair->key   = key;\n  pair->value = *value;\n  if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)\n    qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);\n#ifdef DEBUG\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void *)dict, (unsigned long)dict->num_pairs);\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n  PDFIO_DEBUG_DICT(dict);\n  PDFIO_DEBUG(\"\\n\");\n#endif \n  return (true);\n}", "target": 1}
{"code": "void PDFiumEngine::Form_OnChange(FPDF_FORMFILLINFO* param) {\n}", "target": 0}
{"code": "static spl_ptr_heap_element spl_ptr_heap_delete_top(spl_ptr_heap *heap, void *cmp_userdata TSRMLS_DC) { \n\tint i, j;\n\tconst int limit = (heap->count-1)/2;\n\tspl_ptr_heap_element top;\n\tspl_ptr_heap_element bottom;\n\tif (heap->count == 0) {\n\t\treturn NULL;\n\t}\n\ttop    = heap->elements[0];\n\tbottom = heap->elements[--heap->count];\n\tfor( i = 0; i < limit; i = j)\n\t{\n\t\tj = i*2+1;\n\t\tif(j != heap->count && heap->cmp(heap->elements[j+1], heap->elements[j], cmp_userdata TSRMLS_CC) > 0) {\n\t\t\tj++; \n\t\t}\n\t\tif(heap->cmp(bottom, heap->elements[j], cmp_userdata TSRMLS_CC) < 0) {\n\t\t\theap->elements[i] = heap->elements[j];\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (EG(exception)) {\n\t\theap->flags |= SPL_HEAP_CORRUPTED;\n\t}\n\theap->elements[i] = bottom;\n\theap->dtor(top TSRMLS_CC);\n\treturn top;\n}", "target": 0}
{"code": "bool st_select_lex::setup_ref_array(THD *thd, uint order_group_num)\n{\n  if (!((options & SELECT_DISTINCT) && !group_list.elements))\n    hidden_bit_fields= 0;\n  order_group_num*= 2;\n  Query_arena *arena= thd->stmt_arena;\n  const uint n_elems= (n_sum_items +\n                       n_child_sum_items +\n                       item_list.elements +\n                       select_n_reserved +\n                       select_n_having_items +\n                       select_n_where_fields +\n                       order_group_num +\n                       hidden_bit_fields +\n                       fields_in_window_functions) * 5;\n  if (!ref_pointer_array.is_null())\n  {\n    if (ref_pointer_array.size() >= n_elems)\n      return false;\n   }\n  Item **array= static_cast<Item**>(arena->alloc(sizeof(Item*) * n_elems));\n  if (array != NULL)\n    ref_pointer_array= Ref_ptr_array(array, n_elems);\n  return array == NULL;\n}", "target": 1}
{"code": "jpeg_getc (j_decompress_ptr cinfo)\n{\n  struct jpeg_source_mgr *datasrc = cinfo->src;\n  if (datasrc->bytes_in_buffer == 0) {\n    if (! (*datasrc->fill_input_buffer) (cinfo))\n      ERREXIT(cinfo, JERR_CANT_SUSPEND);\n  }\n  datasrc->bytes_in_buffer--;\n  return GETJOCTET(*datasrc->next_input_byte++);\n}", "target": 0}
{"code": "join_read_last(JOIN_TAB *tab)\n{\n  TABLE *table=tab->table;\n  int error= 0;\n  DBUG_ENTER(\"join_read_last\");\n  DBUG_ASSERT(table->no_keyread ||\n              !table->covering_keys.is_set(tab->index) ||\n              table->file->keyread == tab->index);\n  tab->table->status=0;\n  tab->read_record.read_record_func= join_read_prev;\n  tab->read_record.table=table;\n  if (!table->file->inited)\n    error= table->file->ha_index_init(tab->index, 1);\n  if (likely(!error))\n    error= table->file->prepare_index_scan();\n  if (unlikely(error) ||\n      unlikely(error= tab->table->file->ha_index_last(tab->table->record[0])))\n    DBUG_RETURN(report_error(table, error));\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "static int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\treturn ret;\n}", "target": 0}
{"code": "static int __init nf_tables_module_init(void)\n{\n\tint err;\n\tinfo = kmalloc(sizeof(struct nft_expr_info) * NFT_RULE_MAXEXPRS,\n\t\t       GFP_KERNEL);\n\tif (info == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\terr = nf_tables_core_module_init();\n\tif (err < 0)\n\t\tgoto err2;\n\terr = nfnetlink_subsys_register(&nf_tables_subsys);\n\tif (err < 0)\n\t\tgoto err3;\n\tpr_info(\"nf_tables: (c) 2007-2009 Patrick McHardy <kaber@trash.net>\\n\");\n\treturn register_pernet_subsys(&nf_tables_net_ops);\nerr3:\n\tnf_tables_core_module_exit();\nerr2:\n\tkfree(info);\nerr1:\n\treturn err;\n}", "target": 0}
{"code": "join_path_from_pattern(struct glob_pattern **beg)\n{\n    struct glob_pattern *p;\n    char *path = NULL;\n    size_t path_len = 0;\n    for (p = *beg; p; p = p->next) {\n\tconst char *str;\n\tswitch (p->type) {\n\t  case RECURSIVE:\n\t    str = \"**\";\n\t    break;\n\t  case MATCH_DIR:\n\t    str = \"\";\n\t    break;\n\t  default:\n\t    str = p->str;\n\t    if (!str) continue;\n\t}\n\tif (!path) {\n\t    path_len = strlen(str);\n\t    path = GLOB_ALLOC_N(char, path_len + 1);\n\t    memcpy(path, str, path_len);\n\t    path[path_len] = '\\0';\n        }\n        else {\n\t    size_t len = strlen(str);\n\t    char *tmp;\n\t    tmp = GLOB_REALLOC(path, path_len + len + 2);\n\t    if (tmp) {\n\t\tpath = tmp;\n\t\tpath[path_len++] = '/';\n\t\tmemcpy(path + path_len, str, len);\n\t\tpath_len += len;\n\t\tpath[path_len] = '\\0';\n\t    }\n\t}\n    }\n    return path;\n}", "target": 0}
{"code": "int snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,\n\t\t\t\t struct snd_dma_buffer *dmab)\n{\n\tint err;\n\tsnd_assert(size > 0, return -ENXIO);\n\tsnd_assert(dmab != NULL, return -ENXIO);\n\twhile ((err = snd_dma_alloc_pages(type, device, size, dmab)) < 0) {\n\t\tif (err != -ENOMEM)\n\t\t\treturn err;\n\t\tsize >>= 1;\n\t\tif (size <= PAGE_SIZE)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (! dmab->area)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 0}
{"code": "static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\tif(d_len<8) return;\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n\te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n\tifd = iw_get_ui32_e(&d[4],e.endian);\n\tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n}", "target": 1}
{"code": "DECLAREContigPutFunc(putagreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n    (void) y;\n    while (h-- > 0) {\n\tfor (x = w; x-- > 0;)\n        {\n            *cp++ = BWmap[*pp][0] & (*(pp+1) << 24 | ~A1);\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 1}
{"code": "selaGetCombName(SELA    *sela,\n                l_int32  size,\n                l_int32  direction)\n{\nchar    *selname;\nchar     combname[L_BUF_SIZE];\nl_int32  i, nsels, sx, sy, found;\nSEL     *sel;\n    PROCNAME(\"selaGetCombName\");\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (char *)ERROR_PTR(\"invalid direction\", procName, NULL);\n    if (direction == L_HORIZ)\n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dh\", size);\n    else  \n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dv\", size);\n    found = FALSE;\n    nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (sy != 1 && sx != 1)  \n            continue;\n        selname = selGetName(sel);\n        if (!strcmp(selname, combname)) {\n            found = TRUE;\n            break;\n        }\n    }\n    if (found)\n        return stringNew(selname);\n    else\n        return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}", "target": 1}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n  call_once(flag, [this]() {\n    detail::AtFork::registerHandler(\n        this,\n         []() { return true; },\n         []() {},\n        []() {\n          using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n          auto& t = Single::get();\n          t.ptr_ = t.buffer_.get() + t.bufferSize_;\n        });\n  });\n}", "target": 0}
{"code": "static noinline void __schedule_bug(struct task_struct *prev)\n{\n\tif (oops_in_progress)\n\t\treturn;\n\tprintk(KERN_ERR \"BUG: scheduling while atomic: %s/%d/0x%08x\\n\",\n\t\tprev->comm, prev->pid, preempt_count());\n\tdebug_show_held_locks(prev);\n\tprint_modules();\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(prev);\n#ifdef CONFIG_DEBUG_PREEMPT\n\tif (in_atomic_preempt_off()) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(current->preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n#endif\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}", "target": 0}
{"code": "void RootWindowHostWin::SetCapture() {\n  if (!has_capture_) {\n    has_capture_ = true;\n    ::SetCapture(hwnd());\n  }\n}", "target": 0}
{"code": "GetIoStats(Mgr::IoActionData& stats)\n{\n    int i;\n    stats.http_reads = IOStats.Http.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.http_read_hist[i] = IOStats.Http.read_hist[i];\n    }\n    stats.ftp_reads = IOStats.Ftp.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];\n    }\n    stats.gopher_reads = IOStats.Gopher.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];\n    }\n}", "target": 1}
{"code": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\texp = timespec64_to_ktime(*tsreq);\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}", "target": 1}
{"code": "static int check_reg_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t enum reg_arg_type t)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_insn *insn = env->prog->insnsi + env->insn_idx;\n\tstruct bpf_reg_state *reg, *regs = state->regs;\n\tbool rw64;\n\tif (regno >= MAX_BPF_REG) {\n\t\tverbose(env, \"R%d is invalid\\n\", regno);\n\t\treturn -EINVAL;\n\t}\n\tmark_reg_scratched(env, regno);\n\treg = &regs[regno];\n\trw64 = is_reg64(env, insn, regno, reg, t);\n\tif (t == SRC_OP) {\n\t\tif (reg->type == NOT_INIT) {\n\t\t\tverbose(env, \"R%d !read_ok\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (regno == BPF_REG_FP)\n\t\t\treturn 0;\n\t\tif (rw64)\n\t\t\tmark_insn_zext(env, reg);\n\t\treturn mark_reg_read(env, reg, reg->parent,\n\t\t\t\t     rw64 ? REG_LIVE_READ64 : REG_LIVE_READ32);\n\t} else {\n\t\tif (regno == BPF_REG_FP) {\n\t\t\tverbose(env, \"frame pointer is read only\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\treg->live |= REG_LIVE_WRITTEN;\n\t\treg->subreg_def = rw64 ? DEF_NOT_SUBREG : env->insn_idx + 1;\n\t\tif (t == DST_OP)\n\t\t\tmark_reg_unknown(env, regs, regno);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "copy_creds_except(krb5_context context, krb5_ccache incc,\n                  krb5_ccache outcc, krb5_principal princ)\n{\n    krb5_error_code ret, ret2;\n    krb5_cc_cursor cur;\n    krb5_creds creds;\n    ret = krb5_cc_set_flags(context, incc, 0);\n    if (ret)\n        return ret;\n    ret = krb5_cc_start_seq_get(context, incc, &cur);\n    if (ret)\n        goto cleanup;\n    while (!(ret = krb5_cc_next_cred(context, incc, &cur, &creds))) {\n        if (krb5_principal_compare(context, princ, creds.server))\n            continue;\n        ret = krb5_cc_store_cred(context, outcc, &creds);\n        krb5_free_cred_contents(context, &creds);\n        if (ret)\n            goto cleanup;\n    }\n    if (ret != KRB5_CC_END)\n        goto cleanup;\n    ret = 0;\ncleanup:\n    ret2 = krb5_cc_set_flags(context, incc, KRB5_TC_OPENCLOSE);\n    return (ret == 0) ? ret2 : ret;\n}", "target": 0}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno, opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)\n{\n        assert(cstr_index != 00);\n        assert(cstr_index->tile_index != 00);\n        if ((cstr_index->tile_index[tileno].marknum + 1) > cstr_index->tile_index[tileno].maxmarknum) {\n                opj_marker_info_t *new_marker;\n                cstr_index->tile_index[tileno].maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32) cstr_index->tile_index[tileno].maxmarknum);\n                new_marker = (opj_marker_info_t *) opj_realloc(\n                                cstr_index->tile_index[tileno].marker,\n                                cstr_index->tile_index[tileno].maxmarknum *sizeof(opj_marker_info_t));\n                if (! new_marker) {\n                        opj_free(cstr_index->tile_index[tileno].marker);\n                        cstr_index->tile_index[tileno].marker = NULL;\n                        cstr_index->tile_index[tileno].maxmarknum = 0;\n                        cstr_index->tile_index[tileno].marknum = 0;\n                        return OPJ_FALSE;\n                }\n                cstr_index->tile_index[tileno].marker = new_marker;\n        }\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].type = (OPJ_UINT16)type;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].pos = (OPJ_INT32)pos;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].len = (OPJ_INT32)len;\n        cstr_index->tile_index[tileno].marknum++;\n        if (type == J2K_MS_SOT) {\n                OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;\n                if (cstr_index->tile_index[tileno].tp_index)\n                        cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;\n        }\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "Status SpectrogramShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input));\n  int32_t window_size;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"window_size\", &window_size));\n  if (window_size <= 1) {\n    return errors::InvalidArgument(\"window size must be > 1, got \",\n                                   window_size);\n  }\n  int32_t stride;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"stride\", &stride));\n  if (stride <= 0) {\n    return errors::InvalidArgument(\"stride must be strictly positive, got \",\n                                   stride);\n  }\n  DimensionHandle input_length = c->Dim(input, 0);\n  DimensionHandle input_channels = c->Dim(input, 1);\n  DimensionHandle output_length;\n  if (!c->ValueKnown(input_length)) {\n    output_length = c->UnknownDim();\n  } else {\n    const int64_t input_length_value = c->Value(input_length);\n    const int64_t length_minus_window = (input_length_value - window_size);\n    int64_t output_length_value;\n    if (length_minus_window < 0) {\n      output_length_value = 0;\n    } else {\n      output_length_value = 1 + (length_minus_window / stride);\n    }\n    output_length = c->MakeDim(output_length_value);\n  }\n  DimensionHandle output_channels =\n      c->MakeDim(1 + NextPowerOfTwo(window_size) / 2);\n  c->set_output(0,\n                c->MakeShape({input_channels, output_length, output_channels}));\n  return OkStatus();\n}", "target": 0}
{"code": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}", "target": 1}
{"code": "static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tif ((ctxt->rex_prefix & 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tbreak;\n\t}\n\tcs_sel |= SELECTOR_RPL_MASK;\n\tss_sel |= SELECTOR_RPL_MASK;\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tctxt->_eip = reg_read(ctxt, VCPU_REGS_RDX);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = reg_read(ctxt, VCPU_REGS_RCX);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n            if (op == self) {\n                continue;\n            }\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                break;\n            }\n        }\n    }\n}", "target": 1}
{"code": "void skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      prot.readBool(boolv);\n      return;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      prot.readByte(bytev);\n      return;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      prot.readI16(i16);\n      return;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      prot.readI32(i32);\n      return;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      prot.readI64(i64);\n      return;\n    }\n    case TType::T_DOUBLE: {\n      double dub;\n      prot.readDouble(dub);\n      return;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      prot.readFloat(flt);\n      return;\n    }\n    case TType::T_STRING: {\n      std::string str;\n      prot.readBinary(str);\n      return;\n    }\n    case TType::T_STRUCT: {\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      prot.readStructBegin(name);\n      while (true) {\n        prot.readFieldBegin(name, ftype, fid);\n        if (ftype == TType::T_STOP) {\n          break;\n        }\n        apache::thrift::skip(prot, ftype);\n        prot.readFieldEnd();\n      }\n      prot.readStructEnd();\n      return;\n    }\n    case TType::T_MAP: {\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      prot.readMapBegin(keyType, valType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, keyType);\n        apache::thrift::skip(prot, valType);\n      }\n      prot.readMapEnd();\n      return;\n    }\n    case TType::T_SET: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readSetBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readSetEnd();\n      return;\n    }\n    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}", "target": 1}
{"code": "bool task_blocks_signal(pid_t pid, int signal)\n{\n\tint ret;\n\tchar status[__PROC_STATUS_LEN];\n\tFILE *f;\n\tuint64_t sigblk = 0, one = 1;\n\tsize_t n = 0;\n\tbool bret = false;\n\tchar *line = NULL;\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\twhile (getline(&line, &n, f) != -1) {\n\t\tchar *numstr;\n\t\tif (strncmp(line, \"SigBlk:\", 7))\n\t\t\tcontinue;\n\t\tnumstr = lxc_trim_whitespace_in_place(line + 7);\n\t\tret = lxc_safe_uint64(numstr, &sigblk, 16);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tif (sigblk & (one << (signal - 1)))\n\t\tbret = true;\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}", "target": 0}
{"code": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command,\n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out,\n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "TEST_P(RBACIntegrationTest, RouteOverride) {\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             cfg) {\n        envoy::extensions::filters::http::rbac::v3::RBACPerRoute per_route_config;\n        TestUtility::loadFromJson(\"{}\", per_route_config);\n        auto* config = cfg.mutable_route_config()\n                           ->mutable_virtual_hosts()\n                           ->Mutable(0)\n                           ->mutable_typed_per_filter_config();\n        (*config)[Extensions::HttpFilters::HttpFilterNames::get().Rbac].PackFrom(per_route_config);\n      });\n  config_helper_.addFilter(RBAC_CONFIG);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"POST\"},\n          {\":path\", \"/\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"host\"},\n          {\"x-forwarded-for\", \"10.0.0.1\"},\n      },\n      1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": " void PrintWebViewHelper::OnPrintingDone(bool success) {\n  CHECK_LE(ipc_nesting_level_, 1);\n   notify_browser_of_print_failure_ = false;\n   if (!success)\n     LOG(ERROR) << \"Failure in OnPrintingDone\";\n  DidFinishPrinting(success ? OK : FAIL_PRINT);\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, Cookie> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "AWSEngine::authenticate(const req_state* const s) const\n{\n  const auto auth_data = ver_abstractor.get_auth_data(s);\n  if (auth_data.access_key_id.empty() || auth_data.client_signature.empty()) {\n    return result_t::deny(-EINVAL);\n  } else {\n    return authenticate(auth_data.access_key_id,\n\t\t        auth_data.client_signature,\n\t\t\tauth_data.string_to_sign,\n                        auth_data.signature_factory,\n\t\t\tauth_data.completer_factory,\n\t\t\ts);\n  }\n}", "target": 0}
{"code": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}", "target": 1}
{"code": "generate_spc_link(cms_context *cms, SpcLink *slp, SpcLinkType link_type,\n\t\tvoid *link_data, size_t link_data_size)\n{\n\tSpcLink sl;\n\tmemset(&sl, '\\0', sizeof (sl));\n\tsl.type = link_type;\n\tswitch (sl.type) {\n\tcase SpcLinkTypeFile: {\n\t\tint rc = generate_spc_string(cms, &sl.file, link_data,\n\t\t\t\t\tlink_data_size);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tbreak;\n\t}\n\tcase SpcLinkTypeUrl:\n\t\tsl.url.type = siBuffer;\n\t\tsl.url.data = link_data;\n\t\tsl.url.len = link_data_size;\n\t\tbreak;\n\tdefault:\n\t\tcms->log(cms, LOG_ERR, \"Invalid SpcLinkType\");\n\t\treturn -1;\n\t};\n\tmemcpy(slp, &sl, sizeof (sl));\n\treturn 0;\n}", "target": 0}
{"code": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\treturn task;\n}", "target": 1}
{"code": "void dummy_error_processor(THD *thd, void *data)\n{}", "target": 0}
{"code": "static void asmlinkage smm_do_relocation(void *arg)\n{\n\tconst struct smm_module_params *p;\n\tconst struct smm_runtime *runtime;\n\tint cpu;\n\tuintptr_t curr_smbase;\n\tuintptr_t perm_smbase;\n\tp = arg;\n\truntime = p->runtime;\n\tcpu = p->cpu;\n\tcurr_smbase = runtime->smbase;\n\tif (cpu >= CONFIG_MAX_CPUS) {\n\t\tprintk(BIOS_CRIT,\n\t\t       \"Invalid CPU number assigned in SMM stub: %d\\n\", cpu);\n\t\treturn;\n\t}\n\tperm_smbase = mp_state.perm_smbase;\n\tperm_smbase -= cpu * runtime->save_state_size;\n\tprintk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);\n\tmp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);\n\tif (CONFIG(STM)) {\n\t\tuintptr_t mseg;\n\t\tmseg = mp_state.perm_smbase +\n\t\t\t(mp_state.perm_smsize - CONFIG_MSEG_SIZE);\n\t\tstm_setup(mseg, p->cpu,\n\t\t\t\tperm_smbase,\n\t\t\t\tmp_state.perm_smbase,\n\t\t\t\truntime->start32_offset);\n\t}\n}", "target": 1}
{"code": "stl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n  if (stl->error) return;\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       \n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     \n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     \n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}", "target": 1}
{"code": "bool RenderWidgetHostViewAura::CanFocus() {\n  return popup_type_ == blink::WebPopupTypeNone;\n}", "target": 0}
{"code": "bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {\n  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n    if (fs.offset() == offset) {\n      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n      if (fd->is_static() == is_static) return true;\n    }\n  }\n  return false;\n}", "target": 0}
{"code": "key_ref_t search_process_keyrings(struct key_type *type,\n\t\t\t\t  const void *description,\n\t\t\t\t  key_match_func_t match,\n\t\t\t\t  const struct cred *cred)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\tmight_sleep();\n\tkey_ref = search_my_process_keyrings(type, description, match,\n\t\t\t\t\t     false, cred);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\tif (cred->request_key_auth &&\n\t    cred == current_cred() &&\n\t    type != &key_type_request_key_auth\n\t    ) {\n\t\tdown_read(&cred->request_key_auth->sem);\n\t\tif (key_validate(cred->request_key_auth) == 0) {\n\t\t\trka = cred->request_key_auth->payload.data;\n\t\t\tkey_ref = search_process_keyrings(type, description,\n\t\t\t\t\t\t\t  match, rka->cred);\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\nfound:\n\treturn key_ref;\n}", "target": 0}
{"code": "int btrfs_grow_device(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_fs_info *fs_info = device->fs_info;\n\tstruct btrfs_super_block *super_copy = fs_info->super_copy;\n\tstruct btrfs_fs_devices *fs_devices;\n\tu64 old_total;\n\tu64 diff;\n\tif (!test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state))\n\t\treturn -EACCES;\n\tnew_size = round_down(new_size, fs_info->sectorsize);\n\tmutex_lock(&fs_info->chunk_mutex);\n\told_total = btrfs_super_total_bytes(super_copy);\n\tdiff = round_down(new_size - device->total_bytes, fs_info->sectorsize);\n\tif (new_size <= device->total_bytes ||\n\t    test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\treturn -EINVAL;\n\t}\n\tfs_devices = fs_info->fs_devices;\n\tbtrfs_set_super_total_bytes(super_copy,\n\t\t\tround_down(old_total + diff, fs_info->sectorsize));\n\tdevice->fs_devices->total_rw_bytes += diff;\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tbtrfs_clear_space_info_full(device->fs_info);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &fs_devices->resized_devices);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\treturn btrfs_update_device(trans, device);\n}", "target": 0}
{"code": "static int parseValuesReturnFilter (\n\tOperation *op,\n\tSlapReply *rs,\n\tLDAPControl *ctrl )\n{\n\tBerElement\t*ber;\n\tstruct berval\tfstr = BER_BVNULL;\n\tif ( op->o_valuesreturnfilter != SLAP_CONTROL_NONE ) {\n\t\trs->sr_text = \"valuesReturnFilter control specified multiple times\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tif ( BER_BVISNULL( &ctrl->ldctl_value )) {\n\t\trs->sr_text = \"valuesReturnFilter control value is absent\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tif ( BER_BVISEMPTY( &ctrl->ldctl_value )) {\n\t\trs->sr_text = \"valuesReturnFilter control value is empty\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tber = ber_init( &(ctrl->ldctl_value) );\n\tif (ber == NULL) {\n\t\trs->sr_text = \"internal error\";\n\t\treturn LDAP_OTHER;\n\t}\n\trs->sr_err = get_vrFilter( op, ber,\n\t\t(ValuesReturnFilter **)&(op->o_vrFilter), &rs->sr_text);\n\t(void) ber_free( ber, 1 );\n\tif( rs->sr_err != LDAP_SUCCESS ) {\n\t\tif( rs->sr_err == SLAPD_DISCONNECT ) {\n\t\t\trs->sr_err = LDAP_PROTOCOL_ERROR;\n\t\t\tsend_ldap_disconnect( op, rs );\n\t\t\trs->sr_err = SLAPD_DISCONNECT;\n\t\t} else {\n\t\t\tsend_ldap_result( op, rs );\n\t\t}\n\t\tif( op->o_vrFilter != NULL) vrFilter_free( op, op->o_vrFilter ); \n\t}\n#ifdef LDAP_DEBUG\n\telse {\n\t\tvrFilter2bv( op, op->o_vrFilter, &fstr );\n\t}\n\tDebug( LDAP_DEBUG_ARGS, \"\tvrFilter: %s\\n\",\n\t\tfstr.bv_len ? fstr.bv_val : \"empty\", 0, 0 );\n\top->o_tmpfree( fstr.bv_val, op->o_tmpmemctx );\n#endif\n\top->o_valuesreturnfilter = ctrl->ldctl_iscritical\n\t\t? SLAP_CONTROL_CRITICAL\n\t\t: SLAP_CONTROL_NONCRITICAL;\n\trs->sr_err = LDAP_SUCCESS;\n\treturn LDAP_SUCCESS;\n}", "target": 1}
{"code": "static int sip_endpoint_identifier_str2type(const char *str)\n{\n\tint method;\n\tif (!strcasecmp(str, \"username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME;\n\t} else if (!strcasecmp(str, \"auth_username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME;\n\t} else if (!strcasecmp(str, \"ip\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_IP;\n\t} else if (!strcasecmp(str, \"header\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER;\n\t} else if (!strcasecmp(str, \"request_uri\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI;\n\t} else if (!strcasecmp(str, \"transport\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT;\n\t} else {\n\t\tmethod = -1;\n\t}\n\treturn method;\n}", "target": 1}
{"code": "static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  double\n    extent;\n  size_t\n    quantum;\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+(PrimitiveExtentPad+1)*quantum;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if (extent == (double) CastDoubleToLong(extent))\n    {\n      *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n        *mvg_info->primitive_info,(size_t) (extent+1),quantum);\n      if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n        {\n          ssize_t\n            i;\n          *mvg_info->extent=(size_t) extent;\n          for (i=mvg_info->offset+1; i <= (ssize_t) extent; i++)\n          {\n            (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n            (*mvg_info->primitive_info)[i].text=(char *) NULL;\n          }\n          return(MagickTrue);\n        }\n    }\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    *mvg_info->primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(\n      *mvg_info->primitive_info);\n  *mvg_info->primitive_info=(PrimitiveInfo *) AcquireCriticalMemory((size_t) (\n    (PrimitiveExtentPad+1)*quantum));\n  (void) memset(*mvg_info->primitive_info,0,(size_t) ((PrimitiveExtentPad+1)*\n    quantum));\n  *mvg_info->extent=1;\n  mvg_info->offset=0;\n  return(MagickFalse);\n}", "target": 0}
{"code": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n}", "target": 1}
{"code": "static int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "int ssh_scp_close(ssh_scp scp)\n{\n    char buffer[128] = {0};\n    int rc;\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->channel != NULL) {\n        if (ssh_channel_send_eof(scp->channel) == SSH_ERROR) {\n            scp->state = SSH_SCP_ERROR;\n            return SSH_ERROR;\n        }\n        while (!ssh_channel_is_eof(scp->channel)) {\n            rc = ssh_channel_read(scp->channel, buffer, sizeof(buffer), 0);\n            if (rc == SSH_ERROR || rc == 0) {\n                break;\n            }\n        }\n        if (ssh_channel_close(scp->channel) == SSH_ERROR) {\n            scp->state = SSH_SCP_ERROR;\n            return SSH_ERROR;\n        }\n        ssh_channel_free(scp->channel);\n        scp->channel = NULL;\n    }\n    scp->state = SSH_SCP_NEW;\n    return SSH_OK;\n}", "target": 0}
{"code": "int tipc_nl_publ_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tu32 tsk_portid = cb->args[0];\n\tu32 last_publ = cb->args[1];\n\tu32 done = cb->args[2];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_sock *tsk;\n\tif (!tsk_portid) {\n\t\tstruct nlattr **attrs;\n\t\tstruct nlattr *sock[TIPC_NLA_SOCK_MAX + 1];\n\t\terr = tipc_nlmsg_parse(cb->nlh, &attrs);\n \t\tif (err)\n \t\t\treturn err;\n \t\terr = nla_parse_nested(sock, TIPC_NLA_SOCK_MAX,\n \t\t\t\t       attrs[TIPC_NLA_SOCK],\n \t\t\t\t       tipc_nl_sock_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!sock[TIPC_NLA_SOCK_REF])\n\t\t\treturn -EINVAL;\n\t\ttsk_portid = nla_get_u32(sock[TIPC_NLA_SOCK_REF]);\n\t}\n\tif (done)\n\t\treturn 0;\n\ttsk = tipc_sk_lookup(net, tsk_portid);\n\tif (!tsk)\n\t\treturn -EINVAL;\n\tlock_sock(&tsk->sk);\n\terr = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);\n\tif (!err)\n\t\tdone = 1;\n\trelease_sock(&tsk->sk);\n\tsock_put(&tsk->sk);\n\tcb->args[0] = tsk_portid;\n\tcb->args[1] = last_publ;\n\tcb->args[2] = done;\n\treturn skb->len;\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}", "target": 1}
{"code": "static int dsa_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\n{\n    const unsigned char *p, *pm;\n    int pklen, pmlen;\n    int ptype;\n    void *pval;\n    ASN1_STRING *pstr;\n    X509_ALGOR *palg;\n    ASN1_INTEGER *public_key = NULL;\n    DSA *dsa = NULL;\n    if (!X509_PUBKEY_get0_param(NULL, &p, &pklen, &palg, pubkey))\n        return 0;\n    X509_ALGOR_get0(NULL, &ptype, &pval, palg);\n    if (ptype == V_ASN1_SEQUENCE) {\n        pstr = pval;\n        pm = pstr->data;\n        pmlen = pstr->length;\n        if (!(dsa = d2i_DSAparams(NULL, &pm, pmlen))) {\n            DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\n            goto err;\n        }\n    } else if ((ptype == V_ASN1_NULL) || (ptype == V_ASN1_UNDEF)) {\n        if (!(dsa = DSA_new())) {\n            DSAerr(DSA_F_DSA_PUB_DECODE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    } else {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_PARAMETER_ENCODING_ERROR);\n        goto err;\n    }\n    if (!(public_key = d2i_ASN1_INTEGER(NULL, &p, pklen))) {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\n        goto err;\n    }\n    if (!(dsa->pub_key = ASN1_INTEGER_to_BN(public_key, NULL))) {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_BN_DECODE_ERROR);\n        goto err;\n    }\n    ASN1_INTEGER_free(public_key);\n    EVP_PKEY_assign_DSA(pkey, dsa);\n    return 1;\n err:\n    if (public_key)\n        ASN1_INTEGER_free(public_key);\n    if (dsa)\n        DSA_free(dsa);\n    return 0;\n}", "target": 0}
{"code": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t\tput_io_context(ioc);\n\t}\n}", "target": 1}
{"code": "void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}", "target": 1}
{"code": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}", "target": 1}
{"code": "static int ntlm_decode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t payload_offs,\n                             struct ntlm_buffer *field)\n{\n    struct ntlm_buffer b = { NULL, 0 };\n    uint32_t offs;\n    uint16_t len;\n    len = le16toh(hdr->len);\n    if (len == 0) goto done;\n    offs = le32toh(hdr->offset);\n    if ((offs < payload_offs) ||\n        (offs > buffer->length) ||\n        (UINT32_MAX - offs < len) ||\n        (offs + len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    b.data = malloc(len);\n    if (!b.data) return ENOMEM;\n    b.length = len;\n    memcpy(b.data, &buffer->data[offs], b.length);\ndone:\n    *field = b;\n    return 0;\n}", "target": 0}
{"code": "dcchkstr(int size)\n{\n\twhile( (strsize+size) > strmaxsize ) {\n\t\tdcstr=realloc(dcstr,strmaxsize+DCSTRSIZE);\n\t\tstrmaxsize+=DCSTRSIZE;\n\t\tdcptr=dcstr+strsize;\n\t}\n}", "target": 0}
{"code": "ECDSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                      const std::string& params,\n                                      const std::string& provider) const\n   {\n#if defined(BOTAN_HAS_BEARSSL)\n   if(provider == \"bearssl\" || provider.empty())\n      {\n      try\n         {\n         return make_bearssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"bearssl\")\n            throw;\n         }\n      }\n#endif\n#if defined(BOTAN_HAS_OPENSSL)\n   if(provider == \"openssl\" || provider.empty())\n      {\n      try\n         {\n         return make_openssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"openssl\")\n            throw;\n         }\n      }\n#endif\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new ECDSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }", "target": 1}
{"code": "nfsd4_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_copy *copy)\n{\n\tstruct file *src, *dst;\n\t__be32 status;\n\tssize_t bytes;\n\tstatus = nfsd4_verify_copy(rqstp, cstate, &copy->cp_src_stateid, &src,\n\t\t\t\t   &copy->cp_dst_stateid, &dst);\n\tif (status)\n\t\tgoto out;\n\tbytes = nfsd_copy_file_range(src, copy->cp_src_pos,\n\t\t\tdst, copy->cp_dst_pos, copy->cp_count);\n\tif (bytes < 0)\n\t\tstatus = nfserrno(bytes);\n\telse {\n\t\tcopy->cp_res.wr_bytes_written = bytes;\n\t\tcopy->cp_res.wr_stable_how = NFS_UNSTABLE;\n\t\tcopy->cp_consecutive = 1;\n\t\tcopy->cp_synchronous = 1;\n\t\tgen_boot_verifier(&copy->cp_res.wr_verifier, SVC_NET(rqstp));\n\t\tstatus = nfs_ok;\n\t}\n\tfput(src);\n\tfput(dst);\nout:\n\treturn status;\n}", "target": 0}
{"code": "  NullVideoFrame() {}", "target": 0}
{"code": "ref_param_read_float_array(gs_param_list * plist, gs_param_name pkey,\n                           gs_param_float_array * pvalue)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    iparam_loc loc;\n    ref aref, elt;\n    int code = ref_param_read_array(iplist, pkey, &loc);\n    float *pfv;\n    uint size;\n    long i;\n    if (code != 0)\n        return code;\n    size = r_size(loc.pvalue);\n    pfv = (float *)gs_alloc_byte_array(plist->memory, size, sizeof(float),\n                                       \"ref_param_read_float_array\");\n    if (pfv == 0)\n        return_error(gs_error_VMerror);\n    aref = *loc.pvalue;\n    loc.pvalue = &elt;\n    for (i = 0; code >= 0 && i < size; i++) {\n        array_get(plist->memory, &aref, i, &elt);\n        code = float_param(&elt, pfv + i);\n    }\n    if (code < 0) {\n        gs_free_object(plist->memory, pfv, \"ref_read_float_array_param\");\n        return (*loc.presult = code);\n    }\n    pvalue->data = pfv;\n    pvalue->size = size;\n    pvalue->persistent = true;\n    return 0;\n}", "target": 0}
{"code": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}", "target": 1}
{"code": "void cgit_clone_info(void)\n{\n\tif (!ctx.qry.path || strcmp(ctx.qry.path, \"refs\")) {\n\t\tcgit_print_error_page(400, \"Bad request\", \"Bad request\");\n\t\treturn;\n\t}\n\tctx.page.mimetype = \"text/plain\";\n\tctx.page.filename = \"info/refs\";\n\tcgit_print_http_headers();\n\tfor_each_ref(print_ref_info, NULL);\n}", "target": 0}
{"code": "xfs_ioctl_setattr_prepare_dax(\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode            *inode = VFS_I(ip);\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn;\n\tif (xfs_has_dax_always(mp) || xfs_has_dax_never(mp))\n\t\treturn;\n\tif (((fa->fsx_xflags & FS_XFLAG_DAX) &&\n\t    !(ip->i_diflags2 & XFS_DIFLAG2_DAX)) ||\n\t    (!(fa->fsx_xflags & FS_XFLAG_DAX) &&\n\t     (ip->i_diflags2 & XFS_DIFLAG2_DAX)))\n\t\td_mark_dontcache(inode);\n}", "target": 0}
{"code": "rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)\n{\n\tstruct list_head *tail_page, *to_remove, *next_page;\n\tstruct buffer_page *to_remove_page, *tmp_iter_page;\n\tstruct buffer_page *last_page, *first_page;\n\tunsigned long nr_removed;\n\tunsigned long head_bit;\n\tint page_entries;\n\thead_bit = 0;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\ttail_page = &cpu_buffer->tail_page->list;\n\tif (cpu_buffer->tail_page == cpu_buffer->reader_page)\n\t\ttail_page = rb_list_head(tail_page->next);\n\tto_remove = tail_page;\n\tfirst_page = list_entry(rb_list_head(to_remove->next),\n\t\t\t\tstruct buffer_page, list);\n\tfor (nr_removed = 0; nr_removed < nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->next;\n\t\thead_bit |= (unsigned long)to_remove & RB_PAGE_HEAD;\n\t}\n\tnext_page = rb_list_head(to_remove)->next;\n\ttail_page->next = (struct list_head *)((unsigned long)next_page |\n\t\t\t\t\t\thead_bit);\n\tnext_page = rb_list_head(next_page);\n\tnext_page->prev = tail_page;\n\tcpu_buffer->pages = next_page;\n\tif (head_bit)\n\t\tcpu_buffer->head_page = list_entry(next_page,\n\t\t\t\t\t\tstruct buffer_page, list);\n\tcpu_buffer->read = 0;\n\tatomic_dec(&cpu_buffer->record_disabled);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tRB_WARN_ON(cpu_buffer, list_empty(cpu_buffer->pages));\n\tlast_page = list_entry(rb_list_head(to_remove), struct buffer_page,\n\t\t\t\tlist);\n\ttmp_iter_page = first_page;\n\tdo {\n\t\tto_remove_page = tmp_iter_page;\n\t\trb_inc_page(cpu_buffer, &tmp_iter_page);\n\t\tpage_entries = rb_page_entries(to_remove_page);\n\t\tif (page_entries) {\n\t\t\tlocal_add(page_entries, &cpu_buffer->overrun);\n\t\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\t}\n\t\tfree_buffer_page(to_remove_page);\n\t\tnr_removed--;\n\t} while (to_remove_page != last_page);\n\tRB_WARN_ON(cpu_buffer, nr_removed);\n\treturn nr_removed == 0;\n}", "target": 0}
{"code": "header_match(uschar *name, BOOL has_addresses, BOOL cond, string_item *strings,\n  int count, ...)\n{\nva_list ap;\nstring_item *s;\nint i;\nint slen = Ustrlen(name);\nfor (s = strings; s != NULL; s = s->next)\n  {\n  if (one_pattern_match(name, slen, has_addresses, s->text)) return cond;\n  }\nva_start(ap, count);\nfor (i = 0; i < count; i++)\n  if (one_pattern_match(name, slen, has_addresses, va_arg(ap, uschar *)))\n    {\n    va_end(ap);\n    return cond;\n    }\nva_end(ap);\nreturn !cond;\n}", "target": 0}
{"code": "static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}", "target": 1}
{"code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}", "target": 1}
{"code": "aubio_filterbank_get_coeffs (const aubio_filterbank_t * f)\n{\n  return f->filters;\n}", "target": 0}
{"code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                return;\n            }\n            iterator = it->second;\n        }\n        iterator->messages[messageId] = message;\n        if (!iterator->triggered) {\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }", "target": 1}
{"code": "prefix_code(uint8_t *data, size_t size)\n{\n\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n\treturn 0;\n}", "target": 0}
{"code": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}", "target": 1}
{"code": "PHP_FUNCTION(radius_get_vendor_attr)\n{\n\tint res;\n\tconst void *data;\n\tint len;\n\tu_int32_t vendor;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "httpd_addheader(isc_httpd_t *httpd, const char *name, const char *val) {\n\tisc_result_t result;\n\tunsigned int needlen;\n\tREQUIRE(VALID_HTTPD(httpd));\n\tneedlen = strlen(name); \n\tif (val != NULL) {\n\t\tneedlen += 2 + strlen(val); \n\t}\n\tneedlen += 2; \n\twhile (isc_buffer_availablelength(&httpd->headerbuffer) < needlen) {\n\t\tresult = grow_headerspace(httpd);\n\t\tif (result != ISC_R_SUCCESS) {\n\t\t\treturn (result);\n\t\t}\n\t}\n\tif (val != NULL) {\n\t\treturn (isc_buffer_printf(&httpd->headerbuffer, \"%s: %s\\r\\n\",\n\t\t\t\t\t  name, val));\n\t} else {\n\t\treturn (isc_buffer_printf(&httpd->headerbuffer, \"%s\\r\\n\",\n\t\t\t\t\t  name));\n\t}\n}", "target": 0}
{"code": "static void irda_connect_confirm(void *instance, void *sap,\n\t\t\t\t struct qos_info *qos,\n\t\t\t\t __u32 max_sdu_size, __u8 max_header_size,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tself = instance;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tdev_kfree_skb(skb);\n\tself->max_header_size = max_header_size;\n\tself->max_sdu_size_tx = max_sdu_size;\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (max_sdu_size != 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size must be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif (max_sdu_size == 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size cannot be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = max_sdu_size;\n\t\tbreak;\n\tdefault:\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t}\n\tIRDA_DEBUG(2, \"%s(), max_data_size=%d\\n\", __func__,\n\t\t   self->max_data_size);\n\tmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk->sk_state_change(sk);\n}", "target": 0}
{"code": "int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\ttemp = bridge->current_size;\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\tnum_entries -= agp_memory_reserved/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\treturn -EINVAL;\n\t}\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\tj = pg_start;\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}", "target": 1}
{"code": "check_supported(item *new)\n{\nint c = -1;\nint bot = 0;\nint top = supported_elements_count;\nint mid;\ntree_node *tn;\nparamstr *param;\nwhile (top > bot)\n  {\n  mid = (top + bot)/2;\n  c = Ustrcmp(new->name, supported_elements[mid].name);\n  if (c == 0) break;\n  if (c < 0) top = mid; else bot = mid + 1;\n  }\nif (c != 0)\n  {\n  tn = tree_search(unknown_element_tree, new->name);\n  if (tn == NULL)\n    {\n    tn = misc_malloc(sizeof(tree_node) + Ustrlen(new->name));\n    Ustrcpy(tn->name, new->name);\n    (void)tree_insertnode(&unknown_element_tree, tn);\n    }\n  return;\n  }\nfor (param = new->p.param; param != NULL; param = param->next)\n  {\n  uschar buffer[256];\n  uschar **aptr;\n  if (param->name[0] == '#') continue;\n  if (Ustrcmp(param->name, \"revisionflag\") == 0)\n    {\n    if (Ustrcmp(param->value, \"changed\") == 0) continue;\n    (void)sprintf(CS buffer, \"+%s=%s:%s\", param->name, param->value,\n      new->name);\n    }\n  else\n    {\n    aptr = supported_elements[mid].attrs;\n    if (aptr != NULL)\n      {\n      if (Ustrcmp(*aptr, \"*\") == 0) continue;\n      for (; *aptr != NULL; aptr++)\n        if (Ustrcmp(*aptr, param->name) == 0) break;\n      if (*aptr != NULL) continue;\n      }\n    (void)sprintf(CS buffer, \"+%s:%s\", param->name, new->name);\n    }\n  tn = tree_search(unknown_element_tree, buffer);\n  if (tn == NULL)\n    {\n    tn = misc_malloc(sizeof(tree_node) + Ustrlen(buffer));\n    Ustrcpy(tn->name, buffer);\n    (void)tree_insertnode(&unknown_element_tree, tn);\n    }\n  }\n}", "target": 1}
{"code": "MagickExport ChannelPerceptualHash *GetImagePerceptualHash(const Image *image,\n  ExceptionInfo *exception)\n{\n  ChannelPerceptualHash\n    *perceptual_hash;\n  char\n    *colorspaces,\n    *p,\n    *q;\n  const char\n    *artifact;\n  MagickBooleanType\n    status;\n  ssize_t\n    i;\n  perceptual_hash=(ChannelPerceptualHash *) AcquireQuantumMemory(\n    MaxPixelChannels+1UL,sizeof(*perceptual_hash));\n  if (perceptual_hash == (ChannelPerceptualHash *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  artifact=GetImageArtifact(image,\"phash:colorspaces\");\n  if (artifact != NULL)\n    colorspaces=AcquireString(artifact);\n  else\n    colorspaces=AcquireString(\"sRGB,HCLp\");\n  perceptual_hash[0].number_colorspaces=0;\n  perceptual_hash[0].number_channels=0;\n  q=colorspaces;\n  for (i=0; (p=StringToken(\",\",&q)) != (char *) NULL; i++)\n  {\n    ChannelMoments\n      *moments;\n    Image\n      *hash_image;\n    size_t\n      j;\n    ssize_t\n      channel,\n      colorspace;\n    if (i >= MaximumNumberOfPerceptualColorspaces)\n      break;\n    colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,p);\n    if (colorspace < 0)\n      break;\n    perceptual_hash[0].colorspace[i]=(ColorspaceType) colorspace;\n    hash_image=BlurImage(image,0.0,1.0,exception);\n    if (hash_image == (Image *) NULL)\n      break;\n    hash_image->depth=8;\n    status=TransformImageColorspace(hash_image,(ColorspaceType) colorspace,\n      exception);\n    if (status == MagickFalse)\n      break;\n    moments=GetImageMoments(hash_image,exception);\n    perceptual_hash[0].number_colorspaces++;\n    perceptual_hash[0].number_channels+=GetImageChannels(hash_image);\n    hash_image=DestroyImage(hash_image);\n    if (moments == (ChannelMoments *) NULL)\n      break;\n    for (channel=0; channel <= MaxPixelChannels; channel++)\n      for (j=0; j < MaximumNumberOfImageMoments; j++)\n        perceptual_hash[channel].phash[i][j]=\n          (-MagickLog10(moments[channel].invariant[j]));\n    moments=(ChannelMoments *) RelinquishMagickMemory(moments);\n  }\n  colorspaces=DestroyString(colorspaces);\n  return(perceptual_hash);\n}", "target": 0}
{"code": "MagickExport MagickBooleanType DrawPatternPath(Image *image,\n  const DrawInfo *draw_info,const char *name,Image **pattern,\n  ExceptionInfo *exception)\n{\n  char\n    property[MagickPathExtent];\n  const char\n    *geometry,\n    *path,\n    *type;\n  DrawInfo\n    *clone_info;\n  ImageInfo\n    *image_info;\n  MagickBooleanType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  assert(name != (const char *) NULL);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s\",name);\n  path=GetImageArtifact(image,property);\n  if (path == (const char *) NULL)\n    return(MagickFalse);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-geometry\",name);\n  geometry=GetImageArtifact(image,property);\n  if (geometry == (const char *) NULL)\n    return(MagickFalse);\n  if ((*pattern) != (Image *) NULL)\n    *pattern=DestroyImage(*pattern);\n  image_info=AcquireImageInfo();\n  image_info->size=AcquireString(geometry);\n  *pattern=AcquireImage(image_info,exception);\n  image_info=DestroyImageInfo(image_info);\n  (void) QueryColorCompliance(\"#00000000\",AllCompliance,\n    &(*pattern)->background_color,exception);\n  (void) SetImageBackgroundColor(*pattern,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"begin pattern-path %s %s\",name,geometry);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=DestroyImage(clone_info->stroke_pattern);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-type\",name);\n  type=GetImageArtifact(image,property);\n  if (type != (const char *) NULL)\n    clone_info->gradient.type=(GradientType) ParseCommandOption(\n      MagickGradientOptions,MagickFalse,type);\n  (void) CloneString(&clone_info->primitive,path);\n  status=RenderMVGContent(*pattern,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end pattern-path\");\n  return(status);\n}", "target": 0}
{"code": "cd_device_db_set_property (CdDeviceDb *ddb,\n\t\t\t   const gchar *device_id,\n\t\t\t   const gchar *property,\n\t\t\t   const gchar *value,\n\t\t\t   GError  **error)\n{\n\tCdDeviceDbPrivate *priv = GET_PRIVATE (ddb);\n\tgboolean ret = TRUE;\n\tgchar *error_msg = NULL;\n\tgchar *statement;\n\tgint rc;\n\tg_return_val_if_fail (CD_IS_DEVICE_DB (ddb), FALSE);\n\tg_return_val_if_fail (priv->db != NULL, FALSE);\n\tg_debug (\"CdDeviceDb: add device property %s [%s=%s]\",\n\t\t device_id, property, value);\n\tstatement = sqlite3_mprintf (\"INSERT OR REPLACE INTO properties_v2 (device_id, property, value) \"\n\t\t\t\t     \"VALUES ('%q', '%q', '%q');\",\n\t\t\t\t     device_id, property, value);\n\trc = sqlite3_exec (priv->db, statement, NULL, NULL, &error_msg);\n\tif (rc != SQLITE_OK) {\n\t\tg_set_error (error,\n\t\t\t     CD_CLIENT_ERROR,\n\t\t\t     CD_CLIENT_ERROR_INTERNAL,\n\t\t\t     \"SQL error: %s\",\n\t\t\t     error_msg);\n\t\tsqlite3_free (error_msg);\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\nout:\n\tsqlite3_free (statement);\n\treturn ret;\n}", "target": 0}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tunsigned long eip = vcpu->arch.emulate_ctxt.eip;\n\tu32 dr6 = 0;\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1 | DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = kvm_rip_read(vcpu) +\n\t\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}", "target": 1}
{"code": "rfbMpiToBytes(const gcry_mpi_t value, uint8_t *result, size_t size)\n{\n  gcry_error_t error;\n  size_t len;\n  int i;\n  error = gcry_mpi_print(GCRYMPI_FMT_USG, result, size, &len, value);\n  if (gcry_err_code(error) != GPG_ERR_NO_ERROR)\n  {\n    rfbClientLog(\"gcry_mpi_print error: %s\\n\", gcry_strerror(error));\n    return FALSE;\n  }\n  for (i=size-1;i>(int)size-1-(int)len;--i)\n    result[i] = result[i-size+len];\n  for (;i>=0;--i)\n    result[i] = 0;\n  return TRUE;\n}", "target": 0}
{"code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "\t__must_hold(wqe->lock)\n{\n\tstruct io_wqe_acct *acct = io_wqe_get_acct(worker);\n\tstruct io_wqe *wqe = worker->wqe;\n\tif (!(worker->flags & IO_WORKER_F_UP))\n\t\treturn;\n\tif (atomic_dec_and_test(&acct->nr_running) && io_acct_run_queue(acct)) {\n\t\tatomic_inc(&acct->nr_running);\n\t\tatomic_inc(&wqe->wq->worker_refs);\n\t\tio_queue_worker_create(worker, acct, create_worker_cb);\n\t}\n}", "target": 0}
{"code": "static int proc_pid_limits(struct task_struct *task, char *buffer)\n{\n\tunsigned int i;\n\tint count = 0;\n\tunsigned long flags;\n\tchar *bufptr = buffer;\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\trcu_read_lock();\n\tif (!lock_task_sighand(task,&flags)) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\trcu_read_unlock();\n\tcount += sprintf(&bufptr[count], \"%-25s %-20s %-20s %-10s\\n\",\n\t\t\t\"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20s \",\n\t\t\t\t\t lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20lu \",\n\t\t\t\t\t lnames[i].name, rlim[i].rlim_cur);\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-20lu \",\n\t\t\t\t\t rlim[i].rlim_max);\n\t\tif (lnames[i].unit)\n\t\t\tcount += sprintf(&bufptr[count], \"%-10s\\n\",\n\t\t\t\t\t lnames[i].unit);\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"\\n\");\n\t}\n\treturn count;\n}", "target": 0}
{"code": "static int mov_read_rtmd_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    char buf[AV_TIMECODE_STR_SIZE];\n    int64_t cur_pos = avio_tell(sc->pb);\n    int hh, mm, ss, ff, drop;\n    if (!sti->nb_index_entries)\n        return -1;\n    avio_seek(sc->pb, sti->index_entries->pos, SEEK_SET);\n    avio_skip(s->pb, 13);\n    hh = avio_r8(s->pb);\n    mm = avio_r8(s->pb);\n    ss = avio_r8(s->pb);\n    drop = avio_r8(s->pb);\n    ff = avio_r8(s->pb);\n    snprintf(buf, AV_TIMECODE_STR_SIZE, \"%02d:%02d:%02d%c%02d\",\n             hh, mm, ss, drop ? ';' : ':', ff);\n    av_dict_set(&st->metadata, \"timecode\", buf, 0);\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}", "target": 0}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 0}
{"code": "\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\trq->prev_mm = NULL;\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_lock_switch(rq, prev);\n\tfinish_arch_post_lock_switch();\n\tfire_sched_in_preempt_notifiers(current);\n\tif (mm)\n\t\tmmdrop(mm);\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\t\tkprobe_flush_task(prev);\n\t\tput_task_struct(prev);\n\t}\n\ttick_nohz_task_switch();\n\treturn rq;\n}", "target": 0}
{"code": "void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}", "target": 1}
{"code": "static int kvp_process_ip_address(void *addrp,\n\t\t\t\tint family, char *buffer,\n\t\t\t\tint length,  int *offset)\n{\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tint addr_length;\n\tchar tmp[50];\n\tconst char *str;\n\tif (family == AF_INET) {\n\t\taddr = (struct sockaddr_in *)addrp;\n\t\tstr = inet_ntop(family, &addr->sin_addr, tmp, 50);\n\t\taddr_length = INET_ADDRSTRLEN;\n\t} else {\n\t\taddr6 = (struct sockaddr_in6 *)addrp;\n\t\tstr = inet_ntop(family, &addr6->sin6_addr.s6_addr, tmp, 50);\n\t\taddr_length = INET6_ADDRSTRLEN;\n\t}\n\tif ((length - *offset) < addr_length + 2)\n\t\treturn HV_E_FAIL;\n\tif (str == NULL) {\n\t\tstrcpy(buffer, \"inet_ntop failed\\n\");\n\t\treturn HV_E_FAIL;\n\t}\n\tif (*offset == 0)\n\t\tstrcpy(buffer, tmp);\n\telse {\n\t\tstrcat(buffer, \";\");\n\t\tstrcat(buffer, tmp);\n\t}\n\t*offset += strlen(str) + 1;\n\treturn 0;\n}", "target": 0}
{"code": "sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {\n  newspan->_next = before;\n  newspan->_prev = before->_prev;\n  before->_prev->_next = newspan;\n  before->_prev = newspan;\n}", "target": 1}
{"code": "static void nested_mark_vmcs12_pages_dirty(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tgfn_t gfn;\n\tif (nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW)) {\n\t\tgfn = vmcs12->virtual_apic_page_addr >> PAGE_SHIFT;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n\tif (nested_cpu_has_posted_intr(vmcs12)) {\n\t\tgfn = vmcs12->posted_intr_desc_addr >> PAGE_SHIFT;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n}", "target": 0}
{"code": "static bool get_sequence_numbers(struct torture_context *torture,\n\t\t\t\t struct torture_domain_sequence **seqs)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tconst char *extra_data;\n\tchar line[256];\n\tuint32_t count = 0;\n\tstruct torture_domain_sequence *s = NULL;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_SHOW_SEQUENCE, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL sequence list\");\n\twhile (next_token(&extra_data, line, \"\\n\", sizeof(line))) {\n\t\tchar *p, *lp;\n\t\tuint32_t seq;\n\t\ts = talloc_realloc(torture, s, struct torture_domain_sequence,\n\t\t\t\t   count + 2);\n\t\tZERO_STRUCT(s[count+1]);\n\t\tlp = line;\n\t\tp = strchr(lp, ' ');\n\t\ttorture_assert(torture, p, \"invalid line format\");\n\t\t*p = 0;\n\t\ts[count].netbios_name = talloc_strdup(s, lp);\n\t\tlp = p+1;\n\t\ttorture_assert(torture, strncmp(lp, \": \", 2) == 0,\n\t\t\t       \"invalid line format\");\n\t\tlp += 2;\n\t\tif (strcmp(lp, \"DISCONNECTED\") == 0) {\n\t\t\tseq = (uint32_t)-1;\n\t\t} else {\n\t\t\tseq = (uint32_t)strtol(lp, &p, 10);\n\t\t\ttorture_assert(torture, (*p == '\\0'),\n\t\t\t\t       \"invalid line format\");\n\t\t\ttorture_assert(torture, (seq != (uint32_t)-1),\n\t\t\t\t       \"sequence number -1 encountered\");\n\t\t}\n\t\ts[count].seq = seq;\n\t\tcount++;\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\ttorture_assert(torture, count >= 2, \"The list of domain sequence \"\n\t\t       \"numbers should contain 2 entries\");\n\t*seqs = s;\n\treturn true;\n}", "target": 0}
{"code": "static CURLcode imap_state_fetch_resp(struct connectdata *conn, int imapcode,\n                                      imapstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct pingpong *pp = &imapc->pp;\n  const char *ptr = data->state.buffer;\n  bool parsed = FALSE;\n  curl_off_t size = 0;\n  (void)instate; \n  if(imapcode != '*') {\n    Curl_pgrsSetDownloadSize(data, -1);\n    state(conn, IMAP_STOP);\n    return CURLE_REMOTE_FILE_NOT_FOUND; \n  }\n  while(*ptr && (*ptr != '{'))\n    ptr++;\n  if(*ptr == '{') {\n    char *endptr;\n    if(!curlx_strtoofft(ptr + 1, &endptr, 10, &size)) {\n      if(endptr - ptr > 1 && endptr[0] == '}' &&\n         endptr[1] == '\\r' && endptr[2] == '\\0')\n        parsed = TRUE;\n    }\n  }\n  if(parsed) {\n    infof(data, \"Found %\" CURL_FORMAT_CURL_OFF_TU \" bytes to download\\n\",\n          size);\n    Curl_pgrsSetDownloadSize(data, size);\n    if(pp->cache) {\n      size_t chunk = pp->cache_size;\n      if(chunk > (size_t)size)\n        chunk = (size_t)size;\n      result = Curl_client_write(conn, CLIENTWRITE_BODY, pp->cache, chunk);\n      if(result)\n        return result;\n      data->req.bytecount += chunk;\n      infof(data, \"Written %\" CURL_FORMAT_CURL_OFF_TU\n            \" bytes, %\" CURL_FORMAT_CURL_OFF_TU\n            \" bytes are left for transfer\\n\", (curl_off_t)chunk,\n            size - chunk);\n      if(pp->cache_size > chunk) {\n        memmove(pp->cache, pp->cache + chunk, pp->cache_size - chunk);\n        pp->cache_size -= chunk;\n      }\n      else {\n        Curl_safefree(pp->cache);\n        pp->cache_size = 0;\n      }\n    }\n    if(data->req.bytecount == size)\n      Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n    else {\n      data->req.maxdownload = size;\n      Curl_setup_transfer(conn, FIRSTSOCKET, size, FALSE, NULL, -1, NULL);\n    }\n  }\n  else {\n    failf(pp->conn->data, \"Failed to parse FETCH response.\");\n    result = CURLE_WEIRD_SERVER_REPLY;\n  }\n  state(conn, IMAP_STOP);\n  return result;\n}", "target": 1}
{"code": "static int fsmBackup(int dirfd, rpmfi fi, rpmFileAction action)\n{\n    int rc = 0;\n    const char *suffix = NULL;\n    if (!(rpmfiFFlags(fi) & RPMFILE_GHOST)) {\n\tswitch (action) {\n\tcase FA_SAVE:\n\t    suffix = SUFFIX_RPMSAVE;\n\t    break;\n\tcase FA_BACKUP:\n\t    suffix = SUFFIX_RPMORIG;\n\t    break;\n\tdefault:\n\t    break;\n\t}\n    }\n    if (suffix) {\n\tchar * opath = fsmFsPath(fi, NULL);\n\tchar * path = fsmFsPath(fi, suffix);\n\trc = fsmRename(dirfd, opath, dirfd, path);\n\tif (!rc) {\n\t    rpmlog(RPMLOG_WARNING, _(\"%s saved as %s\\n\"), opath, path);\n\t}\n\tfree(path);\n\tfree(opath);\n    }\n    return rc;\n}", "target": 0}
{"code": "static int thread_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\tstruct timespec *tp)\n{\n\treturn posix_cpu_clock_get(THREAD_CLOCK, tp);\n}", "target": 0}
{"code": "static int check_client_redirect_uri_valid(struct _oidc_config * config,\n                                           const char * client_id,\n                                           const char * redirect_uri,\n                                           const char * ip_source) {\n  json_t * j_client = config->glewlwyd_config->glewlwyd_plugin_callback_get_client(config->glewlwyd_config, client_id);\n  int uri_found = 0, ret;\n  if (check_result_value(j_client, G_OK) && json_object_get(json_object_get(j_client, \"client\"), \"enabled\") == json_true()) {\n    if (!o_strnullempty(redirect_uri)) {\n      if (json_array_has_string(json_object_get(json_object_get(j_client, \"client\"), \"redirect_uri\"), redirect_uri)) {\n        uri_found = 1;\n      } else {\n        uri_found = 0;\n      }\n    } else {\n      uri_found = 1;\n    }\n    if (!uri_found) {\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_redirect_uri_valid - oidc - Error, redirect_uri '%s' is invalid for the client '%s', origin: %s\", redirect_uri, client_id, ip_source);\n      ret = G_ERROR_UNAUTHORIZED;\n    } else {\n      ret = G_OK;\n    }\n  } else {\n    ret = G_ERROR_UNAUTHORIZED;\n  }\n  json_decref(j_client);\n  return ret;\n}", "target": 1}
{"code": "int perf_event_overflow(struct perf_event *event,\n\t\t\t  struct perf_sample_data *data,\n\t\t\t  struct pt_regs *regs)\n{\n\treturn __perf_event_overflow(event, 1, data, regs);\n}", "target": 0}
{"code": "static inline void *packet_current_rx_frame(struct packet_sock *po,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    int status, unsigned int len)\n{\n\tchar *curr = NULL;\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\tcase TPACKET_V2:\n\t\tcurr = packet_lookup_frame(po, &po->rx_ring,\n\t\t\t\t\tpo->rx_ring.head, status);\n\t\treturn curr;\n\tcase TPACKET_V3:\n\t\treturn __packet_lookup_frame_in_block(po, skb, status, len);\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported\\n\");\n\t\tBUG();\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "void blk_cleanup_queue(struct request_queue *q)\n{\n\tmutex_lock(&q->sysfs_lock);\n\tblk_set_queue_dying(q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOXMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_DYING, q);\n\tmutex_unlock(&q->sysfs_lock);\n\tblk_freeze_queue(q);\n\trq_qos_exit(q);\n\tblk_queue_flag_set(QUEUE_FLAG_DEAD, q);\n\tblk_flush_integrity();\n\tdel_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer);\n\tblk_sync_queue(q);\n\tif (queue_is_mq(q))\n\t\tblk_mq_exit_queue(q);\n\tpercpu_ref_exit(&q->q_usage_counter);\n\tblk_put_queue(q);\n}", "target": 1}
{"code": "static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    uint8_t version, flags;\n    CHECK(avifROStreamRead(&s, &version, 1)); \n    if (version != 0) {\n        return AVIF_FALSE;\n    }\n    CHECK(avifROStreamRead(&s, &flags, 1));         \n    CHECK(avifROStreamRead(&s, &grid->rows, 1));    \n    CHECK(avifROStreamRead(&s, &grid->columns, 1)); \n    ++grid->rows;\n    ++grid->columns;\n    uint32_t fieldLength = ((flags & 1) + 1) * 16;\n    if (fieldLength == 16) {\n        uint16_t outputWidth16, outputHeight16;\n        CHECK(avifROStreamReadU16(&s, &outputWidth16));  \n        CHECK(avifROStreamReadU16(&s, &outputHeight16)); \n        grid->outputWidth = outputWidth16;\n        grid->outputHeight = outputHeight16;\n    } else {\n        if (fieldLength != 32) {\n            return AVIF_FALSE;\n        }\n        CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  \n        CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); \n    }\n    return AVIF_TRUE;\n}", "target": 1}
{"code": "int unit_name_build(const char *prefix, const char *instance, const char *suffix, char **ret) {\n        UnitType type;\n        assert(prefix);\n        assert(suffix);\n        assert(ret);\n        if (suffix[0] != '.')\n                return -EINVAL;\n        type = unit_type_from_string(suffix + 1);\n        if (type < 0)\n                return -EINVAL;\n        return unit_name_build_from_type(prefix, instance, type, ret);\n}", "target": 0}
{"code": "void zmq::stream_engine_t::mechanism_ready ()\n{\n    if (options.recv_identity) {\n        msg_t identity;\n        mechanism->peer_identity (&identity);\n        const int rc = session->push_msg (&identity);\n        if (rc == -1 && errno == EAGAIN) {\n            return;\n        }\n        errno_assert (rc == 0);\n        session->flush ();\n    }\n    next_msg = &stream_engine_t::pull_and_encode;\n    process_msg = &stream_engine_t::write_credential;\n    typedef metadata_t::dict_t properties_t;\n    properties_t properties;\n    properties_t::const_iterator it;\n    const properties_t& zap_properties = mechanism->get_zap_properties ();\n    it = zap_properties.begin ();\n    while (it != zap_properties.end ()) {\n        properties.insert (properties_t::value_type (it->first, it->second));\n        it++;\n    }\n    const properties_t& zmtp_properties = mechanism->get_zmtp_properties ();\n    it = zmtp_properties.begin ();\n    while (it != zmtp_properties.end ()) {\n        properties.insert (properties_t::value_type (it->first, it->second));\n        it++;\n    }\n    zmq_assert (metadata == NULL);\n    if (!properties.empty ())\n        metadata = new (std::nothrow) metadata_t (properties);\n}", "target": 0}
{"code": "static void imap_login_preinit(void)\n{\n\tlogin_set_roots = imap_login_setting_roots;\n}", "target": 0}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tr14\\n\" \n\t\t\"=BP\tsrp\\n\" \n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr0\\n\"\n\t\t\"=A1\tr1\\n\"\n\t\t\"=A2\tr2\\n\"\n\t\t\"=A3\tr3\\n\"\n\t\t\"gpr\tsp\t.32\t56\t0\\n\" \n\t\t\"gpr\tacr\t.32\t60\t0\\n\" \n\t\t\"gpr\tpc\t.32\t64\t0\\n\" \n\t\t\"gpr\tsrp\t.32\t68\t0\\n\" \n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t;\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "static inline void write_desc(struct intel_engine_execlists *execlists, u64 desc, u32 port)\n{\n\tif (execlists->ctrl_reg) {\n\t\twritel(lower_32_bits(desc), execlists->submit_reg + port * 2);\n\t\twritel(upper_32_bits(desc), execlists->submit_reg + port * 2 + 1);\n\t} else {\n\t\twritel(upper_32_bits(desc), execlists->submit_reg);\n\t\twritel(lower_32_bits(desc), execlists->submit_reg);\n\t}\n}", "target": 0}
{"code": "test_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}", "target": 1}
{"code": "bool HHVM_FUNCTION(krsort,\n                   VRefParam array,\n                   int sort_flags ) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_ksort(array, sort_flags, false, use_zend_sort);\n}", "target": 0}
{"code": "ldap_pvt_tls_get_peer_dn( void *s, struct berval *dn,\n\tLDAPDN_rewrite_dummy *func, unsigned flags )\n{\n\ttls_session *session = s;\n\tstruct berval bvdn;\n\tint rc;\n\trc = tls_imp->ti_session_peer_dn( session, &bvdn );\n\tif ( rc ) return rc;\n\trc = ldap_X509dn2bv( &bvdn, dn, \n\t\t\t    (LDAPDN_rewrite_func *)func, flags);\n\treturn rc;\n}", "target": 0}
{"code": "static int decode_secinfo_common(struct xdr_stream *xdr, struct nfs4_secinfo_res *res)\n{\n\tstruct nfs4_secinfo_flavor *sec_flavor;\n\tint status;\n\t__be32 *p;\n\tint i, num_flavors;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tres->flavors->num_flavors = 0;\n\tnum_flavors = be32_to_cpup(p);\n\tfor (i = 0; i < num_flavors; i++) {\n\t\tsec_flavor = &res->flavors->flavors[i];\n\t\tif ((char *)&sec_flavor[1] - (char *)res->flavors > PAGE_SIZE)\n\t\t\tbreak;\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\tsec_flavor->flavor = be32_to_cpup(p);\n\t\tif (sec_flavor->flavor == RPC_AUTH_GSS) {\n\t\t\tstatus = decode_secinfo_gss(xdr, sec_flavor);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tres->flavors->num_flavors++;\n\t}\n\tstatus = 0;\nout:\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "uint16_t read16(uint8_t* arr, int pos,  int swapBytes)\n{\n    uint8_t b1 = arr[pos];\n    uint8_t b2 = arr[pos+1];\n    return (swapBytes) ?  ((b2 << 8) | b1) : ((b1 << 8) | b2);\n}", "target": 0}
{"code": "static __be16 sctp_get_asconf_response(struct sctp_chunk *asconf_ack,\n\t\t\t\t      sctp_addip_param_t *asconf_param,\n\t\t\t\t      int no_err)\n{\n\tsctp_addip_param_t\t*asconf_ack_param;\n\tsctp_errhdr_t\t\t*err_param;\n\tint\t\t\tlength;\n\tint\t\t\tasconf_ack_len;\n\t__be16\t\t\terr_code;\n\tif (no_err)\n\t\terr_code = SCTP_ERROR_NO_ERROR;\n\telse\n\t\terr_code = SCTP_ERROR_REQ_REFUSED;\n\tasconf_ack_len = ntohs(asconf_ack->chunk_hdr->length) -\n\t\t\t     sizeof(sctp_chunkhdr_t);\n\tlength = sizeof(sctp_addiphdr_t);\n\tasconf_ack_param = (sctp_addip_param_t *)(asconf_ack->skb->data +\n\t\t\t\t\t\t  length);\n\tasconf_ack_len -= length;\n\twhile (asconf_ack_len > 0) {\n\t\tif (asconf_ack_param->crr_id == asconf_param->crr_id) {\n\t\t\tswitch (asconf_ack_param->param_hdr.type) {\n\t\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\t\t\treturn SCTP_ERROR_NO_ERROR;\n\t\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\t\tlength = sizeof(sctp_addip_param_t);\n\t\t\t\terr_param = (void *)asconf_ack_param + length;\n\t\t\t\tasconf_ack_len -= length;\n\t\t\t\tif (asconf_ack_len > 0)\n\t\t\t\t\treturn err_param->cause;\n\t\t\t\telse\n\t\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\t\tlength = ntohs(asconf_ack_param->param_hdr.length);\n\t\tasconf_ack_param = (void *)asconf_ack_param + length;\n\t\tasconf_ack_len -= length;\n\t}\n\treturn err_code;\n}", "target": 0}
{"code": "BOOL license_read_product_info(wStream* s, PRODUCT_INFO* productInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\tStream_Read_UINT32(s, productInfo->dwVersion); \n\tStream_Read_UINT32(s, productInfo->cbCompanyName); \n\tif (Stream_GetRemainingLength(s) < productInfo->cbCompanyName + 4)\n\t\treturn FALSE;\n\tproductInfo->pbCompanyName = (BYTE*) malloc(productInfo->cbCompanyName);\n\tStream_Read(s, productInfo->pbCompanyName, productInfo->cbCompanyName);\n\tStream_Read_UINT32(s, productInfo->cbProductId); \n\tif (Stream_GetRemainingLength(s) < productInfo->cbProductId)\n\t{\n\t\tfree(productInfo->pbCompanyName);\n\t\tproductInfo->pbCompanyName = NULL;\n\t\treturn FALSE;\n\t}\n\tproductInfo->pbProductId = (BYTE*) malloc(productInfo->cbProductId);\n\tStream_Read(s, productInfo->pbProductId, productInfo->cbProductId);\n\treturn TRUE;\n}", "target": 0}
{"code": "unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n\t\tif (optptr[0] == IPOPT_CIPSO)\n\t\t\treturn optptr;\n\t\ttaglen = optptr[1];\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "update_info_drive_ports (Device *device)\n{\n  GList *ports;\n  GList *l;\n  GPtrArray *p;\n  ports = daemon_local_find_enclosing_ports (device->priv->daemon, device->priv->native_path);\n  p = g_ptr_array_new ();\n  for (l = ports; l != NULL; l = l->next)\n    {\n      Port *port = PORT (l->data);\n      g_ptr_array_add (p, (gpointer) port_local_get_object_path (port));\n    }\n  g_ptr_array_add (p, NULL);\n  device_set_drive_ports (device, (GStrv) p->pdata);\n  g_ptr_array_unref (p);\n  g_list_free (ports);\n  return TRUE;\n}", "target": 0}
{"code": "static bool is_ctx_reg(struct bpf_verifier_env *env, int regno)\n{\n\tconst struct bpf_reg_state *reg = reg_state(env, regno);\n\treturn reg->type == PTR_TO_CTX;\n}", "target": 0}
{"code": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    return self;\n}", "target": 1}
{"code": "translate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace(*s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}", "target": 1}
{"code": "create_llao(uint8_t *llao, uint8_t type)\n{\n  llao[UIP_ND6_OPT_TYPE_OFFSET] = type;\n  llao[UIP_ND6_OPT_LEN_OFFSET] = UIP_ND6_OPT_LLAO_LEN >> 3;\n  memcpy(&llao[UIP_ND6_OPT_DATA_OFFSET], &uip_lladdr, UIP_LLADDR_LEN);\n  memset(&llao[UIP_ND6_OPT_DATA_OFFSET + UIP_LLADDR_LEN], 0,\n         UIP_ND6_OPT_LLAO_LEN - 2 - UIP_LLADDR_LEN);\n}", "target": 0}
{"code": "  bool empty() const override { return value_ == nullptr ? true : value_->empty(); }", "target": 0}
{"code": "static GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif \n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}", "target": 1}
{"code": "set_lenIV(char *line)\n{\n  char *p = strstr(line, \"/lenIV \");\n  if (p && (isdigit(p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}", "target": 1}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink)) {\n\t\t\t\tget_file(epi->ffd.file);\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "long keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "void msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}", "target": 1}
{"code": "static bool rbuf_switch_to_malloc(conn *c) {\n    size_t size = c->rsize * 2;\n    char *tmp = malloc(size);\n    if (!tmp)\n        return false;\n    do_cache_free(c->thread->rbuf_cache, c->rbuf);\n    memcpy(tmp, c->rcurr, c->rbytes);\n    c->rcurr = c->rbuf = tmp;\n    c->rsize = size;\n    c->rbuf_malloced = true;\n    return true;\n}", "target": 0}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev, VhostUserMsg *msg)\n{\n\tuint16_t vring_idx;\n\tswitch (msg->request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = msg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = msg->payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = msg->payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\"invalid vring index: %u\\n\", vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 0}
{"code": "static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\t\tif (tu->timeri)\t\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\ttu->tread = xarg ? 1 : 0;\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}", "target": 0}
{"code": "static int dsa_missing_parameters(const EVP_PKEY *pkey)\n{\n    DSA *dsa;\n    dsa = pkey->pkey.dsa;\n    if ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "static uint64_t HTPStateGetTxCnt(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        const int64_t size = (int64_t)htp_list_size(http_state->conn->transactions);\n        if (size < 0)\n            return 0ULL;\n        SCLogDebug(\"size %\"PRIu64, size);\n        return (uint64_t)size;\n    } else {\n        return 0ULL;\n    }\n}", "target": 1}
{"code": "Status ValidatePaddingValues(absl::Span<const int64_t> input_dimensions,\n                             absl::Span<const int64_t> window_dimensions,\n                             absl::Span<const int64_t> window_strides) {\n  bool ok = input_dimensions.size() == window_dimensions.size() &&\n            input_dimensions.size() == window_strides.size();\n  if (!ok) {\n    return InvalidArgument(\n        \"Want input dimensions size %u = window dimensions size %u = window \"\n        \"strides size %u\",\n        input_dimensions.size(), window_dimensions.size(),\n        window_strides.size());\n  }\n  for (size_t i = 0; i < input_dimensions.size(); ++i) {\n    if (window_dimensions[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive size %d\", i,\n                             window_dimensions[i]);\n    }\n    if (window_strides[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive stride %d\",\n                             i, window_strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64 start, int64 limit) {\n      const int64 batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64 output_size_per_batch = grad_out->NumElements() / batch_size;\n      const int64 input_size_per_batch = grad_in.NumElements() / batch_size;\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n        const int64 output_start = start * output_size_per_batch;\n        const int64 output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64 index = input_start; index < input_end; index++) {\n          if (index >= argmax.NumElements()) {\n            break;\n          }\n          int64 grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64 cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n    const int64 batch_size = GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64 shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }", "target": 0}
{"code": "static inline struct sctp_ulpevent *sctp_ulpq_retrieve_partial(struct sctp_ulpq *ulpq)\n{\n\tstruct sk_buff *pos, *last_frag, *first_frag;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 ctsn, next_tsn;\n\tint is_last;\n\tstruct sctp_ulpevent *retval;\n\tif (skb_queue_empty(&ulpq->reasm))\n\t\treturn NULL;\n\tlast_frag = first_frag = NULL;\n\tretval = NULL;\n\tnext_tsn = 0;\n\tis_last = 0;\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (!first_frag) {\n\t\t\t\tfirst_frag = pos;\n\t\t\t\tnext_tsn = ctsn + 1;\n\t\t\t\tlast_frag = pos;\n\t\t\t} else if (next_tsn == ctsn)\n\t\t\t\tnext_tsn++;\n\t\t\telse\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (!first_frag)\n\t\t\t\tfirst_frag = pos;\n\t\t\telse if (ctsn != next_tsn)\n\t\t\t\tgoto done;\n\t\t\tlast_frag = pos;\n\t\t\tis_last = 1;\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t};\n\t}\ndone:\n\tretval = sctp_make_reassembled_event(&ulpq->reasm, first_frag, last_frag);\n\tif (retval && is_last)\n\t\tretval->msg_flags |= MSG_EOR;\n\treturn retval;\n}", "target": 0}
{"code": "pidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}", "target": 1}
{"code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\t\tnewdst = 0;\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}", "target": 1}
{"code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint error = sock_error(sk);\n\tif (error)\n\t\tgoto no_packet;\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tdo {\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n\t\tskb_queue_walk(queue, skb) {\n\t\t\t*peeked = skb->peeked;\n\t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n\t\t\t\t\t*off -= skb->len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (!wait_for_packet(sk, err, &timeo));\n\treturn NULL;\nno_packet:\n\t*err = error;\n\treturn NULL;\n}", "target": 1}
{"code": "static void handleOutputMode(void* data, struct wl_output* wl_output, uint32_t flags, int32_t width, int32_t height, int32_t refresh) {\n    const auto POUTPUT = (SOutput*)data;\n    POUTPUT->refreshRate = std::round(refresh / 1000.0);\n}", "target": 1}
{"code": "mbc_case_fold(OnigCaseFoldType flag,\n\t      const UChar** pp, const UChar* end ARG_UNUSED, UChar* lower,\n\t      OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  if (*p == 0xdf && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    *lower++ = 's';\n    *lower   = 's';\n    (*pp)++;\n    return 2;\n  }\n  *lower = ENC_ISO_8859_2_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1; \n}", "target": 0}
{"code": "void __do_SAK(struct tty_struct *tty)\n{\n#ifdef TTY_SOFT_SAK\n\ttty_hangup(tty);\n#else\n\tstruct task_struct *g, *p;\n\tstruct pid *session;\n\tint\t\ti;\n\tif (!tty)\n\t\treturn;\n\tsession = tty->session;\n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\tread_lock(&tasklist_lock);\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\ttty_notice(tty, \"SAK: killed process %d (%s): by session\\n\",\n\t\t\t   task_pid_nr(p), p->comm);\n\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n\tdo_each_thread(g, p) {\n\t\tif (p->signal->tty == tty) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by controlling tty\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_lock(p);\n\t\ti = iterate_fd(p->files, 0, this_tty, tty);\n\t\tif (i != 0) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by fd#%d\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t}\n\t\ttask_unlock(p);\n\t} while_each_thread(g, p);\n\tread_unlock(&tasklist_lock);\n#endif\n}", "target": 1}
{"code": "pci_lintr_deassert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == ASSERTED) {\n\t\tdev->lintr.state = IDLE;\n\t\tpci_irq_deassert(dev);\n\t} else if (dev->lintr.state == PENDING)\n\t\tdev->lintr.state = IDLE;\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)\n{\n\tif (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)\n\t\tfatal(\"%s: mm_zalloc(%u, %u)\", __func__, ncount, size);\n\treturn mm_malloc(mm, size * ncount);\n}", "target": 1}
{"code": "uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,\n                                 const QString &app_icon, const QString &summary, const QString &body,\n                                 const QStringList &actions, const QVariantMap &hints, int timeout)\n{\n    uint partOf = 0;\n    const QString appRealName = hints[QStringLiteral(\"x-kde-appname\")].toString();\n    const QString eventId = hints[QStringLiteral(\"x-kde-eventId\")].toString();\n    const bool skipGrouping = hints[QStringLiteral(\"x-kde-skipGrouping\")].toBool();\n    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {\n        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();\n    }\n     qDebug() << \"Currrent active notifications:\" << m_activeNotifications;\n     qDebug() << \"Guessing partOf as:\" << partOf;\n     qDebug() << \" New Notification: \" << summary << body << timeout << \"& Part of:\" << partOf;\n    QString _body;\n     if (partOf > 0) {\n         const QString source = QStringLiteral(\"notification %1\").arg(partOf);\n         Plasma::DataContainer *container = containerForSource(source);\n         if (container) {\n            _body = container->data()[QStringLiteral(\"body\")].toString();\n            if (_body != body) {\n                _body.append(\"\\n\").append(body);\n            } else {\n                _body = body;\n             }\n             replaces_id = partOf;\n            CloseNotification(partOf);\n        }\n    }\n    uint id = replaces_id ? replaces_id : m_nextId++;\n    if (m_alwaysReplaceAppsList.contains(app_name)) {\n        if (m_notificationsFromReplaceableApp.contains(app_name)) {\n            id = m_notificationsFromReplaceableApp.value(app_name);\n        } else {\n            m_notificationsFromReplaceableApp.insert(app_name, id);\n        }\n    }\n    QString appname_str = app_name;\n    if (appname_str.isEmpty()) {\n        appname_str = i18n(\"Unknown Application\");\n    }\n    bool isPersistent = timeout == 0;\n     const int AVERAGE_WORD_LENGTH = 6;\n     const int WORD_PER_MINUTE = 250;\n    int count = summary.length() + body.length();\n        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;\n        timeout = 2000 + qMax(timeout, 3000);\n    }", "target": 1}
{"code": "static void addrconf_dev_config(struct net_device *dev)\n{\n\tstruct in6_addr addr;\n\tstruct inet6_dev *idev;\n\tASSERT_RTNL();\n\tif ((dev->type != ARPHRD_ETHER) &&\n\t    (dev->type != ARPHRD_FDDI) &&\n\t    (dev->type != ARPHRD_ARCNET) &&\n\t    (dev->type != ARPHRD_INFINIBAND) &&\n\t    (dev->type != ARPHRD_IEEE802154) &&\n\t    (dev->type != ARPHRD_IEEE1394)) {\n\t\treturn;\n\t}\n\tidev = addrconf_add_dev(dev);\n\tif (IS_ERR(idev))\n\t\treturn;\n\tmemset(&addr, 0, sizeof(struct in6_addr));\n\taddr.s6_addr32[0] = htonl(0xFE800000);\n\tif (ipv6_generate_eui64(addr.s6_addr + 8, dev) == 0)\n\t\taddrconf_add_linklocal(idev, &addr);\n}", "target": 0}
{"code": "static void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tspin_lock(&n->list_lock);\n\tn->nr_partial++;\n\tif (tail)\n\t\tlist_add_tail(&page->lru, &n->partial);\n\telse\n\t\tlist_add(&page->lru, &n->partial);\n\tspin_unlock(&n->list_lock);\n}", "target": 0}
{"code": "  Declaration_Obj Parser::parse_declaration() {\n    String_Obj prop;\n    bool is_custom_property = false;\n    if (lex< sequence< optional< exactly<'*'> >, identifier_schema > >()) {\n      const std::string property(lexed);\n      is_custom_property = property.compare(0, 2, \"--\") == 0;\n      prop = parse_identifier_schema();\n    }\n    else if (lex< sequence< optional< exactly<'*'> >, identifier, zero_plus< block_comment > > >()) {\n      const std::string property(lexed);\n      is_custom_property = property.compare(0, 2, \"--\") == 0;\n      prop = SASS_MEMORY_NEW(String_Constant, pstate, lexed);\n    }\n    else {\n      css_error(\"Invalid CSS\", \" after \", \": expected \\\"}\\\", was \");\n    }\n    bool is_indented = true;\n    const std::string property(lexed);\n    if (!lex_css< one_plus< exactly<':'> > >()) error(\"property \\\"\" + escape_string(property)  + \"\\\" must be followed by a ':'\");\n    if (!is_custom_property && match< sequence< optional_css_comments, exactly<';'> > >()) error(\"style declaration must contain a value\");\n    if (match< sequence< optional_css_comments, exactly<'{'> > >()) is_indented = false; \n    if (is_custom_property) {\n      return SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, parse_css_variable_value(), false, true);\n    }\n    lex < css_comments >(false);\n    if (peek_css< static_value >()) {\n      return SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, parse_static_value());\n    }\n    else {\n      Expression_Obj value;\n      Lookahead lookahead = lookahead_for_value(position);\n      if (lookahead.found) {\n        if (lookahead.has_interpolants) {\n          value = parse_value_schema(lookahead.found);\n        } else {\n          value = parse_list(DELAYED);\n        }\n      }\n      else {\n        value = parse_list(DELAYED);\n        if (List* list = Cast<List>(value)) {\n          if (!list->is_bracketed() && list->length() == 0 && !peek< exactly <'{'> >()) {\n            css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");\n          }\n        }\n      }\n      lex < css_comments >(false);\n      Declaration_Obj decl = SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, value);\n      decl->is_indented(is_indented);\n      decl->update_pstate(pstate);\n      return decl;\n    }\n  }", "target": 0}
{"code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}", "target": 1}
{"code": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n    for (i = 0; i < 5; i++)\n        s->response[i] = qemu_get_be32(f);\n    s->arglen = qemu_get_be32(f);\n    s->response_pos = qemu_get_be32(f);\n    s->stopping = qemu_get_be32(f);\n    ss->cs = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": "void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tif (nft_set_is_anonymous(set))\n\t\tnft_clear(ctx->net, set);\n\tset->use++;\n}", "target": 0}
{"code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  int64_t nnz = a_indices->dim_size(0);\n  int64_t ndims = a_indices->dim_size(1);\n  if (a_values->dim_size(0) != nnz) {\n    return errors::InvalidArgument(\"Dimensions \", nnz, \" and \",\n                                   a_values->dim_size(0),\n                                   \" are not compatible\");\n  }\n  if (a_shape->dim_size(0) != ndims) {\n    return errors::InvalidArgument(\"Dimensions \", ndims, \" and \",\n                                   a_shape->dim_size(0), \" are not compatible\");\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  const auto a_indices_mat = a_indices->flat_inner_dims<Index>();\n  for (int64_t zidx = 0; zidx < nnz; ++zidx) {\n    for (int64_t didx = 0; didx < ndims; ++didx) {\n      const Index idx = a_indices_mat(zidx, didx);\n      if (idx < 0 || idx >= a_shape_flat(didx)) {\n        return errors::InvalidArgument(\n            \"Sparse tensor has an invalid index on dimension \", didx,\n            \": \"\n            \"a_indices(\",\n            zidx, \",\", didx, \") = \", idx,\n            \", dense tensor shape: \", a_shape_flat);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "ins_ctrl_(void)\n{\n    if (revins_on && revins_chars && revins_scol >= 0)\n    {\n\twhile (gchar_cursor() != NUL && revins_chars--)\n\t    ++curwin->w_cursor.col;\n    }\n    p_ri = !p_ri;\n    revins_on = (State == INSERT && p_ri);\n    if (revins_on)\n    {\n\trevins_scol = curwin->w_cursor.col;\n\trevins_legal++;\n\trevins_chars = 0;\n\tundisplay_dollar();\n    }\n    else\n\trevins_scol = -1;\n    p_hkmap = curwin->w_p_rl ^ p_ri;    \n    showmode();\n}", "target": 0}
{"code": "int seccomp_lock_personality(unsigned long personality) {\n        uint32_t arch;\n        int r;\n        if (personality >= PERSONALITY_INVALID)\n                return -EINVAL;\n        SECCOMP_FOREACH_LOCAL_ARCH(arch) {\n                _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;\n                r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ALLOW);\n                if (r < 0)\n                        return r;\n                r = seccomp_rule_add_exact(\n                                seccomp,\n                                SCMP_ACT_ERRNO(EPERM),\n                                SCMP_SYS(personality),\n                                1,\n                                SCMP_A0(SCMP_CMP_NE, personality));\n                if (r < 0) {\n                        log_debug_errno(r, \"Failed to add scheduler rule for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n                        continue;\n                }\n                r = seccomp_load(seccomp);\n                if (IN_SET(r, -EPERM, -EACCES))\n                        return r;\n                if (r < 0)\n                        log_debug_errno(r, \"Failed to enable personality lock for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n        }\n        return 0;\n}", "target": 0}
{"code": "    bool IsOpened() {return hFile!=FILE_BAD_HANDLE;};", "target": 1}
{"code": "bool chopOff(string &domain) \n{\n  if(domain.empty())\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot==string::npos) \n    domain=\"\";\n  else {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain); \n  }\n  return true;\n}", "target": 1}
{"code": "void fz_cmm_init_profile(fz_context *ctx, fz_iccprofile *profile)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tctx->colorspace->cmm->init_profile(ctx->cmm_instance, profile);\n}", "target": 0}
{"code": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \"(vararg)\";  \n    }\n  }\n  return NULL;  \n}", "target": 1}
{"code": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n\t\t\t struct nf_conntrack_expect *exp)\n{\n\tchar buffer[sizeof(\"4294967296 65635\")];\n\tu_int16_t port;\n\tunsigned int ret;\n\texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n\texp->dir = IP_CT_DIR_REPLY;\n\texp->expectfn = nf_nat_follow_master;\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n\t\treturn NF_DROP;\n\t}\n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n\tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n\t\tnf_ct_unexpect_related(exp);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}", "target": 1}
{"code": "static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte, ptent;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tptep_test_and_clear_young(vma, addr, pte);\n\t\tClearPageReferenced(page);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}", "target": 0}
{"code": "static int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\nretry:\n\thandle = ext4_journal_start(inode, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tflags |= AOP_FLAG_NOFS;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\text4_journal_stop(handle);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t*pagep = page;\n\tret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\text4_get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\nout:\n\treturn ret;\n}", "target": 1}
{"code": "set_tagstack(win_T *wp, dict_T *d, int action)\n{\n    dictitem_T\t*di;\n    list_T\t*l = NULL;\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FAIL;\n    }\n#endif\n    if ((di = dict_find(d, (char_u *)\"items\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_LIST)\n\t{\n\t    emsg(_(e_list_required));\n\t    return FAIL;\n\t}\n\tl = di->di_tv.vval.v_list;\n    }\n    if ((di = dict_find(d, (char_u *)\"curidx\", -1)) != NULL)\n\ttagstack_set_curidx(wp, (int)tv_get_number(&di->di_tv) - 1);\n    if (action == 't')\t\t    \n    {\n\ttaggy_T\t*tagstack = wp->w_tagstack;\n\tint\ttagstackidx = wp->w_tagstackidx;\n\tint\ttagstacklen = wp->w_tagstacklen;\n\twhile (tagstackidx < tagstacklen)\n\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\twp->w_tagstacklen = tagstacklen;\n    }\n    if (l != NULL)\n    {\n\tif (action == 'r')\t\t\n\t    tagstack_clear(wp);\n\ttagstack_push_items(wp, l);\n\twp->w_tagstackidx = wp->w_tagstacklen;\n    }\n    return OK;\n}", "target": 0}
{"code": "ssh_scp ssh_scp_new(ssh_session session, int mode, const char *location){\n  ssh_scp scp=malloc(sizeof(struct ssh_scp_struct));\n  if(scp == NULL){\n    ssh_set_error(session,SSH_FATAL,\"Error allocating memory for ssh_scp\");\n    return NULL;\n  }\n  ZERO_STRUCTP(scp);\n  if((mode&~SSH_SCP_RECURSIVE) != SSH_SCP_WRITE && (mode &~SSH_SCP_RECURSIVE) != SSH_SCP_READ){\n    ssh_set_error(session,SSH_FATAL,\"Invalid mode %d for ssh_scp_new()\",mode);\n    ssh_scp_free(scp);\n    return NULL;\n  }\n  scp->location=strdup(location);\n  if (scp->location == NULL) {\n    ssh_set_error(session,SSH_FATAL,\"Error allocating memory for ssh_scp\");\n    ssh_scp_free(scp);\n    return NULL;\n  }\n  scp->session=session;\n  scp->mode=mode & ~SSH_SCP_RECURSIVE;\n  scp->recursive = (mode & SSH_SCP_RECURSIVE) != 0;\n  scp->channel=NULL;\n  scp->state=SSH_SCP_NEW;\n  return scp;\n}", "target": 1}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 1}
{"code": "static void *unix_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn unix_next_socket(seq, v, pos);\n}", "target": 0}
{"code": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &headers() const override\n    {\n        return headers_;\n    }", "target": 1}
{"code": "std::string GdkAtomToString(const GdkAtom& atom) {\n  gchar* name = gdk_atom_name(atom);\n  std::string rv(name);\n  g_free(name);\n  return rv;\n}", "target": 0}
{"code": "static int nf_tables_table_notify(const struct nft_ctx *ctx, int event)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn 0;\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\terr = nf_tables_fill_table_info(skb, ctx->net, ctx->portid, ctx->seq,\n\t\t\t\t\tevent, 0, ctx->afi->family, ctx->table);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\terr = nfnetlink_send(skb, ctx->net, ctx->portid, NFNLGRP_NFTABLES,\n\t\t\t     ctx->report, GFP_KERNEL);\nerr:\n\tif (err < 0) {\n\t\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES,\n\t\t\t\t  err);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\t*r = -1;\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 1}
{"code": "static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, struct nameidata *nd)\n{\n\tstruct dentry * result;\n\tstruct inode *dir = parent->d_inode;\n\tmutex_lock(&dir->i_mutex);\n\tresult = d_lookup(parent, name);\n\tif (!result) {\n\t\tstruct dentry * dentry = d_alloc(parent, name);\n\t\tresult = ERR_PTR(-ENOMEM);\n\t\tif (dentry) {\n\t\t\tresult = dir->i_op->lookup(dir, dentry, nd);\n\t\t\tif (result)\n\t\t\t\tdput(dentry);\n\t\t\telse\n\t\t\t\tresult = dentry;\n\t\t}\n\t\tmutex_unlock(&dir->i_mutex);\n\t\treturn result;\n\t}\n\tmutex_unlock(&dir->i_mutex);\n\tif (result->d_op && result->d_op->d_revalidate) {\n\t\tresult = do_revalidate(result, nd);\n\t\tif (!result)\n\t\t\tresult = ERR_PTR(-ENOENT);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n\t\t    struct idpair *idmap)\n{\n\tif (!(rold->live & REG_LIVE_READ))\n\t\treturn true;\n\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, live)) == 0)\n\t\treturn true;\n\tif (rold->type == NOT_INIT)\n\t\treturn true;\n\tif (rcur->type == NOT_INIT)\n\t\treturn false;\n\tswitch (rold->type) {\n\tcase SCALAR_VALUE:\n\t\tif (rcur->type == SCALAR_VALUE) {\n\t\t\treturn range_within(rold, rcur) &&\n\t\t\t       tnum_in(rold->var_off, rcur->var_off);\n\t\t} else {\n\t\t\treturn rold->umin_value == 0 &&\n\t\t\t       rold->umax_value == U64_MAX &&\n\t\t\t       rold->smin_value == S64_MIN &&\n\t\t\t       rold->smax_value == S64_MAX &&\n\t\t\t       tnum_is_unknown(rold->var_off);\n\t\t}\n\tcase PTR_TO_MAP_VALUE:\n\t\treturn memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&\n\t\t       range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tif (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\treturn false;\n\t\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))\n\t\t\treturn false;\n\t\treturn check_ids(rold->id, rcur->id, idmap);\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET:\n\t\tif (rcur->type != rold->type)\n\t\t\treturn false;\n\t\tif (rold->range > rcur->range)\n\t\t\treturn false;\n\t\tif (rold->off != rcur->off)\n\t\t\treturn false;\n\t\tif (rold->id && !check_ids(rold->id, rcur->id, idmap))\n\t\t\treturn false;\n\t\treturn range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_CTX:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_PACKET_END:\n\tdefault:\n\t\treturn false;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}", "target": 1}
{"code": "int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\tif (is_vm_hugetlb_page(vma) && (addr &\n\t\t\t\t\t~(huge_page_mask(hstate_vma(vma)))))\n\t\treturn -EINVAL;\n\tnew = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\t*new = *vma;\n\tINIT_LIST_HEAD(&new->anon_vma_chain);\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\tif (!err)\n\t\treturn 0;\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tkmem_cache_free(vm_area_cachep, new);\n\treturn err;\n}", "target": 0}
{"code": "static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (s > ds - o) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}", "target": 1}
{"code": "static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvId;\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\treturn AvId;\n}", "target": 1}
{"code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n\t\tucounts = NULL;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}", "target": 1}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "PHP_FUNCTION(class_parents)\n{\n\tzval *obj;\n\tzend_class_entry *parent_class, *ce;\n\tzend_bool autoload = 1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|b\", &obj, &autoload) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (Z_TYPE_P(obj) != IS_OBJECT && Z_TYPE_P(obj) != IS_STRING) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"object or string expected\");\n\t\tRETURN_FALSE;\n\t}\n\tif (Z_TYPE_P(obj) == IS_STRING) {\n\t\tif (NULL == (ce = spl_find_ce_by_name(Z_STRVAL_P(obj), Z_STRLEN_P(obj), autoload TSRMLS_CC))) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tce = Z_OBJCE_P(obj);\n\t}\n\tarray_init(return_value);\n\tparent_class = ce->parent;\n\twhile (parent_class) {\n\t\tspl_add_class_name(return_value, parent_class, 0, 0 TSRMLS_CC);\n\t\tparent_class = parent_class->parent;\n\t}\n}", "target": 0}
{"code": "void __init kvm_guest_init(void)\n{\n\tint i;\n\tif (!kvm_para_available())\n\t\treturn;\n\tparavirt_ops_setup();\n\tregister_reboot_notifier(&kvm_pv_reboot_nb);\n\tfor (i = 0; i < KVM_TASK_SLEEP_HASHSIZE; i++)\n\t\tspin_lock_init(&async_pf_sleepers[i].lock);\n\tif (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF))\n\t\tx86_init.irqs.trap_init = kvm_apf_trap_init;\n\tif (kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) {\n\t\thas_steal_clock = 1;\n\t\tpv_time_ops.steal_clock = kvm_steal_clock;\n\t}\n\tif (kvm_para_has_feature(KVM_FEATURE_PV_EOI))\n\t\tapic_set_eoi_write(kvm_guest_apic_eoi_write);\n\tif (kvmclock_vsyscall)\n\t\tkvm_setup_vsyscall_timeinfo();\n#ifdef CONFIG_SMP\n\tsmp_ops.smp_prepare_boot_cpu = kvm_smp_prepare_boot_cpu;\n\tregister_cpu_notifier(&kvm_cpu_notifier);\n#else\n\tkvm_guest_cpu_init();\n#endif\n\twatchdog_enable_hardlockup_detector(false);\n}", "target": 0}
{"code": "void spl_filesystem_object_construct(INTERNAL_FUNCTION_PARAMETERS, zend_long ctor_flags) \n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint parsed;\n\tsize_t len;\n\tzend_long flags;\n\tzend_error_handling error_handling;\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling);\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_FLAGS)) {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_FILEINFO;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\", &path, &len, &flags);\n\t} else {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_SELF;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &path, &len);\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_SKIPDOTS)) {\n\t\tflags |= SPL_FILE_DIR_SKIPDOTS;\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_UNIXPATHS)) {\n\t\tflags |= SPL_FILE_DIR_UNIXPATHS;\n\t}\n\tif (parsed == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling);\n\t\treturn;\n\t}\n\tif (!len) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0, \"Directory name must not be empty.\");\n\t\tzend_restore_error_handling(&error_handling);\n\t\treturn;\n\t}\n\tintern = Z_SPLFILESYSTEM_P(getThis());\n\tif (intern->_path) {\n\t\tzend_restore_error_handling(&error_handling);\n\t\tphp_error_docref(NULL, E_WARNING, \"Directory object is already initialized\");\n\t\treturn;\n\t}\n\tintern->flags = flags;\n#ifdef HAVE_GLOB\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_GLOB) && strstr(path, \"glob:\n\t\tspprintf(&path, 0, \"glob:\n\t\tspl_filesystem_dir_open(intern, path);\n\t\tefree(path);\n\t} else\n#endif\n\t{\n\t\tspl_filesystem_dir_open(intern, path);\n\t}\n\tintern->u.dir.is_recursive = instanceof_function(intern->std.ce, spl_ce_RecursiveDirectoryIterator) ? 1 : 0;\n\tzend_restore_error_handling(&error_handling);\n}", "target": 1}
{"code": "gtime2generalTime(time_t gtime, char *str_time, size_t str_time_size)\n{\n\tsize_t ret;\n\tstruct tm _tm;\n\tif (gtime == (time_t)-1\n#if SIZEOF_LONG == 8\n\t\t|| gtime >= 253402210800\n#endif\n\t ) {\n        \tsnprintf(str_time, str_time_size, \"99991231235959Z\");\n        \treturn 0;\n\t}\n\tif (!gmtime_r(&gtime, &_tm)) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_INTERNAL_ERROR;\n\t}\n\tret = strftime(str_time, str_time_size, \"%Y%m%d%H%M%SZ\", &_tm);\n\tif (!ret) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_SHORT_MEMORY_BUFFER;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int i_head = i->head;\n\tsize_t off;\n\tif (unlikely(bytes > i->count))\n\t\tbytes = i->count;\n\tif (unlikely(!bytes))\n\t\treturn 0;\n\tif (!sanity(i))\n\t\treturn 0;\n\toff = i->iov_offset;\n\tbuf = &pipe->bufs[i_head & p_mask];\n\tif (off) {\n\t\tif (offset == off && buf->page == page) {\n\t\t\tbuf->len += bytes;\n\t\t\ti->iov_offset += bytes;\n\t\t\tgoto out;\n\t\t}\n\t\ti_head++;\n\t\tbuf = &pipe->bufs[i_head & p_mask];\n\t}\n\tif (pipe_full(i_head, p_tail, pipe->max_usage))\n\t\treturn 0;\n\tbuf->ops = &page_cache_pipe_buf_ops;\n\tget_page(page);\n\tbuf->page = page;\n\tbuf->offset = offset;\n\tbuf->len = bytes;\n\tpipe->head = i_head + 1;\n\ti->iov_offset = offset + bytes;\n\ti->head = i_head;\nout:\n\ti->count -= bytes;\n\treturn bytes;\n}", "target": 1}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = _mm_xor_si128(D[i], S[i]);\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n  PixelInfo\n    *color_1,\n    *color_2;\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": "static void hugetlb_vm_op_open(struct vm_area_struct *vma)\n{\n\tstruct resv_map *resv = vma_resv_map(vma);\n\tif (resv && is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\tresv_map_dup_hugetlb_cgroup_uncharge_info(resv);\n\t\tkref_get(&resv->refs);\n\t}\n}", "target": 0}
{"code": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\treturn ts;\n}", "target": 1}
{"code": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}", "target": 1}
{"code": "int migrate_page(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page)\n{\n\tint rc;\n\tBUG_ON(PageWriteback(page));\t\n\trc = migrate_page_move_mapping(mapping, newpage, page);\n\tif (rc)\n\t\treturn rc;\n\tmigrate_page_copy(newpage, page);\n\treturn 0;\n}", "target": 0}
{"code": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}", "target": 1}
{"code": "date_initialize(int argc, VALUE *argv, VALUE self)\n{\n    VALUE vy, vm, vd, vsg, y, fr, fr2, ret;\n    int m, d;\n    double sg;\n    struct SimpleDateData *dat = rb_check_typeddata(self, &d_lite_type);\n    if (!simple_dat_p(dat)) {\n\trb_raise(rb_eTypeError, \"Date expected\");\n    }\n    rb_scan_args(argc, argv, \"04\", &vy, &vm, &vd, &vsg);\n    y = INT2FIX(-4712);\n    m = 1;\n    d = 1;\n    fr2 = INT2FIX(0);\n    sg = DEFAULT_SG;\n    switch (argc) {\n      case 4:\n\tval2sg(vsg, sg);\n      case 3:\n        check_numeric(vd, \"day\");\n\tnum2int_with_frac(d, positive_inf);\n      case 2:\n        check_numeric(vm, \"month\");\n\tm = NUM2INT(vm);\n      case 1:\n        check_numeric(vy, \"year\");\n\ty = vy;\n    }\n    if (guess_style(y, sg) < 0) {\n\tVALUE nth;\n\tint ry, rm, rd;\n\tif (!valid_gregorian_p(y, m, d,\n\t\t\t       &nth, &ry,\n\t\t\t       &rm, &rd))\n\t    rb_raise(eDateError, \"invalid date\");\n\tset_to_simple(self, dat, nth, 0, sg, ry, rm, rd, HAVE_CIVIL);\n    }\n    else {\n\tVALUE nth;\n\tint ry, rm, rd, rjd, ns;\n\tif (!valid_civil_p(y, m, d, sg,\n\t\t\t   &nth, &ry,\n\t\t\t   &rm, &rd, &rjd,\n\t\t\t   &ns))\n\t    rb_raise(eDateError, \"invalid date\");\n\tset_to_simple(self, dat, nth, rjd, sg, ry, rm, rd, HAVE_JD | HAVE_CIVIL);\n    }\n    ret = self;\n    add_frac();\n    return ret;\n}", "target": 0}
{"code": "static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  double\n    extent;\n  size_t\n    quantum;\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+PrimitiveExtentPad*quantum+1.0;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if (extent == (double) CastDoubleToLong(extent))\n    {\n      *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n        *mvg_info->primitive_info,(size_t) extent,quantum);\n      if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n        {\n          ssize_t\n            i;\n          *mvg_info->extent=(size_t) extent;\n          for (i=mvg_info->offset+1; i < (ssize_t) extent; i++)\n            (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n          return(MagickTrue);\n        }\n    }\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    *mvg_info->primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(\n      *mvg_info->primitive_info);\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  *mvg_info->primitive_info=(PrimitiveInfo *)  AcquireCriticalMemory(\n    (size_t) (PrimitiveExtentPad*quantum));\n  (void) memset(*mvg_info->primitive_info,0,(size_t)\n    (PrimitiveExtentPad*quantum));\n  *mvg_info->extent=1;\n  return(MagickFalse);\n}", "target": 0}
{"code": "bool HTMLSelectElement::anonymousIndexedSetter(unsigned index, PassRefPtr<HTMLOptionElement> value, ExceptionState& exceptionState)\n{\n    if (!value) {\n        exceptionState.throwTypeError(ExceptionMessages::failedToSet(String::number(index), \"HTMLSelectElement\", \"The value provided was not an HTMLOptionElement.\"));\n        return false;\n    }\n    setOption(index, value.get(), exceptionState);\n    return true;\n}", "target": 0}
{"code": "static ssize_t show_constraint_name(struct device *dev,\n\t\t\t\tstruct device_attribute *dev_attr,\n\t\t\t\tchar *buf)\n{\n\tconst char *name;\n\tstruct powercap_zone *power_zone = to_powercap_zone(dev);\n\tint id;\n\tssize_t len = -ENODATA;\n\tstruct powercap_zone_constraint *pconst;\n\tif (!sscanf(dev_attr->attr.name, \"constraint_%d_\", &id))\n\t\treturn -EINVAL;\n\tif (id >= power_zone->const_id_cnt)\n\t\treturn -EINVAL;\n\tpconst = &power_zone->constraints[id];\n\tif (pconst && pconst->ops && pconst->ops->get_name) {\n\t\tname = pconst->ops->get_name(power_zone, id);\n\t\tif (name) {\n\t\t\tsnprintf(buf, POWERCAP_CONSTRAINT_NAME_LEN,\n\t\t\t\t\t\t\t\t\"%s\\n\", name);\n\t\t\tbuf[POWERCAP_CONSTRAINT_NAME_LEN] = '\\0';\n\t\t\tlen = strlen(buf);\n\t\t}\n\t}\n\treturn len;\n}", "target": 0}
{"code": "static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pcu)\n{\n\tconst struct usb_cdc_union_desc *union_desc;\n\tstruct usb_host_interface *alt;\n\tunion_desc = ims_pcu_get_cdc_union_desc(intf);\n\tif (!union_desc)\n\t\treturn -EINVAL;\n\tpcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bMasterInterface0);\n\tif (!pcu->ctrl_intf)\n\t\treturn -EINVAL;\n\talt = pcu->ctrl_intf->cur_altsetting;\n\tpcu->ep_ctrl = &alt->endpoint[0].desc;\n\tpcu->max_ctrl_size = usb_endpoint_maxp(pcu->ep_ctrl);\n\tpcu->data_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bSlaveInterface0);\n\tif (!pcu->data_intf)\n\t\treturn -EINVAL;\n\talt = pcu->data_intf->cur_altsetting;\n\tif (alt->desc.bNumEndpoints != 2) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Incorrect number of endpoints on data interface (%d)\\n\",\n\t\t\talt->desc.bNumEndpoints);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_out = &alt->endpoint[0].desc;\n\tif (!usb_endpoint_is_bulk_out(pcu->ep_out)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"First endpoint on data interface is not BULK OUT\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_out_size = usb_endpoint_maxp(pcu->ep_out);\n\tif (pcu->max_out_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max OUT packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_out_size);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_in = &alt->endpoint[1].desc;\n\tif (!usb_endpoint_is_bulk_in(pcu->ep_in)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Second endpoint on data interface is not BULK IN\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_in_size = usb_endpoint_maxp(pcu->ep_in);\n\tif (pcu->max_in_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max IN packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_in_size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;", "target": 0}
{"code": "int avrcp_set_volume(struct btd_device *dev, int8_t volume, bool notify)\n{\n\tstruct avrcp_server *server;\n\tstruct avrcp *session;\n\tuint8_t buf[AVRCP_HEADER_LENGTH + 1];\n\tstruct avrcp_header *pdu = (void *) buf;\n\tif (volume < 0)\n\t\treturn -EINVAL;\n\tserver = find_server(servers, device_get_adapter(dev));\n\tif (server == NULL)\n\t\treturn -EINVAL;\n\tsession = find_session(server->sessions, dev);\n\tif (session == NULL)\n\t\treturn -ENOTCONN;\n\tif (notify) {\n\t\tif (!session->target)\n\t\t\treturn -ENOTSUP;\n\t\treturn avrcp_event(session, AVRCP_EVENT_VOLUME_CHANGED,\n\t\t\t\t\t\t\t\t&volume);\n\t}\n\tif (!session->controller && !avrcp_event_registered(session,\n\t\t\t\t\tAVRCP_EVENT_VOLUME_CHANGED))\n\t\treturn -ENOTSUP;\n\tmemset(buf, 0, sizeof(buf));\n\tset_company_id(pdu->company_id, IEEEID_BTSIG);\n\tpdu->pdu_id = AVRCP_SET_ABSOLUTE_VOLUME;\n\tpdu->params[0] = volume;\n\tpdu->params_len = htons(1);\n\treturn avctp_send_vendordep_req(session->conn,\n\t\t\t\t\tAVC_CTYPE_CONTROL, AVC_SUBUNIT_PANEL,\n\t\t\t\t\tbuf, sizeof(buf),\n\t\t\t\t\tavrcp_handle_set_volume, session);\n}", "target": 0}
{"code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\treturn 0;\n}", "target": 1}
{"code": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\tlen = file && file->size > 0 ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\t*data_len = r;\n\tok = 1;\nerr:\n\tsc_file_free(file);\n\treturn ok;\n}", "target": 0}
{"code": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\tvif = pending_tx_info->vif;\n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\txenvif_put(vif);\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}", "target": 1}
{"code": "TfLiteStatus StoreAllDecodedSequences(\n    TfLiteContext* context,\n    const std::vector<std::vector<std::vector<int>>>& sequences,\n    TfLiteNode* node, int top_paths) {\n  const int32_t batch_size = sequences.size();\n  std::vector<int32_t> num_entries(top_paths, 0);\n  for (const auto& batch_s : sequences) {\n    TF_LITE_ENSURE_EQ(context, batch_s.size(), top_paths);\n    for (int p = 0; p < top_paths; ++p) {\n      num_entries[p] += batch_s[p].size();\n    }\n  }\n  for (int p = 0; p < top_paths; ++p) {\n    const int32_t p_num = num_entries[p];\n    TfLiteTensor* indices = GetOutput(context, node, p);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num, 2}, indices));\n    TfLiteTensor* values = GetOutput(context, node, p + top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num}, values));\n    TfLiteTensor* decoded_shape = GetOutput(context, node, p + 2 * top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {2}, decoded_shape));\n    int32_t max_decoded = 0;\n    int32_t offset = 0;\n    int32_t* indices_data = GetTensorData<int32_t>(indices);\n    int32_t* values_data = GetTensorData<int32_t>(values);\n    int32_t* decoded_shape_data = GetTensorData<int32_t>(decoded_shape);\n    for (int b = 0; b < batch_size; ++b) {\n      auto& p_batch = sequences[b][p];\n      int32_t num_decoded = p_batch.size();\n      max_decoded = std::max(max_decoded, num_decoded);\n      std::copy_n(p_batch.begin(), num_decoded, values_data + offset);\n      for (int32_t t = 0; t < num_decoded; ++t, ++offset) {\n        indices_data[offset * 2] = b;\n        indices_data[offset * 2 + 1] = t;\n      }\n    }\n    decoded_shape_data[0] = batch_size;\n    decoded_shape_data[1] = max_decoded;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = buf_.data();\n    *lenReturn = buf_.size();\n  }", "target": 0}
{"code": "void SpeechSynthesis::voicesDidChange()\n{\n    m_voiceList.clear();\n    if (!executionContext()->activeDOMObjectsAreStopped())\n        dispatchEvent(Event::create(EventTypeNames::voiceschanged));\n}", "target": 0}
{"code": "addCharacterClass (FileInfo * nested, const widechar * name, int length)\n{\n  struct CharacterClass *class;\n  if (characterClassAttribute)\n    {\n      if (!(class = malloc (sizeof (*class) + CHARSIZE * (length - 1))))\n\toutOfMemory ();\n      else\n\t{\n\t  memset (class, 0, sizeof (*class));\n\t  memcpy (class->name, name, CHARSIZE * (class->length = length));\n\t  class->attribute = characterClassAttribute;\n\t  characterClassAttribute <<= 1;\n\t  class->next = characterClasses;\n\t  characterClasses = class;\n\t  return class;\n\t}\n    }\n  compileError (nested, \"character class table overflow.\");\n  return NULL;\n}", "target": 0}
{"code": "DLLIMPORT int cfg_setnstr(cfg_t *cfg, const char *name, const char *value, unsigned int index)\n{\n\tcfg_opt_t *opt;\n\topt = cfg_getopt(cfg, name);\n\tif (opt && opt->validcb2 && (*opt->validcb2)(cfg, opt, (void *)value) != 0)\n\t\treturn CFG_FAIL;\n\treturn cfg_opt_setnstr(opt, value, index);\n}", "target": 0}
{"code": "static int acpi_smbus_hc_add(struct acpi_device *device)\n{\n\tint status;\n\tunsigned long long val;\n\tstruct acpi_smb_hc *hc;\n\tif (!device)\n\t\treturn -EINVAL;\n\tstatus = acpi_evaluate_integer(device->handle, \"_EC\", NULL, &val);\n\tif (ACPI_FAILURE(status)) {\n\t\tprintk(KERN_ERR PREFIX \"error obtaining _EC.\\n\");\n\t\treturn -EIO;\n\t}\n\tstrcpy(acpi_device_name(device), ACPI_SMB_HC_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_SMB_HC_CLASS);\n\thc = kzalloc(sizeof(struct acpi_smb_hc), GFP_KERNEL);\n\tif (!hc)\n\t\treturn -ENOMEM;\n\tmutex_init(&hc->lock);\n\tinit_waitqueue_head(&hc->wait);\n\thc->ec = acpi_driver_data(device->parent);\n\thc->offset = (val >> 8) & 0xff;\n\thc->query_bit = val & 0xff;\n\tdevice->driver_data = hc;\n\tacpi_ec_add_query_handler(hc->ec, hc->query_bit, NULL, smbus_alarm, hc);\n\tprintk(KERN_INFO PREFIX \"SBS HC: EC = 0x%p, offset = 0x%0x, query_bit = 0x%0x\\n\",\n\t\thc->ec, hc->offset, hc->query_bit);\n\treturn 0;\n}", "target": 1}
{"code": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}", "target": 1}
{"code": "RequestHandler::RequestHandler(\n    std::shared_ptr<CheckWorkflow> check_workflow,\n    std::shared_ptr<context::ServiceContext> service_context,\n    std::unique_ptr<Request> request_data)\n    : context_(new context::RequestContext(service_context,\n                                           std::move(request_data))),\n      check_workflow_(check_workflow) {\n  std::string buffer;\n  if (context_->request()->FindHeader(\n          google::api_manager::auth::kEndpointApiUserInfo, &buffer)) {\n    context_->request()->AddHeaderToBackend(\n        google::api_manager::auth::kEndpointApiUserInfo, \"\");\n  }\n}", "target": 1}
{"code": "gimp_channel_push_undo (GimpChannel *channel,\n                        const gchar *undo_desc)\n{\n  g_return_if_fail (GIMP_IS_CHANNEL (channel));\n  g_return_if_fail (gimp_item_is_attached (GIMP_ITEM (channel)));\n  gimp_image_undo_push_mask (gimp_item_get_image (GIMP_ITEM (channel)),\n                             undo_desc, channel);\n}", "target": 0}
{"code": "static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *m, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint ret;\n\tint copylen;\n\tret = -EOPNOTSUPP;\n\tif (m->msg_flags&MSG_OOB)\n\t\tgoto read_error;\n\tm->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n\tif (!skb)\n\t\tgoto read_error;\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\tret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);\n\tif (ret)\n\t\tgoto out_free;\n\tret = (flags & MSG_TRUNC) ? skb->len : copylen;\nout_free:\n\tskb_free_datagram(sk, skb);\n\tcaif_check_flow_release(sk);\n\treturn ret;\nread_error:\n\treturn ret;\n}", "target": 1}
{"code": "mm_request_send(int socket, enum monitor_reqtype type, Buffer *m)\n{\n\tu_int mlen = buffer_len(m);\n\tu_char buf[5];\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\tPUT_32BIT(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t\n\tif (atomicio(write, socket, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write\", __func__);\n\tif (atomicio(write, socket, buffer_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write\", __func__);\n}", "target": 0}
{"code": "static char *get_header(FILE *fp)\n{\n    long start;\n    char *header;\n    header = calloc(1, 1024);\n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}", "target": 1}
{"code": "inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}", "target": 1}
{"code": "ssize_t qemu_deliver_packet_iov(NetClientState *sender,\n                                unsigned flags,\n                                const struct iovec *iov,\n                                int iovcnt,\n                                void *opaque)\n{\n    NetClientState *nc = opaque;\n    size_t size = iov_size(iov, iovcnt);\n    int ret;\n    if (size > INT_MAX) {\n        return size;\n    }\n    if (nc->link_down) {\n        return size;\n    }\n    if (nc->receive_disabled) {\n        return 0;\n    }\n    if (nc->info->receive_iov && !(flags & QEMU_NET_PACKET_FLAG_RAW)) {\n        ret = nc->info->receive_iov(nc, iov, iovcnt);\n    } else {\n        ret = nc_sendv_compat(nc, iov, iovcnt, flags);\n    }\n    if (ret == 0) {\n        nc->receive_disabled = 1;\n    }\n    return ret;\n}", "target": 1}
{"code": "   Send an email message */\nPHP_FUNCTION(imap_mail)\n{\n\tchar *to=NULL, *message=NULL, *headers=NULL, *subject=NULL, *cc=NULL, *bcc=NULL, *rpath=NULL;\n\tint to_len, message_len, headers_len, subject_len, cc_len, bcc_len, rpath_len, argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"sss|ssss\", &to, &to_len, &subject, &subject_len, &message, &message_len,\n\t\t&headers, &headers_len, &cc, &cc_len, &bcc, &bcc_len, &rpath, &rpath_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (!to_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No to field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!subject_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No subject field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!message_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No message string in mail command\");\n\t\tmessage = NULL;\n\t}\n\tif (_php_imap_mail(to, subject, message, headers, cc, bcc, rpath TSRMLS_CC)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 1}
{"code": "RGB_to_HWB (RGBType RGB, HWBType * HWB)\n{\n\tfloat R = RGB.R, G = RGB.G, B = RGB.B, w, v, b, f;\n\tint i;\n\tw = MIN3 (R, G, B);\n\tv = MAX3 (R, G, B);\n\tb = 1 - v;\n\tif (v == w)\n\t\tRETURN_HWB (HWB_UNDEFINED, w, b);\n\tf = (R == w) ? G - B : ((G == w) ? B - R : R - G);\n\ti = (R == w) ? 3 : ((G == w) ? 5 : 1);\n\tRETURN_HWB (i - f / (v - w), w, b);\n}", "target": 0}
{"code": "PHP_FUNCTION( msgfmt_format_message )\n{\n\tzval       *args;\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tint         pattern_len = 0;\n\tconst char *slocale = NULL;\n\tint         slocale_len = 0;\n\tMessageFormatter_object mf = {0};\n\tMessageFormatter_object *mfo = &mf;\n\tif( zend_parse_method_parameters( ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"ssa\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &args ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_format_message: unable to parse input params\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n \tmsgformat_data_init(&mfo->mf_data TSRMLS_CC);\n \tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_format_message: error converting pattern to UTF-16\", 0 TSRMLS_CC );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default(TSRMLS_C);\n\t}\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_format_message: error converting pattern to quote-friendly format\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\tmsgfmt_do_format(mfo, args, return_value TSRMLS_CC);\n\tmsgformat_data_free(&mfo->mf_data TSRMLS_CC);\n}", "target": 1}
{"code": "de265_error decoder_context::read_pps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read PPS\\n\");\n  std::shared_ptr<pic_parameter_set> new_pps = std::make_shared<pic_parameter_set>();\n  bool success = new_pps->read(&reader,this);\n  if (param_pps_headers_fd>=0) {\n    new_pps->dump(param_pps_headers_fd);\n  }\n  if (success) {\n    pps[ (int)new_pps->pic_parameter_set_id ] = new_pps;\n  }\n  return success ? DE265_OK : DE265_WARNING_PPS_HEADER_INVALID;\n}", "target": 1}
{"code": "  QuotaManager* quota_manager() const { return quota_manager_.get(); }", "target": 0}
{"code": "xfs_file_splice_write(\n\tstruct pipe_inode_info\t*pipe,\n\tstruct file\t\t*outfilp,\n\tloff_t\t\t\t*ppos,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\tXFS_STATS_INC(xs_write_calls);\n\tif (outfilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= IO_INVIS;\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn ret;\n}", "target": 1}
{"code": "  QInt32() {}", "target": 1}
{"code": "void *HtpGetTxForH2(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        size_t txid = htp_list_array_size(http_state->conn->transactions);\n        if (txid > 0) {\n            return htp_list_get(http_state->conn->transactions, txid - 1);\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "static int aspeed_lpc_ctrl_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct aspeed_lpc_ctrl *lpc_ctrl = file_aspeed_lpc_ctrl(file);\n\tunsigned long vsize = vma->vm_end - vma->vm_start;\n\tpgprot_t prot = vma->vm_page_prot;\n\tif (vma->vm_pgoff + vma_pages(vma) > lpc_ctrl->mem_size >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\tprot = pgprot_noncached(prot);\n\tif (remap_pfn_range(vma, vma->vm_start,\n\t\t(lpc_ctrl->mem_base >> PAGE_SHIFT) + vma->vm_pgoff,\n\t\tvsize, prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}", "target": 0}
{"code": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if (isnan(incr) || isinf(incr)) {\n        addReplyError(c,\"value is NaN or Infinity\");\n        return;\n    }\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}", "target": 0}
{"code": "internalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n  entity = openEntity->entity;\n  textStart = ((char *)entity->textPtr) + entity->processed;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif \n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE);\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (char *)entity->textPtr);\n    return result;\n  } else {\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  } else\n#endif \n  {\n    parser->m_processor = contentProcessor;\n    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n                     s, end, nextPtr,\n                     (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  }\n}", "target": 1}
{"code": "uipbuf_get_len_field(struct uip_ip_hdr *hdr)\n{\n  return ((uint16_t)(hdr->len[0]) << 8) + hdr->len[1];\n}", "target": 0}
{"code": "void dtls1_reset_seq_numbers(SSL *s, int rw)\n{\n    unsigned char *seq;\n    unsigned int seq_bytes = sizeof(s->s3->read_sequence);\n    if (rw & SSL3_CC_READ) {\n        seq = s->s3->read_sequence;\n        s->d1->r_epoch++;\n        memcpy(&(s->d1->bitmap), &(s->d1->next_bitmap), sizeof(DTLS1_BITMAP));\n        memset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP));\n    } else {\n        seq = s->s3->write_sequence;\n        memcpy(s->d1->last_write_sequence, seq,\n               sizeof(s->s3->write_sequence));\n        s->d1->w_epoch++;\n    }\n    memset(seq, 0x00, seq_bytes);\n}", "target": 1}
{"code": "static ssize_t _nfsd_copy_file_range(struct nfsd4_copy *copy)\n{\n\tssize_t bytes_copied = 0;\n\tsize_t bytes_total = copy->cp_count;\n\tu64 src_pos = copy->cp_src_pos;\n\tu64 dst_pos = copy->cp_dst_pos;\n\tdo {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tbytes_copied = nfsd_copy_file_range(copy->file_src, src_pos,\n\t\t\t\tcopy->file_dst, dst_pos, bytes_total);\n\t\tif (bytes_copied <= 0)\n\t\t\tbreak;\n\t\tbytes_total -= bytes_copied;\n\t\tcopy->cp_res.wr_bytes_written += bytes_copied;\n\t\tsrc_pos += bytes_copied;\n\t\tdst_pos += bytes_copied;\n\t} while (bytes_total > 0 && !copy->cp_synchronous);\n\treturn bytes_copied;\n}", "target": 0}
{"code": "cdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)\n{\n\tsize_t i;\n\tfor (i = 0; i < __arraycount(vn); i++)\n\t\tif (vn[i].v == p)\n\t\t\treturn snprintf(buf, bufsiz, \"%s\", vn[i].n);\n\treturn snprintf(buf, bufsiz, \"0x%x\", p);\n}", "target": 0}
{"code": "void sctp_assoc_sync_pmtu(struct sock *sk, struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\t__u32 pmtu = 0;\n\tif (!asoc)\n\t\treturn;\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\tif (t->pmtu_pending && t->dst) {\n\t\t\tsctp_transport_update_pmtu(sk, t, dst_mtu(t->dst));\n\t\t\tt->pmtu_pending = 0;\n\t\t}\n\t\tif (!pmtu || (t->pathmtu < pmtu))\n\t\t\tpmtu = t->pathmtu;\n\t}\n\tif (pmtu) {\n\t\tasoc->pathmtu = pmtu;\n\t\tasoc->frag_point = sctp_frag_point(asoc, pmtu);\n\t}\n\tpr_debug(\"%s: asoc:%p, pmtu:%d, frag_point:%d\\n\", __func__, asoc,\n\t\t asoc->pathmtu, asoc->frag_point);\n}", "target": 0}
{"code": "static int mov_find_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag;\n    if (track->mode == MODE_MP4 || track->mode == MODE_PSP)\n        tag = mp4_get_codec_tag(s, track);\n    else if (track->mode == MODE_ISM) {\n        tag = mp4_get_codec_tag(s, track);\n        if (!tag && track->par->codec_id == AV_CODEC_ID_WMAPRO)\n            tag = MKTAG('w', 'm', 'a', ' ');\n    } else if (track->mode == MODE_IPOD)\n        tag = ipod_get_codec_tag(s, track);\n    else if (track->mode & MODE_3GP)\n        tag = ff_codec_get_tag(codec_3gp_tags, track->par->codec_id);\n    else if (track->mode == MODE_F4V)\n        tag = ff_codec_get_tag(codec_f4v_tags, track->par->codec_id);\n    else\n        tag = mov_get_codec_tag(s, track);\n    return tag;\n}", "target": 0}
{"code": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\tif (--header->nreg)\n\t\treturn;\n\tif (parent)\n\t\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}", "target": 1}
{"code": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 1}
{"code": "parse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\t*ret_username = NULL;\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\tptr = user_input;\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\tif (*ptr == '\\0') {\n\t\treturn (PAM_BUF_ERR);\n\t}\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t'))\n\t\t\tbreak;\n\t\telse {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\tif ((*ret_username = malloc(index + 1)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\t(void) strcpy(*ret_username, username);\n\treturn (PAM_SUCCESS);\n}", "target": 1}
{"code": "cgiSetArray(const char *name,\t\t\n            int        element,\t\t\n            const char *value)\t\t\n{\n  int\t\ti;\t\t\t\n  _cgi_var_t\t*var;\t\t\t\n  if (name == NULL || value == NULL || element < 0 || element > 100000)\n    return;\n  fprintf(stderr, \"DEBUG: cgiSetArray: %s[%d]=\\\"%s\\\"\\n\", name, element, value);\n  if ((var = cgi_find_variable(name)) == NULL)\n  {\n    cgi_add_variable(name, element, value);\n    cgi_sort_variables();\n  }\n  else\n  {\n    if (element >= var->avalues)\n    {\n      const char **temp;\t\t\n      temp = (const char **)realloc((void *)(var->values),\n                                    sizeof(char *) * (size_t)(element + 16));\n      if (!temp)\n        return;\n      var->avalues = element + 16;\n      var->values  = temp;\n    }\n    if (element >= var->nvalues)\n    {\n      for (i = var->nvalues; i < element; i ++)\n\tvar->values[i] = NULL;\n      var->nvalues = element + 1;\n    }\n    else if (var->values[element])\n      _cupsStrFree((char *)var->values[element]);\n    var->values[element] = _cupsStrAlloc(value);\n  }\n}", "target": 0}
{"code": "static void sdhci_send_command(SDHCIState *s)\n{\n    SDRequest request;\n    uint8_t response[16];\n    int rlen;\n    bool timeout = false;\n    s->errintsts = 0;\n    s->acmd12errsts = 0;\n    request.cmd = s->cmdreg >> 8;\n    request.arg = s->argument;\n    trace_sdhci_send_command(request.cmd, request.arg);\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n        if (rlen == 4) {\n            s->rspreg[0] = ldl_be_p(response);\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n            trace_sdhci_response4(s->rspreg[0]);\n        } else if (rlen == 16) {\n            s->rspreg[0] = ldl_be_p(&response[11]);\n            s->rspreg[1] = ldl_be_p(&response[7]);\n            s->rspreg[2] = ldl_be_p(&response[3]);\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n                            response[2];\n            trace_sdhci_response16(s->rspreg[3], s->rspreg[2],\n                                   s->rspreg[1], s->rspreg[0]);\n        } else {\n            timeout = true;\n            trace_sdhci_error(\"timeout waiting for command response\");\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n                s->norintsts |= SDHC_NIS_ERR;\n            }\n        }\n        if (!(s->quirks & SDHCI_QUIRK_NO_BUSY_IRQ) &&\n            (s->norintstsen & SDHC_NISEN_TRSCMP) &&\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n            s->norintsts |= SDHC_NIS_TRSCMP;\n        }\n    }\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n        s->norintsts |= SDHC_NIS_CMDCMP;\n    }\n    sdhci_update_irq(s);\n    if (!timeout && s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n        s->data_count = 0;\n        sdhci_data_transfer(s);\n    }\n}", "target": 0}
{"code": "static __init int efivar_ssdt_load(void)\n{\n\tLIST_HEAD(entries);\n\tstruct efivar_entry *entry, *aux;\n\tunsigned long size;\n\tvoid *data;\n\tint ret;\n\tret = efivar_init(efivar_ssdt_iter, &entries, true, &entries);\n\tlist_for_each_entry_safe(entry, aux, &entries, list) {\n\t\tpr_info(\"loading SSDT from variable %s-%pUl\\n\", efivar_ssdt,\n\t\t\t&entry->var.VendorGuid);\n\t\tlist_del(&entry->list);\n\t\tret = efivar_entry_size(entry, &size);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to get var size\\n\");\n\t\t\tgoto free_entry;\n\t\t}\n\t\tdata = kmalloc(size, GFP_KERNEL);\n\t\tif (!data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_entry;\n\t\t}\n\t\tret = efivar_entry_get(entry, NULL, &size, data);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to get var data\\n\");\n\t\t\tgoto free_data;\n\t\t}\n\t\tret = acpi_load_table(data);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to load table: %d\\n\", ret);\n\t\t\tgoto free_data;\n\t\t}\n\t\tgoto free_entry;\nfree_data:\n\t\tkfree(data);\nfree_entry:\n\t\tkfree(entry);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "ProcFreeGC(ClientPtr client)\n{\n    GC *pGC;\n    int rc;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupGC(&pGC, stuff->id, client, DixDestroyAccess);\n    if (rc != Success)\n        return rc;\n    FreeResource(stuff->id, RT_NONE);\n    return Success;\n}", "target": 0}
{"code": "  QInt8() {}", "target": 1}
{"code": "createFile(const string &filename, const StaticString &contents, mode_t permissions, uid_t owner,\n\tgid_t group, bool overwrite)\n{\n\tFileDescriptor fd;\n\tint ret, e, options;\n\toptions = O_WRONLY | O_CREAT | O_TRUNC;\n\tif (!overwrite) {\n\t\toptions |= O_EXCL;\n\t}\n\tdo {\n\t\tfd = open(filename.c_str(), options, permissions);\n\t} while (fd == -1 && errno == EINTR);\n\tif (fd != -1) {\n\t\tFileGuard guard(filename);\n\t\tdo {\n\t\t\tret = fchmod(fd, permissions);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\te = errno;\n\t\t\tthrow FileSystemException(\"Cannot set permissions on \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = fchown(fd, owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\te = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot set ownership for \" + filename,\n\t\t\t\t\te, filename);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\twriteExact(fd, contents);\n\t\t\tfd.close();\n\t\t} catch (const SystemException &e) {\n\t\t\tthrow FileSystemException(\"Cannot write to file \" + filename,\n\t\t\t\te.code(), filename);\n\t\t}\n\t\tguard.commit();\n\t} else {\n\t\te = errno;\n\t\tif (overwrite || e != EEXIST) {\n\t\t\tthrow FileSystemException(\"Cannot create file \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\tcard = file->card;\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_write(card, file, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}", "target": 0}
{"code": "ExpressionConvert::ExpressionConvert(ExpressionContext* const expCtx,\n                                     boost::intrusive_ptr<Expression> input,\n                                     boost::intrusive_ptr<Expression> to,\n                                     boost::intrusive_ptr<Expression> onError,\n                                     boost::intrusive_ptr<Expression> onNull)\n    : Expression(expCtx, {std::move(input), std::move(to), std::move(onError), std::move(onNull)}),\n      _input(_children[0]),\n      _to(_children[1]),\n      _onError(_children[2]),\n      _onNull(_children[3]) {}", "target": 0}
{"code": "Status KernelAndDeviceOp::Run(\n    ScopedStepContainer* step_container, const EagerKernelArgs& inputs,\n    std::vector<EagerKernelRet>* outputs,\n    CancellationManager* cancellation_manager,\n    const absl::optional<EagerRemoteFunctionParams>& remote_func_params) {\n  OpKernelContext::Params params;\n  params.device = device_;\n  params.frame_iter = FrameAndIter(0, 0);\n  params.inputs = inputs.GetTensorValues();\n  params.op_kernel = kernel_.get();\n  params.resource_manager = device_->resource_manager();\n  params.input_alloc_attrs = &input_alloc_attrs_;\n  params.output_attr_array = output_alloc_attrs_.data();\n  params.function_library = flr_;\n  params.slice_reader_cache = &slice_reader_cache_;\n  params.rendezvous = rendezvous_;\n  OpExecutionState* op_execution_state = nullptr;\n  CancellationManager default_cancellation_manager;\n  if (cancellation_manager) {\n    params.cancellation_manager = cancellation_manager;\n  } else if (kernel_->is_deferred()) {\n    op_execution_state = new OpExecutionState;\n    params.cancellation_manager = &op_execution_state->cancellation_manager;\n    params.inc_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Ref();\n    };\n    params.dec_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Unref();\n    };\n  } else {\n    params.cancellation_manager = &default_cancellation_manager;\n  }\n  params.log_memory = log_memory_;\n  params.runner = get_runner();\n  params.step_container =\n      step_container == nullptr ? &step_container_ : step_container;\n  auto step_container_cleanup = gtl::MakeCleanup([step_container, this] {\n    if (step_container == nullptr) {\n      this->step_container_.CleanUp();\n    }\n  });\n  params.collective_executor =\n      collective_executor_ ? collective_executor_->get() : nullptr;\n  OpKernelContext context(&params);\n  {\n    port::ScopedFlushDenormal flush;\n    port::ScopedSetRound round(FE_TONEAREST);\n    profiler::AnnotatedTraceMe activity(\n        [&] { return kernel_->TraceString(context, false); },\n        profiler::TraceMeLevel::kInfo);\n    device_->Compute(kernel_.get(), &context);\n  }\n  if (op_execution_state != nullptr) {\n    op_execution_state->Unref();\n  }\n  if (!context.status().ok()) return context.status();\n  if (outputs != nullptr) {\n    outputs->clear();\n    for (int i = 0; i < context.num_outputs(); ++i) {\n      outputs->push_back(Tensor(*context.mutable_output(i)));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "void rds_inc_init(struct rds_incoming *inc, struct rds_connection *conn,\n\t\t  __be32 saddr)\n{\n\tatomic_set(&inc->i_refcount, 1);\n\tINIT_LIST_HEAD(&inc->i_item);\n\tinc->i_conn = conn;\n\tinc->i_saddr = saddr;\n\tinc->i_rdma_cookie = 0;\n\tinc->i_rx_tstamp.tv_sec = 0;\n\tinc->i_rx_tstamp.tv_usec = 0;\n}", "target": 0}
{"code": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\t\tif (!sgt)\n\t\t\treturn false;\n\t\tsgl = sgt->sgl;\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "void addReply(redisClient *c, robj *obj) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    redisAssert(!server.vm_enabled || obj->storage == REDIS_VM_MEMORY);\n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n    } else {\n        obj = getDecodedObject(obj);\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n        decrRefCount(obj);\n    }\n}", "target": 1}
{"code": "static void nfs_fattr_free_owner_name(struct nfs_fattr *fattr)\n{\n\tfattr->valid &= ~NFS_ATTR_FATTR_OWNER_NAME;\n\tkfree(fattr->owner_name->data);\n}", "target": 0}
{"code": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tstruct minidump_directory entry;\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\tut64 rvadir = obj->hdr->stream_directory_rva;\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tut32 delta = i * sizeof (struct minidump_directory);\n\t\tint r = r_buf_read_at (obj->b, rvadir + delta, (ut8*) &entry, sizeof (struct minidump_directory));\n\t\tif (r) {\n\t\t\tr_bin_mdmp_init_directory_entry (obj, &entry);\n\t\t}\n\t}\n\treturn true;\n}", "target": 0}
{"code": "void HeaderTable::setCapacity(uint32_t capacity) {\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ <= oldCapacity) {\n    evict(0);\n  } else {\n    auto oldTail = tail();\n    auto oldLength = table_.size();\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    table_.resize(newLength);\n    if (size_ > 0 && oldTail > head_) {\n      std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                table_.begin() + newLength - (oldLength - oldTail));\n      for (auto& names_it: names_) {\n        for (auto& idx: names_it.second) {\n          if (idx >= oldTail) {\n            DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n            idx += (table_.size() - oldLength);\n          } else {\n            break;\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "struct pmu *perf_init_event(struct perf_event *event)\n{\n\tstruct pmu *pmu = NULL;\n\tint idx;\n\tint ret;\n\tidx = srcu_read_lock(&pmus_srcu);\n\trcu_read_lock();\n\tpmu = idr_find(&pmu_idr, event->attr.type);\n\trcu_read_unlock();\n\tif (pmu) {\n\t\tevent->pmu = pmu;\n\t\tret = pmu->event_init(event);\n\t\tif (ret)\n\t\t\tpmu = ERR_PTR(ret);\n\t\tgoto unlock;\n\t}\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tevent->pmu = pmu;\n\t\tret = pmu->event_init(event);\n\t\tif (!ret)\n\t\t\tgoto unlock;\n\t\tif (ret != -ENOENT) {\n\t\t\tpmu = ERR_PTR(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tpmu = ERR_PTR(-ENOENT);\nunlock:\n\tsrcu_read_unlock(&pmus_srcu, idx);\n\treturn pmu;\n}", "target": 0}
{"code": "int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n  return nItems;\n}", "target": 1}
{"code": "static struct dentry *__d_obtain_alias(struct inode *inode, int disconnected)\n{\n\tstatic const struct qstr anonstring = QSTR_INIT(\"/\", 1);\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\tunsigned add_flags;\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\ttmp = __d_alloc(inode->i_sb, &anonstring);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(tmp);\n\t\tgoto out_iput;\n\t}\n\tadd_flags = d_flags_for_inode(inode);\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\tspin_lock(&tmp->d_lock);\n\t__d_set_inode_and_type(tmp, inode, add_flags);\n\thlist_add_head(&tmp->d_u.d_alias, &inode->i_dentry);\n\thlist_bl_lock(&tmp->d_sb->s_anon);\n\thlist_bl_add_head(&tmp->d_hash, &tmp->d_sb->s_anon);\n\thlist_bl_unlock(&tmp->d_sb->s_anon);\n\tspin_unlock(&tmp->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(tmp, inode);\n\treturn tmp;\n out_iput:\n\tif (res && !IS_ERR(res))\n\t\tsecurity_d_instantiate(res, inode);\n\tiput(inode);\n\treturn res;\n}", "target": 0}
{"code": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}", "target": 1}
{"code": "static int __udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\tif (inet_sk(sk)->inet_daddr) {\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tsk_incoming_cpu_update(sk);\n\t}\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0) {\n\t\tint is_udplite = IS_UDPLITE(sk);\n\t\tif (rc == -ENOMEM)\n\t\t\tUDP_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS,\n\t\t\t\t\t is_udplite);\n\t\tUDP_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t\tkfree_skb(skb);\n\t\ttrace_udp_fail_queue_rcv_skb(rc, sk);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "Bool Ppmd8_Alloc(CPpmd8 *p, UInt32 size)\n{\n  if (p->Base == 0 || p->Size != size)\n  {\n    Ppmd8_Free(p);\n    p->AlignOffset =\n      #ifdef PPMD_32BIT\n        (4 - size) & 3;\n      #else\n        4 - (size & 3);\n      #endif\n    if ((p->Base = (Byte *)malloc(p->AlignOffset + size)) == 0)\n      return False;\n    p->Size = size;\n  }\n  return True;\n}", "target": 0}
{"code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            return;\n        }\n    }\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { \n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n}", "target": 1}
{"code": "oftrace_add_recirc_node(struct ovs_list *recirc_queue,\n                        enum oftrace_recirc_type type, const struct flow *flow,\n                        const struct dp_packet *packet, uint32_t recirc_id,\n                        const uint16_t zone)\n{\n    if (!recirc_id_node_find_and_ref(recirc_id)) {\n        return false;\n    }\n    struct oftrace_recirc_node *node = xmalloc(sizeof *node);\n    ovs_list_push_back(recirc_queue, &node->node);\n    node->type = type;\n    node->recirc_id = recirc_id;\n    node->flow = *flow;\n    node->flow.recirc_id = recirc_id;\n    node->flow.ct_zone = zone;\n    node->packet = packet ? dp_packet_clone(packet) : NULL;\n    return true;\n}", "target": 0}
{"code": "const u8 *tcp_parse_md5sig_option(const struct tcphdr *th)\n{\n\tint length = (th->doff << 2) - sizeof(*th);\n\tconst u8 *ptr = (const u8 *)(th + 1);\n\tif (length < TCPOLEN_MD5SIG)\n\t\treturn NULL;\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn NULL;\n\t\tcase TCPOPT_NOP:\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2 || opsize > length)\n\t\t\t\treturn NULL;\n\t\t\tif (opcode == TCPOPT_MD5SIG)\n\t\t\t\treturn opsize == TCPOLEN_MD5SIG ? ptr : NULL;\n\t\t}\n\t\tptr += opsize - 2;\n\t\tlength -= opsize;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              FALSE, 0, NULL, arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,\n                                          arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n    if (ret.code != KADM5_AUTH_CHANGEPW) {\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static int __init ipgre_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\nout:\n\treturn err;\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}", "target": 1}
{"code": "bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n}", "target": 1}
{"code": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif \n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif \n\t\tcap->device_caps = cap->capabilities = capabilities;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}", "target": 1}
{"code": "ram_addr_t qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n                                   void (*resized)(const char*,\n                                                   uint64_t length,\n                                                   void *host),\n                                   void *host, bool resizeable,\n                                   MemoryRegion *mr, Error **errp)\n{\n    RAMBlock *new_block;\n    ram_addr_t addr;\n    Error *local_err = NULL;\n    size = TARGET_PAGE_ALIGN(size);\n    max_size = TARGET_PAGE_ALIGN(max_size);\n    new_block = g_malloc0(sizeof(*new_block));\n    new_block->mr = mr;\n    new_block->resized = resized;\n    new_block->used_length = size;\n    new_block->max_length = max_size;\n    assert(max_size >= size);\n    new_block->fd = -1;\n    new_block->host = host;\n    if (host) {\n        new_block->flags |= RAM_PREALLOC;\n    }\n    if (resizeable) {\n        new_block->flags |= RAM_RESIZEABLE;\n    }\n    addr = ram_block_add(new_block, &local_err);\n    if (local_err) {\n        g_free(new_block);\n        error_propagate(errp, local_err);\n        return -1;\n    }\n    return addr;\n}", "target": 0}
{"code": "static int present_and_same_family(const struct sadb_address *src,\n\t\t\t\t   const struct sadb_address *dst)\n{\n\tconst struct sockaddr *s_addr, *d_addr;\n\tif (!src || !dst)\n\t\treturn 0;\n\ts_addr = (const struct sockaddr *)(src + 1);\n\td_addr = (const struct sockaddr *)(dst + 1);\n\tif (s_addr->sa_family != d_addr->sa_family)\n\t\treturn 0;\n\tif (s_addr->sa_family != AF_INET\n#if IS_ENABLED(CONFIG_IPV6)\n\t    && s_addr->sa_family != AF_INET6\n#endif\n\t\t)\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "DLLIMPORT cfg_bool_t cfg_getbool(cfg_t *cfg, const char *name)\n{\n\treturn cfg_getnbool(cfg, name, 0);\n}", "target": 0}
{"code": "void preempt_notifier_dec(void)\n{\n\tstatic_key_slow_dec(&preempt_notifier_key);\n}", "target": 0}
{"code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  int pos = 0;\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n  for(int i = 0; i < commentFields; i++) {\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    int commentSeparatorPosition = comment.find(\"=\");\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n    addField(key, value, false);\n  }\n}", "target": 1}
{"code": "void ssl_update_cache(SSL *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(s, s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "cdf_dump_stream(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\tcdf_dump(sst->sst_tab, ss * sst->sst_len);\n}", "target": 0}
{"code": "static int orinoco_ioctl_setwap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct sockaddr *ap_addr,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t\n\tunsigned long flags;\n\tstatic const u8 off_addr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tstatic const u8 any_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tif (memcmp(&ap_addr->sa_data, off_addr, ETH_ALEN) == 0 ||\n\t    memcmp(&ap_addr->sa_data, any_addr, ETH_ALEN) == 0) {\n\t\tpriv->bssid_fixed = 0;\n\t\tmemset(priv->desired_bssid, 0, ETH_ALEN);\n\t\tif (ap_addr->sa_data[0] == 0) {\n\t\t\t__orinoco_hw_set_wap(priv);\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\tif (priv->firmware_type == FIRMWARE_TYPE_AGERE) {\n\t\tprintk(KERN_WARNING \"%s: Lucent/Agere firmware doesn't \"\n\t\t       \"support manual roaming\\n\",\n\t\t       dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (priv->iw_mode != NL80211_IFTYPE_STATION) {\n\t\tprintk(KERN_WARNING \"%s: Manual roaming supported only in \"\n\t\t       \"managed mode\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (priv->firmware_type == FIRMWARE_TYPE_INTERSIL &&\n\t    strlen(priv->desired_essid) == 0) {\n\t\tprintk(KERN_WARNING \"%s: Desired ESSID must be set for \"\n\t\t       \"manual roaming\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tpriv->bssid_fixed = 1;\n\tmemcpy(priv->desired_bssid, &ap_addr->sa_data, ETH_ALEN);\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}", "target": 0}
{"code": "translate_input(int forward_translation, char *table_name) {\n\tchar charbuf[BUFSIZE];\n\tuint8_t *outputbuf;\n\tsize_t outlen;\n\twidechar inbuf[BUFSIZE];\n\twidechar transbuf[BUFSIZE];\n\tint inlen;\n\tint translen;\n\tint k;\n\tint ch = 0;\n\tint result;\n\twhile (1) {\n\t\ttranslen = BUFSIZE;\n\t\tk = 0;\n\t\twhile ((ch = fgetc(input)) != '\\n' && ch != EOF && k < BUFSIZE - 1)\n\t\t\tcharbuf[k++] = ch;\n\t\tif (ch == EOF && k == 0) break;\n\t\tcharbuf[k] = 0;\n\t\tinlen = _lou_extParseChars(charbuf, inbuf);\n\t\tif (forward_translation)\n\t\t\tresult = lou_translateString(\n\t\t\t\t\ttable_name, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0);\n\t\telse\n\t\t\tresult = lou_backTranslateString(\n\t\t\t\t\ttable_name, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0);\n\t\tif (!result) break;\n#ifdef WIDECHARS_ARE_UCS4\n\t\toutputbuf = u32_to_u8(transbuf, translen, NULL, &outlen);\n#else\n\t\toutputbuf = u16_to_u8(transbuf, translen, NULL, &outlen);\n#endif\n\t\tprintf(ch == EOF ? \"%.*s\" : \"%.*s\\n\", (int)outlen, outputbuf);\n\t\tfree(outputbuf);\n\t}\n\tlou_free();\n}", "target": 1}
{"code": "clientHierarchical(ClientHttpRequest * http)\n{\n    HttpRequest *request = http->request;\n    HttpRequestMethod method = request->method;\n    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))\n        return 0;\n    if (request->flags.ims && !neighbors_do_private_keys)\n        return 0;\n    if (request->flags.auth)\n        return 0;\n    if (method == Http::METHOD_TRACE)\n        return 1;\n    if (method != Http::METHOD_GET)\n        return 0;\n    if (request->flags.loopDetected)\n        return 0;\n    if (request->url.getScheme() == AnyP::PROTO_HTTP)\n        return method.respMaybeCacheable();\n    if (request->url.getScheme() == AnyP::PROTO_GOPHER)\n        return gopherCachable(request);\n    if (request->url.getScheme() == AnyP::PROTO_CACHE_OBJECT)\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo,\n\t\t\t\t const void *text, size_t text_size,\n\t\t\t\t void *digest)\n{\n\tstruct nettle_hash_ctx ctx;\n\tint ret;\n\tret = _ctx_init(algo, &ctx);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tctx.update(&ctx, text_size, text);\n\tctx.digest(&ctx, ctx.length, digest);\n\treturn 0;\n}", "target": 1}
{"code": "static void blk_mq_insert_requests(struct request_queue *q,\n\t\t\t\t     struct blk_mq_ctx *ctx,\n\t\t\t\t     struct list_head *list,\n\t\t\t\t     int depth,\n\t\t\t\t     bool from_schedule)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct blk_mq_ctx *current_ctx;\n\ttrace_block_unplug(q, depth, !from_schedule);\n\tcurrent_ctx = blk_mq_get_ctx(q);\n\tif (!cpu_online(ctx->cpu))\n\t\tctx = current_ctx;\n\thctx = q->mq_ops->map_queue(q, ctx->cpu);\n\tspin_lock(&ctx->lock);\n\twhile (!list_empty(list)) {\n\t\tstruct request *rq;\n\t\trq = list_first_entry(list, struct request, queuelist);\n\t\tlist_del_init(&rq->queuelist);\n\t\trq->mq_ctx = ctx;\n\t\t__blk_mq_insert_request(hctx, rq, false);\n\t}\n\tspin_unlock(&ctx->lock);\n\tblk_mq_run_hw_queue(hctx, from_schedule);\n\tblk_mq_put_ctx(current_ctx);\n}", "target": 0}
{"code": "void STDCALL mysql_close(MYSQL *mysql)\n{\n  DBUG_ENTER(\"mysql_close\");\n  if (mysql)\t\t\t\t\t\n  {\n    if (mysql->net.vio != 0)\n    {\n      free_old_query(mysql);\n      mysql->status=MYSQL_STATUS_READY; \n      mysql->reconnect=0;\n      simple_command(mysql,COM_QUIT,(uchar*) 0,0,1);\n      end_server(mysql);\t\t\t\n    }\n    mysql_close_free_options(mysql);\n    mysql_close_free(mysql);\n    mysql_detach_stmt_list(&mysql->stmts, \"mysql_close\");\n#ifndef MYSQL_SERVER\n    if (mysql->thd)\n      (*mysql->methods->free_embedded_thd)(mysql);\n#endif\n    if (mysql->free_me)\n      my_free(mysql);\n  }\n  DBUG_VOID_RETURN;", "target": 0}
{"code": "struct bio *bio_map_kern(struct request_queue *q, void *data, unsigned int len,\n\t\t\t gfp_t gfp_mask)\n{\n\tunsigned long kaddr = (unsigned long)data;\n\tunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = kaddr >> PAGE_SHIFT;\n\tconst int nr_pages = end - start;\n\tint offset, i;\n\tstruct bio *bio;\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\toffset = offset_in_page(kaddr);\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunsigned int bytes = PAGE_SIZE - offset;\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\t\tif (bio_add_pc_page(q, bio, virt_to_page(data), bytes,\n\t\t\t\t    offset) < bytes) {\n\t\t\tbio_put(bio);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdata += bytes;\n\t\tlen -= bytes;\n\t\toffset = 0;\n\t}\n\tbio->bi_end_io = bio_map_kern_endio;\n\treturn bio;\n}", "target": 0}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int PpapiPluginMain(const content::MainFunctionParams& parameters) {\n  const CommandLine& command_line = parameters.command_line;\n#if defined(OS_WIN)\n  g_target_services = parameters.sandbox_info->target_services;\n#endif\n  if (command_line.HasSwitch(switches::kPpapiStartupDialog)) {\n    if (g_target_services)\n      base::debug::WaitForDebugger(2*60, false);\n    else\n       ChildProcess::WaitForDebugger(\"Ppapi\");\n   }\n  if (command_line.HasSwitch(switches::kLang)) {\n    std::string locale = command_line.GetSwitchValueASCII(switches::kLang);\n    base::i18n::SetICUDefaultLocale(locale);\n  }\n   MessageLoop main_message_loop;\n   base::PlatformThread::SetName(\"CrPPAPIMain\");\n#if defined(OS_LINUX)\n  content::InitializeSandbox();\n#endif\n  ChildProcess ppapi_process;\n  ppapi_process.set_main_thread(\n      new PpapiThread(parameters.command_line, false));  \n  main_message_loop.Run();\n  return 0;\n}", "target": 0}
{"code": "static void ff_layout_put_mirror(struct nfs4_ff_layout_mirror *mirror)\n{\n\tif (mirror != NULL && refcount_dec_and_test(&mirror->ref))\n\t\tff_layout_free_mirror(mirror);\n}", "target": 0}
{"code": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}", "target": 1}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static int load_file(struct augeas *aug, struct lens *lens,\n                     const char *lens_name, char *filename) {\n    char *text = NULL;\n    const char *err_status = NULL;\n    struct tree *tree = NULL;\n    char *path = NULL;\n    struct lns_error *err = NULL;\n    struct span *span = NULL;\n    int result = -1, r, text_len = 0;\n    path = file_name_path(aug, filename);\n    ERR_NOMEM(path == NULL, aug);\n    r = add_file_info(aug, path, lens, lens_name, filename, false);\n    if (r < 0)\n        goto done;\n    text = xread_file(filename);\n    if (text == NULL) {\n        err_status = \"read_failed\";\n        goto done;\n    }\n    text_len = strlen(text);\n    text = append_newline(text, text_len);\n    struct info *info;\n    make_ref(info);\n    make_ref(info->filename);\n    info->filename->str = strdup(filename);\n    info->error = aug->error;\n    info->flags = aug->flags;\n    info->first_line = 1;\n    if (aug->flags & AUG_ENABLE_SPAN) {\n        span = make_span(info);\n        ERR_NOMEM(span == NULL, info);\n    }\n    tree = lns_get(info, lens, text, &err);\n    unref(info, info);\n    if (err != NULL) {\n        err_status = \"parse_failed\";\n        goto done;\n    }\n    tree_replace(aug, path, tree);\n    if (span != NULL && tree != NULL) {\n        tree->parent->span = span;\n        tree->parent->span->span_start = 0;\n        tree->parent->span->span_end = text_len;\n    }\n    tree = NULL;\n    result = 0;\n done:\n    store_error(aug, filename + strlen(aug->root) - 1, path, err_status,\n                errno, err, text);\n error:\n    free_lns_error(err);\n    free(path);\n    free_tree(tree);\n    free(text);\n    return result;\n}", "target": 0}
{"code": "ZEND_API int ZEND_FASTCALL zend_binary_strncmp(const char *s1, size_t len1, const char *s2, size_t len2, size_t length) \n{\n\tint retval;\n\tif (s1 == s2) {\n\t\treturn 0;\n\t}\n\tretval = memcmp(s1, s2, MIN(length, MIN(len1, len2)));\n\tif (!retval) {\n\t\treturn (int)(MIN(length, len1) - MIN(length, len2));\n\t} else {\n\t\treturn retval;\n\t}\n}", "target": 0}
{"code": "static int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tkenter(\"{%d}\", key->serial);\n\tBUG_ON(key != ctx->match_data);\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}", "target": 1}
{"code": "static void nvme_dsm_cb(void *opaque, int ret)\n{\n    NvmeDSMAIOCB *iocb = opaque;\n    NvmeRequest *req = iocb->req;\n    NvmeCtrl *n = nvme_ctrl(req);\n    NvmeNamespace *ns = req->ns;\n    NvmeDsmRange *range;\n    uint64_t slba;\n    uint32_t nlb;\n    if (ret < 0) {\n        iocb->ret = ret;\n        goto done;\n    }\nnext:\n    if (iocb->idx == iocb->nr) {\n        goto done;\n    }\n    range = &iocb->range[iocb->idx++];\n    slba = le64_to_cpu(range->slba);\n    nlb = le32_to_cpu(range->nlb);\n    trace_pci_nvme_dsm_deallocate(slba, nlb);\n    if (nlb > n->dmrsl) {\n        trace_pci_nvme_dsm_single_range_limit_exceeded(nlb, n->dmrsl);\n        goto next;\n    }\n    if (nvme_check_bounds(ns, slba, nlb)) {\n        trace_pci_nvme_err_invalid_lba_range(slba, nlb,\n                                             ns->id_ns.nsze);\n        goto next;\n    }\n    iocb->aiocb = blk_aio_pdiscard(ns->blkconf.blk, nvme_l2b(ns, slba),\n                                   nvme_l2b(ns, nlb),\n                                   nvme_dsm_md_cb, iocb);\n    return;\ndone:\n    iocb->aiocb = NULL;\n    qemu_bh_schedule(iocb->bh);\n}", "target": 0}
{"code": "static int exif_rewrite_tag_format_to_unsigned(int format)\n{\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE: return TAG_FMT_BYTE;\n\t\tcase TAG_FMT_SRATIONAL: return TAG_FMT_URATIONAL;\n\t\tcase TAG_FMT_SSHORT: return TAG_FMT_USHORT;\n\t\tcase TAG_FMT_SLONG: return TAG_FMT_ULONG;\n\t}\n\treturn format;\n}", "target": 0}
{"code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1}
{"code": "writepid (const char* pidfile, pid_t pid)\n{\n\tFILE* f;\n\tif ((f = fopen(pidfile, \"w\")) ==  NULL ) {\n\t\tlog_err(\"cannot open pidfile %s: %s\", \n\t\t\tpidfile, strerror(errno));\n\t\treturn;\n\t}\n\tif(fprintf(f, \"%lu\\n\", (unsigned long)pid) < 0) {\n\t\tlog_err(\"cannot write to pidfile %s: %s\", \n\t\t\tpidfile, strerror(errno));\n\t}\n\tfclose(f);\n}", "target": 1}
{"code": "static int i740fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset\t= var->green.offset = var->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (var->green.length) {\n\t\tdefault:\n\t\tcase 5:\n\t\t\tvar->red.offset = 10;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length\t= 5;\n\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.length = 5;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tvar->red.offset = 11;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length = var->blue.length = 5;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->transp.length = 8;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\tif (info->monspecs.hfmax && info->monspecs.vfmax &&\n\t    info->monspecs.dclkmax && fb_validate_mode(var, info) < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "struct mb2_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}", "target": 0}
{"code": "dump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[21];\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\tif (!level)\n\t\tfclose(fp);\n}", "target": 1}
{"code": "static inline int xsave_state(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\talternative_input_2(\n\t\t\"1:\"XSAVE,\n\t\t\"1:\"XSAVEOPT,\n\t\tX86_FEATURE_XSAVEOPT,\n\t\t\"1:\"XSAVES,\n\t\tX86_FEATURE_XSAVES,\n\t\t[fx] \"D\" (fx), \"a\" (lmask), \"d\" (hmask) :\n\t\t\"memory\");\n\tasm volatile(\"2:\\n\\t\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "static void csi_X(struct vc_data *vc, int vpar) \n{\t\t\t\t\t  \n\tint count;\n\tif (!vpar)\n\t\tvpar++;\n\tcount = (vpar > vc->vc_cols - vc->vc_x) ? (vc->vc_cols - vc->vc_x) : vpar;\n\tvc_uniscr_clear_line(vc, vc->vc_x, count);\n\tscr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);\n\tif (con_should_update(vc))\n\t\tvc->vc_sw->con_clear(vc, vc->vc_y, vc->vc_x, 1, count);\n\tvc->vc_need_wrap = 0;\n}", "target": 0}
{"code": "static void date_period_it_invalidate_current(zend_object_iterator *iter TSRMLS_DC)\n{\n\tdate_period_it *iterator = (date_period_it *)iter;\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}", "target": 0}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "static int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count;\n    nut->avf = s;\n    pos = 0;\n    do {\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while (decode_main_header(nut) < 0);\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n        decode_info_header(nut);\n    }\n    ffformatcontext(s)->data_offset = pos - 8;\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n    return 0;\n}", "target": 1}
{"code": "int git_treebuilder_insert(\n\tconst git_tree_entry **entry_out,\n\tgit_treebuilder *bld,\n\tconst char *filename,\n\tconst git_oid *id,\n\tgit_filemode_t filemode)\n{\n\tgit_tree_entry *entry;\n\tsize_t pos;\n\tassert(bld && id && filename);\n\tif (!valid_filemode(filemode))\n\t\treturn tree_error(\"Failed to insert entry. Invalid filemode for file\", filename);\n\tif (!valid_entry_name(filename))\n\t\treturn tree_error(\"Failed to insert entry. Invalid name for a tree entry\", filename);\n\tif (!tree_key_search(&pos, &bld->entries, filename, strlen(filename))) {\n\t\tentry = git_vector_get(&bld->entries, pos);\n\t\tif (entry->removed) {\n\t\t\tentry->removed = 0;\n\t\t\tbld->entrycount++;\n\t\t}\n\t\tentry->attr = filemode;\n\t\tgit_oid_cpy(&entry->oid, id);\n\t} else {\n\t\tentry = alloc_entry(filename);\n\t\tGITERR_CHECK_ALLOC(entry);\n\t\tentry->attr = filemode;\n\t\tgit_oid_cpy(&entry->oid, id);\n\t\tif (git_vector_insert_sorted(&bld->entries, entry, NULL) < 0) {\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t\tbld->entrycount++;\n\t}\n\tif (entry_out)\n\t\t*entry_out = entry;\n\treturn 0;\n}", "target": 0}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "void Hybrid_type_traits_decimal::set_zero(Hybrid_type *val) const\n{\n  my_decimal_set_zero(&val->dec_buf[0]);\n  val->used_dec_buf_no= 0;\n}", "target": 0}
{"code": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tstruct sshcomp *comp;\n\tint r, mode;\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif (ssh->state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &ssh->state->newkeys[mode]->comp;\n\t\tif (comp && comp->enabled &&\n\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static bool ok_inflater_compressed_block(ok_inflater *inflater) {\n    const bool is_fixed = inflater->state == OK_INFLATER_STATE_READING_FIXED_COMPRESSED_BLOCK;\n    const ok_inflater_huffman_tree *literal_tree =\n        (is_fixed ? inflater->fixed_literal_huffman : inflater->literal_huffman);\n    const ok_inflater_huffman_tree *distance_tree =\n        (is_fixed ? inflater->fixed_distance_huffman : inflater->distance_huffman);\n    size_t max_write = ok_inflater_can_write_total(inflater);\n    const uint16_t *tree_lookup_table = literal_tree->lookup_table;\n    const unsigned int tree_bits = literal_tree->bits;\n    while (max_write > 0) {\n        int value = ok_inflater_decode_literal(inflater, tree_lookup_table, tree_bits);\n        if (value < 0) {\n            return false;\n        } else if (value < 256) {\n            ok_inflater_write_byte(inflater, (uint8_t)value);\n            max_write--;\n        } else if (value == 256) {\n            inflater->state = OK_INFLATER_STATE_READY_FOR_NEXT_BLOCK;\n            return true;\n        } else if (value < 286) {\n            inflater->huffman_code = value - 257;\n            inflater->state_count = -1;\n            inflater->state_distance = -1;\n            if (ok_inflater_distance_with_tree(inflater, distance_tree)) {\n                max_write = ok_inflater_can_write_total(inflater);\n            } else {\n                if (is_fixed) {\n                    inflater->state = OK_INFLATER_STATE_READING_FIXED_DISTANCE;\n                } else {\n                    inflater->state = OK_INFLATER_STATE_READING_DYNAMIC_DISTANCE;\n                }\n                return false;\n            }\n        } else {\n            ok_inflater_error(inflater, \"Invalid inflater literal\");\n            return false;\n        }\n    }\n    return false;\n}", "target": 0}
{"code": "ctnetlink_parse_tuple_filter(const struct nlattr * const cda[],\n\t\t\t      struct nf_conntrack_tuple *tuple, u32 type,\n\t\t\t      u_int8_t l3num, struct nf_conntrack_zone *zone,\n\t\t\t      u_int32_t flags)\n{\n\tstruct nlattr *tb[CTA_TUPLE_MAX+1];\n\tint err;\n\tmemset(tuple, 0, sizeof(*tuple));\n\terr = nla_parse_nested_deprecated(tb, CTA_TUPLE_MAX, cda[type],\n\t\t\t\t\t  tuple_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\ttuple->src.l3num = l3num;\n\tif (flags & CTA_FILTER_FLAG(CTA_IP_DST) ||\n\t    flags & CTA_FILTER_FLAG(CTA_IP_SRC)) {\n\t\tif (!tb[CTA_TUPLE_IP])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_ip(tb[CTA_TUPLE_IP], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (flags & CTA_FILTER_FLAG(CTA_PROTO_NUM)) {\n\t\tif (!tb[CTA_TUPLE_PROTO])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_proto(tb[CTA_TUPLE_PROTO], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (flags & CTA_FILTER_FLAG(ALL_CTA_PROTO)) {\n\t\treturn -EINVAL;\n\t}\n\tif ((flags & CTA_FILTER_FLAG(CTA_TUPLE_ZONE)) && tb[CTA_TUPLE_ZONE]) {\n\t\tif (!zone)\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_zone(tb[CTA_TUPLE_ZONE],\n\t\t\t\t\t\t type, zone);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (type == CTA_TUPLE_REPLY)\n\t\ttuple->dst.dir = IP_CT_DIR_REPLY;\n\telse\n\t\ttuple->dst.dir = IP_CT_DIR_ORIGINAL;\n\treturn 0;\n}", "target": 1}
{"code": "static void ml_ff_destroy(struct ff_device *ff)\n{\n\tstruct ml_device *ml = ff->private;\n\tkfree(ml->private);\n}", "target": 1}
{"code": "static CURLcode error_init_writer(struct Curl_easy *data,\n                                  struct contenc_writer *writer)\n{\n  (void) data;\n  return writer->downstream? CURLE_OK: CURLE_WRITE_ERROR;\n}", "target": 0}
{"code": "Status OpLevelCostEstimator::PredictMaxPoolGrad(const OpContext& op_context,\n                                                NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;\n  } else if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy);\n  } else {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy * 2);\n  }\n  node_costs->num_compute_ops = ops;\n  const int64_t input0_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  const int64_t input2_size =\n      CalculateTensorSize(op_info.inputs(2), &found_unknown_shapes);\n  node_costs->num_input_bytes_accessed = {input0_size, 0, input2_size};\n  const int64_t output_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "  void dumpState(std::ostream& os, int indent_level = 0) const override {\n    header_map_->dumpState(os, indent_level);\n  }", "target": 0}
{"code": "static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tchar *end;\n\tint rc;\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\tmemcpy(drc_name, buf, nbytes);\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\trc = dlpar_add_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\treturn nbytes;\n}", "target": 1}
{"code": "static int iommu_init_domains(struct intel_iommu *iommu)\n{\n\tu32 ndomains, nlongs;\n\tsize_t size;\n\tndomains = cap_ndoms(iommu->cap);\n\tpr_debug(\"%s: Number of Domains supported <%d>\\n\",\n\t\t iommu->name, ndomains);\n\tnlongs = BITS_TO_LONGS(ndomains);\n\tspin_lock_init(&iommu->lock);\n\tiommu->domain_ids = kcalloc(nlongs, sizeof(unsigned long), GFP_KERNEL);\n\tif (!iommu->domain_ids) {\n\t\tpr_err(\"%s: Allocating domain id array failed\\n\",\n\t\t       iommu->name);\n\t\treturn -ENOMEM;\n\t}\n\tsize = (ALIGN(ndomains, 256) >> 8) * sizeof(struct dmar_domain **);\n\tiommu->domains = kzalloc(size, GFP_KERNEL);\n\tif (iommu->domains) {\n\t\tsize = 256 * sizeof(struct dmar_domain *);\n\t\tiommu->domains[0] = kzalloc(size, GFP_KERNEL);\n\t}\n\tif (!iommu->domains || !iommu->domains[0]) {\n\t\tpr_err(\"%s: Allocating domain array failed\\n\",\n\t\t       iommu->name);\n\t\tkfree(iommu->domain_ids);\n\t\tkfree(iommu->domains);\n\t\tiommu->domain_ids = NULL;\n\t\tiommu->domains    = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tset_bit(0, iommu->domain_ids);\n\treturn 0;\n}", "target": 0}
{"code": "static int wcd9335_slim_status(struct slim_device *sdev,\n\t\t\t       enum slim_device_status status)\n{\n\tstruct device *dev = &sdev->dev;\n\tstruct device_node *ifc_dev_np;\n\tstruct wcd9335_codec *wcd;\n\tint ret;\n\twcd = dev_get_drvdata(dev);\n\tifc_dev_np = of_parse_phandle(dev->of_node, \"slim-ifc-dev\", 0);\n\tif (!ifc_dev_np) {\n\t\tdev_err(dev, \"No Interface device found\\n\");\n\t\treturn -EINVAL;\n\t}\n\twcd->slim = sdev;\n\twcd->slim_ifc_dev = of_slim_get_device(sdev->ctrl, ifc_dev_np);\n\tof_node_put(ifc_dev_np);\n\tif (!wcd->slim_ifc_dev) {\n\t\tdev_err(dev, \"Unable to get SLIM Interface device\\n\");\n\t\treturn -EINVAL;\n\t}\n\tslim_get_logical_addr(wcd->slim_ifc_dev);\n\twcd->regmap = regmap_init_slimbus(sdev, &wcd9335_regmap_config);\n\tif (IS_ERR(wcd->regmap)) {\n\t\tdev_err(dev, \"Failed to allocate slim register map\\n\");\n\t\treturn PTR_ERR(wcd->regmap);\n\t}\n\twcd->if_regmap = regmap_init_slimbus(wcd->slim_ifc_dev,\n\t\t\t\t\t\t  &wcd9335_ifc_regmap_config);\n\tif (IS_ERR(wcd->if_regmap)) {\n\t\tdev_err(dev, \"Failed to allocate ifc register map\\n\");\n\t\treturn PTR_ERR(wcd->if_regmap);\n\t}\n\tret = wcd9335_bring_up(wcd);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to bringup WCD9335\\n\");\n\t\treturn ret;\n\t}\n\tret = wcd9335_irq_init(wcd);\n\tif (ret)\n\t\treturn ret;\n\twcd9335_probe(wcd);\n\treturn ret;\n}", "target": 0}
{"code": "static int32_t gcd(int a, int b)\n{\n  if (a == 0 && b == 0) {\n    return 1;\n  }\n  if (a == 0) return b;\n  if (b == 0) return a;\n  int32_t h;\n  do {\n    h = a % b;\n    a = b;\n    b = h;\n  } while (b != 0);\n  return a;\n}", "target": 1}
{"code": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\treturn (state->list[state->pos++] + state->rand) % state->count;\n}", "target": 1}
{"code": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n        return FALSE;\n}", "target": 1}
{"code": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\t\tALLOC_INIT_ZVAL(key);\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tALLOC_INIT_ZVAL(data);\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\tzval_dtor(data);\n\t\t\tFREE_ZVAL(data);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n                } else {\n                        convert_to_string(key);\n                       if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n                               var_push_dtor(var_hash, old_data);\n                       }\n                        zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n                                        sizeof data, NULL);\n                }\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}", "target": 0}
{"code": "static int nfs4_xdr_dec_rename(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       struct nfs_renameres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_savefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_rename(xdr, &res->old_cinfo, &res->new_cinfo);\nout:\n\treturn status;\n}", "target": 0}
{"code": "static int __init si_domain_init(int hw)\n{\n\tint nid, ret;\n\tsi_domain = alloc_domain(DOMAIN_FLAG_STATIC_IDENTITY);\n\tif (!si_domain)\n\t\treturn -EFAULT;\n\tif (md_domain_init(si_domain, DEFAULT_DOMAIN_ADDRESS_WIDTH)) {\n\t\tdomain_exit(si_domain);\n\t\treturn -EFAULT;\n\t}\n\tpr_debug(\"Identity mapping domain allocated\\n\");\n\tif (hw)\n\t\treturn 0;\n\tfor_each_online_node(nid) {\n\t\tunsigned long start_pfn, end_pfn;\n\t\tint i;\n\t\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {\n\t\t\tret = iommu_domain_identity_map(si_domain,\n\t\t\t\t\tPFN_PHYS(start_pfn), PFN_PHYS(end_pfn));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void sco_conn_ready(struct sco_conn *conn)\n{\n\tstruct sock *parent;\n\tstruct sock *sk = conn->sk;\n\tBT_DBG(\"conn %p\", conn);\n\tif (sk) {\n\t\tlock_sock(sk);\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tsk->sk_state_change(sk);\n\t\trelease_sock(sk);\n\t} else {\n\t\tsco_conn_lock(conn);\n\t\tif (!conn->hcon) {\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\t\tparent = sco_get_sock_listen(&conn->hcon->src);\n\t\tif (!parent) {\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\t\tlock_sock(parent);\n\t\tsk = sco_sock_alloc(sock_net(parent), NULL,\n\t\t\t\t    BTPROTO_SCO, GFP_ATOMIC, 0);\n\t\tif (!sk) {\n\t\t\trelease_sock(parent);\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\t\tsco_sock_init(sk, parent);\n\t\tbacpy(&sco_pi(sk)->src, &conn->hcon->src);\n\t\tbacpy(&sco_pi(sk)->dst, &conn->hcon->dst);\n\t\thci_conn_hold(conn->hcon);\n\t\t__sco_chan_add(conn, sk, parent);\n\t\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags))\n\t\t\tsk->sk_state = BT_CONNECT2;\n\t\telse\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\tparent->sk_data_ready(parent);\n\t\trelease_sock(parent);\n\t\tsco_conn_unlock(conn);\n\t}\n}", "target": 0}
{"code": "static __init int seqgen_init(void)\n{\n\trekey_seq_generator(NULL);\n\treturn 0;\n}", "target": 1}
{"code": "int infra_ip_ratelimit_inc(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint has_cookie, int backoff, struct sldns_buffer* buffer)\n{\n\tint max;\n\tstruct lruhash_entry* entry;\n\tif(!infra_ip_ratelimit) {\n\t\treturn 1;\n\t}\n\tentry = infra_find_ip_ratedata(infra, addr, addrlen, 1);\n\tif(entry) {\n\t\tint premax = infra_rate_max(entry->data, timenow, backoff);\n\t\tint* cur = infra_rate_give_second(entry->data, timenow);\n\t\t(*cur)++;\n\t\tmax = infra_rate_max(entry->data, timenow, backoff);\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn check_ip_ratelimit(addr, addrlen, buffer, premax, max,\n\t\t\thas_cookie);\n\t}\n\tinfra_ip_create_ratedata(infra, addr, addrlen, timenow);\n\treturn 1;\n}", "target": 1}
{"code": "static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n{\n    CURLState *s = ((CURLState*)opaque);\n    size_t realsize = size * nmemb;\n    int i;\n    DPRINTF(\"CURL: Just reading %zd bytes\\n\", realsize);\n    if (!s || !s->orig_buf)\n        goto read_end;\n    memcpy(s->orig_buf + s->buf_off, ptr, realsize);\n    s->buf_off += realsize;\n    for(i=0; i<CURL_NUM_ACB; i++) {\n        CURLAIOCB *acb = s->acb[i];\n        if (!acb)\n            continue;\n        if ((s->buf_off >= acb->end)) {\n            qemu_iovec_from_buf(acb->qiov, 0, s->orig_buf + acb->start,\n                                acb->end - acb->start);\n            acb->common.cb(acb->common.opaque, 0);\n            qemu_aio_release(acb);\n            s->acb[i] = NULL;\n        }\n    }\nread_end:\n    return realsize;\n}", "target": 1}
{"code": "int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tunsigned short snum;\n\tint err;\n\tint dif = sk->sk_bound_dev_if;\n\terr = ping_check_bind_addr(sk, isk, uaddr, addr_len);\n\tif (err)\n\t\treturn err;\n\tlock_sock(sk);\n\terr = -EINVAL;\n\tif (isk->inet_num != 0)\n\t\tgoto out;\n\terr = -EADDRINUSE;\n\tping_set_saddr(sk, uaddr);\n\tsnum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);\n\tif (ping_get_port(sk, snum) != 0) {\n\t\tping_clear_saddr(sk, dif);\n\t\tgoto out;\n\t}\n\tpr_debug(\"after bind(): num = %hu, dif = %d\\n\",\n\t\t isk->inet_num,\n\t\t sk->sk_bound_dev_if);\n\terr = 0;\n\tif (sk->sk_family == AF_INET && isk->inet_rcv_saddr)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6 && !ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#endif\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tisk->inet_sport = htons(isk->inet_num);\n\tisk->inet_daddr = 0;\n\tisk->inet_dport = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\tmemset(&sk->sk_v6_daddr, 0, sizeof(sk->sk_v6_daddr));\n#endif\n\tsk_dst_reset(sk);\nout:\n\trelease_sock(sk);\n\tpr_debug(\"ping_v4_bind -> %d\\n\", err);\n\treturn err;\n}", "target": 0}
{"code": "xfs_bmap_add_free(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_defer_ops\t\t*dfops,\n\txfs_fsblock_t\t\t\tbno,\n\txfs_filblks_t\t\t\tlen,\n\tstruct xfs_owner_info\t\t*oinfo)\n{\n\tstruct xfs_extent_free_item\t*new;\t\t\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xefi_startblock = bno;\n\tnew->xefi_blockcount = (xfs_extlen_t)len;\n\tif (oinfo)\n\t\tnew->xefi_oinfo = *oinfo;\n\telse\n\t\txfs_rmap_skip_owner_update(&new->xefi_oinfo);\n\ttrace_xfs_bmap_free_defer(mp, XFS_FSB_TO_AGNO(mp, bno), 0,\n\t\t\tXFS_FSB_TO_AGBNO(mp, bno), len);\n\txfs_defer_add(dfops, XFS_DEFER_OPS_TYPE_FREE, &new->xefi_list);\n}", "target": 0}
{"code": "void WasmBinaryBuilder::visitDrop(Drop* curr) {\n  BYN_TRACE(\"zz node: Drop\\n\");\n  curr->value = popNonVoidExpression();\n  curr->finalize();\n}", "target": 0}
{"code": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\tif (entry->fields.mask)\n\t\treturn -1;\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr &= ~(1 << irq);\n\tif (irq == RTC_GSI && line_status) {\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\tioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = ret;\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\treturn ret;\n}", "target": 1}
{"code": "int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tif (sec_attr == NULL || sec_attr_len) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\treturn 0;\n}", "target": 0}
{"code": "static int irda_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\treturn -ENOIOCTLCMD;\n}", "target": 0}
{"code": "OmniboxViewWin::~OmniboxViewWin() {\n  text_object_model_->Release();\n  g_paint_patcher.Pointer()->DerefPatch();\n}", "target": 0}
{"code": "rb_reserve_next_event(struct ring_buffer *buffer,\n\t\t      struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      unsigned long length)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_event_info info;\n\tint nr_loops = 0;\n\tu64 diff;\n\trb_start_commit(cpu_buffer);\n#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP\n\tbarrier();\n\tif (unlikely(ACCESS_ONCE(cpu_buffer->buffer) != buffer)) {\n\t\tlocal_dec(&cpu_buffer->committing);\n\t\tlocal_dec(&cpu_buffer->commits);\n\t\treturn NULL;\n\t}\n#endif\n\tinfo.length = rb_calculate_event_length(length);\n again:\n\tinfo.add_timestamp = 0;\n\tinfo.delta = 0;\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 1000))\n\t\tgoto out_fail;\n\tinfo.ts = rb_time_stamp(cpu_buffer->buffer);\n\tdiff = info.ts - cpu_buffer->write_stamp;\n\tbarrier();\n\tif (likely(info.ts >= cpu_buffer->write_stamp)) {\n\t\tinfo.delta = diff;\n\t\tif (unlikely(test_time_stamp(info.delta)))\n\t\t\trb_handle_timestamp(cpu_buffer, &info);\n\t}\n\tevent = __rb_reserve_next(cpu_buffer, &info);\n\tif (unlikely(PTR_ERR(event) == -EAGAIN)) {\n\t\tif (info.add_timestamp)\n\t\t\tinfo.length -= RB_LEN_TIME_EXTEND;\n\t\tgoto again;\n\t}\n\tif (!event)\n\t\tgoto out_fail;\n\treturn event;\n out_fail:\n\trb_end_commit(cpu_buffer);\n\treturn NULL;\n}", "target": 0}
{"code": "static void interface_release_resource(QXLInstance *sin,\n                                       QXLReleaseInfoExt ext)\n{\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n    QXLReleaseRing *ring;\n    uint64_t *item, id;\n    if (ext.group_id == MEMSLOT_GROUP_HOST) {\n        QXLCommandExt *cmdext = (void *)(intptr_t)(ext.info->id);\n        SimpleSpiceUpdate *update;\n        g_assert(cmdext->cmd.type == QXL_CMD_DRAW);\n        update = container_of(cmdext, SimpleSpiceUpdate, ext);\n        qemu_spice_destroy_update(&qxl->ssd, update);\n        return;\n    }\n    ring = &qxl->ram->release_ring;\n    SPICE_RING_PROD_ITEM(qxl, ring, item);\n    if (!item) {\n        return;\n    }\n    if (*item == 0) {\n        id = ext.info->id;\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n        *item = id;\n        qxl_ring_set_dirty(qxl);\n    } else {\n        qxl->last_release->next = ext.info->id;\n        qxl_ram_set_dirty(qxl, &qxl->last_release->next);\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n    }\n    qxl->last_release = ext.info;\n    qxl->num_free_res++;\n    trace_qxl_ring_res_put(qxl->id, qxl->num_free_res);\n    qxl_push_free_res(qxl, 0);\n}", "target": 1}
{"code": "static void nf_tables_commit_release(struct nft_trans *trans)\n{\n\tswitch (trans->msg_type) {\n\tcase NFT_MSG_DELTABLE:\n\t\tnf_tables_table_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_DELCHAIN:\n\t\tnf_tables_chain_destroy(trans->ctx.chain);\n\t\tbreak;\n\tcase NFT_MSG_DELRULE:\n\t\tnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELSET:\n\t\tnft_set_destroy(nft_trans_set(trans));\n\t\tbreak;\n\t}\n\tkfree(trans);\n}", "target": 0}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct VhostUserMsg *msg)\n{\n\tuint16_t vring_idx;\n\tswitch (msg->request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = msg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = msg->payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = msg->payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid vring index: %u\\n\", vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": "int OutputValueSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    cmsPsSamplerCargo* sc = (cmsPsSamplerCargo*) Cargo;\n    cmsUInt32Number i;\n    if (sc -> FixWhite) {\n        if (In[0] == 0xFFFF) {  \n            if ((In[1] >= 0x7800 && In[1] <= 0x8800) &&\n                (In[2] >= 0x7800 && In[2] <= 0x8800)) {\n                cmsUInt16Number* Black;\n                cmsUInt16Number* White;\n                cmsUInt32Number nOutputs;\n                if (!_cmsEndPointsBySpace(sc ->ColorSpace, &White, &Black, &nOutputs))\n                        return 0;\n                for (i=0; i < nOutputs; i++)\n                        Out[i] = White[i];\n            }\n        }\n    }\n    if (In[0] != sc ->FirstComponent) {\n            if (sc ->FirstComponent != -1) {\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n                    sc ->SecondComponent = -1;\n                    _cmsIOPrintf(sc ->m, sc ->PostMaj);\n            }\n            _cmsPSActualColumn = 0;\n            _cmsIOPrintf(sc ->m, sc ->PreMaj);\n            sc ->FirstComponent = In[0];\n    }\n      if (In[1] != sc ->SecondComponent) {\n            if (sc ->SecondComponent != -1) {\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n            }\n            _cmsIOPrintf(sc ->m, sc ->PreMin);\n            sc ->SecondComponent = In[1];\n    }\n      for (i=0; i < sc -> Pipeline ->Params->nOutputs; i++) {\n          cmsUInt16Number wWordOut = Out[i];\n          cmsUInt8Number wByteOut;           \n          wByteOut = Word2Byte(wWordOut);\n          WriteByte(sc -> m, wByteOut);\n      }\n      return 1;\n}", "target": 0}
{"code": "void SVGDocumentExtensions::reportWarning(const String& message)\n{\n    reportMessage(m_document, WarningMessageLevel, \"Warning: \" + message);\n}", "target": 0}
{"code": "static inline bool is_flush_request(struct request *rq,\n\t\tstruct blk_flush_queue *fq, unsigned int tag)\n{\n\treturn ((rq->cmd_flags & REQ_FLUSH_SEQ) &&\n\t\t\tfq->flush_rq->tag == tag);\n}", "target": 1}
{"code": "xfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\tuint32_t\t\tlen,\n\tuint32_t\t\tflags)\n{\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= XFS_I(inode),\n\t\t.attr_filter\t= xfs_attr_filter(flags),\n\t\t.attr_flags\t= xfs_attr_flags(flags),\n\t\t.name\t\t= name,\n\t\t.namelen\t= strlen(name),\n\t};\n\tint\t\t\terror;\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (ubuf) {\n\t\tif (len > XFS_XATTR_SIZE_MAX)\n\t\t\treturn -EINVAL;\n\t\targs.value = memdup_user(ubuf, len);\n\t\tif (IS_ERR(args.value))\n\t\t\treturn PTR_ERR(args.value);\n\t\targs.valuelen = len;\n\t}\n\terror = xfs_attr_set(&args);\n\tif (!error && (flags & XFS_IOC_ATTR_ROOT))\n\t\txfs_forget_acl(inode, name);\n\tkfree(args.value);\n\treturn error;\n}", "target": 0}
{"code": "    Classifier (const char *&ptr, int size)\n    {\n        if (size <= 0) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        {\n            char suffix[Name::SIZE+1];\n            memset (suffix, 0, Name::SIZE+1);\n            Xdr::read<CharPtrIO> (ptr, std::min(size, Name::SIZE-1), suffix);\n            _suffix = std::string(suffix);\n        }\n        if (static_cast<size_t>(size) < _suffix.length() + 1 + 2*Xdr::size<char>()) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        char value;\n        Xdr::read<CharPtrIO> (ptr, value);\n        _cscIdx = (int)(value >> 4) - 1;\n        if (_cscIdx < -1 || _cscIdx >= 3) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt cscIdx rule).\");\n        _scheme = (CompressorScheme)((value >> 2) & 3);\n        if (_scheme < 0 || _scheme >= NUM_COMPRESSOR_SCHEMES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt scheme rule).\");\n        _caseInsensitive = (value & 1 ? true : false);\n        Xdr::read<CharPtrIO> (ptr, value);\n        if (value < 0 || value >= NUM_PIXELTYPES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt rule).\");\n        _type = (PixelType)value;\n    }", "target": 0}
{"code": "static int qrtr_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\tsize_t size, int flags)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, msg->msg_name);\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tint copied, rc;\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\trelease_sock(sk);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb) {\n\t\trelease_sock(sk);\n\t\treturn rc;\n\t}\n\tcb = (struct qrtr_cb *)skb->cb;\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\trc = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = copied;\n\tif (addr) {\n\t\taddr->sq_family = AF_QIPCRTR;\n\t\taddr->sq_node = cb->src_node;\n\t\taddr->sq_port = cb->src_port;\n\t\tmsg->msg_namelen = sizeof(*addr);\n\t}\nout:\n\tif (cb->confirm_rx)\n\t\tqrtr_send_resume_tx(cb);\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "static void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\tpvclock_update_vm_gtod_copy(kvm);\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}", "target": 0}
{"code": "GF_Err mfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, mfra_on_child_box);\n}", "target": 0}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n    SSLLogErrors(action, ret, err, len, ssock);\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}", "target": 1}
{"code": "static const char *escape_identifier(const char *identifier)\n{\n\tsize_t pos = strcspn(identifier, \"./%\");\n\tif (pos < strlen(identifier)) {\n\t\tstring_t *new_id = t_str_new(strlen(identifier));\n\t\tstr_append_data(new_id, identifier, pos);\n\t\tfor (const char *c = identifier+pos; *c != '\\0'; c++) {\n\t\t\tswitch (*c) {\n\t\t\tcase '.':\n\t\t\t\tstr_append(new_id, \"%2e\");\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tstr_append(new_id, \"%2f\");\n\t\t\t\tbreak;\n\t\t\tcase '%':\n\t\t\t\tstr_append(new_id, \"%25\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstr_append_c(new_id, *c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn str_c(new_id);\n\t}\n\treturn identifier;\n}", "target": 1}
{"code": "fetch_alt_indirect_string (dwarf_vma offset)\n{\n  separate_info * i;\n  if (! do_follow_links)\n    return \"\";\n  if (first_separate_info == NULL)\n    return _(\"<no links available>\");\n  for (i = first_separate_info; i != NULL; i = i->next)\n    {\n      struct dwarf_section * section;\n      const char *           ret;\n      if (! load_debug_section (separate_debug_str, i->handle))\n\tcontinue;\n      section = &debug_displays [separate_debug_str].section;\n      if (section->start == NULL)\n\tcontinue;\n      if (offset >= section->size)\n\tcontinue;\n      ret = (const char *) (section->start + offset);\n      if (strnlen ((const char *) ret, section->size - offset)\n\t  == section->size - offset)\n\treturn _(\"<no NUL byte at end of alt .debug_str section>\");\n      return ret;\n    }\n  warn (_(\"DW_FORM_GNU_strp_alt offset (%s) too big or no string sections available\\n\"),\n\tdwarf_vmatoa (\"x\", offset));\n  return _(\"<offset is too big>\");\n}", "target": 0}
{"code": "\t\tvoid CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}", "target": 1}
{"code": "static int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tif (!options)\n\t\treturn 1;\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpid->pid_gid = make_kgid(current_user_ns(), option);\n\t\t\tbreak;\n\t\tcase Opt_hidepid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > 2) {\n\t\t\t\tpr_err(\"proc: hidepid value must be between 0 and 2.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpid->hide_pid = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static void ncq_err(NCQTransferState *ncq_tfs)\n{\n    IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];\n     ide_state->error = ABRT_ERR;\n     ide_state->status = READY_STAT | ERR_STAT;\n     ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);\n    ncq_tfs->used = 0;\n }", "target": 0}
{"code": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}", "target": 1}
{"code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\t\tif (net != c_net || !tc->t_sock)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}", "target": 1}
{"code": "ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)\n{\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tzend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];\n\tobj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);;\n\tobj_bucket->destructor_called = 1;\n}", "target": 1}
{"code": "static int seed_from_urandom(uint32_t *seed) {\n    char data[sizeof(uint32_t)];\n    int ok;\n#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n    int urandom;\n    urandom = open(\"/dev/urandom\", O_RDONLY);\n    if (urandom == -1)\n        return 1;\n    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n    close(urandom);\n#else\n    FILE *urandom;\n    urandom = fopen(\"/dev/urandom\", \"rb\");\n    if (!urandom)\n        return 1;\n    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n    fclose(urandom);\n#endif\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32(data);\n    return 0;\n}", "target": 0}
{"code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n\tchar *ptr;\n\tint err;\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n\tif (!file)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\tkfree(file);\n\treturn err;\n}", "target": 1}
{"code": "static void move_huge_pte(struct vm_area_struct *vma, unsigned long old_addr,\n\t\t\t  unsigned long new_addr, pte_t *src_pte)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *dst_pte, pte;\n\tspinlock_t *src_ptl, *dst_ptl;\n\tdst_pte = huge_pte_offset(mm, new_addr, huge_page_size(h));\n\tdst_ptl = huge_pte_lock(h, mm, dst_pte);\n\tsrc_ptl = huge_pte_lockptr(h, mm, src_pte);\n\tif (src_ptl != dst_ptl)\n\t\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\tpte = huge_ptep_get_and_clear(mm, old_addr, src_pte);\n\tset_huge_pte_at(mm, new_addr, dst_pte, pte);\n\tif (src_ptl != dst_ptl)\n\t\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\n}", "target": 0}
{"code": "static inline MagickOffsetType WritePixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,const unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n  ssize_t\n    count;\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n    count=write(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pwrite(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}", "target": 0}
{"code": "static bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {\n\tbool phdr_found = false;\n\tint i;\n#if R_BIN_ELF64\n\tconst bool is_elf64 = true;\n#else\n\tconst bool is_elf64 = false;\n#endif\n\tut64 phnum = Elf_(r_bin_elf_get_phnum) (bin);\n\tfor (i = 0; i < phnum; i++) {\n\t\tut8 phdr[sizeof (Elf_(Phdr))] = {0};\n\t\tint j = 0;\n\t\tconst size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));\n\t\tint len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_ERROR (\"read (phdr)\");\n\t\t\tR_FREE (bin->phdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->phdr[i].p_type = READ32 (phdr, j);\n\t\tif (bin->phdr[i].p_type == PT_PHDR) {\n\t\t\tphdr_found = true;\n\t\t}\n\t\tif (is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_offset = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_vaddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_paddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_filesz = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_memsz = R_BIN_ELF_READWORD (phdr, j);\n\t\tif (!is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_align = R_BIN_ELF_READWORD (phdr, j);\n\t}\n\tif (linux_kernel_hack && phdr_found) {\n\t\tut64 load_addr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\tbin->ehdr.e_phoff = Elf_(r_bin_elf_v2p) (bin, load_addr + bin->ehdr.e_phoff);\n\t\treturn read_phdr (bin, false);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}", "target": 1}
{"code": "size_t TensorSliceWriter::MaxBytesPerElement(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      LOG(FATAL) << \"MaxBytesPerElement not implemented for dtype: \" << dt;\n  }\n  return 0;\n}", "target": 1}
{"code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 1}
{"code": "krb5_encode_histkey(osa_princ_ent_rec *princ_ent)\n{\n    unsigned int i;\n    krb5_error_code err = 0;\n    struct berval **ret = NULL;\n    if (princ_ent->old_key_len <= 0)\n        return NULL;\n    ret = k5calloc(princ_ent->old_key_len + 1, sizeof(struct berval *), &err);\n    if (ret == NULL)\n        goto cleanup;\n    for (i = 0; i < princ_ent->old_key_len; i++) {\n        if (princ_ent->old_keys[i].n_key_data <= 0) {\n            err = EINVAL;\n            goto cleanup;\n        }\n        err = encode_keys(princ_ent->old_keys[i].key_data,\n                          princ_ent->old_keys[i].n_key_data,\n                          princ_ent->admin_history_kvno, &ret[i]);\n        if (err)\n            goto cleanup;\n    }\n    ret[princ_ent->old_key_len] = NULL;\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "    inline char lowercase(const char x) {\n      return (char)((x<'A'||x>'Z')?x:x - 'A' + 'a');", "target": 0}
{"code": "void mvcg_box_del(GF_Box *s)\n{\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}", "target": 0}
{"code": "float ewk_view_device_pixel_ratio_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, -1.0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, -1.0);\n    return priv->settings.devicePixelRatio;\n}", "target": 0}
{"code": "aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\tif (bytesread < dword)\n\t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n\tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n\t\tfree (psf->channel_map) ;\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\treturn 0 ;\n} ", "target": 1}
{"code": "TIFFWriteDirectoryTagCheckedLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value)\n{\n\tuint64 m;\n\tassert(sizeof(uint64)==8);\n\tif( !(tif->tif_flags&TIFF_BIGTIFF) ) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\"TIFFWriteDirectoryTagCheckedLong8\",\"LONG8 not allowed for ClassicTIFF\");\n\t\treturn(0);\n\t}\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong8(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG8,1,8,&m));\n}", "target": 0}
{"code": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}", "target": 1}
{"code": "device_linux_md_check_authorized_cb (Daemon *daemon,\n                                     Device *device,\n                                     DBusGMethodInvocation *context,\n                                     const gchar *action_id,\n                                     guint num_user_data,\n                                     gpointer *user_data_elements)\n{\n  gchar **options = user_data_elements[0];\n  gchar *filename;\n  int n, m;\n  char *argv[128];\n  const gchar *job_name;\n  filename = NULL;\n  if (!device->priv->device_is_linux_md)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not a Linux md drive\");\n      goto out;\n    }\n  if (g_strcmp0 (device->priv->linux_md_sync_action, \"idle\") != 0)\n    {\n      throw_error (context, ERROR_FAILED, \"Array is not idle\");\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"udisks-helper-linux-md-check\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = device->priv->native_path;\n  for (m = 0; options[m] != NULL; m++)\n    {\n      if (n >= (int) sizeof(argv) - 1)\n        {\n          throw_error (context, ERROR_FAILED, \"Too many options\");\n          goto out;\n        }\n      argv[n++] = (char *) options[m];\n    }\n  argv[n++] = NULL;\n  job_name = \"LinuxMdCheck\";\n  for (n = 0; options != NULL && options[n] != NULL; n++)\n    if (strcmp (options[n], \"repair\") == 0)\n      job_name = \"LinuxMdRepair\";\n  if (!job_new (context, job_name, TRUE, device, argv, NULL, linux_md_check_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "fbCombineOutU (CARD32 *dest, const CARD32 *src, int width)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32 s = READ(src + i);\n        CARD32 a = Alpha(~READ(dest + i));\n        FbByteMul(s, a);\n        WRITE(dest + i, s);\n    }\n}", "target": 0}
{"code": "void acpi_os_unmap_generic_address(struct acpi_generic_address *gas)\n{\n\tu64 addr;\n\tstruct acpi_ioremap *map;\n\tif (gas->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\treturn;\n\tmemcpy(&addr, &gas->address, sizeof(addr));\n\tif (!addr || !gas->bit_width)\n\t\treturn;\n\tmutex_lock(&acpi_ioremap_lock);\n\tmap = acpi_map_lookup(addr, gas->bit_width / 8);\n\tif (!map) {\n\t\tmutex_unlock(&acpi_ioremap_lock);\n\t\treturn;\n\t}\n\tacpi_os_drop_map_ref(map);\n\tmutex_unlock(&acpi_ioremap_lock);\n\tacpi_os_map_cleanup(map);\n}", "target": 0}
{"code": "SMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_flush_req *req;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint rc = 0;\n\tint flags = 0;\n\tunsigned int total_len;\n\tcifs_dbg(FYI, \"Flush\\n\");\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\trc = smb2_plain_req_init(SMB2_FLUSH, tcon, (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\t\ttrace_smb3_flush_err(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t     rc);\n\t}\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 0}
{"code": "void InstanceKlass::set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS) {\n  if (!is_shared()) {\n    check_prohibited_package(name(), loader_data, CHECK);\n  }\n  if (is_shared() && _package_entry != NULL) {\n    if (MetaspaceShared::use_full_module_graph() && _package_entry == pkg_entry) {\n      assert(MetaspaceShared::is_in_shared_metaspace(_package_entry), \"must be\");\n      return;\n    } else {\n      _package_entry = NULL;\n    }\n  }\n  TempNewSymbol from_class_name =\n      (pkg_entry != NULL) ? NULL : ClassLoader::package_from_class_name(name());\n  Symbol* pkg_name;\n  if (pkg_entry != NULL) {\n    pkg_name = pkg_entry->name();\n  } else {\n    pkg_name = from_class_name;\n  }\n  if (pkg_name != NULL && loader_data != NULL) {\n    _package_entry = pkg_entry != NULL ? pkg_entry : loader_data->packages()->lookup_only(pkg_name);\n    if (_package_entry == NULL) {\n      if (!ModuleEntryTable::javabase_defined()) {\n        assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME \" module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n      } else {\n        assert(loader_data->unnamed_module() != NULL, \"unnamed module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name,\n                                                         loader_data->unnamed_module());\n      }\n      DEBUG_ONLY(ResourceMark rm(THREAD));\n      assert(_package_entry != NULL, \"Package entry for class %s not found, loader %s\",\n             name()->as_C_string(), loader_data->loader_name_and_id());\n    }\n    if (log_is_enabled(Debug, module)) {\n      ResourceMark rm(THREAD);\n      ModuleEntry* m = _package_entry->module();\n      log_trace(module)(\"Setting package: class: %s, package: %s, loader: %s, module: %s\",\n                        external_name(),\n                        pkg_name->as_C_string(),\n                        loader_data->loader_name_and_id(),\n                        (m->is_named() ? m->name()->as_C_string() : UNNAMED_MODULE));\n    }\n  } else {\n    ResourceMark rm(THREAD);\n    log_trace(module)(\"Setting package: class: %s, package: unnamed, loader: %s, module: %s\",\n                      external_name(),\n                      (loader_data != NULL) ? loader_data->loader_name_and_id() : \"NULL\",\n                      UNNAMED_MODULE);\n  }\n}", "target": 0}
{"code": "static int x509_info_subject_alt_name( char **buf, size_t *size,\n                                       const mbedtls_x509_sequence *subject_alt_name )\n{\n    size_t i;\n    size_t n = *size;\n    char *p = *buf;\n    const mbedtls_x509_sequence *cur = subject_alt_name;\n    const char *sep = \"\";\n    size_t sep_len = 0;\n    while( cur != NULL )\n    {\n        if( cur->buf.len + sep_len >= n )\n        {\n            *p = '\\0';\n            return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );\n        }\n        n -= cur->buf.len + sep_len;\n        for( i = 0; i < sep_len; i++ )\n            *p++ = sep[i];\n        for( i = 0; i < cur->buf.len; i++ )\n            *p++ = cur->buf.p[i];\n        sep = \", \";\n        sep_len = 2;\n        cur = cur->next;\n    }\n    *p = '\\0';\n    *size = n;\n    *buf = p;\n    return( 0 );\n}", "target": 0}
{"code": "LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  luaC_upvdeccount(L, *up1);\n  *up1 = *up2;\n  (*up1)->refcount++;\n  if (upisopen(*up1)) (*up1)->u.open.touched = 1;\n  luaC_upvalbarrier(L, *up1);\n}", "target": 1}
{"code": "methodHandle LinkResolver::linktime_resolve_interface_method_or_null(\n                                                 const LinkInfo& link_info) {\n  EXCEPTION_MARK;\n  methodHandle method_result = linktime_resolve_interface_method(link_info, THREAD);\n  if (HAS_PENDING_EXCEPTION) {\n    CLEAR_PENDING_EXCEPTION;\n    return methodHandle();\n  } else {\n    return method_result;\n  }\n}", "target": 0}
{"code": "GF_Err gitn_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tptr->size += 2;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->entries[i].name) ptr->size += strlen(ptr->entries[i].name);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void update_attr(struct vc_data *vc)\n{\n\tvc->vc_attr = build_attr(vc, vc->vc_color, vc->vc_intensity,\n\t              vc->vc_blink, vc->vc_underline,\n\t              vc->vc_reverse ^ vc->vc_decscnm, vc->vc_italic);\n\tvc->vc_video_erase_char = (build_attr(vc, vc->vc_color, 1, vc->vc_blink, 0, vc->vc_decscnm, 0) << 8) | ' ';\n}", "target": 0}
{"code": "static zend_bool php_auto_globals_create_request(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *form_variables;\n\tunsigned char _gpc_flags[3] = {0, 0, 0};\n\tchar *p;\n\tALLOC_ZVAL(form_variables);\n\tarray_init(form_variables);\n\tINIT_PZVAL(form_variables);\n\tif (PG(request_order) != NULL) {\n\t\tp = PG(request_order);\n\t} else {\n\t\tp = PG(variables_order);\n\t}\n\tfor (; p && *p; p++) {\n\t\tswitch (*p) {\n\t\t\tcase 'g':\n\t\t\tcase 'G':\n\t\t\t\tif (!_gpc_flags[0]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_GET]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[0] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\tcase 'P':\n\t\t\t\tif (!_gpc_flags[1]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_POST]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[1] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\tif (!_gpc_flags[2]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_COOKIE]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[2] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &form_variables, sizeof(zval *), NULL);\n\treturn 0;\n}", "target": 0}
{"code": "setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n        set_description (client);\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}", "target": 1}
{"code": "compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}", "target": 1}
{"code": "int bio_uncopy_user(struct bio *bio)\n{\n\tstruct bio_map_data *bmd = bio->bi_private;\n\tint ret = 0;\n\tif (!bio_flagged(bio, BIO_NULL_MAPPED)) {\n\t\tif (!current->mm)\n\t\t\tret = -EINTR;\n\t\telse if (bio_data_dir(bio) == READ)\n\t\t\tret = bio_copy_to_iter(bio, bmd->iter);\n\t\tif (bmd->is_our_pages)\n\t\t\tbio_free_pages(bio);\n\t}\n\tkfree(bmd);\n\tbio_put(bio);\n\treturn ret;\n}", "target": 0}
{"code": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\tdown_write(&key->sem);\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}", "target": 1}
{"code": "static void ip6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,\n\t\t\t   int how)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tstruct inet6_dev *idev = rt->rt6i_idev;\n\tstruct net_device *loopback_dev =\n\t\tdev_net(dev)->loopback_dev;\n\tif (dev != loopback_dev) {\n\t\tif (idev && idev->dev == dev) {\n\t\t\tstruct inet6_dev *loopback_idev =\n\t\t\t\tin6_dev_get(loopback_dev);\n\t\t\tif (loopback_idev) {\n\t\t\t\trt->rt6i_idev = loopback_idev;\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}\n\t\t}\n\t\tif (rt->n && rt->n->dev == dev) {\n\t\t\trt->n->dev = loopback_dev;\n\t\t\tdev_hold(loopback_dev);\n\t\t\tdev_put(dev);\n\t\t}\n\t}\n}", "target": 0}
{"code": "rdpsnd_register_drivers(char *options)\n{\n\tstruct audio_driver **reg;\n\treg = &drivers;\n#if defined(RDPSND_ALSA)\n\t*reg = alsa_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_SUN)\n\t*reg = sun_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_OSS)\n\t*reg = oss_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_SGI)\n\t*reg = sgi_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_LIBAO)\n\t*reg = libao_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n\t*reg = NULL;\n}", "target": 0}
{"code": "void ChangeListLoader::UpdateAboutResourceAfterGetAbout(\n    const google_apis::AboutResourceCallback& callback,\n    google_apis::GDataErrorCode status,\n    scoped_ptr<google_apis::AboutResource> about_resource) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!callback.is_null());\n  FileError error = GDataToFileError(status);\n  if (error == FILE_ERROR_OK) {\n    if (cached_about_resource_ &&\n        cached_about_resource_->largest_change_id() >\n        about_resource->largest_change_id()) {\n      LOG(WARNING) << \"Local cached about resource is fresher than server, \"\n                   << \"local = \" << cached_about_resource_->largest_change_id()\n                   << \", server = \" << about_resource->largest_change_id();\n    }\n    cached_about_resource_.reset(\n        new google_apis::AboutResource(*about_resource));\n  }\n  callback.Run(status, about_resource.Pass());\n}", "target": 0}
{"code": "static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)\n{\n\tif ((delegation->type & open_flags) != open_flags)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}", "target": 1}
{"code": "static int create_srq_ring(PCIDevice *pci_dev, PvrdmaRing **ring,\n                           uint64_t pdir_dma, uint32_t max_wr,\n                           uint32_t max_sge, uint32_t nchunks)\n{\n    uint64_t *dir = NULL, *tbl = NULL;\n    PvrdmaRing *r;\n    int rc = -EINVAL;\n    char ring_name[MAX_RING_NAME_SZ];\n    uint32_t wqe_sz;\n    if (!nchunks || nchunks > PVRDMA_MAX_FAST_REG_PAGES) {\n        rdma_error_report(\"Got invalid page count for SRQ ring: %d\",\n                          nchunks);\n        return rc;\n    }\n    dir = rdma_pci_dma_map(pci_dev, pdir_dma, TARGET_PAGE_SIZE);\n    if (!dir) {\n        rdma_error_report(\"Failed to map to SRQ page directory\");\n        goto out;\n    }\n    tbl = rdma_pci_dma_map(pci_dev, dir[0], TARGET_PAGE_SIZE);\n    if (!tbl) {\n        rdma_error_report(\"Failed to map to SRQ page table\");\n        goto out;\n    }\n    r = g_malloc(sizeof(*r));\n    *ring = r;\n    r->ring_state = (PvrdmaRingState *)\n            rdma_pci_dma_map(pci_dev, tbl[0], TARGET_PAGE_SIZE);\n    if (!r->ring_state) {\n        rdma_error_report(\"Failed to map tp SRQ ring state\");\n        goto out_free_ring_mem;\n    }\n    wqe_sz = pow2ceil(sizeof(struct pvrdma_rq_wqe_hdr) +\n                      sizeof(struct pvrdma_sge) * max_sge - 1);\n    sprintf(ring_name, \"srq_ring_%\" PRIx64, pdir_dma);\n    rc = pvrdma_ring_init(r, ring_name, pci_dev, &r->ring_state[1], max_wr,\n                          wqe_sz, (dma_addr_t *)&tbl[1], nchunks - 1);\n    if (rc) {\n        goto out_unmap_ring_state;\n    }\n    goto out;\nout_unmap_ring_state:\n    rdma_pci_dma_unmap(pci_dev, r->ring_state, TARGET_PAGE_SIZE);\nout_free_ring_mem:\n    g_free(r);\nout:\n    rdma_pci_dma_unmap(pci_dev, tbl, TARGET_PAGE_SIZE);\n    rdma_pci_dma_unmap(pci_dev, dir, TARGET_PAGE_SIZE);\n    return rc;\n}", "target": 0}
{"code": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!ax)\n\t\treturn;\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\tnetif_stop_queue(ax->dev);\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\tax->tty = NULL;\n\tunregister_netdev(ax->dev);\n\tfree_netdev(ax->dev);\n}", "target": 1}
{"code": "cdf_dump_catalog(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tcdf_catalog_t *cat;\n\tcdf_unpack_catalog(h, sst, &cat);\n\tconst cdf_catalog_entry_t *ce = cat->cat_e;\n\tstruct timespec ts;\n\tchar tbuf[64], sbuf[256];\n\tsize_t i;\n\tprintf(\"Catalog:\\n\");\n\tfor (i = 0; i < cat->cat_num; i++) {\n\t\tcdf_timestamp_to_timespec(&ts, ce[i].ce_timestamp);\n\t\tprintf(\"\\t%d %s %s\", ce[i].ce_num,\n\t\t    cdf_u16tos8(sbuf, ce[i].ce_namlen, ce[i].ce_name),\n\t\t    cdf_ctime(&ts.tv_sec, tbuf));\n\t}\n\tfree(cat);\n}", "target": 0}
{"code": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}", "target": 1}
{"code": "static inline int bitDiff(int value1, int value2)\n{\n  int decBits = 0;\n  if (value2 < value1)\n    while (decBits <= 14 && (value2 << ++decBits) < value1)\n      ;\n  return decBits;\n}", "target": 0}
{"code": "my_pipe_sig_handler(int sig __attribute__((unused)))\n{\n  DBUG_PRINT(\"info\",(\"Hit by signal %d\",sig));\n#ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY\n  (void) signal(SIGPIPE, my_pipe_sig_handler);\n#endif\n}", "target": 0}
{"code": "int lowmem_reserve_ratio_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tproc_dointvec_minmax(table, write, buffer, length, ppos);\n\tsetup_per_zone_lowmem_reserve();\n\treturn 0;\n}", "target": 0}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "GF_Err text_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\t\t\t\n\tgf_bs_write_u32(bs, ptr->textJustification);\t\n\tgf_bs_write_data(bs, ptr->background_color, 6);\t\n\tgpp_write_box(bs, &ptr->default_box);\t\t\t\n\tgf_bs_write_data(bs, ptr->reserved1, 8);\t\t\n\tgf_bs_write_u16(bs, ptr->fontNumber);\t\t\t\n\tgf_bs_write_u16(bs, ptr->fontFace);\t\t\t\t\n\tgf_bs_write_u8(bs, ptr->reserved2);\t\t\t\t\n\tgf_bs_write_u16(bs, ptr->reserved3);\t\t\t\n\tgf_bs_write_data(bs, ptr->foreground_color, 6);\t\n\tif (ptr->textName && (pSize = (u16) strlen(ptr->textName))) {\n\t\tgf_bs_write_u8(bs, pSize);\t\t\t\t\t\n\t\tgf_bs_write_data(bs, ptr->textName, pSize);\t\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void setup_DMA(void)\n{\n\tunsigned long f;\n\tif (raw_cmd->length == 0) {\n\t\tint i;\n\t\tpr_info(\"zero dma transfer size:\");\n\t\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\t\tpr_cont(\"%x,\", raw_cmd->cmd[i]);\n\t\tpr_cont(\"\\n\");\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tif (((unsigned long)raw_cmd->kernel_data) % 512) {\n\t\tpr_info(\"non aligned address: %p\\n\", raw_cmd->kernel_data);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n#ifdef fd_dma_setup\n\tif (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,\n\t\t\t (raw_cmd->flags & FD_RAW_READ) ?\n\t\t\t DMA_MODE_READ : DMA_MODE_WRITE, FDCS->address) < 0) {\n\t\trelease_dma_lock(f);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\trelease_dma_lock(f);\n#else\n\tfd_clear_dma_ff();\n\tfd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);\n\tfd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ?\n\t\t\tDMA_MODE_READ : DMA_MODE_WRITE);\n\tfd_set_dma_addr(raw_cmd->kernel_data);\n\tfd_set_dma_count(raw_cmd->length);\n\tvirtual_dma_port = FDCS->address;\n\tfd_enable_dma();\n\trelease_dma_lock(f);\n#endif\n}", "target": 0}
{"code": "static inline void sctp_ulpq_store_reasm(struct sctp_ulpq *ulpq,\n\t\t\t\t\t struct sctp_ulpevent *event)\n{\n\tstruct sk_buff *pos;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 tsn, ctsn;\n\ttsn = event->tsn;\n\tpos = skb_peek_tail(&ulpq->reasm);\n\tif (!pos) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\tcevent = sctp_skb2event(pos);\n\tctsn = cevent->tsn;\n\tif (TSN_lt(ctsn, tsn)) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\t\tif (TSN_lt(tsn, ctsn))\n\t\t\tbreak;\n\t}\n\t__skb_insert(sctp_event2skb(event), pos->prev, pos, &ulpq->reasm);\n}", "target": 0}
{"code": "cleanup_bmc_device(struct kref *ref)\n{\n\tstruct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);\n\tschedule_work(&bmc->remove_work);\n}", "target": 0}
{"code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void record_recent_object(struct object *obj,\n\t\t\t\t struct strbuf *path,\n\t\t\t\t const char *last,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}", "target": 1}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 1}
{"code": "int main_configure(char *arg1, char *arg2) {\n    int cmdline_status;\n    cmdline_status=options_cmdline(arg1, arg2);\n    if(cmdline_status) \n        return cmdline_status;\n    options_apply();\n    str_canary_init(); \n    log_open(SINK_SYSLOG);\n    if(bind_ports())\n        return 1;\n#ifdef HAVE_CHROOT\n    if(change_root())\n        return 1;\n#endif \n    if(drop_privileges(1))\n        return 1;\n    if(log_open(SINK_OUTFILE))\n        return 1;\n#ifndef USE_FORK\n    num_clients=0; \n#endif\n    log_flush(LOG_MODE_CONFIGURED);\n    return 0;\n}", "target": 1}
{"code": "get_text_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = read_pbm_integer(cinfo, infile, maxval);\n      JSAMPLE g = read_pbm_integer(cinfo, infile, maxval);\n      JSAMPLE b = read_pbm_integer(cinfo, infile, maxval);\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      JSAMPLE g = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      JSAMPLE b = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "int __nla_parse(struct nlattr **tb, int maxtype,\n\t\tconst struct nlattr *head, int len,\n\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, tb);\n}", "target": 1}
{"code": "  bool IsBelowFrame(JavaScriptFrame* frame) {\n    return (c_entry_fp_ == 0) || (c_entry_fp_ > frame->sp());\n  }", "target": 0}
{"code": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}", "target": 1}
{"code": "void Rectangle(double x,double y,double w,double h) {\n    outpos += sprintf(outpos,\"\\n %12.3f %12.3f %12.3f %12.3f re\",x,y,w,h);\n}", "target": 1}
{"code": "PrintWebViewHelper::PrintPreviewContext::metafile() const {\n  DCHECK(IsRendering());\n  return metafile_.get();\n}", "target": 0}
{"code": "NOEXPORT int init_section(int eof, SERVICE_OPTIONS **section_ptr) {\n    char *errstr;\n#ifndef USE_WIN32\n    (*section_ptr)->option.log_stderr=new_global_options.option.log_stderr;\n#endif \n    if(*section_ptr==&new_service_options) {\n        errstr=parse_global_option(CMD_INITIALIZE, NULL, NULL);\n        if(errstr) {\n            s_log(LOG_ERR, \"Global options: %s\", errstr);\n            return 1;\n        }\n    }\n    if(*section_ptr!=&new_service_options || eof) {\n        if(*section_ptr==&new_service_options)\n            s_log(LOG_INFO, \"Initializing inetd mode configuration\");\n        else\n            s_log(LOG_INFO, \"Initializing service [%s]\",\n                (*section_ptr)->servname);\n        errstr=parse_service_option(CMD_INITIALIZE, section_ptr, NULL, NULL);\n        if(errstr) {\n            if(*section_ptr==&new_service_options)\n                s_log(LOG_ERR, \"Inetd mode: %s\", errstr);\n            else\n                s_log(LOG_ERR, \"Service [%s]: %s\",\n                    (*section_ptr)->servname, errstr);\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 1}
{"code": "GetNumWrongData(const byte * curPtr, const int maxnum)\n{\n    int count = 0;\n    if (1 == maxnum) {\n        return (1);\n    }\n    while (*(curPtr + count) != *(curPtr + count + 1) && maxnum > count) {\n        count++;\n    }\n    return (count);\n}", "target": 1}
{"code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n    return sRet + \"/\";\n}", "target": 1}
{"code": "static void __skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype)\n{\n\tstruct sock_exterr_skb *serr;\n\tint err;\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\tserr->ee.ee_info = tstype;\n\tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n\t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\terr = sock_queue_err_skb(sk, skb);\n\tif (err)\n\t\tkfree_skb(skb);", "target": 1}
{"code": "void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\tkvm_put_guest_xcr0(vcpu);\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\tfpu_restore_checking(&vcpu->arch.guest_fpu);\n\ttrace_kvm_fpu(1);\n}", "target": 0}
{"code": "static bool io_wq_worker_affinity(struct io_worker *worker, void *data)\n{\n\tstruct online_data *od = data;\n\tif (od->online)\n\t\tcpumask_set_cpu(od->cpu, worker->wqe->cpu_mask);\n\telse\n\t\tcpumask_clear_cpu(od->cpu, worker->wqe->cpu_mask);\n\treturn false;\n}", "target": 0}
{"code": "struct extent_map *btrfs_get_chunk_map(struct btrfs_fs_info *fs_info,\n\t\t\t\t       u64 logical, u64 length)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tem_tree = &fs_info->mapping_tree.map_tree;\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, length);\n\tread_unlock(&em_tree->lock);\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"unable to find logical %llu length %llu\",\n\t\t\t   logical, length);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info,\n\t\t\t   \"found a bad mapping, wanted %llu-%llu, found %llu-%llu\",\n\t\t\t   logical, length, em->start, em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\treturn em;\n}", "target": 0}
{"code": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}", "target": 1}
{"code": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tunsigned long cr4;\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  \n\tvmcs_writel(HOST_CR3, read_cr3());  \n\tcr4 = read_cr4();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t\n\tvmx->host_state.vmcs_host_cr4 = cr4;\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  \n#ifdef CONFIG_X86_64\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  \n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  \n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   \n\tvmx->host_idt_base = dt.address;\n\tvmcs_writel(HOST_RIP, vmx_return); \n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   \n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}", "target": 0}
{"code": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\treturn result;\n}", "target": 1}
{"code": "static inline int http_parse_chunk_size(struct http_msg *msg)\n{\n\tconst struct buffer *buf = msg->chn->buf;\n\tconst char *ptr = b_ptr(buf, msg->next);\n\tconst char *ptr_old = ptr;\n\tconst char *end = buf->data + buf->size;\n\tconst char *stop = bi_end(buf);\n\tunsigned int chunk = 0;\n\twhile (1) {\n\t\tint c;\n\t\tif (ptr == stop)\n\t\t\treturn 0;\n\t\tc = hex2i(*ptr);\n\t\tif (c < 0) \n\t\t\tbreak;\n\t\tif (unlikely(++ptr >= end))\n\t\t\tptr = buf->data;\n\t\tif (chunk & 0xF8000000) \n\t\t\tgoto error;\n\t\tchunk = (chunk << 4) + c;\n\t}\n\tif (unlikely(ptr == ptr_old))\n\t\tgoto error;\n\twhile (http_is_spht[(unsigned char)*ptr]) {\n\t\tif (++ptr >= end)\n\t\t\tptr = buf->data;\n\t\tif (unlikely(ptr == stop))\n\t\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\tif (likely(*ptr == '\\r')) {\n\t\t\t\tif (++ptr >= end)\n\t\t\t\t\tptr = buf->data;\n\t\t\t\tif (ptr == stop)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*ptr != '\\n')\n\t\t\t\tgoto error;\n\t\t\tif (++ptr >= end)\n\t\t\t\tptr = buf->data;\n\t\t\tbreak;\n\t\t}\n\t\telse if (*ptr == ';') {\n\t\t\tif (++ptr >= end)\n\t\t\t\tptr = buf->data;\n\t\t\tif (ptr == stop)\n\t\t\t\treturn 0;\n\t\t\twhile (!HTTP_IS_CRLF(*ptr)) {\n\t\t\t\tif (++ptr >= end)\n\t\t\t\t\tptr = buf->data;\n\t\t\t\tif (ptr == stop)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t\tgoto error;\n\t}\n\tif (unlikely(ptr < ptr_old))\n\t\tmsg->sov += buf->size;\n\tmsg->sov += ptr - ptr_old;\n\tmsg->next = buffer_count(buf, buf->p, ptr);\n\tmsg->chunk_len = chunk;\n\tmsg->body_len += chunk;\n\tmsg->msg_state = chunk ? HTTP_MSG_DATA : HTTP_MSG_TRAILERS;\n\treturn 1;\n error:\n\tmsg->err_pos = buffer_count(buf, buf->p, ptr);\n\treturn -1;\n}", "target": 0}
{"code": "bool PrintWebViewHelper::PrintPreviewContext::IsModifiable() {\n  return !PrintingNodeOrPdfFrame(source_frame(), source_node_);\n}", "target": 0}
{"code": "static int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\thwc->state = !(flags & PERF_EF_START);\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\tWARN_ON_ONCE(swhash->online);\n\t\treturn -EINVAL;\n\t}\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\treturn 0;\n}", "target": 1}
{"code": "PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n}", "target": 1}
{"code": "void usbredirparser_caps_set_cap(uint32_t *caps, int cap)\n{\n    caps[cap / 32] |= 1 << (cap % 32);\n}", "target": 0}
{"code": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n}", "target": 1}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[13]) << 32) + X[0]);\n}", "target": 1}
{"code": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n{\n\tstruct nfs_delegation *delegation;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}", "target": 1}
{"code": "struct sock *ax25_get_socket(ax25_address *my_addr, ax25_address *dest_addr,\n\tint type)\n{\n\tstruct sock *sk = NULL;\n\tax25_cb *s;\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk && !ax25cmp(&s->source_addr, my_addr) &&\n\t\t    !ax25cmp(&s->dest_addr, dest_addr) &&\n\t\t    s->sk->sk_type == type) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ax25_list_lock);\n\treturn sk;\n}", "target": 0}
{"code": "char *suhosin_decrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key, char **where TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n    int o_name_len = name_len;\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n\tint l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\ndecrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n            memcpy(*where, name, o_name_len);\n            *where += o_name_len;\n            **where = '='; *where +=1;\n\t        memcpy(*where, value, value_len);\n\t        *where += value_len;\n\t\t\treturn *where;\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto decrypt_return_plain;\n\t\t}\n\t}\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\tvalue_len = php_url_decode(buf2, value_len);\n\td = suhosin_decrypt_string(buf2, value_len, buf, name_len, key, &l, SUHOSIN_G(cookie_checkraddr) TSRMLS_CC);\n    if (d == NULL) {\n        goto skip_cookie;\n    }\n\td_url = php_url_encode(d, l, &l);\n\tefree(d);\n    memcpy(*where, name, o_name_len);\n    *where += o_name_len;\n    **where = '=';*where += 1;\n\tmemcpy(*where, d_url, l);\n\t*where += l;\n\tefree(d_url);\nskip_cookie:\n\tif (buf != buffer) {\n\t\tefree(buf);\n\t}\n\tif (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn *where;\n}", "target": 1}
{"code": "lt_dlinsertsearchdir (const char *before, const char *search_dir)\n{\n  int errors = 0;\n  if (before)\n    {\n      if ((before < user_search_path)\n\t  || (before >= user_search_path + LT_STRLEN (user_search_path)))\n\t{\n\t  LT__SETERROR (INVALID_POSITION);\n\t  return 1;\n\t}\n    }\n  if (search_dir && *search_dir)\n    {\n      if (lt_dlpath_insertdir (&user_search_path,\n\t\t\t       (char *) before, search_dir) != 0)\n\t{\n\t  ++errors;\n\t}\n    }\n  return errors;\n}", "target": 0}
{"code": "xfs_iolock_two_inodes_and_break_layout(\n\tstruct inode\t\t*src,\n\tstruct inode\t\t*dest)\n{\n\tint\t\t\terror;\n\tif (src > dest)\n\t\tswap(src, dest);\nretry:\n\terror = break_layout(src, true);\n\tif (error)\n\t\treturn error;\n\tif (src != dest) {\n\t\terror = break_layout(dest, true);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tinode_lock(src);\n\terror = break_layout(src, false);\n\tif (error) {\n\t\tinode_unlock(src);\n\t\tif (error == -EWOULDBLOCK)\n\t\t\tgoto retry;\n\t\treturn error;\n\t}\n\tif (src == dest)\n\t\treturn 0;\n\tinode_lock_nested(dest, I_MUTEX_NONDIR2);\n\terror = break_layout(dest, false);\n\tif (error) {\n\t\tinode_unlock(src);\n\t\tinode_unlock(dest);\n\t\tif (error == -EWOULDBLOCK)\n\t\t\tgoto retry;\n\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}", "target": 1}
{"code": "static void b43_request_firmware(struct work_struct *work)\n{\n\tstruct b43_wl *wl = container_of(work,\n\t\t\t    struct b43_wl, firmware_load);\n\tstruct b43_wldev *dev = wl->current_dev;\n\tstruct b43_request_fw_context *ctx;\n\tunsigned int i;\n\tint err;\n\tconst char *errmsg;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn;\n\tctx->dev = dev;\n\tctx->req_type = B43_FWTYPE_PROPRIETARY;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; \n\tif (ctx->fatal_failure)\n\t\tgoto out;\n\tctx->req_type = B43_FWTYPE_OPENSOURCE;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; \n\tif(ctx->fatal_failure)\n\t\tgoto out;\n\tfor (i = 0; i < B43_NR_FWTYPES; i++) {\n\t\terrmsg = ctx->errors[i];\n\t\tif (strlen(errmsg))\n\t\t\tb43err(dev->wl, errmsg);\n\t}\n\tb43_print_fw_helptext(dev->wl, 1);\n\tgoto out;\nstart_ieee80211:\n\twl->hw->queues = B43_QOS_QUEUE_NUM;\n\tif (!modparam_qos || dev->fw.opensource)\n\t\twl->hw->queues = 1;\n\terr = ieee80211_register_hw(wl->hw);\n\tif (err)\n\t\tgoto err_one_core_detach;\n\twl->hw_registred = true;\n\tb43_leds_register(wl->current_dev);\n\tgoto out;\nerr_one_core_detach:\n\tb43_one_core_detach(dev->dev);\nout:\n\tkfree(ctx);\n}", "target": 1}
{"code": "virStoragePoolObjBuildTempFilePath(virStoragePoolObj *obj,\n                                   virStorageVolDef *voldef)\n{\n    virStoragePoolDef *def = virStoragePoolObjGetDef(obj);\n    return g_strdup_printf(\"%s/%s.%s.secret.XXXXXX\", driver->stateDir,\n                           def->name, voldef->name);\n}", "target": 0}
{"code": "static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\t__u8 proto;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tstruct xfrm_state *x;\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tproto = x->id.proto;\n\txfrm_state_put(x);\n\tif (IS_ERR(out_skb))\n\t\treturn  PTR_ERR(out_skb);\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GET;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n\treturn 0;\n}", "target": 0}
{"code": "static gboolean printable_str(const char *str)\n{\n    do {\n        if ((unsigned char)(*str) < ' ' || *str == 0x7f)\n            return FALSE;\n        str++;\n    } while (*str);\n    return TRUE;\n}", "target": 1}
{"code": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\titem->data = rdata;\n#ifndef OPENSSL_NO_SCTP\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\treturn(1);\n\t}", "target": 1}
{"code": "void ipmi_unregister_smi(struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_watcher *w;\n\tint intf_num = intf->intf_num, index;\n\tmutex_lock(&ipmi_interfaces_mutex);\n\tintf->intf_num = -1;\n\tintf->in_shutdown = true;\n\tlist_del_rcu(&intf->link);\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\tsynchronize_srcu(&ipmi_interfaces_srcu);\n\tmutex_lock(&smi_watchers_mutex);\n\tlist_for_each_entry(w, &smi_watchers, link)\n\t\tw->smi_gone(intf_num);\n\tmutex_unlock(&smi_watchers_mutex);\n\tindex = srcu_read_lock(&intf->users_srcu);\n\twhile (!list_empty(&intf->users)) {\n\t\tstruct ipmi_user *user =\n\t\t\tcontainer_of(list_next_rcu(&intf->users),\n\t\t\t\t     struct ipmi_user, link);\n\t\t_ipmi_destroy_user(user);\n\t}\n\tsrcu_read_unlock(&intf->users_srcu, index);\n\tif (intf->handlers->shutdown)\n\t\tintf->handlers->shutdown(intf->send_info);\n\tcleanup_smi_msgs(intf);\n\tipmi_bmc_unregister(intf);\n\tcleanup_srcu_struct(&intf->users_srcu);\n\tkref_put(&intf->refcount, intf_free);\n}", "target": 0}
{"code": "njs_json_push_parse_state(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *value)\n{\n    njs_json_state_t  *state;\n    if (njs_slow_path(parse->depth >= NJS_JSON_MAX_DEPTH)) {\n        njs_type_error(vm, \"Nested too deep or a cyclic structure\");\n        return NULL;\n    }\n    state = &parse->states[parse->depth++];\n    state->value = *value;\n    state->index = 0;\n    state->prop = NULL;\n    state->keys = njs_value_own_enumerate(vm, value, NJS_ENUM_KEYS,\n                                          NJS_ENUM_STRING, 0);\n    if (state->keys == NULL) {\n        return NULL;\n    }\n    return state;\n}", "target": 1}
{"code": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\treturn (CHDLC_HDRLEN);\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}", "target": 0}
{"code": "normalizeLines(XML_Char *s)\n{\n  XML_Char *p;\n  for (;; s++) {\n    if (*s == XML_T('\\0'))\n      return;\n    if (*s == 0xD)\n      break;\n  }\n  p = s;\n  do {\n    if (*s == 0xD) {\n      *p++ = 0xA;\n      if (*++s == 0xA)\n        s++;\n    }\n    else\n      *p++ = *s++;\n  } while (*s);\n  *p = XML_T('\\0');\n}", "target": 0}
{"code": "gfp_to_alloc_flags(gfp_t gfp_mask)\n{\n\tunsigned int alloc_flags = ALLOC_WMARK_MIN | ALLOC_CPUSET;\n\tBUILD_BUG_ON(__GFP_HIGH != (__force gfp_t) ALLOC_HIGH);\n\talloc_flags |= (__force int) (gfp_mask & __GFP_HIGH);\n\tif (gfp_mask & __GFP_ATOMIC) {\n\t\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\t\talloc_flags |= ALLOC_HARDER;\n\t\talloc_flags &= ~ALLOC_CPUSET;\n\t} else if (unlikely(rt_task(current)) && !in_interrupt())\n\t\talloc_flags |= ALLOC_HARDER;\n#ifdef CONFIG_CMA\n\tif (gfpflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)\n\t\talloc_flags |= ALLOC_CMA;\n#endif\n\treturn alloc_flags;\n}", "target": 0}
{"code": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; \n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n    rc = (digp && (p == pend)) ? 0 : -1;\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}", "target": 1}
{"code": "void encode(ArgumentEncoder* encoder, CFNumberRef number)\n{\n    CFNumberType numberType = CFNumberGetType(number);\n    Vector<uint8_t> buffer(CFNumberGetByteSize(number));\n    bool result = CFNumberGetValue(number, numberType, buffer.data());\n    ASSERT_UNUSED(result, result);\n    encoder->encodeEnum(numberType);\n    encoder->encodeVariableLengthByteArray(buffer);\n}", "target": 0}
{"code": "static void prepare_attr_stack(const char *path, int dirlen)\n{\n\tstruct attr_stack *elem, *info;\n\tint len;\n\tstruct strbuf pathbuf;\n\tstrbuf_init(&pathbuf, dirlen+2+strlen(GITATTRIBUTES_FILE));\n\tif (!attr_stack)\n\t\tbootstrap_attr_stack();\n\tinfo = attr_stack;\n\tattr_stack = info->prev;\n\twhile (attr_stack && attr_stack->origin) {\n\t\tint namelen = strlen(attr_stack->origin);\n\t\telem = attr_stack;\n\t\tif (namelen <= dirlen &&\n\t\t    !strncmp(elem->origin, path, namelen))\n\t\t\tbreak;\n\t\tdebug_pop(elem);\n\t\tattr_stack = elem->prev;\n\t\tfree_attr_elem(elem);\n\t}\n\tif (!is_bare_repository()) {\n\t\twhile (1) {\n\t\t\tchar *cp;\n\t\t\tlen = strlen(attr_stack->origin);\n\t\t\tif (dirlen <= len)\n\t\t\t\tbreak;\n\t\t\tstrbuf_reset(&pathbuf);\n\t\t\tstrbuf_add(&pathbuf, path, dirlen);\n\t\t\tstrbuf_addch(&pathbuf, '/');\n\t\t\tcp = strchr(pathbuf.buf + len + 1, '/');\n\t\t\tstrcpy(cp + 1, GITATTRIBUTES_FILE);\n\t\t\telem = read_attr(pathbuf.buf, 0);\n\t\t\t*cp = '\\0';\n\t\t\telem->origin = strdup(pathbuf.buf);\n\t\t\telem->prev = attr_stack;\n\t\t\tattr_stack = elem;\n\t\t\tdebug_push(elem);\n\t\t}\n\t}\n\tinfo->prev = attr_stack;\n\tattr_stack = info;\n}", "target": 0}
{"code": "unsigned get_next_char(ASS_Renderer *render_priv, char **str)\n{\n    char *p = *str;\n    unsigned chr;\n    if (*p == '\\t') {\n        ++p;\n        *str = p;\n        return ' ';\n    }\n    if (*p == '\\\\') {\n        if ((p[1] == 'N') || ((p[1] == 'n') &&\n                              (render_priv->state.wrap_style == 2))) {\n            p += 2;\n            *str = p;\n            return '\\n';\n        } else if (p[1] == 'n') {\n            p += 2;\n            *str = p;\n            return ' ';\n        } else if (p[1] == 'h') {\n            p += 2;\n            *str = p;\n            return NBSP;\n        } else if (p[1] == '{') {\n            p += 2;\n            *str = p;\n            return '{';\n        } else if (p[1] == '}') {\n            p += 2;\n            *str = p;\n            return '}';\n        }\n    }\n    chr = ass_utf8_get_char((char **) &p);\n    *str = p;\n    return chr;\n}", "target": 0}
{"code": "static void decode_data(struct sixpack *sp, unsigned char inbyte)\n{\n\tunsigned char *buf;\n\tif (sp->rx_count != 3) {\n\t\tsp->raw_buf[sp->rx_count++] = inbyte;\n\t\treturn;\n\t}\n\tbuf = sp->raw_buf;\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\tbuf[0] | ((buf[1] << 2) & 0xc0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[1] & 0x0f) | ((buf[2] << 2) & 0xf0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[2] & 0x03) | (inbyte << 2);\n\tsp->rx_count = 0;\n}", "target": 1}
{"code": "bool CxImage::Transfer(CxImage &from, bool bTransferFrames )\n{\n\tif (!Destroy())\n\t\treturn false;\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\tpDib = from.pDib;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int collect_syscall(struct task_struct *target, struct syscall_info *info)\n{\n\tstruct pt_regs *regs;\n\tif (!try_get_task_stack(target)) {\n\t\tmemset(info, 0, sizeof(*info));\n\t\tinfo->data.nr = -1;\n\t\treturn 0;\n\t}\n\tregs = task_pt_regs(target);\n\tif (unlikely(!regs)) {\n\t\tput_task_stack(target);\n\t\treturn -EAGAIN;\n\t}\n\tinfo->sp = user_stack_pointer(regs);\n\tinfo->data.instruction_pointer = instruction_pointer(regs);\n\tinfo->data.nr = syscall_get_nr(target, regs);\n\tif (info->data.nr != -1L)\n\t\tsyscall_get_arguments(target, regs,\n\t\t\t\t      (unsigned long *)&info->data.args[0]);\n\tput_task_stack(target);\n\treturn 0;\n}", "target": 1}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "_tiffReadProc(thandle_t hdata, tdata_t buf, tsize_t size) {\n    TIFFSTATE *state = (TIFFSTATE *)hdata;\n    tsize_t to_read;\n    TRACE((\"_tiffReadProc: %d \\n\", (int)size));\n    dump_state(state);\n    to_read = min(size, min(state->size, (tsize_t)state->eof) - (tsize_t)state->loc);\n    TRACE((\"to_read: %d\\n\", (int)to_read));\n    _TIFFmemcpy(buf, (UINT8 *)state->data + state->loc, to_read);\n    state->loc += (toff_t)to_read;\n    TRACE((\"location: %u\\n\", (uint)state->loc));\n    return to_read;\n}", "target": 1}
{"code": "void Item_string::print(String *str, enum_query_type query_type)\n{\n  const bool print_introducer=\n    !(query_type & QT_WITHOUT_INTRODUCERS) && is_cs_specified();\n  if (print_introducer)\n  {\n    str->append('_');\n    str->append(collation.collation->csname);\n  }\n  str->append('\\'');\n  if (query_type & QT_TO_SYSTEM_CHARSET)\n  {\n    if (print_introducer)\n    {\n      ErrConvString tmp(str_value.ptr(), str_value.length(), &my_charset_bin);\n      str->append(tmp.ptr());\n    }\n    else\n    {\n      if (my_charset_same(str_value.charset(), system_charset_info))\n        str_value.print(str); \n      else \n      {\n        THD *thd= current_thd;\n        LEX_STRING utf8_lex_str;\n        thd->convert_string(&utf8_lex_str,\n                            system_charset_info,\n                            str_value.c_ptr_safe(),\n                            str_value.length(),\n                            str_value.charset());\n        String utf8_str(utf8_lex_str.str,\n                        utf8_lex_str.length,\n                        system_charset_info);\n        utf8_str.print(str);\n      }\n    }\n  }\n  else\n  {\n    str_value.print(str);\n  }\n  str->append('\\'');\n}", "target": 0}
{"code": "TEST(QuantizedPoolingOpTest, AveragePoolActivationRelu) {\n  QuantizedPoolingOpModel m(\n      BuiltinOperator_AVERAGE_POOL_2D,\n      {TensorType_UINT8, {1, 2, 4, 1}, -15.9375, 15.9375},\n      2, 2,\n      {TensorType_UINT8, {}, -15.9375, 15.9375}, Padding_VALID, 2, 2,\n      ActivationFunctionType_RELU);\n  m.SetInput({\n      0, -6, 2, 4,   \n      3, 2, -10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({0.0, 0.75})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({128, 134}));\n}", "target": 0}
{"code": "static bool FNAME(gpte_changed)(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct guest_walker *gw, int level)\n{\n\tpt_element_t curr_pte;\n\tgpa_t base_gpa, pte_gpa = gw->pte_gpa[level - 1];\n\tu64 mask;\n\tint r, index;\n\tif (level == PT_PAGE_TABLE_LEVEL) {\n\t\tmask = PTE_PREFETCH_NUM * sizeof(pt_element_t) - 1;\n\t\tbase_gpa = pte_gpa & ~mask;\n\t\tindex = (pte_gpa - base_gpa) / sizeof(pt_element_t);\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, base_gpa,\n\t\t\t\tgw->prefetch_ptes, sizeof(gw->prefetch_ptes));\n\t\tcurr_pte = gw->prefetch_ptes[index];\n\t} else\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, pte_gpa,\n\t\t\t\t  &curr_pte, sizeof(curr_pte));\n\treturn r || curr_pte != gw->ptes[level - 1];\n}", "target": 0}
{"code": "asmlinkage long compat_sys_epoll_pwait(int epfd,\n\t\t\tstruct compat_epoll_event __user *events,\n\t\t\tint maxevents, int timeout,\n\t\t\tconst compat_sigset_t __user *sigmask,\n\t\t\tcompat_size_t sigsetsize)\n{\n\tlong err;\n\tcompat_sigset_t csigmask;\n\tsigset_t ksigmask, sigsaved;\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&csigmask, sigmask, sizeof(csigmask)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&ksigmask, &csigmask);\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n#ifdef CONFIG_HAS_COMPAT_EPOLL_EVENT\n\terr = compat_sys_epoll_wait(epfd, events, maxevents, timeout);\n#else\n\terr = sys_epoll_wait(epfd, events, maxevents, timeout);\n#endif\n\tif (sigmask) {\n\t\tif (err == -EINTR) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t       sizeof(sigsaved));\n\t\t\tset_thread_flag(TIF_RESTORE_SIGMASK);\n\t\t} else\n\t\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "void RemoteFsDevice::setup()\n{\n    details.load(details.name);\n    configured=details.configured;\n    if (isConnected()) {\n        readOpts(settingsFileName(), opts, true);\n    }\n    load();\n}", "target": 0}
{"code": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\tdelete[] audioDriverName;\n\tdelete listener;\n}", "target": 1}
{"code": "static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&c->object, NULL, NULL, data);\n}", "target": 1}
{"code": "void bitmap_cache_register_callbacks(rdpUpdate* update)\n{\n\trdpCache* cache = update->context->cache;\n\tcache->bitmap->MemBlt = update->primary->MemBlt;\n\tcache->bitmap->Mem3Blt = update->primary->Mem3Blt;\n\tupdate->primary->MemBlt = update_gdi_memblt;\n\tupdate->primary->Mem3Blt = update_gdi_mem3blt;\n\tupdate->secondary->CacheBitmap = update_gdi_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_gdi_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_gdi_cache_bitmap_v3;\n\tupdate->BitmapUpdate = gdi_bitmap_update;\n}", "target": 0}
{"code": "psf_d2i_clip_array (const double *src, int *dest, int count, int normalize)\n{\tdouble\t\t\tnormfact, scaled_value ;\n\tnormfact = normalize ? (8.0 * 0x10000000) : 1.0 ;\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))\n\t\t{\tdest [count] = 0x7FFFFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))\n\t\t{\tdest [count] = 0x80000000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\treturn ;\n} ", "target": 0}
{"code": "int SafeMulDims(const matvar_t *matvar, size_t* nelems)\n{\n    int i;\n    for ( i = 0; i < matvar->rank; i++ ) {\n        if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) {\n            *nelems = 0;\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 1}
{"code": "asmlinkage void __sched schedule(void)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq *rq;\n\tint cpu;\nneed_resched:\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\trcu_note_context_switch(cpu);\n\tprev = rq->curr;\n\trelease_kernel_lock(prev);\nneed_resched_nonpreemptible:\n\tschedule_debug(prev);\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\traw_spin_lock_irq(&rq->lock);\n\tclear_tsk_need_resched(prev);\n\tswitch_count = &prev->nivcsw;\n\tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup);\n\t\t\t}\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\tpre_schedule(rq, prev);\n\tif (unlikely(!rq->nr_running))\n\t\tidle_balance(cpu, rq);\n\tput_prev_task(rq, prev);\n\tnext = pick_next_task(rq);\n\tif (likely(prev != next)) {\n\t\tsched_info_switch(prev, next);\n\t\tperf_event_task_sched_out(prev, next);\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t++*switch_count;\n\t\tcontext_switch(rq, prev, next); \n\t\tcpu = smp_processor_id();\n\t\trq = cpu_rq(cpu);\n\t} else\n\t\traw_spin_unlock_irq(&rq->lock);\n\tpost_schedule(rq);\n\tif (unlikely(reacquire_kernel_lock(prev)))\n\t\tgoto need_resched_nonpreemptible;\n\tpreempt_enable_no_resched();\n\tif (need_resched())\n\t\tgoto need_resched;\n}", "target": 1}
{"code": "waitfd(int fd, int *timeoutp, short events)\n{\n\tstruct pollfd pfd;\n\tstruct timeval t_start;\n\tint oerrno, r;\n\tpfd.fd = fd;\n\tpfd.events = events;\n\tfor (; *timeoutp >= 0;) {\n\t\tmonotime_tv(&t_start);\n\t\tr = poll(&pfd, 1, *timeoutp);\n\t\toerrno = errno;\n\t\tms_subtract_diff(&t_start, timeoutp);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN && errno != EINTR)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\terrno = ETIMEDOUT;\n\treturn -1;\n}", "target": 0}
{"code": "static int32_t virtio_net_rsc_coalesce4(VirtioNetRscChain *chain,\n                                        VirtioNetRscSeg *seg,\n                                        const uint8_t *buf, size_t size,\n                                        VirtioNetRscUnit *unit)\n{\n    struct ip_header *ip1, *ip2;\n    ip1 = (struct ip_header *)(unit->ip);\n    ip2 = (struct ip_header *)(seg->unit.ip);\n    if ((ip1->ip_src ^ ip2->ip_src) || (ip1->ip_dst ^ ip2->ip_dst)\n        || (unit->tcp->th_sport ^ seg->unit.tcp->th_sport)\n        || (unit->tcp->th_dport ^ seg->unit.tcp->th_dport)) {\n        chain->stat.no_match++;\n        return RSC_NO_MATCH;\n    }\n    return virtio_net_rsc_coalesce_data(chain, seg, buf, unit);\n}", "target": 0}
{"code": "static u_int mp_dss_len(const  struct mp_dss *m, int csum)\n{\n        u_int len;\n        len = 4;\n        if (m->flags & MP_DSS_A) {\n                len += (m->flags & MP_DSS_a) ? 8 : 4;\n        }\n        if (m->flags & MP_DSS_M) {\n                len += (m->flags & MP_DSS_m) ? 14 : 10;\n                if (csum)\n                        len += 2;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "static void __mcheck_cpu_clear_vendor(struct cpuinfo_x86 *c)\n{\n\tswitch (c->x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\tmce_intel_feature_clear(c);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "mm_answer_rsa_challenge(int socket, Buffer *m)\n{\n\tKey *key = NULL;\n\tu_char *blob;\n\tu_int blen;\n\tdebug3(\"%s entering\", __func__);\n\tif (!authctxt->valid)\n\t\tfatal(\"%s: authctxt not valid\", __func__);\n\tblob = buffer_get_string(m, &blen);\n\tif (!monitor_allowed_key(blob, blen))\n\t\tfatal(\"%s: bad key, not previously allowed\", __func__);\n\tif (key_blobtype != MM_RSAUSERKEY && key_blobtype != MM_RSAHOSTKEY)\n\t\tfatal(\"%s: key type mismatch\", __func__);\n\tif ((key = key_from_blob(blob, blen)) == NULL)\n\t\tfatal(\"%s: received bad key\", __func__);\n\tif (ssh1_challenge)\n\t\tBN_clear_free(ssh1_challenge);\n\tssh1_challenge = auth_rsa_generate_challenge(key);\n\tbuffer_clear(m);\n\tbuffer_put_bignum2(m, ssh1_challenge);\n\tdebug3(\"%s sending reply\", __func__);\n\tmm_request_send(socket, MONITOR_ANS_RSACHALLENGE, m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_RSARESPONSE, 1);\n\txfree(blob);\n\tkey_free(key);\n\treturn (0);\n}", "target": 0}
{"code": "  const std::string& get_id() const {\n    ceph_assert(t != Wildcard && t != Tenant);\n    return u.id;\n  }", "target": 1}
{"code": "    void resize (std::size_t new_size_) { _buf_size = new_size_; }", "target": 1}
{"code": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n\t    data[1] = new >> 4;\n\t} else {\n\t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n\t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n\t    else\n\t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}", "target": 1}
{"code": "cr_input_read_byte (CRInput * a_this, guchar * a_byte)\n{\n        g_return_val_if_fail (a_this && PRIVATE (a_this)\n                              && a_byte, CR_BAD_PARAM_ERROR);\n        g_return_val_if_fail (PRIVATE (a_this)->next_byte_index <=\n                              PRIVATE (a_this)->nb_bytes, CR_BAD_PARAM_ERROR);\n        if (PRIVATE (a_this)->end_of_input == TRUE)\n                return CR_END_OF_INPUT_ERROR;\n        *a_byte = PRIVATE (a_this)->in_buf[PRIVATE (a_this)->next_byte_index];\n        if (PRIVATE (a_this)->nb_bytes -\n            PRIVATE (a_this)->next_byte_index < 2) {\n                PRIVATE (a_this)->end_of_input = TRUE;\n        } else {\n                PRIVATE (a_this)->next_byte_index++;\n        }\n        return CR_OK;\n}", "target": 1}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif \n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif \n\t\tcap->device_caps = cap->capabilities = capabilities;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}", "target": 1}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "void FrameLoader::checkIfDisplayInsecureContent(SecurityOrigin* context, const KURL& url)\n{\n    if (!isMixedContent(context, url))\n        return;\n    String message = String::format(\"The page at %s displayed insecure content from %s.\\n\",\n        m_URL.string().utf8().data(), url.string().utf8().data());\n    m_frame->domWindow()->console()->addMessage(HTMLMessageSource, LogMessageType, WarningMessageLevel, message, 1, String());\n    m_client->didDisplayInsecureContent();\n}", "target": 0}
{"code": "void CallInfo::print() {\n  ResourceMark rm;\n  const char* kindstr;\n  switch (_call_kind) {\n  case direct_call: kindstr = \"direct\";  break;\n  case vtable_call: kindstr = \"vtable\";  break;\n  case itable_call: kindstr = \"itable\";  break;\n  default         : kindstr = \"unknown\"; break;\n  }\n  tty->print_cr(\"Call %s@%d %s\", kindstr, _call_index,\n                _resolved_method.is_null() ? \"(none)\" : _resolved_method->name_and_sig_as_C_string());\n}", "target": 0}
{"code": "void hid_reset(HIDState *hs)\n{\n    switch (hs->kind) {\n    case HID_KEYBOARD:\n        memset(hs->kbd.keycodes, 0, sizeof(hs->kbd.keycodes));\n        memset(hs->kbd.key, 0, sizeof(hs->kbd.key));\n        hs->kbd.keys = 0;\n        break;\n    case HID_MOUSE:\n    case HID_TABLET:\n        memset(hs->ptr.queue, 0, sizeof(hs->ptr.queue));\n        break;\n    }\n    hs->head = 0;\n    hs->n = 0;\n    hs->protocol = 1;\n    hs->idle = 0;\n    hs->idle_pending = false;\n    hid_del_idle_timer(hs);\n}", "target": 1}
{"code": "static void close_all_connections(struct Curl_multi *multi)\n{\n  struct connectdata *conn;\n  conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  while(conn) {\n    SIGPIPE_VARIABLE(pipe_st);\n    conn->data = multi->closure_handle;\n    sigpipe_ignore(conn->data, &pipe_st);\n    (void)Curl_disconnect(conn, FALSE);\n    sigpipe_restore(&pipe_st);\n    conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  }\n}", "target": 1}
{"code": "gopherCachable(const HttpRequest * req)\n{\n    int cachable = 1;\n    char type_id;\n    gopher_request_parse(req,\n                         &type_id,\n                         nullptr);\n    switch (type_id) {\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        cachable = 0;\n        break;\n    default:\n        cachable = 1;\n    }\n    return cachable;\n}", "target": 1}
{"code": "void mce_setup(struct mce *m)\n{\n\tmemset(m, 0, sizeof(struct mce));\n\tm->cpu = m->extcpu = smp_processor_id();\n\tm->time = get_seconds();\n\tm->cpuvendor = boot_cpu_data.x86_vendor;\n\tm->cpuid = cpuid_eax(1);\n\tm->socketid = cpu_data(m->extcpu).phys_proc_id;\n\tm->apicid = cpu_data(m->extcpu).initial_apicid;\n\trdmsrl(MSR_IA32_MCG_CAP, m->mcgcap);\n\tif (this_cpu_has(X86_FEATURE_INTEL_PPIN))\n\t\trdmsrl(MSR_PPIN, m->ppin);\n\tm->microcode = boot_cpu_data.microcode;\n}", "target": 0}
{"code": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->process_keyring)\n\t\treturn -EEXIST;\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->process_keyring = keyring;\n\treturn 0;\n}", "target": 1}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = disconnect_mount(p, how);\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 1}
{"code": "FILE *mingw_freopen (const char *filename, const char *otype, FILE *stream)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfreopen(wfilename, wotype, stream);\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}", "target": 0}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "bool CSPSource::schemeMatches(const KURL& url) const\n {\n     if (m_scheme.isEmpty())\n         return m_policy->protocolMatchesSelf(url);\n    if (equalIgnoringCase(m_scheme, \"http\"))\n        return equalIgnoringCase(url.protocol(), \"http\") || equalIgnoringCase(url.protocol(), \"https\");\n    if (equalIgnoringCase(m_scheme, \"ws\"))\n        return equalIgnoringCase(url.protocol(), \"ws\") || equalIgnoringCase(url.protocol(), \"wss\");\n     return equalIgnoringCase(url.protocol(), m_scheme);\n }", "target": 0}
{"code": "void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - FF_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + FF_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p, 0, min_size + FF_INPUT_BUFFER_PADDING_SIZE);\n}", "target": 0}
{"code": "  tt_size_reset( TT_Size  size,\n                 FT_Bool  only_height )\n  {\n    TT_Face           face;\n     FT_Size_Metrics*  metrics;\n    size->ttmetrics.valid = FALSE;\n     face = (TT_Face)size->root.face;\n     metrics = &size->metrics;\n    if ( face->header.Flags & 8 )\n    {\n      metrics->ascender =\n        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );\n      metrics->descender =\n        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );\n      metrics->height =\n        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );\n    }\n    size->ttmetrics.valid = TRUE;\n    if ( only_height )\n      return FT_Err_Ok;\n    if ( face->header.Flags & 8 )\n    {\n      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,\n                                    face->root.units_per_EM );\n      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,\n                                    face->root.units_per_EM );\n      metrics->max_advance =\n        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,\n                                 metrics->x_scale ) );\n    }\n    if ( metrics->x_ppem >= metrics->y_ppem )\n    {\n      size->ttmetrics.scale   = metrics->x_scale;\n      size->ttmetrics.ppem    = metrics->x_ppem;\n      size->ttmetrics.x_ratio = 0x10000L;\n      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,\n                                           metrics->x_ppem );\n    }\n    else\n    {\n      size->ttmetrics.scale   = metrics->y_scale;\n      size->ttmetrics.ppem    = metrics->y_ppem;\n      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,\n                                           metrics->y_ppem );\n      size->ttmetrics.y_ratio = 0x10000L;\n    }\n#ifdef TT_USE_BYTECODE_INTERPRETER\n    size->cvt_ready = -1;\n#endif \n    return FT_Err_Ok;\n  }", "target": 1}
{"code": "UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\tStream_Read_UINT16(s, rect16->left);   \n\tStream_Read_UINT16(s, rect16->top);    \n\tStream_Read_UINT16(s, rect16->right);  \n\tStream_Read_UINT16(s, rect16->bottom); \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "static int netsnmp_session_gen_sec_key(struct snmp_session *s, char *pass)\n{\n\tint snmp_errno;\n\ts->securityPrivKeyLen = USM_PRIV_KU_LEN;\n\tif ((snmp_errno = generate_Ku(s->securityAuthProto, s->securityAuthProtoLen,\n\t\t\t(u_char *)pass, strlen(pass),\n\t\t\ts->securityPrivKey, &(s->securityPrivKeyLen)))) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Error generating a key for privacy pass phrase '%s': %s\", pass, snmp_api_errstring(snmp_errno));\n\t\treturn (-2);\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "CharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}", "target": 1}
{"code": "int qemu_can_send_packet(NetClientState *sender)\n{\n    int vm_running = runstate_is_running();\n    if (!vm_running) {\n        return 0;\n    }\n    if (!sender->peer) {\n        return 1;\n    }\n    if (sender->peer->receive_disabled) {\n        return 0;\n    } else if (sender->peer->info->can_receive &&\n               !sender->peer->info->can_receive(sender->peer)) {\n        return 0;\n    }\n    return 1;\n}", "target": 1}
{"code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "PHP_METHOD(snmp, set)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, SNMP_CMD_SET, (-1));\n}", "target": 0}
{"code": "int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_context_destroy *args = data;\n\tstruct drm_i915_file_private *file_priv = file->driver_priv;\n\tstruct i915_gem_context *ctx;\n\tint ret;\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\tif (args->ctx_id == DEFAULT_CONTEXT_HANDLE)\n\t\treturn -ENOENT;\n\tctx = i915_gem_context_lookup(file_priv, args->ctx_id);\n\tif (!ctx)\n\t\treturn -ENOENT;\n\tret = mutex_lock_interruptible(&dev->struct_mutex);\n\tif (ret)\n\t\tgoto out;\n\tidr_remove(&file_priv->context_idr, ctx->user_handle);\n\tcontext_close(ctx);\n\tmutex_unlock(&dev->struct_mutex);\nout:\n\ti915_gem_context_put(ctx);\n\treturn 0;\n}", "target": 1}
{"code": "static int hfs_cat_build_thread(struct super_block *sb,\n\t\t\t\thfs_cat_rec *rec, int type,\n\t\t\t\tu32 parentid, struct qstr *name)\n{\n\trec->type = type;\n\tmemset(rec->thread.reserved, 0, sizeof(rec->thread.reserved));\n\trec->thread.ParID = cpu_to_be32(parentid);\n\thfs_asc2mac(sb, &rec->thread.CName, name);\n\treturn sizeof(struct hfs_cat_thread);\n}", "target": 0}
{"code": "static int get_vdev_port_node_info(struct mdesc_handle *md, u64 node,\n\t\t\t\t   union md_node_info *node_info)\n{\n\tconst u64 *parent_cfg_hdlp;\n\tconst char *name;\n\tconst u64 *idp;\n\tidp = mdesc_get_property(md, node, \"id\", NULL);\n\tname = mdesc_get_property(md, node, \"name\", NULL);\n\tparent_cfg_hdlp = parent_cfg_handle(md, node);\n\tif (!idp || !name || !parent_cfg_hdlp)\n\t\treturn -1;\n\tnode_info->vdev_port.id = *idp;\n\tnode_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);\n\tnode_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;\n\treturn 0;\n}", "target": 1}
{"code": "static int connection_handle_write(request_st * const r, connection * const con) {\n\tif (con->is_writable <= 0) return CON_STATE_WRITE;\n\tint rc = connection_write_chunkqueue(con, con->write_queue, MAX_WRITE_LIMIT);\n\tswitch (rc) {\n\tcase 0:\n\t\tif (r->resp_body_finished) {\n\t\t\tconnection_set_state(r, CON_STATE_RESPONSE_END);\n\t\t\treturn CON_STATE_RESPONSE_END;\n\t\t}\n\t\tbreak;\n\tcase -1: \n\t\tlog_error(r->conf.errh, __FILE__, __LINE__,\n\t\t  \"connection closed: write failed on fd %d\", con->fd);\n\t\tconnection_set_state_error(r, CON_STATE_ERROR);\n\t\treturn CON_STATE_ERROR;\n\tcase -2: \n\t\tconnection_set_state_error(r, CON_STATE_ERROR);\n\t\treturn CON_STATE_ERROR;\n\tcase 1:\n\t\tif (con->write_queue->bytes_out)\n\t\t\tcon->is_writable = 0;\n\t\tbreak;\n\t}\n\treturn CON_STATE_WRITE; \n}", "target": 0}
{"code": "int ImagingLibTiffEncodeInit(ImagingCodecState state, char *filename, int fp) {\n    TIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n    int bufsize = 64*1024;\n    char *mode = \"w\";\n    TRACE((\"initing libtiff\\n\"));\n    TRACE((\"Filename %s, filepointer: %d \\n\", filename,  fp));\n    TRACE((\"State: count %d, state %d, x %d, y %d, ystep %d\\n\", state->count, state->state,\n           state->x, state->y, state->ystep));\n    TRACE((\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\", state->xsize, state->ysize,\n           state->xoff, state->yoff));\n    TRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n    TRACE((\"State: context %p \\n\", state->context));\n    clientstate->loc = 0;\n    clientstate->size = 0;\n    clientstate->eof =0;\n    clientstate->data = 0;\n    clientstate->flrealloc = 0;\n    clientstate->fp = fp;\n    state->state = 0;\n    if (fp) {\n        TRACE((\"Opening using fd: %d for writing \\n\",clientstate->fp));\n        clientstate->tiff = TIFFFdOpen(clientstate->fp, filename, mode);\n    } else {\n        TRACE((\"Opening a buffer for writing \\n\"));\n        clientstate->data = malloc(bufsize);\n        clientstate->size = bufsize;\n        clientstate->flrealloc=1;\n        if (!clientstate->data) {\n            TRACE((\"Error, couldn't allocate a buffer of size %d\\n\", bufsize));\n            return 0;\n        }\n        clientstate->tiff = TIFFClientOpen(filename, mode,\n                                           (thandle_t) clientstate,\n                                           _tiffReadProc, _tiffWriteProc,\n                                           _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n                                           _tiffNullMapProc, _tiffUnmapProc); \n    }\n    if (!clientstate->tiff) {\n        TRACE((\"Error, couldn't open tiff file\\n\"));\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "check_SET_IP_TTL(const struct ofpact_ip_ttl *a OVS_UNUSED,\n                 struct ofpact_check_params *cp)\n{\n    return check_set_ip(cp);\n}", "target": 0}
{"code": "int jpc_pi_init(jpc_pi_t *pi)\n{\n\tint compno;\n\tint rlvlno;\n\tint prcno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tint *prclyrno;\n\tpi->prgvolfirst = 0;\n\tpi->valid = 0;\n\tpi->pktno = -1;\n\tpi->pchgno = -1;\n\tpi->pchg = 0;\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t  ++compno, ++picomp) {\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void blk_mq_kick_requeue_list(struct request_queue *q)\n{\n\tkblockd_schedule_work(&q->requeue_work);\n}", "target": 0}
{"code": "  static void *operator new(size_t size, MEM_ROOT *mem_root)\n  {\n    return alloc_root(mem_root, size);\n  }", "target": 0}
{"code": "int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}", "target": 0}
{"code": "static void calc_timer_values(struct perf_event *event,\n\t\t\t\tu64 *now,\n\t\t\t\tu64 *enabled,\n\t\t\t\tu64 *running)\n{\n\tu64 ctx_time;\n\t*now = perf_clock();\n\tctx_time = event->shadow_ctx_time + *now;\n\t*enabled = ctx_time - event->tstamp_enabled;\n\t*running = ctx_time - event->tstamp_running;\n}", "target": 0}
{"code": "void set_task_comm(struct task_struct *tsk, char *buf)\n{\n\ttask_lock(tsk);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n}", "target": 0}
{"code": "ex_redraw(exarg_T *eap)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n    validate_cursor();\n    update_topline();\n    update_screen(eap->forceit ? CLEAR : VIsual_active ? INVERTED : 0);\n    if (need_maketitle)\n\tmaketitle();\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n\tresize_console_buf();\n#endif\n    RedrawingDisabled = r;\n    p_lz = p;\n    screen_stop_highlight();\n    msg_didout = FALSE;\n    msg_col = 0;\n    need_wait_return = FALSE;\n    if (State & CMDLINE)\n\tredrawcmdline();\n    out_flush();\n}", "target": 0}
{"code": "videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\tdprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}", "target": 1}
{"code": "static TEE_Result do_alloc_publickey(struct rsa_public_key *s,\n\t\t\t\t     size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n)) {\n\t\tcrypto_bignum_free(s->e);\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "static void debug_print_fis(uint8_t *fis, int cmd_len)\n{\n#if DEBUG_AHCI\n    int i;\n    fprintf(stderr, \"fis:\");\n    for (i = 0; i < cmd_len; i++) {\n        if ((i & 0xf) == 0) {\n            fprintf(stderr, \"\\n%02x:\",i);\n        }\n        fprintf(stderr, \"%02x \",fis[i]);\n    }\n    fprintf(stderr, \"\\n\");\n#endif\n}", "target": 0}
{"code": "MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}", "target": 1}
{"code": "static inline int get_len(LZOContext *c, int x, int mask)\n{\n    int cnt = x & mask;\n    if (!cnt) {\n        while (!(x = get_byte(c)))\n            cnt += 255;\n        cnt += mask + x;\n    }\n    return cnt;\n}", "target": 1}
{"code": "decompileINITOBJECT(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *nparam;\n\tnparam=pop();\n\tpush(newVar_N2(\"\",\"\",\"\",\"{\", nparam->p.Integer,\"}\"));\n\treturn 0;\n}", "target": 0}
{"code": "der_to_ldap_BitString (struct berval *berValue,\n                                   struct berval *ldapValue)\n{\n\tber_len_t bitPadding=0;\n\tber_len_t bits, maxBits;\n\tchar *tmpStr;\n\tunsigned char byte;\n\tber_len_t bitLength;\n\tber_len_t valLen;\n\tunsigned char* valPtr;\n\tldapValue->bv_len=0;\n\tldapValue->bv_val=NULL;\n\tvalLen=berValue->bv_len;\n\tvalPtr=(unsigned char*)berValue->bv_val;\n\tif (valLen) {\n\t\tbitPadding=(ber_len_t)(valPtr[0]);\n\t\tvalLen--;\n\t\tvalPtr++;\n\t}\n\tif (bitPadding >= BITS_PER_BYTE) {\n\t\tif (valLen*BITS_PER_BYTE > bitPadding ) {\n\t\t\tvalLen-=(bitPadding/BITS_PER_BYTE);\n\t\t\tbitPadding%=BITS_PER_BYTE;\n\t\t} else {\n\t\t\tvalLen=0;\n\t\t\tbitPadding=0;\n\t\t}\n\t}\n\tif (valLen*BITS_PER_BYTE < bitPadding ) {\n\t\tbitPadding=0;\n\t\tvalLen=0;\n\t}\n\tbitLength=valLen*BITS_PER_BYTE-bitPadding;\n\ttmpStr=LDAP_MALLOC(bitLength + STR_OVERHEAD + 1);\n\tif (!tmpStr)\n\t\treturn LDAP_NO_MEMORY;\n\tldapValue->bv_val=tmpStr;\n\tldapValue->bv_len=bitLength + STR_OVERHEAD;\n\tmaxBits=BITS_PER_BYTE;\n\t*tmpStr++ ='\\'';\n\twhile(valLen) {\n\t\tbyte=*valPtr;\n\t\tif (valLen==1)\n\t\t\tmaxBits-=bitPadding;\n\t\tfor (bits=0; bits<maxBits; bits++) {\n\t\t\tif (0x80 & byte)\n\t\t\t\t*tmpStr='1';\n\t\t\telse\n\t\t\t\t*tmpStr='0';\n\t\t\ttmpStr++;\n\t\t\tbyte<<=1;\n\t\t}\n\t\tvalPtr++;\n\t\tvalLen--;\n\t}\n\t*tmpStr++ ='\\'';\n\t*tmpStr++ ='B';\n\t*tmpStr=0;\n\treturn LDAP_SUCCESS;\n}", "target": 0}
{"code": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\tval = 0;\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif (val > SG_MAX_QUEUE)\n\t\t\tbreak;\n\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n\t\trinfo[val].req_state = srp->done + 1;\n\t\trinfo[val].problem =\n\t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}", "target": 1}
{"code": "static void move_msr_up(struct vcpu_vmx *vmx, int from, int to)\n{\n\tstruct shared_msr_entry tmp;\n\ttmp = vmx->guest_msrs[to];\n\tvmx->guest_msrs[to] = vmx->guest_msrs[from];\n\tvmx->guest_msrs[from] = tmp;\n}", "target": 0}
{"code": "static void hardware_enable_nolock(void *junk)\n{\n\tint cpu = raw_smp_processor_id();\n\tint r;\n\tif (cpumask_test_cpu(cpu, cpus_hardware_enabled))\n\t\treturn;\n\tcpumask_set_cpu(cpu, cpus_hardware_enabled);\n\tr = kvm_arch_hardware_enable(NULL);\n\tif (r) {\n\t\tcpumask_clear_cpu(cpu, cpus_hardware_enabled);\n\t\tatomic_inc(&hardware_enable_failed);\n\t\tprintk(KERN_INFO \"kvm: enabling virtualization on \"\n\t\t\t\t \"CPU%d failed\\n\", cpu);\n\t}\n}", "target": 0}
{"code": "zisofs_free(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tint ret = ARCHIVE_OK;\n\tfree(iso9660->zisofs.block_pointers);\n\tif (iso9660->zisofs.stream_valid &&\n\t    deflateEnd(&(iso9660->zisofs.stream)) != Z_OK) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to clean up compressor\");\n\t\tret = ARCHIVE_FATAL;\n\t}\n\tiso9660->zisofs.block_pointers = NULL;\n\tiso9660->zisofs.stream_valid = 0;\n\treturn (ret);\n}", "target": 0}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "static void check_hostalias(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    return;\nfound:\n    r->server = s;\n}", "target": 1}
{"code": "find_reserved_job_in_conn(conn c, job j)\n{\n    return (j && j->reserver == c && j->state == JOB_STATE_RESERVED) ? j : NULL;\n}", "target": 0}
{"code": "bool sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t\tstruct sctp_chunk *chunk, bool addr_param_needed,\n\t\t\tstruct sctp_paramhdr **errp)\n{\n\tsctp_addip_chunk_t *addip = (sctp_addip_chunk_t *) chunk->chunk_hdr;\n\tunion sctp_params param;\n\tbool addr_param_seen = false;\n\tsctp_walk_params(param, addip, addip_hdr.params) {\n\t\tsize_t length = ntohs(param.p->length);\n\t\t*errp = param.p;\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t\tif (length != sizeof(sctp_ipv4addr_param_t))\n\t\t\t\treturn false;\n\t\t\taddr_param_seen = true;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\t\tif (length != sizeof(sctp_ipv6addr_param_t))\n\t\t\t\treturn false;\n\t\t\taddr_param_seen = true;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_PARAM_DEL_IP:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t\tif (addr_param_needed && !addr_param_seen)\n\t\t\t\treturn false;\n\t\t\tlength = ntohs(param.addip->param_hdr.length);\n\t\t\tif (length < sizeof(sctp_addip_param_t) +\n\t\t\t\t     sizeof(sctp_paramhdr_t))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\t\tif (length != sizeof(sctp_addip_param_t))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (addr_param_needed && !addr_param_seen)\n\t\treturn false;\n\tif (!addr_param_needed && addr_param_seen)\n\t\treturn false;\n\tif (param.v != chunk->chunk_end)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "sg_rq_end_io_usercontext(struct work_struct *work)\n{\n\tstruct sg_request *srp = container_of(work, struct sg_request, ew.work);\n\tstruct sg_fd *sfp = srp->parentfp;\n\tsg_finish_rem_req(srp);\n\tsg_remove_request(sfp, srp);\n\tkref_put(&sfp->f_ref, sg_remove_sfp);\n}", "target": 0}
{"code": "void IndexedDBDatabase::ReportErrorWithDetails(Status status,\n                                               const char* message) {\n  DCHECK(!status.ok());\n  if (status.IsCorruption()) {\n    IndexedDBDatabaseError error(blink::kWebIDBDatabaseExceptionUnknownError,\n                                 message);\n    factory_->HandleBackingStoreCorruption(backing_store_->origin(), error);\n  } else {\n    factory_->HandleBackingStoreFailure(backing_store_->origin());\n  }\n}", "target": 0}
{"code": "find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_head = quicklist->head;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {\n        quicklist->head->zl =\n            ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(quicklist->head);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);\n    }\n    quicklist->count++;\n    quicklist->head->count++;\n    return (orig_head != quicklist->head);\n}", "target": 0}
{"code": "static void n_tty_receive_break(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tif (I_IGNBRK(tty))\n\t\treturn;\n\tif (I_BRKINT(tty)) {\n\t\tisig(SIGINT, tty);\n\t\tif (!L_NOFLSH(tty)) {\n\t\t\tup_read(&tty->termios_rwsem);\n\t\t\tn_tty_flush_buffer(tty);\n\t\t\ttty_driver_flush_buffer(tty);\n\t\t\tdown_read(&tty->termios_rwsem);\n\t\t}\n\t\treturn;\n\t}\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t}\n\tput_tty_queue('\\0', ldata);\n\tif (waitqueue_active(&tty->read_wait))\n\t\twake_up_interruptible(&tty->read_wait);\n}", "target": 0}
{"code": "static int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tmutex_lock(&cfg80211_mutex);\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif_idx = 0;\n\t\tmutex_lock(&rdev->devlist_mtx);\n\t\tlist_for_each_entry(wdev, &rdev->wdev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl80211_send_iface(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t       rdev, wdev) < 0) {\n\t\t\t\tmutex_unlock(&rdev->devlist_mtx);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\t\tmutex_unlock(&rdev->devlist_mtx);\n\t\twp_idx++;\n\t}\n out:\n\tmutex_unlock(&cfg80211_mutex);\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n \tstruct sock *sk;\n \tax25_cb *ax25;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n \tif (!net_eq(net, &init_net))\n \t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tax25->sk    = sk;\n\treturn 0;\n}", "target": 0}
{"code": "int service_init(int argc __attribute__((unused)),\n\t\t char **argv __attribute__((unused)),\n\t\t char **envp __attribute__((unused)))\n{\n    int opt;\n    const char *prefix;\n    initialize_nntp_error_table();\n    if (geteuid() == 0) fatal(\"must run as the Cyrus user\", EC_USAGE);\n    setproctitle_init(argc, argv, envp);\n    signals_set_shutdown(&shut_down);\n    signal(SIGPIPE, SIG_IGN);\n    global_sasl_init(1, 1, mysasl_cb);\n    if ((prefix = config_getstring(IMAPOPT_NEWSPREFIX)))\n\tsnprintf(newsprefix, sizeof(newsprefix), \"%s.\", prefix);\n    newsgroups = split_wildmats((char *) config_getstring(IMAPOPT_NEWSGROUPS));\n    if (duplicate_init(NULL, 0) != 0) {\n\tsyslog(LOG_ERR, \n\t       \"unable to init duplicate delivery database\\n\");\n\tfatal(\"unable to init duplicate delivery database\", EC_SOFTWARE);\n    }\n    mboxlist_init(0);\n    mboxlist_open(NULL);\n    quotadb_init(0);\n    quotadb_open(NULL);\n    denydb_init(0);\n    denydb_open(NULL);\n    idle_enabled();\n    while ((opt = getopt(argc, argv, \"srfp:\")) != EOF) {\n\tswitch(opt) {\n\tcase 's': \n\t    nntps = 1;\n\t    if (!tls_enabled()) {\n\t\tsyslog(LOG_ERR, \"nntps: required OpenSSL options not present\");\n\t\tfatal(\"nntps: required OpenSSL options not present\",\n\t\t      EC_CONFIG);\n\t    }\n\t    break;\n\tcase 'r': \n\t    nntp_capa = MODE_READ;\n\t    break;\n\tcase 'f': \n\t    nntp_capa = MODE_FEED;\n\t    break;\n\tcase 'p': \n\t    extprops_ssf = atoi(optarg);\n\t    break;\n\tdefault:\n\t    usage();\n\t}\n    }\n    annotatemore_init(NULL, NULL);\n    annotatemore_open();\n    newsmaster = (char *) config_getstring(IMAPOPT_NEWSMASTER);\n    newsmaster_authstate = auth_newstate(newsmaster);\n    singleinstance = config_getswitch(IMAPOPT_SINGLEINSTANCESTORE);\n    protin = protgroup_new(2);\n    return 0;\n}", "target": 0}
{"code": "GF_ItemListBox *gf_ismo_locate_box(GF_List *list, u32 boxType, bin128 UUID)\n{\n\tu32 i;\n\tGF_Box *box;\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tif (box->type == boxType) {\n\t\t\tGF_UUIDBox* box2 = (GF_UUIDBox* )box;\n\t\t\tif (boxType != GF_ISOM_BOX_TYPE_UUID) return (GF_ItemListBox *)box;\n\t\t\tif (!memcmp(box2->uuid, UUID, 16)) return (GF_ItemListBox *)box;\n\t\t}\n\t}\n\treturn NULL;", "target": 0}
{"code": "static inline int dpt_dma64(adpt_hba *pHba)\n{\n\treturn (sizeof(dma_addr_t) > 4 && (pHba)->dma64);\n}", "target": 1}
{"code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\treturn 0;\n}", "target": 1}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t}\n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "Extension::State ExtensionPrefs::GetExtensionState(\n    const std::string& extension_id) const {\n  const DictionaryValue* extension = GetExtensionPref(extension_id);\n  if (!extension)\n    return Extension::ENABLED;\n  int state = -1;\n  if (!extension->GetInteger(kPrefState, &state) ||\n      state < 0 || state >= Extension::NUM_STATES) {\n    LOG(ERROR) << \"Bad or missing pref 'state' for extension '\"\n               << extension_id << \"'\";\n    return Extension::ENABLED;\n  }\n  return static_cast<Extension::State>(state);\n}", "target": 0}
{"code": "externalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; \n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif \n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}", "target": 1}
{"code": "SPL_METHOD(DirectoryIterator, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tintern->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t\tintern->file_name = NULL;\n\t}\n}", "target": 0}
{"code": "int posix_cpu_clock_get(const clockid_t which_clock, struct timespec *tp)\n{\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\tint error = -EINVAL;\n\tunion cpu_time_count rtn;\n\tif (pid == 0) {\n\t\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\t\terror = cpu_clock_sample(which_clock,\n\t\t\t\t\t\t current, &rtn);\n\t\t} else {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\terror = cpu_clock_sample_group(which_clock,\n\t\t\t\t\t\t       current, &rtn);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p) {\n\t\t\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\t\t\tif (same_thread_group(p, current)) {\n\t\t\t\t\terror = cpu_clock_sample(which_clock,\n\t\t\t\t\t\t\t\t p, &rtn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tread_lock(&tasklist_lock);\n\t\t\t\tif (thread_group_leader(p) && p->signal) {\n\t\t\t\t\terror =\n\t\t\t\t\t    cpu_clock_sample_group(which_clock,\n\t\t\t\t\t\t\t           p, &rtn);\n\t\t\t\t}\n\t\t\t\tread_unlock(&tasklist_lock);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (error)\n\t\treturn error;\n\tsample_to_timespec(which_clock, rtn, tp);\n\treturn 0;\n}", "target": 0}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}", "target": 1}
{"code": "int jpc_pchglist_numpchgs(jpc_pchglist_t *pchglist)\n{\n\treturn pchglist->numpchgs;\n}", "target": 0}
{"code": "static inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}", "target": 0}
{"code": "static inline void perf_get_data_addr(struct pt_regs *regs, u64 *addrp) { }", "target": 0}
{"code": "static int read_file(const char *path, char *buf, size_t size,\n\t\t     struct file_info *d)\n{\n\tsize_t linelen = 0, total_len = 0, rv = 0;\n\tchar *line = NULL;\n\tchar *cache = d->buf;\n\tsize_t cache_size = d->buflen;\n\tFILE *f = fopen(path, \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\tsize_t l = snprintf(cache, cache_size, \"%s\", line);\n\t\tif (l < 0) {\n\t\t\tperror(\"Error writing to cache\");\n\t\t\trv = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (l >= cache_size) {\n\t\t\tfprintf(stderr, \"Internal error: truncated write to cache\\n\");\n\t\t\trv = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (l < cache_size) {\n\t\t\tcache += l;\n\t\t\tcache_size -= l;\n\t\t\ttotal_len += l;\n\t\t} else {\n\t\t\tcache += cache_size;\n\t\t\ttotal_len += cache_size;\n\t\t\tcache_size = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\td->size = total_len;\n\tif (total_len > size ) total_len = size;\n\tmemcpy(buf, d->buf, total_len);\n\trv = total_len;\n  err:\n\tfclose(f);\n\tfree(line);\n\treturn rv;\n}", "target": 0}
{"code": "int X509_REQ_check_private_key(X509_REQ *x, EVP_PKEY *k)\n{\n    EVP_PKEY *xk = NULL;\n    int ok = 0;\n    xk = X509_REQ_get_pubkey(x);\n    switch (EVP_PKEY_cmp(xk, k)) {\n    case 1:\n        ok = 1;\n        break;\n    case 0:\n        X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,\n                X509_R_KEY_VALUES_MISMATCH);\n        break;\n    case -1:\n        X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_KEY_TYPE_MISMATCH);\n        break;\n    case -2:\n#ifndef OPENSSL_NO_EC\n        if (k->type == EVP_PKEY_EC) {\n            X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, ERR_R_EC_LIB);\n            break;\n        }\n#endif\n#ifndef OPENSSL_NO_DH\n        if (k->type == EVP_PKEY_DH) {\n            X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,\n                    X509_R_CANT_CHECK_DH_KEY);\n            break;\n        }\n#endif\n        X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_UNKNOWN_KEY_TYPE);\n    }\n    EVP_PKEY_free(xk);\n    return (ok);\n}", "target": 0}
{"code": "irc_server_sasl_enabled (struct t_irc_server *server)\n{\n    int sasl_mechanism, rc;\n    char *sasl_username, *sasl_password;\n    const char *sasl_key;\n    sasl_mechanism = IRC_SERVER_OPTION_INTEGER(\n        server, IRC_SERVER_OPTION_SASL_MECHANISM);\n    sasl_username = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_USERNAME));\n    sasl_password = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_PASSWORD));\n    sasl_key = IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_KEY);\n    rc = ((sasl_mechanism == IRC_SASL_MECHANISM_EXTERNAL)\n          || ((sasl_mechanism == IRC_SASL_MECHANISM_ECDSA_NIST256P_CHALLENGE)\n              && sasl_username && sasl_username[0]\n              && sasl_key && sasl_key[0])\n          || (sasl_username && sasl_username[0]\n              && sasl_password && sasl_password[0])) ? 1 : 0;\n    if (sasl_username)\n        free (sasl_username);\n    if (sasl_password)\n        free (sasl_password);\n    return rc;\n}", "target": 0}
{"code": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\tif (!fstype)\n\t\treturn -EINVAL;\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}", "target": 1}
{"code": "rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n\t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n\t\t    rxent->client.s_addr == clip &&\n\t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&\n\t\t    rxent->dport == sport) {\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\treturn(0);\n}", "target": 1}
{"code": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n  if (!s)\n    return -1;\n  while (*s)\n  {\n    SKIPWS(s);\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS(s);\n      ptmp = tmp;\n      while (isdigit((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = '\\0';\n      if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->id = 0;\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}", "target": 0}
{"code": "SPL_METHOD(SplHeap, key)\n{\n\tspl_heap_object *intern = (spl_heap_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\t\t\n\tRETURN_LONG(intern->heap->count - 1);\n}", "target": 0}
{"code": "static inline long div_long_long_rem_signed(const long long dividend,\n\t\t\t\t\t    const long divisor, long *remainder)\n{\n\tlong res;\n\tif (unlikely(dividend < 0)) {\n\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n\t\t*remainder = -(*remainder);\n\t} else\n\t\tres = div_long_long_rem(dividend, divisor, remainder);\n\treturn res;\n}", "target": 1}
{"code": "static inline u32 dma_low(dma_addr_t addr)\n{\n\treturn (u32)addr;\n}", "target": 1}
{"code": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}", "target": 1}
{"code": "SPL_METHOD(SplDoublyLinkedList, unserialize)\n{\n\tspl_dllist_object     *intern   = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzval                  *flags, *elem;\n\tchar *buf;\n\tint buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (buf_len == 0) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Serialized string cannot be empty\");\n\t\treturn;\n\t}\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tALLOC_INIT_ZVAL(flags);\n\tif (!php_var_unserialize(&flags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(flags) != IS_LONG) {\n\t\tzval_ptr_dtor(&flags);\n\t\tgoto error;\n\t}\n\tintern->flags = Z_LVAL_P(flags);\n\tzval_ptr_dtor(&flags);\n\twhile(*p == ':') {\n\t\t++p;\n\t\tALLOC_INIT_ZVAL(elem);\n\t\tif (!php_var_unserialize(&elem, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n\t\t\tzval_ptr_dtor(&elem);\n\t\t\tgoto error;\n\t\t}\n\t\tspl_ptr_llist_push(intern->llist, elem TSRMLS_CC);\n\t}\n\tif (*p != '\\0') {\n\t\tgoto error;\n\t}\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn;\nerror:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Error at offset %ld of %d bytes\", (long)((char*)p - buf), buf_len);\n\treturn;\n} ", "target": 1}
{"code": "static int fuse_push_module(struct fuse *f, const char *module,\n                            struct fuse_args *args)\n{\n    struct fuse_fs *newfs;\n    struct fuse_module *m = fuse_get_module(module);\n    struct fuse_fs *fs[2];\n    fs[0] = f->fs;\n    fs[1] = NULL;\n    if (!m)\n        return -1;\n    newfs = m->factory(args, fs);\n    if (!newfs) {\n        fuse_put_module(m);\n        return -1;\n    }\n    newfs->m = m;\n    f->fs = newfs;\n    return 0;\n}", "target": 0}
{"code": "struct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename filename = { .name = name };\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\tif (dentry->d_inode->i_op->follow_link && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_REVAL);\n\treturn file;\n}", "target": 0}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tif (gf_bs_get_position(state->bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}", "target": 1}
{"code": "*/\nPHP_FUNCTION(date_interval_create_from_date_string)\n{\n\tchar           *time_str = NULL;\n\tint             time_str_len = 0;\n\ttimelib_time   *time;\n\ttimelib_error_container *err = NULL;\n\tphp_interval_obj *diobj;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &time_str, &time_str_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tphp_date_instantiate(date_ce_interval, return_value TSRMLS_CC);\n\ttime = timelib_strtotime(time_str, time_str_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\tdiobj = (php_interval_obj *) zend_object_store_get_object(return_value TSRMLS_CC);\n\tdiobj->diff = timelib_rel_time_clone(&time->relative);\n\tdiobj->initialized = 1;\n\ttimelib_time_dtor(time);\n\ttimelib_error_container_dtor(err);", "target": 0}
{"code": "bool RenderMenuList::multiple()\n {\n     return toHTMLSelectElement(node())->multiple();\n }", "target": 1}
{"code": "void Transform::interpolate_nearestneighbour( RawTile& in, unsigned int resampled_width, unsigned int resampled_height ){\n  unsigned char *input = (unsigned char*) in.data;\n  int channels = in.channels;\n  unsigned int width = in.width;\n  unsigned int height = in.height;\n  unsigned char *output;\n  bool new_buffer = false;\n  if( resampled_width*resampled_height > in.width*in.height ){\n    new_buffer = true;\n    output = new unsigned char[(unsigned long long)resampled_width*resampled_height*in.channels];\n  }\n  else output = (unsigned char*) in.data;\n  float xscale = (float)width / (float)resampled_width;\n  float yscale = (float)height / (float)resampled_height;\n  for( unsigned int j=0; j<resampled_height; j++ ){\n    for( unsigned int i=0; i<resampled_width; i++ ){\n      unsigned long ii = (unsigned int) floorf(i*xscale);\n      unsigned long jj = (unsigned int) floorf(j*yscale);\n      unsigned long pyramid_index = (unsigned int) channels * ( ii + jj*width );\n      unsigned long long resampled_index = (unsigned long long)(i + j*resampled_width)*channels;\n      for( int k=0; k<in.channels; k++ ){\n\toutput[resampled_index+k] = input[pyramid_index+k];\n      }\n    }\n  }\n  if( new_buffer ) delete[] (unsigned char*) input;\n  in.width = resampled_width;\n  in.height = resampled_height;\n  in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);\n  in.data = output;\n}", "target": 1}
{"code": "handle_action(netdissect_options *ndo,\n              const uint8_t *src, const u_char *p, u_int length)\n{\n\tif (!ND_TTEST2(*p, 2))\n\t\treturn 0;\n\tif (length < 2)\n\t\treturn 0;\n\tif (ndo->ndo_eflag) {\n\t\tND_PRINT((ndo, \": \"));\n\t} else {\n\t\tND_PRINT((ndo, \" (%s): \", etheraddr_string(ndo, src)));\n\t}\n\tswitch (p[0]) {\n\tcase 0: ND_PRINT((ndo, \"Spectrum Management Act#%d\", p[1])); break;\n\tcase 1: ND_PRINT((ndo, \"QoS Act#%d\", p[1])); break;\n\tcase 2: ND_PRINT((ndo, \"DLS Act#%d\", p[1])); break;\n\tcase 3: ND_PRINT((ndo, \"BA \")); PRINT_BA_ACTION(p[1]); break;\n\tcase 7: ND_PRINT((ndo, \"HT \")); PRINT_HT_ACTION(p[1]); break;\n\tcase 13: ND_PRINT((ndo, \"MeshAction \")); PRINT_MESH_ACTION(p[1]); break;\n\tcase 14:\n\t\tND_PRINT((ndo, \"MultiohopAction \"));\n\t\tPRINT_MULTIHOP_ACTION(p[1]); break;\n\tcase 15:\n\t\tND_PRINT((ndo, \"SelfprotectAction \"));\n\t\tPRINT_SELFPROT_ACTION(p[1]); break;\n\tcase 127: ND_PRINT((ndo, \"Vendor Act#%d\", p[1])); break;\n\tdefault:\n\t\tND_PRINT((ndo, \"Reserved(%d) Act#%d\", p[0], p[1]));\n\t\tbreak;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();\n  if (!compositor->InCompositingMode())\n    return;\n  if (UsesCompositedScrolling()) {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n        Layer()->IsRootLayer() && scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n     if (!handled_scroll) {\n      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {\n        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(\n            kGraphicsLayerUpdateSubtree);\n      }\n      compositor->SetNeedsCompositingUpdate(\n          kCompositingUpdateAfterGeometryChange);\n    }\n    if (Layer()->IsRootLayer()) {\n      LocalFrame* frame = GetLayoutBox()->GetFrame();\n      if (frame && frame->View() &&\n          frame->View()->HasViewportConstrainedObjects()) {\n        Layer()->SetNeedsCompositingInputsUpdate();\n      }\n    }\n  } else {\n    Layer()->SetNeedsCompositingInputsUpdate();\n  }\n}", "target": 1}
{"code": "bool PrintMsg_Print_Params_IsEqual(\n    const PrintMsg_PrintPages_Params& oldParams,\n    const PrintMsg_PrintPages_Params& newParams) {\n  return PageLayoutIsEqual(oldParams, newParams) &&\n         oldParams.params.max_shrink == newParams.params.max_shrink &&\n         oldParams.params.min_shrink == newParams.params.min_shrink &&\n         oldParams.params.selection_only == newParams.params.selection_only &&\n         oldParams.params.supports_alpha_blend ==\n             newParams.params.supports_alpha_blend &&\n         oldParams.pages.size() == newParams.pages.size() &&\n         oldParams.params.display_header_footer ==\n             newParams.params.display_header_footer &&\n         oldParams.params.date == newParams.params.date &&\n         oldParams.params.title == newParams.params.title &&\n         oldParams.params.url == newParams.params.url &&\n         std::equal(oldParams.pages.begin(), oldParams.pages.end(),\n             newParams.pages.begin());\n}", "target": 0}
{"code": "void ConnectDialogEdit::showNotice(const QString &text) {\n\tQLabel *label = qwInlineNotice->findChild<QLabel *>(QLatin1String(\"qlPasteNotice\"));\n\tQ_ASSERT(label);\n\tlabel->setText(text);\n\tqwInlineNotice->show();\n\tadjustSize();\n}", "target": 0}
{"code": "libxlDomainDefCheckABIStability(libxlDriverPrivate *driver,\n                                virDomainDef *src,\n                                virDomainDef *dst)\n{\n    virDomainDef *migratableDefSrc = NULL;\n    virDomainDef *migratableDefDst = NULL;\n    bool ret = false;\n    if (!(migratableDefSrc = virDomainDefCopy(src, driver->xmlopt, NULL, true)) ||\n        !(migratableDefDst = virDomainDefCopy(dst, driver->xmlopt, NULL, true)))\n        goto cleanup;\n    ret = virDomainDefCheckABIStability(migratableDefSrc,\n                                        migratableDefDst,\n                                        driver->xmlopt);\n cleanup:\n    virDomainDefFree(migratableDefSrc);\n    virDomainDefFree(migratableDefDst);\n    return ret;\n}", "target": 0}
{"code": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}", "target": 1}
{"code": "flatpak_context_merge (FlatpakContext *context,\n                       FlatpakContext *other)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  context->shares &= ~other->shares_valid;\n  context->shares |= other->shares;\n  context->shares_valid |= other->shares_valid;\n  context->sockets &= ~other->sockets_valid;\n  context->sockets |= other->sockets;\n  context->sockets_valid |= other->sockets_valid;\n  context->devices &= ~other->devices_valid;\n  context->devices |= other->devices;\n  context->devices_valid |= other->devices_valid;\n  context->features &= ~other->features_valid;\n  context->features |= other->features;\n  context->features_valid |= other->features_valid;\n  g_hash_table_iter_init (&iter, other->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));\n  g_hash_table_iter_init (&iter, other->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->persistent, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->filesystems, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char **policy_values = (const char **) value;\n      int i;\n      for (i = 0; policy_values[i] != NULL; i++)\n        flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);\n    }\n}", "target": 1}
{"code": "static void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}", "target": 0}
{"code": "Browser::CreateParams Browser::CreateParams::CreateForApp(\n    const std::string& app_name,\n    bool trusted_source,\n    const gfx::Rect& window_bounds,\n    Profile* profile) {\n  DCHECK(!app_name.empty());\n  CreateParams params(TYPE_POPUP, profile);\n  params.app_name = app_name;\n  params.trusted_source = trusted_source;\n  params.initial_bounds = window_bounds;\n  return params;\n}", "target": 0}
{"code": "delete_buff_tail(buffheader_T *buf, int slen)\n{\n    int len = (int)STRLEN(buf->bh_curr->b_str);\n    if (len >= slen)\n    {\n\tbuf->bh_curr->b_str[len - slen] = NUL;\n\tbuf->bh_space += slen;\n    }\n}", "target": 1}
{"code": "void LibRaw::get_mem_image_format(int *width, int *height, int *colors,\n                                  int *bps) const\n{\n  if (S.flip & 4)\n  {\n    *width = S.height;\n    *height = S.width;\n  }\n  else\n  {\n    *width = S.width;\n    *height = S.height;\n  }\n  *colors = P1.colors;\n  *bps = O.output_bps;\n}", "target": 0}
{"code": "static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_pmd_page_dtor(virt_to_page(pmd));\n\tcrst_table_free(mm, (unsigned long *) pmd);\n}", "target": 0}
{"code": "static int exif_file_sections_add(image_info_type *ImageInfo, int type, size_t size, uchar *data)\n{\n\tfile_section    *tmp;\n\tint             count = ImageInfo->file.count;\n\ttmp = safe_erealloc(ImageInfo->file.list, (count+1), sizeof(file_section), 0);\n\tImageInfo->file.list = tmp;\n\tImageInfo->file.list[count].type = 0xFFFF;\n\tImageInfo->file.list[count].data = NULL;\n\tImageInfo->file.list[count].size = 0;\n\tImageInfo->file.count = count+1;\n\tif (!size) {\n\t\tdata = NULL;\n\t} else if (data == NULL) {\n\t\tdata = safe_emalloc(size, 1, 0);\n\t}\n\tImageInfo->file.list[count].type = type;\n\tImageInfo->file.list[count].data = data;\n\tImageInfo->file.list[count].size = size;\n\treturn count;\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "void G711::reset2()\n{\n\tint framesize = m_inChunk->f.channelCount;\n\tm_track->fpos_next_frame = m_track->fpos_first_frame +\n\t\tframesize * m_track->nextfframe;\n\tm_track->frames2ignore = 0;\n}", "target": 0}
{"code": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int av_hwframe_ctx_init(AVBufferRef *ref)\n{\n    AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;\n    const enum AVPixelFormat *pix_fmt;\n    int ret;\n    if (ctx->internal->source_frames) {\n        return 0;\n    }\n    for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {\n        if (*pix_fmt == ctx->format)\n            break;\n    }\n    if (*pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"The hardware pixel format '%s' is not supported by the device type '%s'\\n\",\n               av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);\n        return AVERROR(ENOSYS);\n    }\n    ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);\n    if (ret < 0)\n        return ret;\n    if (ctx->internal->hw_type->frames_init) {\n        ret = ctx->internal->hw_type->frames_init(ctx);\n        if (ret < 0)\n            goto fail;\n    }\n    if (ctx->internal->pool_internal && !ctx->pool)\n        ctx->pool = ctx->internal->pool_internal;\n    if (ctx->initial_pool_size > 0) {\n        ret = hwframe_pool_prealloc(ref);\n        if (ret < 0)\n            goto fail;\n    }\n    return 0;\nfail:\n    if (ctx->internal->hw_type->frames_uninit)\n        ctx->internal->hw_type->frames_uninit(ctx);\n    return ret;\n}", "target": 1}
{"code": "static void __mark_reg_const_zero(struct bpf_reg_state *reg)\n{\n\t__mark_reg_known(reg, 0);\n\treg->type = SCALAR_VALUE;\n}", "target": 0}
{"code": "static void ext4_end_io_work(struct work_struct *work)\n{\n\text4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\n\tstruct inode *inode = io->inode;\n\tint ret = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = ext4_end_io_nolock(io);\n\tif (ret >= 0) {\n\t\tif (!list_empty(&io->list))\n\t\t\tlist_del_init(&io->list);\n\t\text4_free_io_end(io);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n}", "target": 1}
{"code": "    uint32_t TiffDirectory::doSizeData() const\n    {\n        assert(false);\n        return 0;\n    } ", "target": 0}
{"code": "_asn1_extract_der_octet (asn1_node node, const unsigned char *der,\n\t\t\t int der_len, unsigned flags)\n{\n  int len2, len3;\n  int counter, counter_end;\n  int result;\n  len2 = asn1_get_length_der (der, der_len, &len3);\n  if (len2 < -1)\n    return ASN1_DER_ERROR;\n  counter = len3 + 1;\n  if (len2 == -1)\n    counter_end = der_len - 2;\n  else\n    counter_end = der_len;\n  while (counter < counter_end)\n    {\n      len2 = asn1_get_length_der (der + counter, der_len, &len3);\n      if (IS_ERR(len2, flags))\n\t{\n\t  warn();\n\t  return ASN1_DER_ERROR;\n\t}\n      if (len2 >= 0)\n\t{\n\t  DECR_LEN(der_len, len2+len3);\n\t  _asn1_append_value (node, der + counter + len3, len2);\n\t}\n      else\n\t{\t\t\t\n\t  DECR_LEN(der_len, len3);\n\t  result =\n\t    _asn1_extract_der_octet (node, der + counter + len3,\n\t\t\t\t     der_len, flags);\n\t  if (result != ASN1_SUCCESS)\n\t    return result;\n\t  len2 = 0;\n\t}\n      DECR_LEN(der_len, 1);\n      counter += len2 + len3 + 1;\n    }\n  return ASN1_SUCCESS;\ncleanup:\n  return result;\n}", "target": 1}
{"code": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\nfail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}", "target": 1}
{"code": "    Image::UniquePtr ImageFactory::create(ImageType type,\n                                        const std::wstring& wpath)\n    {\n        std::unique_ptr<FileIo> fileIo(new FileIo(wpath));\n        if (fileIo->open(\"w+b\") != 0) {\n            throw WError(kerFileOpenFailed, wpath, \"w+b\", strError().c_str());\n        }\n        fileIo->close();\n        BasicIo::UniquePtr io(std::move(fileIo));\n        Image::UniquePtr image = create(type, std::move(io));\n        if (image.get() == 0) throw Error(kerUnsupportedImageType, static_cast<int>(type));\n        return image;\n    }", "target": 0}
{"code": "irc_server_get_name_without_port (const char *name)\n{\n    char *pos;\n    if (!name)\n        return NULL;\n    pos = strchr (name, '/');\n    if (pos && (pos != name))\n        return weechat_strndup (name, pos - name);\n    return strdup (name);\n}", "target": 0}
{"code": "static struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol *control,\n\t\t\t\t\tunsigned int access)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tif (snd_BUG_ON(!control || !control->count))\n\t\treturn NULL;\n\tif (control->count > MAX_CONTROL_COUNT)\n\t\treturn NULL;\n\tkctl = kzalloc(sizeof(*kctl) + sizeof(struct snd_kcontrol_volatile) * control->count, GFP_KERNEL);\n\tif (kctl == NULL) {\n\t\tpr_err(\"ALSA: Cannot allocate control instance\\n\");\n\t\treturn NULL;\n\t}\n\t*kctl = *control;\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tkctl->vd[idx].access = access;\n\treturn kctl;\n}", "target": 0}
{"code": "separate_nextcmd(exarg_T *eap, int keep_backslash)\n{\n    char_u\t*p;\n#ifdef FEAT_QUICKFIX\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == Ctrl_V)\n\t{\n\t    if ((eap->argt & (EX_CTRLV | EX_XFILE)) || keep_backslash)\n\t\t++p;\t\t\n\t    else\n\t\tSTRMOVE(p, p + 1);\n\t    if (*p == NUL)\t\t\n\t\tbreak;\n\t}\n#ifdef FEAT_EVAL\n\telse if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE))\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == NUL)\t\t\n\t\tbreak;\n\t}\n#endif\n\telse if ((*p == '\"'\n#ifdef FEAT_EVAL\n\t\t    && !in_vim9script()\n#endif\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)\n\t\t\t\t\t\t\t      || p != eap->arg)\n\t\t    && (eap->cmdidx != CMD_redir\n\t\t\t\t\t || p != eap->arg + 1 || p[-1] != '@'))\n#ifdef FEAT_EVAL\n\t\t|| (*p == '#'\n\t\t    && in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && p > eap->cmd && VIM_ISWHITE(p[-1]))\n#endif\n\t\t|| *p == '|' || *p == '\\n')\n\t{\n\t    if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n\t\t\t      || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\')\n\t    {\n\t\tif (!keep_backslash)\n\t\t{\n\t\t    STRMOVE(p - 1, p);\t\n\t\t    --p;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\teap->nextcmd = check_nextcmd(p);\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (!(eap->argt & EX_NOTRLCOM))\t\n\tdel_trailing_spaces(eap->arg);\n}", "target": 0}
{"code": "append_wild(char *to, char *end, const char *wild)\n{\n  end-=5;\t\t\t\t\t\n  if (wild && wild[0])\n  {\n    to=strmov(to,\" like '\");\n    while (*wild && to < end)\n    {\n      if (*wild == '\\\\' || *wild == '\\'')\n\t*to++='\\\\';\n      *to++= *wild++;\n    }\n    if (*wild)\t\t\t\t\t\n      *to++='%';\t\t\t\t\n    to[0]='\\'';\n    to[1]=0;\n  }\n}", "target": 0}
{"code": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\treturn ret;\n}", "target": 1}
{"code": "static int snd_usb_novation_boot_quirk(struct usb_device *dev)\n{\n\tusb_set_interface(dev, 0, 1);\n\treturn 0;\n}", "target": 0}
{"code": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "int HeaderMapWrapper::luaPairs(lua_State* state) {\n  if (iterator_.get() != nullptr) {\n    luaL_error(state, \"cannot create a second iterator before completing the first\");\n  }\n  iterator_.reset(HeaderMapIterator::create(state, *this), true);\n  lua_pushcclosure(state, HeaderMapIterator::static_luaPairsIterator, 1);\n  return 1;\n}", "target": 0}
{"code": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}", "target": 1}
{"code": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\t\tif (!dst->anon_vma && src->anon_vma &&\n\t\t    anon_vma != src->anon_vma && anon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n enomem_failure:\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "GF_Err gf_isom_avc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleDescriptionBox *stsd;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc && !gf_sys_is_test_mode() )\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\tentry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\tif (!entry->avc_config) return GF_OUT_OF_MEM;\n\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\tif (!entry->avc_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}", "target": 0}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 0}
{"code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "int snd_card_register(struct snd_card *card)\n{\n\tint err;\n\tif (snd_BUG_ON(!card))\n\t\treturn -EINVAL;\n\tif (!card->registered) {\n\t\terr = device_add(&card->card_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tcard->registered = true;\n\t}\n\tif ((err = snd_device_register_all(card)) < 0)\n\t\treturn err;\n\tmutex_lock(&snd_card_mutex);\n\tif (snd_cards[card->number]) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\treturn 0;\n\t}\n\tif (*card->id) {\n\t\tchar tmpid[sizeof(card->id)];\n\t\tmemcpy(tmpid, card->id, sizeof(card->id));\n\t\tsnd_card_set_id_no_lock(card, tmpid, tmpid);\n\t} else {\n\t\tconst char *src;\n\t\tsrc = *card->shortname ? card->shortname : card->longname;\n\t\tsnd_card_set_id_no_lock(card, src,\n\t\t\t\t\tretrieve_id_from_card_name(src));\n\t}\n\tsnd_cards[card->number] = card;\n\tmutex_unlock(&snd_card_mutex);\n\tinit_info_for_card(card);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; \n    pb_size_t new_tag = field->tag; \n    if (old_tag == 0)\n        return true; \n    if (old_tag == new_tag)\n        return true; \n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n    pb_release_single_field(&old_field);\n    return true;\n}", "target": 1}
{"code": "static void ff_layout_write_release(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\tff_layout_write_record_layoutstats_done(&hdr->task, hdr);\n\tif (test_bit(NFS_IOHDR_RESEND_PNFS, &hdr->flags)) {\n\t\tff_layout_send_layouterror(hdr->lseg);\n\t\tff_layout_reset_write(hdr, true);\n\t} else if (test_bit(NFS_IOHDR_RESEND_MDS, &hdr->flags))\n\t\tff_layout_reset_write(hdr, false);\n\tpnfs_generic_rw_release(data);\n}", "target": 0}
{"code": "  CdsIntegrationTest()\n      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),\n                            ConfigHelper::discoveredClustersBootstrap(\n                                sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                    ? \"GRPC\"\n                                    : \"DELTA_GRPC\")) {\n    if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n      config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n    }\n    use_lds_ = false;\n    sotw_or_delta_ = sotwOrDelta();\n  }", "target": 1}
{"code": "vhost_user_reset_owner(struct virtio_net *dev)\n{\n\tif (dev->flags & VIRTIO_DEV_RUNNING) {\n\t\tdev->flags &= ~VIRTIO_DEV_RUNNING;\n\t\tdev->notify_ops->destroy_device(dev->vid);\n\t}\n\tcleanup_device(dev, 0);\n\treset_device(dev);\n\treturn 0;\n}", "target": 0}
{"code": "gdImagePtr gdImageCreateTrueColor (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(int), sx)) {\n\t\treturn NULL;\n\t}\n\tim = (gdImage *) gdMalloc(sizeof(gdImage));\n\tmemset(im, 0, sizeof(gdImage));\n\tim->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\tim->tpixels[i] = (int *) gdCalloc(sx, sizeof(int));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->trueColor = 1;\n\tim->saveAlphaFlag = 0;\n\tim->alphaBlendingFlag = 1;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 0}
{"code": "TEST(LteOp, MatchesMaxKey) {\n    BSONObj operand = BSON(\"a\" << MaxKey);\n    LTEMatchExpression lte(\"a\", operand[\"a\"]);\n    BSONObj minKeyObj = BSON(\"a\" << MinKey);\n    BSONObj maxKeyObj = BSON(\"a\" << MaxKey);\n    BSONObj numObj = BSON(\"a\" << 4);\n    ASSERT(lte.matchesBSON(minKeyObj, NULL));\n    ASSERT(lte.matchesBSON(maxKeyObj, NULL));\n    ASSERT(lte.matchesBSON(numObj, NULL));\n    ASSERT(lte.matchesSingleElement(minKeyObj.firstElement()));\n    ASSERT(lte.matchesSingleElement(maxKeyObj.firstElement()));\n    ASSERT(lte.matchesSingleElement(numObj.firstElement()));\n}", "target": 0}
{"code": "static void session_init_control(struct avrcp *session)\n{\n\tsession->passthrough_id = avctp_register_passthrough_handler(\n\t\t\t\t\t\t\tsession->conn,\n\t\t\t\t\t\t\thandle_passthrough,\n\t\t\t\t\t\t\tsession);\n\tsession->passthrough_handlers = passthrough_handlers;\n\tsession->control_id = avctp_register_pdu_handler(session->conn,\n\t\t\t\t\t\t\tAVC_OP_VENDORDEP,\n\t\t\t\t\t\t\thandle_vendordep_pdu,\n\t\t\t\t\t\t\tsession);\n\tsession->control_handlers = control_handlers;\n\tif (btd_device_get_service(session->dev, AVRCP_TARGET_UUID) != NULL)\n\t\tcontroller_init(session);\n\tif (btd_device_get_service(session->dev, AVRCP_REMOTE_UUID) != NULL)\n\t\ttarget_init(session);\n}", "target": 0}
{"code": "static void __reg_bound_offset32(struct bpf_reg_state *reg)\n{\n\tu64 mask = 0xffffFFFF;\n\tstruct tnum range = tnum_range(reg->umin_value & mask,\n\t\t\t\t       reg->umax_value & mask);\n\tstruct tnum lo32 = tnum_cast(reg->var_off, 4);\n\tstruct tnum hi32 = tnum_lshift(tnum_rshift(reg->var_off, 32), 32);\n\treg->var_off = tnum_or(hi32, tnum_intersect(lo32, range));\n}", "target": 0}
{"code": "static inline int ReadPropertyByte(const unsigned char **p,size_t *length)\n{\n  int\n    c;\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}", "target": 0}
{"code": "void ipc_rcu_getref(void *ptr)\n{\n\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n}", "target": 1}
{"code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather *tlb;\n\tstruct vm_area_struct *vma = mm->mmap;\n\tunsigned long nr_accounted = 0;\n\tunsigned long end;\n\tarch_exit_mmap(mm);\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb = tlb_gather_mmu(mm, 1);\n\tend = unmap_vmas(&tlb, vma, 0, -1, &nr_accounted, NULL);\n\tvm_unacct_memory(nr_accounted);\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, 0);\n\ttlb_finish_mmu(tlb, 0, end);\n\twhile (vma)\n\t\tvma = remove_vma(vma);\n\tBUG_ON(mm->nr_ptes > (FIRST_USER_ADDRESS+PMD_SIZE-1)>>PMD_SHIFT);\n}", "target": 0}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "static void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\tlist_del(&local->list);\n\tlocal_cleanup(local);\n\tkfree(local);\n}", "target": 1}
{"code": "int main(int ac, char *av[])\n{\n  int i, max_threads = 2;\n  pthread_t *threads;\n  if (ac < 2)\n    usage(av[0]);\n  queue = calloc(ac - 1, sizeof(queue[0]));\n  for (i = 1; i < ac; i++)\n  {\n    if (av[i][0] == '-')\n    {\n      if (av[i][1] == 'w')\n        use_camera_wb = 1;\n      if (av[i][1] == 'a')\n        use_auto_wb = 1;\n      if (av[i][1] == 'v')\n        verbose = 1;\n      if (av[i][1] == 'T')\n        tiff_mode = 1;\n      if (av[i][1] == 'J')\n      {\n        max_threads = atoi(av[++i]);\n        if (max_threads < 1)\n        {\n          fprintf(stderr, \"Job count should be at least 1\\n\");\n          exit(1);\n        }\n      }\n    }\n    else\n      queue[qsize++] = av[i];\n  }\n  pthread_mutex_init(&qm, NULL);\n  threads = calloc(max_threads, sizeof(threads[0]));\n  for (i = 0; i < max_threads; i++)\n    pthread_create(&threads[i], NULL, process_files, NULL);\n  for (i = 0; i < max_threads; i++)\n  {\n    int *iptr;\n    if (threads[i])\n    {\n      pthread_join(threads[i], (void *)&iptr);\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "static void evdev_cleanup(struct evdev *evdev)\n{\n\tstruct input_handle *handle = &evdev->handle;\n\tevdev_mark_dead(evdev);\n\tevdev_hangup(evdev);\n\tcdev_del(&evdev->cdev);\n\tif (evdev->open) {\n\t\tinput_flush_device(handle, NULL);\n\t\tinput_close_device(handle);\n\t}\n}", "target": 0}
{"code": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}", "target": 0}
{"code": "STATIC int\nS_edit_distance(const UV* src,\n                const UV* tgt,\n                const STRLEN x,             \n                const STRLEN y,             \n                const SSize_t maxDistance\n)\n{\n    item *head = NULL;\n    UV swapCount, swapScore, targetCharCount, i, j;\n    UV *scores;\n    UV score_ceil = x + y;\n    PERL_ARGS_ASSERT_EDIT_DISTANCE;\n    Newx(scores, ( (x + 2) * (y + 2)), UV);\n    scores[0] = score_ceil;\n    scores[1 * (y + 2) + 0] = score_ceil;\n    scores[0 * (y + 2) + 1] = score_ceil;\n    scores[1 * (y + 2) + 1] = 0;\n    head = uniquePush(uniquePush(head, src[0]), tgt[0]);\n    for (i=1;i<=x;i++) {\n        if (i < x)\n            head = uniquePush(head, src[i]);\n        scores[(i+1) * (y + 2) + 1] = i;\n        scores[(i+1) * (y + 2) + 0] = score_ceil;\n        swapCount = 0;\n        for (j=1;j<=y;j++) {\n            if (i == 1) {\n                if(j < y)\n                head = uniquePush(head, tgt[j]);\n                scores[1 * (y + 2) + (j + 1)] = j;\n                scores[0 * (y + 2) + (j + 1)] = score_ceil;\n            }\n            targetCharCount = find(head, tgt[j-1])->value;\n            swapScore = scores[targetCharCount * (y + 2) + swapCount] + i - targetCharCount - 1 + j - swapCount;\n            if (src[i-1] != tgt[j-1]){\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(swapScore,(MIN(scores[i * (y + 2) + j], MIN(scores[(i+1) * (y + 2) + j], scores[i * (y + 2) + (j + 1)])) + 1));\n            }\n            else {\n                swapCount = j;\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(scores[i * (y + 2) + j], swapScore);\n            }\n        }\n        find(head, src[i-1])->value = i;\n    }\n    {\n        IV score = scores[(x+1) * (y + 2) + (y + 1)];\n        dict_free(head);\n        Safefree(scores);\n        return (maxDistance != 0 && maxDistance < score)?(-1):score;\n    }", "target": 0}
{"code": "static void floppy_shutdown(struct work_struct *arg)\n{\n\tunsigned long flags;\n\tif (initialized)\n\t\tshow_floppy();\n\tcancel_activity();\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\tif (initialized)\n\t\tDPRINT(\"floppy timeout called\\n\");\n\tFDCS->reset = 1;\n\tif (cont) {\n\t\tcont->done(0);\n\t\tcont->redo();\t\n\t} else {\n\t\tpr_info(\"no cont in shutdown!\\n\");\n\t\tprocess_fd_request();\n\t}\n\tis_alive(__func__, \"\");\n}", "target": 0}
{"code": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}", "target": 1}
{"code": "static void fuse_freecontext(void *data)\n{\n    free(data);\n}", "target": 0}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "static void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "static void irda_connect_indication(void *instance, void *sap,\n\t\t\t\t    struct qos_info *qos, __u32 max_sdu_size,\n\t\t\t\t    __u8 max_header_size, struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tself = instance;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tself->max_header_size = max_header_size;\n\tself->max_sdu_size_tx = max_sdu_size;\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (max_sdu_size != 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size must be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif (max_sdu_size == 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size cannot be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = max_sdu_size;\n\t\tbreak;\n\tdefault:\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t}\n\tIRDA_DEBUG(2, \"%s(), max_data_size=%d\\n\", __func__,\n\t\t   self->max_data_size);\n\tmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_state_change(sk);\n}", "target": 0}
{"code": "static unsigned etag_match(const char *hdr[], const char *etag)\n{\n    unsigned i, match = 0;\n    tok_t tok;\n    char *token;\n    for (i = 0; !match && hdr[i]; i++) {\n        tok_init(&tok, hdr[i], \",\", TOK_TRIMLEFT|TOK_TRIMRIGHT);\n        while (!match && (token = tok_next(&tok))) {\n            if (!etagcmp(token, etag)) match = 1;\n        }\n        tok_fini(&tok);\n    }\n    return match;\n}", "target": 0}
{"code": "static void bnx2x_after_function_update(struct bnx2x *bp)\n{\n\tint q, rc;\n\tstruct bnx2x_fastpath *fp;\n\tstruct bnx2x_queue_state_params queue_params = {NULL};\n\tstruct bnx2x_queue_update_params *q_update_params =\n\t\t&queue_params.params.update;\n\tqueue_params.cmd = BNX2X_Q_CMD_UPDATE;\n\t__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM_CHNG,\n\t\t  &q_update_params->update_flags);\n\t__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM,\n\t\t  &q_update_params->update_flags);\n\t__set_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\n\tif (bp->afex_vlan_mode == FUNC_MF_CFG_AFEX_VLAN_ACCESS_MODE) {\n\t\tq_update_params->silent_removal_value = 0;\n\t\tq_update_params->silent_removal_mask = 0;\n\t} else {\n\t\tq_update_params->silent_removal_value =\n\t\t\t(bp->afex_def_vlan_tag & VLAN_VID_MASK);\n\t\tq_update_params->silent_removal_mask = VLAN_VID_MASK;\n\t}\n\tfor_each_eth_queue(bp, q) {\n\t\tfp = &bp->fp[q];\n\t\tqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\t\trc = bnx2x_queue_state_change(bp, &queue_params);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to config silent vlan rem for Q %d\\n\",\n\t\t\t\t  q);\n\t}\n\tif (!NO_FCOE(bp) && CNIC_ENABLED(bp)) {\n\t\tfp = &bp->fp[FCOE_IDX(bp)];\n\t\tqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\t\t__clear_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(BNX2X_AFEX_FCOE_Q_UPDATE_PENDING, &bp->sp_state);\n\t\tsmp_mb__after_atomic();\n\t\trc = bnx2x_queue_state_change(bp, &queue_params);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to config silent vlan rem for Q %d\\n\",\n\t\t\t\t  q);\n\t} else {\n\t\tbnx2x_link_report(bp);\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_VIFSET_ACK, 0);\n\t}\n}", "target": 0}
{"code": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tinit_emulate_ctxt(vcpu);\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\treturn r;\n}", "target": 1}
{"code": "static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); \n\tchar *endptr;\n\tif (hexadecimal && (**buf != '\\0'))\n\t\t(*buf)++;\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t*buf = endptr;\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\treturn SUCCESS;\n}", "target": 1}
{"code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}", "target": 1}
{"code": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}", "target": 1}
{"code": "mrb_prev_pc(codegen_scope *s, const mrb_code *pc)\n{\n  const mrb_code *prev_pc = NULL;\n  const mrb_code *i = s->iseq;\n  while (i<pc) {\n    uint8_t insn = i[0];\n    prev_pc = i;\n    switch (insn) {\n    case OP_EXT1:\n      i += mrb_insn_size1[i[1]] + 1;\n      break;\n    case OP_EXT2:\n      i += mrb_insn_size2[i[1]] + 1;\n      break;\n    case OP_EXT3:\n      i += mrb_insn_size3[i[1]] + 1;\n      break;\n    default:\n      i += mrb_insn_size[insn];\n      break;\n    }\n  }\n  return prev_pc;\n}", "target": 0}
{"code": "static bool io_wq_for_each_worker(struct io_wqe *wqe,\n\t\t\t\t  bool (*func)(struct io_worker *, void *),\n\t\t\t\t  void *data)\n{\n\tstruct io_worker *worker;\n\tbool ret = false;\n\tlist_for_each_entry_rcu(worker, &wqe->all_list, all_list) {\n\t\tif (io_worker_get(worker)) {\n\t\t\tif (worker->task)\n\t\t\t\tret = func(worker, data);\n\t\t\tio_worker_release(worker);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "hb_map_clear (hb_map_t *map)\n{\n  if (unlikely (hb_object_is_immutable (map)))\n    return;\n  return map->clear ();\n}", "target": 1}
{"code": "static struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}", "target": 0}
{"code": "lexer_process_char_literal (parser_context_t *context_p, \n                            const uint8_t *char_p, \n                            size_t length, \n                            uint8_t literal_type, \n                            bool has_escape) \n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  uint32_t literal_index = 0;\n  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_STRING_LITERAL);\n  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);\n  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == literal_type\n        && literal_p->prop.length == length\n        && memcmp (literal_p->u.char_p, char_p, length) == 0)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);\n      return;\n    }\n    literal_index++;\n  }\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n   }\n   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n   literal_p->prop.length = (uint16_t) length;\n   literal_p->type = literal_type;\n  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;\n  if (has_escape)\n  {\n    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);\n    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);\n  }\n  else\n  {\n    literal_p->u.char_p = char_p;\n  }\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n  context_p->literal_count++;\n} ", "target": 1}
{"code": "Status InferenceContext::Multiply(DimensionHandle first,\n                                  DimensionOrConstant second,\n                                  DimensionHandle* out) {\n  const int64_t first_value = Value(first);\n  const int64_t second_value = Value(second);\n  if (first_value == 0) {\n    *out = first;\n  } else if (second_value == 0) {\n    *out = MakeDim(second);\n  } else if (first_value == 1) {\n    *out = MakeDim(second);\n  } else if (second_value == 1) {\n    *out = first;\n  } else if (first_value == kUnknownDim || second_value == kUnknownDim) {\n    *out = UnknownDim();\n  } else {\n    const int64_t product = first_value * second_value;\n    if (product < 0) {\n      return errors::InvalidArgument(\n          \"Negative dimension size caused by overflow when multiplying \",\n          first_value, \" and \", second_value);\n    }\n    *out = MakeDim(product);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\treturn ret;\n}", "target": 1}
{"code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n\t    wp += n + stride - 1;\t\n\t    ip += n + stride - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "target": 1}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "ospf_ls_req_send (struct ospf_neighbor *nbr)\n{\n  struct ospf_interface *oi;\n  struct ospf_packet *op;\n  u_int16_t length = OSPF_HEADER_SIZE;\n  oi = nbr->oi;\n  op = ospf_packet_new (oi->ifp->mtu);\n  ospf_make_header (OSPF_MSG_LS_REQ, oi, op->s);\n  length += ospf_make_ls_req (nbr, op->s);\n  if (length == OSPF_HEADER_SIZE)\n    {\n      ospf_packet_free (op);\n      return;\n    }\n  ospf_fill_header (oi, op->s, length);\n  op->length = length;\n  if (oi->type == OSPF_IFTYPE_POINTOPOINT) \n    op->dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else\n    op->dst = nbr->address.u.prefix4;\n  ospf_packet_add (oi, op);\n  OSPF_ISM_WRITE_ON (oi->ospf);\n  OSPF_NSM_TIMER_ON (nbr->t_ls_req, ospf_ls_req_timer, nbr->v_ls_req);\n}", "target": 0}
{"code": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){\n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, LteWithRHSFieldPathMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: {$lte: [3, '$x']}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 3)));\n    ASSERT_TRUE(matches(BSON(\"x\" << 10)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 1)));\n}", "target": 0}
{"code": "static int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (fence->error)\n\t\t\treturn fence->error;\n\t}\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n}", "target": 1}
{"code": "void PdfXRefStreamParserObject::ReadXRefTable()\n{\n    int64_t size = this->GetDictionary().FindKeyAs<int64_t>(PdfName::KeySize, 0);\n    auto& arrObj = this->GetDictionary().MustFindKey(\"W\");\n    const PdfArray* arr;\n    if (!arrObj.TryGetArray(arr) || arr->size() != 3)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n    int64_t wArray[W_ARRAY_SIZE] = { 0, 0, 0 };\n    int64_t num;\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (!(*arr)[i].TryGetNumber(num))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n        wArray[i] = num;\n    }\n    vector<int64_t> indices;\n    getIndices(indices, static_cast<int64_t>(size));\n    parseStream(wArray, indices);\n}", "target": 1}
{"code": "test_save_copy (const char *origname)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", origname, TEST_COPY_FILE);\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 1}
{"code": "static int log_access_ok(void __user *log_base, u64 addr, unsigned long sz)\n{\n\tu64 a = addr / VHOST_PAGE_SIZE / 8;\n\tif (a > ULONG_MAX - (unsigned long)log_base ||\n\t    a + (unsigned long)log_base > ULONG_MAX)\n\t\treturn 0;\n\treturn access_ok(VERIFY_WRITE, log_base + a,\n\t\t\t (sz + VHOST_PAGE_SIZE * 8 - 1) / VHOST_PAGE_SIZE / 8);\n}", "target": 0}
{"code": "njs_string_to_number(const njs_value_t *value, njs_bool_t parse_float)\n{\n    double             num;\n    njs_bool_t         minus;\n    const u_char       *p, *start, *end;\n    njs_string_prop_t  string;\n    const size_t  infinity = njs_length(\"Infinity\");\n    (void) njs_string_trim(value, &string, NJS_TRIM_START);\n    p = string.start;\n    end = p + string.size;\n    if (p == end) {\n        return parse_float ? NAN : 0.0;\n    }\n    minus = 0;\n    if (*p == '+') {\n        p++;\n    } else if (*p == '-') {\n        p++;\n        minus = 1;\n    }\n    if (p == end) {\n        return NAN;\n    }\n    if (!parse_float\n        && p + 2 < end && p[0] == '0' && (p[1] == 'x' || p[1] == 'X'))\n    {\n        p += 2;\n        num = njs_number_hex_parse(&p, end, 0);\n    } else {\n        start = p;\n        num = njs_number_dec_parse(&p, end, 0);\n        if (p == start) {\n            if (p + infinity > end || memcmp(p, \"Infinity\", infinity) != 0) {\n                return NAN;\n            }\n            num = INFINITY;\n            p += infinity;\n        }\n    }\n    if (!parse_float) {\n        while (p < end) {\n            if (*p != ' ' && *p != '\\t') {\n                return NAN;\n            }\n            p++;\n        }\n    }\n    return minus ? -num : num;\n}", "target": 0}
{"code": "cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,\n                                       const char* Name,\n                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])\n{\n    cmsUInt32Number i;\n    if (NamedColorList == NULL) return FALSE;\n    if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {\n        if (!GrowNamedColorList(NamedColorList)) return FALSE;\n    }\n    for (i=0; i < NamedColorList ->ColorantCount; i++)\n        NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i];\n    for (i=0; i < 3; i++)\n        NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i];\n    if (Name != NULL) {\n        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,\n                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name));\n        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;\n    }\n    else\n        NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0;\n    NamedColorList ->nColors++;\n    return TRUE;\n}", "target": 1}
{"code": "read_password(FILE *in, FILE *out, char *buf, size_t bufsz)\n{\n\tint infd = fileno(in);\n\tstruct termios tio;\n\tchar *ret;\n\tret = fgets(buf, bufsz, in);\n\tif (isatty(infd)) {\n\t\tfprintf(out, \"\\n\");\n\t\tfflush(out);\n\t\ttcgetattr(infd, &tio);\n\t\ttio.c_lflag |= ECHO;\n\t\ttcsetattr(infd, TCSAFLUSH, &tio);\n\t}\n\tif (ret == NULL)\n\t\treturn -1;\n\tbuf[strlen(buf)-1] = '\\0';\n\treturn 0;\n}", "target": 0}
{"code": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_make_cookie_ack(const struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tretval = sctp_make_control(asoc, SCTP_CID_COOKIE_ACK, 0, 0, GFP_ATOMIC);\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\treturn retval;\n}", "target": 0}
{"code": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}", "target": 1}
{"code": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::OnGpuSwapBuffersCompletedInternal(\n    const ui::LatencyInfo& latency_info) {\n  ui::LatencyInfo::LatencyComponent window_snapshot_component;\n  if (latency_info.FindLatency(ui::BROWSER_SNAPSHOT_FRAME_NUMBER_COMPONENT,\n                               GetLatencyComponentId(),\n                               &window_snapshot_component)) {\n    int sequence_number =\n        static_cast<int>(window_snapshot_component.sequence_number);\n#if defined(OS_MACOSX) || defined(OS_WIN)\n    base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(\n        FROM_HERE,\n        base::Bind(&RenderWidgetHostImpl::WindowSnapshotReachedScreen,\n                   weak_factory_.GetWeakPtr(), sequence_number),\n        base::TimeDelta::FromSecondsD(1. / 6));\n#else\n    WindowSnapshotReachedScreen(sequence_number);\n#endif\n  }\n  latency_tracker_.OnGpuSwapBuffersCompleted(latency_info);\n}", "target": 0}
{"code": "RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server,\n                                 GeneralRequest* request, GeneralResponse* response)\n    : RestVocbaseBaseHandler(server, request, response),\n      _validFor(60 * 60 * 24 * 30) {}", "target": 1}
{"code": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}", "target": 1}
{"code": "int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n}", "target": 1}
{"code": "  int DoWrite(WriteWrap* w,\n              uv_buf_t* bufs,\n              size_t count,\n              uv_stream_t* send_handle) override {\n    return UV_ENOSYS;  \n  }", "target": 1}
{"code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "memcmp_constant_time (const void *a, const void *b, size_t size) {\n  const uint8_t * a1 = a;\n  const uint8_t * b1 = b;\n  int ret = 0;\n  size_t i;\n  for (i = 0; i < size; i++) {\n      ret |= *a1++ ^ *b1++;\n  }\n  return ret;\n}", "target": 0}
{"code": "int reds_on_migrate_dst_set_seamless(RedsState *reds, MainChannelClient *mcc, uint32_t src_version)\n{\n    if (reds->allow_multiple_clients  || src_version > SPICE_MIGRATION_PROTOCOL_VERSION) {\n        reds->dst_do_seamless_migrate = FALSE;\n    } else {\n        RedClient *client = mcc->get_client();\n        client->set_migration_seamless();\n        reds->dst_do_seamless_migrate = reds_link_mig_target_channels(reds, client);\n    }\n    return reds->dst_do_seamless_migrate;\n}", "target": 0}
{"code": "static int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight->stream[stream_id];\n    int previous_out;\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight->tight.buffer, vs->tight->tight.offset);\n        return bytes;\n    }\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n    buffer_reserve(&vs->tight->zlib, bytes + 64);\n    zstream->next_in = vs->tight->tight.buffer;\n    zstream->avail_in = vs->tight->tight.offset;\n    zstream->next_out = vs->tight->zlib.buffer + vs->tight->zlib.offset;\n    zstream->avail_out = vs->tight->zlib.capacity - vs->tight->zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n    vs->tight->zlib.offset = vs->tight->zlib.capacity - zstream->avail_out;\n    bytes = previous_out - zstream->avail_out;\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight->zlib.buffer, bytes);\n    buffer_reset(&vs->tight->zlib);\n    return bytes;\n}", "target": 0}
{"code": "skipString(const xmlChar *cur, int end) {\n    xmlChar limit;\n    if ((cur == NULL) || (end < 0)) return(-1);\n    if ((cur[end] == '\\'') || (cur[end] == '\"')) limit = cur[end];\n    else return(end);\n    end++;\n    while (cur[end] != 0) {\n        if (cur[end] == limit)\n\t    return(end + 1);\n\tend++;\n    }\n    return(-1);\n}", "target": 0}
{"code": "ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(Navigator& navigator, ExceptionState& exceptionState)\n {\n     return NavigatorServiceWorker::from(navigator).serviceWorker(exceptionState);\n }", "target": 1}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 0}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int get_user_page_nowait(struct task_struct *tsk, struct mm_struct *mm,\n\tunsigned long start, int write, struct page **page)\n{\n\tint flags = FOLL_TOUCH | FOLL_NOWAIT | FOLL_HWPOISON | FOLL_GET;\n\tif (write)\n\t\tflags |= FOLL_WRITE;\n\treturn __get_user_pages(tsk, mm, start, 1, flags, page, NULL, NULL);\n}", "target": 0}
{"code": "PHP_XML_API zend_string *xml_utf8_encode(const char *s, size_t len, const XML_Char *encoding)\n{\n\tsize_t pos = len;\n\tzend_string *str;\n\tunsigned int c;\n\tunsigned short (*encoder)(unsigned char) = NULL;\n\txml_encoding *enc = xml_get_encoding(encoding);\n\tif (enc) {\n\t\tencoder = enc->encoding_function;\n\t} else {\n\t\treturn NULL;\n\t}\n\tif (encoder == NULL) {\n\t\tstr = zend_string_init(s, len, 0);\n\t\treturn str;\n\t}\n\tstr = zend_string_alloc(len * 4, 0);\n\tZSTR_LEN(str) = 0;\n\twhile (pos > 0) {\n\t\tc = encoder ? encoder((unsigned char)(*s)) : (unsigned short)(*s);\n\t\tif (c < 0x80) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (char) c;\n\t\t} else if (c < 0x800) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | (c >> 6));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t} else if (c < 0x10000) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xe0 | (c >> 12));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | ((c >> 6) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t} else if (c < 0x200000) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xf0 | (c >> 18));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xe0 | ((c >> 12) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | ((c >> 6) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t}\n\t\tpos--;\n\t\ts++;\n\t}\n\tZSTR_VAL(str)[ZSTR_LEN(str)] = '\\0';\n\tstr = zend_string_truncate(str, ZSTR_LEN(str), 0);\n\treturn str;\n}", "target": 1}
{"code": "read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n{\n\tint\t  ret;\n\tstatic uint32_t\t\tlen = 0;\n\tstatic char\t\tlen_buf[4];\n\tstatic int\t\tlen_buf_pos = 0;\n\tstatic char *\t\ttmpbuf = 0;\n\tstatic int\t\ttmpbuf_pos = 0;\n\tif (first) {\n\t\tlen_buf_pos = 0;\n\t\treturn -2;\n\t}\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\t\tif (ret == 0) {\t\t\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\treturn -1;\n\t\t}\n\t\tlen_buf_pos += ret;\n\t}\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\tlen = ntohl(*(uint32_t *)len_buf);\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\treturn -1;\n\t}\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\treturn -1;\n\t}\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\treturn -1;\n\t}\n\ttmpbuf_pos += ret;\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\treturn -2;\n}", "target": 1}
{"code": "jio_snprintf(char * str, int n, const char * format, ...)\n{\n\tva_list args;\n\tint result;\n\tTrc_SC_snprintf_Entry();\n\tva_start(args, format);\n#if defined(WIN32) && !defined(WIN32_IBMC)\n\tresult = _vsnprintf( str, n, format, args );\n#else\n\tresult = vsprintf( str, format, args );\n#endif\n\tva_end(args);\n\tTrc_SC_snprintf_Exit(result);\n\treturn result;\n}", "target": 1}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    next_start_code_studio(gb);\n}", "target": 1}
{"code": "static int unlock_full_stripe(struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t      bool locked)\n{\n\tstruct btrfs_block_group_cache *bg_cache;\n\tstruct btrfs_full_stripe_locks_tree *locks_root;\n\tstruct full_stripe_lock *fstripe_lock;\n\tu64 fstripe_start;\n\tbool freeit = false;\n\tint ret = 0;\n\tif (!locked)\n\t\treturn 0;\n\tbg_cache = btrfs_lookup_block_group(fs_info, bytenr);\n\tif (!bg_cache) {\n\t\tASSERT(0);\n\t\treturn -ENOENT;\n\t}\n\tif (!(bg_cache->flags & BTRFS_BLOCK_GROUP_RAID56_MASK))\n\t\tgoto out;\n\tlocks_root = &bg_cache->full_stripe_locks_root;\n\tfstripe_start = get_full_stripe_logical(bg_cache, bytenr);\n\tmutex_lock(&locks_root->lock);\n\tfstripe_lock = search_full_stripe_lock(locks_root, fstripe_start);\n\tif (!fstripe_lock) {\n\t\tWARN_ON(1);\n\t\tret = -ENOENT;\n\t\tmutex_unlock(&locks_root->lock);\n\t\tgoto out;\n\t}\n\tif (fstripe_lock->refs == 0) {\n\t\tWARN_ON(1);\n\t\tbtrfs_warn(fs_info, \"full stripe lock at %llu refcount underflow\",\n\t\t\tfstripe_lock->logical);\n\t} else {\n\t\tfstripe_lock->refs--;\n\t}\n\tif (fstripe_lock->refs == 0) {\n\t\trb_erase(&fstripe_lock->node, &locks_root->root);\n\t\tfreeit = true;\n\t}\n\tmutex_unlock(&locks_root->lock);\n\tmutex_unlock(&fstripe_lock->mutex);\n\tif (freeit)\n\t\tkfree(fstripe_lock);\nout:\n\tbtrfs_put_block_group(bg_cache);\n\treturn ret;\n}", "target": 0}
{"code": "PHP_FUNCTION(xsl_xsltprocessor_set_security_prefs)\n{\n\tzval *id;\n\txsl_object *intern;\n\tlong securityPrefs, oldSecurityPrefs;\n\tDOM_GET_THIS(id);\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &securityPrefs) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n\toldSecurityPrefs = intern->securityPrefs;\n\tintern->securityPrefs = securityPrefs;\n\tintern->securityPrefsSet = 1;\n\tRETURN_LONG(oldSecurityPrefs);\n}", "target": 0}
{"code": "static int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tret = __nla_validate(nla_data(entry), nla_len(entry),\n\t\t\t\t     maxtype, policy, validate, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int pdf_load_xrefs(FILE *fp, pdf_t *pdf)\n{\n    int  i, ver, is_linear;\n    long pos, pos_count;\n    char x, *c, buf[256];\n    c = NULL;\n    pdf->n_xrefs = 0;\n    fseek(fp, 0, SEEK_SET);\n    while (get_next_eof(fp) >= 0)\n      ++pdf->n_xrefs;\n    if (!pdf->n_xrefs)\n      return 0;\n    fseek(fp, 0, SEEK_SET);\n    pdf->xrefs = calloc(1, sizeof(xref_t) * pdf->n_xrefs);\n    ver = 1;\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if ((pos = get_next_eof(fp)) < 0)\n          break;\n        pdf->xrefs[i].version = ver++;\n        pos_count = 0;\n        while (SAFE_F(fp, ((x = fgetc(fp)) != 'f')))\n          fseek(fp, pos - (++pos_count), SEEK_SET);\n        if (pos_count >= sizeof(buf)) {\n          ERR(\"Failed to locate the startxref token. \"\n              \"This might be a corrupt PDF.\\n\");\n          return -1;\n        }\n        memset(buf, 0, sizeof(buf));\n        SAFE_E(fread(buf, 1, pos_count, fp), pos_count,\n               \"Failed to read startxref.\\n\");\n        c = buf;\n        while (*c == ' ' || *c == '\\n' || *c == '\\r')\n          ++c;\n        pdf->xrefs[i].start = atol(c);\n        if (pdf->xrefs[i].start == 0)\n          get_xref_linear_skipped(fp, &pdf->xrefs[i]);\n        else\n        {\n            pos = ftell(fp);\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            pdf->xrefs[i].end = get_next_eof(fp);\n            fseek(fp, pos, SEEK_SET);\n        }\n        if (!is_valid_xref(fp, pdf, &pdf->xrefs[i]))\n        {\n            is_linear = pdf->xrefs[i].is_linear;\n            memset(&pdf->xrefs[i], 0, sizeof(xref_t));\n            pdf->xrefs[i].is_linear = is_linear;\n            rewind(fp);\n            get_next_eof(fp);\n            continue;\n        }\n        load_xref_entries(fp, &pdf->xrefs[i]);\n    }\n    if (pdf->xrefs[0].is_linear)\n      resolve_linearized_pdf(pdf);\n    load_creator(fp, pdf);\n    return pdf->n_xrefs;\n}", "target": 1}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "bool RenderView::allowImages(WebFrame* frame, bool enabled_per_settings) {\n  if (enabled_per_settings &&\n      AllowContentType(CONTENT_SETTINGS_TYPE_IMAGES))\n    return true;\n  if (IsWhitelistedForContentSettings(frame))\n    return true;\n  DidBlockContentType(CONTENT_SETTINGS_TYPE_IMAGES);\n  return false;  \n}", "target": 0}
{"code": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page->index,\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}", "target": 1}
{"code": "static inline bool cpu_has_vmx_apic_register_virt(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT;\n}", "target": 0}
{"code": "Variant HHVM_FUNCTION(mcrypt_get_block_size, const String& cipher,\n                                    const Variant& module ) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.asCStrRef().data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_block_size\");\n    return false;\n  }\n  int64_t ret = mcrypt_enc_get_block_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}", "target": 1}
{"code": "void free_key_material(key_material_t* pkey)\n{\n\tint i;\n\tif (!pkey)\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; i < TAG_MAX; i++)\n\t{\n\t\tif (pkey[i].big)\n\t\t{\n\t\t\tfree(pkey[i].big);\n\t\t}\n\t}\n}", "target": 0}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "is_empty(const uint8_t *data, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size && data[i] != '\\n'; i++)\n\t\tif (data[i] != ' ')\n\t\t\treturn 0;\n\treturn i + 1;\n}", "target": 0}
{"code": "static inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\tle32_to_cpu(raw_inode->i_size_lo);", "target": 1}
{"code": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\t_gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);\n\t\t\tpk->keyid[0] = _cdk_buftou32(buf + 12);\n\t\t\tpk->keyid[1] = _cdk_buftou32(buf + 16);\n\t\t}\n\t}\n\tlowbits = pk ? pk->keyid[1] : 0;\n\tif (keyid && pk) {\n\t\tkeyid[0] = pk->keyid[0];\n\t\tkeyid[1] = pk->keyid[1];\n\t}\n\treturn lowbits;\n}", "target": 1}
{"code": "static int vsock_create(struct net *net, struct socket *sock,\n\t\t\tint protocol, int kern)\n{\n\tif (!sock)\n\t\treturn -EINVAL;\n\tif (protocol && protocol != PF_VSOCK)\n\t\treturn -EPROTONOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tsock->ops = &vsock_dgram_ops;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsock->ops = &vsock_stream_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsock->state = SS_UNCONNECTED;\n\treturn __vsock_create(net, sock, NULL, GFP_KERNEL, 0) ? 0 : -ENOMEM;\n}", "target": 0}
{"code": "static IHEVCD_ERROR_T ihevcd_parse_profile_tier_level_layer(bitstrm_t *ps_bitstrm,\n profile_tier_lvl_t *ps_ptl)\n{\n    WORD32 value;\n    WORD32 i;\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    BITS_PARSE(\"XXX_profile_space[]\", value, ps_bitstrm, 2);\n    ps_ptl->i1_profile_space = value;\n    BITS_PARSE(\"XXX_tier_flag[]\", value, ps_bitstrm, 1);\n    ps_ptl->i1_tier_flag = value;\n    BITS_PARSE(\"XXX_profile_idc[]\", value, ps_bitstrm, 5);\n    ps_ptl->i1_profile_idc = value;\n for(i = 0; i < MAX_PROFILE_COMPATBLTY; i++)\n {\n        BITS_PARSE(\"XXX_profile_compatibility_flag[][j]\", value, ps_bitstrm, 1);\n        ps_ptl->ai1_profile_compatibility_flag[i] = value;\n }\n    BITS_PARSE(\"general_progressive_source_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_progressive_source_flag = value;\n    BITS_PARSE(\"general_interlaced_source_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_interlaced_source_flag = value;\n    BITS_PARSE(\"general_non_packed_constraint_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_non_packed_constraint_flag = value;\n    BITS_PARSE(\"general_frame_only_constraint_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_frame_only_constraint_flag = value;\n    BITS_PARSE(\"XXX_reserved_zero_44bits[0..15]\", value, ps_bitstrm, 16);\n    BITS_PARSE(\"XXX_reserved_zero_44bits[16..31]\", value, ps_bitstrm, 16);\n    BITS_PARSE(\"XXX_reserved_zero_44bits[32..43]\", value, ps_bitstrm, 12);\n return ret;\n}", "target": 0}
{"code": "yang_deviate_delete_unique(struct lys_module *module, struct lys_deviate *deviate,\n                           struct lys_node_list *list, int index, char * value)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, k;\n    for (i = 0; i < list->unique_size; i++) {\n        if (list->unique[i].expr_size != deviate->unique[index].expr_size) {\n            continue;\n        }\n        for (j = 0; j < deviate->unique[index].expr_size; j++) {\n            if (!ly_strequal(list->unique[i].expr[j], deviate->unique[index].expr[j], 1)) {\n                break;\n            }\n        }\n        if (j == deviate->unique[index].expr_size) {\n            for (j = 0; j < list->unique[i].expr_size; j++) {\n                lydict_remove(ctx, list->unique[i].expr[j]);\n            }\n            free(list->unique[i].expr);\n            list->unique_size--;\n            if (i != list->unique_size) {\n                list->unique[i].expr_size = list->unique[list->unique_size].expr_size;\n                list->unique[i].expr = list->unique[list->unique_size].expr;\n            }\n            if (!list->unique_size) {\n                free(list->unique);\n                list->unique = NULL;\n            } else {\n                list->unique[list->unique_size].expr_size = 0;\n                list->unique[list->unique_size].expr = NULL;\n            }\n            k = i; \n            i = -1; \n            break;\n        }\n    }\n    if (i != -1) {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n        return EXIT_FAILURE;\n    }\n    j = -1;\n    while ((j = lys_ext_iter(list->ext, list->ext_size, j + 1, LYEXT_SUBSTMT_UNIQUE)) != -1) {\n        if (list->ext[j]->insubstmt_index == k) {\n            lyp_ext_instance_rm(ctx, &list->ext, &list->ext_size, j);\n            --j;\n        } else if (list->ext[j]->insubstmt_index > k) {\n            list->ext[j]->insubstmt_index--;\n        }\n    }\n    return EXIT_SUCCESS;\n}", "target": 0}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        return CalculateOutputIndexValueRowID(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        return CalculateOutputIndexRowSplit(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "lexer_scan_identifier (parser_context_t *context_p, \n                       bool propety_name) \n{\n  skip_spaces (context_p);\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n  if (context_p->source_p < context_p->source_end_p\n      && (lit_char_is_identifier_start (context_p->source_p) || context_p->source_p[0] == LIT_CHAR_BACKSLASH))\n  {\n    lexer_parse_identifier (context_p, false);\n    if (propety_name && context_p->token.lit_location.length == 3)\n    {\n      skip_spaces (context_p);\n      if (context_p->source_p < context_p->source_end_p\n          && context_p->source_p[0] != LIT_CHAR_COLON)\n      {\n        if (lexer_compare_identifier_to_current (context_p, &lexer_get_literal))\n        {\n          context_p->token.type = LEXER_PROPERTY_GETTER;\n        }\n        else if (lexer_compare_identifier_to_current (context_p, &lexer_set_literal))\n        {\n          context_p->token.type = LEXER_PROPERTY_SETTER;\n        }\n      }\n    }\n    return;\n  }\n  if (propety_name)\n  {\n    lexer_next_token (context_p);\n    if (context_p->token.type == LEXER_LITERAL\n        || context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      return;\n    }\n  }\n  parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n} ", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr && sz >= offset) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;\n\t\tattr->info.annotation_default_attr.default_value = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (attr->info.annotation_default_attr.default_value) {\n\t\t\toffset += attr->info.annotation_default_attr.default_value->size;\n\t\t}\n\t}\n\tr_bin_java_print_annotation_default_attr_summary (attr);\n\treturn attr;\n}", "target": 1}
{"code": "    int CommentValue::read(const byte* buf, size_t len, ByteOrder byteOrder)\n    {\n        byteOrder_ = byteOrder;\n        return StringValueBase::read(buf, len, byteOrder);\n    }", "target": 0}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}", "target": 1}
{"code": "static ssize_t ppp_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t ret;\n\tstruct sk_buff *skb = NULL;\n\tstruct iovec iov;\n\tstruct iov_iter to;\n\tret = count;\n\tif (!pf)\n\t\treturn -ENXIO;\n\tadd_wait_queue(&pf->rwait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&pf->rq);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (pf->dead)\n\t\t\tbreak;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\t\t\tif (ppp->n_channels == 0 &&\n\t\t\t    (ppp->flags & SC_LOOP_TRAFFIC) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&pf->rwait, &wait);\n\tif (!skb)\n\t\tgoto out;\n\tret = -EOVERFLOW;\n\tif (skb->len > count)\n\t\tgoto outf;\n\tret = -EFAULT;\n\tiov.iov_base = buf;\n\tiov.iov_len = count;\n\tiov_iter_init(&to, READ, &iov, 1, count);\n\tif (skb_copy_datagram_iter(skb, 0, &to, skb->len))\n\t\tgoto outf;\n\tret = skb->len;\n outf:\n\tkfree_skb(skb);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !ap_cstr_casecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 1}
{"code": "    void RafImage::setIptcData(const IptcData& )\n    {\n        throw(Error(kerInvalidSettingForImage, \"IPTC metadata\", \"RAF\"));\n    }", "target": 0}
{"code": "static void __init taa_select_mitigation(void)\n{\n\tu64 ia32_cap;\n\tif (!boot_cpu_has_bug(X86_BUG_TAA)) {\n\t\ttaa_mitigation = TAA_MITIGATION_OFF;\n\t\treturn;\n\t}\n\tif (!boot_cpu_has(X86_FEATURE_RTM)) {\n\t\ttaa_mitigation = TAA_MITIGATION_TSX_DISABLED;\n\t\tgoto out;\n\t}\n\tif (cpu_mitigations_off()) {\n\t\ttaa_mitigation = TAA_MITIGATION_OFF;\n\t\treturn;\n\t}\n\tif (taa_mitigation == TAA_MITIGATION_OFF &&\n\t    mds_mitigation == MDS_MITIGATION_OFF)\n\t\tgoto out;\n\tif (boot_cpu_has(X86_FEATURE_MD_CLEAR))\n\t\ttaa_mitigation = TAA_MITIGATION_VERW;\n\telse\n\t\ttaa_mitigation = TAA_MITIGATION_UCODE_NEEDED;\n\tia32_cap = x86_read_arch_cap_msr();\n\tif ( (ia32_cap & ARCH_CAP_MDS_NO) &&\n\t    !(ia32_cap & ARCH_CAP_TSX_CTRL_MSR))\n\t\ttaa_mitigation = TAA_MITIGATION_UCODE_NEEDED;\n\tstatic_branch_enable(&mds_user_clear);\n\tif (taa_nosmt || cpu_mitigations_auto_nosmt())\n\t\tcpu_smt_disable(false);\n\tif (mds_mitigation == MDS_MITIGATION_OFF &&\n\t    boot_cpu_has_bug(X86_BUG_MDS)) {\n\t\tmds_mitigation = MDS_MITIGATION_FULL;\n\t\tmds_select_mitigation();\n\t}\nout:\n\tpr_info(\"%s\\n\", taa_strings[taa_mitigation]);\n}", "target": 0}
{"code": "static double util_pointsize( wmfAPI* API, wmfFont* font, char* str, double font_height, ExceptionInfo *exception)\n{\n  wmf_magick_t\n    *ddata = WMF_MAGICK_GetData(API);\n  Image\n    *image = ddata->image;\n  TypeMetric\n    metrics;\n  DrawInfo\n    *draw_info;\n  double\n    pointsize = 0;\n  draw_info=ddata->draw_info;\n  if (draw_info == (const DrawInfo *) NULL)\n    return 0;\n  draw_info->font=WMF_FONT_PSNAME(font);\n  draw_info->pointsize=font_height;\n  draw_info->text=str;\n  if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n    {\n      if (strlen(str) == 1)\n        {\n          pointsize = (font_height *\n                       ( font_height / (metrics.ascent + fabs(metrics.descent))));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / ( metrics.ascent + fabs(metrics.descent)));\n        }\n      else\n        {\n          pointsize = (font_height * (font_height / (metrics.height)));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / metrics.height);\n        }\n#if 0\n      draw_info.pointsize = pointsize;\n      if (GetTypeMetrics(image, &draw_info, &metrics, exception) != MagickFalse)\n        pointsize *= (font_height / (metrics.ascent + fabs(metrics.descent)));\n      pointsize *= 1.114286; \n#endif\n    }\n  draw_info->font=NULL;\n  draw_info->text=NULL;\n#if 0\n  printf(\"String    = %s\\n\", str);\n  printf(\"Font      = %s\\n\", WMF_FONT_PSNAME(font));\n  printf(\"lfHeight  = %g\\n\", font_height);\n  printf(\"bounds    = %g,%g %g,%g\\n\", metrics.bounds.x1, metrics.bounds.y1,\n         metrics.bounds.x2,metrics.bounds.y2);\n  printf(\"ascent    = %g\\n\", metrics.ascent);\n  printf(\"descent   = %g\\n\", metrics.descent);\n  printf(\"height    = %g\\n\", metrics.height);\n  printf(\"Pointsize = %g\\n\", pointsize);\n#endif\n  return floor(pointsize);\n}", "target": 0}
{"code": "  const uint8_t *getBytecode(uint32_t) const override {\n    llvm_unreachable(\"Accessing bytecode from a lazy module\");\n  }", "target": 1}
{"code": "_tiffSizeProc(thandle_t fd)\n{\n\t_TIFF_stat_s sb;\n\treturn (toff_t) (_TIFF_fstat_f((int) fd, &sb) < 0 ? 0 : sb.st_size);\n}", "target": 0}
{"code": "spnego_gss_inquire_cred(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_cred_id_t cred_handle,\n\t\t\tgss_name_t *name,\n\t\t\tOM_uint32 *lifetime,\n\t\t\tint *cred_usage,\n\t\t\tgss_OID_set *mechanisms)\n{\n\tOM_uint32 status;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tgss_cred_id_t creds = GSS_C_NO_CREDENTIAL;\n\tOM_uint32 tmp_minor_status;\n\tOM_uint32 initiator_lifetime, acceptor_lifetime;\n\tdsyslog(\"Entering inquire_cred\\n\");\n\tspcred = (spnego_gss_cred_id_t)cred_handle;\n\tif (spcred == NULL) {\n\t\tstatus = get_available_mechs(minor_status,\n\t\t\tGSS_C_NO_NAME,\n\t\t\tGSS_C_BOTH,\n\t\t\tGSS_C_NO_CRED_STORE,\n\t\t\t&creds,\n\t\t\tmechanisms);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\t\tif ((*mechanisms)->count == 0) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tgss_release_oid_set(&tmp_minor_status, mechanisms);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (GSS_S_DEFECTIVE_CREDENTIAL);\n\t\t}\n\t\tassert((*mechanisms)->elements != NULL);\n\t\tstatus = gss_inquire_cred_by_mech(minor_status,\n\t\t\tcreds,\n\t\t\t&(*mechanisms)->elements[0],\n\t\t\tname,\n\t\t\t&initiator_lifetime,\n\t\t\t&acceptor_lifetime,\n\t\t\tcred_usage);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\t\tif (lifetime != NULL)\n\t\t\t*lifetime = (*cred_usage == GSS_C_ACCEPT) ?\n\t\t\t\tacceptor_lifetime : initiator_lifetime;\n\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t} else {\n\t\tstatus = gss_inquire_cred(minor_status, spcred->mcred,\n\t\t\t\t\t  name, lifetime,\n\t\t\t\t\t  cred_usage, mechanisms);\n\t}\n\tdsyslog(\"Leaving inquire_cred\\n\");\n\treturn (status);\n}", "target": 0}
{"code": "bgp_capability_receive (struct peer *peer, bgp_size_t size)\n{\n  u_char *pnt;\n  int ret;\n  pnt = stream_pnt (peer->ibuf);\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv CAPABILITY\", peer->host);\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP dynamic capability is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n  if (peer->status != Established)\n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Dynamic capability packet received under status %s\", peer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n  ret = bgp_capability_msg_parse (peer, pnt, size);\n}", "target": 1}
{"code": "ldbm_txn_ruv_modify_context( Slapi_PBlock *pb, modify_context *mc )\n{\n    char *uniqueid = NULL;\n    backend *be;\n    Slapi_Mods *smods = NULL;\n    struct backentry *bentry;\n    entry_address bentry_addr;\n    IFP fn = NULL;\n    int rc = 0;\n    back_txn txn = {NULL};\n    slapi_pblock_get(pb, SLAPI_TXN_RUV_MODS_FN, (void *)&fn);\n    slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);\n    if (NULL == fn) {\n        return (0);\n    }\n    rc = (*fn)(pb, &uniqueid, &smods);\n    if (1 != rc || NULL == smods || NULL == uniqueid) {\n        return (rc);\n    }\n    slapi_pblock_get( pb, SLAPI_BACKEND, &be);\n    bentry_addr.sdn = NULL;\n    bentry_addr.udn = NULL;\n    bentry_addr.uniqueid = uniqueid;\n    bentry = find_entry2modify_only( pb, be, &bentry_addr, &txn );\n    if (NULL == bentry) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to retrieve and lock RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        goto done;\n    }\n    modify_init( mc, bentry );\n    if (modify_apply_mods_ignore_error( mc, smods, LDAP_TYPE_OR_VALUE_EXISTS )) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to apply updates to RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        modify_term( mc, be );\n    }\ndone:\n    slapi_ch_free_string( &uniqueid );\n    return (rc);\n}", "target": 1}
{"code": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}", "target": 1}
{"code": "static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\treturn LOC_NOT_FOUND;\n}", "target": 1}
{"code": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); \n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}", "target": 1}
{"code": "TEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}", "target": 1}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\tport = args->args[0];\n\tidx = args->args[1];\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\treturn ERR_PTR(-ENODEV);\n}", "target": 1}
{"code": "static int nested_vmx_store_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tfor (i = 0; i < count; i++) {\n\t\tstruct msr_data msr_info;\n\t\tif (kvm_vcpu_read_guest(vcpu,\n\t\t\t\t\tgpa + i * sizeof(e),\n\t\t\t\t\t&e, 2 * sizeof(u32))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nested_vmx_store_msr_check(vcpu, &e)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmsr_info.host_initiated = false;\n\t\tmsr_info.index = e.index;\n\t\tif (kvm_get_msr(vcpu, &msr_info)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR (%u, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (kvm_vcpu_write_guest(vcpu,\n\t\t\t\t\t gpa + i * sizeof(e) +\n\t\t\t\t\t     offsetof(struct vmx_msr_entry, value),\n\t\t\t\t\t &msr_info.data, sizeof(msr_info.data))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, msr_info.data);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\tpr_debug(\"\\n\");\n#endif\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; \n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\tparams->resp_avail(params->v);\n\treturn 0;\n}", "target": 1}
{"code": "activate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n        primary = _(\"Untrusted application launcher\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"The application launcher %s has not been marked as trusted. \"\n                               \"If you do not know the source of this file, launching it may be unsafe.\"\n                               ),\n                             display_name);\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                      \"text\", primary,\n                      \"secondary-text\", secondary,\n                      NULL);\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Launch Anyway\"), RESPONSE_RUN);\n        if (nautilus_file_can_set_permissions (file))\n        {\n            gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"Mark as _Trusted\"), RESPONSE_MARK_TRUSTED);\n        }\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n        g_signal_connect (dialog, \"response\",\n                          G_CALLBACK (untrusted_launcher_response_callback),\n                          parameters_desktop);\n        gtk_widget_show (dialog);\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"Launching trusted launcher %s\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}", "target": 1}
{"code": "static int decode_preamble(void *p, struct ceph_frame_desc *desc)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tu32 crc, expected_crc;\n\tint i;\n\tcrc = crc32c(0, p, crcp - p);\n\texpected_crc = get_unaligned_le32(crcp);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad preamble crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\tmemset(desc, 0, sizeof(*desc));\n\tdesc->fd_tag = ceph_decode_8(&p);\n\tdesc->fd_seg_cnt = ceph_decode_8(&p);\n\tif (desc->fd_seg_cnt < 1 ||\n\t    desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT) {\n\t\tpr_err(\"bad segment count %d\\n\", desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = ceph_decode_32(&p);\n\t\tdesc->fd_aligns[i] = ceph_decode_16(&p);\n\t}\n\tif (!desc->fd_lens[desc->fd_seg_cnt - 1]) {\n\t\tpr_err(\"last segment empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[0] > CEPH_MSG_MAX_CONTROL_LEN) {\n\t\tpr_err(\"control segment too big %d\\n\", desc->fd_lens[0]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[1] > CEPH_MSG_MAX_FRONT_LEN) {\n\t\tpr_err(\"front segment too big %d\\n\", desc->fd_lens[1]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[2] > CEPH_MSG_MAX_MIDDLE_LEN) {\n\t\tpr_err(\"middle segment too big %d\\n\", desc->fd_lens[2]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[3] > CEPH_MSG_MAX_DATA_LEN) {\n\t\tpr_err(\"data segment too big %d\\n\", desc->fd_lens[3]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "struct sock *vsock_find_bound_socket(struct sockaddr_vm *addr)\n{\n\tstruct sock *sk;\n\tspin_lock_bh(&vsock_table_lock);\n\tsk = __vsock_find_bound_socket(addr);\n\tif (sk)\n\t\tsock_hold(sk);\n\tspin_unlock_bh(&vsock_table_lock);\n\treturn sk;\n}", "target": 0}
{"code": "bool PrintWebViewHelper::PreviewPageRendered(int page_number,\n                                             PdfMetafileSkia* metafile) {\n  DCHECK_GE(page_number, FIRST_PAGE_INDEX);\n  if (!print_preview_context_.IsModifiable() ||\n      !print_preview_context_.generate_draft_pages()) {\n    DCHECK(!metafile);\n    return true;\n  }\n  if (!metafile) {\n    NOTREACHED();\n    print_preview_context_.set_error(\n        PREVIEW_ERROR_PAGE_RENDERED_WITHOUT_METAFILE);\n    return false;\n  }\n  PrintHostMsg_DidPreviewPage_Params preview_page_params;\n  uint32 buf_size = metafile->GetDataSize();\n  DCHECK_GT(buf_size, 0u);\n  if (!CopyMetafileDataToSharedMem(\n          metafile, &(preview_page_params.metafile_data_handle))) {\n    LOG(ERROR) << \"CopyMetafileDataToSharedMem failed\";\n    print_preview_context_.set_error(PREVIEW_ERROR_METAFILE_COPY_FAILED);\n    return false;\n  }\n  preview_page_params.data_size = buf_size;\n  preview_page_params.page_number = page_number;\n  preview_page_params.preview_request_id =\n      print_pages_params_->params.preview_request_id;\n  Send(new PrintHostMsg_DidPreviewPage(routing_id(), preview_page_params));\n  return true;\n}", "target": 0}
{"code": "     res1 = cimg::eval(\"cos(x)^2 + sin(y)^2\",2,2),  \n     res2 = cimg::eval(0,1,1);                    \n     \\endcode\n  **/", "target": 0}
{"code": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}", "target": 1}
{"code": "static int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\treturn 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_indices_in = context->input(0);\n    const Tensor& input_shape_in = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),\n                errors::InvalidArgument(\"Input must be a matrix.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector.\"));\n    OP_REQUIRES(context,\n                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),\n                errors::InvalidArgument(\n                    \"Input tensor rank must match input shape length.\"));\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 0}
{"code": "iasecc_pin_get_status(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data info;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tif (data->pin_type != SC_AC_CHV)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"PIN type is not supported for status\");\n\tmemset(&info, 0, sizeof(info));\n\tinfo.cmd = SC_PIN_CMD_GET_INFO;\n\tinfo.pin_type = data->pin_type;\n\tinfo.pin_reference = data->pin_reference;\n\trv = iso_ops->pin_cmd(card, &info, tries_left);\n\tLOG_TEST_RET(ctx, rv, \"Failed to get PIN info\");\n\tdata->pin1.max_tries = info.pin1.max_tries;\n\tdata->pin1.tries_left = info.pin1.tries_left;\n\tdata->pin1.logged_in = info.pin1.logged_in;\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "static u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock;\n\ts64 delta;\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\told_clock = scd->clock;\n\tclock = scd->tick_gtod + delta;\n\tmin_clock = wrap_max(scd->tick_gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, scd->tick_gtod + TICK_NSEC);\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\treturn clock;\n}", "target": 0}
{"code": "void options_free() {\n    parse_global_option(CMD_FREE, NULL, NULL);\n}", "target": 1}
{"code": "static const char *req_handler_field(request_rec *r)\n{\n    return r->handler;\n}", "target": 0}
{"code": "void sock_init_data(struct socket *sock, struct sock *sk)\n{\n\tskb_queue_head_init(&sk->sk_receive_queue);\n\tskb_queue_head_init(&sk->sk_write_queue);\n\tskb_queue_head_init(&sk->sk_error_queue);\n#ifdef CONFIG_NET_DMA\n\tskb_queue_head_init(&sk->sk_async_wait_queue);\n#endif\n\tsk->sk_send_head\t=\tNULL;\n\tinit_timer(&sk->sk_timer);\n\tsk->sk_allocation\t=\tGFP_KERNEL;\n\tsk->sk_rcvbuf\t\t=\tsysctl_rmem_default;\n\tsk->sk_sndbuf\t\t=\tsysctl_wmem_default;\n\tsk->sk_state\t\t=\tTCP_CLOSE;\n\tsk_set_socket(sk, sock);\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sock) {\n\t\tsk->sk_type\t=\tsock->type;\n\t\tsk->sk_wq\t=\tsock->wq;\n\t\tsock->sk\t=\tsk;\n\t} else\n\t\tsk->sk_wq\t=\tNULL;\n\tspin_lock_init(&sk->sk_dst_lock);\n\trwlock_init(&sk->sk_callback_lock);\n\tlockdep_set_class_and_name(&sk->sk_callback_lock,\n\t\t\taf_callback_keys + sk->sk_family,\n\t\t\taf_family_clock_key_strings[sk->sk_family]);\n\tsk->sk_state_change\t=\tsock_def_wakeup;\n\tsk->sk_data_ready\t=\tsock_def_readable;\n\tsk->sk_write_space\t=\tsock_def_write_space;\n\tsk->sk_error_report\t=\tsock_def_error_report;\n\tsk->sk_destruct\t\t=\tsock_def_destruct;\n\tsk->sk_sndmsg_page\t=\tNULL;\n\tsk->sk_sndmsg_off\t=\t0;\n\tsk->sk_peek_off\t\t=\t-1;\n\tsk->sk_peer_pid \t=\tNULL;\n\tsk->sk_peer_cred\t=\tNULL;\n\tsk->sk_write_pending\t=\t0;\n\tsk->sk_rcvlowat\t\t=\t1;\n\tsk->sk_rcvtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_sndtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_stamp = ktime_set(-1L, 0);\n\tsmp_wmb();\n\tatomic_set(&sk->sk_refcnt, 1);\n\tatomic_set(&sk->sk_drops, 0);\n}", "target": 0}
{"code": "static void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}", "target": 1}
{"code": "static inline ut64 dwarf_read_offset(bool is_64bit, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (is_64bit) {\n\t\tresult = READ64 (*buf);\n\t} else {\n\t\tresult = READ32 (*buf);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "    StringValue::StringValue(const std::string& buf)\n        : StringValueBase(string, buf)\n    {\n    }", "target": 0}
{"code": "int Item_decimal::save_in_field(Field *field, bool no_conversions)\n{\n  field->set_notnull();\n  return field->store_decimal(&decimal_value);\n}", "target": 0}
{"code": "    inline EndpointSecurityAttributesMask mask() const\n    {\n        EndpointSecurityAttributesMask rv = ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_read_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_READ_PROTECTED;\n        if (is_write_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_WRITE_PROTECTED;\n        if (is_discovery_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_DISCOVERY_PROTECTED;\n        if (is_liveliness_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_LIVELINESS_PROTECTED;\n        if (is_submessage_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_PROTECTED;\n        if (is_payload_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_PROTECTED;\n        if (is_key_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_KEY_PROTECTED;\n        return rv;\n    }", "target": 1}
{"code": "static void __reg64_deduce_bounds(struct bpf_reg_state *reg)\n{\n\tif (reg->smin_value >= 0 || reg->smax_value < 0) {\n\t\treg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,\n\t\t\t\t\t\t\t  reg->umin_value);\n\t\treg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,\n\t\t\t\t\t\t\t  reg->umax_value);\n\t\treturn;\n\t}\n\tif ((s64)reg->umax_value >= 0) {\n\t\treg->smin_value = reg->umin_value;\n\t\treg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,\n\t\t\t\t\t\t\t  reg->umax_value);\n\t} else if ((s64)reg->umin_value < 0) {\n\t\treg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,\n\t\t\t\t\t\t\t  reg->umin_value);\n\t\treg->smax_value = reg->umax_value;\n\t}\n}", "target": 0}
{"code": "void gdImagePaletteCopy (gdImagePtr to, gdImagePtr from)\n{\n\tint i;\n\tint x, y, p;\n\tint xlate[256];\n\tif (to->trueColor || from->trueColor) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 256; i++) {\n\t\txlate[i] = -1;\n\t}\n\tfor (y = 0; y < to->sy; y++) {\n\t\tfor (x = 0; x < to->sx; x++) {\n\t\t\tp = gdImageGetPixel(to, x, y);\n\t\t\tif (xlate[p] == -1) {\n\t\t\t\txlate[p] = gdImageColorClosestAlpha (from, to->red[p], to->green[p], to->blue[p], to->alpha[p]);\n\t\t\t}\n\t\t\tgdImageSetPixel(to, x, y, xlate[p]);\n\t\t}\n\t}\n\tfor (i = 0; i < from->colorsTotal; i++) {\n\t\tto->red[i] = from->red[i];\n\t\tto->blue[i] = from->blue[i];\n\t\tto->green[i] = from->green[i];\n\t\tto->alpha[i] = from->alpha[i];\n\t\tto->open[i] = 0;\n\t}\n\tfor (i = from->colorsTotal; i < to->colorsTotal; i++) {\n\t\tto->open[i] = 1;\n\t}\n\tto->colorsTotal = from->colorsTotal;\n}", "target": 0}
{"code": "GF_Err ohdr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu16 cid_len, ri_len;\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox*)s;\n\tISOM_DECREASE_SIZE(ptr, (1+1+8+2+2+2) );\n\tptr->EncryptionMethod = gf_bs_read_u8(bs);\n\tptr->PaddingScheme = gf_bs_read_u8(bs);\n\tptr->PlaintextLength = gf_bs_read_u64(bs);\n\tcid_len = gf_bs_read_u16(bs);\n\tri_len = gf_bs_read_u16(bs);\n\tptr->TextualHeadersLen = gf_bs_read_u16(bs);\n\tif (ptr->size<cid_len+ri_len+ptr->TextualHeadersLen) return GF_ISOM_INVALID_FILE;\n\tif (cid_len) {\n\t\tptr->ContentID = (char *)gf_malloc(sizeof(char)*(cid_len+1));\n\t\tif (!ptr->ContentID) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->ContentID, cid_len);\n\t\tptr->ContentID[cid_len]=0;\n\t}\n\tif (ri_len) {\n\t\tptr->RightsIssuerURL = (char *)gf_malloc(sizeof(char)*(ri_len+1));\n\t\tif (!ptr->RightsIssuerURL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->RightsIssuerURL, ri_len);\n\t\tptr->RightsIssuerURL[ri_len]=0;\n\t}\n\tif (ptr->TextualHeadersLen) {\n\t\tptr->TextualHeaders = (char *)gf_malloc(sizeof(char)*(ptr->TextualHeadersLen+1));\n\t\tif (!ptr->TextualHeaders) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->TextualHeaders, ptr->TextualHeadersLen);\n\t\tptr->TextualHeaders[ptr->TextualHeadersLen] = 0;\n\t}\n\tISOM_DECREASE_SIZE(ptr, (cid_len+ri_len+ptr->TextualHeadersLen) );\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "static struct list_head *rb_list_head(struct list_head *list)\n{\n\tunsigned long val = (unsigned long)list;\n\treturn (struct list_head *)(val & ~RB_FLAG_MASK);\n}", "target": 0}
{"code": "static inline s16 fixp_mult(s16 a, s16 b)\n{\n\ta = ((s32)a * 0x100) / 0x7fff;\n\treturn ((s32)(a * b)) >> FRAC_N;\n}", "target": 0}
{"code": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)\n{\n\tvoid **old_p, *retval;\n\tif (zend_hash_index_find(&xlat_table, (ulong)source, (void **)&old_p) == SUCCESS) {\n\t\treturn *old_p;\n\t}\n\tretval = ZCG(mem);;\n\tZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n\tmemcpy(retval, source, size);\n\tif (free_source) {\n\t\tinterned_efree((char*)source);\n\t}\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n\treturn retval;\n}", "target": 1}
{"code": "static int vmci_transport_send_conn_request2(struct sock *sk, size_t size,\n\t\t\t\t\t     u16 version)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\tsk, VMCI_TRANSPORT_PACKET_TYPE_REQUEST2,\n\t\t\t\t\tsize, 0, NULL, version,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}", "target": 0}
{"code": "static void iommu_enable_dev_iotlb(struct device_domain_info *info)\n{\n\tstruct pci_dev *pdev;\n\tassert_spin_locked(&device_domain_lock);\n\tif (!info || !dev_is_pci(info->dev))\n\t\treturn;\n\tpdev = to_pci_dev(info->dev);\n\tif (!ecap_dit(info->iommu->ecap))\n\t\tinfo->pfsid = 0;\n\telse {\n\t\tstruct pci_dev *pf_pdev;\n\t\tpf_pdev = pci_physfn(pdev);\n\t\tinfo->pfsid = PCI_DEVID(pf_pdev->bus->number, pf_pdev->devfn);\n\t}\n#ifdef CONFIG_INTEL_IOMMU_SVM\n\tif (info->pasid_supported && !pci_enable_pasid(pdev, info->pasid_supported & ~1))\n\t\tinfo->pasid_enabled = 1;\n\tif (info->pri_supported && !pci_reset_pri(pdev) && !pci_enable_pri(pdev, 32))\n\t\tinfo->pri_enabled = 1;\n#endif\n\tif (!pdev->untrusted && info->ats_supported &&\n\t    !pci_enable_ats(pdev, VTD_PAGE_SHIFT)) {\n\t\tinfo->ats_enabled = 1;\n\t\tdomain_update_iotlb(info->domain);\n\t\tinfo->ats_qdep = pci_ats_queue_depth(pdev);\n\t}\n}", "target": 0}
{"code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n\t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\tskcipher->setkey = alg->setkey;\n\tskcipher->encrypt = alg->encrypt;\n\tskcipher->decrypt = alg->decrypt;\n\tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\treturn 0;\n}", "target": 1}
{"code": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "int sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "inline int nci_request(struct nci_dev *ndev,\n\t\t       void (*req)(struct nci_dev *ndev,\n\t\t\t\t   const void *opt),\n\t\t       const void *opt, __u32 timeout)\n{\n\tint rc;\n\tif (!test_bit(NCI_UP, &ndev->flags))\n\t\treturn -ENETDOWN;\n\tmutex_lock(&ndev->req_lock);\n\trc = __nci_request(ndev, req, opt, timeout);\n\tmutex_unlock(&ndev->req_lock);\n\treturn rc;\n}", "target": 1}
{"code": "void PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}", "target": 1}
{"code": "http_error_t::make_body (int n, const str &si, const str &aux)\n{\n  strbuf b;\n  str ldesc;\n  const str sdesc = http_status.get_desc (n, &ldesc);\n  b << \"<html>\\n\"\n    << \" <head>\\n\"\n    << \"  <title>\" << n << \" \" << sdesc << \"</title>\\n\"\n    << \" </head>\\n\"\n    << \" <body>\\n\"\n    << \" <h1>Error \" << n << \" \" << sdesc << \"</h1><br><br>\\n\"\n    ;\n  if (n == HTTP_NOT_FOUND && aux) {\n    b << \"The file <tt>\" << aux \n      << \"</tt> was not found on this server.<br><br>\\n\\n\";\n  }\n  b << \"  <hr>\\n\"\n    << \"  <i>\" << si << \"</i>\\n\"\n    << \" <br>\\n\"\n    << \" </body>\\n\"\n    << \"</html>\\n\"\n    ;\n  return b;\n}", "target": 1}
{"code": "int sldns_str2wire_dname_buf_origin(const char* str, uint8_t* buf, size_t* len,\n\tuint8_t* origin, size_t origin_len)\n{\n\tsize_t dlen = *len;\n\tint rel = 0;\n\tint s = sldns_str2wire_dname_buf_rel(str, buf, &dlen, &rel);\n\tif(s) return s;\n\tif(rel && origin && dlen > 0) {\n\t\tif(dlen + origin_len - 1 > LDNS_MAX_DOMAINLEN)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_DOMAINNAME_OVERFLOW,\n\t\t\t\tLDNS_MAX_DOMAINLEN);\n\t\tif(dlen + origin_len - 1 > *len)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL,\n\t\t\t\t*len);\n\t\tmemmove(buf+dlen-1, origin, origin_len);\n\t\t*len = dlen + origin_len - 1;\n\t} else\n\t\t*len = dlen;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 1}
{"code": "KCleanup::itemDir( const KFileInfo *item ) const\n{\n    QString dir = item->url();\n    if ( ! item->isDir() && ! item->isDotEntry() )\n    {\n\tdir.replace ( QRegExp ( \"/[^/]*$\" ), \"\" );\n    }\n    return dir;\n}", "target": 0}
{"code": "read_nextline(void)\n{\nint len;\nuschar *p, *q;\nif (next_line != NULL)\n  {\n  uschar *yield = next_line;\n  next_line = NULL;\n  return yield;\n  }\nif (popto == 0)\n  {\n  pushstr *ps = pushed;\n  if (ps == NULL) error(12); else\n    {\n    popto = -1;\n    (void)sprintf(CS inbuffer, \"%s\\n\", ps->string);\n    pushed = ps->next;\n    free(ps);\n    return inbuffer;\n    }\n  }\nif (popto > 0)\n  {\n  pushstr *ps = pushed;\n  if (ps->letter == popto) popto = -1;  \n  (void)sprintf(CS inbuffer, \"%s\\n\", ps->string);\n  pushed = ps->next;\n  free(ps);\n  return inbuffer;\n  }\nif (from_type_ptr < 0) return NULL;\nfor (;;)\n  {\n  if (from_type[from_type_ptr] == FROM_MACRO)\n    {\n    if (macrocurrent->nextline == NULL)\n      {\n      macroexe *temp = macrocurrent;\n      macrocurrent = macrocurrent->prev;\n      macro_free(temp);\n      }\n    else\n      {\n      read_process_macroline(macrocurrent->nextline->string, inbuffer);\n      macrocurrent->nextline = macrocurrent->nextline->next;\n      break;\n      }\n    }\n  else\n    {\n    len = get_nextline(istack->file, inbuffer, INBUFFSIZE);\n    if (len < 0)\n      {\n      istackstr *prev = istack->prev;\n      fclose(istack->file);\n      free(istack);\n      istack = prev;\n      }\n    else\n      {\n      istack->linenumber++;\n      q = inbuffer;\n      for (;;)\n        {\n        p = q + len;\n        while (p > q && isspace(p[-1])) p--;\n        if (p - q < 3 || Ustrncmp(p - 3, \"&&&\", 3) != 0) break;\n        q = p - 3;\n        *q = 0;\n        if (istack == NULL) break;\n        len = get_nextline(istack->file, q, INBUFFSIZE - (q - inbuffer));\n        if (len < 0) break;\n        istack->linenumber++;\n        p = q;\n        while (*p == ' ' || *p == '\\t') { p++; len--; }\n        if (p > q) memmove(q, p, len + 1);\n        }\n      break;\n      }\n    }\n  if (--from_type_ptr < 0) return NULL;\n  }\nreturn inbuffer;\n}", "target": 1}
{"code": "static int jsR_delproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto dontconf;\n\t\tif (!strcmp(name, \"global\")) goto dontconf;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto dontconf;\n\t\tif (!strcmp(name, \"multiline\")) goto dontconf;\n\t\tif (!strcmp(name, \"lastIndex\")) goto dontconf;\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.delete && obj->u.user.delete(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\tref = jsV_getownproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->atts & JS_DONTCONF)\n\t\t\tgoto dontconf;\n\t\tjsV_delproperty(J, obj, name);\n\t}\n\treturn 1;\ndontconf:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\treturn 0;\n}", "target": 0}
{"code": "is_code_ctype(OnigCodePoint code, unsigned int ctype, OnigEncoding enc ARG_UNUSED)\n{\n  if (code < 256)\n    return ENC_IS_ISO_8859_15_CTYPE(code, ctype);\n  else\n    return FALSE;\n}", "target": 0}
{"code": "int ZEXPORT inflatePrime(strm, bits, value)\nz_streamp strm;\nint bits;\nint value;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (bits < 0) {\n        state->hold = 0;\n        state->bits = 0;\n        return Z_OK;\n    }\n    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;\n    value &= (1L << bits) - 1;\n    state->hold += (unsigned)value << state->bits;\n    state->bits += bits;\n    return Z_OK;\n}", "target": 0}
{"code": "int jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\treturn 0;\n}", "target": 1}
{"code": "double AccessibilityUIElement::clickPointY()\n{\n    return 0.0f;\n}", "target": 0}
{"code": "static void ucvector_cleanup(void* p)\n{\n  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;\n  free(((ucvector*)p)->data);\n  ((ucvector*)p)->data = NULL;\n}", "target": 0}
{"code": "gpg_ctx_add_recipient (struct _GpgCtx *gpg,\n                       const gchar *keyid)\n{\n\tif (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT)\n\t\treturn;\n\tif (!gpg->recipients)\n\t\tgpg->recipients = g_ptr_array_new ();\n\tg_ptr_array_add (gpg->recipients, g_strdup (keyid));\n}", "target": 1}
{"code": "static int em_bt(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_NONE;\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n\temulate_2op_SrcV_nobyte(ctxt, \"bt\");\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "int pam_sm_close_session (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n    return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_STOP, NULL);\n}    ", "target": 0}
{"code": "status_t Parcel::write(const FlattenableHelperInterface& val)\n{\n status_t err;\n const size_t len = val.getFlattenedSize();\n const size_t fd_count = val.getFdCount();\n if ((len > INT32_MAX) || (fd_count > INT32_MAX)) {\n return BAD_VALUE;\n }\n    err = this->writeInt32(len);\n if (err) return err;\n    err = this->writeInt32(fd_count);\n if (err) return err;\n void* const buf = this->writeInplace(pad_size(len));\n if (buf == NULL)\n return BAD_VALUE;\n int* fds = NULL;\n if (fd_count) {\n        fds = new int[fd_count];\n }\n    err = val.flatten(buf, len, fds, fd_count);\n for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {\n        err = this->writeDupFileDescriptor( fds[i] );\n }\n if (fd_count) {\n delete [] fds;\n }\n return err;\n}", "target": 0}
{"code": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n\t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "bool AccessibilityUIElement::attributedStringRangeIsMisspelled(unsigned location, unsigned length)\n{\n    return false;\n}", "target": 0}
{"code": "static DBusConnection *si_dbus_get_system_bus(void)\n{\n    DBusConnection *connection;\n    DBusError error;\n    dbus_error_init(&error);\n    connection = dbus_bus_get_private(DBUS_BUS_SYSTEM, &error);\n    if (connection == NULL || dbus_error_is_set(&error)) {\n        if (dbus_error_is_set(&error)) {\n            syslog(LOG_WARNING, \"Unable to connect to system bus: %s\",\n                   error.message);\n            dbus_error_free(&error);\n        } else {\n            syslog(LOG_WARNING, \"Unable to connect to system bus\");\n        }\n        return NULL;\n    }\n    return connection;\n}", "target": 0}
{"code": "static void tty_ldisc_close(struct tty_struct *tty, struct tty_ldisc *ld)\n{\n\tWARN_ON(!test_bit(TTY_LDISC_OPEN, &tty->flags));\n\tclear_bit(TTY_LDISC_OPEN, &tty->flags);\n\tif (ld->ops->close)\n\t\tld->ops->close(tty);\n\ttty_ldisc_debug(tty, \"%p: closed\\n\", tty->ldisc);\n}", "target": 0}
{"code": "int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n        mode_t old_mode;\n        int r;\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tstruct bpf_prog *prog_adj;\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\tinsn_adj_cnt = prog->len + insn_delta;\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\tprog_adj->len = insn_adj_cnt;\n\tinsn_rest = insn_adj_cnt - off - len;\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\tbpf_adj_branches(prog_adj, off, insn_delta);\n\treturn prog_adj;\n}", "target": 1}
{"code": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n\t\tmosquitto__free(packet);\n\t\tif(mosq->is_dropping == false){\n\t\t\tmosq->is_dropping = true;\n\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\tmosq->id);\n\t\t}\n\t\tG_MSGS_DROPPED_INC();\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}", "target": 0}
{"code": "void ConnectDialog::on_qtwServers_customContextMenuRequested(const QPoint &mpos) {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->itemAt(mpos));\n\tqmPopup->clear();\n\tif (si != NULL && si->bParent) {\n\t\tsi = NULL;\n\t}\n\tif (si != NULL) {\n\t\tif (!g.s.disableConnectDialogEditing) {\n\t\t\tif (si->itType == ServerItem::FavoriteType) {\n\t\t\t\tqmPopup->addAction(qaFavoriteEdit);\n\t\t\t\tqmPopup->addAction(qaFavoriteRemove);\n\t\t\t} else {\n\t\t\t\tqmPopup->addAction(qaFavoriteAdd);\n\t\t\t}\n\t\t}\n\t\tif (!si->qsUrl.isEmpty()) {\n\t\t\tqmPopup->addAction(qaUrl);\n\t\t}\n\t}\n\tif (! qmPopup->isEmpty()) {\n\t\tqmPopup->addSeparator();\n\t}\n\tqmPopup->addMenu(qmFilters);\n\tqmPopup->popup(qtwServers->viewport()->mapToGlobal(mpos), NULL);\n}", "target": 0}
{"code": "pci_lintr_assert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == IDLE) {\n\t\tif (pci_lintr_permitted(dev)) {\n\t\t\tdev->lintr.state = ASSERTED;\n\t\t\tpci_irq_assert(dev);\n\t\t} else\n\t\t\tdev->lintr.state = PENDING;\n\t}\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "static int mov_read_SA3D(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int i, version, type;\n    int ambisonic_order, channel_order, normalization, channel_count;\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    if (atom.size < 16) {\n        av_log(c->fc, AV_LOG_ERROR, \"SA3D audio box too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported SA3D box version %d\\n\", version);\n        return 0;\n    }\n    type = avio_r8(pb);\n    if (type) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported ambisonic type %d\\n\", type);\n        return 0;\n    }\n    ambisonic_order = avio_rb32(pb);\n    channel_order = avio_r8(pb);\n    if (channel_order) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported channel_order %d\\n\", channel_order);\n        return 0;\n    }\n    normalization = avio_r8(pb);\n    if (normalization) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported normalization %d\\n\", normalization);\n        return 0;\n    }\n    channel_count = avio_rb32(pb);\n    if (ambisonic_order < 0 || channel_count != (ambisonic_order + 1LL) * (ambisonic_order + 1LL)) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Invalid number of channels (%d / %d)\\n\",\n               channel_count, ambisonic_order);\n        return 0;\n    }\n    for (i = 0; i < channel_count; i++) {\n        if (i != avio_rb32(pb)) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Ambisonic channel reordering is not supported\\n\");\n            return 0;\n        }\n    }\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_AMBISONIC;\n    st->codecpar->ch_layout.nb_channels = channel_count;\n    return 0;\n}", "target": 0}
{"code": "static void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length)\n{\n\tint queued;\n\tqueued = tty_insert_flip_string(&port->port, data, length);\n\tif (queued < length)\n\t\tdev_err(&port->dev, \"%s - dropping data, %d bytes lost\\n\",\n\t\t\t__func__, length - queued);\n\ttty_flip_buffer_push(&port->port);\n}", "target": 0}
{"code": "hash_findi_add(struct hash_table *hash, const char *str)\n{\n    struct hash_insert hi;\n    void **r;\n    char *strx;\n    size_t l = strlen(str) + 1;\n    r = hash_findib(hash, str, l, &hi);\n    if (r)\n        return r;\n    strx = nasm_malloc(l);  \n    memcpy(strx, str, l);\n    return hash_add(&hi, strx, NULL);\n}", "target": 0}
{"code": "int ssh_scp_accept_request(ssh_scp scp)\n{\n    char buffer[] = {0x00};\n    int rc;\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->state != SSH_SCP_READ_REQUESTED) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"ssh_scp_deny_request called under invalid state\");\n        return SSH_ERROR;\n    }\n    rc = ssh_channel_write(scp->channel, buffer, 1);\n    if (rc == SSH_ERROR) {\n        return SSH_ERROR;\n    }\n    if (scp->request_type == SSH_SCP_REQUEST_NEWFILE) {\n        scp->state = SSH_SCP_READ_READING;\n    } else {\n        scp->state = SSH_SCP_READ_INITED;\n    }\n    return SSH_OK;\n}", "target": 0}
{"code": "build_cert_bag (unsigned char *buffer, size_t buflen, char *salt,\n                size_t *r_length)\n{\n  size_t len[9], needed;\n  unsigned char *p, *certbag;\n  size_t certbaglen;\n  needed = compute_tag_length (buflen);\n  needed += buflen;\n  needed += DIM (data_rc2iter2048);\n  needed += 2 + DIM (oid_data);\n  len[5] = needed;\n  needed += compute_tag_length ( needed);\n  needed += 3;\n  len[3] = needed;\n  needed += compute_tag_length (needed);\n  len[2] = needed;\n  needed += compute_tag_length (needed);\n  needed += 2 + DIM (oid_encryptedData);\n  len[0] = needed;\n  needed += compute_tag_length (needed);\n  p = certbag = gcry_malloc (needed);\n  if (!certbag)\n    {\n      log_error (\"error allocating buffer\\n\");\n      return NULL;\n    }\n  p = store_tag_length (p, TAG_SEQUENCE, len[0]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_encryptedData));\n  memcpy (p, oid_encryptedData, DIM (oid_encryptedData));\n  p += DIM (oid_encryptedData);\n  p = store_tag_length (p, 0xa0, len[2]);\n  p = store_tag_length (p, TAG_SEQUENCE, len[3]);\n  *p++ = TAG_INTEGER;\n  *p++ = 1;\n  *p++ = 0;\n  p = store_tag_length (p, TAG_SEQUENCE, len[5]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_data));\n  memcpy (p, oid_data, DIM (oid_data));\n  p += DIM (oid_data);\n  memcpy (p, data_rc2iter2048, DIM (data_rc2iter2048));\n  memcpy (p + DATA_RC2ITER2048_SALT_OFF, salt, 8);\n  p += DIM (data_rc2iter2048);\n  p = store_tag_length (p, 0x80, buflen);\n  memcpy (p, buffer, buflen);\n  p += buflen;\n  certbaglen = p - certbag;\n  if (needed != certbaglen)\n    log_debug (\"length mismatch: %lu, %lu\\n\",\n               (unsigned long)needed, (unsigned long)certbaglen);\n  *r_length = certbaglen;\n  return certbag;\n}", "target": 0}
{"code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n  return 0;\nfail:\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}", "target": 1}
{"code": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}", "target": 1}
{"code": "  virtual void SetUpCommandLine(CommandLine* command_line) {\n    GpuFeatureTest::SetUpCommandLine(command_line);\n    command_line->AppendSwitch(switches::kEnableThreadedCompositing);\n  }", "target": 1}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tmake_pages_present(addr, prev->vm_end);\n\treturn prev;\n}", "target": 0}
{"code": "static struct nft_chain *nf_tables_chain_lookup(const struct nft_table *table,\n\t\t\t\t\t\tconst struct nlattr *nla)\n{\n\tstruct nft_chain *chain;\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (!nla_strcmp(nla, chain->name))\n\t\t\treturn chain;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}", "target": 0}
{"code": "static int orinoco_ioctl_getessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_point *erq,\n\t\t\t\t  char *essidbuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint active;\n\tint err = 0;\n\tunsigned long flags;\n\tif (netif_running(dev)) {\n\t\terr = orinoco_hw_get_essid(priv, &active, essidbuf);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terq->length = err;\n\t} else {\n\t\tif (orinoco_lock(priv, &flags) != 0)\n\t\t\treturn -EBUSY;\n\t\tmemcpy(essidbuf, priv->desired_essid, IW_ESSID_MAX_SIZE);\n\t\terq->length = strlen(priv->desired_essid);\n\t\torinoco_unlock(priv, &flags);\n\t}\n\terq->flags = 1;\n\treturn 0;\n}", "target": 0}
{"code": "  void setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n    san_matchers_ = san_matchers;\n  };", "target": 1}
{"code": "void ap_lua_rstack_dump(lua_State *L, request_rec *r, const char *msg)\n{\n    int i;\n    int top = lua_gettop(L);\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01484) \"Lua Stack Dump: [%s]\", msg);\n    for (i = 1; i <= top; i++) {\n        int t = lua_type(L, i);\n        switch (t) {\n        case LUA_TSTRING:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  '%s'\", i, lua_tostring(L, i));\n                break;\n            }\n        case LUA_TUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  userdata\",\n                              i);\n                break;\n            }\n        case LUA_TLIGHTUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  lightuserdata\", i);\n                break;\n            }\n        case LUA_TNIL:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  NIL\", i);\n                break;\n            }\n        case LUA_TNONE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  None\", i);\n                break;\n            }\n        case LUA_TBOOLEAN:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %s\", i, lua_toboolean(L,\n                                                          i) ? \"true\" :\n                              \"false\");\n                break;\n            }\n        case LUA_TNUMBER:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %g\", i, lua_tonumber(L, i));\n                break;\n            }\n        case LUA_TTABLE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <table>\", i);\n                break;\n            }\n        case LUA_TFUNCTION:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <function>\", i);\n                break;\n            }\n        default:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  unknown: -[%s]-\", i, lua_typename(L, i));\n                break;\n            }\n        }\n    }\n}", "target": 0}
{"code": "void sc_pkcs15emu_sc_hsm_free_cvc(sc_cvc_t *cvc)\n{\n\tif (cvc->signature) {\n\t\tfree(cvc->signature);\n\t\tcvc->signature = NULL;\n\t}\n\tif (cvc->primeOrModulus) {\n\t\tfree(cvc->primeOrModulus);\n\t\tcvc->primeOrModulus = NULL;\n\t}\n\tif (cvc->coefficientAorExponent) {\n\t\tfree(cvc->coefficientAorExponent);\n\t\tcvc->coefficientAorExponent = NULL;\n\t}\n\tif (cvc->coefficientB) {\n\t\tfree(cvc->coefficientB);\n\t\tcvc->coefficientB = NULL;\n\t}\n\tif (cvc->basePointG) {\n\t\tfree(cvc->basePointG);\n\t\tcvc->basePointG = NULL;\n\t}\n\tif (cvc->order) {\n\t\tfree(cvc->order);\n\t\tcvc->order = NULL;\n\t}\n\tif (cvc->publicPoint) {\n\t\tfree(cvc->publicPoint);\n\t\tcvc->publicPoint = NULL;\n\t}\n\tif (cvc->cofactor) {\n\t\tfree(cvc->cofactor);\n\t\tcvc->cofactor = NULL;\n\t}\n}", "target": 0}
{"code": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n{\n\tswitch (open_flags) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n}", "target": 1}
{"code": "daemon_linux_lvm2_vg_remove_pv (Daemon *daemon,\n                                const gchar *vg_uuid,\n                                const gchar *pv_uuid,\n                                gchar **options,\n                                DBusGMethodInvocation *context)\n{\n  daemon_local_check_auth (daemon,\n                           NULL,\n                           \"org.freedesktop.udisks.linux-lvm2\",\n                           \"LinuxLvm2VGRemovePV\",\n                           TRUE,\n                           daemon_linux_lvm2_vg_remove_pv_authorized_cb,\n                           context,\n                           3,\n                           g_strdup (vg_uuid),\n                           g_free,\n                           g_strdup (pv_uuid),\n                           g_free,\n                           g_strdupv (options),\n                           g_strfreev);\n  return TRUE;\n}", "target": 0}
{"code": "static int wcd9335_probe(struct wcd9335_codec *wcd)\n{\n\tstruct device *dev = wcd->dev;\n\tmemcpy(wcd->rx_chs, wcd9335_rx_chs, sizeof(wcd9335_rx_chs));\n\tmemcpy(wcd->tx_chs, wcd9335_tx_chs, sizeof(wcd9335_tx_chs));\n\twcd->sido_input_src = SIDO_SOURCE_INTERNAL;\n\twcd->sido_voltage = SIDO_VOLTAGE_NOMINAL_MV;\n\treturn devm_snd_soc_register_component(dev, &wcd9335_component_drv,\n\t\t\t\t\t       wcd9335_slim_dais,\n\t\t\t\t\t       ARRAY_SIZE(wcd9335_slim_dais));\n}", "target": 0}
{"code": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n\t}\n}", "target": 1}
{"code": "static uint16 TIFFClampDoubleToUInt16( double val )\n{\n    if( val < 0 )\n        return 0;\n    if( val > 65535 || val != val )\n        return 65535;\n    return (uint16)val;\n}", "target": 0}
{"code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n        ctx->cid = cid;\n    }\n    return 0;\n}", "target": 1}
{"code": "static char* guess_timezone(const timelib_tzdb *tzdb TSRMLS_DC)\n{\n\tif (DATEG(timezone) && (strlen(DATEG(timezone))) > 0) {\n\t\treturn DATEG(timezone);\n\t}\n\tif (!DATEG(default_timezone)) {\n\t\tzval ztz;\n\t\tif (SUCCESS == zend_get_configuration_directive(\"date.timezone\", sizeof(\"date.timezone\"), &ztz)\n\t\t\t&& Z_TYPE(ztz) == IS_STRING && Z_STRLEN(ztz) > 0 && timelib_timezone_id_is_valid(Z_STRVAL(ztz), tzdb)) {\n\t\t\treturn Z_STRVAL(ztz);\n\t\t}\n\t} else if (*DATEG(default_timezone)) {\n\t\tif (DATEG(timezone_valid) == 1) {\n\t\t\treturn DATEG(default_timezone);\n\t\t}\n\t\tif (!timelib_timezone_id_is_valid(DATEG(default_timezone), tzdb)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid date.timezone value '%s', we selected the timezone 'UTC' for now.\", DATEG(default_timezone));\n\t\t\treturn \"UTC\";\n\t\t}\n\t\tDATEG(timezone_valid) = 1;\n\t\treturn DATEG(default_timezone);\n\t}\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, DATE_TZ_ERRMSG \"We selected the timezone 'UTC' for now, but please set date.timezone to select your timezone.\");\n\treturn \"UTC\";", "target": 0}
{"code": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}", "target": 1}
{"code": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}", "target": 1}
{"code": "__u32 secure_ip_id(__be32 daddr)\n{\n\tstruct keydata *keyptr;\n\t__u32 hash[4];\n\tkeyptr = get_keyptr();\n\thash[0] = (__force __u32)daddr;\n\thash[1] = keyptr->secret[9];\n\thash[2] = keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}", "target": 1}
{"code": "int LibRaw::subtract_black()\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\ttry {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))\n        {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c] \n            int cblk[4],i;\n            for(i=0;i<4;i++)\n                cblk[i] = C.cblack[i];\n            int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(C.data_maximum < val) C.data_maximum = val;\n              }\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n            C.maximum -= C.black;\n            ZERO(C.cblack);\n            C.black = 0;\n#undef BAYERC\n        }\n    else\n        {\n          int idx;\n          ushort *p = (ushort*)imgdata.image;\n          C.data_maximum = 0;\n          for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n            if(C.data_maximum < p[idx]) C.data_maximum = p[idx];\n        }\n\t\treturn 0;\n\t}\n\tcatch ( LibRaw_exceptions err) {\n\t\tEXCEPTION_HANDLER(err);\n\t}\n}", "target": 1}
{"code": "static __exit void sctp_exit(void)\n{\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\tunregister_pernet_subsys(&sctp_net_ops);\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\trcu_barrier(); \n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}", "target": 1}
{"code": "void mark_mounts_for_expiry(struct list_head *mounts)\n{\n\tstruct mount *mnt, *next;\n\tLIST_HEAD(graveyard);\n\tif (list_empty(mounts))\n\t\treturn;\n\tnamespace_lock();\n\tlock_mount_hash();\n\tlist_for_each_entry_safe(mnt, next, mounts, mnt_expire) {\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1) ||\n\t\t\tpropagate_mount_busy(mnt, 1))\n\t\t\tcontinue;\n\t\tlist_move(&mnt->mnt_expire, &graveyard);\n\t}\n\twhile (!list_empty(&graveyard)) {\n\t\tmnt = list_first_entry(&graveyard, struct mount, mnt_expire);\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tumount_tree(mnt, 1);\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}", "target": 0}
{"code": "do_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "completion_glob_pattern (string)\n     char *string;\n{\n  register int c;\n  char *send;\n  int open;\n  DECLARE_MBSTATE;\n  open = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string++ == 0)\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return (0);\n}", "target": 1}
{"code": " void FrameView::updateLayoutAndStyleForPainting()\n {\n     RefPtr<FrameView> protector(this);\n     updateLayoutAndStyleIfNeededRecursive();\n     if (RenderView* view = renderView()) {\n         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"UpdateLayerTree\", \"frame\", m_frame.get());\n        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());\n        view->compositor()->updateIfNeededRecursive();\n        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())\n            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();\n        updateCompositedSelectionBoundsIfNeeded();\n        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());\n        invalidateTreeIfNeededRecursive();\n    }\n    scrollContentsIfNeededRecursive();\n    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);\n}", "target": 1}
{"code": "static int add_seccomp_syscall_filter(scmp_filter_ctx seccomp,\n                                      uint32_t arch,\n                                      int nr,\n                                      unsigned int arg_cnt,\n                                      const struct scmp_arg_cmp arg) {\n        int r;\n        r = seccomp_rule_add_exact(seccomp, SCMP_ACT_ERRNO(EPERM), nr, arg_cnt, arg);\n        if (r < 0) {\n                _cleanup_free_ char *n = NULL;\n                n = seccomp_syscall_resolve_num_arch(arch, nr);\n                log_debug_errno(r, \"Failed to add %s() rule for architecture %s, skipping: %m\",\n                                strna(n),\n                                seccomp_arch_to_string(arch));\n        }\n        return r;\n}", "target": 0}
{"code": "open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\tif (!name)\n\t\treturn;\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\tlog_file = fopen(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\tFREE(file_name);\n}", "target": 1}
{"code": "append_command(char_u *cmd)\n{\n    char_u *s = cmd;\n    char_u *d;\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff + 5 < IOSIZE)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\t    break;\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}", "target": 1}
{"code": "int nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\t\tnfs_inode_find_state_and_recover(state->inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -EKEYEXPIRED:\n\t\t\tcase -ENOMEM:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}", "target": 0}
{"code": "ExprCreateFloat(void)\n{\n    EXPR_CREATE(ExprFloat, expr, EXPR_VALUE, EXPR_TYPE_FLOAT);\n    return expr;\n}", "target": 0}
{"code": "static void bundle_add_conn(struct connectbundle *bundle,\n                            struct connectdata *conn)\n{\n  Curl_llist_insert_next(&bundle->conn_list, bundle->conn_list.tail, conn,\n                         &conn->bundle_node);\n  conn->bundle = bundle;\n  bundle->num_connections++;\n}", "target": 0}
{"code": "int sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}", "target": 1}
{"code": "void QuotaManager::GetGlobalUsage(\n    StorageType type,\n    GlobalUsageCallback* callback) {\n  LazyInitialize();\n  GetUsageTracker(type)->GetGlobalUsage(callback);\n}", "target": 0}
{"code": "static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tpte_unmap(page_table);\n\tif (!vma->vm_ops->fault)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (!(flags & FAULT_FLAG_WRITE))\n\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 0}
{"code": "void DHT::illustrate_dirs()\n{\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for schedule(guided)\n#endif\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    illustrate_dline(i);\n  }\n}", "target": 0}
{"code": "static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}", "target": 1}
{"code": "static char *red_stream_get_local_address(RedStream *stream)\n{\n    return addr_to_string(\"%s;%s\", &stream->priv->info->laddr_ext,\n                          stream->priv->info->llen_ext);\n}", "target": 0}
{"code": "static inline long put_compat_itimerval(struct compat_itimerval __user *o,\n\t\tstruct itimerval *i)\n{\n\treturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\n\t\t(__put_user(i->it_interval.tv_sec, &o->it_interval.tv_sec) |\n\t\t __put_user(i->it_interval.tv_usec, &o->it_interval.tv_usec) |\n\t\t __put_user(i->it_value.tv_sec, &o->it_value.tv_sec) |\n\t\t __put_user(i->it_value.tv_usec, &o->it_value.tv_usec)));\n}", "target": 0}
{"code": "void DHT::restore_hots()\n{\n  int iwidth = libraw.imgdata.sizes.iwidth;\n#if defined(LIBRAW_USE_OPENMP)\n#ifdef _MSC_VER\n#pragma omp parallel for firstprivate(iwidth)\n#else\n#pragma omp parallel for schedule(guided) firstprivate(iwidth) collapse(2)\n#endif\n#endif\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    for (int j = 0; j < iwidth; ++j)\n    {\n      int x = j + nr_leftmargin;\n      int y = i + nr_topmargin;\n      if (ndir[nr_offset(y, x)] & HOT)\n      {\n        int l = libraw.COLOR(i, j);\n        nraw[nr_offset(i + nr_topmargin, j + nr_leftmargin)][l] =\n            libraw.imgdata.image[i * iwidth + j][l];\n      }\n    }\n  }\n}", "target": 0}
{"code": "errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n                            const char *input,\n                            char **sanitized)\n{\n    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n}", "target": 1}
{"code": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\treturn usb_serial_generic_open(tty, port);\n}", "target": 1}
{"code": "date_s__valid_nth_kday_p(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE vy, vm, vn, vk, vsg;\n    VALUE argv2[5];\n    rb_scan_args(argc, argv, \"41\", &vy, &vm, &vn, &vk, &vsg);\n    argv2[0] = vy;\n    argv2[1] = vm;\n    argv2[2] = vn;\n    argv2[3] = vk;\n    if (argc < 5)\n\targv2[4] = DBL2NUM(GREGORIAN);\n    else\n\targv2[4] = vsg;\n    return valid_nth_kday_sub(5, argv2, klass, 1);\n}", "target": 0}
{"code": "static av_always_inline float flt16_even(float pf)\n{\n    union av_intfloat32 tmp;\n    tmp.f = pf;\n    tmp.i = (tmp.i + 0x00007FFFU + (tmp.i & 0x00010000U >> 16)) & 0xFFFF0000U;\n    return tmp.f;\n}", "target": 0}
{"code": "base64_decode(packet_info *pinfo, tvbuff_t *b64_tvb, char *name)\n{\n    char *data;\n    tvbuff_t *tvb;\n    data = tvb_get_string_enc(wmem_packet_scope(), b64_tvb, 0, tvb_reported_length(b64_tvb), ENC_ASCII);\n    tvb = base64_to_tvb(b64_tvb, data);\n    add_new_data_source(pinfo, tvb, name);\n    return tvb;\n}", "target": 0}
{"code": "raptor_libxml_resolveEntity(void* user_data, \n                            const xmlChar *publicId, const xmlChar *systemId) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_resolveEntity(sax2->xc, publicId, systemId);\n}", "target": 1}
{"code": "policies_exit_policy_append_reject_star(smartlist_t **dest)\n{\n  append_exit_policy_string(dest, \"reject *:*\");\n}", "target": 0}
{"code": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\treturn ret;\n}", "target": 1}
{"code": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "rb_handle_timestamp(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t    struct rb_event_info *info)\n{\n\tWARN_ONCE(info->delta > (1ULL << 59),\n\t\t  KERN_WARNING \"Delta way too big! %llu ts=%llu write stamp = %llu\\n%s\",\n\t\t  (unsigned long long)info->delta,\n\t\t  (unsigned long long)info->ts,\n\t\t  (unsigned long long)cpu_buffer->write_stamp,\n\t\t  sched_clock_stable() ? \"\" :\n\t\t  \"If you just came from a suspend/resume,\\n\"\n\t\t  \"please switch to the trace global clock:\\n\"\n\t\t  \"  echo global > /sys/kernel/debug/tracing/trace_clock\\n\");\n\tinfo->add_timestamp = 1;\n}", "target": 0}
{"code": "void DevToolsDownloadManagerDelegate::Shutdown() {\n  if (proxy_download_delegate_)\n    proxy_download_delegate_->Shutdown();\n  download_manager_ = nullptr;\n}", "target": 0}
{"code": "pci_lintr_route(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct intxinfo *ii;\n\tif (dev->lintr.pin == 0)\n\t\treturn;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tii = &bi->slotinfo[dev->slot].si_intpins[dev->lintr.pin - 1];\n\tif (ii->ii_ioapic_irq == 0)\n\t\tii->ii_ioapic_irq = ioapic_pci_alloc_irq(dev);\n\tassert(ii->ii_ioapic_irq > 0);\n\tif (ii->ii_pirq_pin == 0)\n\t\tii->ii_pirq_pin = pirq_alloc_pin(dev);\n\tassert(ii->ii_pirq_pin > 0);\n\tdev->lintr.ioapic_irq = ii->ii_ioapic_irq;\n\tdev->lintr.pirq_pin = ii->ii_pirq_pin;\n\tpci_set_cfgdata8(dev, PCIR_INTLINE, pirq_irq(ii->ii_pirq_pin));\n}", "target": 1}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "void ContainerNode::notifyNodeRemoved(Node& root)\n{\n    ScriptForbiddenScope forbidScript;\n    EventDispatchForbiddenScope assertNoEventDispatch;\n    for (Node& node : NodeTraversal::inclusiveDescendantsOf(root)) {\n        if (!node.isContainerNode() && !node.isInTreeScope())\n            continue;\n        node.removedFrom(this);\n        for (ShadowRoot* shadowRoot = node.youngestShadowRoot(); shadowRoot; shadowRoot = shadowRoot->olderShadowRoot())\n            notifyNodeRemoved(*shadowRoot);\n    }\n}", "target": 0}
{"code": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}", "target": 1}
{"code": "static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}", "target": 1}
{"code": "mark_op_resolved (FlatpakTransactionOperation *op,\n                  const char                  *commit,\n                  GFile                       *sideload_path,\n                  GBytes                      *metadata,\n                  GBytes                      *old_metadata)\n{\n  g_debug (\"marking op %s:%s resolved to %s\", kind_to_str (op->kind), flatpak_decomposed_get_ref (op->ref), commit ? commit : \"-\");\n  g_assert (op != NULL);\n  g_assert (commit != NULL);\n  op->resolved = TRUE;\n  if (op->resolved_commit != commit)\n    {\n      g_free (op->resolved_commit); \n      op->resolved_commit = g_strdup (commit);\n    }\n  if (sideload_path)\n    op->resolved_sideload_path = g_object_ref (sideload_path);\n  if (metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_metadata = g_bytes_ref (metadata);\n          op->resolved_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n  if (old_metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, old_metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_old_metadata = g_bytes_ref (old_metadata);\n          op->resolved_old_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse old metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n}", "target": 1}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 0}
{"code": "njs_string_slice(njs_vm_t *vm, njs_value_t *dst,\n    const njs_string_prop_t *string, const njs_slice_prop_t *slice)\n{\n    njs_string_prop_t  prop;\n    njs_string_slice_string_prop(&prop, string, slice);\n    if (njs_fast_path(prop.size != 0)) {\n        return njs_string_new(vm, dst, prop.start, prop.size, prop.length);\n    }\n    *dst = njs_string_empty;\n    return NJS_OK;\n}", "target": 0}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}", "target": 1}
{"code": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}", "target": 1}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 1}
{"code": "static struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}", "target": 1}
{"code": "int ssl_init(void) { \n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS |\n        OPENSSL_INIT_LOAD_CRYPTO_STRINGS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#else\n    OPENSSL_config(NULL);\n    SSL_load_error_strings();\n    SSL_library_init();\n#endif\n    index_ssl_cli=SSL_get_ex_new_index(0,\n        \"CLI pointer\", NULL, NULL, NULL);\n    index_ssl_ctx_opt=SSL_CTX_get_ex_new_index(0,\n        \"SERVICE_OPTIONS pointer\", NULL, NULL, NULL);\n    index_session_authenticated=SSL_SESSION_get_ex_new_index(0,\n        \"session authenticated\", NULL, NULL, NULL);\n    index_session_connect_address=SSL_SESSION_get_ex_new_index(0,\n        \"session connect address\", NULL, cb_dup_addr, cb_free_addr);\n    if(index_ssl_cli<0 || index_ssl_ctx_opt<0 ||\n            index_session_authenticated<0 ||\n            index_session_connect_address<0) {\n        s_log(LOG_ERR, \"Application specific data initialization failed\");\n        return 1;\n    }\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_load_builtin_engines();\n#endif\n#ifndef OPENSSL_NO_DH\n    dh_params=get_dh2048();\n    if(!dh_params) {\n        s_log(LOG_ERR, \"Failed to get default DH parameters\");\n        return 1;\n    }\n#endif \n    return 0;\n}", "target": 1}
{"code": "void gdImageString (gdImagePtr im, gdFontPtr f, int x, int y, unsigned char *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen ((char *) s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageChar(im, f, x, y, s[i], color);\n\t\tx += f->w;\n\t}\n}", "target": 0}
{"code": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tgoto error;\n\t}\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static void sctp_destroy_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp;\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\tsp = sctp_sk(sk);\n\tif (sp->ep == NULL)\n\t\treturn;\n\tif (sp->do_auto_asconf) {\n\t\tsp->do_auto_asconf = 0;\n\t\tlist_del(&sp->auto_asconf_list);\n\t}\n\tsctp_endpoint_free(sp->ep);\n\tlocal_bh_disable();\n\tsk_sockets_allocated_dec(sk);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n}", "target": 1}
{"code": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}", "target": 1}
{"code": "void GLES2DecoderImpl::DoColorMask(\n    GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {\n  mask_red_ = red;\n  mask_green_ = green;\n  mask_blue_ = blue;\n  mask_alpha_ = alpha;\n  glColorMask(red, green, blue, alpha);\n}", "target": 0}
{"code": "static bool rb_is_reader_page(struct buffer_page *page)\n{\n\tstruct list_head *list = page->list.prev;\n\treturn rb_list_head(list->next) != &page->list;\n}", "target": 0}
{"code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}", "target": 1}
{"code": "static int metachar(char c)\n{\n\treturn (strchr(metachars(), c) != NULL);\n}", "target": 1}
{"code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   \n    size_t dsize;                  \n    unsigned char *buf = 0;\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}", "target": 1}
{"code": "return_enc_padata(krb5_context context, krb5_data *req_pkt,\n                  krb5_kdc_req *request, krb5_keyblock *reply_key,\n                  krb5_db_entry *server, krb5_enc_kdc_rep_part *reply_encpart,\n                  krb5_boolean is_referral)\n{\n    krb5_error_code code = 0;\n    assert(reply_encpart->enc_padata == NULL);\n    if (is_referral) {\n        code = return_referral_enc_padata(context, reply_encpart, server);\n        if (code)\n            return code;\n    }\n    code = kdc_handle_protected_negotiation(context, req_pkt, request, reply_key,\n                                            &reply_encpart->enc_padata);\n    if (code)\n        goto cleanup;\ncleanup:\n    return code;\n}", "target": 1}
{"code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    return get_bits_count(&gb);\n}", "target": 1}
{"code": "static inline void nf_reset(struct sk_buff *skb)\n{\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\n\tnf_conntrack_put(skb->nfct);\n\tskb->nfct = NULL;\n#endif\n#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED\n\tnf_conntrack_put_reasm(skb->nfct_reasm);\n\tskb->nfct_reasm = NULL;\n#endif\n#ifdef CONFIG_BRIDGE_NETFILTER\n\tnf_bridge_put(skb->nf_bridge);\n\tskb->nf_bridge = NULL;\n#endif\n}", "target": 0}
{"code": "void SimpleModule::runPull()\n{\n\tpull(m_outChunk->frameCount);\n\trun(*m_inChunk, *m_outChunk);\n}", "target": 1}
{"code": "bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=(size_t)Arc.FileHead.PackSize;\n    if (DataSize>ASIZE(Target)-1)\n      return false;\n    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)\n      return false;\n    Target[DataSize]=0;\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n    wchar TargetW[NM];\n    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n      return false;\n    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n        !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))\n      return false;\n    return UnixSymlink(Cmd,Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}", "target": 1}
{"code": "int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len)\n{\n\tif (rr_nested == NULL || data == NULL || data_len <= 0) {\n\t\treturn -1;\n\t}\n\tif (_dns_left_len(&rr_nested->context) < data_len) {\n\t\treturn -1;\n\t}\n\tmemcpy(rr_nested->context.ptr, data, data_len);\n\trr_nested->context.ptr += data_len;\n\treturn 0;\n}", "target": 1}
{"code": "monitor_sync(struct monitor *pmonitor)\n{\n\tif (options.compression) {\n\t\tmm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);\n\t}\n}", "target": 1}
{"code": "get_smb2_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\t     const char *path, u32 *pacllen, u32 info)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tunsigned int xid;\n\tint rc;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\t__le16 *utf16_path;\n\tcifs_dbg(FYI, \"get smb3 acl for path %s\\n\", path);\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path) {\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn ERR_PTR(rc);\n\t}\n\toparms.tcon = tcon;\n\toparms.desired_access = READ_CONTROL;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = cifs_create_options(cifs_sb, 0) | OPEN_REPARSE_POINT;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\tif (info & SACL_SECINFO)\n\t\toparms.desired_access |= SYSTEM_SECURITY;\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL, NULL,\n\t\t       NULL);\n\tkfree(utf16_path);\n\tif (!rc) {\n\t\trc = SMB2_query_acl(xid, tlink_tcon(tlink), fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (void **)&pntsd, pacllen,\n\t\t\t\t    info);\n\t\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\t}\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}", "target": 0}
{"code": "PackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "void pdu_submit(V9fsPDU *pdu, P9MsgHeader *hdr)\n{\n    Coroutine *co;\n    CoroutineEntry *handler;\n    V9fsState *s = pdu->s;\n    pdu->size = le32_to_cpu(hdr->size_le);\n    pdu->id = hdr->id;\n    pdu->tag = le16_to_cpu(hdr->tag_le);\n    if (pdu->id >= ARRAY_SIZE(pdu_co_handlers) ||\n        (pdu_co_handlers[pdu->id] == NULL)) {\n        handler = v9fs_op_not_supp;\n    } else if (is_ro_export(&s->ctx) && !is_read_only_op(pdu)) {\n        handler = v9fs_fs_ro;\n    } else {\n        handler = pdu_co_handlers[pdu->id];\n    }\n    qemu_co_queue_init(&pdu->complete);\n    co = qemu_coroutine_create(handler, pdu);\n    qemu_coroutine_enter(co);\n}", "target": 0}
{"code": "static int calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn + (bandno + 2) / 3);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static char *str_dup_safe_fixed(const ut8 *b, const ut8 *str, ut64 len, const ut8 *end) {\n\tif (str >= b && str + len < end) {\n\t\tchar *result = calloc (1, len + 1);\n\t\tif (result) {\n\t\t\tr_str_ncpy (result, (const char *)str, len);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "int RGWGetObj_ObjStore_S3Website::send_response_data(bufferlist& bl, off_t bl_ofs, off_t bl_len) {\n  map<string, bufferlist>::iterator iter;\n  iter = attrs.find(RGW_ATTR_AMZ_WEBSITE_REDIRECT_LOCATION);\n  if (iter != attrs.end()) {\n    bufferlist &bl = iter->second;\n    s->redirect = bl.c_str();\n    s->err.http_ret = 301;\n    ldout(s->cct, 20) << __CEPH_ASSERT_FUNCTION << \" redirecting per x-amz-website-redirect-location=\" << s->redirect << dendl;\n    op_ret = -ERR_WEBSITE_REDIRECT;\n    set_req_state_err(s, op_ret);\n    dump_errno(s);\n    dump_content_length(s, 0);\n    dump_redirect(s, s->redirect);\n    end_header(s, this);\n    return op_ret;\n  } else {\n    return RGWGetObj_ObjStore_S3::send_response_data(bl, bl_ofs, bl_len);\n  }\n}", "target": 0}
{"code": "static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i;\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = shinfo->frags + i;\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct page *page;\n\t\tu16 pending_idx;\n\t\tpending_idx = frag_get_pending_idx(frag);\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tpage = virt_to_page(idx_to_kaddr(netbk, pending_idx));\n\t\t__skb_fill_page_desc(skb, i, page, txp->offset, txp->size);\n\t\tskb->len += txp->size;\n\t\tskb->data_len += txp->size;\n\t\tskb->truesize += txp->size;\n\t\tget_page(netbk->mmap_pages[pending_idx]);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t}\n}", "target": 1}
{"code": "reg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0)\n\treturn FALSE;\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n    if (mode == 'v')\n    {\n\tcol = (colnr_T)(rex.input - rex.line);\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\tcols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\tif (!(dev->flags & IFF_UP))\n\t\treturn NET_RX_DROP;\n\tif (skb->len > (dev->mtu + dev->hard_header_len))\n\t\treturn NET_RX_DROP;\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}", "target": 1}
{"code": "static inline bool mpOk(const QString &mp)\n{\n    return !mp.isEmpty() && mp.startsWith(\"/home/\"); \n}", "target": 1}
{"code": "int gnutls_x509_ext_import_basic_constraints(const gnutls_datum_t * ext,\n\t\t\t\t\t  unsigned int *ca, int *pathlen)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tchar str[128]=\"\";\n\tint len, result;\n\tif ((result = asn1_create_element\n\t     (_gnutls_get_pkix(), \"PKIX1.BasicConstraints\",\n\t      &c2)) != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_der_decoding(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (pathlen) {\n\t\tresult = _gnutls_x509_read_uint(c2, \"pathLenConstraint\",\n\t\t\t\t\t\t(unsigned int *)\n\t\t\t\t\t\tpathlen);\n\t\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND)\n\t\t\t*pathlen = -1;\n\t\telse if (result != GNUTLS_E_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tresult = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tlen = sizeof(str) - 1;\n\tresult = asn1_read_value(c2, \"cA\", str, &len);\n\tif (result == ASN1_SUCCESS && strcmp(str, \"TRUE\") == 0)\n\t\t*ca = 1;\n\telse\n\t\t*ca = 0;\n\tresult = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn result;\n}", "target": 0}
{"code": "date_s__iso8601(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, opt;\n    rb_scan_args(argc, argv, \"1:\", &str, &opt);\n    check_limit(str, opt);\n    return date__iso8601(str);\n}", "target": 0}
{"code": "TEST(RegexMatchExpression, MatchesElementExtendedOn) {\n    BSONObj match = BSON(\"x\"\n                         << \"ab\");\n    BSONObj notMatch = BSON(\"x\"\n                            << \"a b\");\n    RegexMatchExpression regex(\"\", \"a b\", \"x\");\n    ASSERT(regex.matchesSingleElement(match.firstElement()));\n    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));\n}", "target": 0}
{"code": "static void increment_offset(int64_t delta)\n{\n    if (unlikely(delta == 0))\n        return;\n    location.offset += delta;\n    set_curr_offs(location.offset);\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}", "target": 1}
{"code": "int test_gtpu_send_indirect_data_forwarding(\n        ogs_socknode_t *node, test_bearer_t *bearer, ogs_pkbuf_t *pkbuf)\n{\n    test_sess_t *sess = NULL;\n    ogs_gtp2_header_t gtp_hdesc;\n    ogs_gtp2_extension_header_t ext_hdesc;\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    ogs_assert(pkbuf);\n    memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n    memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n    gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n    if (bearer->qfi) {\n        gtp_hdesc.teid = sess->handover.upf_dl_teid;\n        ext_hdesc.qos_flow_identifier = bearer->qfi;\n    } else if (bearer->ebi) {\n        ogs_fatal(\"Not implmented EPC Indirect Tunnel\");\n        ogs_assert_if_reached();\n    } else {\n        ogs_fatal(\"No QFI[%d] and EBI[%d]\", bearer->qfi, bearer->ebi);\n        ogs_assert_if_reached();\n    }\n    return test_gtpu_send(node, bearer, &gtp_hdesc, &ext_hdesc, pkbuf);\n}", "target": 1}
{"code": "void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\tstatic_key_slow_dec(&kvm_no_apic_vcpu);\n}", "target": 0}
{"code": "mrb_decode_insn(const mrb_code *pc)\n{\n  struct mrb_insn_data data = { 0 };\n  if (pc == 0) return data;\n  data.addr = pc;\n  mrb_code insn = READ_B();\n  uint16_t a = 0;\n  uint16_t b = 0;\n  uint16_t c = 0;\n  switch (insn) {\n#define FETCH_Z() \n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n  }\n  switch (insn) {\n  case OP_EXT1:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _1 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT2:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _2 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT3:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _3 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  default:\n    break;\n  }\n  data.insn = insn;\n  data.a = a;\n  data.b = b;\n  data.c = c;\n  return data;\n}", "target": 0}
{"code": "swallow_until_crlf(int fd, uschar *base, int already, int capacity)\n{\nuschar *to = base + already;\nuschar *cr;\nint have = 0;\nint ret;\nint last = 0;\ncr = memchr(base, '\\r', already);\nif (cr != NULL)\n  {\n  if ((cr - base) < already - 1)\n    {\n    return 0;\n    }\n  last = 1;\n  }\nwhile (capacity > 0)\n  {\n  do { ret = recv(fd, to, 1, 0); } while (ret == -1 && errno == EINTR);\n  if (ret == -1)\n    return -1;\n  have++;\n  if (last)\n    return have;\n  if (*to == '\\r')\n    last = 1;\n  capacity--;\n  to++;\n  }\nerrno = EOVERFLOW;\nreturn -1;\n}", "target": 0}
{"code": "static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,\n                                const unsigned char* in, size_t i, const LodePNGColorMode* mode)\n{\n  if(mode->colortype == LCT_GREY)\n  {\n    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];\n    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\n    else *a = 65535;\n  }\n  else if(mode->colortype == LCT_RGB)\n  {\n    *r = 256 * in[i * 6 + 0] + in[i * 6 + 1];\n    *g = 256 * in[i * 6 + 2] + in[i * 6 + 3];\n    *b = 256 * in[i * 6 + 4] + in[i * 6 + 5];\n    if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n       && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n       && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\n    else *a = 65535;\n  }\n  else if(mode->colortype == LCT_GREY_ALPHA)\n  {\n    *r = *g = *b = 256 * in[i * 4 + 0] + in[i * 4 + 1];\n    *a = 256 * in[i * 4 + 2] + in[i * 4 + 3];\n  }\n  else if(mode->colortype == LCT_RGBA)\n  {\n    *r = 256 * in[i * 8 + 0] + in[i * 8 + 1];\n    *g = 256 * in[i * 8 + 2] + in[i * 8 + 3];\n    *b = 256 * in[i * 8 + 4] + in[i * 8 + 5];\n    *a = 256 * in[i * 8 + 6] + in[i * 8 + 7];\n  }\n}", "target": 0}
{"code": "  explicit BoostedTreesAggregateStatsOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n  }", "target": 0}
{"code": "MagickPrivate size_t GetOptimalKernelWidth2D(const double radius,\n  const double sigma)\n{\n  double\n    alpha,\n    beta,\n    gamma,\n    normalize,\n    value;\n  size_t\n    width;\n  ssize_t\n    j,\n    u,\n    v;\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (radius > MagickEpsilon)\n    return((size_t) (2.0*ceil(radius)+1.0));\n  gamma=fabs(sigma);\n  if (gamma <= MagickEpsilon)\n    return(3UL);\n  alpha=PerceptibleReciprocal(2.0*gamma*gamma);\n  beta=(double) PerceptibleReciprocal((double) Magick2PI*gamma*gamma);\n  for (width=5; ; )\n  {\n    normalize=0.0;\n    j=(ssize_t) (width-1)/2;\n    for (v=(-j); v <= j; v++)\n      for (u=(-j); u <= j; u++)\n        normalize+=exp(-((double) (u*u+v*v))*alpha)*beta;\n    value=exp(-((double) (j*j))*alpha)*beta/normalize;\n    if ((value < QuantumScale) || (value < MagickEpsilon))\n      break;\n    width+=2;\n  }\n  return((size_t) (width-2));\n}", "target": 0}
{"code": "void stl_phys(AddressSpace *as, hwaddr addr, uint32_t val)\n{\n    address_space_stl(as, addr, val, MEMTXATTRS_UNSPECIFIED, NULL);\n}", "target": 0}
{"code": "static void __exit packet_exit(void)\n{\n\tunregister_netdevice_notifier(&packet_netdev_notifier);\n\tunregister_pernet_subsys(&packet_net_ops);\n\tsock_unregister(PF_PACKET);\n\tproto_unregister(&packet_proto);\n}", "target": 0}
{"code": "static void naludmx_update_nalu_maxsize(GF_NALUDmxCtx *ctx, u32 size)\n{\n\tif (ctx->max_nalu_size < size) {\n\t\tctx->max_nalu_size = size;\n\t\tif (size > ctx->max_nalu_size_allowed) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] nal size %d larger than max allowed size %d - change import settings\\n\", ctx->log_name, size, ctx->max_nalu_size_allowed ));\n\t\t}\n\t}\n}", "target": 0}
{"code": "pci_get_vdev_info(int slot)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct pci_vdev *dev = NULL;\n\tbi = pci_businfo[0];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[slot];\n\tif (si != NULL)\n\t\tdev = si->si_funcs[0].fi_devi;\n\telse\n\t\tfprintf(stderr, \"slot=%d is empty!\\n\", slot);\n\treturn dev;\n}", "target": 1}
{"code": "  void connectErr(const AsyncSocketException& ex) noexcept override {\n    FAIL() << ex.what();\n  }", "target": 0}
{"code": "monitor_init(void)\n{\n\tstruct ssh *ssh = active_state;\t\t\t\n\tstruct monitor *mon;\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\tif (options.compression) {\n\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n\treturn mon;\n}", "target": 1}
{"code": "static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)\n{\n  ExitDataCP *exd = (ExitDataCP *)ud;\n  cframe_errfunc(L->cframe) = -1;  \n  exd->pc = lj_snap_restore(exd->J, exd->exptr);\n  UNUSED(dummy);\n  return NULL;\n}", "target": 1}
{"code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n\tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tnla_strlcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]),\n\t\t    TIPC_MAX_LINK_NAME);\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n\t\t\t    &link_info, sizeof(link_info));\n}", "target": 0}
{"code": "parsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}", "target": 1}
{"code": "void *TrustedPrimitives::UntrustedLocalAlloc(size_t size) noexcept {\n  void *result;\n  CHECK_OCALL(\n      ocall_untrusted_local_alloc(&result, static_cast<uint64_t>(size)));\n  if (result && !IsOutsideEnclave(result, static_cast<uint64_t>(size))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Allocated memory not found to be outside the enclave.\");\n  }\n  if (!result) {\n    errno = ENOMEM;\n    TrustedPrimitives::DebugPuts(\"UntrustedLocalAlloc on SGX failed.\");\n  }\n  return result;\n}", "target": 0}
{"code": "int con_clear_unimap(struct vc_data *vc)\n{\n\tint ret;\n\tconsole_lock();\n\tret = con_do_clear_unimap(vc);\n\tconsole_unlock();\n\treturn ret;\n}", "target": 0}
{"code": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}", "target": 1}
{"code": "Status ArrayFromMemory(int dim_size, npy_intp* dims, void* data, DataType dtype,\n                       std::function<void()> destructor, PyObject** result) {\n  if (dtype == DT_STRING || dtype == DT_RESOURCE) {\n    return errors::FailedPrecondition(\n        \"Cannot convert string or resource Tensors.\");\n  }\n  int type_num = -1;\n  Status s =\n      TF_DataType_to_PyArray_TYPE(static_cast<TF_DataType>(dtype), &type_num);\n  if (!s.ok()) {\n    return s;\n  }\n  if (dim_size > NPY_MAXDIMS) {\n    return errors::InvalidArgument(\n        \"Cannot convert tensor with \", dim_size,\n        \" dimensions to NumPy array. NumPy arrays can have at most \",\n        NPY_MAXDIMS, \" dimensions\");\n  }\n  auto* np_array = reinterpret_cast<PyArrayObject*>(\n      PyArray_SimpleNewFromData(dim_size, dims, type_num, data));\n  if (np_array == nullptr) {\n    string shape_str = absl::StrJoin(\n        absl::Span<npy_intp>{dims, static_cast<size_t>(dim_size)}, \", \");\n    if (PyErr_Occurred()) {\n      string exception_str = PyExceptionFetch();\n      PyErr_Clear();\n      return errors::InvalidArgument(\n          \"Failed to create numpy array from tensor of shape [\", shape_str,\n          \"]. Numpy error: \", exception_str);\n    }\n    return errors::Internal(\n        \"Failed to create numpy array from tensor of shape [\", shape_str, \"]\");\n  }\n  PyArray_CLEARFLAGS(np_array, NPY_ARRAY_OWNDATA);\n  if (PyType_Ready(&TensorReleaserType) == -1) {\n    return errors::Unknown(\"Python type initialization failed.\");\n  }\n  auto* releaser = reinterpret_cast<TensorReleaser*>(\n      TensorReleaserType.tp_alloc(&TensorReleaserType, 0));\n  releaser->destructor = new std::function<void()>(std::move(destructor));\n  if (PyArray_SetBaseObject(np_array, reinterpret_cast<PyObject*>(releaser)) ==\n      -1) {\n    Py_DECREF(releaser);\n    return errors::Unknown(\"Python array refused to use memory.\");\n  }\n  *result = reinterpret_cast<PyObject*>(np_array);\n  return OkStatus();\n}", "target": 0}
{"code": "jd_to_nth_kday(VALUE jd, double sg,\n\t       VALUE *nth, int *rjd,\n\t       int *ry, int *rm, int *rn, int *rk)\n{\n    decode_jd(jd, nth, rjd);\n    c_jd_to_nth_kday(*rjd, sg, ry, rm, rn, rk);\n}", "target": 0}
{"code": "static inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}", "target": 1}
{"code": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\treturn raw;\n}", "target": 1}
{"code": "static inline vm_fault_t hugetlb_handle_userfault(struct vm_area_struct *vma,\n\t\t\t\t\t\t  struct address_space *mapping,\n\t\t\t\t\t\t  pgoff_t idx,\n\t\t\t\t\t\t  unsigned int flags,\n\t\t\t\t\t\t  unsigned long haddr,\n\t\t\t\t\t\t  unsigned long reason)\n{\n\tvm_fault_t ret;\n\tu32 hash;\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = haddr,\n\t\t.flags = flags,\n\t};\n\thash = hugetlb_fault_mutex_hash(mapping, idx);\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\ti_mmap_unlock_read(mapping);\n\tret = handle_userfault(&vmf, reason);\n\ti_mmap_lock_read(mapping);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\treturn ret;\n}", "target": 0}
{"code": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "archive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\tzip = (struct zip *)(a->format->data);\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n\t\tinflateEnd(&zip->stream);\n#endif\n#if HAVA_LZMA_H && HAVE_LIBLZMA\n    if (zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t}\n#endif\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\tfree(zip->uncompressed_buffer);\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}", "target": 1}
{"code": "Value ExpressionDateFromParts::evaluate(const Document& root, Variables* variables) const {\n    long long hour, minute, second, millisecond;\n    if (!evaluateNumberWithDefaultAndBounds(root, _hour.get(), \"hour\"_sd, 0, &hour, variables) ||\n        !evaluateNumberWithDefaultAndBounds(\n            root, _minute.get(), \"minute\"_sd, 0, &minute, variables) ||\n        !evaluateNumberWithDefault(root, _second.get(), \"second\"_sd, 0, &second, variables) ||\n        !evaluateNumberWithDefault(\n            root, _millisecond.get(), \"millisecond\"_sd, 0, &millisecond, variables)) {\n        return Value(BSONNULL);\n    }\n    auto timeZone =\n        makeTimeZone(getExpressionContext()->timeZoneDatabase, root, _timeZone.get(), variables);\n    if (!timeZone) {\n        return Value(BSONNULL);\n    }\n    if (_year) {\n        long long year, month, day;\n        if (!evaluateNumberWithDefault(root, _year.get(), \"year\"_sd, 1970, &year, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _month.get(), \"month\"_sd, 1, &month, variables) ||\n            !evaluateNumberWithDefaultAndBounds(root, _day.get(), \"day\"_sd, 1, &day, variables)) {\n            return Value(BSONNULL);\n        }\n        uassert(40523,\n                str::stream() << \"'year' must evaluate to an integer in the range \" << 1 << \" to \"\n                              << 9999 << \", found \" << year,\n                year >= 1 && year <= 9999);\n        return Value(\n            timeZone->createFromDateParts(year, month, day, hour, minute, second, millisecond));\n    }\n    if (_isoWeekYear) {\n        long long isoWeekYear, isoWeek, isoDayOfWeek;\n        if (!evaluateNumberWithDefault(\n                root, _isoWeekYear.get(), \"isoWeekYear\"_sd, 1970, &isoWeekYear, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _isoWeek.get(), \"isoWeek\"_sd, 1, &isoWeek, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _isoDayOfWeek.get(), \"isoDayOfWeek\"_sd, 1, &isoDayOfWeek, variables)) {\n            return Value(BSONNULL);\n        }\n        uassert(31095,\n                str::stream() << \"'isoWeekYear' must evaluate to an integer in the range \" << 1\n                              << \" to \" << 9999 << \", found \" << isoWeekYear,\n                isoWeekYear >= 1 && isoWeekYear <= 9999);\n        return Value(timeZone->createFromIso8601DateParts(\n            isoWeekYear, isoWeek, isoDayOfWeek, hour, minute, second, millisecond));\n    }\n    MONGO_UNREACHABLE;\n}", "target": 0}
{"code": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr >> 12) & 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value;\n\tregs->ARM_pc += 4;\n\treturn 0;\n}", "target": 1}
{"code": "void blog_post(char post_path[]) {\n\tif(strlen(post_path) != 0 || post_path[0] == '.'\n\t\t\t|| strchr(post_path, '/') == NULL) {\n\t\tsend_header(\"Content-type\", \"text/plain\");\n\t\tterminate_headers();\n\t\tprintf(\"No, my dear h4xxx0r :)\\nYou won\\'t do that :p\\n\");\n\t\treturn;\n\t}\n\tif(file_exists(post_path) > 0) {\n\t\tstruct blogpost post = make_blogpost(post_path);\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_post_single_entry(post);\n\t} else {\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tsend_header(\"Status\", \"404 Not Found\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_error_404();\n\t}\n\ttemplate_footer();\n}", "target": 0}
{"code": "void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 overrun;\n\tlockdep_assert_held(&cfs_b->lock);\n\tif (cfs_b->period_active)\n\t\treturn;\n\tcfs_b->period_active = 1;\n\toverrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\tcfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}", "target": 1}
{"code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tmm_init_uprobes_state(mm);\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "target": 0}
{"code": "static struct nfc_dev *__get_device_from_cb(struct netlink_callback *cb)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn ERR_PTR(-EINVAL);\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\treturn dev;\n}", "target": 0}
{"code": "int snd_timer_global_new(char *id, int device, struct snd_timer **rtimer)\n{\n\tstruct snd_timer_id tid;\n\ttid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = -1;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\treturn snd_timer_new(NULL, id, &tid, rtimer);\n}", "target": 0}
{"code": "int read_record_hdr(int ifd, void *buffer, struct record_header *record_hdr,\n\t\t    struct file_header *file_hdr, int arch_64, int endian_mismatch,\n\t\t    int oneof, size_t b_size)\n{\n\tint rc;\n\tdo {\n\t\tif ((rc = sa_fread(ifd, buffer, (size_t) file_hdr->rec_size, SOFT_SIZE, oneof)) != 0)\n\t\t\treturn rc;\n\t\tif (remap_struct(rec_types_nr, file_hdr->rec_types_nr, buffer,\n\t\t\t\t file_hdr->rec_size, RECORD_HEADER_SIZE, b_size) < 0)\n\t\t\treturn 2;\n\t\tmemcpy(record_hdr, buffer, RECORD_HEADER_SIZE);\n\t\tif (endian_mismatch) {\n\t\t\tswap_struct(rec_types_nr, record_hdr, arch_64);\n\t\t}\n\t\tif ((record_hdr->record_type != R_COMMENT) && (record_hdr->record_type != R_RESTART) &&\n\t\t    record_hdr->extra_next && (skip_extra_struct(ifd, endian_mismatch, arch_64) < 0))\n\t\t\treturn 2;\n\t}\n\twhile (record_hdr->record_type == R_EXTRA);\n\treturn 0;\n}", "target": 0}
{"code": "void rose_stop_timer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->timer);\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &getHeaders() const\n    {\n        return headers();\n    }", "target": 1}
{"code": "static int ion_handle_put(struct ion_handle *handle)\n{\n\tstruct ion_client *client = handle->client;\n\tint ret;\n\tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\tmutex_unlock(&client->lock);\n\treturn ret;\n}", "target": 1}
{"code": "static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)\n{\n#if BITS_PER_LONG == 32\n\treturn (u32)(unsigned long)reply;\n#else\n\tulong flags = 0;\n\tu32 nr, i;\n\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tnr = ARRAY_SIZE(pHba->ioctl_reply_context);\n\tfor (i = 0; i < nr; i++) {\n\t\tif (pHba->ioctl_reply_context[i] == NULL) {\n\t\t\tpHba->ioctl_reply_context[i] = reply;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\tif (i >= nr) {\n\t\tprintk(KERN_WARNING\"%s: Too many outstanding \"\n\t\t\t\t\"ioctl commands\\n\", pHba->name);\n\t\treturn (u32)-1;\n\t}\n\treturn i;\n#endif\n}", "target": 1}
{"code": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, NULL);\n\t\tfputs(\"\\n\", stdout);\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}", "target": 1}
{"code": "static char *get_pid_cgroup(pid_t pid, const char *contrl)\n{\n\tchar fnam[PROCLEN];\n\tFILE *f;\n\tchar *answer = NULL;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\tconst char *h = find_mounted_controller(contrl);\n\tif (!h)\n\t\treturn NULL;\n\tret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);\n\tif (ret < 0 || ret >= PROCLEN)\n\t\treturn NULL;\n\tif (!(f = fopen(fnam, \"r\")))\n\t\treturn NULL;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *c1, *c2;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\t\tc1 = strchr(line, ':');\n\t\tif (!c1)\n\t\t\tgoto out;\n\t\tc1++;\n\t\tc2 = strchr(c1, ':');\n\t\tif (!c2)\n\t\t\tgoto out;\n\t\t*c2 = '\\0';\n\t\tif (strcmp(c1, h) != 0)\n\t\t\tcontinue;\n\t\tc2++;\n\t\tstripnewline(c2);\n\t\tdo {\n\t\t\tanswer = strdup(c2);\n\t\t} while (!answer);\n\t\tbreak;\n\t}\nout:\n\tfclose(f);\n\tfree(line);\n\treturn answer;\n}", "target": 0}
{"code": "int RGWHandler_REST_S3Website::error_handler(int err_no,\n\t\t\t\t\t    string* error_content) {\n  int new_err_no = -1;\n  rgw_http_errors::const_iterator r = rgw_http_s3_errors.find(err_no > 0 ? err_no : -err_no);\n  int http_error_code = -1;\n  if (r != rgw_http_s3_errors.end()) {\n    http_error_code = r->second.first;\n  }\n  ldpp_dout(s, 10) << \"RGWHandler_REST_S3Website::error_handler err_no=\" << err_no << \" http_ret=\" << http_error_code << dendl;\n  RGWBWRoutingRule rrule;\n  bool should_redirect =\n    s->bucket_info.website_conf.should_redirect(original_object_name,\n                                                http_error_code, &rrule);\n  if (should_redirect) {\n    const string& hostname = s->info.env->get(\"HTTP_HOST\", \"\");\n    const string& protocol =\n      (s->info.env->get(\"SERVER_PORT_SECURE\") ? \"https\" : \"http\");\n    int redirect_code = 0;\n    rrule.apply_rule(protocol, hostname, original_object_name,\n                     &s->redirect, &redirect_code);\n    if (redirect_code > 0)\n      s->err.http_ret = redirect_code; \n    ldpp_dout(s, 10) << \"error handler redirect code=\" << redirect_code\n\t\t      << \" proto+host:\" << protocol << \":\n\t\t      << \" -> \" << s->redirect << dendl;\n    return -ERR_WEBSITE_REDIRECT;\n  } else if (err_no == -ERR_WEBSITE_REDIRECT) {\n  } else if (!s->bucket_info.website_conf.error_doc.empty()) {\n    new_err_no = RGWHandler_REST_S3Website::serve_errordoc(http_error_code, s->bucket_info.website_conf.error_doc);\n    if (new_err_no && new_err_no != -1) {\n      err_no = new_err_no;\n    }\n  } else {\n    ldpp_dout(s, 20) << \"No special error handling today!\" << dendl;\n  }\n  return err_no;\n}", "target": 0}
{"code": "void ConnectDialog::udpReply() {\n\tQUdpSocket *sock = qobject_cast<QUdpSocket *>(sender());\n\twhile (sock->hasPendingDatagrams()) {\n\t\tchar blob[64];\n\t\tQHostAddress host;\n\t\tunsigned short port;\n\t\tqint64 len = sock->readDatagram(blob+4, 24, &host, &port);\n\t\tif (len == 24) {\n\t\t\tif (host.scopeId() == QLatin1String(\"0\"))\n\t\t\t\thost.setScopeId(QLatin1String(\"\"));\n\t\t\tServerAddress address(HostAddress(host), port);\n\t\t\tif (qhPings.contains(address)) {\n\t\t\t\tquint32 *ping = reinterpret_cast<quint32 *>(blob+4);\n\t\t\t\tquint64 *ts = reinterpret_cast<quint64 *>(blob+8);\n\t\t\t\tquint64 elapsed = tPing.elapsed() - (*ts ^ qhPingRand.value(address));\n\t\t\t\tforeach(ServerItem *si, qhPings.value(address)) {\n\t\t\t\t\tsi->uiVersion = qFromBigEndian(ping[0]);\n\t\t\t\t\tquint32 users = qFromBigEndian(ping[3]);\n\t\t\t\t\tquint32 maxusers = qFromBigEndian(ping[4]);\n\t\t\t\t\tsi->uiBandwidth = qFromBigEndian(ping[5]);\n\t\t\t\t\tif (! si->uiPingSort)\n\t\t\t\t\t\tsi->uiPingSort = qmPingCache.value(UnresolvedServerAddress(si->qsHostname, si->usPort));\n\t\t\t\t\tsi->setDatas(static_cast<double>(elapsed), users, maxusers);\n\t\t\t\t\tsi->hideCheck();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "zrcheck(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    int code = access_check(i_ctx_p, a_read, false);\n    if (code >= 0)\n        make_bool(op, code), code = 0;\n    return code;\n}", "target": 0}
{"code": "void Document::UpdateStyleAndLayoutIgnorePendingStylesheets(\n    Document::RunPostLayoutTasks run_post_layout_tasks) {\n  UpdateStyleAndLayoutTreeIgnorePendingStylesheets();\n  UpdateStyleAndLayout();\n  if (run_post_layout_tasks == kRunPostLayoutTasksSynchronously && View())\n    View()->FlushAnyPendingPostLayoutTasks();\n}", "target": 0}
{"code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\tif (id < 0)\n\t\treturn NULL;\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\treturn peer;\n}", "target": 1}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline u32 nfsd4_readdir_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.readdir.rd_maxcount, maxcount);\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz +\n\t\tXDR_QUADLEN(rlen)) * sizeof(__be32);\n}", "target": 0}
{"code": "int crxFreeImageData(CrxImage *img)\n{\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "int nfc_stop_poll(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->polling) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tdev->ops->stop_poll(dev);\n\tdev->polling = false;\n\tdev->rf_mode = NFC_RF_NONE;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int make_cdt24_entry(int p1, int p2, int16_t *cdt)\n{\n    int r, b;\n    b = cdt[p2];\n    r = cdt[p1]<<16;\n    return (b+r) << 1;\n}", "target": 0}
{"code": "update_bar_address(struct vmctx *ctx, struct pci_vdev *dev, uint64_t addr,\n\tint idx, int type, bool ignore_reg_unreg)\n{\n\tbool decode = false;\n\tuint64_t orig_addr = dev->bar[idx].addr;\n\tif (!ignore_reg_unreg) {\n\t\tif (dev->bar[idx].type == PCIBAR_IO)\n\t\t\tdecode = porten(dev);\n\t\telse\n\t\t\tdecode = memen(dev);\n\t}\n\tif (decode)\n\t\tunregister_bar(dev, idx);\n\tswitch (type) {\n\tcase PCIBAR_IO:\n\tcase PCIBAR_MEM32:\n\t\tdev->bar[idx].addr = addr;\n\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}", "target": 1}
{"code": "moveToFreeBindingList(XML_Parser parser, BINDING *bindings) {\n  while (bindings) {\n    BINDING *b = bindings;\n    bindings = bindings->nextTagBinding;\n    b->nextTagBinding = parser->m_freeBindingList;\n    parser->m_freeBindingList = b;\n  }\n}", "target": 0}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "static CURLcode transfer_per_config(struct GlobalConfig *global,\n                                    struct OperationConfig *config,\n                                    CURLSH *share,\n                                    bool *added)\n{\n  CURLcode result = CURLE_OK;\n  bool capath_from_env;\n  *added = FALSE;\n  if(!config->url_list || !config->url_list->url) {\n    helpf(global->errors, \"no URL specified!\\n\");\n    return CURLE_FAILED_INIT;\n  }\n  capath_from_env = false;\n  if(!config->cacert &&\n     !config->capath &&\n     (!config->insecure_ok || (config->doh_url && !config->doh_insecure_ok))) {\n    CURL *curltls = curl_easy_init();\n    struct curl_tlssessioninfo *tls_backend_info = NULL;\n    result = curl_easy_getinfo(curltls, CURLINFO_TLS_SSL_PTR,\n                               &tls_backend_info);\n    if(result)\n      return result;\n    if(tls_backend_info->backend != CURLSSLBACKEND_SCHANNEL) {\n      char *env;\n      env = curlx_getenv(\"CURL_CA_BUNDLE\");\n      if(env) {\n        config->cacert = strdup(env);\n        if(!config->cacert) {\n          curl_free(env);\n          errorf(global, \"out of memory\\n\");\n          return CURLE_OUT_OF_MEMORY;\n        }\n      }\n      else {\n        env = curlx_getenv(\"SSL_CERT_DIR\");\n        if(env) {\n          config->capath = strdup(env);\n          if(!config->capath) {\n            curl_free(env);\n            helpf(global->errors, \"out of memory\\n\");\n            return CURLE_OUT_OF_MEMORY;\n          }\n          capath_from_env = true;\n        }\n        else {\n          env = curlx_getenv(\"SSL_CERT_FILE\");\n          if(env) {\n            config->cacert = strdup(env);\n            if(!config->cacert) {\n              curl_free(env);\n              errorf(global, \"out of memory\\n\");\n              return CURLE_OUT_OF_MEMORY;\n            }\n          }\n        }\n      }\n      if(env)\n        curl_free(env);\n#ifdef WIN32\n      else {\n        result = FindWin32CACert(config, tls_backend_info->backend,\n                                 TEXT(\"curl-ca-bundle.crt\"));\n      }\n#endif\n    }\n    curl_easy_cleanup(curltls);\n  }\n  if(!result)\n    result = single_transfer(global, config, share, capath_from_env, added);\n  return result;\n}", "target": 0}
{"code": "int tipc_nl_node_dump_monitor_peer(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tu32 prev_node = cb->args[1];\n\tu32 bearer_id = cb->args[2];\n\tint done = cb->args[0];\n\tstruct tipc_nl_msg msg;\n\tint err;\n\tif (!prev_node) {\n\t\tstruct nlattr **attrs = genl_dumpit_info(cb)->attrs;\n\t\tstruct nlattr *mon[TIPC_NLA_MON_MAX + 1];\n\t\tif (!attrs[TIPC_NLA_MON])\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested_deprecated(mon, TIPC_NLA_MON_MAX,\n\t\t\t\t\t\t  attrs[TIPC_NLA_MON],\n\t\t\t\t\t\t  tipc_nl_monitor_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!mon[TIPC_NLA_MON_REF])\n\t\t\treturn -EINVAL;\n\t\tbearer_id = nla_get_u32(mon[TIPC_NLA_MON_REF]);\n\t\tif (bearer_id >= MAX_BEARERS)\n\t\t\treturn -EINVAL;\n\t}\n\tif (done)\n\t\treturn 0;\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\trtnl_lock();\n\terr = tipc_nl_add_monitor_peer(net, &msg, bearer_id, &prev_node);\n\tif (!err)\n\t\tdone = 1;\n\trtnl_unlock();\n\tcb->args[0] = done;\n\tcb->args[1] = prev_node;\n\tcb->args[2] = bearer_id;\n\treturn skb->len;\n}", "target": 0}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\tstrlcpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n  imap_quote_string(dest, dlen, buf);\n  FREE(&buf);\n}", "target": 1}
{"code": "ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n    return str;\n}", "target": 0}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tfree(context->planesBuffer);\n\tfree(context->pTempData);\n\tfree(context->deltaPlanesBuffer);\n\tfree(context->rlePlanesBuffer);\n\tcontext->planesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->pTempData = calloc(context->maxPlaneSize, 6);\n\tcontext->deltaPlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->rlePlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tif (!context->planesBuffer || !context->pTempData || !context->deltaPlanesBuffer ||\n\t    !context->rlePlanesBuffer)\n\t\treturn FALSE;\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}", "target": 1}
{"code": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\treturn 0;\n}", "target": 1}
{"code": "cdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_tab = NULL;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\tscn->sst_ss = ss;\n\tif (scn->sst_len == (size_t)-1)\n\t\tgoto out;\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn cdf_zero_stream(scn);\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn cdf_zero_stream(scn);\n}", "target": 0}
{"code": "static void agent_connect(UdscsConnection *conn)\n{\n    struct agent_data *agent_data;\n    agent_data = g_new0(struct agent_data, 1);\n    GError *err = NULL;\n    if (session_info) {\n        PidUid pid_uid = vdagent_connection_get_peer_pid_uid(VDAGENT_CONNECTION(conn), &err);\n        if (err || pid_uid.pid <= 0) {\n            static const char msg[] = \"Could not get peer PID, disconnecting new client\";\n            if (err) {\n                syslog(LOG_ERR, \"%s: %s\", msg, err->message);\n                g_error_free(err);\n            } else {\n                syslog(LOG_ERR, \"%s\", msg);\n            }\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n        agent_data->session = session_info_session_for_pid(session_info, pid_uid.pid);\n        if (!check_uid_of_pid(pid_uid.pid, pid_uid.uid)) {\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n    }\n    g_object_set_data_full(G_OBJECT(conn), \"agent_data\", agent_data,\n                           (GDestroyNotify) agent_data_destroy);\n    udscs_write(conn, VDAGENTD_VERSION, 0, 0,\n                (uint8_t *)VERSION, strlen(VERSION) + 1);\n    update_active_session_connection(conn);\n    if (device_info) {\n        forward_data_to_session_agent(VDAGENTD_GRAPHICS_DEVICE_INFO,\n                                      (uint8_t *) device_info, device_info_size);\n    }\n}", "target": 1}
{"code": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\t*pos = '\\0'; \n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}", "target": 1}
{"code": "JANET_CORE_FN(cfun_array_new_filled,\n              \"(array/new-filled count &opt value)\",\n              \"Creates a new array of `count` elements, all set to `value`, which defaults to nil. Returns the new array.\") {\n    janet_arity(argc, 1, 2);\n    int32_t count = janet_getinteger(argv, 0);\n    if (count < 0) janet_panic(\"expected positive integer\");\n    Janet x = (argc == 2) ? argv[1] : janet_wrap_nil();\n    JanetArray *array = janet_array(count);\n    for (int32_t i = 0; i < count; i++) {\n        array->data[i] = x;\n    }\n    array->count = count;\n    return janet_wrap_array(array);\n}", "target": 0}
{"code": "\t\tSetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n    if (!frame)\n        return NULL;\n    frame->width  = w;\n    frame->height = h;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n    return frame;\n}", "target": 1}
{"code": "void HTMLSelectElement::dispatchFocusEvent(Element* oldFocusedElement, FocusDirection direction)\n{\n    if (usesMenuList())\n        saveLastSelection();\n    HTMLFormControlElementWithState::dispatchFocusEvent(oldFocusedElement, direction);\n}", "target": 0}
{"code": "make_valid_utf8 (string & str)\n{\n  const char *pos;\n  if (!g_utf8_validate (str.c_str(), -1, &pos)) {\n    PTRACE (4, \"Ekiga\\tTrimming invalid UTF-8 string: \" << str.c_str());\n    str = str.substr (0, pos - str.c_str()).append (\"...\");\n  }\n}", "target": 0}
{"code": "    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        if(len < 1)\n        {\n            return alloc;\n        }\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n        if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n        alloc = std::string(attr_vals);\n        return alloc;\n    }", "target": 1}
{"code": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\t*bounce_buf_ret = bounce_buf;\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}", "target": 1}
{"code": "static int decode_sao_offset_sign(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_offset_sign\\n\");\n  int value = decode_CABAC_bypass(&tctx->cabac_decoder);\n  logtrace(LogSymbols,\"$1 sao_offset_sign=%d\\n\",value);\n  return value;\n}", "target": 0}
{"code": "static int _process_request_metaflags(mcp_parser_t *pr, int token) {\n    if (pr->ntokens <= token) {\n        pr->t.meta.flags = 0; \n        return 0;\n    }\n    const char *cur = pr->request + pr->tokens[token];\n    const char *end = pr->request + pr->reqlen - 2;\n    int state = 0;\n    while (cur != end) {\n        switch (state) {\n            case 0:\n                if (*cur == ' ') {\n                    cur++;\n                } else {\n                    if (*cur < 65 || *cur > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", __func__, *cur - 65);\n                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);\n                    state = 1;\n                }\n                break;\n            case 1:\n                if (*cur != ' ') {\n                    cur++;\n                } else {\n                    state = 0;\n                }\n                break;\n        }\n    }\n    if (pr->t.meta.flags & ((uint64_t)1 << 48)) {\n        pr->noreply = true;\n    }\n    return 0;\n}", "target": 1}
{"code": "int snd_usb_apply_interface_quirk(struct snd_usb_audio *chip,\n\t\t\t\t  int iface,\n\t\t\t\t  int altno)\n{\n\tif (chip->usb_id == USB_ID(0x0763, 0x2003))\n\t\treturn audiophile_skip_setting_quirk(chip, iface, altno);\n\tif (chip->usb_id == USB_ID(0x0763, 0x2001))\n\t\treturn quattro_skip_setting_quirk(chip, iface, altno);\n\tif (chip->usb_id == USB_ID(0x0763, 0x2012))\n\t\treturn fasttrackpro_skip_setting_quirk(chip, iface, altno);\n\treturn 0;\n}", "target": 0}
{"code": "static int madvise_need_mmap_write(int behavior)\n{\n\tswitch (behavior) {\n\tcase MADV_REMOVE:\n\tcase MADV_WILLNEED:\n\tcase MADV_DONTNEED:\n\tcase MADV_COLD:\n\tcase MADV_PAGEOUT:\n\tcase MADV_FREE:\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}", "target": 0}
{"code": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\tgenl_lock_all();\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\tif (family == &genl_ctrl) {\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_locked;\n\t}\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\tgenl_unlock_all();\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\treturn 0;\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}", "target": 1}
{"code": "static int nbd_receive_option_reply(QIOChannel *ioc, uint32_t opt,\n                                    nbd_opt_reply *reply, Error **errp)\n{\n    QEMU_BUILD_BUG_ON(sizeof(*reply) != 20);\n    if (read_sync(ioc, reply, sizeof(*reply)) != sizeof(*reply)) {\n        error_setg(errp, \"failed to read option reply\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    be64_to_cpus(&reply->magic);\n    be32_to_cpus(&reply->option);\n    be32_to_cpus(&reply->type);\n    be32_to_cpus(&reply->length);\n    TRACE(\"Received option reply %\" PRIx32\", type %\" PRIx32\", len %\" PRIu32,\n          reply->option, reply->type, reply->length);\n    if (reply->magic != NBD_REP_MAGIC) {\n        error_setg(errp, \"Unexpected option reply magic\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    if (reply->option != opt) {\n        error_setg(errp, \"Unexpected option type %x expected %x\",\n                   reply->option, opt);\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "void CSSStyleSheet::addSubresourceStyleURLs(ListHashSet<KURL>& urls)\n{\n    Deque<CSSStyleSheet*> styleSheetQueue;\n    styleSheetQueue.append(this);\n    while (!styleSheetQueue.isEmpty()) {\n        CSSStyleSheet* styleSheet = styleSheetQueue.takeFirst();\n        for (unsigned i = 0; i < styleSheet->length(); ++i) {\n            StyleBase* styleBase = styleSheet->item(i);\n            if (!styleBase->isRule())\n                continue;\n            CSSRule* rule = static_cast<CSSRule*>(styleBase);\n            if (rule->isImportRule()) {\n                if (CSSStyleSheet* ruleStyleSheet = static_cast<CSSImportRule*>(rule)->styleSheet())\n                    styleSheetQueue.append(ruleStyleSheet);\n            }\n            rule->addSubresourceStyleURLs(urls);\n        }\n    }\n}", "target": 0}
{"code": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\treturn opt;\n}", "target": 1}
{"code": "void WebContentsImpl::SetIsCrashed(base::TerminationStatus status,\n                                   int error_code) {\n  if (status == crashed_status_)\n    return;\n  crashed_status_ = status;\n  crashed_error_code_ = error_code;\n  NotifyNavigationStateChanged(INVALIDATE_TYPE_TAB);\n}", "target": 0}
{"code": "static void __init acpi_request_region (struct acpi_generic_address *gas,\n\tunsigned int length, char *desc)\n{\n\tu64 addr;\n\tmemcpy(&addr, &gas->address, sizeof(addr));\n\tif (!addr || !length)\n\t\treturn;\n\tif (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO)\n\t\trequest_region(addr, length, desc);\n\telse if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\trequest_mem_region(addr, length, desc);\n}", "target": 0}
{"code": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\tINFO(\"Mounting container /dev\");\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn false;\n\t}\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) \n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}", "target": 1}
{"code": "static int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr)\n{\n\tvoid *ext_hdrs[SADB_EXT_MAX];\n\tint err;\n\tpfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,\n\t\t\tBROADCAST_PROMISC_ONLY, NULL, sock_net(sk));\n\tmemset(ext_hdrs, 0, sizeof(ext_hdrs));\n\terr = parse_exthdrs(skb, hdr, ext_hdrs);\n\tif (!err) {\n\t\terr = -EOPNOTSUPP;\n\t\tif (pfkey_funcs[hdr->sadb_msg_type])\n\t\t\terr = pfkey_funcs[hdr->sadb_msg_type](sk, skb, hdr, ext_hdrs);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "parse_emph1(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\t\tif (i >= size) return 0;\n\t\tif (data[i] == c && !_isspace(data[i - 1])) {\n\t\t\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n\t\t\t\tif (i + i < size && _isalnum(data[i + 1]))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tif (rndr->ext_flags & MKDEXT_UNDERLINE && c == '_')\n\t\t\t\tr = rndr->cb.underline(ob, work, rndr->opaque);\n\t\t\telse\n\t\t\t\tr = rndr->cb.emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 1 : 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void FoFiTrueType::cvtCharStrings(char **encoding,\n\t\t\t\t  int *codeToGID,\n\t\t\t\t  FoFiOutputFunc outputFunc,\n\t\t\t\t  void *outputStream) {\n  char *name;\n  GooString *buf;\n  char buf2[16];\n  int i, k;\n  (*outputFunc)(outputStream, \"/CharStrings 256 dict dup begin\\n\", 32);\n  (*outputFunc)(outputStream, \"/.notdef 0 def\\n\", 15);\n  if (nCmaps == 0) {\n    goto err;\n  }\n  k = 0; \n  for (i = 255; i >= 0; --i) {\n    if (encoding) {\n      name = encoding[i];\n    } else {\n      sprintf(buf2, \"c%02x\", i);\n      name = buf2;\n    }\n    if (name && strcmp(name, \".notdef\")) {\n      k = codeToGID[i];\n      if (k > 0 && k < nGlyphs) {\n\t(*outputFunc)(outputStream, \"/\", 1);\n\t(*outputFunc)(outputStream, name, strlen(name));\n\tbuf = GooString::format(\" {0:d} def\\n\", k);\n\t(*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n\tdelete buf;\n      }\n    }\n  }\n err:\n  (*outputFunc)(outputStream, \"end readonly def\\n\", 17);\n}", "target": 0}
{"code": "                uint64_t readData(int size) const\n                {\n                    const DataBuf data = Image::io().read(size);\n                    enforce(data.size_ != 0, kerCorruptedMetadata);\n                    uint64_t result = 0;\n                    if (data.size_ == 1)\n                        {}\n                    else if (data.size_ == 2)\n                        result = byteSwap2(data, 0, doSwap_);\n                    else if (data.size_ == 4)\n                        result = byteSwap4(data, 0, doSwap_);\n                    else if (data.size_ == 8)\n                        result = byteSwap8(data, 0, doSwap_);\n                    else\n                        throw Exiv2::Error(kerCorruptedMetadata);\n                    return result;\n                }", "target": 0}
{"code": "static void prefetch_enc(void)\n{\n  prefetch_table((const void *)encT, sizeof(encT));\n}", "target": 1}
{"code": "QPDF::QPDF() :\n    encrypted(false),\n    encryption_initialized(false),\n    ignore_xref_streams(false),\n    suppress_warnings(false),\n    out_stream(&std::cout),\n    err_stream(&std::cerr),\n    attempt_recovery(true),\n    encryption_V(0),\n    encryption_R(0),\n    encrypt_metadata(true),\n    cf_stream(e_none),\n    cf_string(e_none),\n    cf_file(e_none),\n    cached_key_objid(0),\n    cached_key_generation(0),\n    pushed_inherited_attributes_to_pages(false),\n    copied_stream_data_provider(0),\n    first_xref_item_offset(0),\n    uncompressed_after_compressed(false)\n{\n}", "target": 1}
{"code": "int send_sigqueue(struct sigqueue *q, struct task_struct *t, int group)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tunsigned long flags;\n\tint ret;\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\tret = -1;\n\tif (!likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\tret = 1; \n\tif (!prepare_signal(sig, t, 0))\n\t\tgoto out;\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\tsignalfd_notify(t, sig);\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\nout:\n\tunlock_task_sighand(t, &flags);\nret:\n\treturn ret;\n}", "target": 0}
{"code": "rrdp_process_deltas(struct update_notification *parent,\n    unsigned long cur_serial, struct visited_uris *visited_uris,\n    bool log_operation)\n{\n\tstruct proc_upd_args args;\n\targs.parent = parent;\n\targs.visited_uris = visited_uris;\n\targs.log_operation = log_operation;\n\treturn deltas_head_for_each(parent->deltas_list,\n\t    parent->global_data.serial, cur_serial, process_delta, &args);\n}", "target": 1}
{"code": "static void check_serverpath(request_rec *r)\n{\n    server_rec *s;\n    server_rec *last_s;\n    name_chain *src;\n    apr_port_t port;\n    port = r->connection->local_addr->port;\n    last_s = NULL;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        if (src->sar->host_port != 0 && port != src->sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s == last_s) {\n            continue;\n        }\n        last_s = s;\n        if (s->path && !strncmp(r->uri, s->path, s->pathlen) &&\n            (s->path[s->pathlen - 1] == '/' ||\n             r->uri[s->pathlen] == '/' ||\n             r->uri[s->pathlen] == '\\0')) {\n            r->server = s;\n            return;\n        }\n    }\n}", "target": 1}
{"code": "void __export pptp_get_stat(unsigned int **starting, unsigned int **active)\n{\n\t*starting = &stat_starting;\n\t*active = &stat_active;\n}", "target": 0}
{"code": "static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                return status;\n            }\n            else\n            {\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                return func(stream, iter->pos, pItem);\n            }\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}", "target": 1}
{"code": "__delta_head_destroy(struct delta_head **delta_head)\n{\n\tdelta_head_destroy(*delta_head);\n}", "target": 1}
{"code": "check_packet_auth(NTP_Packet *pkt, int length, int *has_auth, uint32_t *key_id)\n{\n  int i, remainder, ext_length;\n  unsigned char *data;\n  uint32_t id;\n  i = NTP_NORMAL_PACKET_LENGTH;\n  data = (void *)pkt;\n  while (1) {\n    remainder = length - i;\n    if (remainder >= NTP_MIN_MAC_LENGTH && remainder <= NTP_MAX_MAC_LENGTH) {\n      id = ntohl(*(uint32_t *)(data + i));\n      if (KEY_CheckAuth(id, (void *)pkt, i, (void *)(data + i + 4),\n                        remainder - 4)) {\n        if (key_id)\n          *key_id = id;\n        if (has_auth)\n          *has_auth = 1;\n        return 1;\n      }\n    }\n    if (remainder >= NTP_MIN_EXTENSION_LENGTH) {\n      ext_length = ntohs(*(uint16_t *)(data + i + 2));\n      if (ext_length >= NTP_MIN_EXTENSION_LENGTH &&\n          ext_length <= remainder && ext_length % 4 == 0) {\n        i += ext_length;\n        continue;\n      }\n    }\n    break;\n  }\n  if (has_auth)\n    *has_auth = remainder >= NTP_MIN_MAC_LENGTH;\n  return 0;\n}", "target": 0}
{"code": "void HeaderMapImpl::addReference(const LowerCaseString& key, absl::string_view value) {\n  HeaderString ref_key(key);\n  HeaderString ref_value(value);\n  insertByKey(std::move(ref_key), std::move(ref_value));\n}", "target": 0}
{"code": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), result);\n\t\t}", "target": 1}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == 0xF2) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xD3;\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xF3;\n      }\n    }\n    else if (code == 0xB5) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xCC;\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xEC;\n      }\n    }\n    else if (code == 0xC0 || code == 0xE0 || code == 0xB6)\n      ;\n    else if ((EncCP1253_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      code = ENC_CP1253_TO_LOWER_CASE(code);\n    }\n    else if ((EncCP1253_CtypeTable[code] & BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 0xDC)\n\tcode = 0xA2;\n      else if (code >= 0xDD && code <= 0xDF)\n\tcode -= 0x25;\n      else if (code == 0xFC)\n\tcode = 0xBC;\n      else if (code == 0xFD || code == 0xFE)\n\tcode -= 0x3F;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "void RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n}", "target": 1}
{"code": "static int mxf_uid_to_str(UID uid, char **str)\n{\n    int i;\n    char *p;\n    p = *str = av_mallocz(sizeof(UID) * 2 + 4 + 1);\n    if (!p)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < sizeof(UID); i++) {\n        snprintf(p, 2 + 1, \"%.2x\", uid[i]);\n        p += 2;\n        if (i == 3 || i == 5 || i == 7 || i == 9) {\n            snprintf(p, 1 + 1, \"-\");\n            p++;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static bool FNAME(prefetch_invalid_gpte)(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  u64 gpte)\n{\n\tif (!FNAME(is_present_gpte)(gpte))\n\t\tgoto no_present;\n\tif (PT_HAVE_ACCESSED_DIRTY(vcpu->arch.mmu) &&\n\t    !(gpte & PT_GUEST_ACCESSED_MASK))\n\t\tgoto no_present;\n\tif (FNAME(is_rsvd_bits_set)(vcpu->arch.mmu, gpte, PG_LEVEL_4K))\n\t\tgoto no_present;\n\treturn false;\nno_present:\n\tdrop_spte(vcpu->kvm, spte);\n\treturn true;\n}", "target": 0}
{"code": "vhost_user_set_features(struct virtio_net *dev, uint64_t features)\n{\n\tuint64_t vhost_features = 0;\n\trte_vhost_driver_get_features(dev->ifname, &vhost_features);\n\tif (features & ~vhost_features) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\"(%d) received invalid negotiated features.\\n\",\n\t\t\tdev->vid);\n\t\treturn -1;\n\t}\n\tif (dev->flags & VIRTIO_DEV_RUNNING) {\n\t\tif (dev->features == features)\n\t\t\treturn 0;\n\t\tif ((dev->features ^ features) & ~(1ULL << VHOST_F_LOG_ALL)) {\n\t\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\t\"(%d) features changed while device is running.\\n\",\n\t\t\t\tdev->vid);\n\t\t\treturn -1;\n\t\t}\n\t\tif (dev->notify_ops->features_changed)\n\t\t\tdev->notify_ops->features_changed(dev->vid, features);\n\t}\n\tdev->features = features;\n\tif (dev->features &\n\t\t((1 << VIRTIO_NET_F_MRG_RXBUF) | (1ULL << VIRTIO_F_VERSION_1))) {\n\t\tdev->vhost_hlen = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\t} else {\n\t\tdev->vhost_hlen = sizeof(struct virtio_net_hdr);\n\t}\n\tLOG_DEBUG(VHOST_CONFIG,\n\t\t\"(%d) mergeable RX buffers %s, virtio 1 %s\\n\",\n\t\tdev->vid,\n\t\t(dev->features & (1 << VIRTIO_NET_F_MRG_RXBUF)) ? \"on\" : \"off\",\n\t\t(dev->features & (1ULL << VIRTIO_F_VERSION_1)) ? \"on\" : \"off\");\n\tif ((dev->flags & VIRTIO_DEV_BUILTIN_VIRTIO_NET) &&\n\t    !(dev->features & (1ULL << VIRTIO_NET_F_MQ))) {\n\t\twhile (dev->nr_vring > 2) {\n\t\t\tstruct vhost_virtqueue *vq;\n\t\t\tvq = dev->virtqueue[--dev->nr_vring];\n\t\t\tif (!vq)\n\t\t\t\tcontinue;\n\t\t\tdev->virtqueue[dev->nr_vring] = NULL;\n\t\t\tcleanup_vq(vq, 1);\n\t\t\tfree_vq(vq);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void out_string(conn *c, const char *str) {\n    size_t len;\n    mc_resp *resp = c->resp;\n    assert(c != NULL);\n    resp_reset(resp);\n    if (c->noreply) {\n        resp->skip = true;\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n    len = strlen(str);\n    if ((len + 2) > WRITE_BUFFER_SIZE) {\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n    memcpy(resp->wbuf, str, len);\n    memcpy(resp->wbuf + len, \"\\r\\n\", 2);\n    resp_add_iov(resp, resp->wbuf, len + 2);\n    conn_set_state(c, conn_new_cmd);\n    return;\n}", "target": 1}
{"code": "int h1_parse_cont_len_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n;\n\tlong long cl;\n\tint not_first = !!(h1m->flags & H1_MF_CLEN);\n\tstruct ist word;\n\tword.ptr = value->ptr - 1; \n\te = value->ptr + value->len;\n\twhile (++word.ptr < e) {\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\tif (unlikely(n == word.ptr)) \n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl + c;\n\t\t}\n\t\tword.len = n - word.ptr;\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (h1m->flags & H1_MF_CLEN && cl != h1m->body_len)\n\t\t\tgoto fail;\n\t\th1m->flags |= H1_MF_CLEN;\n\t\th1m->curr_len = h1m->body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t}\n\treturn !not_first;\n fail:\n\treturn -1;\n}", "target": 1}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n  const int nfilled = table.size();\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}", "target": 1}
{"code": "void blk_mq_add_to_requeue_list(struct request *rq, bool at_head)\n{\n\tstruct request_queue *q = rq->q;\n\tunsigned long flags;\n\tBUG_ON(rq->cmd_flags & REQ_SOFTBARRIER);\n\tspin_lock_irqsave(&q->requeue_lock, flags);\n\tif (at_head) {\n\t\trq->cmd_flags |= REQ_SOFTBARRIER;\n\t\tlist_add(&rq->queuelist, &q->requeue_list);\n\t} else {\n\t\tlist_add_tail(&rq->queuelist, &q->requeue_list);\n\t}\n\tspin_unlock_irqrestore(&q->requeue_lock, flags);\n}", "target": 0}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void calc_load_migrate(struct rq *rq)\n{\n\tlong delta = calc_load_fold_active(rq);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n}", "target": 0}
{"code": "_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "static void nfs4_xdr_enc_destroy_session(struct rpc_rqst *req,\n\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t struct nfs4_session *session)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = session->clp->cl_mvops->minor_version,\n\t};\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_destroy_session(xdr, session, &hdr);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "decompileCALLFRAME(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"callFrame(\");\n\tdecompilePUSHPARAM(pop(),1);\n\tprintln(\");\");\n\treturn 0;\n}", "target": 0}
{"code": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "FunctionTemplateFactory V8ClassIndex::GetFactory(V8WrapperType type)\n{\n    switch (type) {\n#define MAKE_CASE(type, name)\\\n    case V8ClassIndex::type: return V8##name::GetTemplate;\n    WRAPPER_TYPES(MAKE_CASE)\n#undef MAKE_CASE\n    default: return NULL;\n    }\n}", "target": 0}
{"code": "static int vhost_vdpa_map(struct vhost_vdpa *v, u64 iova,\n\t\t\t  u64 size, u64 pa, u32 perm, void *opaque)\n{\n\tstruct vhost_dev *dev = &v->vdev;\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tconst struct vdpa_config_ops *ops = vdpa->config;\n\tint r = 0;\n\tr = vhost_iotlb_add_range_ctx(dev->iotlb, iova, iova + size - 1,\n\t\t\t\t      pa, perm, opaque);\n\tif (r)\n\t\treturn r;\n\tif (ops->dma_map) {\n\t\tr = ops->dma_map(vdpa, iova, size, pa, perm, opaque);\n\t} else if (ops->set_map) {\n\t\tif (!v->in_batch)\n\t\t\tr = ops->set_map(vdpa, dev->iotlb);\n\t} else {\n\t\tr = iommu_map(v->domain, iova, pa, size,\n\t\t\t      perm_to_iommu_flags(perm));\n\t}\n\tif (r) {\n\t\tvhost_iotlb_del_range(dev->iotlb, iova, iova + size - 1);\n\t\treturn r;\n\t}\n\tif (!vdpa->use_va)\n\t\tatomic64_add(PFN_DOWN(size), &dev->mm->pinned_vm);\n\treturn 0;\n}", "target": 0}
{"code": "OpTypeConstructor UnaryTensorContainer(FullTypeId t, FullTypeId dtype) {\n  return [t, dtype](OpDef* op_def) {\n    FullTypeDef* tdef =\n        op_def->mutable_output_arg(0)->mutable_experimental_full_type();\n    tdef->set_type_id(t);\n    FullTypeDef* arg = tdef->add_args();\n    arg->set_type_id(TFT_TENSOR);\n    FullTypeDef* targ = arg->add_args();\n    targ->set_type_id(dtype);\n    return Status::OK();\n  };\n}", "target": 0}
{"code": "static void DecodeFPDelta(unsigned char *input, unsigned char *output, int cols,\n                          int channels, int bytesPerSample)\n{\n  DecodeDeltaBytes(input, cols * bytesPerSample, channels);\n  int32_t rowIncrement = cols * channels;\n  if (bytesPerSample == 2)\n  {\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n#else\n    const unsigned char *input1 = input;\n    const unsigned char *input0 = input + rowIncrement;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output += 2;\n    }\n  }\n  else if (bytesPerSample == 3)\n  {\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output += 3;\n    }\n  }\n  else\n  {\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    const unsigned char *input3 = input + rowIncrement * 3;\n#else\n    const unsigned char *input3 = input;\n    const unsigned char *input2 = input + rowIncrement;\n    const unsigned char *input1 = input + rowIncrement * 2;\n    const unsigned char *input0 = input + rowIncrement * 3;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output[3] = input3[col];\n      output += 4;\n    }\n  }\n}", "target": 0}
{"code": "static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl,\n\t\t\t  u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t qdisc_root_sleeping_lock(q), &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n{\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 1}
{"code": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}", "target": 1}
{"code": "GF_Err proj_type_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->layout = gf_bs_read_u32(bs);\n\t\tptr->padding = gf_bs_read_u32(bs);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->bounds_top = gf_bs_read_u32(bs);\n\t\tptr->bounds_bottom = gf_bs_read_u32(bs);\n\t\tptr->bounds_left = gf_bs_read_u32(bs);\n\t\tptr->bounds_right = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->crc = gf_bs_read_u32(bs);\n\t\tptr->encoding_4cc = gf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "static int sanitize_err(struct bpf_verifier_env *env,\n\t\t\tconst struct bpf_insn *insn, int reason,\n\t\t\tconst struct bpf_reg_state *off_reg,\n\t\t\tconst struct bpf_reg_state *dst_reg)\n{\n\tstatic const char *err = \"pointer arithmetic with it prohibited for !root\";\n\tconst char *op = BPF_OP(insn->code) == BPF_ADD ? \"add\" : \"sub\";\n\tu32 dst = insn->dst_reg, src = insn->src_reg;\n\tswitch (reason) {\n\tcase REASON_BOUNDS:\n\t\tverbose(env, \"R%d has unknown scalar with mixed signed bounds, %s\\n\",\n\t\t\toff_reg == dst_reg ? dst : src, err);\n\t\tbreak;\n\tcase REASON_TYPE:\n\t\tverbose(env, \"R%d has pointer with unsupported alu operation, %s\\n\",\n\t\t\toff_reg == dst_reg ? src : dst, err);\n\t\tbreak;\n\tcase REASON_PATHS:\n\t\tverbose(env, \"R%d tried to %s from different maps, paths or scalars, %s\\n\",\n\t\t\tdst, op, err);\n\t\tbreak;\n\tcase REASON_LIMIT:\n\t\tverbose(env, \"R%d tried to %s beyond pointer bounds, %s\\n\",\n\t\t\tdst, op, err);\n\t\tbreak;\n\tcase REASON_STACK:\n\t\tverbose(env, \"R%d could not be pushed for speculative verification, %s\\n\",\n\t\t\tdst, err);\n\t\tbreak;\n\tdefault:\n\t\tverbose(env, \"verifier internal error: unknown reason (%d)\\n\",\n\t\t\treason);\n\t\tbreak;\n\t}\n\treturn -EACCES;\n}", "target": 0}
{"code": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}", "target": 1}
{"code": "onig_get_callout_data(regex_t* reg, OnigMatchParam* mp,\n                      int callout_num, int slot,\n                      OnigType* type, OnigValue* val)\n{\n  OnigType t;\n  CalloutData* d;\n  if (callout_num <= 0) return ONIGERR_INVALID_ARGUMENT;\n  d = CALLOUT_DATA_AT_NUM(mp, callout_num);\n  if (d->last_match_at_call_counter != mp->match_at_call_counter) {\n    xmemset(d, 0, sizeof(*d));\n    d->last_match_at_call_counter = mp->match_at_call_counter;\n  }\n  t = d->slot[slot].type;\n  if (IS_NOT_NULL(type)) *type = t;\n  if (IS_NOT_NULL(val))  *val  = d->slot[slot].val;\n  return (t == ONIG_TYPE_VOID ? 1 : ONIG_NORMAL);\n}", "target": 0}
{"code": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}", "target": 1}
{"code": "struct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}", "target": 1}
{"code": "void OverlayWindowViews::OnGestureEvent(ui::GestureEvent* event) {\n  if (event->type() != ui::ET_GESTURE_TAP)\n    return;\n  hide_controls_timer_.Reset();\n  if (!GetControlsScrimLayer()->visible()) {\n    UpdateControlsVisibility(true);\n    return;\n  }\n  if (GetCloseControlsBounds().Contains(event->location())) {\n    controller_->Close(true ,\n                       true );\n    event->SetHandled();\n  } else if (GetPlayPauseControlsBounds().Contains(event->location())) {\n     TogglePlayPause();\n     event->SetHandled();\n   }\n }", "target": 0}
{"code": "shell_gtk_embed_on_window_mapped (GtkWidget     *object,\n                                  ShellGtkEmbed *embed)\n{\n  ShellGtkEmbedPrivate *priv = shell_gtk_embed_get_instance_private (embed);\n  MetaDisplay *display = shell_global_get_display (shell_global_get ());\n  if (priv->window_created_handler == 0 && priv->window_actor == NULL)\n    priv->window_created_handler =\n      g_signal_connect (display,\n                        \"window-created\",\n                        G_CALLBACK (shell_gtk_embed_window_created_cb),\n                        embed);\n}", "target": 0}
{"code": "static int snd_timer_start1(struct snd_timer_instance *timeri,\n\t\t\t    bool start, unsigned long ticks)\n{\n\tstruct snd_timer *timer;\n\tint result;\n\tunsigned long flags;\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (timer->card && timer->card->shutdown) {\n\t\tresult = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t     SNDRV_TIMER_IFLG_START)) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tif (start)\n\t\ttimeri->ticks = timeri->cticks = ticks;\n\telse if (!timeri->cticks)\n\t\ttimeri->cticks = 1;\n\ttimeri->pticks = 0;\n\tlist_move_tail(&timeri->active_list, &timer->active_list_head);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tgoto __start_now;\n\t\ttimer->flags |= SNDRV_TIMER_FLG_RESCHED;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_START;\n\t\tresult = 1; \n\t} else {\n\t\tif (start)\n\t\t\ttimer->sticks = ticks;\n\t\ttimer->hw.start(timer);\n\t      __start_now:\n\t\ttimer->running++;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\tresult = 0;\n\t}\n\tsnd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}", "target": 0}
{"code": "gopher_request_parse(const HttpRequest * req, char *type_id, char *request)\n{\n    ::Parser::Tokenizer tok(req->url.path());\n    if (request)\n        *request = 0;\n    tok.skip('/'); \n    if (tok.atEnd()) {\n        *type_id = GOPHER_DIRECTORY;\n        return;\n    }\n    static const CharacterSet anyByte(\"UTF-8\",0x00, 0xFF);\n    SBuf typeId;\n    (void)tok.prefix(typeId, anyByte, 1); \n    *type_id = typeId[0];\n    if (request) {\n        SBufToCstring(request, tok.remaining().substr(0, MAX_URL-1));\n        rfc1738_unescape(request);\n    }\n}", "target": 1}
{"code": "ppp_mp_insert(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *p;\n\tstruct sk_buff_head *list = &ppp->mrq;\n\tu32 seq = skb->sequence;\n\tskb_queue_walk(list, p) {\n\t\tif (seq_before(seq, p->sequence))\n\t\t\tbreak;\n\t}\n\t__skb_queue_before(list, p, skb);\n}", "target": 0}
{"code": "void Http2Stream::SubmitRstStream(const uint32_t code) {\n  CHECK(!this->is_destroyed());\n  code_ = code;\n  if (session_->is_in_scope() &&\n      !is_writable() && is_reading()) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  if (session_->SendPendingData() != 0) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  FlushRstStream();\n}", "target": 1}
{"code": "    bool Converter::prepareIptcTarget(const char* to, bool force)\n    {\n        Exiv2::IptcData::iterator pos = iptcData_->findKey(IptcKey(to));\n        if (pos == iptcData_->end()) return true;\n        if (!overwrite_ && !force) return false;\n        while ((pos = iptcData_->findKey(IptcKey(to))) != iptcData_->end()) {\n            iptcData_->erase(pos);\n        }\n        return true;\n    }", "target": 0}
{"code": "read_response_line(smtp_inblock *inblock, uschar *buffer, int size, int timeout)\n{\nuschar *p = buffer;\nuschar *ptr = inblock->ptr;\nuschar *ptrend = inblock->ptrend;\nclient_conn_ctx * cctx = inblock->cctx;\nfor (;;)\n  {\n  int rc;\n  while (ptr < ptrend)\n    {\n    int c = *ptr++;\n    if (c == '\\n')\n      {\n      while (p > buffer && isspace(p[-1])) p--;\n      *p = 0;\n      inblock->ptr = ptr;\n      return p - buffer;\n      }\n    *p++ = c;\n    if (--size < 4)\n      {\n      *p = 0;                     \n      errno = ERRNO_SMTPFORMAT;\n      return -1;\n      }\n    }\n  if((rc = ip_recv(cctx, inblock->buffer, inblock->buffersize, timeout)) <= 0)\n    {\n    DEBUG(D_deliver|D_transport|D_acl)\n      debug_printf_indent(errno ? \"  SMTP(%s)<<\\n\" : \"  SMTP(closed)<<\\n\",\n\tstrerror(errno));\n    break;\n    }\n  ptrend = inblock->ptrend = inblock->buffer + rc;\n  ptr = inblock->buffer;\n  DEBUG(D_transport|D_acl) debug_printf_indent(\"read response data: size=%d\\n\", rc);\n  }\n*buffer = 0;\nreturn -1;\n}", "target": 0}
{"code": "TxnWrap::TxnWrap(MDB_env *env, MDB_txn *txn) {\n    this->env = env;\n    this->txn = txn;\n    this->flags = 0;\n}", "target": 0}
{"code": "PHP_FUNCTION(locale_parse)\n{\n    const char* loc_name        = NULL;\n    int         loc_name_len    = 0;\n    int         grOffset    \t= 0;\n    intl_error_reset( NULL TSRMLS_CC );\n    if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n        &loc_name, &loc_name_len ) == FAILURE)\n    {\n        intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n             \"locale_parse: unable to parse input params\", 0 TSRMLS_CC );\n        RETURN_FALSE;\n    }\n    if(loc_name_len == 0) {\n        loc_name = intl_locale_get_default(TSRMLS_C);\n    }\n\tarray_init( return_value );\n\tgrOffset =  findOffset( LOC_GRANDFATHERED , loc_name );\n\tif( grOffset >= 0 ){\n\t\tadd_assoc_string( return_value , LOC_GRANDFATHERED_LANG_TAG , estrdup(loc_name) ,FALSE );\n\t}\n\telse{\n\t\tadd_array_entry( loc_name , return_value , LOC_LANG_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_SCRIPT_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_REGION_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_VARIANT_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_PRIVATE_TAG TSRMLS_CC);\n\t}\n}", "target": 0}
{"code": "nfs_idmap_new(struct nfs_client *clp)\n{\n\tstruct idmap *idmap;\n\tstruct rpc_pipe *pipe;\n\tint error;\n\tidmap = kzalloc(sizeof(*idmap), GFP_KERNEL);\n\tif (idmap == NULL)\n\t\treturn -ENOMEM;\n\trpc_init_pipe_dir_object(&idmap->idmap_pdo,\n\t\t\t&nfs_idmap_pipe_dir_object_ops,\n\t\t\tidmap);\n\tpipe = rpc_mkpipe_data(&idmap_upcall_ops, 0);\n\tif (IS_ERR(pipe)) {\n\t\terror = PTR_ERR(pipe);\n\t\tgoto err;\n\t}\n\tidmap->idmap_pipe = pipe;\n\tmutex_init(&idmap->idmap_mutex);\n\terror = rpc_add_pipe_dir_object(clp->cl_net,\n\t\t\t&clp->cl_rpcclient->cl_pipedir_objects,\n\t\t\t&idmap->idmap_pdo);\n\tif (error)\n\t\tgoto err_destroy_pipe;\n\tclp->cl_idmap = idmap;\n\treturn 0;\nerr_destroy_pipe:\n\trpc_destroy_pipe_data(idmap->idmap_pipe);\nerr:\n\tkfree(idmap);\n\treturn error;\n}", "target": 0}
{"code": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}", "target": 1}
{"code": "DECLAREContigPutFunc(putRGBAAcontig8bittile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    while (h-- > 0) {\n\tUNROLL8(w, NOP,\n\t    *cp++ = PACK4(pp[0], pp[1], pp[2], pp[3]);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 0}
{"code": "void setup_work_tree(void)\n{\n\tconst char *work_tree, *git_dir;\n\tstatic int initialized = 0;\n\tif (initialized)\n\t\treturn;\n\twork_tree = get_git_work_tree();\n\tgit_dir = get_git_dir();\n\tif (!is_absolute_path(git_dir))\n\t\tset_git_dir(make_absolute_path(git_dir));\n\tif (!work_tree || chdir(work_tree))\n\t\tdie(\"This operation must be run in a work tree\");\n\tinitialized = 1;\n}", "target": 0}
{"code": "xmlValidGetElemDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t            xmlNodePtr elem, int *extsubset) {\n    xmlElementPtr elemDecl = NULL;\n    const xmlChar *prefix = NULL;\n    if ((ctxt == NULL) || (doc == NULL) ||\n        (elem == NULL) || (elem->name == NULL))\n        return(NULL);\n    if (extsubset != NULL)\n\t*extsubset = 0;\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL))\n\tprefix = elem->ns->prefix;\n    if (prefix != NULL) {\n\telemDecl = xmlGetDtdQElementDesc(doc->intSubset,\n\t\t                         elem->name, prefix);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdQElementDesc(doc->extSubset,\n\t\t                             elem->name, prefix);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\telemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\txmlErrValidNode(ctxt, elem,\n\t\t\tXML_DTD_UNKNOWN_ELEM,\n\t       \"No declaration for element %s\\n\",\n\t       elem->name, NULL, NULL);\n    }\n    return(elemDecl);\n}", "target": 0}
{"code": "void GLES2DecoderTestBase::DoCreateShader(\n    GLenum shader_type, GLuint client_id, GLuint service_id) {\n  EXPECT_CALL(*gl_, CreateShader(shader_type))\n      .Times(1)\n      .WillOnce(Return(service_id))\n      .RetiresOnSaturation();\n  CreateShader cmd;\n  cmd.Init(shader_type, client_id);\n  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));\n}", "target": 0}
{"code": "xbstream_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *mystat)\n{\n\tds_file_t\t\t*file;\n\tds_stream_file_t\t*stream_file;\n\tds_stream_ctxt_t\t*stream_ctxt;\n\tds_ctxt_t\t\t*dest_ctxt;\n\txb_wstream_t\t\t*xbstream;\n\txb_wstream_file_t\t*xbstream_file;\n\txb_ad(ctxt->pipe_ctxt != NULL);\n\tdest_ctxt = ctxt->pipe_ctxt;\n\tstream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;\n\tpthread_mutex_lock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\tstream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);\n\t\tif (stream_ctxt->dest_file == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&stream_ctxt->mutex);\n\tfile = (ds_file_t *) my_malloc(sizeof(ds_file_t) +\n\t\t\t\t       sizeof(ds_stream_file_t),\n\t\t\t\t       MYF(MY_FAE));\n\tstream_file = (ds_stream_file_t *) (file + 1);\n\txbstream = stream_ctxt->xbstream;\n\txbstream_file = xb_stream_write_open(xbstream, path, mystat,\n\t\t                             stream_ctxt,\n\t\t\t\t\t     my_xbstream_write_callback);\n\tif (xbstream_file == NULL) {\n\t\tmsg(\"xb_stream_write_open() failed.\");\n\t\tgoto err;\n\t}\n\tstream_file->xbstream_file = xbstream_file;\n\tstream_file->stream_ctxt = stream_ctxt;\n\tfile->ptr = stream_file;\n\tfile->path = stream_ctxt->dest_file->path;\n\treturn file;\nerr:\n\tif (stream_ctxt->dest_file) {\n\t\tds_close(stream_ctxt->dest_file);\n\t\tstream_ctxt->dest_file = NULL;\n\t}\n\tmy_free(file);\n\treturn NULL;\n}", "target": 1}
{"code": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "static void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint uninitialized_var(is_swbp);\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\tsend_sig(SIGTRAP, current, 0);\n\t\t} else {\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\tinstruction_pointer_set(regs, bp_vaddr);\n\tsmp_rmb(); \n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\tif (!get_utask())\n\t\tgoto out;\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\thandler_chain(uprobe, regs);\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\nout:\n\tput_uprobe(uprobe);\n}", "target": 0}
{"code": "int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d,\n                                 int n)\n{\n    int al = -1;\n    unsigned char *ptmp = *p;\n    if (ssl_scan_clienthello_tlsext(s, p, d, n, &al) <= 0) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        return 0;\n    }\n    if (ssl_check_clienthello_tlsext_early(s) <= 0) {\n        SSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT, SSL_R_CLIENTHELLO_TLSEXT);\n        return 0;\n    }\n    custom_ext_init(&s->cert->srv_ext);\n    if (ssl_scan_clienthello_custom_tlsext(s, ptmp, d + n, &al) <= 0) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "static int fsck_tag(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object *tagged = tag->tagged;\n\tif (!tagged)\n\t\treturn report(options, &tag->object, FSCK_MSG_BAD_TAG_OBJECT, \"could not load tagged object\");\n\treturn fsck_tag_buffer(tag, data, size, options);\n}", "target": 0}
{"code": "char * gf_get_default_cache_directory() {\n\tchar szPath[GF_MAX_PATH];\n\tchar* root_tmp;\n\tsize_t len;\n#ifdef _WIN32_WCE\n\tstrcpy(szPath, \"\\\\windows\\\\temp\" );\n#elif defined(WIN32)\n\tGetTempPath(GF_MAX_PATH, szPath);\n#else\n\tstrcpy(szPath, \"/tmp\");\n#endif\n\troot_tmp = gf_strdup(szPath);\n\tlen = strlen(szPath);\n\tif (szPath[len-1] != GF_PATH_SEPARATOR) {\n\t\tszPath[len] = GF_PATH_SEPARATOR;\n\t\tszPath[len+1] = 0;\n\t}\n\tstrcat(szPath, \"gpac_cache\");\n\tif ( !gf_dir_exists(szPath) && gf_mkdir(szPath)!=GF_OK ) {\n\t\treturn root_tmp;\n\t}\n\tgf_free(root_tmp);\n\treturn gf_strdup(szPath);\n}", "target": 0}
{"code": "static int snd_ctl_dev_free(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_kcontrol *control;\n\tdown_write(&card->controls_rwsem);\n\twhile (!list_empty(&card->controls)) {\n\t\tcontrol = snd_kcontrol(card->controls.next);\n\t\tsnd_ctl_remove(card, control);\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::ImeConfirmComposition(\n    const base::string16& text,\n    const gfx::Range& replacement_range,\n    bool keep_selection) {\n  Send(new InputMsg_ImeConfirmComposition(\n        GetRoutingID(), text, replacement_range, keep_selection));\n}", "target": 0}
{"code": "static void ashtech_event_hook(struct gps_device_t *session, event_t event)\n{\n    if (session->context->readonly)\n\treturn;\n    if (event == event_wakeup)\n\t(void)nmea_send(session, \"$PASHQ,RID\");\n    if (event == event_identified) {\n\t(void)nmea_send(session, \"$PASHS,WAS,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,ALL,A,OFF\");\n#ifdef __future__\n\t(void)nmea_send(session, \"$PASHS,NME,POS,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,SAT,A,ON\");\n#else\n\t(void)nmea_send(session, \"$PASHS,NME,GGA,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,GSA,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,GSV,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,RMC,A,ON\");\n#endif\n\t(void)nmea_send(session, \"$PASHS,NME,ZDA,A,ON\");\n    }\n}", "target": 0}
{"code": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}", "target": 1}
{"code": "sread(int fd, void *buf, size_t n, int canbepipe)\n{\n\tssize_t rv;\n#ifdef FIONREAD\n\tint t = 0;\n#endif\n\tsize_t rn = n;\n\tif (fd == STDIN_FILENO)\n\t\tgoto nocheck;\n#ifdef FIONREAD\n\tif (canbepipe && (ioctl(fd, FIONREAD, &t) == -1 || t == 0)) {\n#ifdef FD_ZERO\n\t\tssize_t cnt;\n\t\tfor (cnt = 0;; cnt++) {\n\t\t\tfd_set check;\n\t\t\tstruct timeval tout = {0, 100 * 1000};\n\t\t\tint selrv;\n\t\t\tFD_ZERO(&check);\n\t\t\tFD_SET(fd, &check);\n\t\t\tselrv = select(fd + 1, &check, NULL, NULL, &tout);\n\t\t\tif (selrv == -1) {\n\t\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (selrv == 0 && cnt >= 5) {\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n#endif\n\t\t(void)ioctl(fd, FIONREAD, &t);\n\t}\n\tif (t > 0 && (size_t)t < n) {\n\t\tn = t;\n\t\trn = n;\n\t}\n#endif\nnocheck:\n\tdo\n\t\tswitch ((rv = FINFO_READ_FUNC(fd, buf, n))) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\treturn rn - n;\n\t\tdefault:\n\t\t\tn -= rv;\n\t\t\tbuf = ((char *)buf) + rv;\n\t\t\tbreak;\n\t\t}\n\twhile (n > 0);\n\treturn rn;\n}", "target": 0}
{"code": "static ssize_t stream_ssl_write_cb(RedStream *s, const void *buf, size_t size)\n{\n    int return_code;\n    return_code = SSL_write(s->priv->ssl, buf, size);\n    if (return_code < 0) {\n        return stream_ssl_error(s, return_code);\n    }\n    return return_code;\n}", "target": 0}
{"code": "bool Item::cleanup_processor(uchar *arg)\n{\n  if (fixed)\n    cleanup();\n  return FALSE;\n}", "target": 0}
{"code": "ppm_load_read_header(FILE       *fp,\n                     pnm_struct *img)\n{\n    gchar *ptr;\n    gchar  header[MAX_CHARS_IN_ROW];\n    gint   maxval;\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    if (header[0] != ASCII_P ||\n        (header[1] != PIXMAP_ASCII &&\n         header[1] != PIXMAP_RAW))\n      {\n        g_warning (\"Image is not a portable pixmap\");\n        return FALSE;\n      }\n    img->type = header[1];\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    while(header[0] == '#')\n      {\n        fgets (header,MAX_CHARS_IN_ROW,fp);\n      }\n    img->width  = strtol (header,&ptr,0);\n    img->height = atoi (ptr);\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    maxval = strtol (header,&ptr,0);\n    if ((maxval != 255) && (maxval != 65535))\n      {\n        g_warning (\"Image is not an 8-bit or 16-bit portable pixmap\");\n        return FALSE;\n      }\n  switch (maxval)\n    {\n    case 255:\n      img->bpc = sizeof (guchar);\n      break;\n    case 65535:\n      img->bpc = sizeof (gushort);\n      break;\n    default:\n      g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n    }\n    if (!img->width || !img->height ||\n        G_MAXSIZE / img->width / img->height / CHANNEL_COUNT < img->bpc)\n      {\n        g_warning (\"Illegal width/height: %ld/%ld\", img->width, img->height);\n        return FALSE;\n      }\n    img->numsamples = img->width * img->height * CHANNEL_COUNT;\n    return TRUE;\n}", "target": 1}
{"code": "static void __rfcomm_sock_close(struct sock *sk)\n{\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\trfcomm_sock_cleanup_listen(sk);\n\t\tbreak;\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\tcase BT_CONNECTED:\n\t\trfcomm_dlc_close(d, 0);\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, GteWithLHSFieldPathMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: {$gte: ['$x', 3]}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 3)));\n    ASSERT_TRUE(matches(BSON(\"x\" << 10)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 1)));\n}", "target": 0}
{"code": "rsa_compute_root_tr(const struct rsa_public_key *pub,\n\t\t    const struct rsa_private_key *key,\n\t\t    void *random_ctx, nettle_random_func *random,\n\t\t    mpz_t x, const mpz_t m)\n{\n  int res;\n  mpz_t t, mb, xb, ri;\n  mpz_init (mb);\n  mpz_init (xb);\n  mpz_init (ri);\n  mpz_init (t);\n  rsa_blind (pub, random_ctx, random, mb, ri, m);\n  rsa_compute_root (key, xb, mb);\n  mpz_powm_sec(t, xb, pub->e, pub->n);\n  res = (mpz_cmp(mb, t) == 0);\n  if (res)\n    rsa_unblind (pub, x, ri, xb);\n  mpz_clear (mb);\n  mpz_clear (xb);\n  mpz_clear (ri);\n  mpz_clear (t);\n  return res;\n}", "target": 1}
{"code": "\tEventReturn OnPreCommand(CommandSource &source, Command *command, std::vector<Anope::string> &params) anope_override\n\t{\n\t\tif (command->name == \"nickserv/confirm\" && params.size() > 1)\n\t\t{\n\t\t\tif (Anope::ReadOnly)\n\t\t\t{\n\t\t\t\tsource.Reply(READ_ONLY_MODE);\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t\tNickAlias *na = NickAlias::Find(params[0]);\n\t\t\tResetInfo *ri = na ? reset.Get(na->nc) : NULL;\n\t\t\tif (na && ri)\n\t\t\t{\n\t\t\t\tNickCore *nc = na->nc;\n\t\t\t\tif (nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\t\t{\n\t\t\t\t\tsource.Reply(NICK_X_SUSPENDED, nc->display.c_str());\n\t\t\t\t\treturn EVENT_STOP;\n\t\t\t\t}\n\t\t\t\tconst Anope::string &passcode = params[1];\n\t\t\t\tif (ri->time < Anope::CurTime - 3600)\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tsource.Reply(_(\"Your password reset request has expired.\"));\n\t\t\t\t}\n\t\t\t\telse if (passcode.equals_cs(ri->code))\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tnc->Shrink<bool>(\"UNCONFIRMED\");\n\t\t\t\t\tLog(LOG_COMMAND, source, &commandnsresetpass) << \"to confirm RESETPASS and forcefully identify as \" << na->nick;\n\t\t\t\t\tif (source.GetUser())\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.GetUser()->Identify(na);\n\t\t\t\t\t}\n\t\t\t\t\tsource.Reply(_(\"You are now identified for your nick. Change your password now.\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn EVENT_CONTINUE;\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t}\n\t\treturn EVENT_CONTINUE;\n\t}", "target": 0}
{"code": "static void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,\n\t\t\t\t\t  u32 gsi)\n{\n\tint ioapic;\n\tint pin;\n\tstruct mpc_intsrc mp_irq;\n\tioapic = mp_find_ioapic(gsi);\n\tif (ioapic < 0)\n\t\treturn;\n\tpin = mp_find_ioapic_pin(ioapic, gsi);\n\tif ((bus_irq == 0) && (trigger == 3))\n\t\ttrigger = 1;\n\tmp_irq.type = MP_INTSRC;\n\tmp_irq.irqtype = mp_INT;\n\tmp_irq.irqflag = (trigger << 2) | polarity;\n\tmp_irq.srcbus = MP_ISA_BUS;\n\tmp_irq.srcbusirq = bus_irq;\t\n\tmp_irq.dstapic = mpc_ioapic_id(ioapic); \n\tmp_irq.dstirq = pin;\t\n\tmp_save_irq(&mp_irq);\n\tif (gsi < nr_legacy_irqs() && isa_irq_to_gsi[gsi] == gsi)\n\t\tisa_irq_to_gsi[gsi] = ACPI_INVALID_GSI;\n\tisa_irq_to_gsi[bus_irq] = gsi;\n}", "target": 1}
{"code": "static int cma_netdev_change(struct net_device *ndev, struct rdma_id_private *id_priv)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\tstruct cma_work *work;\n\tdev_addr = &id_priv->id.route.addr.dev_addr;\n\tif ((dev_addr->bound_dev_if == ndev->ifindex) &&\n\t    (net_eq(dev_net(ndev), dev_addr->net)) &&\n\t    memcmp(dev_addr->src_dev_addr, ndev->dev_addr, ndev->addr_len)) {\n\t\tpr_info(\"RDMA CM addr change for ndev %s used by id %p\\n\",\n\t\t\tndev->name, &id_priv->id);\n\t\twork = kzalloc(sizeof *work, GFP_KERNEL);\n\t\tif (!work)\n\t\t\treturn -ENOMEM;\n\t\tINIT_WORK(&work->work, cma_work_handler);\n\t\twork->id = id_priv;\n\t\twork->event.event = RDMA_CM_EVENT_ADDR_CHANGE;\n\t\tcma_id_get(id_priv);\n\t\tqueue_work(cma_wq, &work->work);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void ttm_unmap_and_unpopulate_pages(struct device *dev, struct ttm_dma_tt *tt)\n{\n\tunsigned i, j;\n\tfor (i = 0; i < tt->ttm.num_pages;) {\n\t\tstruct page *p = tt->ttm.pages[i];\n\t\tsize_t num_pages = 1;\n\t\tif (!tt->dma_address[i] || !tt->ttm.pages[i]) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = i + 1; j < tt->ttm.num_pages; ++j) {\n\t\t\tif (++p != tt->ttm.pages[j])\n\t\t\t\tbreak;\n\t\t\t++num_pages;\n\t\t}\n\t\tdma_unmap_page(dev, tt->dma_address[i], num_pages * PAGE_SIZE,\n\t\t\t       DMA_BIDIRECTIONAL);\n\t\ti += num_pages;\n\t}\n\tttm_pool_unpopulate(&tt->ttm);\n}", "target": 0}
{"code": "ppp_create_interface(struct net *net, int unit, int *retp)\n{\n\tstruct ppp *ppp;\n\tstruct ppp_net *pn;\n\tstruct net_device *dev = NULL;\n\tint ret = -ENOMEM;\n\tint i;\n\tdev = alloc_netdev(sizeof(struct ppp), \"\", ppp_setup);\n\tif (!dev)\n\t\tgoto out1;\n\tpn = ppp_pernet(net);\n\tppp = netdev_priv(dev);\n\tppp->dev = dev;\n\tppp->mru = PPP_MRU;\n\tinit_ppp_file(&ppp->file, INTERFACE);\n\tppp->file.hdrlen = PPP_HDRLEN - 2;\t\n\tfor (i = 0; i < NUM_NP; ++i)\n\t\tppp->npmode[i] = NPMODE_PASS;\n\tINIT_LIST_HEAD(&ppp->channels);\n\tspin_lock_init(&ppp->rlock);\n\tspin_lock_init(&ppp->wlock);\n#ifdef CONFIG_PPP_MULTILINK\n\tppp->minseq = -1;\n\tskb_queue_head_init(&ppp->mrq);\n#endif \n\tdev_net_set(dev, net);\n\tret = -EEXIST;\n\tmutex_lock(&pn->all_ppp_mutex);\n\tif (unit < 0) {\n\t\tunit = unit_get(&pn->units_idr, ppp);\n\t\tif (unit < 0) {\n\t\t\t*retp = unit;\n\t\t\tgoto out2;\n\t\t}\n\t} else {\n\t\tif (unit_find(&pn->units_idr, unit))\n\t\t\tgoto out2; \n\t\tunit = unit_set(&pn->units_idr, ppp, unit);\n\t\tif (unit < 0)\n\t\t\tgoto out2;\n\t}\n\tppp->file.index = unit;\n\tsprintf(dev->name, \"ppp%d\", unit);\n\tret = register_netdev(dev);\n\tif (ret != 0) {\n\t\tunit_put(&pn->units_idr, unit);\n\t\tprintk(KERN_ERR \"PPP: couldn't register device %s (%d)\\n\",\n\t\t       dev->name, ret);\n\t\tgoto out2;\n\t}\n\tppp->ppp_net = net;\n\tatomic_inc(&ppp_unit_count);\n\tmutex_unlock(&pn->all_ppp_mutex);\n\t*retp = 0;\n\treturn ppp;\nout2:\n\tmutex_unlock(&pn->all_ppp_mutex);\n\tfree_netdev(dev);\nout1:\n\t*retp = ret;\n\treturn NULL;\n}", "target": 0}
{"code": "get_auth_param(struct auth_param *auth, char *name)\n{\n    struct auth_param *ap;\n    for (ap = auth; ap->name != NULL; ap++) {\n\tif (strcasecmp(name, ap->name) == 0)\n\t    return ap->val;\n    }\n    return NULL;\n}", "target": 0}
{"code": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}", "target": 1}
{"code": "WebContentsImpl* WebContentsImpl::CreateWithOpener(\n    const WebContents::CreateParams& params,\n    WebContentsImpl* opener) {\n  TRACE_EVENT0(\"browser\", \"WebContentsImpl::CreateWithOpener\");\n  WebContentsImpl* new_contents = new WebContentsImpl(\n      params.browser_context, opener);\n  new_contents->Init(params);\n  return new_contents;\n}", "target": 0}
{"code": "PS_SERIALIZER_DECODE_FUNC(php_binary) \n{\n\tconst char *p;\n\tchar *name;\n\tconst char *endptr = val + vallen;\n\tzval *current;\n\tint namelen;\n\tint has_value;\n\tphp_unserialize_data_t var_hash;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tfor (p = val; p < endptr; ) {\n\t\tzval **tmp;\n                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);\n                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {\n                        return FAILURE;\n                }\n\t\tname = estrndup(p + 1, namelen);\n\t\tp += namelen + 1;\n\t\tif (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {\n\t\t\tif ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {\n\t\t\t\tefree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (has_value) {\n\t\t\tALLOC_INIT_ZVAL(current);\n\t\t\tif (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {\n\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n\t\t}\n\t\tPS_ADD_VARL(name, namelen);\n\t\tefree(name);\n\t}\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn SUCCESS;\n}", "target": 1}
{"code": "static int intel_iommu_add_device(struct device *dev)\n{\n\tstruct intel_iommu *iommu;\n\tstruct iommu_group *group;\n\tu8 bus, devfn;\n\tiommu = device_to_iommu(dev, &bus, &devfn);\n\tif (!iommu)\n\t\treturn -ENODEV;\n\tiommu_device_link(&iommu->iommu, dev);\n\tgroup = iommu_group_get_for_dev(dev);\n\tif (IS_ERR(group))\n\t\treturn PTR_ERR(group);\n\tiommu_group_put(group);\n\treturn 0;\n}", "target": 0}
{"code": "pa2ycbcr(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    pa2rgb(out, in, xsize, palette);\n    ImagingConvertRGB2YCbCr(out, out, xsize);\n}", "target": 0}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}", "target": 1}
{"code": "xfs_iunlink_remove(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_buf\t\t*agibp;\n\tstruct xfs_buf\t\t*last_ibp;\n\tstruct xfs_dinode\t*last_dip = NULL;\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\txfs_agino_t\t\tnext_agino;\n\txfs_agino_t\t\thead_agino;\n\tshort\t\t\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tint\t\t\terror;\n\ttrace_xfs_iunlink_remove(ip);\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\tagi = agibp->b_addr;\n\thead_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\tif (!xfs_verify_agino(mp, agno, head_agino)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\tagi, sizeof(*agi));\n\t\treturn -EFSCORRUPTED;\n\t}\n\terror = xfs_iunlink_update_inode(tp, ip, agno, NULLAGINO, &next_agino);\n\tif (error)\n\t\treturn error;\n\tif (next_agino != NULLAGINO) {\n\t\terror = xfs_iunlink_change_backref(agibp->b_pag, next_agino,\n\t\t\t\tNULLAGINO);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (head_agino != agino) {\n\t\tstruct xfs_imap\timap;\n\t\txfs_agino_t\tprev_agino;\n\t\terror = xfs_iunlink_map_prev(tp, agno, head_agino, agino,\n\t\t\t\t&prev_agino, &imap, &last_dip, &last_ibp,\n\t\t\t\tagibp->b_pag);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_iunlink_update_dinode(tp, agno, prev_agino, last_ibp,\n\t\t\t\tlast_dip, &imap, next_agino);\n\t\treturn xfs_iunlink_change_backref(agibp->b_pag, agino,\n\t\t\t\tnext_agino);\n\t}\n\treturn xfs_iunlink_update_bucket(tp, agno, agibp, bucket_index,\n\t\t\tnext_agino);\n}", "target": 0}
{"code": "int linenoiseHistorySave(const char* filename) {\n    FILE* fp = fopen(filename, \"wt\");\n    if (fp == NULL) {\n        return -1;\n    }\n    for (int j = 0; j < historyLen; ++j) {\n        if (history[j][0] != '\\0') {\n            fprintf(fp, \"%s\\n\", history[j]);\n        }\n    }\n    fclose(fp);\n    return 0;\n}", "target": 1}
{"code": "mm_answer_sign(int socket, Buffer *m)\n{\n\tKey *key;\n\tu_char *p;\n\tu_char *signature;\n\tu_int siglen, datlen;\n\tint keyid;\n\tdebug3(\"%s\", __func__);\n\tkeyid = buffer_get_int(m);\n\tp = buffer_get_string(m, &datlen);\n\tif (datlen != 20)\n\t\tfatal(\"%s: data length incorrect: %u\", __func__, datlen);\n\tif (session_id2_len == 0) {\n\t\tsession_id2_len = datlen;\n\t\tsession_id2 = xmalloc(session_id2_len);\n\t\tmemcpy(session_id2, p, session_id2_len);\n\t}\n\tif ((key = get_hostkey_by_index(keyid)) == NULL)\n\t\tfatal(\"%s: no hostkey from index %d\", __func__, keyid);\n\tif (key_sign(key, &signature, &siglen, p, datlen) < 0)\n\t\tfatal(\"%s: key_sign failed\", __func__);\n\tdebug3(\"%s: signature %p(%u)\", __func__, signature, siglen);\n\tbuffer_clear(m);\n\tbuffer_put_string(m, signature, siglen);\n\txfree(p);\n\txfree(signature);\n\tmm_request_send(socket, MONITOR_ANS_SIGN, m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);\n\treturn (0);\n}", "target": 0}
{"code": "static ssize_t stream_writev_cb(RedStream *s, const struct iovec *iov, int iovcnt)\n{\n    ssize_t ret = 0;\n    do {\n        int tosend;\n        ssize_t n, expected = 0;\n        int i;\n#ifdef IOV_MAX\n        tosend = MIN(iovcnt, IOV_MAX);\n#else\n        tosend = iovcnt;\n#endif\n        for (i = 0; i < tosend; i++) {\n            expected += iov[i].iov_len;\n        }\n        n = socket_writev(s->socket, iov, tosend);\n        if (n <= expected) {\n            if (n > 0)\n                ret += n;\n            return ret == 0 ? n : ret;\n        }\n        ret += n;\n        iov += tosend;\n        iovcnt -= tosend;\n    } while(iovcnt > 0);\n    return ret;\n}", "target": 0}
{"code": "static void OneLineTransp(struct ico_progressive_state *context)\n{\n\tgint X;\n\tguchar *Pixels;\n\tif (context->Header.depth == 32)\n\t\treturn;\n\tX = 0;\n\tif (context->Header.Negative == 0)\n\t\tPixels = (context->pixbuf->pixels +\n\t\t\t  (gsize) context->pixbuf->rowstride *\n\t\t\t  (2*context->Header.height - context->Lines - 1));\n\telse\n\t\tPixels = (context->pixbuf->pixels +\n\t\t\t  (gsize) context->pixbuf->rowstride *\n\t\t\t  (context->Lines-context->Header.height));\n\twhile (X < context->Header.width) {\n\t\tint Bit;\n\t\tBit = (context->LineBuf[X / 8]) >> (7 - (X & 7));\n\t\tBit = Bit & 1;\n\t\tPixels[X * 4 + 3] = 255-Bit*255;\n#if 0\n\t\tif (Bit){\n\t\t  Pixels[X*4+0] = 255;\n\t\t  Pixels[X*4+1] = 255;\n\t\t} else {\n\t\t  Pixels[X*4+0] = 0;\n\t\t  Pixels[X*4+1] = 0;\n\t\t}\n#endif\t\t\n\t\tX++;\n\t}\n}", "target": 0}
{"code": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n\tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n\tdm_get(md);\n\treturn md;\n}", "target": 1}
{"code": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}", "target": 1}
{"code": "static struct sk_buff *noop_dequeue(struct Qdisc * qdisc)\n{\n\treturn NULL;\n}", "target": 0}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 1}
{"code": "int recursive_destroy(char *dirname)\n{\n\tint ret;\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\twhile ((direntp = readdir(dir))) {\n\t\tchar *pathname;\n\t\tstruct stat mystat;\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret < 0) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"Failed to stat \\\"%s\\\"\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tret = recursive_destroy(pathname);\n\t\tif (ret < 0)\n\t\t\tr = -1;\n\tnext:\n\t\tfree(pathname);\n\t}\n\tret = rmdir(dirname);\n\tif (ret < 0) {\n\t\tif (!r)\n\t\t\tSYSWARN(\"Failed to delete \\\"%s\\\"\", dirname);\n\t\tr = -1;\n\t}\n\tret = closedir(dir);\n\tif (ret < 0) {\n\t\tif (!r)\n\t\t\tSYSWARN(\"Failed to delete \\\"%s\\\"\", dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "static void r_coresym_cache_element_line_info_fini(RCoreSymCacheElementLineInfo *line) {\n\tif (line) {\n\t\tr_coresym_cache_element_flc_fini (&line->flc);\n\t}\n}", "target": 0}
{"code": "QMimeData *ServerItem::toMimeData() const {\n\tQMimeData *mime = ServerItem::toMimeData(qsName, qsHostname, usPort);\n\tif (itType == FavoriteType)\n\t\tmime->setData(QLatin1String(\"OriginatedInMumble\"), QByteArray());\n\treturn mime;\n}", "target": 0}
{"code": "GF_Err gf_isom_get_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char **outName)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !outName) return GF_BAD_PARAM;\n\t*outName = trak->Media->handler->nameUTF8;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n{\n\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n}", "target": 1}
{"code": "bool Matrix::invertTo(Matrix *other) const\n{\n    const double det_denominator = determinant();\n    if (unlikely(det_denominator == 0)) {\n        *other = { 1, 0, 0, 1, 0, 0 };\n        return false;\n    }\n    const double det = 1 / det_denominator;\n    other->m[0] = m[3] * det;\n    other->m[1] = -m[1] * det;\n    other->m[2] = -m[2] * det;\n    other->m[3] = m[0] * det;\n    other->m[4] = (m[2] * m[5] - m[3] * m[4]) * det;\n    other->m[5] = (m[1] * m[4] - m[0] * m[5]) * det;\n    return true;\n}", "target": 0}
{"code": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}", "target": 1}
{"code": "fmtfloat(double value, char type, int forcesign, int leftjust,\n\t\t int minlen, int zpad, int precision, int pointflag,\n\t\t PrintfTarget *target)\n{\n\tint\t\t\tsignvalue = 0;\n\tint\t\t\tvallen;\n\tchar\t\tfmt[32];\n\tchar\t\tconvert[512];\n\tint\t\t\tpadlen = 0;\t\t\n\tif (pointflag)\n\t\tsprintf(fmt, \"%%.%d%c\", precision, type);\n\telse\n\t\tsprintf(fmt, \"%%%c\", type);\n\tif (adjust_sign((value < 0), forcesign, &signvalue))\n\t\tvalue = -value;\n\tvallen = sprintf(convert, fmt, value);\n\tadjust_padlen(minlen, vallen, leftjust, &padlen);\n\tleading_pad(zpad, &signvalue, &padlen, target);\n\tdostr(convert, vallen, target);\n\ttrailing_pad(&padlen, target);\n}", "target": 1}
{"code": "void html_link_open(const char *url, const char *title, const char *class)\n{\n\thtml(\"<a href='\");\n\thtml_attr(url);\n\tif (title) {\n\t\thtml(\"' title='\");\n\t\thtml_attr(title);\n\t}\n\tif (class) {\n\t\thtml(\"' class='\");\n\t\thtml_attr(class);\n\t}\n\thtml(\"'>\");\n}", "target": 0}
{"code": "PHPAPI int php_execute_simple_script(zend_file_handle *primary_file, zval *ret)\n{\n\tchar *old_cwd;\n\tALLOCA_FLAG(use_heap)\n\tEG(exit_status) = 0;\n#define OLD_CWD_SIZE 4096\n\told_cwd = do_alloca(OLD_CWD_SIZE, use_heap);\n\told_cwd[0] = '\\0';\n\tzend_try {\n#ifdef PHP_WIN32\n\t\tif(primary_file->filename) {\n\t\t\tUpdateIniFromRegistry((char*)primary_file->filename);\n\t\t}\n#endif\n\t\tPG(during_request_startup) = 0;\n\t\tif (primary_file->filename && !(SG(options) & SAPI_OPTION_NO_CHDIR)) {\n\t\t\tphp_ignore_value(VCWD_GETCWD(old_cwd, OLD_CWD_SIZE-1));\n\t\t\tVCWD_CHDIR_FILE(primary_file->filename);\n\t\t}\n\t\tzend_execute_scripts(ZEND_REQUIRE, ret, 1, primary_file);\n\t} zend_end_try();\n\tif (old_cwd[0] != '\\0') {\n\t\tphp_ignore_value(VCWD_CHDIR(old_cwd));\n\t}\n\tfree_alloca(old_cwd, use_heap);\n\treturn EG(exit_status);\n}", "target": 0}
{"code": "int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_list)\n{\n    int result;\n    if ((message == NULL) ||\n        (sequence_list == NULL))\n    {\n        LogError(\"Bad arguments: message = %p, sequence_list = %p\",\n            message, sequence_list);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);\n        if ((body_type == MESSAGE_BODY_TYPE_DATA) ||\n            (body_type == MESSAGE_BODY_TYPE_VALUE))\n        {\n            LogError(\"Body is already set to another body type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, sizeof(AMQP_VALUE) * (message->body_amqp_sequence_count + 1));\n            if (new_body_amqp_sequence_items == NULL)\n            {\n                LogError(\"Cannot allocate enough memory for sequence items\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n                message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n                if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n                {\n                    LogError(\"Cloning sequence failed\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    message->body_amqp_sequence_count++;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "GF_Err jp2h_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}", "target": 0}
{"code": "defbackend_bind( Slapi_PBlock *pb )\n{\n    int\t\t\trc;\n    ber_tag_t\t\tmethod;\n    struct berval\t*cred;\n    LDAPDebug( LDAP_DEBUG_TRACE, \"defbackend_bind\\n\", 0, 0, 0 );\n    slapi_pblock_get( pb, SLAPI_BIND_METHOD, &method );\n    slapi_pblock_get( pb, SLAPI_BIND_CREDENTIALS, &cred );\n    if ( method == LDAP_AUTH_SIMPLE && cred->bv_len == 0 ) {\n\tslapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsAnonymousBinds);\n\trc = SLAPI_BIND_ANONYMOUS;\n    } else {\n\tsend_nobackend_ldap_result( pb );\n\trc = SLAPI_BIND_FAIL;\n    }\n    return( rc );\n}", "target": 1}
{"code": "        bool operator()(const Exiv2::Xmpdatum& xmpdatum) const\n            { return key_ == xmpdatum.key(); }", "target": 0}
{"code": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}", "target": 1}
{"code": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}", "target": 1}
{"code": "void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}", "target": 1}
{"code": "void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}", "target": 1}
{"code": "bool Item_param::set_from_user_var(THD *thd, const user_var_entry *entry)\n{\n  DBUG_ENTER(\"Item_param::set_from_user_var\");\n  if (entry && entry->value)\n  {\n    item_result_type= entry->type;\n    unsigned_flag= entry->unsigned_flag;\n    if (limit_clause_param)\n    {\n      bool unused;\n      set_int(entry->val_int(&unused), MY_INT64_NUM_DECIMAL_DIGITS);\n      item_type= Item::INT_ITEM;\n      DBUG_RETURN(!unsigned_flag && value.integer < 0 ? 1 : 0);\n    }\n    switch (item_result_type) {\n    case REAL_RESULT:\n      set_double(*(double*)entry->value);\n      item_type= Item::REAL_ITEM;\n      param_type= MYSQL_TYPE_DOUBLE;\n      break;\n    case INT_RESULT:\n      set_int(*(longlong*)entry->value, MY_INT64_NUM_DECIMAL_DIGITS);\n      item_type= Item::INT_ITEM;\n      param_type= MYSQL_TYPE_LONGLONG;\n      break;\n    case STRING_RESULT:\n    {\n      CHARSET_INFO *fromcs= entry->collation.collation;\n      CHARSET_INFO *tocs= thd->variables.collation_connection;\n      uint32 dummy_offset;\n      value.cs_info.character_set_of_placeholder= fromcs;\n      value.cs_info.character_set_client= thd->variables.character_set_client;\n      value.cs_info.final_character_set_of_str_value=\n        String::needs_conversion(0, fromcs, tocs, &dummy_offset) ?\n        tocs : fromcs;\n      item_type= Item::STRING_ITEM;\n      param_type= MYSQL_TYPE_VARCHAR;\n      if (set_str((const char *)entry->value, entry->length))\n        DBUG_RETURN(1);\n      break;\n    }\n    case DECIMAL_RESULT:\n    {\n      const my_decimal *ent_value= (const my_decimal *)entry->value;\n      my_decimal2decimal(ent_value, &decimal_value);\n      state= DECIMAL_VALUE;\n      decimals= ent_value->frac;\n      max_length=\n        my_decimal_precision_to_length_no_truncation(ent_value->precision(),\n                                                     decimals, unsigned_flag);\n      item_type= Item::DECIMAL_ITEM;\n      param_type= MYSQL_TYPE_NEWDECIMAL;\n      break;\n    }\n    case ROW_RESULT:\n    case TIME_RESULT:\n    case IMPOSSIBLE_RESULT:\n      DBUG_ASSERT(0);\n      set_null();\n    }\n  }\n  else\n    set_null();\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "njs_chb_write_byte_as_utf8(njs_chb_t *chain, u_char byte)\n{\n    njs_utf8_encode(njs_chb_current(chain), byte);\n    njs_chb_written(chain, njs_utf8_size(byte));\n}", "target": 0}
{"code": "  char *strndup(const char *str, size_t size)\n  {\n    char *copy;\n    size_t len = strlen(str);\n    if (len > size)\n      len = size;\n    copy = (char *)REDIRECT_MALLOC(len + 1);\n    if (copy == NULL) {\n      errno = ENOMEM;\n      return NULL;\n    }\n    BCOPY(str, copy, len);\n    copy[len] = '\\0';\n    return copy;\n  }", "target": 0}
{"code": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\tset_pte(ptep, pte);\n}", "target": 1}
{"code": "static int dbConnect(char *host, char *user, char *passwd)\n{\n  DBUG_ENTER(\"dbConnect\");\n  if (verbose)\n  {\n    fprintf(stderr, \"# Connecting to %s...\\n\", host ? host : \"localhost\");\n  }\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql_connection, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlcheck\");\n  if (!(sock = mysql_real_connect(&mysql_connection, host, user, passwd,\n         NULL, opt_mysql_port, opt_mysql_unix_port, 0)))\n  {\n    DBerror(&mysql_connection, \"when trying to connect\");\n    DBUG_RETURN(1);\n  }\n  mysql_connection.reconnect= 1;\n  DBUG_RETURN(0);\n} ", "target": 1}
{"code": "update_ldap_mod_auth_ind(krb5_context context, krb5_db_entry *entry,\n                         LDAPMod ***mods)\n{\n    int i = 0;\n    krb5_error_code ret;\n    char *auth_ind = NULL;\n    char *strval[10] = {};\n    char *ai, *ai_save = NULL;\n    int sv_num = sizeof(strval) / sizeof(*strval);\n    ret = krb5_dbe_get_string(context, entry, KRB5_KDB_SK_REQUIRE_AUTH,\n                              &auth_ind);\n    if (ret || auth_ind == NULL)\n        goto cleanup;\n    ai = strtok_r(auth_ind, \" \", &ai_save);\n    while (ai != NULL && i < sv_num) {\n        strval[i++] = ai;\n        ai = strtok_r(NULL, \" \", &ai_save);\n    }\n    ret = krb5_add_str_mem_ldap_mod(mods, \"krbPrincipalAuthInd\",\n                                    LDAP_MOD_REPLACE, strval);\ncleanup:\n    krb5_dbe_free_string(context, auth_ind);\n    return ret;\n}", "target": 0}
{"code": "static int __init sit_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\treturn err;\n}", "target": 1}
{"code": "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\nerror:\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}", "target": 1}
{"code": "static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\tint err = 0;\n\tu32 perm;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tif (skb->len < NLMSG_HDRLEN) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tnlh = nlmsg_hdr(skb);\n\terr = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);\n\tif (err) {\n\t\tif (err == -EINVAL) {\n\t\t\tpr_warn_ratelimited(\"SELinux: unrecognized netlink\"\n\t\t\t       \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n\t\t\t       \" pid=%d comm=%s\\n\",\n\t\t\t       sk->sk_protocol, nlh->nlmsg_type,\n\t\t\t       secclass_map[sksec->sclass - 1].name,\n\t\t\t       task_pid_nr(current), current->comm);\n\t\t\tif (!enforcing_enabled(&selinux_state) ||\n\t\t\t    security_get_allow_unknown(&selinux_state))\n\t\t\t\terr = 0;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto out;\n\t}\n\terr = sock_has_perm(sk, perm);\nout:\n\treturn err;\n}", "target": 1}
{"code": "xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {\n    int len = 0, l;\n    int c;\n    int count = 0;\n    const xmlChar *end; \n#ifdef DEBUG\n    nbParseNCNameComplex++;\n#endif\n    GROW;\n    end = ctxt->input->cur;\n    c = CUR_CHAR(l);\n    if ((c == ' ') || (c == '>') || (c == '/') || \n\t(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {\n\treturn(NULL);\n    }\n    while ((c != ' ') && (c != '>') && (c != '/') && \n\t   (xmlIsNameChar(ctxt, c) && (c != ':'))) {\n\tif (count++ > XML_PARSER_CHUNK_SIZE) {\n            if ((len > XML_MAX_NAME_LENGTH) &&\n                ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n                return(NULL);\n            }\n\t    count = 0;\n\t    GROW;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t}\n\tlen += l;\n\tNEXTL(l);\n\tend = ctxt->input->cur;\n\tc = CUR_CHAR(l);\n\tif (c == 0) {\n\t    count = 0;\n\t    ctxt->input->cur -= l;\n\t    GROW;\n\t    ctxt->input->cur += l;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t    end = ctxt->input->cur;\n\t    c = CUR_CHAR(l);\n\t}\n    }\n    if ((len > XML_MAX_NAME_LENGTH) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n        return(NULL);\n    }\n    return(xmlDictLookup(ctxt->dict, end - len, len));\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, EqCanUseHashedIndexWithRegex) {\n    addIndex(BSON(\"a\"\n                  << \"hashed\"));\n    runQuery(fromjson(\"{a: {$eq: /abc/}}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n}", "target": 0}
{"code": "static int backref_match_at_nested_level(regex_t* reg,\n\t OnigStackType* top, OnigStackType* stk_base,\n\t int ignore_case, int case_fold_flag,\n\t int nest, int mem_num, UChar* memp, UChar** s, const UChar* send)\n{\n  UChar *ss, *p, *pstart, *pend = NULL_UCHARP;\n  int level;\n  OnigStackType* k;\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_START) {\n\tif (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {\n\t  pstart = k->u.mem.pstr;\n\t  if (pend != NULL_UCHARP) {\n\t    if (pend - pstart > send - *s) return 0; \n\t    p  = pstart;\n\t    ss = *s;\n\t    if (ignore_case != 0) {\n\t      if (string_cmp_ic(reg->enc, case_fold_flag,\n\t\t\t\tpstart, &ss, pend - pstart, send) == 0)\n\t\treturn 0; \n\t    }\n\t    else {\n\t      while (p < pend) {\n\t\tif (*p++ != *ss++) return 0; \n\t      }\n\t    }\n\t    *s = ss;\n\t    return 1;\n\t  }\n\t}\n      }\n      else if (k->type == STK_MEM_END) {\n\tif (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {\n\t  pend = k->u.mem.pstr;\n\t}\n      }\n    }\n    k--;\n  }\n  return 0;\n}", "target": 0}
{"code": "h2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\tconst char *b;\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (r2->req->req_body_status == REQ_BODY_NONE) {\n\t\tr2->state = H2_S_CLOS_REM;\n\t}\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tAZ(r2->req->ws->r);\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t\n\tif (req->req_body_status == REQ_BODY_INIT) {\n\t\tif (!http_GetHdr(req->http, H_Content_Length, &b))\n\t\t\treq->req_body_status = REQ_BODY_WITHOUT_LEN;\n\t\telse\n\t\t\treq->req_body_status = REQ_BODY_WITH_LEN;\n\t} else {\n\t\tassert (req->req_body_status == REQ_BODY_NONE);\n\t\tif (http_GetContentLength(req->http) > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task.func = h2_do_req;\n\treq->task.priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, &req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); \n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)\n{\n\tbool answer = false;\n\tchar *c2, *task_cg;\n\tsize_t target_len, task_len;\n\tif (strcmp(cg, \"/\") == 0)\n\t\treturn true;\n\tc2 = get_pid_cgroup(pid, contrl);\n\tif (!c2)\n\t\treturn false;\n\ttask_cg = c2 + 1;\n\ttarget_len = strlen(cg);\n\ttask_len = strlen(task_cg);\n\tif (strcmp(cg, task_cg) == 0) {\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len < task_len) {\n\t\tif (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len > task_len) {\n\t\tif (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfree(c2);\n\treturn answer;\n}", "target": 0}
{"code": "void Context::onStart(absl::string_view root_id, absl::string_view vm_configuration) {\n  if (wasm_->onStart_) {\n    auto root_id_addr = wasm_->copyString(root_id);\n    auto config_addr = wasm_->copyString(vm_configuration);\n    wasm_->onStart_(this, id_, root_id_addr, root_id.size(), config_addr, vm_configuration.size());\n  }\n  in_vm_context_created_ = true;\n}", "target": 0}
{"code": "get_number(int *numptr, int low, const char *names[], int ch, FILE *file,\n    const char *terms) {\n\tchar temp[MAX_TEMPSTR], *pc;\n\tint len, i;\n\tpc = temp;\n\tlen = 0;\n\twhile (isdigit((unsigned char)ch)) {\n\t\tif (++len >= MAX_TEMPSTR)\n\t\t\tgoto bad;\n\t\t*pc++ = ch;\n\t\tch = get_char(file);\n\t}\n\t*pc = '\\0';\n\tif (len != 0) {\n\t\tif (!strchr(terms, ch))\n\t\t\tgoto bad;\n\t\t*numptr = atoi(temp);\n\t\treturn (ch);\n\t}\n\tif (names) {\n\t\twhile (isalpha((unsigned char)ch)) {\n\t\t\tif (++len >= MAX_TEMPSTR)\n\t\t\t\tgoto bad;\n\t\t\t*pc++ = ch;\n\t\t\tch = get_char(file);\n\t\t}\n\t\t*pc = '\\0';\n\t\tif (len != 0 && strchr(terms, ch)) {\n\t\t\tfor (i = 0;  names[i] != NULL;  i++) {\n\t\t\t\tDebug(DPARS|DEXT,\n\t\t\t\t\t(\"get_num, compare(%s,%s)\\n\", names[i],\n\t\t\t\t\ttemp))\n\t\t\t\tif (!strcasecmp(names[i], temp)) {\n\t\t\t\t\t*numptr = i+low;\n\t\t\t\t\treturn (ch);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nbad:\n\tunget_char(ch, file);\n\treturn (EOF);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, CompoundIndexBoundsRangeAndEquality) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    runQuery(fromjson(\"{a: {$gt: 8}, b: 6}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, bounds: \"\n        \"{a: [[8,Infinity,false,true]], b:[[6,6,true,true]]}}}}}\");\n}", "target": 0}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "bool AudioContext::isAudioThread() const\n{\n    return currentThread() == m_audioThread;\n}", "target": 0}
{"code": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval; \n}", "target": 1}
{"code": "    void Encode(Key, const Value& value) {\n      AddToSummary(Key::key(), Key::Encode(value).size());\n    }", "target": 1}
{"code": "static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}", "target": 1}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "std::map<string, AttrValue> GetSetAttrs(const FunctionDef& fdef) {\n  std::map<string, AttrValue> set_attrs;\n  for (const auto& pair : fdef.attr()) {\n    if (pair.second.value_case() != AttrValue::VALUE_NOT_SET) {\n      set_attrs[pair.first] = pair.second;\n    }\n  }\n  return set_attrs;\n}", "target": 0}
{"code": "static bool shouldOpenInNewWindow(Frame* targetFrame, const FrameLoadRequest& request, const NavigationAction& action)\n{\n    if (!targetFrame && !request.frameName().isEmpty())\n        return true;\n    if (!request.formState())\n        return false;\n    NavigationPolicy navigationPolicy = NavigationPolicyCurrentTab;\n    if (!action.specifiesNavigationPolicy(&navigationPolicy))\n        return false;\n    return navigationPolicy != NavigationPolicyCurrentTab;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, AndWithNestedNE) {\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{a: {$gt: -1, $lt: 1, $ne: 0}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a:1}, \"\n        \"bounds: {a: [[-1,0,false,false], \"\n        \"[0,1,false,false]]}}}}}\");\n}", "target": 0}
{"code": "static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)\n{\n    int sig_nid, use_pc_sigalgs = 0;\n    size_t i;\n    const SIGALG_LOOKUP *sigalg;\n    size_t sigalgslen;\n    if (default_nid == -1)\n        return 1;\n    sig_nid = X509_get_signature_nid(x);\n    if (default_nid)\n        return sig_nid == default_nid ? 1 : 0;\n    if (SSL_IS_TLS13(s) && s->s3.tmp.peer_cert_sigalgs != NULL) {\n        sigalgslen = s->s3.tmp.peer_cert_sigalgslen;\n        use_pc_sigalgs = 1;\n    } else {\n        sigalgslen = s->shared_sigalgslen;\n    }\n    for (i = 0; i < sigalgslen; i++) {\n        sigalg = use_pc_sigalgs\n                 ? tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i])\n                 : s->shared_sigalgs[i];\n        if (sig_nid == sigalg->sigandhash)\n            return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "int sc_compare_oid(const struct sc_object_id *oid1, const struct sc_object_id *oid2)\n{\n\tint i;\n\tif (oid1 == NULL || oid2 == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tfor (i = 0; i < SC_MAX_OBJECT_ID_OCTETS; i++)   {\n\t\tif (oid1->value[i] != oid2->value[i])\n\t\t\treturn 0;\n\t\tif (oid1->value[i] == -1)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "CONCRETE_IO_HANDLE socketio_create(void* io_create_parameters)\n{\n    SOCKETIO_CONFIG* socket_io_config = (SOCKETIO_CONFIG*)io_create_parameters;\n    SOCKET_IO_INSTANCE* result;\n    struct tcp_keepalive tcp_keepalive = { 0, 0, 0 };\n    if (socket_io_config == NULL)\n    {\n        LogError(\"Invalid argument: socket_io_config is NULL\");\n        result = NULL;\n    }\n    else\n    {\n        result = (SOCKET_IO_INSTANCE*)malloc(sizeof(SOCKET_IO_INSTANCE));\n        if (result != NULL)\n        {\n            (void)memset(result, 0, sizeof(SOCKET_IO_INSTANCE));\n            result->address_type = ADDRESS_TYPE_IP;\n            result->pending_io_list = singlylinkedlist_create();\n            if (result->pending_io_list == NULL)\n            {\n                LogError(\"Failure: singlylinkedlist_create unable to create pending list.\");\n                destroy_socket_io_instance(result);\n                result = NULL;\n            }\n            else\n            {\n                if (socket_io_config->hostname != NULL)\n                {\n                    result->hostname = (char*)malloc(strlen(socket_io_config->hostname) + 1);\n                    if (result->hostname != NULL)\n                    {\n                        (void)strcpy(result->hostname, socket_io_config->hostname);\n                    }\n                    result->socket = INVALID_SOCKET;\n                }\n                else\n                {\n                    result->hostname = NULL;\n                    result->socket = *((SOCKET*)socket_io_config->accepted_socket);\n                }\n                if ((result->hostname == NULL) && (result->socket == INVALID_SOCKET))\n                {\n                    LogError(\"Failure: hostname == NULL and socket is invalid.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else if ((result->addrInfo = calloc(1, sizeof(struct addrinfo))) == NULL)\n                {\n                    LogError(\"Failure: addrInfo == NULL.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->port = socket_io_config->port;\n                    result->on_io_open_complete = NULL;\n                    result->dns_resolver = dns_resolver_create(result->hostname, socket_io_config->port, NULL);\n                    result->on_bytes_received = NULL;\n                    result->on_io_error = NULL;\n                    result->on_bytes_received_context = NULL;\n                    result->on_io_error_context = NULL;\n                    result->io_state = IO_STATE_CLOSED;\n                    result->keep_alive = tcp_keepalive;\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Allocation Failure: SOCKET_IO_INSTANCE\");\n        }\n    }\n    return (XIO_HANDLE)result;\n}", "target": 1}
{"code": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  \n\tURI_CHAR * write = dest;\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\t\tqueryList = queryList->next;\n\t}\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; \n\t\t}\n\t}\n\treturn URI_SUCCESS;\n}", "target": 1}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\treturn data;\n}", "target": 1}
{"code": "inline bool RARPPM_CONTEXT::decodeSymbol2(ModelPPM *Model)\n{\n  int count, HiCnt, i=NumStats-Model->NumMasked;\n  RARPPM_SEE2_CONTEXT* psee2c=makeEscFreq2(Model,i);\n  RARPPM_STATE* ps[256], ** pps=ps, * p=U.Stats-1;\n  HiCnt=0;\n  do \n  {\n    do \n    { \n      p++; \n    } while (Model->CharMask[p->Symbol] == Model->EscCount);\n    HiCnt += p->Freq;\n    if (pps>=ps+ASIZE(ps))\n      return false;\n    *pps++ = p;\n  } while ( --i );\n  Model->Coder.SubRange.scale += HiCnt;\n  count=Model->Coder.GetCurrentCount();\n  if (count>=(int)Model->Coder.SubRange.scale)\n    return(false);\n  p=*(pps=ps);\n  if (count < HiCnt) \n  {\n    HiCnt=0;\n    while ((HiCnt += p->Freq) <= count) \n    {\n      pps++;\n      if (pps>=ps+ASIZE(ps)) \n        return false;\n      p=*pps;\n    }\n    Model->Coder.SubRange.LowCount = (Model->Coder.SubRange.HighCount=HiCnt)-p->Freq;\n    psee2c->update();\n    update2(Model,p);\n  }\n  else\n  {\n    Model->Coder.SubRange.LowCount=HiCnt;\n    Model->Coder.SubRange.HighCount=Model->Coder.SubRange.scale;\n    i=NumStats-Model->NumMasked;\n    pps--;\n    do \n    { \n      pps++;\n      if (pps>=ps+ASIZE(ps)) \n        return false;\n      Model->CharMask[(*pps)->Symbol]=Model->EscCount; \n    } while ( --i );\n    psee2c->Summ += Model->Coder.SubRange.scale;\n    Model->NumMasked = NumStats;\n  }\n  return true;\n}", "target": 1}
{"code": " void DelegatedFrameHost::ClearDelegatedFrame() {\n   EvictDelegatedFrame();\n }", "target": 1}
{"code": "static int ptrace_signal(int signr, siginfo_t *info,\n\t\t\t struct pt_regs *regs, void *cookie)\n{\n\tif (!task_ptrace(current))\n\t\treturn signr;\n\tptrace_signal_deliver(regs, cookie);\n\tptrace_stop(signr, 0, info);\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\tcurrent->exit_code = 0;\n\tif (signr != info->si_signo) {\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = task_uid(current->parent);\n\t}\n\tif (sigismember(&current->blocked, signr)) {\n\t\tspecific_send_sig_info(signr, info, current);\n\t\tsignr = 0;\n\t}\n\treturn signr;\n}", "target": 0}
{"code": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = *data++;\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\treturn data;\n}", "target": 1}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\trcu_assign_pointer(*pp, p);\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "static int selinux_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec;\n\tsbsec = kzalloc(sizeof(struct superblock_security_struct), GFP_KERNEL);\n\tif (!sbsec)\n\t\treturn -ENOMEM;\n\tmutex_init(&sbsec->lock);\n\tINIT_LIST_HEAD(&sbsec->isec_head);\n\tspin_lock_init(&sbsec->isec_lock);\n\tsbsec->sb = sb;\n\tsbsec->sid = SECINITSID_UNLABELED;\n\tsbsec->def_sid = SECINITSID_FILE;\n\tsbsec->mntpoint_sid = SECINITSID_UNLABELED;\n\tsb->s_security = sbsec;\n\treturn 0;\n}", "target": 0}
{"code": "void fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_work(&delayed_fput_work);\n\t}\n}", "target": 1}
{"code": "int gnutls_x509_aki_set_cert_issuer(gnutls_x509_aki_t aki,\n\t\t\t\t    unsigned int san_type,\n\t\t\t\t    const gnutls_datum_t * san,\n\t\t\t\t    const char *othername_oid,\n\t\t\t\t    const gnutls_datum_t * serial)\n{\n\tint ret;\n\tgnutls_datum_t t_san, t_othername_oid = { NULL, 0 };\n\tret = _gnutls_set_datum(&aki->serial, serial->data, serial->size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\taki->cert_issuer.names[aki->cert_issuer.size].type = san_type;\n\tret = _gnutls_set_datum(&t_san, san->data, san->size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tif (othername_oid) {\n\t\tt_othername_oid.data = (uint8_t *) gnutls_strdup(othername_oid);\n\t\tif (t_othername_oid.data == NULL) {\n\t\t\tgnutls_free(t_san.data);\n\t\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\t\t}\n\t\tt_othername_oid.size = strlen(othername_oid);\n\t}\n\tret =\n\t    subject_alt_names_set(&aki->cert_issuer.names,\n\t\t\t\t  &aki->cert_issuer.size, san_type, &t_san,\n\t\t\t\t  (char *)t_othername_oid.data);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "PHP_FUNCTION(imagecropauto)\n{\n\tzval *IM;\n\tlong mode = -1;\n\tlong color = -1;\n\tdouble threshold = 0.5f;\n\tgdImagePtr im;\n\tgdImagePtr im_crop;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|ldl\", &IM, &mode, &threshold, &color) == FAILURE)  {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tswitch (mode) {\n\t\tcase -1:\n\t\t\tmode = GD_CROP_DEFAULT;\n\t\tcase GD_CROP_DEFAULT:\n\t\tcase GD_CROP_TRANSPARENT:\n\t\tcase GD_CROP_BLACK:\n\t\tcase GD_CROP_WHITE:\n\t\tcase GD_CROP_SIDES:\n\t\t\tim_crop = gdImageCropAuto(im, mode);\n\t\t\tbreak;\n\t\tcase GD_CROP_THRESHOLD:\n\t\t\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color argument missing with threshold mode\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tim_crop = gdImageCropThreshold(im, color, (float) threshold);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown crop mode\");\n\t\t\tRETURN_FALSE;\n\t}\n\tif (im_crop == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);\n\t}\n}", "target": 0}
{"code": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MagickPathExtent];\n  const char\n    *option;\n  graph_t\n    *graph;\n  Image\n    *image;\n  ImageInfo\n    *read_info;\n  MagickBooleanType\n    status;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}", "target": 1}
{"code": "new_msg_lsa_change_notify (u_char msgtype,\n\t\t\t   u_int32_t seqnum,\n\t\t\t   struct in_addr ifaddr,\n\t\t\t   struct in_addr area_id,\n\t\t\t   u_char is_self_originated, struct lsa_header *data)\n{\n  u_char buf[OSPF_API_MAX_MSG_SIZE];\n  struct msg_lsa_change_notify *nmsg;\n  int len;\n  assert (data);\n  nmsg = (struct msg_lsa_change_notify *) buf;\n  len = ntohs (data->length) + sizeof (struct msg_lsa_change_notify)\n    - sizeof (struct lsa_header);\n  nmsg->ifaddr = ifaddr;\n  nmsg->area_id = area_id;\n  nmsg->is_self_originated = is_self_originated;\n  memset (&nmsg->pad, 0, sizeof (nmsg->pad));\n  memcpy (&nmsg->data, data, ntohs (data->length));\n  return msg_new (msgtype, nmsg, seqnum, len);\n}", "target": 1}
{"code": "int fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tif (!ci ||\n\t\t(ci->ci_keyring_key &&\n\t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))\n\t\treturn fscrypt_get_crypt_info(inode);\n\treturn 0;\n}", "target": 1}
{"code": "int fz_colorspace_device_n_has_only_cmyk(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && ((cs->flags & FZ_CS_HAS_CMYK_AND_SPOTS) == FZ_CS_HAS_CMYK);\n}", "target": 0}
{"code": "static cfg_opt_t *cfg_dupopt_array(cfg_opt_t *opts)\n{\n\tint i;\n\tcfg_opt_t *dupopts;\n\tint n = cfg_numopts(opts);\n\tdupopts = calloc(n + 1, sizeof(cfg_opt_t));\n\tif (!dupopts)\n\t\treturn NULL;\n\tmemcpy(dupopts, opts, n * sizeof(cfg_opt_t));\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = NULL;\n\t\tdupopts[i].subopts = NULL;\n\t\tdupopts[i].def.parsed = NULL;\n\t\tdupopts[i].def.string = NULL;\n\t\tdupopts[i].comment = NULL;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = strdup(opts[i].name);\n\t\tif (!dupopts[i].name)\n\t\t\tgoto err;\n\t\tif (opts[i].subopts) {\n\t\t\tdupopts[i].subopts = cfg_dupopt_array(opts[i].subopts);\n\t\t\tif (!dupopts[i].subopts)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.parsed) {\n\t\t\tdupopts[i].def.parsed = strdup(opts[i].def.parsed);\n\t\t\tif (!dupopts[i].def.parsed)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.string) {\n\t\t\tdupopts[i].def.string = strdup(opts[i].def.string);\n\t\t\tif (!dupopts[i].def.string)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].comment) {\n\t\t\tdupopts[i].comment = strdup(opts[i].comment);\n\t\t\tif (!dupopts[i].comment)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn dupopts;\nerr:\n\tcfg_free_opt_array(dupopts);\n\treturn NULL;\n}", "target": 0}
{"code": "gs_font_map_glyph_to_unicode(gs_font *font, gs_glyph glyph, int ch, ushort *u, unsigned int length)\n{\n    font_data *pdata = pfont_data(font);\n    const ref *UnicodeDecoding;\n    uchar *unicode_return = (uchar *)u;\n    if (r_type(&pdata->GlyphNames2Unicode) == t_dictionary) {\n        int c = gs_font_map_glyph_by_dict(font->memory,\n                                              &pdata->GlyphNames2Unicode, glyph, u, length);\n        if (c != 0)\n            return c;\n        if (ch != -1) { \n            ref *v, n;\n            make_int(&n, ch);\n            if (dict_find(&pdata->GlyphNames2Unicode, &n, &v) > 0) {\n                if (r_has_type(v, t_string)) {\n                    int l = r_size(v);\n                    if (l > length)\n                        return l;\n                    memcpy(unicode_return, v->value.const_bytes, l * sizeof(short));\n                    return l;\n                }\n                if (r_type(v) == t_integer) {\n                    if (v->value.intval > 65535) {\n                        if (length < 4)\n                            return 4;\n                        unicode_return[0] = v->value.intval >> 24;\n                        unicode_return[1] = (v->value.intval & 0x00FF0000) >> 16;\n                        unicode_return[2] = (v->value.intval & 0x0000FF00) >> 8;\n                        unicode_return[3] = v->value.intval & 0xFF;\n                        return 4;\n                    } else {\n                        if (length < 2)\n                            return 2;\n                        unicode_return[0] = v->value.intval >> 8;\n                        unicode_return[1] = v->value.intval & 0xFF;\n                        return 2;\n                    }\n                }\n            }\n        }\n    }\n    if (glyph <= GS_MIN_CID_GLYPH) {\n        UnicodeDecoding = zfont_get_to_unicode_map(font->dir);\n        if (UnicodeDecoding != NULL && r_type(UnicodeDecoding) == t_dictionary)\n            return gs_font_map_glyph_by_dict(font->memory, UnicodeDecoding, glyph, u, length);\n    }\n    return 0; \n}", "target": 1}
{"code": "op_reindent(oparg_T *oap, int (*how)(void))\n{\n    long\ti = 0;\n    char_u\t*l;\n    int\t\tamount;\n    linenr_T\tfirst_changed = 0;\n    linenr_T\tlast_changed = 0;\n    linenr_T\tstart_lnum = curwin->w_cursor.lnum;\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n    if (u_savecommon(start_lnum - 1, start_lnum + oap->line_count,\n\t\t\t\t     start_lnum + oap->line_count, FALSE) == OK)\n\tfor (i = oap->line_count; --i >= 0 && !got_int; )\n\t{\n\t    if (i > 1\n\t\t    && (i % 50 == 0 || i == oap->line_count - 1)\n\t\t    && oap->line_count > p_report)\n\t\tsmsg(_(\"%ld lines to indent... \"), i);\n\t    if (i != oap->line_count - 1 || oap->line_count == 1\n\t\t\t\t\t\t     || how != get_lisp_indent)\n\t    {\n\t\tl = skipwhite(ml_get_curline());\n\t\tif (*l == NUL)\t\t    \n\t\t    amount = 0;\n\t\telse\n\t\t    amount = how();\t    \n\t\tif (amount >= 0 && set_indent(amount, 0))\n\t\t{\n\t\t    if (first_changed == 0)\n\t\t\tfirst_changed = curwin->w_cursor.lnum;\n\t\t    last_changed = curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;  \n\t}\n    curwin->w_cursor.lnum = start_lnum;\n    beginline(BL_SOL | BL_FIX);\n    if (last_changed != 0)\n\tchanged_lines(first_changed, 0,\n\t\toap->is_VIsual ? start_lnum + oap->line_count :\n\t\tlast_changed + 1, 0L);\n    else if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n    if (oap->line_count > p_report)\n    {\n\ti = oap->line_count - (i + 1);\n\tsmsg(NGETTEXT(\"%ld line indented \",\n\t\t\t\t\t\t \"%ld lines indented \", i), i);\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n}", "target": 0}
{"code": "void connection_graceful_shutdown_maint (server *srv) {\n    connections * const conns = &srv->conns;\n    const int graceful_expire =\n      (srv->graceful_expire_ts && srv->graceful_expire_ts < log_epoch_secs);\n    for (uint32_t ndx = 0; ndx < conns->used; ++ndx) {\n        connection * const con = conns->ptr[ndx];\n        int changed = 0;\n        request_st * const r = &con->request;\n        if (r->state == CON_STATE_CLOSE) {\n            if (HTTP_LINGER_TIMEOUT > 1)\n                con->close_timeout_ts -= (HTTP_LINGER_TIMEOUT - 1);\n            if (log_epoch_secs - con->close_timeout_ts > HTTP_LINGER_TIMEOUT)\n                changed = 1;\n        }\n        else if (con->h2 && r->state == CON_STATE_WRITE) {\n            h2_send_goaway(con, H2_E_NO_ERROR);\n            if (0 == con->h2->rused && chunkqueue_is_empty(con->write_queue)) {\n                connection_set_state(r, CON_STATE_RESPONSE_END);\n                changed = 1;\n            }\n        }\n        else if (r->state == CON_STATE_READ && con->request_count > 1\n                 && chunkqueue_is_empty(con->read_queue)) {\n            connection_set_state_error(r, CON_STATE_ERROR);\n            changed = 1;\n        }\n        if (graceful_expire) {\n            connection_set_state_error(r, CON_STATE_ERROR);\n            changed = 1;\n        }\n        r->keep_alive = 0;            \n        r->conf.bytes_per_second = 0;         \n        r->conf.global_bytes_per_second = 0;  \n        if (con->traffic_limit_reached) {\n            con->traffic_limit_reached = 0;\n            changed = 1;\n        }\n        if (changed) {\n            connection_state_machine(con);\n        }\n    }\n}", "target": 0}
{"code": "inline bool operator ==(const MaskedIP& l, const MaskedIP& r) {\n  auto shift = std::max((l.v6 ? 128 : 32) - l.prefix,\n\t\t\t(r.v6 ? 128 : 32) - r.prefix);\n  ceph_assert(shift > 0);\n  return (l.addr >> shift) == (r.addr >> shift);\n}", "target": 1}
{"code": "void Statement::Work_AfterReset(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { env.Null() };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n    STATEMENT_END();\n}", "target": 0}
{"code": "mld6_print(netdissect_options *ndo, const u_char *bp)\n{\n\tconst struct mld6_hdr *mp = (const struct mld6_hdr *)bp;\n\tconst u_char *ep;\n\tep = ndo->ndo_snapend;\n\tif ((const u_char *)mp + sizeof(*mp) > ep)\n\t\treturn;\n\tND_PRINT((ndo,\"max resp delay: %d \", EXTRACT_16BITS(&mp->mld6_maxdelay)));\n\tND_PRINT((ndo,\"addr: %s\", ip6addr_string(ndo, &mp->mld6_addr)));\n}", "target": 0}
{"code": "extract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n    gboolean result = FALSE;\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n            goto out;\n        }\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}", "target": 1}
{"code": "RecordCloseDown(ExtensionEntry * extEntry)\n{\n    DeleteCallback(&ClientStateCallback, RecordAClientStateChange, NULL);\n}                               ", "target": 0}
{"code": "static void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}", "target": 1}
{"code": "int ldb_match_message(struct ldb_context *ldb,\n\t\t      const struct ldb_message *msg,\n\t\t      const struct ldb_parse_tree *tree,\n\t\t      enum ldb_scope scope, bool *matched)\n{\n\tunsigned int i;\n\tint ret;\n\t*matched = false;\n\tif (scope != LDB_SCOPE_BASE && ldb_dn_is_special(msg->dn)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tswitch (tree->operation) {\n\tcase LDB_OP_AND:\n\t\tfor (i=0;i<tree->u.list.num_elements;i++) {\n\t\t\tret = ldb_match_message(ldb, msg, tree->u.list.elements[i], scope, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (!*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = true;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_OR:\n\t\tfor (i=0;i<tree->u.list.num_elements;i++) {\n\t\t\tret = ldb_match_message(ldb, msg, tree->u.list.elements[i], scope, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = false;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_NOT:\n\t\tret = ldb_match_message(ldb, msg, tree->u.isnot.child, scope, matched);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t*matched = ! *matched;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_EQUALITY:\n\t\treturn ldb_match_equality(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_SUBSTRING:\n\t\treturn ldb_match_substring(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_GREATER:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_GREATER, matched);\n\tcase LDB_OP_LESS:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_LESS, matched);\n\tcase LDB_OP_PRESENT:\n\t\treturn ldb_match_present(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_APPROX:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_APPROX, matched);\n\tcase LDB_OP_EXTENDED:\n\t\treturn ldb_match_extended(ldb, msg, tree, scope, matched);\n\t}\n\treturn LDB_ERR_INAPPROPRIATE_MATCHING;\n}", "target": 0}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "static void execlists_submit_request(struct i915_request *request)\n{\n\tstruct intel_engine_cs *engine = request->engine;\n\tunsigned long flags;\n\tspin_lock_irqsave(&engine->active.lock, flags);\n\tqueue_request(engine, &request->sched, rq_prio(request));\n\tGEM_BUG_ON(RB_EMPTY_ROOT(&engine->execlists.queue.rb_root));\n\tGEM_BUG_ON(list_empty(&request->sched.link));\n\tsubmit_queue(engine, request);\n\tspin_unlock_irqrestore(&engine->active.lock, flags);\n}", "target": 0}
{"code": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tdevice_unregister(&clt->dev);\n}", "target": 1}
{"code": "__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; \n\tstruct alloc_context ac = { };\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\tfinalise_ac(gfp_mask, order, &ac);\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\treturn page;\n}", "target": 0}
{"code": "static int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", NT_PRXFPREG, sizeof(t->xfpu),\n\t\t\t  &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}", "target": 0}
{"code": "get_signed_descriptor_by_fp(const char *fp, int extrainfo,\n                            time_t publish_cutoff)\n{\n  if (router_digest_is_me(fp)) {\n    if (extrainfo)\n      return &(router_get_my_extrainfo()->cache_info);\n    else\n      return &(router_get_my_routerinfo()->cache_info);\n  } else {\n    const routerinfo_t *ri = router_get_by_id_digest(fp);\n    if (ri &&\n        ri->cache_info.published_on > publish_cutoff) {\n      if (extrainfo)\n        return extrainfo_get_by_descriptor_digest(\n                                     ri->cache_info.extra_info_digest);\n      else\n        return &ri->cache_info;\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "max3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum,\n\t\t    int force_toggles)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint old_epnum, same_ep, rcvtog, sndtog;\n\tstruct usb_device *old_dev;\n\tu8 hctl;\n\told_dev = max3421_hcd->loaded_dev;\n\told_epnum = max3421_hcd->loaded_epnum;\n\tsame_ep = (dev == old_dev && epnum == old_epnum);\n\tif (same_ep && !force_toggles)\n\t\treturn;\n\tif (old_dev && !same_ep) {\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\trcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tsndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tusb_settoggle(old_dev, old_epnum, 0, rcvtog);\n\t\tusb_settoggle(old_dev, old_epnum, 1, sndtog);\n\t}\n\trcvtog = usb_gettoggle(dev, epnum, 0);\n\tsndtog = usb_gettoggle(dev, epnum, 1);\n\thctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\n\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\tmax3421_hcd->loaded_epnum = epnum;\n\tspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\n\tmax3421_hcd->loaded_dev = dev;\n\tspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\n}", "target": 1}
{"code": "int get_netnsid_from_name(const char *name)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct rtgenmsg g;\n\t\tchar            buf[1024];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST,\n\t\t.n.nlmsg_type = RTM_GETNSID,\n\t\t.g.rtgen_family = AF_UNSPEC,\n\t};\n\tstruct nlmsghdr *answer;\n\tstruct rtattr *tb[NETNSA_MAX + 1];\n\tstruct rtgenmsg *rthdr;\n\tint len, fd;\n\tnetns_nsid_socket_init();\n\tfd = netns_get_fd(name);\n\tif (fd < 0)\n\t\treturn fd;\n\taddattr32(&req.n, 1024, NETNSA_FD, fd);\n\tif (rtnl_talk(&rtnsh, &req.n, &answer) < 0) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tclose(fd);\n\tif (answer->nlmsg_type == NLMSG_ERROR)\n\t\tgoto err_out;\n\trthdr = NLMSG_DATA(answer);\n\tlen = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr));\n\tif (len < 0)\n\t\tgoto err_out;\n\tparse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len);\n\tif (tb[NETNSA_NSID]) {\n\t\tfree(answer);\n\t\treturn rta_getattr_u32(tb[NETNSA_NSID]);\n\t}\nerr_out:\n\tfree(answer);\n\treturn -1;\n}", "target": 1}
{"code": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\treturn do_send_specific(tgid, pid, sig, info);\n}", "target": 1}
{"code": "static void compact(VarEnv* v, Array &ret, const Variant& var) {\n  if (var.isArray()) {\n    for (ArrayIter iter(var.getArrayData()); iter; ++iter) {\n      compact(v, ret, iter.second());\n    }\n  } else {\n    String varname = var.toString();\n    if (!varname.empty() && v->lookup(varname.get()) != NULL) {\n      ret.set(varname, *reinterpret_cast<Variant*>(v->lookup(varname.get())));\n    }\n  }\n}", "target": 1}
{"code": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tsmp_wmb(); \n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (pud_present(*pud))\t\t\n\t\tpmd_free(mm, new);\n\telse\n\t\tpud_populate(mm, pud, new);\n#else\n\tif (pgd_present(*pud))\t\t\n\t\tpmd_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pud, new);\n#endif \n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}", "target": 0}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                   (unsigned long) strip, (unsigned long)rows);\n                         return 0;\n                 }\n                bufp += bytes_read;\n         }\n         return 1;\n} ", "target": 1}
{"code": "ds_fgetstr (FILE *f, dynamic_string *s, char eos)\n{\n  int insize;\t\t\t\n  int strsize;\t\t\t\n  int next_ch;\n  insize = 0;\n  strsize = s->ds_length;\n  next_ch = getc (f);\n  while (next_ch != eos && next_ch != EOF)\n    {\n      if (insize >= strsize - 1)\n\t{\n\t  ds_resize (s, strsize * 2 + 2);\n\t  strsize = s->ds_length;\n\t}\n      s->ds_string[insize++] = next_ch;\n      next_ch = getc (f);\n    }\n  s->ds_string[insize++] = '\\0';\n  if (insize == 1 && next_ch == EOF)\n    return NULL;\n  else\n    return s->ds_string;\n}", "target": 1}
{"code": "static int proc_uptime_read(char *buf, size_t size, off_t offset,\n\t\tstruct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tstruct file_info *d = (struct file_info *)fi->fh;\n\tlong int reaperage = getreaperage(fc->pid);;\n\tunsigned long int busytime = get_reaper_busy(fc->pid), idletime;\n\tchar *cache = d->buf;\n\tsize_t total_len = 0;\n\tif (offset){\n\t\tif (offset > d->size)\n\t\t\treturn -EINVAL;\n\t\tif (!d->cached)\n\t\t\treturn 0;\n\t\tint left = d->size - offset;\n\t\ttotal_len = left > size ? size: left;\n\t\tmemcpy(buf, cache + offset, total_len);\n\t\treturn total_len;\n\t}\n\tidletime = reaperage - busytime;\n\tif (idletime > reaperage)\n\t\tidletime = reaperage;\n\ttotal_len = snprintf(d->buf, d->size, \"%ld.0 %lu.0\\n\", reaperage, idletime);\n\tif (total_len < 0){\n\t\tperror(\"Error writing to cache\");\n\t\treturn 0;\n\t}\n\td->size = (int)total_len;\n\td->cached = 1;\n\tif (total_len > size) total_len = size;\n\tmemcpy(buf, d->buf, total_len);\n\treturn total_len;\n}", "target": 0}
{"code": "SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\t\t       unsigned int, flags)\n{\n\tstruct sched_attr attr;\n\tstruct task_struct *p;\n\tint retval;\n\tif (!uattr || pid < 0 || flags)\n\t\treturn -EINVAL;\n\tretval = sched_copy_attr(uattr, &attr);\n\tif (retval)\n\t\treturn retval;\n\tif ((int)attr.sched_policy < 0)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setattr(p, &attr);\n\trcu_read_unlock();\n\treturn retval;\n}", "target": 0}
{"code": "init_connection_options(MYSQL *mysql)\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n}", "target": 1}
{"code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\tbool success = true;\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\tfree(buffer);\n\treturn success;\n}", "target": 1}
{"code": "isis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}", "target": 1}
{"code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\treturn -EINVAL;\n\t}\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\treturn 0;\n}", "target": 1}
{"code": "int32_t PPB_Flash_MessageLoop_Impl::InternalRun(\n    const RunFromHostProxyCallback& callback) {\n  if (state_->run_called()) {\n    if (!callback.is_null())\n      callback.Run(PP_ERROR_FAILED);\n    return PP_ERROR_FAILED;\n  }\n  state_->set_run_called();\n  state_->set_run_callback(callback);\n  scoped_refptr<State> state_protector(state_);\n   {\n     base::MessageLoop::ScopedNestableTaskAllower allow(\n         base::MessageLoop::current());\n     base::MessageLoop::current()->Run();\n   }\n  return state_protector->result();\n}", "target": 1}
{"code": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\tif ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)\n\t    && !vendor_intel(ctxt))\n\t\treturn emulate_ud(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tctxt->eflags &= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static void *my_malloc(size_t size)\n{\n    malloc_called += 1;\n    return malloc(size);\n}", "target": 1}
{"code": "DECLAREContigPutFunc(putcontig8bitCIELab)\n{\n\tfloat X, Y, Z;\n\tuint32 r, g, b;\n\t(void) y;\n\tfromskew *= 3;\n\twhile (h-- > 0) {\n\t\tfor (x = w; x-- > 0;) {\n\t\t\tTIFFCIELabToXYZ(img->cielab,\n\t\t\t\t\t(unsigned char)pp[0],\n\t\t\t\t\t(signed char)pp[1],\n\t\t\t\t\t(signed char)pp[2],\n\t\t\t\t\t&X, &Y, &Z);\n\t\t\tTIFFXYZToRGB(img->cielab, X, Y, Z, &r, &g, &b);\n\t\t\t*cp++ = PACK(r, g, b);\n\t\t\tpp += 3;\n\t\t}\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t}\n}", "target": 0}
{"code": "InlineBox* InlineFlowBox::firstLeafChild() const\n{\n    InlineBox* leaf = 0;\n    for (InlineBox* child = firstChild(); child && !leaf; child = child->nextOnLine())\n        leaf = child->isLeaf() ? child : static_cast<InlineFlowBox*>(child)->firstLeafChild();\n    return leaf;\n}", "target": 0}
{"code": "xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size,\n                  const char *URL, const char *encoding, int options)\n{\n    xmlParserInputBufferPtr input;\n    xmlParserInputPtr stream;\n    if (ctxt == NULL)\n        return (NULL);\n    if (buffer == NULL)\n        return (NULL);\n    xmlInitParser();\n    xmlCtxtReset(ctxt);\n    input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n    if (input == NULL) {\n\treturn(NULL);\n    }\n    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);\n    if (stream == NULL) {\n\txmlFreeParserInputBuffer(input);\n\treturn(NULL);\n    }\n    inputPush(ctxt, stream);\n    return (xmlDoRead(ctxt, URL, encoding, options, 1));\n}", "target": 0}
{"code": "  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      if (headers.Path() == nullptr) {\n        return false;\n      }\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }", "target": 0}
{"code": "parse_LEARN(char *arg, const struct ofpact_parse_params *pp)\n{\n    return learn_parse(arg, pp->port_map, pp->table_map, pp->ofpacts);\n}", "target": 0}
{"code": "join_tab_cmp_straight(const void *dummy, const void* ptr1, const void* ptr2)\n{\n  JOIN_TAB *jt1= *(JOIN_TAB**) ptr1;\n  JOIN_TAB *jt2= *(JOIN_TAB**) ptr2;\n  DBUG_ASSERT(!jt1->emb_sj_nest);\n  DBUG_ASSERT(!jt2->emb_sj_nest);\n  int cmp;\n  if ((cmp= compare_embedding_subqueries(jt1, jt2)) != 0)\n    return cmp;\n  if (jt1->dependent & jt2->table->map)\n    return 1;\n  if (jt2->dependent & jt1->table->map)\n    return -1;\n  return jt1 > jt2 ? 1 : (jt1 < jt2 ? -1 : 0);\n}", "target": 0}
{"code": "static int kvp_get_value(int pool, __u8 *key, int key_size, __u8 *value,\n\t\t\tint value_size)\n{\n\tint i;\n\tint num_records;\n\tstruct kvp_record *record;\n\tif ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||\n\t\t(value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE))\n\t\treturn 1;\n\tkvp_update_mem_state(pool);\n\tnum_records = kvp_file_info[pool].num_records;\n\trecord = kvp_file_info[pool].records;\n\tfor (i = 0; i < num_records; i++) {\n\t\tif (memcmp(key, record[i].key, key_size))\n\t\t\tcontinue;\n\t\tmemcpy(value, record[i].value, value_size);\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int rc4_hmac_md5_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                             void *ptr)\n{\n    EVP_RC4_HMAC_MD5 *key = data(ctx);\n    switch (type) {\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        {\n            unsigned int i;\n            unsigned char hmac_key[64];\n            memset(hmac_key, 0, sizeof(hmac_key));\n            if (arg > (int)sizeof(hmac_key)) {\n                MD5_Init(&key->head);\n                MD5_Update(&key->head, ptr, arg);\n                MD5_Final(hmac_key, &key->head);\n            } else {\n                memcpy(hmac_key, ptr, arg);\n            }\n            for (i = 0; i < sizeof(hmac_key); i++)\n                hmac_key[i] ^= 0x36; \n            MD5_Init(&key->head);\n            MD5_Update(&key->head, hmac_key, sizeof(hmac_key));\n            for (i = 0; i < sizeof(hmac_key); i++)\n                hmac_key[i] ^= 0x36 ^ 0x5c; \n            MD5_Init(&key->tail);\n            MD5_Update(&key->tail, hmac_key, sizeof(hmac_key));\n            OPENSSL_cleanse(hmac_key, sizeof(hmac_key));\n            return 1;\n        }\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        {\n            unsigned char *p = ptr;\n            unsigned int len;\n            if (arg != EVP_AEAD_TLS1_AAD_LEN)\n                return -1;\n            len = p[arg - 2] << 8 | p[arg - 1];\n            if (!EVP_CIPHER_CTX_encrypting(ctx)) {\n                len -= MD5_DIGEST_LENGTH;\n                p[arg - 2] = len >> 8;\n                p[arg - 1] = len;\n            }\n            key->payload_length = len;\n            key->md = key->head;\n            MD5_Update(&key->md, p, arg);\n            return MD5_DIGEST_LENGTH;\n        }\n    default:\n        return -1;\n    }\n}", "target": 1}
{"code": "AcpiNsGetNode (\n    ACPI_NAMESPACE_NODE     *PrefixNode,\n    const char              *Pathname,\n    UINT32                  Flags,\n    ACPI_NAMESPACE_NODE     **ReturnNode)\n{\n    ACPI_STATUS             Status;\n    ACPI_FUNCTION_TRACE_PTR (NsGetNode, ACPI_CAST_PTR (char, Pathname));\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_ACPI_STATUS (Status);\n    }\n    Status = AcpiNsGetNodeUnlocked (PrefixNode, Pathname,\n        Flags, ReturnNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n    return_ACPI_STATUS (Status);\n}", "target": 0}
{"code": "bool VBRISeeker::getOffsetForTime(int64_t *timeUs, off64_t *pos) {\n if (mDurationUs < 0 || mSegments.size() == 0) {\n return false;\n }\n int64_t segmentDurationUs = mDurationUs / mSegments.size();\n int64_t nowUs = 0;\n *pos = mBasePos;\n size_t segmentIndex = 0;\n while (segmentIndex < mSegments.size() && nowUs < *timeUs) {\n        nowUs += segmentDurationUs;\n *pos += mSegments.itemAt(segmentIndex++);\n }\n    ALOGV(\"getOffsetForTime %lld us => 0x%016llx\", (long long)*timeUs, (long long)*pos);\n *timeUs = nowUs;\n return true;\n}", "target": 0}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid *buf;\n\tint err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (memcpy_from_msg(buf, msg, len)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, buf, len, msg->msg_flags);\n\telse\n\t\terr = -ENOTCONN;\n\trelease_sock(sk);\n\tkfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "SSLNetVConnection::select_next_protocol(SSL *ssl, const unsigned char **out, unsigned char *outlen,\n                                        const unsigned char *in ATS_UNUSED, unsigned inlen ATS_UNUSED, void *)\n{\n  SSLNetVConnection *netvc = SSLNetVCAccess(ssl);\n  const unsigned char *npn = nullptr;\n  unsigned npnsz           = 0;\n  ink_release_assert(netvc != nullptr);\n  if (netvc->npnSet && netvc->npnSet->advertiseProtocols(&npn, &npnsz)) {\n#if HAVE_SSL_SELECT_NEXT_PROTO\n    if (SSL_select_next_proto((unsigned char **)out, outlen, npn, npnsz, in, inlen) == OPENSSL_NPN_NEGOTIATED) {\n      Debug(\"ssl\", \"selected ALPN protocol %.*s\", (int)(*outlen), *out);\n      return SSL_TLSEXT_ERR_OK;\n    }\n#endif \n  }\n  *out    = nullptr;\n  *outlen = 0;\n  return SSL_TLSEXT_ERR_NOACK;\n}", "target": 0}
{"code": "PHP_FUNCTION(is_finite)\n{\n\tdouble dval;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"d\", &dval) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_BOOL(zend_finite(dval));\n}", "target": 0}
{"code": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\ttrace_xfs_attr_sf_addname(args);\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}", "target": 1}
{"code": "mes_lookup (struct message *meslist, int max, int index)\n{\n  if ((index >= 0) && (index < max) && (meslist[index].key == index))\n    return meslist[index].str;\n  {\n    int i;\n    for (i = 0; i < max; i++, meslist++)\n      {\n\tif (meslist->key == index)\n\t  {\n\t    zlog_warn(\"message index %d [%s] found in position %d (max is %d)\",\n\t\t      index, meslist->str, i, max);\n\t    return meslist->str;\n\t  }\n      }\n  }\n  zlog_err(\"message index %d not found (max is %d)\", index, max);\n  return NULL;\n}", "target": 1}
{"code": "static gboolean is_correct_filename(const char *value)\n{\n    return printable_str(value) && !strchr(value, '/') && !strchr(value, '.');\n}", "target": 1}
{"code": "gx_default_update_spot_equivalent_colors(gx_device *pdev, const gs_gstate * pgs)\n{\n    return 0;\n}", "target": 0}
{"code": "unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)\n{\n    return ((f != NULL &&\n             f->addressFamily != NULL && f->addressFamily->data != NULL)\n            ? ((f->addressFamily->data[0] << 8) | (f->addressFamily->data[1]))\n            : 0);\n}", "target": 1}
{"code": "tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)\n{\n    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 1}
{"code": "static struct media_item *parse_media_folder(struct avrcp *session,\n\t\t\t\t\tuint8_t *operands, uint16_t len)\n{\n\tstruct avrcp_player *player = session->controller->player;\n\tstruct media_player *mp = player->user_data;\n\tstruct media_item *item;\n\tuint16_t namelen;\n\tchar name[255];\n\tuint64_t uid;\n\tuint8_t type;\n\tuint8_t playable;\n\tif (len < 12)\n\t\treturn NULL;\n\tuid = get_be64(&operands[0]);\n\ttype = operands[8];\n\tplayable = operands[9];\n\tnamelen = MIN(get_be16(&operands[12]), sizeof(name) - 1);\n\tif (namelen > 0) {\n\t\tmemcpy(name, &operands[14], namelen);\n\t\tname[namelen] = '\\0';\n\t}\n\titem = media_player_create_folder(mp, name, type, uid);\n\tif (!item)\n\t\treturn NULL;\n\tmedia_item_set_playable(item, playable & 0x01);\n\treturn item;\n}", "target": 0}
{"code": "status_t MPEG4Extractor::parseAC3SpecificBox(\n off64_t offset, uint16_t sampleRate) {\n uint32_t size;\n const uint32_t kAC3SpecificBoxSize = 11;\n if (!mDataSource->getUInt32(offset, &size) || size < kAC3SpecificBoxSize) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 block: cannot read specific box size\");\n return ERROR_MALFORMED;\n }\n    offset += 4;\n uint32_t type;\n if (!mDataSource->getUInt32(offset, &type) || type != FOURCC('d', 'a', 'c', '3')) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 specific block: header not dac3\");\n return ERROR_MALFORMED;\n }\n    offset += 4;\n const uint32_t kAC3SpecificBoxPayloadSize = 3;\n uint8_t chunk[kAC3SpecificBoxPayloadSize];\n if (mDataSource->readAt(offset, chunk, sizeof(chunk)) != sizeof(chunk)) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 specific block: bitstream fields\");\n return ERROR_MALFORMED;\n }\n ABitReader br(chunk, sizeof(chunk));\n static const unsigned channelCountTable[] = {2, 1, 2, 3, 3, 4, 4, 5};\n static const unsigned sampleRateTable[] = {48000, 44100, 32000};\n unsigned fscod = br.getBits(2);\n if (fscod == 3) {\n        ALOGE(\"Incorrect fscod (3) in AC3 header\");\n return ERROR_MALFORMED;\n }\n unsigned boxSampleRate = sampleRateTable[fscod];\n if (boxSampleRate != sampleRate) {\n        ALOGE(\"sample rate mismatch: boxSampleRate = %d, sampleRate = %d\",\n            boxSampleRate, sampleRate);\n return ERROR_MALFORMED;\n }\n unsigned bsid = br.getBits(5);\n if (bsid > 8) {\n        ALOGW(\"Incorrect bsid in AC3 header. Possibly E-AC-3?\");\n return ERROR_MALFORMED;\n }\n unsigned bsmod __unused = br.getBits(3);\n unsigned acmod = br.getBits(3);\n unsigned lfeon = br.getBits(1);\n unsigned channelCount = channelCountTable[acmod] + lfeon;\n if (mLastTrack == NULL) {\n return ERROR_MALFORMED;\n }\n    mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AC3);\n    mLastTrack->meta->setInt32(kKeyChannelCount, channelCount);\n    mLastTrack->meta->setInt32(kKeySampleRate, sampleRate);\n return OK;\n}", "target": 0}
{"code": "polkit_system_bus_name_get_creds_sync (PolkitSystemBusName           *system_bus_name,\n\t\t\t\t       guint32                       *out_uid,\n\t\t\t\t       guint32                       *out_pid,\n\t\t\t\t       GCancellable                  *cancellable,\n\t\t\t\t       GError                       **error)\n{\n  gboolean ret = FALSE;\n  AsyncGetBusNameCredsData data = { 0, };\n  GDBusConnection *connection = NULL;\n  GMainContext *tmp_context = NULL;\n  connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, cancellable, error);\n  if (connection == NULL)\n    goto out;\n  data.error = error;\n  tmp_context = g_main_context_new ();\n  g_main_context_push_thread_default (tmp_context);\n  g_dbus_connection_call (connection,\n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"/org/freedesktop/DBus\",      \n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"GetConnectionUnixUser\",      \n\t\t\t  g_variant_new (\"(s)\", system_bus_name->name),\n\t\t\t  G_VARIANT_TYPE (\"(u)\"),\n\t\t\t  G_DBUS_CALL_FLAGS_NONE,\n\t\t\t  -1,\n\t\t\t  cancellable,\n\t\t\t  on_retrieved_unix_uid_pid,\n\t\t\t  &data);\n  g_dbus_connection_call (connection,\n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"/org/freedesktop/DBus\",      \n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"GetConnectionUnixProcessID\", \n\t\t\t  g_variant_new (\"(s)\", system_bus_name->name),\n\t\t\t  G_VARIANT_TYPE (\"(u)\"),\n\t\t\t  G_DBUS_CALL_FLAGS_NONE,\n\t\t\t  -1,\n\t\t\t  cancellable,\n\t\t\t  on_retrieved_unix_uid_pid,\n\t\t\t  &data);\n  while (!((data.retrieved_uid && data.retrieved_pid) || data.caught_error))\n    g_main_context_iteration (tmp_context, TRUE);\n  if (out_uid)\n    *out_uid = data.uid;\n  if (out_pid)\n    *out_pid = data.pid;\n  ret = TRUE;\n out:\n  if (tmp_context)\n    {\n      g_main_context_pop_thread_default (tmp_context);\n      g_main_context_unref (tmp_context);\n    }\n  if (connection != NULL)\n    g_object_unref (connection);\n  return ret;\n}", "target": 1}
{"code": "uint64_t HeaderMapImpl::byteSize() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 1}
{"code": "compat_sys_writev(unsigned long fd, const struct compat_iovec __user *vec, unsigned long vlen)\n{\n\tstruct file *file;\n\tssize_t ret = -EBADF;\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (!file->f_op || (!file->f_op->aio_write && !file->f_op->write))\n\t\tgoto out;\n\tret = compat_do_readv_writev(WRITE, file, vec, vlen, &file->f_pos);\nout:\n\tfput(file);\n\treturn ret;\n}", "target": 0}
{"code": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}", "target": 1}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 1}
{"code": "static int _strlen_check(int linenumber, char *buf, size_t len)\n{\n  size_t buflen = strlen(buf);\n  if(len != buflen) {\n    printf(\"sprintf strlen:%d failed:\\nwe '%d'\\nsystem: '%d'\\n\",\n           linenumber, buflen, len);\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "pci_emul_add_msicap(struct pci_vdev *dev, int msgnum)\n{\n\tstruct msicap msicap;\n\tpci_populate_msicap(&msicap, msgnum, 0);\n\treturn pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));\n}", "target": 1}
{"code": "int rtnl_send_check(struct rtnl_handle *rth, const void *buf, int len)\n{\n\tstruct nlmsghdr *h;\n\tint status;\n\tchar resp[1024];\n\tstatus = send(rth->fd, buf, len, 0);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = recv(rth->fd, resp, sizeof(resp), MSG_DONTWAIT|MSG_PEEK);\n\tif (status < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\tfor (h = (struct nlmsghdr *)resp; NLMSG_OK(h, status);\n\t     h = NLMSG_NEXT(h, status)) {\n\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\tstruct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(h);\n\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr)))\n\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\telse\n\t\t\t\terrno = -err->error;\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}", "target": 1}
{"code": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\t\tbase_name = _g_path_get_relative_basename ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\tg_file_query_info_async (destination,\n\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t odata);\n\t\tg_object_unref (destination);\n\t\treturn;\n\t}\n\tif (odata->edata->file_list != NULL) {\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\tg_free (odata);\n}", "target": 1}
{"code": "int STDCALL mysql_server_init(int argc __attribute__((unused)),\n\t\t\t      char **argv __attribute__((unused)),\n\t\t\t      char **groups __attribute__((unused)))\n{\n  int result= 0;\n  if (!mysql_client_init)\n  {\n    mysql_client_init=1;\n    org_my_init_done=my_init_done;\n    if (my_init())\t\t\t\t\n      return 1;\n    init_client_errs();\n    if (mysql_client_plugin_init())\n      return 1;\n    if (!mysql_port)\n    {\n      char *env;\n      struct servent *serv_ptr __attribute__((unused));\n      mysql_port = MYSQL_PORT;\n#if MYSQL_PORT_DEFAULT == 0\n      if ((serv_ptr= getservbyname(\"mysql\", \"tcp\")))\n        mysql_port= (uint) ntohs((ushort) serv_ptr->s_port);\n#endif\n      if ((env= getenv(\"MYSQL_TCP_PORT\")))\n        mysql_port=(uint) atoi(env);\n    }\n    if (!mysql_unix_port)\n    {\n      char *env;\n#ifdef __WIN__\n      mysql_unix_port = (char*) MYSQL_NAMEDPIPE;\n#else\n      mysql_unix_port = (char*) MYSQL_UNIX_ADDR;\n#endif\n      if ((env = getenv(\"MYSQL_UNIX_PORT\")))\n\tmysql_unix_port = env;\n    }\n    mysql_debug(NullS);\n#if defined(SIGPIPE) && !defined(__WIN__)\n    (void) signal(SIGPIPE, SIG_IGN);\n#endif\n#ifdef EMBEDDED_LIBRARY\n    if (argc > -1)\n       result= init_embedded_server(argc, argv, groups);\n#endif\n  }\n  else\n    result= (int)my_thread_init();         \n  return result;\n}", "target": 0}
{"code": "static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                return status;\n            }\n            else\n            {\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                return func(stream, iter->pos, pItem);\n            }\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}", "target": 1}
{"code": "FileInformation ImageReadJPEGInfo( String const& filename ) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}", "target": 1}
{"code": "init_line_list(line_list *ll, gs_memory_t * mem)\n{\n    ll->memory = mem;\n    ll->active_area = 0;\n    ll->next_active = ll->local_active;\n    ll->limit = ll->next_active + MAX_LOCAL_ACTIVE;\n    ll->close_count = 0;\n    ll->y_list = 0;\n    ll->y_line = 0;\n    ll->h_list0 = ll->h_list1 = 0;\n    ll->x_head.prev = NULL;\n    ll->x_head.start.x = 0;\n    ll->x_head.start.y = 0;\n    ll->x_head.end.x = 0;\n    ll->x_head.end.y = 0;\n    INCR(fill);\n}", "target": 0}
{"code": "chop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n}", "target": 0}
{"code": "int rm_rf_children(\n                int fd,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n        _cleanup_closedir_ DIR *d = NULL;\n        int ret = 0, r;\n        assert(fd >= 0);\n        d = fdopendir(fd);\n        if (!d) {\n                safe_close(fd);\n                return -errno;\n        }\n        if (!(flags & REMOVE_PHYSICAL)) {\n                struct statfs sfs;\n                if (fstatfs(dirfd(d), &sfs) < 0)\n                        return -errno;\n                if (is_physical_fs(&sfs)) {\n                        _cleanup_free_ char *path = NULL;\n                        (void) fd_get_path(fd, &path);\n                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n                                               strna(path));\n                }\n        }\n        FOREACH_DIRENT_ALL(de, d, return -errno) {\n                int is_dir;\n                if (dot_or_dot_dot(de->d_name))\n                        continue;\n                is_dir =\n                        de->d_type == DT_UNKNOWN ? -1 :\n                        de->d_type == DT_DIR;\n                r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);\n                if (r < 0 && r != -ENOENT && ret == 0)\n                        ret = r;\n        }\n        if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)\n                ret = -errno;\n        return ret;\n}", "target": 1}
{"code": "  base::WeakPtr<Task> GetWeakPtr() { return weak_factory_.GetWeakPtr(); }", "target": 0}
{"code": "kvm_pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,\n\t\t      bool *writable)\n{\n\treturn __gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn, false, NULL,\n\t\t\t\t    write_fault, writable);\n}", "target": 0}
{"code": "gss_wrap_iov (minor_status,\n              context_handle,\n              conf_req_flag,\n              qop_req,\n              conf_state,\n              iov,\n              iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_wrap_iov) {\n\t    status = mech->gss_wrap_iov(\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx->internal_ctx_id,\n\t\t\t\t\tconf_req_flag,\n\t\t\t\t\tqop_req,\n\t\t\t\t\tconf_state,\n\t\t\t\t\tiov,\n\t\t\t\t\tiov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)\n{\n\treturn map_id_up(&targ->uid_map, __kuid_val(kuid));\n}", "target": 0}
{"code": "static void alloc_stmt_fields(MYSQL_STMT *stmt)\n{\n  MYSQL_FIELD *fields, *field, *end;\n  MEM_ROOT *fields_mem_root= &stmt->extension->fields_mem_root;\n  MYSQL *mysql= stmt->mysql;\n  DBUG_ASSERT(stmt->field_count);\n  free_root(fields_mem_root, MYF(0));\n  if (!(stmt->fields= (MYSQL_FIELD *) alloc_root(fields_mem_root,\n\t\t\t\t\t\t sizeof(MYSQL_FIELD) *\n\t\t\t\t\t\t stmt->field_count)) ||\n      !(stmt->bind= (MYSQL_BIND *) alloc_root(fields_mem_root,\n\t\t\t\t\t      sizeof(MYSQL_BIND) *\n\t\t\t\t\t      stmt->field_count)))\n  {\n    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);\n    return;\n  }\n  for (fields= mysql->fields, end= fields+stmt->field_count,\n\t field= stmt->fields;\n       field && fields < end; fields++, field++)\n  {\n    *field= *fields; \n    field->catalog=   strmake_root(fields_mem_root,\n                                   fields->catalog,\n                                   fields->catalog_length);\n    field->db=        strmake_root(fields_mem_root,\n                                   fields->db,\n                                   fields->db_length);\n    field->table=     strmake_root(fields_mem_root,\n                                   fields->table,\n                                   fields->table_length);\n    field->org_table= strmake_root(fields_mem_root,\n                                   fields->org_table,\n                                   fields->org_table_length);\n    field->name=      strmake_root(fields_mem_root,\n                                   fields->name,\n                                   fields->name_length);\n    field->org_name=  strmake_root(fields_mem_root,\n                                   fields->org_name,\n                                   fields->org_name_length);\n    if (fields->def)\n    {\n      field->def= strmake_root(fields_mem_root,\n                               fields->def,\n                               fields->def_length);\n      field->def_length= fields->def_length;\n    }\n    else\n    {\n      field->def= NULL;\n      field->def_length= 0;\n    }\n    field->extension= 0; \n    field->max_length= 0; \n  }\n}", "target": 0}
{"code": "static void smp_update_key_mask(tSMP_CB* p_cb, uint8_t key_type, bool recv) {\n  SMP_TRACE_DEBUG(\n \"%s before update role=%d recv=%d local_i_key = %02x, local_r_key = %02x\",\n      __func__, p_cb->role, recv, p_cb->local_i_key, p_cb->local_r_key);\n if (((p_cb->le_secure_connections_mode_is_used) || (p_cb->smp_over_br)) &&\n ((key_type == SMP_SEC_KEY_TYPE_ENC) ||\n (key_type == SMP_SEC_KEY_TYPE_LK))) {\n    p_cb->local_i_key &= ~key_type;\n    p_cb->local_r_key &= ~key_type;\n } else if (p_cb->role == HCI_ROLE_SLAVE) {\n if (recv)\n      p_cb->local_i_key &= ~key_type;\n else\n      p_cb->local_r_key &= ~key_type;\n } else {\n if (recv)\n      p_cb->local_r_key &= ~key_type;\n else\n      p_cb->local_i_key &= ~key_type;\n }\n  SMP_TRACE_DEBUG(\"updated local_i_key = %02x, local_r_key = %02x\",\n                  p_cb->local_i_key, p_cb->local_r_key);\n}", "target": 0}
{"code": "GF_Err akey_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeKeyInfoBox *ptr = (GF_AdobeKeyInfoBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->params, &pos);\n    return GF_OK;\n}", "target": 0}
{"code": "void EditorClientBlackBerry::enableSpellChecking(bool enable)\n{\n    m_spellCheckState = enable ? SpellCheckDefault : SpellCheckOff;\n}", "target": 0}
{"code": "static void *seq_buf_alloc(unsigned long size)\n{\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}", "target": 1}
{"code": "static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,\n\t\t\t unsigned long fh, u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(tp->q)->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tNLA_PUT_STRING(skb, TCA_KIND, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, BasicSkipNoIndex) {\n    addIndex(BSON(\"a\" << 1));\n    runQuerySkipNToReturn(BSON(\"x\" << 5), 3, 0);\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\"{skip: {n: 3, node: {cscan: {dir: 1, filter: {x: 5}}}}}\");\n}", "target": 0}
{"code": "static pid_t get_task_reaper_pid(pid_t task)\n{\n\tint sock[2];\n\tpid_t pid;\n\tpid_t ret = -1;\n\tchar v = '0';\n\tstruct ucred cred;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\treturn -1;\n\t}\n\tpid = fork();\n\tif (pid < 0)\n\t\tgoto out;\n\tif (!pid) {\n\t\tclose(sock[1]);\n\t\twrite_task_init_pid_exit(sock[0], task);\n\t}\n\tif (!recv_creds(sock[1], &cred, &v))\n\t\tgoto out;\n\tret = cred.pid;\nout:\n\tclose(sock[0]);\n\tclose(sock[1]);\n\treturn ret;\n}", "target": 0}
{"code": "static void sigchld_reaper(void) {\n\tWAIT_T waiter;\n\tPID_T pid;\n\tdo {\n\t\tpid = waitpid(-1, &waiter, WNOHANG);\n\t\tswitch (pid) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tDebug(DPROC, (\"[%ld] sigchld...no children\\n\", (long) getpid()))\n\t\t\t\tbreak;\n\t\tcase 0:\n\t\t\tDebug(DPROC, (\"[%ld] sigchld...no dead kids\\n\", (long) getpid()))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tDebug(DPROC,\n\t\t\t\t(\"[%ld] sigchld...pid #%ld died, stat=%d\\n\",\n\t\t\t\t\t(long) getpid(), (long) pid, WEXITSTATUS(waiter)))\n\t\t\t\tbreak;\n\t\t}\n\t} while (pid > 0);\n}", "target": 0}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "static int cma_addr_cmp(const struct sockaddr *src, const struct sockaddr *dst)\n{\n\tif (src->sa_family != dst->sa_family)\n\t\treturn -1;\n\tswitch (src->sa_family) {\n\tcase AF_INET:\n\t\treturn ((struct sockaddr_in *)src)->sin_addr.s_addr !=\n\t\t       ((struct sockaddr_in *)dst)->sin_addr.s_addr;\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *src_addr6 = (struct sockaddr_in6 *)src;\n\t\tstruct sockaddr_in6 *dst_addr6 = (struct sockaddr_in6 *)dst;\n\t\tbool link_local;\n\t\tif (ipv6_addr_cmp(&src_addr6->sin6_addr,\n\t\t\t\t\t  &dst_addr6->sin6_addr))\n\t\t\treturn 1;\n\t\tlink_local = ipv6_addr_type(&dst_addr6->sin6_addr) &\n\t\t\t     IPV6_ADDR_LINKLOCAL;\n\t\treturn link_local ? (src_addr6->sin6_scope_id !=\n\t\t\t\t     dst_addr6->sin6_scope_id) :\n\t\t\t\t    0;\n\t}\n\tdefault:\n\t\treturn ib_addr_cmp(&((struct sockaddr_ib *) src)->sib_addr,\n\t\t\t\t   &((struct sockaddr_ib *) dst)->sib_addr);\n\t}\n}", "target": 0}
{"code": "merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JSAMPROW work_ptrs[2];\n  JDIMENSION num_rows;          \n  if (upsample->spare_full) {\n    JDIMENSION size = upsample->out_row_width;\n    if (cinfo->out_color_space == JCS_RGB565)\n      size = cinfo->output_width * 2;\n    jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0, 1,\n                      size);\n    num_rows = 1;\n    upsample->spare_full = FALSE;\n  } else {\n    num_rows = 2;\n    if (num_rows > upsample->rows_to_go)\n      num_rows = upsample->rows_to_go;\n    out_rows_avail -= *out_row_ctr;\n    if (num_rows > out_rows_avail)\n      num_rows = out_rows_avail;\n    work_ptrs[0] = output_buf[*out_row_ctr];\n    if (num_rows > 1) {\n      work_ptrs[1] = output_buf[*out_row_ctr + 1];\n    } else {\n      work_ptrs[1] = upsample->spare_row;\n      upsample->spare_full = TRUE;\n    }\n    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);\n  }\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  if (!upsample->spare_full)\n    (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "void V8Window::namedPropertyGetterCustom(v8::Local<v8::Name> name, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    if (!name->IsString())\n        return;\n    auto nameString = name.As<v8::String>();\n    LocalDOMWindow* window = toLocalDOMWindow(V8Window::toImpl(info.Holder()));\n    if (!window)\n        return;\n    LocalFrame* frame = window->frame();\n    if (!frame)\n        return;\n    AtomicString propName = toCoreAtomicString(nameString);\n    Frame* child = frame->tree().scopedChild(propName);\n    if (child) {\n        v8SetReturnValueFast(info, child->domWindow(), window);\n        return;\n    }\n     if (!info.Holder()->GetRealNamedProperty(nameString).IsEmpty())\n         return;\n    frame = window->frame();\n    if (!frame)\n        return;\n     Document* doc = frame->document();\n    if (doc && doc->isHTMLDocument()) {\n        if (toHTMLDocument(doc)->hasNamedItem(propName) || doc->hasElementWithId(propName)) {\n            RefPtrWillBeRawPtr<HTMLCollection> items = doc->windowNamedItems(propName);\n            if (!items->isEmpty()) {\n                if (items->hasExactlyOneItem()) {\n                    v8SetReturnValueFast(info, items->item(0), window);\n                    return;\n                }\n                v8SetReturnValueFast(info, items.release(), window);\n                return;\n            }\n        }\n    }\n}", "target": 0}
{"code": "static void __spin_time_accum(u64 delta, u32 *array)\n{\n\tunsigned index;\n\tindex = ilog2(delta);\n\tcheck_zero();\n\tif (index < HISTO_BUCKETS)\n\t\tarray[index]++;\n\telse\n\t\tarray[HISTO_BUCKETS]++;\n}", "target": 0}
{"code": "coolkey_get_attribute_data_fixed(CK_ATTRIBUTE_TYPE attr_type, unsigned long fixed_attributes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsc_cardctl_coolkey_attribute_t *attr_out) {\n\tunsigned long cka_id = fixed_attributes & 0xf;\n\tunsigned long cka_class = ((fixed_attributes) >> 4) & 0x7;\n\tunsigned long mask, bit;\n\tif (attr_type == CKA_ID) {\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value= &coolkey_static_cka_id[cka_id];\n\t\treturn SC_SUCCESS;\n\t}\n\tif (attr_type == CKA_CLASS) {\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t\tattr_out->attribute_length = 4;\n\t\tattr_out->attribute_value = coolkey_static_cka_class[cka_class].class_value;\n\t\treturn SC_SUCCESS;\n\t}\n\tmask = coolkey_static_cka_class[cka_class].boolean_mask;\n\tbit = coolkey_get_fixed_boolean_bit(attr_type);\n\tif ((bit & mask) == 0) {\n\t\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n\t}\n\tattr_out->attribute_length = 1;\n\tattr_out->attribute_value = bit & fixed_attributes ? &coolkey_static_true : &coolkey_static_false;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 1}
{"code": "static void cmv_decode_intra(CmvContext * s, AVFrame *frame,\n                             const uint8_t *buf, const uint8_t *buf_end)\n{\n    unsigned char *dst = frame->data[0];\n    int i;\n    for (i=0; i < s->avctx->height && buf_end - buf >= s->avctx->width; i++) {\n        memcpy(dst, buf, s->avctx->width);\n        dst += frame->linesize[0];\n        buf += s->avctx->width;\n    }\n}", "target": 0}
{"code": "TEST(HeaderDataConstructorTest, RegexMatchSpecifier) {\n  const std::string yaml = R\"EOF(\nname: test-header\nregex_match: value\n  )EOF\";\n  HeaderUtility::HeaderData header_data =\n      HeaderUtility::HeaderData(parseHeaderMatcherFromYaml(yaml));\n  EXPECT_EQ(\"test-header\", header_data.name_.get());\n  EXPECT_EQ(HeaderUtility::HeaderMatchType::Regex, header_data.header_match_type_);\n  EXPECT_EQ(\"\", header_data.value_);\n}", "target": 0}
{"code": "int git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_buf tree = GIT_BUF_INIT;\n\tgit_odb *odb;\n\tassert(bld);\n\tgit_vector_sort(&bld->entries);\n\terror = git_buf_grow(&tree, bld->entries.length * 72);\n\tfor (i = 0; i < bld->entries.length && !error; ++i) {\n\t\tgit_tree_entry *entry = git_vector_get(&bld->entries, i);\n\t\tif (entry->removed)\n\t\t\tcontinue;\n\t\tgit_buf_printf(&tree, \"%o \", entry->attr);\n\t\tgit_buf_put(&tree, entry->filename, entry->filename_len + 1);\n\t\tgit_buf_put(&tree, (char *)entry->oid.id, GIT_OID_RAWSZ);\n\t\tif (git_buf_oom(&tree))\n\t\t\terror = -1;\n\t}\n\tif (!error &&\n\t\t!(error = git_repository_odb__weakptr(&odb, repo)))\n\t\terror = git_odb_write(oid, odb, tree.ptr, tree.size, GIT_OBJ_TREE);\n\tgit_buf_free(&tree);\n\treturn error;\n}", "target": 0}
{"code": "static bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SELECTOR_TI_MASK)\t\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) \n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "decode_NXAST_RAW_ENCAP(const struct nx_action_encap *nae,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       struct ofpbuf *out)\n{\n    struct ofpact_encap *encap;\n    const struct ofp_ed_prop_header *ofp_prop;\n    const size_t encap_ofs = out->size;\n    size_t props_len;\n    uint16_t n_props = 0;\n    int err;\n    encap = ofpact_put_ENCAP(out);\n    encap->ofpact.raw = NXAST_RAW_ENCAP;\n    switch (ntohl(nae->new_pkt_type)) {\n    case PT_ETH:\n    case PT_NSH:\n        break;\n    default:\n        return OFPERR_NXBAC_BAD_HEADER_TYPE;\n    }\n    encap->new_pkt_type = nae->new_pkt_type;\n    encap->hdr_size = ntohs(nae->hdr_size);\n    ofp_prop = nae->props;\n    props_len = ntohs(nae->len) - offsetof(struct nx_action_encap, props);\n    n_props = 0;\n    while (props_len > 0) {\n        err = decode_ed_prop(&ofp_prop, out, &props_len);\n        if (err) {\n            return err;\n        }\n        n_props++;\n    }\n    encap = ofpbuf_at_assert(out, encap_ofs, sizeof *encap);\n    encap->n_props = n_props;\n    out->header = &encap->ofpact;\n    ofpact_finish_ENCAP(out, &encap);\n    return 0;\n}", "target": 0}
{"code": "static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)\n{\n\tsize_t offset;\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\toffset = ntlm_av_pair_get_next_offset(pAvPair);\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}", "target": 1}
{"code": "SampleEncrypter::EncryptAudioSample(AP4_DataBuffer& sample, AP4_SampleDescription* sample_description)\n{\n    if (sample.GetDataSize() <= 16) {\n        return AP4_SUCCESS;\n    }\n    if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {\n        AP4_UI08*    data      = sample.UseData();\n        unsigned int data_size = sample.GetDataSize();\n        while (data_size > 4) {\n            unsigned int syncword = (data[0]<<8) | data[1];\n            if (syncword != 0x0b77) {\n                return AP4_ERROR_INVALID_FORMAT; \n            }\n            unsigned int frmsiz = 1+(((data[2]<<8)|(data[3]))&0x7FF);\n            unsigned int frame_size = 2*frmsiz;\n            if (data_size < frame_size) {\n                return AP4_ERROR_INVALID_FORMAT; \n            }\n            if (frame_size > 16) {\n                unsigned int encrypted_block_count = (frame_size-16)/16;\n                AP4_Size encrypted_size = encrypted_block_count*16;\n                m_StreamCipher->SetIV(m_IV);\n                m_StreamCipher->ProcessBuffer(data+16, encrypted_size, data+16, &encrypted_size);\n            }\n            data      += frame_size;\n            data_size -= frame_size;\n        }\n    } else {\n        unsigned int encrypted_block_count = (sample.GetDataSize()-16)/16;\n        AP4_Size encrypted_size = encrypted_block_count*16;\n        m_StreamCipher->SetIV(m_IV);\n        m_StreamCipher->ProcessBuffer(sample.UseData()+16, encrypted_size, sample.UseData()+16, &encrypted_size);\n    }\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}", "target": 1}
{"code": "static Image *DrawCompositeMask(Image *image,const DrawInfo *draw_info,\n  const char *id,const char *mask_path,ExceptionInfo *exception)\n{\n  Image\n    *composite_mask;\n  DrawInfo\n    *clone_info;\n  MagickStatusType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  composite_mask=AcquireImage((const ImageInfo *) NULL);\n  status=SetImageExtent(composite_mask,image->columns,image->rows);\n  if (status == MagickFalse)\n    return(DestroyImage(composite_mask));\n  status=SetImageMask(image,(Image *) NULL);\n  status=QueryColorCompliance(\"#0000\",AllCompliance,\n    &composite_mask->background_color,exception);\n  composite_mask->background_color.opacity=(Quantum) TransparentOpacity;\n  (void) SetImageBackgroundColor(composite_mask);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin mask-path %s\",\n      id);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,mask_path);\n  status=QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  status=QueryColorCompliance(\"#00000000\",AllCompliance,&clone_info->stroke,\n    exception);\n  clone_info->stroke_width=0.0;\n  clone_info->opacity=OpaqueOpacity;\n  status=RenderMVGContent(composite_mask,clone_info,0);\n  clone_info=DestroyDrawInfo(clone_info);\n  status&=SeparateImageChannel(composite_mask,TrueAlphaChannel);\n  status&=NegateImage(composite_mask,MagickFalse);\n  if (status == MagickFalse)\n    composite_mask=DestroyImage(composite_mask);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end mask-path\");\n  return(composite_mask);\n}", "target": 0}
{"code": "bool WebContents::SendIPCMessageToFrame(bool internal,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 );\n  return true;\n}", "target": 1}
{"code": "cdf_read_user_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, const char *name, cdf_stream_t *scn)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\tsize_t name_len = strlen(name) + 1;\n\tfor (i = dir->dir_len; i > 0; i--)\n\t\tif (dir->dir_tab[i - 1].d_type == CDF_DIR_TYPE_USER_STREAM &&\n\t\t    cdf_namecmp(name, dir->dir_tab[i - 1].d_name, name_len)\n\t\t    == 0)\n\t\t\tbreak;\n\tif (i == 0) {\n\t\tDPRINTF((\"Cannot find user stream `%s'\\n\", name));\n\t\terrno = ESRCH;\n\t\treturn -1;\n\t}\n\td = &dir->dir_tab[i - 1];\n\treturn cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t    d->d_stream_first_sector, d->d_size, scn);\n}", "target": 0}
{"code": "snmp_oid_copy(uint32_t *dst, uint32_t *src)\n{\n  uint8_t i;\n  i = 0;\n  while(src[i] != ((uint32_t)-1)) {\n    dst[i] = src[i];\n    i++;\n  }\n  dst[i] = src[i];\n}", "target": 1}
{"code": "static int coolkey_read_object(sc_card_t *card, unsigned long object_id, size_t offset,\n\t\t\tu8 *out_buf, size_t out_len, u8 *nonce, size_t nonce_size)\n{\n\tcoolkey_read_object_param_t params;\n\tu8 *out_ptr;\n\tsize_t left = 0;\n\tsize_t len;\n\tint r;\n\tulong2bebytes(&params.object_id[0], object_id);\n\tout_ptr = out_buf;\n\tleft = out_len;\n\tdo {\n\t\tulong2bebytes(&params.offset[0], offset);\n\t\tparams.length = MIN(left, COOLKEY_MAX_CHUNK_SIZE);\n\t\tlen = left;\n\t\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_READ_OBJECT, 0, 0,\n\t\t\t(u8 *)&params, sizeof(params), &out_ptr, &len, nonce, nonce_size);\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((left < len) || (len == 0)) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tout_ptr += len;\n\t\toffset += len;\n\t\tleft -= len;\n\t} while (left != 0);\n\treturn out_len;\nfail:\n\treturn r;\n}", "target": 0}
{"code": "build_model(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; \n  XML_Content *ret;\n  XML_Char *str; \n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n  XML_Content *dest = ret; \n  XML_Content *const destLimit = &ret[dtd->scaffCount];\n  XML_Content *const stackBottom = &ret[dtd->scaffCount];\n  XML_Content *stackTop = stackBottom; \n  str = (XML_Char *)&ret[dtd->scaffCount];\n  (--stackTop)->numchildren = 0;\n  for (; dest < destLimit; dest++) {\n    const int src_node = (int)(stackTop++)->numchildren;\n    dest->type = dtd->scaffold[src_node].type;\n    dest->quant = dtd->scaffold[src_node].quant;\n    if (dest->type == XML_CTYPE_NAME) {\n      const XML_Char *src;\n      dest->name = str;\n      src = dtd->scaffold[src_node].name;\n      for (;;) {\n        *str++ = *src;\n        if (! *src)\n          break;\n        src++;\n      }\n      dest->numchildren = 0;\n      dest->children = NULL;\n    } else {\n      unsigned int i;\n      int cn;\n      dest->name = NULL;\n      dest->numchildren = dtd->scaffold[src_node].childcnt;\n      dest->children = &dest[1];\n      stackTop -= dest->numchildren;\n      for (i = 0, cn = dtd->scaffold[src_node].firstchild;\n           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {\n        (stackTop + i)->numchildren = (unsigned int)cn;\n      }\n    }\n  }\n  return ret;\n}", "target": 0}
{"code": "static void vnc_display_close(VncDisplay *vd)\n{\n    if (!vd) {\n        return;\n    }\n    vd->is_unix = false;\n    if (vd->listener) {\n        qio_net_listener_disconnect(vd->listener);\n        object_unref(OBJECT(vd->listener));\n    }\n    vd->listener = NULL;\n    if (vd->wslistener) {\n        qio_net_listener_disconnect(vd->wslistener);\n        object_unref(OBJECT(vd->wslistener));\n    }\n    vd->wslistener = NULL;\n    vd->auth = VNC_AUTH_INVALID;\n    vd->subauth = VNC_AUTH_INVALID;\n    if (vd->tlscreds) {\n        object_unparent(OBJECT(vd->tlscreds));\n        vd->tlscreds = NULL;\n    }\n    if (vd->tlsauthz) {\n        object_unparent(OBJECT(vd->tlsauthz));\n        vd->tlsauthz = NULL;\n    }\n    g_free(vd->tlsauthzid);\n    vd->tlsauthzid = NULL;\n    if (vd->lock_key_sync) {\n        qemu_remove_led_event_handler(vd->led);\n        vd->led = NULL;\n    }\n#ifdef CONFIG_VNC_SASL\n    if (vd->sasl.authz) {\n        object_unparent(OBJECT(vd->sasl.authz));\n        vd->sasl.authz = NULL;\n    }\n    g_free(vd->sasl.authzid);\n    vd->sasl.authzid = NULL;\n#endif\n}", "target": 0}
{"code": "NTSTATUS ldapsrv_queue_reply(struct ldapsrv_call *call, struct ldapsrv_reply *reply)\n{\n\tNTSTATUS status = ldapsrv_encode(call, reply);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\tif (call->reply_size > call->reply_size + reply->blob.length\n\t    || call->reply_size + reply->blob.length > LDAP_SERVER_MAX_REPLY_SIZE) {\n\t\tDBG_WARNING(\"Refusing to queue LDAP search response size \"\n\t\t\t    \"of more than %zu bytes\\n\",\n\t\t\t    LDAP_SERVER_MAX_REPLY_SIZE);\n\t\tTALLOC_FREE(reply->blob.data);\n\t\treturn NT_STATUS_FILE_TOO_LARGE;\n\t}\n\tcall->reply_size += reply->blob.length;\n\tDLIST_ADD_END(call->replies, reply);\n\treturn status;\n}", "target": 0}
{"code": "enum io_wq_cancel io_wq_cancel_cb(struct io_wq *wq, work_cancel_fn *cancel,\n\t\t\t\t  void *data, bool cancel_all)\n{\n\tstruct io_cb_cancel_data match = {\n\t\t.fn\t\t= cancel,\n\t\t.data\t\t= data,\n\t\t.cancel_all\t= cancel_all,\n\t};\n\tint node;\n\tfor_each_node(node) {\n\t\tstruct io_wqe *wqe = wq->wqes[node];\n\t\tio_wqe_cancel_pending_work(wqe, &match);\n\t\tif (match.nr_pending && !match.cancel_all)\n\t\t\treturn IO_WQ_CANCEL_OK;\n\t}\n\tfor_each_node(node) {\n\t\tstruct io_wqe *wqe = wq->wqes[node];\n\t\tio_wqe_cancel_running_work(wqe, &match);\n\t\tif (match.nr_running && !match.cancel_all)\n\t\t\treturn IO_WQ_CANCEL_RUNNING;\n\t}\n\tif (match.nr_running)\n\t\treturn IO_WQ_CANCEL_RUNNING;\n\tif (match.nr_pending)\n\t\treturn IO_WQ_CANCEL_OK;\n\treturn IO_WQ_CANCEL_NOTFOUND;\n}", "target": 0}
{"code": "sldns_affix_token(sldns_buffer* strbuf, char* token, size_t* token_len,\n\tint* quoted, int* parens, size_t* pre_data_pos,\n\tconst char* delimiters, sldns_rdf_type rdftype, size_t* token_strlen)\n{\n\tsize_t addlen = *token_len - *token_strlen;\n\tsize_t addstrlen = 0;\n\tif(addlen < 1) return 0;\n\ttoken[*token_strlen] = ' ';\n\ttoken[++(*token_strlen)] = 0;\n\taddlen = *token_len - *token_strlen;\n\tif(!sldns_parse_rdf_token(strbuf, token+*token_strlen, addlen, quoted,\n\t\tparens, pre_data_pos, delimiters, rdftype, &addstrlen))\n\t\treturn 0;\n\t(*token_strlen) += addstrlen;\n\treturn 1;\n}", "target": 0}
{"code": " Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)\n {\n     HTMLElement::insertedInto(insertionPoint);\n    return InsertionShouldCallDidNotifySubtreeInsertions;\n}\nvoid HTMLBodyElement::didNotifySubtreeInsertionsToDocument()\n{\n    Element* ownerElement = document().ownerElement();\n    if (!isHTMLFrameElementBase(ownerElement))\n        return;\n    HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);\n    int marginWidth = ownerFrameElement.marginWidth();\n    int marginHeight = ownerFrameElement.marginHeight();\n    if (marginWidth != -1)\n        setIntegralAttribute(marginwidthAttr, marginWidth);\n    if (marginHeight != -1)\n        setIntegralAttribute(marginheightAttr, marginHeight);\n }", "target": 0}
{"code": "hb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->set (*other);\n}", "target": 1}
{"code": "static char *make_filename_safe(const char *filename TSRMLS_DC)\n{\n\tif (*filename && strncmp(filename, \":memory:\", sizeof(\":memory:\")-1)) {\n\t\tchar *fullpath = expand_filepath(filename, NULL TSRMLS_CC);\n\t\tif (!fullpath) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (php_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn fullpath;\n\t}\n\treturn estrdup(filename);\n}", "target": 1}
{"code": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\t\tunsigned int len;\n\t\tswitch (**nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\tlen = ipv6_optlen(exthdr);\n\t\tif (len + offset >= IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\toffset += len;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\tvma->anon_vma = NULL;\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\tif (vma->anon_vma)\n\t\treturn 0;\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\tget_anon_vma(anon_vma->root);\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\treturn 0;\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "SMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct cifs_spnego_msg *msg;\n\tstruct key *spnego_key = NULL;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\tmsg = spnego_key->payload.data[0];\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS,\n\t\t\t  \"bad cifs.upcall version. Expected %d got %d\",\n\t\t\t  CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Kerberos can't allocate (%u bytes) memory\",\n\t\t\tmsg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\tses->Suid = rsp->sync_hdr.SessionId;\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\trc = SMB2_sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tSMB2_sess_free_buffer(sess_data);\n}", "target": 0}
{"code": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\treturn 0;\n}", "target": 1}
{"code": "static dma_addr_t __intel_map_single(struct device *dev, phys_addr_t paddr,\n\t\t\t\t     size_t size, int dir, u64 dma_mask)\n{\n\tstruct dmar_domain *domain;\n\tphys_addr_t start_paddr;\n\tunsigned long iova_pfn;\n\tint prot = 0;\n\tint ret;\n\tstruct intel_iommu *iommu;\n\tunsigned long paddr_pfn = paddr >> PAGE_SHIFT;\n\tBUG_ON(dir == DMA_NONE);\n\tif (iommu_no_mapping(dev))\n\t\treturn paddr;\n\tdomain = get_valid_domain_for_dev(dev);\n\tif (!domain)\n\t\treturn DMA_MAPPING_ERROR;\n\tiommu = domain_get_iommu(domain);\n\tsize = aligned_nrpages(paddr, size);\n\tiova_pfn = intel_alloc_iova(dev, domain, dma_to_mm_pfn(size), dma_mask);\n\tif (!iova_pfn)\n\t\tgoto error;\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL || \\\n\t\t\t!cap_zlr(iommu->cap))\n\t\tprot |= DMA_PTE_READ;\n\tif (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tprot |= DMA_PTE_WRITE;\n\tret = domain_pfn_mapping(domain, mm_to_dma_pfn(iova_pfn),\n\t\t\t\t mm_to_dma_pfn(paddr_pfn), size, prot);\n\tif (ret)\n\t\tgoto error;\n\tstart_paddr = (phys_addr_t)iova_pfn << PAGE_SHIFT;\n\tstart_paddr += paddr & ~PAGE_MASK;\n\treturn start_paddr;\nerror:\n\tif (iova_pfn)\n\t\tfree_iova_fast(&domain->iovad, iova_pfn, dma_to_mm_pfn(size));\n\tdev_err(dev, \"Device request: %zx@%llx dir %d --- failed\\n\",\n\t\tsize, (unsigned long long)paddr, dir);\n\treturn DMA_MAPPING_ERROR;\n}", "target": 0}
{"code": "pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs)\n{\n    uint count = min(max_data,\n                     pcs->status.write_pos - pcs->status.read_pos);\n    if (count)\n        memcpy(data, pcs->status.buffer + pcs->status.read_pos, count);\n    pcs->status.read_pos += count;\n    if (pcs->status.read_pos == pcs->status.write_pos) {\n        gs_free_object(pcs->memory, pcs->status.buffer, \"status buffer\");\n        pcs->status.write_pos = pcs->status.read_pos = 0;\n    }\n    return count;\n}", "target": 1}
{"code": "static void fanout_release_data(struct packet_fanout *f)\n{\n\tswitch (f->type) {\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\t__fanout_set_data_bpf(f, NULL);\n\t};\n}", "target": 0}
{"code": "Opal::Call::~Call ()\n{\n}", "target": 0}
{"code": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "bool PrintWebViewHelper::CopyAndPrint(WebKit::WebFrame* web_frame) {\n  WebPreferences prefs = render_view()->GetWebkitPreferences();\n  prefs.javascript_enabled = false;\n  prefs.java_enabled = false;\n  print_web_view_ = WebView::create(this);\n  prefs.Apply(print_web_view_);\n  print_web_view_->initializeMainFrame(this);\n  print_pages_params_->pages.clear();  \n  std::string html = web_frame->selectionAsMarkup().utf8();\n  std::string url_str = \"data:text/html;charset=utf-8,\";\n  url_str.append(html);\n  GURL url(url_str);\n  print_web_view_->mainFrame()->loadRequest(WebURLRequest(url));\n  return true;\n}", "target": 0}
{"code": "void nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\tlocal_cleanup(local);\n\tnfc_llcp_local_put(local);\n}", "target": 1}
{"code": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n  default:\n    break;\n  }\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}", "target": 1}
{"code": "Document DocumentSourceGroup::makeDocument(const Value& id,\n                                           const Accumulators& accums,\n                                           bool mergeableOutput) {\n    const size_t n = _accumulatedFields.size();\n    MutableDocument out(1 + n);\n    out.addField(\"_id\", expandId(id));\n    for (size_t i = 0; i < n; ++i) {\n        Value val = accums[i]->getValue(mergeableOutput);\n        if (val.missing()) {\n            out.addField(_accumulatedFields[i].fieldName, Value(BSONNULL));\n        } else {\n            out.addField(_accumulatedFields[i].fieldName, std::move(val));\n        }\n    }\n    _stats.totalOutputDataSizeBytes += out.getApproximateSize();\n    return out.freeze();\n}", "target": 0}
{"code": "static int legacy_get_tree(struct fs_context *fc)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\troot = fc->fs_type->mount(fc->fs_type, fc->sb_flags,\n\t\t\t\t      fc->source, ctx->legacy_data);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\tsb = root->d_sb;\n\tBUG_ON(!sb);\n\tfc->root = root;\n\treturn 0;\n}", "target": 0}
{"code": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\tadd_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "init_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    \n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n    alloc_cmdbuff(exmode_active ? 250 : indent + 1);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n    return OK;\n}", "target": 1}
{"code": "c_valid_gregorian_p(int y, int m, int d, int *rm, int *rd)\n{\n    int last;\n    if (m < 0)\n\tm += 13;\n    if (m < 1 || m > 12)\n\treturn 0;\n    last = c_gregorian_last_day_of_month(y, m);\n    if (d < 0)\n\td = last + d + 1;\n    if (d < 1 || d > last)\n\treturn 0;\n    *rm = m;\n    *rd = d;\n    return 1;\n}", "target": 0}
{"code": "bool inode_capable(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n}", "target": 1}
{"code": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}", "target": 1}
{"code": "void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) \n{\n\tconst char *s;\n        while ((s = zend_memrchr(filename, '/', filename_len))) {\n                filename_len = s - filename;\n               if (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n                        break;\n                }\n        }\n}", "target": 1}
{"code": "static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)\n{\n\treturn kstrdup(name, GFP_KERNEL);\n}", "target": 1}
{"code": "    void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Reading TIFF file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"TIFF\");\n        }\n        clearMetadata();\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n        Exiv2::ExifKey            key(\"Exif.Image.InterColorProfile\");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count()*pos->typeSize());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n    } ", "target": 1}
{"code": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}", "target": 1}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 0}
{"code": "static void domain_exit(struct dmar_domain *domain)\n{\n\tstruct page *freelist = NULL;\n\tif (!domain)\n\t\treturn;\n\trcu_read_lock();\n\tdomain_remove_dev_info(domain);\n\trcu_read_unlock();\n\tput_iova_domain(&domain->iovad);\n\tfreelist = domain_unmap(domain, 0, DOMAIN_MAX_PFN(domain->gaw));\n\tdma_free_pagelist(freelist);\n\tfree_domain_mem(domain);\n}", "target": 0}
{"code": "int cg_write(const char *path, const char *buf, size_t size, off_t offset,\n\t     struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *localbuf = NULL;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *f = (struct file_info *)fi->fh;\n\tbool r;\n\tif (f->type != LXC_TYPE_CGFILE) {\n\t\tfprintf(stderr, \"Internal error: directory cache info used in cg_write\\n\");\n\t\treturn -EIO;\n\t}\n\tif (offset)\n\t\treturn 0;\n\tif (!fc)\n\t\treturn -EIO;\n\tlocalbuf = alloca(size+1);\n\tlocalbuf[size] = '\\0';\n\tmemcpy(localbuf, buf, size);\n\tif ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {\n\t\tsize = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\tif (!r)\n\t\tsize = -EINVAL;\nout:\n\tfree_key(k);\n\treturn size;\n}", "target": 1}
{"code": "parse_MULTIPATH(const char *arg, const struct ofpact_parse_params *pp)\n{\n    return multipath_parse(ofpact_put_MULTIPATH(pp->ofpacts), arg);\n}", "target": 0}
{"code": "SHA256_Init(struct SHA256_CTX * ctx)\n{\n  ctx->count[0] = ctx->count[1] = 0;\n  ctx->state[0] = 0x6A09E667;\n  ctx->state[1] = 0xBB67AE85;\n  ctx->state[2] = 0x3C6EF372;\n  ctx->state[3] = 0xA54FF53A;\n  ctx->state[4] = 0x510E527F;\n  ctx->state[5] = 0x9B05688C;\n  ctx->state[6] = 0x1F83D9AB;\n  ctx->state[7] = 0x5BE0CD19;\n}", "target": 1}
{"code": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint err;\n\tstruct iattr newattrs;\n\tif (length < 0)\n\t\treturn -EINVAL;\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\terr = notify_change(dentry, &newattrs);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn err;\n}", "target": 1}
{"code": "BGD_DECLARE(int) gdImageColorReplaceThreshold (gdImagePtr im, int src, int dst, float threshold)\n{\n\tregister int x, y;\n\tint n = 0;\n\tif (src == dst) {\n\t\treturn 0;\n\t}\n#define REPLACING_LOOP(pixel) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (y = im->cy1; y <= im->cy2; y++) {\t\t\t\t\t\t\t\\\n\t\t\tfor (x = im->cx1; x <= im->cx2; x++) {\t\t\t\t\t\t\\\n\t\t\t\tif (gdColorMatch(im, src, pixel(im, x, y), threshold)) { \\\n\t\t\t\t\tgdImageSetPixel(im, x, y, dst);\t\t\t\t\t\t\\\n\t\t\t\t\tn++;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\tif (im->trueColor) {\n\t\tREPLACING_LOOP(gdImageTrueColorPixel);\n\t} else {\n\t\tREPLACING_LOOP(gdImagePalettePixel);\n\t}\n#undef REPLACING_LOOP\n\treturn n;\n}", "target": 0}
{"code": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC)\n{\n\tzend_lex_state original_lex_state;\n\tzend_op_array *op_array = (zend_op_array *) emalloc(sizeof(zend_op_array));\n\tzend_op_array *original_active_op_array = CG(active_op_array);\n\tzend_op_array *retval;\n\tzval tmp;\n\tint compiler_result;\n\tzend_bool original_in_compilation = CG(in_compilation);\n\tif (source_string->value.str.len==0) {\n\t\tefree(op_array);\n\t\treturn NULL;\n\t}\n\tCG(in_compilation) = 1;\n\ttmp = *source_string;\n\tzval_copy_ctor(&tmp);\n\tconvert_to_string(&tmp);\n\tsource_string = &tmp;\n\tzend_save_lexical_state(&original_lex_state TSRMLS_CC);\n\tif (zend_prepare_string_for_scanning(source_string, filename TSRMLS_CC)==FAILURE) {\n\t\tefree(op_array);\n\t\tretval = NULL;\n\t} else {\n\t\tzend_bool orig_interactive = CG(interactive);\n\t\tCG(interactive) = 0;\n\t\tinit_op_array(op_array, ZEND_EVAL_CODE, INITIAL_OP_ARRAY_SIZE TSRMLS_CC);\n\t\tCG(interactive) = orig_interactive;\n\t\tCG(active_op_array) = op_array;\n\t\tzend_stack_push(&CG(context_stack), (void *) &CG(context), sizeof(CG(context)));\n\t\tzend_init_compiler_context(TSRMLS_C);\n\t\tBEGIN(ST_IN_SCRIPTING);\n\t\tcompiler_result = zendparse(TSRMLS_C);\n\t\tif (SCNG(script_filtered)) {\n\t\t\tefree(SCNG(script_filtered));\n\t\t\tSCNG(script_filtered) = NULL;\n\t\t}\n\t\tif (compiler_result==1) {\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tCG(unclean_shutdown)=1;\n\t\t\tdestroy_op_array(op_array TSRMLS_CC);\n\t\t\tefree(op_array);\n\t\t\tretval = NULL;\n\t\t} else {\n\t\t\tzend_do_return(NULL, 0 TSRMLS_CC);\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tpass_two(op_array TSRMLS_CC);\n\t\t\tzend_release_labels(0 TSRMLS_CC);\n\t\t\tretval = op_array;\n\t\t}\n\t}\n\tzend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n\tzval_dtor(&tmp);\n\tCG(in_compilation) = original_in_compilation;\n\treturn retval;\n}", "target": 1}
{"code": "static int evdev_revoke(struct evdev *evdev, struct evdev_client *client,\n\t\t\tstruct file *file)\n{\n\tclient->revoked = true;\n\tevdev_ungrab(evdev, client);\n\tinput_flush_device(&evdev->handle, file);\n\twake_up_interruptible(&evdev->wait);\n\treturn 0;\n}", "target": 0}
{"code": "int __ref online_pages(unsigned long pfn, unsigned long nr_pages)\n{\n\tunsigned long onlined_pages = 0;\n\tstruct zone *zone;\n\tint need_zonelists_rebuild = 0;\n\tint nid;\n\tint ret;\n\tstruct memory_notify arg;\n\tlock_memory_hotplug();\n\targ.start_pfn = pfn;\n\targ.nr_pages = nr_pages;\n\targ.status_change_nid = -1;\n\tnid = page_to_nid(pfn_to_page(pfn));\n\tif (node_present_pages(nid) == 0)\n\t\targ.status_change_nid = nid;\n\tret = memory_notify(MEM_GOING_ONLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone = page_zone(pfn_to_page(pfn));\n\tmutex_lock(&zonelists_mutex);\n\tif (!populated_zone(zone))\n\t\tneed_zonelists_rebuild = 1;\n\tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\n\t\tonline_pages_range);\n\tif (ret) {\n\t\tmutex_unlock(&zonelists_mutex);\n\t\tprintk(KERN_DEBUG \"online_pages [mem %#010llx-%#010llx] failed\\n\",\n\t\t       (unsigned long long) pfn << PAGE_SHIFT,\n\t\t       (((unsigned long long) pfn + nr_pages)\n\t\t\t    << PAGE_SHIFT) - 1);\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone->present_pages += onlined_pages;\n\tzone->zone_pgdat->node_present_pages += onlined_pages;\n\tif (need_zonelists_rebuild)\n\t\tbuild_all_zonelists(NULL, zone);\n\telse\n\t\tzone_pcp_update(zone);\n\tmutex_unlock(&zonelists_mutex);\n\tinit_per_zone_wmark_min();\n\tif (onlined_pages) {\n\t\tkswapd_run(zone_to_nid(zone));\n\t\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);\n\t}\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\tif (onlined_pages)\n\t\tmemory_notify(MEM_ONLINE, &arg);\n\tunlock_memory_hotplug();\n\treturn 0;\n}", "target": 1}
{"code": "otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)\n{\n    otError error = OT_ERROR_NO_BUFS;\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n    VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);\n    RemoveJoiner(aEui64, 0); \n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (joiner->mValid)\n        {\n            continue;\n        }\n        if (aEui64 != NULL)\n        {\n            joiner->mEui64 = *aEui64;\n            joiner->mAny   = false;\n        }\n        else\n        {\n            joiner->mAny = true;\n        }\n        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));\n        joiner->mValid          = true;\n        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);\n        UpdateJoinerExpirationTimer();\n        SendCommissionerSet();\n        otLogInfoMeshCoP(\"Added Joiner (%s, %s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\", aPskd);\n        ExitNow(error = OT_ERROR_NONE);\n    }\nexit:\n    return error;\n}", "target": 1}
{"code": "void TightDecoder::FilterGradient(const rdr::U8* inbuf,\n                                  const PixelFormat& pf, PIXEL_T* outbuf,\n                                  int stride, const Rect& r)\n{\n  int x, y, c;\n  static rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  static rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);\n    for (c = 0; c < 3; c++)\n      pix[c] += prevRow[c];\n    memcpy(thisRow, pix, sizeof(pix));\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 255) {\n          est[c] = 255;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n      }\n      pf.rgbFromBuffer(pix, &inbuf[y*rectWidth+x], 1);\n      for (c = 0; c < 3; c++)\n        pix[c] += est[c];\n      memcpy(&thisRow[x*3], pix, sizeof(pix));\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 1}
{"code": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}", "target": 1}
{"code": "vhost_user_set_owner(struct virtio_net **pdev __rte_unused,\n\t\t\tstruct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tif (validate_msg_fds(msg, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "sec_connect(char *server, char *username, char *domain, char *password, RD_BOOL reconnect)\n{\n\tuint32 selected_proto;\n\tstruct stream mcs_data;\n\tif (!mcs_connect_start(server, username, domain, password, reconnect, &selected_proto))\n\t\treturn False;\n\tmcs_data.size = 512;\n\tmcs_data.p = mcs_data.data = (uint8 *) xmalloc(mcs_data.size);\n\tsec_out_mcs_data(&mcs_data, selected_proto);\n\tif (!mcs_connect_finalize(&mcs_data))\n\t\treturn False;\n\tif (g_encryption)\n\t\tsec_establish_key();\n\txfree(mcs_data.data);\n\treturn True;\n}", "target": 0}
{"code": "static INLINE RECTANGLE_16* region16_rects_noconst(REGION16* region)\n{\n\tREGION16_DATA* data;\n\tdata = region->data;\n\tif (!data)\n\t\treturn NULL;\n\treturn (RECTANGLE_16*)(&data[1]);\n}", "target": 0}
{"code": "static bool allowed_problem_dir(const char *dir_name)\n{\n#if 0\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0\n     || (dir_name[len] != '/' && dir_name[len] != '\\0')\n     || strstr(dir_name + len, \"/.\")\n    ) {\n        return false;\n    }\n#endif\n    return true;\n}", "target": 1}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4009 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n    ld->bytes_left = ld->buffer_size - words*4;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n    ld->error = 0;\n}", "target": 1}
{"code": "static struct rt6_info *rt6_multipath_select(struct rt6_info *match,\n\t\t\t\t\t     struct flowi6 *fl6)\n{\n\tstruct rt6_info *sibling, *next_sibling;\n\tint route_choosen;\n\troute_choosen = rt6_info_hash_nhsfn(match->rt6i_nsiblings + 1, fl6);\n\tif (route_choosen)\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t&match->rt6i_siblings, rt6i_siblings) {\n\t\t\troute_choosen--;\n\t\t\tif (route_choosen == 0) {\n\t\t\t\tmatch = sibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\treturn match;\n}", "target": 0}
{"code": "void RenderThreadImpl::Shutdown() {\n  FOR_EACH_OBSERVER(\n      RenderProcessObserver, observers_, OnRenderProcessShutdown());\n  ChildThread::Shutdown();\n  if (memory_observer_) {\n    message_loop()->RemoveTaskObserver(memory_observer_.get());\n    memory_observer_.reset();\n  }\n  if (webkit_platform_support_) {\n    WebView::willEnterModalLoop();\n    webkit_platform_support_->web_database_observer_impl()->\n        WaitForAllDatabasesToClose();\n    WebView::didExitModalLoop();\n  }\n  if (devtools_agent_message_filter_.get()) {\n    RemoveFilter(devtools_agent_message_filter_.get());\n    devtools_agent_message_filter_ = NULL;\n  }\n  RemoveFilter(audio_input_message_filter_.get());\n  audio_input_message_filter_ = NULL;\n#if defined(ENABLE_WEBRTC)\n  RTCPeerConnectionHandler::DestructAllHandlers();\n  peer_connection_factory_.reset();\n#endif\n  RemoveFilter(vc_manager_->video_capture_message_filter());\n  vc_manager_.reset();\n  RemoveFilter(db_message_filter_.get());\n  db_message_filter_ = NULL;\n  if (file_thread_)\n    file_thread_->Stop();\n  if (compositor_output_surface_filter_.get()) {\n    RemoveFilter(compositor_output_surface_filter_.get());\n    compositor_output_surface_filter_ = NULL;\n  }\n  media_thread_.reset();\n  RemoveFilter(audio_message_filter_.get());\n  audio_message_filter_ = NULL;\n  compositor_thread_.reset();\n  input_handler_manager_.reset();\n  if (input_event_filter_.get()) {\n    RemoveFilter(input_event_filter_.get());\n    input_event_filter_ = NULL;\n  }\n  embedded_worker_dispatcher_.reset();\n  main_thread_indexed_db_dispatcher_.reset();\n  main_thread_compositor_task_runner_ = NULL;\n  main_message_loop_.reset();\n  if (webkit_platform_support_)\n    blink::shutdown();\n  lazy_tls.Pointer()->Set(NULL);\n#if defined(OS_WIN)\n  NPChannelBase::CleanupChannels();\n#endif\n}", "target": 0}
{"code": "static void nft_objref_map_activate(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "ffi_prep_closure_loc (ffi_closure *closure,\n                      ffi_cif* cif,\n                      void (*fun)(ffi_cif*,void*,void**,void*),\n                      void *user_data,\n                      void *codeloc)\n{\n  if (cif->abi != FFI_SYSV)\n    return FFI_BAD_ABI;\n  void (*start)(void);\n  if (cif->flags & AARCH64_FLAG_ARG_V)\n    start = ffi_closure_SYSV_V;\n  else\n    start = ffi_closure_SYSV;\n#if FFI_EXEC_TRAMPOLINE_TABLE\n#ifdef __MACH__\n  void **config = (void **)((uint8_t *)codeloc - PAGE_MAX_SIZE);\n  config[0] = closure;\n  config[1] = start;\n#endif\n#else\n  static const unsigned char trampoline[16] = {\n    0x90, 0x00, 0x00, 0x58,\t\n    0xf1, 0xff, 0xff, 0x10,\t\n    0x00, 0x02, 0x1f, 0xd6\t\n  };\n  char *tramp = closure->tramp;\n  memcpy (tramp, trampoline, sizeof(trampoline));\n  *(UINT64 *)(tramp + 16) = (uintptr_t)start;\n  ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);\n#endif\n  closure->cif = cif;\n  closure->fun = fun;\n  closure->user_data = user_data;\n  return FFI_OK;\n}", "target": 1}
{"code": "void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    \n    }\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n            gnrc_sixlowpan_frag_fb_t *fb = ctx;\n            if (fb->pkt == pkt) {\n                fb->pkt = NULL;\n            }\n        }\n        gnrc_pktbuf_release(pkt);\n    }\n}", "target": 0}
{"code": "void WriteValue(Message* m, const Value* value, int recursion) {\n  bool result;\n  if (recursion > kMaxRecursionDepth) {\n    LOG(WARNING) << \"Max recursion depth hit in WriteValue.\";\n    return;\n  }\n  m->WriteInt(value->GetType());\n  switch (value->GetType()) {\n    case Value::TYPE_NULL:\n    break;\n    case Value::TYPE_BOOLEAN: {\n      bool val;\n      result = value->GetAsBoolean(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_INTEGER: {\n      int val;\n      result = value->GetAsInteger(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_DOUBLE: {\n      double val;\n      result = value->GetAsDouble(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_STRING: {\n      std::string val;\n      result = value->GetAsString(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_BINARY: {\n      const base::BinaryValue* binary =\n          static_cast<const base::BinaryValue*>(value);\n      m->WriteData(binary->GetBuffer(), static_cast<int>(binary->GetSize()));\n      break;\n    }\n    case Value::TYPE_DICTIONARY: {\n      const DictionaryValue* dict = static_cast<const DictionaryValue*>(value);\n      WriteParam(m, static_cast<int>(dict->size()));\n      for (DictionaryValue::key_iterator it = dict->begin_keys();\n           it != dict->end_keys(); ++it) {\n        const Value* subval;\n        if (dict->GetWithoutPathExpansion(*it, &subval)) {\n          WriteParam(m, *it);\n          WriteValue(m, subval, recursion + 1);\n        } else {\n          NOTREACHED() << \"DictionaryValue iterators are filthy liars.\";\n        }\n      }\n      break;\n    }\n    case Value::TYPE_LIST: {\n      const ListValue* list = static_cast<const ListValue*>(value);\n      WriteParam(m, static_cast<int>(list->GetSize()));\n      for (size_t i = 0; i < list->GetSize(); ++i) {\n        const Value* subval;\n        if (list->Get(i, &subval)) {\n          WriteValue(m, subval, recursion + 1);\n        } else {\n          NOTREACHED() << \"ListValue::GetSize is a filthy liar.\";\n        }\n      }\n      break;\n    }\n  }\n}", "target": 0}
{"code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[12];\n\tmemcpy(hash, saddr, 16);\n\thash[4] = (__force u32)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\treturn twothirdsMD4Transform((const __u32 *)daddr, hash);\n}", "target": 1}
{"code": "ZEND_API void ZEND_FASTCALL convert_scalar_to_number(zval *op) \n{\n\t_convert_scalar_to_number(op, 1, 0);\n}", "target": 0}
{"code": "xmlParseElementEnd(xmlParserCtxtPtr ctxt) {\n    xmlParserNodeInfo node_info;\n    xmlNodePtr ret = ctxt->node;\n    if (ctxt->nameNr <= 0)\n        return;\n    if (ctxt->sax2) {\n        const xmlChar *prefix = ctxt->pushTab[ctxt->nameNr * 3 - 3];\n        const xmlChar *URI = ctxt->pushTab[ctxt->nameNr * 3 - 2];\n        int nsNr = (ptrdiff_t) ctxt->pushTab[ctxt->nameNr * 3 - 1];\n\txmlParseEndTag2(ctxt, prefix, URI, 0, nsNr, 0);\n\tnamePop(ctxt);\n    }\n#ifdef LIBXML_SAX1_ENABLED\n    else\n\txmlParseEndTag1(ctxt, 0);\n#endif \n    if ( ret != NULL && ctxt->record_info ) {\n       node_info.end_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n       node_info.end_line = ctxt->input->line;\n       node_info.node = ret;\n       xmlParserAddNodeInfo(ctxt, &node_info);\n    }\n}", "target": 0}
{"code": "int xt_compat_check_entry_offsets(const void *base,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\tkey_put(ci->ci_keyring_key);\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}", "target": 1}
{"code": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n    VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n    memset(&txcq_descr, 0, sizeof(txcq_descr));\n    txcq_descr.txdIdx = tx_ridx;\n    txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n    txcq_descr.val1 = cpu_to_le32(txcq_descr.val1);\n    txcq_descr.val2 = cpu_to_le32(txcq_descr.val2);\n    vmxnet3_ring_write_curr_cell(d, &s->txq_descr[qidx].comp_ring, &txcq_descr);\n    smp_wmb();\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}", "target": 0}
{"code": "static int check_is_mount_child(void *p)\n{\n\tconst char **a = p;\n\tconst char *last = a[0];\n\tconst char *mnt = a[1];\n\tint res;\n\tconst char *procmounts = \"/proc/mounts\";\n\tint found;\n\tFILE *fp;\n\tstruct mntent *entp;\n\tint count;\n\tres = mount(\"\", \"/\", \"\", MS_PRIVATE | MS_REC, NULL);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to mark mounts private: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn 1;\n\t}\n\tfp = setmntent(procmounts, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname,\n\t\t\tprocmounts, strerror(errno));\n\t\treturn 1;\n\t}\n\tcount = 0;\n\twhile (getmntent(fp) != NULL)\n\t\tcount++;\n\tendmntent(fp);\n\tfp = setmntent(procmounts, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname,\n\t\t\tprocmounts, strerror(errno));\n\t\treturn 1;\n\t}\n\tres = mount(\".\", \"/\", \"\", MS_BIND | MS_REC, NULL);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to bind parent to /: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn 1;\n\t}\n\tfound = 0;\n\twhile ((entp = getmntent(fp)) != NULL) {\n\t\tif (count > 0) {\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (entp->mnt_dir[0] == '/' &&\n\t\t    strcmp(entp->mnt_dir + 1, last) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tendmntent(fp);\n\tif (!found) {\n\t\tfprintf(stderr, \"%s: %s not mounted\\n\", progname, mnt);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "method_invocation_get_uid (GDBusMethodInvocation *context)\n{\n  const gchar *sender;\n  PolkitSubject *busname;\n  PolkitSubject *process;\n  uid_t uid;\n  sender = g_dbus_method_invocation_get_sender (context);\n  busname = polkit_system_bus_name_new (sender);\n  process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (busname), NULL, NULL);\n  uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  g_object_unref (busname);\n  g_object_unref (process);\n  return uid;\n}", "target": 1}
{"code": "static int _FVMenuClose(FontView *fv) {\n    int i;\n    SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;\n    if ( !SFCloseAllInstrs(fv->b.sf) )\nreturn( false );\n    if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {\n    } else if ( warn_script_unsaved && fv->script_unsaved && \n                AskScriptChanged()==2 ) {\n        return false;\n    } else if ( SFAnyChanged(sf) ) {\n\ti = AskChanged(fv->b.sf);\n\tif ( i==2 )\t\nreturn( false );\n\tif ( i==0 && !_FVMenuSave(fv))\t\t\nreturn(false);\n\telse\n\t    SFClearAutoSave(sf);\t\t\n    }\n    _FVCloseWindows(fv);\n    if ( sf->filename!=NULL )\n\tRecentFilesRemember(sf->filename);\n    else if ( sf->origname!=NULL )\n\tRecentFilesRemember(sf->origname);\n    GDrawDestroyWindow(fv->gw);\nreturn( true );\n}", "target": 0}
{"code": "static int io_wqe_worker(void *data)\n{\n\tstruct io_worker *worker = data;\n\tstruct io_wqe_acct *acct = io_wqe_get_acct(worker);\n\tstruct io_wqe *wqe = worker->wqe;\n\tstruct io_wq *wq = wqe->wq;\n\tbool last_timeout = false;\n\tchar buf[TASK_COMM_LEN];\n\tworker->flags |= (IO_WORKER_F_UP | IO_WORKER_F_RUNNING);\n\tsnprintf(buf, sizeof(buf), \"iou-wrk-%d\", wq->task->pid);\n\tset_task_comm(current, buf);\n\twhile (!test_bit(IO_WQ_BIT_EXIT, &wq->state)) {\n\t\tlong ret;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\nloop:\n\t\traw_spin_lock(&wqe->lock);\n\t\tif (io_acct_run_queue(acct)) {\n\t\t\tio_worker_handle_work(worker);\n\t\t\tgoto loop;\n\t\t}\n\t\tif (last_timeout && acct->nr_workers > 1) {\n\t\t\traw_spin_unlock(&wqe->lock);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tlast_timeout = false;\n\t\t__io_worker_idle(wqe, worker);\n\t\traw_spin_unlock(&wqe->lock);\n\t\tif (io_flush_signals())\n\t\t\tcontinue;\n\t\tret = schedule_timeout(WORKER_IDLE_TIMEOUT);\n\t\tif (signal_pending(current)) {\n\t\t\tstruct ksignal ksig;\n\t\t\tif (!get_signal(&ksig))\n\t\t\t\tcontinue;\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tlast_timeout = !ret;\n\t}\n\tif (test_bit(IO_WQ_BIT_EXIT, &wq->state)) {\n\t\traw_spin_lock(&wqe->lock);\n\t\tio_worker_handle_work(worker);\n\t}\n\tio_worker_exit(worker);\n\treturn 0;\n}", "target": 0}
{"code": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}", "target": 1}
{"code": "Status FunctionLibraryDefinition::AddGradientDef(const GradientDef& grad) {\n  mutex_lock l(mu_);\n  bool added;\n  return AddGradientDefHelper(grad, &added);\n}", "target": 0}
{"code": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 1}
{"code": "static void lag_pred_line(LagarithContext *l, uint8_t *buf,\n                          int width, int stride, int line)\n{\n    int L, TL;\n    if (!line) {\n        int i, align_width = (width - 1) & ~31;\n        L = l->dsp.add_hfyu_left_prediction(buf + 1, buf + 1,\n                                            align_width, buf[0]);\n        for (i = align_width + 1; i < width; i++)\n            buf[i] += buf[i - 1];\n    } else {\n        L = buf[width - stride - 1];\n        if (line == 1) {\n            TL = l->avctx->pix_fmt == AV_PIX_FMT_YUV420P ? buf[-stride] : L;\n        } else {\n            TL = buf[width - (2 * stride) - 1];\n        }\n        add_lag_median_prediction(buf, buf - stride, buf,\n                                  width, &L, &TL);\n    }\n}", "target": 0}
{"code": "stmt_read_row_from_cursor(MYSQL_STMT *stmt, unsigned char **row)\n{\n  if (stmt->data_cursor)\n    return stmt_read_row_buffered(stmt, row);\n  if (stmt->server_status & SERVER_STATUS_LAST_ROW_SENT)\n    stmt->server_status &= ~SERVER_STATUS_LAST_ROW_SENT;\n  else\n  {\n    MYSQL *mysql= stmt->mysql;\n    NET *net= &mysql->net;\n    MYSQL_DATA *result= &stmt->result;\n    uchar buff[4  +\n               4 ];\n    free_root(&result->alloc, MYF(MY_KEEP_PREALLOC));\n    result->data= NULL;\n    result->rows= 0;\n    int4store(buff, stmt->stmt_id);\n    int4store(buff + 4, stmt->prefetch_rows); \n    if ((*mysql->methods->advanced_command)(mysql, COM_STMT_FETCH,\n                                            buff, sizeof(buff), (uchar*) 0, 0,\n                                            1, stmt))\n    {\n      if (stmt->mysql)\n        set_stmt_errmsg(stmt, net);\n      return 1;\n    }\n    if ((*mysql->methods->read_rows_from_cursor)(stmt))\n      return 1;\n    stmt->server_status= mysql->server_status;\n    stmt->data_cursor= result->data;\n    return stmt_read_row_buffered(stmt, row);\n  }\n  *row= 0;\n  return MYSQL_NO_DATA;\n}", "target": 0}
{"code": "AP_DECLARE(const char *) ap_context_prefix(request_rec *r)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    if (conf->context_prefix)\n        return conf->context_prefix;\n    else\n        return \"\";\n}", "target": 0}
{"code": "void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\tif (cur_pos < 0) return;\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;", "target": 1}
{"code": " void LayerWebKitThread::setNeedsCommit()\n {\n     if (m_owner)\n        m_owner->notifySyncRequired();\n }", "target": 1}
{"code": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n    memory_region_destroy(&s->mmio);\n}", "target": 1}
{"code": "static inline int prb_curr_blk_in_use(struct kbdq_core *pkc,\n\t\t\t\t      struct block_desc *pbd)\n{\n\treturn TP_STATUS_USER & BLOCK_STATUS(pbd);\n}", "target": 0}
{"code": "FoFiTrueType::FoFiTrueType(char *fileA, int lenA, GBool freeFileDataA, int faceIndexA):\n  FoFiBase(fileA, lenA, freeFileDataA)\n{\n  tables = NULL;\n  nTables = 0;\n  cmaps = NULL;\n  nCmaps = 0;\n  nameToGID = NULL;\n  parsedOk = gFalse;\n  faceIndex = faceIndexA;\n  gsubFeatureTable = 0;\n  gsubLookupList = 0;\n  parse();\n}", "target": 0}
{"code": "void comps_objrtree_unite(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_ObjRTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjRTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL) {\n                    comps_objrtree_set(rt1, pair->key,\n                                      (((COMPS_ObjRTreeData*)it->data)->data));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}", "target": 1}
{"code": "\tvirtual void describe()\n\t{\n\t\tgetDefaultPCMMapping(m_outChunk->f.sampleWidth,\n\t\t\tm_outChunk->f.pcm.slope,\n\t\t\tm_outChunk->f.pcm.intercept,\n\t\t\tm_outChunk->f.pcm.minClip,\n\t\t\tm_outChunk->f.pcm.maxClip);\n\t}", "target": 0}
{"code": "static int core_upgrade_handler(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    const char *upgrade;\n    if (c->master) {\n        return DECLINED;\n    }\n    upgrade = apr_table_get(r->headers_in, \"Upgrade\");\n    if (upgrade && *upgrade) {\n        const char *conn = apr_table_get(r->headers_in, \"Connection\");\n        if (ap_find_token(r->pool, conn, \"upgrade\")) {\n            apr_array_header_t *offers = NULL;\n            const char *err;\n            err = ap_parse_token_list_strict(r->pool, upgrade, &offers, 0);\n            if (err) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02910)\n                              \"parsing Upgrade header: %s\", err);\n                return DECLINED;\n            }\n            if (offers && offers->nelts > 0) {\n                const char *protocol = ap_select_protocol(c, r, NULL, offers);\n                if (protocol && strcmp(protocol, ap_get_protocol(c))) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02909)\n                                  \"Upgrade selects '%s'\", protocol);\n                    apr_table_clear(r->headers_out);\n                    apr_table_setn(r->headers_out, \"Upgrade\", protocol);\n                    apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n                    r->status = HTTP_SWITCHING_PROTOCOLS;\n                    r->status_line = ap_get_status_line(r->status);\n                    ap_send_interim_response(r, 1);\n                    ap_switch_protocol(c, r, r->server, protocol);\n                    c->keepalive = AP_CONN_CLOSE;\n                    return DONE;\n                }\n            }\n        }\n    }\n    else if (!c->keepalives) {\n        const apr_array_header_t *upgrades;\n        ap_get_protocol_upgrades(c, r, NULL, 0, &upgrades);\n        if (upgrades && upgrades->nelts > 0) {\n            char *protocols = apr_array_pstrcat(r->pool, upgrades, ',');\n            apr_table_setn(r->headers_out, \"Upgrade\", protocols);\n            apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n        }\n    }\n    return DECLINED;\n}", "target": 0}
{"code": "bool PluginInfoMessageFilter::OnMessageReceived(const IPC::Message& message,\n                                                bool* message_was_ok) {\n  IPC_BEGIN_MESSAGE_MAP_EX(PluginInfoMessageFilter, message, *message_was_ok)\n    IPC_MESSAGE_HANDLER_DELAY_REPLY(ChromeViewHostMsg_GetPluginInfo,\n                                    OnGetPluginInfo)\n    IPC_MESSAGE_UNHANDLED(return false)\n  IPC_END_MESSAGE_MAP()\n  return true;\n}", "target": 0}
{"code": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}", "target": 1}
{"code": "gopherHTMLFooter(StoreEntry * e)\n{\n    storeAppendPrintf(e, \"<HR noshade size=\\\"1px\\\">\\n\");\n    storeAppendPrintf(e, \"<ADDRESS>\\n\");\n    storeAppendPrintf(e, \"Generated %s by %s (%s)\\n\",\n                      Time::FormatRfc1123(squid_curtime),\n                      getMyHostname(),\n                      visible_appname_string);\n    storeAppendPrintf(e, \"</ADDRESS></BODY></HTML>\\n\");\n}", "target": 1}
{"code": "void disk_part_iter_init(struct disk_part_iter *piter, struct gendisk *disk,\n\t\t\t  unsigned int flags)\n{\n\tstruct disk_part_tbl *ptbl;\n\trcu_read_lock();\n\tptbl = rcu_dereference(disk->part_tbl);\n\tpiter->disk = disk;\n\tpiter->part = NULL;\n\tif (flags & DISK_PITER_REVERSE)\n\t\tpiter->idx = ptbl->len - 1;\n\telse if (flags & (DISK_PITER_INCL_PART0 | DISK_PITER_INCL_EMPTY_PART0))\n\t\tpiter->idx = 0;\n\telse\n\t\tpiter->idx = 1;\n\tpiter->flags = flags;\n\trcu_read_unlock();\n}", "target": 0}
{"code": "list_fields(MYSQL *mysql,const char *db,const char *table,\n\t    const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  ulong UNINIT_VAR(rows);\n  if (mysql_select_db(mysql,db))\n  {\n    fprintf(stderr,\"%s: Cannot connect to db: %s: %s\\n\",my_progname,db,\n\t    mysql_error(mysql));\n    return 1;\n  }\n  if (opt_count)\n  {\n    sprintf(query,\"select count(*) from `%s`\", table);\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot get record count for db: %s, table: %s: %s\\n\",\n              my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    row= mysql_fetch_row(result);\n    rows= (ulong) strtoull(row[0], (char**) 0, 10);\n    mysql_free_result(result);\n  }\n  end=strmov(strmov(strmov(query,\"show  columns from `\"),table),\"`\");\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot list columns in db: %s, table: %s: %s\\n\",\n\t    my_progname,db,table,mysql_error(mysql));\n    return 1;\n  }\n  printf(\"Database: %s  Table: %s\", db, table);\n  if (opt_count)\n    printf(\"  Rows: %lu\", rows);\n  if (wild && wild[0])\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  if (opt_show_keys)\n  {\n    end=strmov(strmov(strmov(query,\"show keys from `\"),table),\"`\");\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot list keys in db: %s, table: %s: %s\\n\",\n\t      my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    if (mysql_num_rows(result))\n    {\n      print_res_header(result);\n      while ((row=mysql_fetch_row(result)))\n\tprint_res_row(result,row);\n      print_res_top(result);\n    }\n    else\n      puts(\"Table has no keys\");\n  }\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->size) return GF_OK;\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;", "target": 1}
{"code": "static CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,\n  const size_t depth,const size_t maximum_colors)\n{\n  CubeInfo\n    *cube_info;\n  double\n    sum,\n    weight;\n  register ssize_t\n    i;\n  size_t\n    length;\n  cube_info=(CubeInfo *) AcquireMagickMemory(sizeof(*cube_info));\n  if (cube_info == (CubeInfo *) NULL)\n    return((CubeInfo *) NULL);\n  (void) memset(cube_info,0,sizeof(*cube_info));\n  cube_info->depth=depth;\n  if (cube_info->depth > MaxTreeDepth)\n    cube_info->depth=MaxTreeDepth;\n  if (cube_info->depth < 2)\n    cube_info->depth=2;\n  cube_info->maximum_colors=maximum_colors;\n  cube_info->root=GetNodeInfo(cube_info,0,0,(NodeInfo *) NULL);\n  if (cube_info->root == (NodeInfo *) NULL)\n    return((CubeInfo *) NULL);\n  cube_info->root->parent=cube_info->root;\n  cube_info->quantize_info=CloneQuantizeInfo(quantize_info);\n  if (cube_info->quantize_info->dither_method == NoDitherMethod)\n    return(cube_info);\n  length=(size_t) (1UL << (4*(8-CacheShift)));\n  cube_info->memory_info=AcquireVirtualMemory(length,sizeof(*cube_info->cache));\n  if (cube_info->memory_info == (MemoryInfo *) NULL)\n    return((CubeInfo *) NULL);\n  cube_info->cache=(ssize_t *) GetVirtualMemoryBlob(cube_info->memory_info);\n  (void) memset(cube_info->cache,(-1),sizeof(*cube_info->cache)*\n    length);\n  weight=1.0;\n  for (i=0; i < ErrorQueueLength; i++)\n  {\n    cube_info->weights[ErrorQueueLength-i-1]=PerceptibleReciprocal(weight);\n    weight*=exp(log(((double) QuantumRange+1.0))/(ErrorQueueLength-1.0));\n  }\n  weight=0.0;\n  for (i=0; i < ErrorQueueLength; i++)\n    weight+=cube_info->weights[i];\n  sum=0.0;\n  for (i=0; i < ErrorQueueLength; i++)\n  {\n    cube_info->weights[i]/=weight;\n    sum+=cube_info->weights[i];\n  }\n  cube_info->weights[0]+=1.0-sum;\n  return(cube_info);\n}", "target": 0}
{"code": "int detach_capi_ctr(struct capi_ctr *ctr)\n{\n\tint err = 0;\n\tmutex_lock(&capi_controller_lock);\n\tctr_down(ctr, CAPI_CTR_DETACHED);\n\tif (capi_controller[ctr->cnr - 1] != ctr) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\tcapi_controller[ctr->cnr - 1] = NULL;\n\tncontrollers--;\n\tif (ctr->procent)\n\t\tremove_proc_entry(ctr->procfn, NULL);\n\tprintk(KERN_NOTICE \"kcapi: controller [%03d]: %s unregistered\\n\",\n\t       ctr->cnr, ctr->name);\nunlock_out:\n\tmutex_unlock(&capi_controller_lock);\n\treturn err;\n}", "target": 1}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = self_in;\n    long long val = self->val;\n    if (big_endian) {\n        byte *b = buf + len;\n        while (b > buf) {\n            *--b = val;\n            val >>= 8;\n        }\n    } else {\n        for (; len > 0; --len) {\n            *buf++ = val;\n            val >>= 8;\n        }\n    }\n}", "target": 1}
{"code": "static struct page *__page_frag_cache_refill(struct page_frag_cache *nc,\n\t\t\t\t\t     gfp_t gfp_mask)\n{\n\tstruct page *page = NULL;\n\tgfp_t gfp = gfp_mask;\n#if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)\n\tgfp_mask |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY |\n\t\t    __GFP_NOMEMALLOC;\n\tpage = alloc_pages_node(NUMA_NO_NODE, gfp_mask,\n\t\t\t\tPAGE_FRAG_CACHE_MAX_ORDER);\n\tnc->size = page ? PAGE_FRAG_CACHE_MAX_SIZE : PAGE_SIZE;\n#endif\n\tif (unlikely(!page))\n\t\tpage = alloc_pages_node(NUMA_NO_NODE, gfp, 0);\n\tnc->va = page ? page_address(page) : NULL;\n\treturn page;\n}", "target": 0}
{"code": "static int rfcomm_sock_debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, rfcomm_sock_debugfs_show, inode->i_private);\n}", "target": 0}
{"code": "void cred_to_ucred(struct pid *pid, const struct cred *cred,\n\t\t   struct ucred *ucred)\n{\n\tucred->pid = pid_vnr(pid);\n\tucred->uid = ucred->gid = -1;\n\tif (cred) {\n\t\tstruct user_namespace *current_ns = current_user_ns();\n\t\tucred->uid = from_kuid(current_ns, cred->euid);\n\t\tucred->gid = from_kgid(current_ns, cred->egid);\n\t}\n}", "target": 0}
{"code": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}", "target": 1}
{"code": "static int io_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 io_info = svm->vmcb->control.exit_info_1; \n\tint size, in, string;\n\tunsigned port;\n\t++svm->vcpu.stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn kvm_fast_pio_out(vcpu, size, port);\n}", "target": 0}
{"code": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "static int qh_help(int sd, char *buf, unsigned int len)\n{\n\tstruct query_handler *qh = NULL;\n\tif (!*buf || !strcmp(buf, \"help\")) {\n\t\tnsock_printf_nul(sd,\n\t\t\t\"  help <name>   show help for handler <name>\\n\"\n\t\t\t\"  help list     list registered handlers\\n\");\n\t\treturn 0;\n\t}\n\tif (!strcmp(buf, \"list\")) {\n\t\tfor (qh = qhandlers; qh != NULL; qh = qh->next_qh) {\n\t\t\tnsock_printf(sd, \"%-10s %s\\n\", qh->name, qh->description ? qh->description : \"(No description available)\");\n\t\t}\n\t\tnsock_printf(sd, \"%c\", 0);\n\t\treturn 0;\n\t}\n\tqh = qh_find_handler(buf);\n\tif (qh == NULL) {\n\t\tnsock_printf_nul(sd, \"No handler named '%s' is registered\\n\", buf);\n\t} else if (qh->handler(sd, \"help\", 4) > 200) {\n\t\tnsock_printf_nul(sd, \"The handler %s doesn't have any help yet.\", buf);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void ConnectDialog::accept() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (bAllowHostLookup && si->qlAddresses.isEmpty()) || si->qsHostname.isEmpty()) {\n\t\tqWarning() << \"Invalid server\";\n\t\treturn;\n\t}\n\tqsPassword = si->qsPassword;\n\tqsServer = si->qsHostname;\n\tusPort = si->usPort;\n\tif (si->qsUsername.isEmpty()) {\n\t\tbool ok;\n\t\tQString defUserName = QInputDialog::getText(this, tr(\"Connecting to %1\").arg(si->qsName), tr(\"Enter username\"), QLineEdit::Normal, g.s.qsUsername, &ok).trimmed();\n\t\tif (! ok)\n\t\t\treturn;\n\t\tg.s.qsUsername = si->qsUsername = defUserName;\n\t}\n\tqsUsername = si->qsUsername;\n\tg.s.qsLastServer = si->qsName;\n\tQDialog::accept();\n}", "target": 0}
{"code": "static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}", "target": 1}
{"code": "readpw(PK11SlotInfo *slot UNUSED,\n       PRBool retry UNUSED,\n       void *arg UNUSED)\n{\n\tstruct termios sio, tio;\n\tchar line[LINE_MAX], *p;\n\tchar *ret;\n\tingress();\n\tmemset(line, '\\0', sizeof (line));\n\tif (tcgetattr(fileno(stdin), &sio) < 0) {\n\t\twarnx(\"Could not read password from standard input.\");\n\t\treturn NULL;\n\t}\n\ttio = sio;\n\ttio.c_lflag &= ~ECHO;\n\tif (tcsetattr(fileno(stdin), 0, &tio) < 0) {\n\t\twarnx(\"Could not read password from standard input.\");\n\t\treturn NULL;\n\t}\n\tfprintf(stdout, \"Enter passphrase for private key: \");\n\tfflush(stdout);\n\tret = fgets(line, sizeof(line), stdin);\n\tset_errno_guard();\n\ttcsetattr(fileno(stdin), 0, &sio);\n\tfprintf(stdout, \"\\n\");\n\tfflush(stdout);\n\tif (ret == NULL)\n\t\treturn NULL;\n\tp = line + strcspn(line, \"\\r\\n\");\n\tif (p == NULL)\n\t\tp = line + strcspn(line, \"\\n\");\n\tif (p != NULL)\n\t\t*p = '\\0';\n\tret = strdup(line);\n\tmemset(line, '\\0', sizeof (line));\n\tif (!ret) {\n\t\twarnx(\"Could not read passphrase.\");\n\t\treturn NULL;\n\t}\n\tegress();\n\treturn ret;\n}", "target": 0}
{"code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}", "target": 1}
{"code": "int db__close(void)\n{\n\tsubhier_clean(&db.subs);\n\tretain__clean(&db.retains);\n\tdb__msg_store_clean();\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int unload_module(void)\n{\n\tast_cli_unregister_multiple(cli_identify, ARRAY_LEN(cli_identify));\n\tast_sip_unregister_cli_formatter(cli_formatter);\n\tast_sip_unregister_endpoint_formatter(&endpoint_identify_formatter);\n\tast_sip_unregister_endpoint_identifier(&header_identifier);\n\tast_sip_unregister_endpoint_identifier(&request_identifier);\n\tast_sip_unregister_endpoint_identifier(&ip_identifier);\n\tast_sip_unregister_endpoint_identifier(&transport_identifier);\n\treturn 0;\n}", "target": 1}
{"code": "alloc_handle( void *ctx_arg, int is_server )\n{\n\ttls_ctx\t*ctx;\n\ttls_session\t*ssl;\n\tif ( ctx_arg ) {\n\t\tctx = ctx_arg;\n\t} else {\n\t\tstruct ldapoptions *lo = LDAP_INT_GLOBAL_OPT();   \n\t\tif ( ldap_pvt_tls_init_def_ctx( is_server ) < 0 ) return NULL;\n\t\tctx = lo->ldo_tls_ctx;\n\t}\n\tssl = tls_imp->ti_session_new( ctx, is_server );\n\tif ( ssl == NULL ) {\n\t\tDebug( LDAP_DEBUG_ANY,\"TLS: can't create ssl handle.\\n\",0,0,0);\n\t\treturn NULL;\n\t}\n\treturn ssl;\n}", "target": 0}
{"code": "static int is_printable(char p)\n{\n\tif ((p >= 'a' && p <= 'z') || (p >= 'A' && p <= 'Z') ||\n\t    (p >= '0' && p <= '9') || p == ' ' || p == '(' || p == ')' ||\n\t    p == '+' || p == ',' || p == '-' || p == '.' || p == '/' ||\n\t    p == ':' || p == '=' || p == '?')\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "int ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info;\n\tint i, j, count;\n\tkgid_t low, high;\n\tint ret = 0;\n\tif (sk->sk_family == AF_INET6)\n\t\tsk->sk_ipv6only = 1;\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\tgroup_info = get_current_groups();\n\tcount = group_info->ngroups;\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\tgoto out_release_group;\n\t\t}\n\t\tcount -= cp_count;\n\t}\n\tret = -EACCES;\nout_release_group:\n\tput_group_info(group_info);\n\treturn ret;\n}", "target": 0}
{"code": "struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n\t\t\t\t\tconst struct sockaddr_in *addr, int H,\n\t\t\t\t\tconst char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack = mempool_alloc(pack_pool);\n\tif (!pack)\n\t\treturn NULL;\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\tpack->hdr.ver = ver;\n\tpack->hdr.T = 1;\n\tpack->hdr.L = 1;\n\tpack->hdr.S = 1;\n\tmemcpy(&pack->addr, addr, sizeof(*addr));\n\tpack->hide_avps = H;\n\tpack->secret = secret;\n\tpack->secret_len = secret_len;\n\tif (msg_type) {\n\t\tif (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {\n\t\t\tmempool_free(pack);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn pack;\n}", "target": 1}
{"code": "static void patch_fn(struct cgit_context *ctx)\n{\n\tcgit_print_patch(ctx->qry.sha1);\n}", "target": 0}
{"code": "IOBasicTypes::LongFilePositionType ObjectByteWriterWithPosition::GetCurrentPosition()\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"getCurrentPosition\")).ToLocalChecked();\n    if(value->IsUndefined())\n        return true;\n    Local<Function> func = Local<Function>::Cast(value);\n\treturn TO_NUMBER(func->Call(GET_CURRENT_CONTEXT, OBJECT_FROM_PERSISTENT(mObject), 0, NULL).ToLocalChecked())->Value();\n}", "target": 1}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 1}
{"code": "bool RenderView::CaptureSnapshot(WebView* view, SkBitmap* snapshot) {\n  base::TimeTicks beginning_time = base::TimeTicks::Now();\n  skia::PlatformCanvas canvas;\n  if (!PaintViewIntoCanvas(view, canvas))\n    return false;\n  skia::BitmapPlatformDevice& device =\n      static_cast<skia::BitmapPlatformDevice&>(canvas.getTopPlatformDevice());\n  const SkBitmap& bitmap = device.accessBitmap(false);\n  if (!bitmap.copyTo(snapshot, SkBitmap::kARGB_8888_Config))\n    return false;\n  HISTOGRAM_TIMES(\"Renderer4.Snapshot\",\n                  base::TimeTicks::Now() - beginning_time);\n  return true;\n}", "target": 0}
{"code": "cp1251_apply_all_case_fold(OnigCaseFoldType flag,\n\t\t\t       OnigApplyAllCaseFoldFunc f, void* arg, OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_apply_all_case_fold_with_map(\n             sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,\n             flag, f, arg);\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n}", "target": 1}
{"code": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}", "target": 1}
{"code": "_parse_config_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval;\n    char buffer[BUF_SIZE];\n    FILE *conf;\n    VAR Var, *var=&Var;\n    D((\"Called.\"));\n    var->name=NULL; var->defval=NULL; var->override=NULL;\n    D((\"Config file name is: %s\", file));\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open config file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n    while (( retval = _assemble_line(conf, buffer, BUF_SIZE)) > 0) {\n      D((\"Read line: %s\", buffer));\n      if ((retval = _parse_line(pamh, buffer, var)) == GOOD_LINE) {\n\tretval = _check_var(pamh, var);\n\tif (DEFINE_VAR == retval) {\n\t  retval = _define_var(pamh, ctrl, var);\n\t} else if (UNDEFINE_VAR == retval) {\n\t  retval = _undefine_var(pamh, ctrl, var);\n\t}\n      }\n      if (PAM_SUCCESS != retval && ILLEGAL_VAR != retval\n\t  && BAD_LINE != retval && PAM_BAD_ITEM != retval) break;\n      _clean_var(var);\n    }  \n    (void) fclose(conf);\n    _clean_var(var);        \n    D((\"Exit.\"));\n    return (retval != 0 ? PAM_ABORT : PAM_SUCCESS);\n}", "target": 0}
{"code": "static void header(RBinFile *bf) {\n\tr_return_if_fail (bf && bf->o);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tif (!element) {\n\t\treturn;\n\t}\n\tRBin *bin = bf->rbin;\n\tPrintfCallback p = bin->cb_printf;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_o (pj);\n\tpj_kn (pj, \"cs_version\", element->hdr->version);\n\tpj_kn (pj, \"size\", element->hdr->size);\n\tif (element->file_name) {\n\t\tpj_ks (pj, \"name\", element->file_name);\n\t}\n\tif (element->binary_version) {\n\t\tpj_ks (pj, \"version\", element->binary_version);\n\t}\n\tchar uuidstr[R_UUID_LENGTH];\n\tr_hex_bin2str (element->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_kn (pj, \"segments\", element->hdr->n_segments);\n\tpj_kn (pj, \"sections\", element->hdr->n_sections);\n\tpj_kn (pj, \"symbols\", element->hdr->n_symbols);\n\tpj_kn (pj, \"lined_symbols\", element->hdr->n_lined_symbols);\n\tpj_kn (pj, \"line_info\", element->hdr->n_line_info);\n\tpj_end (pj);\n\tp (\"%s\\n\", pj_string (pj));\n\tpj_free (pj);\n}", "target": 0}
{"code": "void file_sb_list_del(struct file *file)\n{\n\tif (!list_empty(&file->f_u.fu_list)) {\n\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n\t\tlist_del_init(&file->f_u.fu_list);\n\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n\t}\n}", "target": 1}
{"code": "static int rds_recv_track_latency(struct rds_sock *rs, char __user *optval,\n\t\t\t\t  int optlen)\n{\n\tstruct rds_rx_trace_so trace;\n\tint i;\n\tif (optlen != sizeof(struct rds_rx_trace_so))\n\t\treturn -EFAULT;\n\tif (copy_from_user(&trace, optval, sizeof(trace)))\n\t\treturn -EFAULT;\n\trs->rs_rx_traces = trace.rx_traces;\n\tfor (i = 0; i < rs->rs_rx_traces; i++) {\n\t\tif (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {\n\t\t\trs->rs_rx_traces = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trs->rs_rx_trace[i] = trace.rx_trace_pos[i];\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "ex_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\teap->errmsg =\n\t\t_(\"E319: Sorry, the command is not available in this version\");\n}", "target": 0}
{"code": "inline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n  return t->dims->data[dim];\n}", "target": 1}
{"code": "snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\tif (dp->synths[dev].is_midi) {\n\t\tstruct midi_info minf;\n\t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}", "target": 1}
{"code": "void __init files_init(unsigned long mempages)\n{ \n\tunsigned long n;\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n\tfiles_defer_init();\n\tlg_lock_init(&files_lglock, \"files_lglock\");\n\tpercpu_counter_init(&nr_files, 0);\n} ", "target": 1}
{"code": "print_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n#ifdef CONFIG_TIMER_STATS\n\tchar tmp[TASK_COMM_LEN + 1];\n#endif\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n#ifdef CONFIG_TIMER_STATS\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->start_site);\n\tmemcpy(tmp, timer->start_comm, TASK_COMM_LEN);\n\ttmp[TASK_COMM_LEN] = 0;\n\tSEQ_printf(m, \", %s/%d\", tmp, timer->start_pid);\n#endif\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}", "target": 1}
{"code": "isdn_net_getphones(isdn_net_ioctl_phone *phone, char __user *phones)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint inout = phone->outgoing & 1;\n\tint more = 0;\n\tint count = 0;\n\tisdn_net_phone *n;\n\tif (!p)\n\t\treturn -ENODEV;\n\tinout &= 1;\n\tfor (n = p->local->phone[inout]; n; n = n->next) {\n\t\tif (more) {\n\t\t\tput_user(' ', phones++);\n\t\t\tcount++;\n\t\t}\n\t\tif (copy_to_user(phones, n->num, strlen(n->num) + 1)) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tphones += strlen(n->num);\n\t\tcount += strlen(n->num);\n\t\tmore = 1;\n\t}\n\tput_user(0, phones);\n\tcount++;\n\treturn count;\n}", "target": 0}
{"code": "z_jbig2decode(i_ctx_t * i_ctx_p)\n{\n    os_ptr op = osp;\n    ref *sop = NULL;\n    s_jbig2_global_data_t *gref;\n    stream_jbig2decode_state state;\n    s_jbig2decode_set_global_data((stream_state*)&state, NULL);\n    if (r_has_type(op, t_dictionary)) {\n        check_dict_read(*op);\n        if ( dict_find_string(op, \".jbig2globalctx\", &sop) > 0) {\n            gref = r_ptr(sop, s_jbig2_global_data_t);\n            s_jbig2decode_set_global_data((stream_state*)&state, gref);\n        }\n    }\n    return filter_read(i_ctx_p, 0, &s_jbig2decode_template,\n                       (stream_state *) & state, (sop ? r_space(sop) : 0));\n}", "target": 1}
{"code": "int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                    UINT32* pDstSize, UINT32 flags)\n {\n \tint status = -1;\n \tBYTE descriptor;\n \twStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);\n \tif (!stream)\n \t\treturn -1;\n\tif (Stream_GetRemainingLength(stream) < 1)\n\t\tgoto fail;\n\tStream_Read_UINT8(stream, descriptor); \n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t{\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n \t\t\tgoto fail;\n \t\t*ppDstData = NULL;\n \t\tif (zgfx->OutputCount > 0)\n \t\t\t*ppDstData = (BYTE*) malloc(zgfx->OutputCount);\n\t\tif (!*ppDstData)\n\t\t\tgoto fail;\n\t\t*pDstSize = zgfx->OutputCount;\n\t\tCopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);\n\t}\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t{\n\t\tUINT32 segmentSize;\n\t\tUINT16 segmentNumber;\n \t\tUINT16 segmentCount;\n \t\tUINT32 uncompressedSize;\n \t\tBYTE* pConcatenated;\n \t\tif (Stream_GetRemainingLength(stream) < 6)\n \t\t\tgoto fail;\n\t\tStream_Read_UINT16(stream, segmentCount); \n\t\tStream_Read_UINT32(stream, uncompressedSize); \n\t\tif (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))\n\t\t\tgoto fail;\n\t\tpConcatenated = (BYTE*) malloc(uncompressedSize);\n\t\tif (!pConcatenated)\n\t\t\tgoto fail;\n\t\t*ppDstData = pConcatenated;\n\t\t*pDstSize = uncompressedSize;\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(stream) < sizeof(UINT32))\n\t\t\t\tgoto fail;\n\t\t\tStream_Read_UINT32(stream, segmentSize); \n \t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n \t\t\t\tgoto fail;\n \t\t\tCopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);\n \t\t\tpConcatenated += zgfx->OutputCount;\n \t\t}\n \t}\n \telse\n\t{\n\t\tgoto fail;\n\t}\n\tstatus = 1;\nfail:\n\tStream_Free(stream, FALSE);\n\treturn status;\n}", "target": 1}
{"code": "void handle_get_plugin_schema(nng_aio *aio)\n{\n    size_t      len                        = 0;\n    char *      schema_path                = NULL;\n    char        param[NEU_PLUGIN_NAME_LEN] = { 0 };\n    const char *schema_name                = param;\n    NEU_VALIDATE_JWT(aio);\n    int rv = neu_http_get_param_str(aio, \"schema_name\", param, sizeof(param));\n    if (-2 == rv) {\n        rv = neu_http_get_param_str(aio, \"plugin_name\", param, sizeof(param));\n        schema_name = plugin_name_to_schema_name(param);\n    }\n    if (rv < 0) {\n        neu_http_bad_request(aio, \"{\\\"error\\\": 1002}\");\n        return;\n    }\n    if (0 > neu_asprintf(&schema_path, \"%s/schema/%s.json\", g_plugin_dir,\n                         schema_name)) {\n        NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n            neu_http_response(aio, error_code.error, result_error);\n        });\n        return;\n    }\n    char *buf = NULL;\n    buf = file_string_read(&len, schema_path);\n    if (NULL == buf) {\n        free(schema_path);\n        if (0 > neu_asprintf(&schema_path, \"%s/custom/schema/%s.json\",\n                             g_plugin_dir, schema_name)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n    }\n    if (NULL == buf) {\n        free(schema_path);\n        if (0 > neu_asprintf(&schema_path, \"%s/system/schema/%s.json\",\n                             g_plugin_dir, schema_name)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n    }\n    if (NULL == buf) {\n        nlog_info(\"open %s error: %d\", schema_path, errno);\n        neu_http_not_found(aio, \"{\\\"status\\\": \\\"error\\\"}\");\n        free(schema_path);\n        return;\n    }\n    neu_http_ok(aio, buf);\n    free(buf);\n    free(schema_path);\n}", "target": 1}
{"code": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\tmutex_lock(&client->lock);\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "\tMode mode() const { return m_mode; }", "target": 0}
{"code": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    for (const std::string& input : node.input()) {\n      if (input.empty())\n        return InvalidArgument(\"Node '\", node.name(), \"' has an empty input\");\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    }\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr type,\n                          ConvertAttribute(node.experimental_type(), builder));\n      state.addAttribute(fulltype_attr, type);\n    }\n    Operation* op = builder.create(state);\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return ::tensorflow::OkStatus();\n}", "target": 1}
{"code": "char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}", "target": 1}
{"code": "static unsigned short muscle_parse_singleAcl(const sc_acl_entry_t* acl)\n{\n\tunsigned short acl_entry = 0;\n\twhile(acl) {\n\t\tint key = acl->key_ref;\n\t\tint method = acl->method;\n\t\tswitch(method) {\n\t\tcase SC_AC_NEVER:\n\t\t\treturn 0xFFFF;\n\t\tcase SC_AC_NONE:\n\t\tcase SC_AC_UNKNOWN:\n\t\t\tbreak;\n\t\tcase SC_AC_CHV:\n\t\t\tacl_entry |= (1 << key); \n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tacl = acl->next;\n\t}\n\treturn acl_entry;\n}", "target": 0}
{"code": "void SetBackgroundColor(int par)\n{\n    if ( par == STROKING ) { outpos += sprintf(outpos,\" 0 0 0 0 K\"); }\n    else                   { outpos += sprintf(outpos,\" 0 0 0 0 k\"); }\n}", "target": 1}
{"code": "    TaskFactory& TaskFactory::instance()\n    {\n        static TaskFactory ins;\n        return ins;\n    }", "target": 0}
{"code": "bool JOIN::save_explain_data(Explain_query *output, bool can_overwrite,\n                             bool need_tmp_table, bool need_order, \n                             bool distinct)\n{\n  DBUG_ENTER(\"JOIN::save_explain_data\");\n  DBUG_PRINT(\"enter\", (\"Save explain Select_lex: %u (%p)  parent lex: %p  stmt_lex: %p  present select: %u (%p)\",\n                        select_lex->select_number, select_lex,\n                        select_lex->parent_lex, thd->lex->stmt_lex,\n                        (output->get_select(select_lex->select_number) ?\n                         select_lex->select_number : 0),\n                        (output->get_select(select_lex->select_number) ?\n                         output->get_select(select_lex->select_number)\n                         ->select_lex : NULL)));\n  DBUG_SLOW_ASSERT(select_lex->select_number == UINT_MAX ||\n              select_lex->select_number == INT_MAX ||\n              !output ||\n              !output->get_select(select_lex->select_number) ||\n              output->get_select(select_lex->select_number)->select_lex ==\n                select_lex);\n  if (select_lex->select_number != UINT_MAX && \n      select_lex->select_number != INT_MAX  && \n      have_query_plan != JOIN::QEP_NOT_PRESENT_YET && \n      have_query_plan != JOIN::QEP_DELETED &&  \n      output && \n      (can_overwrite? true: !output->get_select(select_lex->select_number)))\n  {\n    const char *message= NULL;\n    if (!table_count || !tables_list || zero_result_cause)\n    {\n      message= zero_result_cause ? zero_result_cause : \"No tables used\";\n    }\n    bool rc= save_explain_data_intern(thd->lex->explain, need_tmp_table,\n                                      need_order, distinct, message);\n    DBUG_RETURN(rc);\n  }\n  if (select_lex == select_lex->master_unit()->fake_select_lex && join_tab)\n  {\n    uint nr= select_lex->master_unit()->first_select()->select_number;\n    Explain_union *eu= output->get_union(nr);\n    explain= &eu->fake_select_lex_explain;\n    join_tab[0].tracker= eu->get_fake_select_lex_tracker();\n    for (uint i=0 ; i < exec_join_tab_cnt() + aggr_tables; i++)\n    {\n      if (join_tab[i].filesort)\n      {\n        if (!(join_tab[i].filesort->tracker=\n              new Filesort_tracker(thd->lex->analyze_stmt)))\n          DBUG_RETURN(1);\n      }\n    }\n  }\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "parse_table(\n\tstruct buf *ob,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size)\n{\n\tsize_t i;\n\tstruct buf *header_work = 0;\n\tstruct buf *body_work = 0;\n\tsize_t columns;\n\tint *col_data = NULL;\n\theader_work = rndr_newbuf(rndr, BUFFER_SPAN);\n\tbody_work = rndr_newbuf(rndr, BUFFER_BLOCK);\n\ti = parse_table_header(header_work, rndr, data, size, &columns, &col_data);\n\tif (i > 0) {\n\t\twhile (i < size) {\n\t\t\tsize_t row_start;\n\t\t\tint pipes = 0;\n\t\t\trow_start = i;\n\t\t\twhile (i < size && data[i] != '\\n')\n\t\t\t\tif (data[i++] == '|')\n\t\t\t\t\tpipes++;\n\t\t\tif (pipes == 0 || i == size) {\n\t\t\t\ti = row_start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparse_table_row(\n\t\t\t\tbody_work,\n\t\t\t\trndr,\n\t\t\t\tdata + row_start,\n\t\t\t\ti - row_start,\n\t\t\t\tcolumns,\n\t\t\t\tcol_data, 0\n\t\t\t);\n\t\t\ti++;\n\t\t}\n\t\tif (rndr->cb.table)\n\t\t\trndr->cb.table(ob, header_work, body_work, rndr->opaque);\n\t}\n\tfree(col_data);\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn i;\n}", "target": 0}
{"code": "static INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static void bdrv_mirror_top_refresh_filename(BlockDriverState *bs)\n{\n    if (bs->backing == NULL) {\n        return;\n    }\n    pstrcpy(bs->exact_filename, sizeof(bs->exact_filename),\n            bs->backing->bs->filename);\n}", "target": 0}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &nd->path);\nout:\n\treturn ERR_PTR(error);\n}", "target": 0}
{"code": "static void llcp_sock_destruct(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tpr_debug(\"%p\\n\", sk);\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_put_device(llcp_sock->dev);\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tnfc_llcp_sock_free(llcp_sock);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC LLCP socket %p\\n\", sk);\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "int mbedtls_x509_crt_parse_der( mbedtls_x509_crt *chain, const unsigned char *buf,\n                        size_t buflen )\n{\n    int ret;\n    mbedtls_x509_crt *crt = chain, *prev = NULL;\n    if( crt == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n    while( crt->version != 0 && crt->next != NULL )\n    {\n        prev = crt;\n        crt = crt->next;\n    }\n    if( crt->version != 0 && crt->next == NULL )\n    {\n        crt->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_crt ) );\n        if( crt->next == NULL )\n            return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n        prev = crt;\n        mbedtls_x509_crt_init( crt->next );\n        crt = crt->next;\n    }\n    if( ( ret = x509_crt_parse_der_core( crt, buf, buflen ) ) != 0 )\n    {\n        if( prev )\n            prev->next = NULL;\n        if( crt != chain )\n            mbedtls_free( crt );\n        return( ret );\n    }\n    return( 0 );\n}", "target": 0}
{"code": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\tif (size_left == 0)\n\t\treturn 0;\n\tbuf = (char *) match32;\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\t\tsize_left -= match32->match_size;\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\treturn growth;\n}", "target": 1}
{"code": "int git_delta_read_header_fromstream(\n\tsize_t *base_sz, size_t *res_sz, git_packfile_stream *stream)\n{\n\tstatic const size_t buffer_len = DELTA_HEADER_BUFFER_LEN;\n\tunsigned char buffer[DELTA_HEADER_BUFFER_LEN];\n\tconst unsigned char *delta, *delta_end;\n\tsize_t len;\n\tssize_t read;\n\tlen = read = 0;\n\twhile (len < buffer_len) {\n\t\tread = git_packfile_stream_read(stream, &buffer[len], buffer_len - len);\n\t\tif (read == 0)\n\t\t\tbreak;\n\t\tif (read == GIT_EBUFS)\n\t\t\tcontinue;\n\t\tlen += read;\n\t}\n\tdelta = buffer;\n\tdelta_end = delta + len;\n\tif ((hdr_sz(base_sz, &delta, delta_end) < 0) ||\n\t\t(hdr_sz(res_sz, &delta, delta_end) < 0))\n\t\treturn -1;\n\treturn 0;\n}", "target": 0}
{"code": "void __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tdrm_atomic_state_clear(state);\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n}", "target": 1}
{"code": "static UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tStream_Read_UINT16(s, eventId);   \n\tStream_Read_UINT32(s, pduLength); \n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "compat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2_f(\"original KEX proposal: %s\", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\t}\n\tdebug2_f(\"compat KEX proposal: %s\", p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}", "target": 1}
{"code": "static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)\n{\n#if BITS_PER_LONG == 32\n\treturn (void *)(unsigned long)context;\n#else\n\tvoid *p = pHba->ioctl_reply_context[context];\n\tpHba->ioctl_reply_context[context] = NULL;\n\treturn p;\n#endif\n}", "target": 1}
{"code": "static int fts3ConnectMethod(\n  sqlite3 *db,                    \n  void *pAux,                     \n  int argc,                       \n  const char * const *argv,       \n  sqlite3_vtab **ppVtab,          \n  char **pzErr                    \n){\n  return fts3InitVtab(0, db, pAux, argc, argv, ppVtab, pzErr);\n}", "target": 0}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static void free_kvm_area(void)\n{\n\tint cpu;\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}", "target": 0}
{"code": "static Exit_status safe_connect()\n{\n  mysql= mysql_init(NULL);\n  if (!mysql)\n  {\n    error(\"Failed on mysql_init.\");\n    return ERROR_STOP;\n  }\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME,\n                  shared_memory_base_name);\n#endif\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlbinlog\");\n  if (!mysql_real_connect(mysql, host, user, pass, 0, port, sock, 0))\n  {\n    error(\"Failed on connect: %s\", mysql_error(mysql));\n    return ERROR_STOP;\n  }\n  mysql->reconnect= 1;\n  return OK_CONTINUE;\n}", "target": 1}
{"code": "static void nodeDestruct(struct SaveNode* node)\n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}", "target": 1}
{"code": "static void nested_release_page(struct page *page)\n{\n\tkvm_release_page_dirty(page);\n}", "target": 0}
{"code": "static int __init ipip_init(void)\n{\n\tint err;\n\tprintk(banner);\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\treturn err;\n}", "target": 1}
{"code": "int jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tint k;\n\tjas_seqent_t v;\n\tint c;\n\tjas_seqent_t *dr;\n\tjas_seqent_t *d;\n\tint drs;\n\tJAS_DBGLOG(100, (\"jas_image_readcmpt(%p, %d, %ld, %ld, %ld, %ld, %p)\\n\",\n\t  image, cmptno, JAS_CAST(long, x), JAS_CAST(long, y),\n\t  JAS_CAST(long, width), JAS_CAST(long, height), data));\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\tif (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {\n\t\treturn -1;\n\t}\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\tif (jas_matrix_resize(data, height, width)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = 0;\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv = (v << 8) | (c & 0xff);\n\t\t\t}\n\t\t\t*d = bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void sco_sock_clear_timer(struct sock *sk)\n{\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tsk_stop_timer(sk, &sk->sk_timer);\n}", "target": 0}
{"code": "send_client_notifications (void)\n{\n  struct {\n    pid_t pid;\n#ifdef HAVE_W32_SYSTEM\n    HANDLE handle;\n#else\n    int signo;\n#endif\n  } killed[50];\n  int killidx = 0;\n  int kidx;\n  struct server_local_s *sl;\n  for (sl=session_list; sl; sl = sl->next_session)\n    {\n      if (sl->event_signal && sl->assuan_ctx)\n        {\n          pid_t pid = assuan_get_pid (sl->assuan_ctx);\n#ifdef HAVE_W32_SYSTEM\n          HANDLE handle = (void *)sl->event_signal;\n          for (kidx=0; kidx < killidx; kidx++)\n            if (killed[kidx].pid == pid\n                && killed[kidx].handle == handle)\n              break;\n          if (kidx < killidx)\n            log_info (\"event %lx (%p) already triggered for client %d\\n\",\n                      sl->event_signal, handle, (int)pid);\n          else\n            {\n              log_info (\"triggering event %lx (%p) for client %d\\n\",\n                        sl->event_signal, handle, (int)pid);\n              if (!SetEvent (handle))\n                log_error (\"SetEvent(%lx) failed: %s\\n\",\n                           sl->event_signal, w32_strerror (-1));\n              if (killidx < DIM (killed))\n                {\n                  killed[killidx].pid = pid;\n                  killed[killidx].handle = handle;\n                  killidx++;\n                }\n            }\n#else \n          int signo = sl->event_signal;\n          if (pid != (pid_t)(-1) && pid && signo > 0)\n            {\n              for (kidx=0; kidx < killidx; kidx++)\n                if (killed[kidx].pid == pid\n                    && killed[kidx].signo == signo)\n                  break;\n              if (kidx < killidx)\n                log_info (\"signal %d already sent to client %d\\n\",\n                          signo, (int)pid);\n              else\n                {\n                  log_info (\"sending signal %d to client %d\\n\",\n                            signo, (int)pid);\n                  kill (pid, signo);\n                  if (killidx < DIM (killed))\n                    {\n                      killed[killidx].pid = pid;\n                      killed[killidx].signo = signo;\n                      killidx++;\n                    }\n                }\n            }\n#endif \n        }\n    }\n}", "target": 0}
