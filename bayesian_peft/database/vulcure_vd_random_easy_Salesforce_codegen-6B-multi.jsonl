{"code": "bool CxImage::Transfer(CxImage &from, bool bTransferFrames )\n{\n\tif (!Destroy())\n\t\treturn false;\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\tpDib = from.pDib;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n \tif (sk_hashed(sk)) {\n \t\twrite_lock_bh(&ping_table.lock);\n \t\thlist_nulls_del(&sk->sk_nulls_node);\n \t\tsock_put(sk);\n \t\tisk->inet_num = 0;\n \t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}", "target": 1}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n \tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n \t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n \t\treturn -EINVAL;\n \tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "static void __mark_reg_const_zero(struct bpf_reg_state *reg)\n{\n\t__mark_reg_known(reg, 0);\n\treg->type = SCALAR_VALUE;\n}", "target": 0}
{"code": "static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n \t}\n \tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n \t    tu->last_resolution != resolution) {\n \t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n \t\tr1.tstamp = tstamp;\n \t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}", "target": 1}
{"code": "TEST_F(ExprMatchTest, FailGracefullyOnInvalidExpression) {\n    ASSERT_THROWS_CODE(createMatcher(fromjson(\"{$expr: {$anyElementTrue: undefined}}\")),\n                       AssertionException,\n                       17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$and: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$or: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$nor: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n}", "target": 0}
{"code": "void CheckServiceControl(std::shared_ptr<context::RequestContext> context,\n                         std::function<void(Status status)> continuation) {\n  std::shared_ptr<cloud_trace::CloudTraceSpan> trace_span(\n      CreateSpan(context->cloud_trace(), \"CheckServiceControl\"));\n  if (!context->method()) {\n    if (context->GetRequestHTTPMethodWithOverride() == \"OPTIONS\") {\n      TRACE(trace_span) << \"OPTIONS request is rejected\";\n      continuation(Status(Code::PERMISSION_DENIED,\n                          \"The service does not allow CORS traffic.\",\n                          Status::SERVICE_CONTROL));\n    } else {\n      TRACE(trace_span) << \"Method is not configured in the service config\";\n      continuation(Status(Code::NOT_FOUND, \"Method does not exist.\",\n                          Status::SERVICE_CONTROL));\n    }\n    return;\n  } else if (!context->service_context()->service_control() ||\n             context->method()->skip_service_control()) {\n    TRACE(trace_span) << \"Service control check is not needed\";\n    continuation(Status::OK);\n    return;\n  }\n  if (context->api_key().empty()) {\n    if (context->method()->allow_unregistered_calls()) {\n      TRACE(trace_span) << \"Service control check is not needed\";\n      continuation(Status::OK);\n      return;\n    }\n    TRACE(trace_span) << \"Failed at checking caller identity.\";\n    continuation(\n        Status(Code::UNAUTHENTICATED,\n               \"Method doesn't allow unregistered callers (callers without \"\n               \"established identity). Please use API Key or other form of \"\n               \"API consumer identity to call this API.\",\n               Status::SERVICE_CONTROL));\n    return;\n  }\n  service_control::CheckRequestInfo info;\n  context->FillCheckRequestInfo(&info);\n  context->service_context()->service_control()->Check(\n      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        context->set_check_response_info(info);\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(kConsumerProjecId,\n                                                 info.consumer_project_id);\n        }\n        continuation(status);\n      });\n}", "target": 1}
{"code": "test_append_uri_pathel(void)\n{\n  unsigned i;\n  static const struct {\n    const char *original_url;\n    const char *input;\n    bool escaped;\n    const char *expected_result;\n  } test_array[] = {\n    { \"http:\n  };\n  for (i = 0; i < countof(test_array); ++i)\n    {\n      struct growable dest;\n      const char *p = test_array[i].input;\n      memset (&dest, 0, sizeof (dest));\n      append_string (test_array[i].original_url, &dest);\n      append_uri_pathel (p, p + strlen(p), test_array[i].escaped, &dest);\n      mu_assert (\"test_append_uri_pathel: wrong result\",\n                 strcmp (dest.base, test_array[i].expected_result) == 0);\n      xfree (dest.base);\n    }\n  return NULL;\n}", "target": 0}
{"code": "PHPAPI void php_store_class_name(zval *object, const char *name, zend_uint len)\n{\n\tzval *val;\n\tTSRMLS_FETCH();\n\tMAKE_STD_ZVAL(val);\n\tZ_TYPE_P(val)   = IS_STRING;\n\tZ_STRVAL_P(val) = estrndup(name, len);\n\tZ_STRLEN_P(val) = len;\n\tzend_hash_update(Z_OBJPROP_P(object), MAGIC_MEMBER, sizeof(MAGIC_MEMBER), &val, sizeof(val), NULL);\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}", "target": 1}
{"code": "finish_pam(void)\n{\n\tfatal_remove_cleanup(sshpam_cleanup, NULL);\n\tsshpam_cleanup(NULL);\n}", "target": 0}
{"code": "fbStore_r5g6b5 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    CARD16 *pixel = ((CARD16 *) bits) + x;\n    for (i = 0; i < width; ++i) {\n        CARD32 s = READ(values + i);\n        WRITE(pixel++, ((s >> 3) & 0x001f) |\n\t      ((s >> 5) & 0x07e0) |\n\t      ((s >> 8) & 0xf800));\n    }\n}", "target": 0}
{"code": "static void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\tpvclock_update_vm_gtod_copy(kvm);\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}", "target": 0}
{"code": "static struct page *alloc_gigantic_page(struct hstate *h, gfp_t gfp_mask,\n\t\t\t\t\tint nid, nodemask_t *nodemask)\n{\n\treturn NULL;\n}", "target": 0}
{"code": "void GfxCalRGBColorSpace::getGray(const GfxColor *color, GfxGray *gray) const\n{\n    GfxRGB rgb;\n#ifdef USE_CMS\n    if (transform != nullptr && transform->getTransformPixelType() == PT_GRAY) {\n        unsigned char out[gfxColorMaxComps];\n        double in[gfxColorMaxComps];\n        double X, Y, Z;\n        getXYZ(color, &X, &Y, &Z);\n        in[0] = clip01(X);\n        in[1] = clip01(Y);\n        in[2] = clip01(Z);\n        transform->doTransform(in, out, 1);\n        *gray = byteToCol(out[0]);\n        return;\n    }\n#endif\n    getRGB(color, &rgb);\n    *gray = clip01((GfxColorComp)(0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b + 0.5));\n}", "target": 0}
{"code": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err akey_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeKeyInfoBox *ptr = (GF_AdobeKeyInfoBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->params, &pos);\n    return GF_OK;\n}", "target": 0}
{"code": "process_demand_active(STREAM s)\n {\n \tuint8 type;\n \tuint16 len_src_descriptor, len_combined_caps;\n \trd_create_ui();\n \tin_uint32_le(s, g_rdp_shareid);\n \tin_uint16_le(s, len_src_descriptor);\n \tin_uint16_le(s, len_combined_caps);\n \tin_uint8s(s, len_src_descriptor);\n \tlogger(Protocol, Debug, \"process_demand_active(), shareid=0x%x\", g_rdp_shareid);\n\trdp_process_server_caps(s, len_combined_caps);\n\trdp_send_confirm_active();\n\trdp_send_synchronise();\n\trdp_send_control(RDP_CTL_COOPERATE);\n\trdp_send_control(RDP_CTL_REQUEST_CONTROL);\n\trdp_recv(&type);\t\n\trdp_recv(&type);\t\n\trdp_recv(&type);\t\n\trdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,\n\t\t       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\trdp_enum_bmpcache2();\n\t\trdp_send_fonts(3);\n\t}\n\telse\n\t{\n\t\trdp_send_fonts(1);\n\t\trdp_send_fonts(2);\n\t}\n\trdp_recv(&type);\t\n\treset_order_state();\n}", "target": 1}
{"code": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n      return;\n   }\n   ctx_params.shared = true;\n   ctx_params.major_ver = VREND_GL_VER_MAJOR;\n   ctx_params.minor_ver = VREND_GL_VER_MINOR;\n   blit_ctx->gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; \n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}", "target": 1}
{"code": "    bool triggered() const { return m_triggered; }", "target": 0}
{"code": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\tBUG_ON (!data || !frags);\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n \tlist_add_tail (&f->list, frags);\n found:\n \tif (f->map & (1 << rec)) {\n \t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n \t\tf->map &= 0x7F;\t\t\t\n\t\treturn false;\n\t}\n\tf->map |= (1 << rec);\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\treturn true;\n}", "target": 1}
{"code": "proto_reg_handoff_sysdig_event(void)\n{\n    dissector_handle_t sysdig_event_handle;\n    sysdig_event_handle = create_dissector_handle(dissect_sysdig_event,\n            proto_sysdig_event);\n    dissector_add_uint(\"pcapng.block_type\", BLOCK_TYPE_SYSDIG_EVENT, sysdig_event_handle);\n    dissector_add_uint(\"pcapng.block_type\", BLOCK_TYPE_SYSDIG_EVENT_V2, sysdig_event_handle);\n    dissector_add_uint(\"pcapng.block_type\", BLOCK_TYPE_SYSDIG_EVENT_V2_LARGE, sysdig_event_handle);\n}", "target": 0}
{"code": "int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tstruct sk_buff *skb;\n\tunsigned long time_left;\n\tint ret = 0;\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, headroom);\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\tmutex_lock(&wmi->op_mutex);\n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\n\tif (ret)\n\t\tgoto out;\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\treturn -ETIMEDOUT;\n\t}\n\tmutex_unlock(&wmi->op_mutex);\n\treturn 0;\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 1}
{"code": "njs_string_slice(njs_vm_t *vm, njs_value_t *dst,\n    const njs_string_prop_t *string, const njs_slice_prop_t *slice)\n{\n    njs_string_prop_t  prop;\n    njs_string_slice_string_prop(&prop, string, slice);\n    if (njs_fast_path(prop.size != 0)) {\n        return njs_string_new(vm, dst, prop.start, prop.size, prop.length);\n    }\n    *dst = njs_string_empty;\n    return NJS_OK;\n}", "target": 0}
{"code": "static void emit(JF, int value)\n{\n\temitraw(J, F, value);\n}", "target": 0}
{"code": "xmlValidateNmtokensValue(const xmlChar *value) {\n    return(xmlValidateNmtokensValueInternal(NULL, value));\n}", "target": 0}
{"code": "void QuotaManagerProxy::NotifyOriginNoLongerInUse(\n    const GURL& origin) {\n  if (!io_thread_->BelongsToCurrentThread()) {\n    io_thread_->PostTask(FROM_HERE, NewRunnableMethod(\n        this, &QuotaManagerProxy::NotifyOriginNoLongerInUse, origin));\n    return;\n  }\n  if (manager_)\n    manager_->NotifyOriginNoLongerInUse(origin);\n}", "target": 0}
{"code": "static void __net_exit pfkey_net_exit(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tpfkey_exit_proc(net);\n\tWARN_ON(!hlist_empty(&net_pfkey->table));\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_t = ctx->input(0);\n    const Tensor& rate_t = ctx->input(1);\n    TensorShape samples_shape;\n    OP_REQUIRES_OK(ctx, tensor::MakeShape(shape_t, &samples_shape));\n    const int64_t num_samples = samples_shape.num_elements();\n    samples_shape.AppendShape(rate_t.shape());\n    Tensor* samples_t = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, samples_shape, &samples_t));\n    if (num_samples == 0) return;\n    const auto rate_flat = rate_t.flat<T>().data();\n    const int64_t num_rate = rate_t.NumElements();\n    auto samples_flat = samples_t->flat<U>().data();\n    random::PhiloxRandom rng = generator_.ReserveRandomOutputs(\n        num_samples * num_rate, kReservedSamplesPerOutput);\n    functor::PoissonFunctor<CPUDevice, T, U>()(\n        ctx, ctx->eigen_device<CPUDevice>(), rate_flat, num_rate, num_samples,\n        rng, samples_flat);\n  }", "target": 1}
{"code": "bool timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tstruct rb_node **p = &head->head.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct timerqueue_node  *ptr;\n\tWARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));\n\twhile (*p) {\n\t\tparent = *p;\n\t\tptr = rb_entry(parent, struct timerqueue_node, node);\n\t\tif (node->expires < ptr->expires)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\trb_link_node(&node->node, parent, p);\n\trb_insert_color(&node->node, &head->head);\n\tif (!head->next || node->expires < head->next->expires) {\n\t\thead->next = node;\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "void TestGatherNd(int* param_dims, const ParamType* param_data, int* index_dims,\n                  const IndexType* index_data, int* output_dims,\n                  ParamType* output_data,\n                  const ParamType* expected_output_data) {\n  TfLiteIntArray* pdims = IntArrayFromInts(param_dims);\n  TfLiteIntArray* idims = IntArrayFromInts(index_dims);\n  TfLiteIntArray* odims = IntArrayFromInts(output_dims);\n  constexpr int inputs_size = 2;\n  constexpr int outputs_size = 1;\n  constexpr int tensors_size = inputs_size + outputs_size;\n  TfLiteTensor tensors[tensors_size] = {\n      CreateTensor(param_data, pdims),\n      CreateTensor(index_data, idims),\n      CreateTensor(output_data, odims),\n  };\n  int inputs_array_data[] = {2, 0, 1};\n  TfLiteIntArray* inputs_array = IntArrayFromInts(inputs_array_data);\n  int outputs_array_data[] = {1, 2};\n  TfLiteIntArray* outputs_array = IntArrayFromInts(outputs_array_data);\n  const TfLiteRegistration registration = Register_GATHER_ND();\n  micro::KernelRunner runner(registration, tensors, tensors_size, inputs_array,\n                             outputs_array, nullptr);\n  TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.InitAndPrepare());\n  TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.Invoke());\n  TfLiteTensor* actual_output_tensor = &tensors[2];\n  TfLiteIntArray* actual_output_dims = actual_output_tensor->dims;\n  const int output_size = ElementCount(*actual_output_dims);\n  for (int i = 0; i < output_size; ++i) {\n    TF_LITE_MICRO_EXPECT_EQ(expected_output_data[i], output_data[i]);\n  }\n}", "target": 1}
{"code": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "smb_fdata(netdissect_options *ndo,\n          const u_char *buf, const char *fmt, const u_char *maxbuf,\n          int unicodestr)\n{\n    static int depth = 0;\n    char s[128];\n    char *p;\n    while (*fmt) {\n\tswitch (*fmt) {\n\tcase '*':\n\t    fmt++;\n\t    while (buf < maxbuf) {\n\t\tconst u_char *buf2;\n\t\tdepth++;\n\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);\n\t\tdepth--;\n\t\tif (buf2 == NULL)\n\t\t    return(NULL);\n\t\tif (buf2 == buf)\n\t\t    return(buf);\n\t\tbuf = buf2;\n\t    }\n\t    return(buf);\n\tcase '|':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    break;\n\tcase '%':\n\t    fmt++;\n\t    buf = maxbuf;\n\t    break;\n\tcase '#':\n\t    fmt++;\n\t    return(buf);\n\t    break;\n\tcase '[':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    memset(s, 0, sizeof(s));\n\t    p = strchr(fmt, ']');\n\t    if ((size_t)(p - fmt + 1) > sizeof(s)) {\n\t\treturn(buf);\n\t    }\n\t    strncpy(s, fmt, p - fmt);\n\t    s[p - fmt] = '\\0';\n\t    fmt = p + 1;\n\t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);\n\t    if (buf == NULL)\n\t\treturn(NULL);\n\t    break;\n\tdefault:\n\t    ND_PRINT((ndo, \"%c\", *fmt));\n\t    fmt++;\n\t    break;\n\t}\n    }\n    if (!depth && buf < maxbuf) {\n\tsize_t len = PTR_DIFF(maxbuf, buf);\n\tND_PRINT((ndo, \"Data: (%lu bytes)\\n\", (unsigned long)len));\n\tsmb_print_data(ndo, buf, len);\n\treturn(buf + len);\n    }\n    return(buf);\n}", "target": 1}
{"code": "int __ref online_pages(unsigned long pfn, unsigned long nr_pages)\n{\n\tunsigned long onlined_pages = 0;\n\tstruct zone *zone;\n\tint need_zonelists_rebuild = 0;\n\tint nid;\n\tint ret;\n\tstruct memory_notify arg;\n\tlock_memory_hotplug();\n\targ.start_pfn = pfn;\n\targ.nr_pages = nr_pages;\n\targ.status_change_nid = -1;\n\tnid = page_to_nid(pfn_to_page(pfn));\n\tif (node_present_pages(nid) == 0)\n\t\targ.status_change_nid = nid;\n\tret = memory_notify(MEM_GOING_ONLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone = page_zone(pfn_to_page(pfn));\n\tmutex_lock(&zonelists_mutex);\n\tif (!populated_zone(zone))\n\t\tneed_zonelists_rebuild = 1;\n\tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\n\t\tonline_pages_range);\n\tif (ret) {\n\t\tmutex_unlock(&zonelists_mutex);\n\t\tprintk(KERN_DEBUG \"online_pages [mem %#010llx-%#010llx] failed\\n\",\n\t\t       (unsigned long long) pfn << PAGE_SHIFT,\n\t\t       (((unsigned long long) pfn + nr_pages)\n\t\t\t    << PAGE_SHIFT) - 1);\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone->present_pages += onlined_pages;\n\tzone->zone_pgdat->node_present_pages += onlined_pages;\n\tif (need_zonelists_rebuild)\n\t\tbuild_all_zonelists(NULL, zone);\n\telse\n\t\tzone_pcp_update(zone);\n\tmutex_unlock(&zonelists_mutex);\n\tinit_per_zone_wmark_min();\n\tif (onlined_pages) {\n\t\tkswapd_run(zone_to_nid(zone));\n\t\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);\n\t}\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\tif (onlined_pages)\n\t\tmemory_notify(MEM_ONLINE, &arg);\n\tunlock_memory_hotplug();\n\treturn 0;\n}", "target": 1}
{"code": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}", "target": 1}
{"code": "int IniParser::write()\n{\n    int bugs = 0;\n    if (!inifile.isDirty())\n    {\n        y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    if (read_only)\n    {\n        y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    UpdateIfModif ();\n    if (multiple_files)\n    {\n\tIniIterator\n\t    ci = inifile.getContainerBegin (),\n\t    ce = inifile.getContainerEnd ();\n\tfor (;ci != ce; ++ci)\n\t    {\n\t\tif (ci->t () == SECTION)\n\t\t    {\n\t\t\tIniSection&s = ci->s ();\n\t\t\tint wb = s.getRewriteBy (); \n\t\t\tstring filename = getFileName (s.getName (), wb);\n\t\t\tdeleted_sections.erase (filename);\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n\t\t\tPathname pn (filename);\n\t\t\tPathInfo::assert_dir (pn.dirname ());\n\t\t\tofstream of(filename.c_str());\n\t\t\tif (!of.good())\n\t\t\t{\n\t\t\t    bugs++;\n\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\twrite_helper (s, of, 0);\n\t\t\ts.clean();\n\t\t\tof.close ();\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n\tPathname pn (file);\n\tPathInfo::assert_dir (pn.dirname ());\n\tofstream of(file.c_str());\n\tif (!of.good())\n\t{\n\t    y2error (\"Can not open file %s for write\", file.c_str());\n\t    return -1;\n\t}\n\twrite_helper (inifile, of, 0);\n\tof.close();\n\ttimestamp = getTimeStamp ();\n    }\n    inifile.clean ();\n    return bugs ? -1 : 0;\n}", "target": 1}
{"code": "static int parse_video_info(AVIOContext *pb, AVStream *st)\n{\n    uint16_t size_asf; \n    uint32_t size_bmp; \n    unsigned int tag;\n    st->codecpar->width  = avio_rl32(pb);\n    st->codecpar->height = avio_rl32(pb);\n    avio_skip(pb, 1); \n    size_asf = avio_rl16(pb);\n    tag = ff_get_bmp_header(pb, st, &size_bmp);\n    st->codecpar->codec_tag = tag;\n     st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);\n     size_bmp = FFMAX(size_asf, size_bmp);\n    if (size_bmp > BMP_HEADER_SIZE) {\n         int ret;\n         st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;\n         if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +\n                                               AV_INPUT_BUFFER_PADDING_SIZE))) {\n            st->codecpar->extradata_size = 0;\n            return AVERROR(ENOMEM);\n        }\n        memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,\n               AV_INPUT_BUFFER_PADDING_SIZE);\n        if ((ret = avio_read(pb, st->codecpar->extradata,\n                             st->codecpar->extradata_size)) < 0)\n            return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {\n    int len = 0, l;\n    int c;\n    int count = 0;\n    const xmlChar *end; \n#ifdef DEBUG\n    nbParseNCNameComplex++;\n#endif\n    GROW;\n    end = ctxt->input->cur;\n    c = CUR_CHAR(l);\n    if ((c == ' ') || (c == '>') || (c == '/') || \n\t(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {\n\treturn(NULL);\n    }\n    while ((c != ' ') && (c != '>') && (c != '/') && \n\t   (xmlIsNameChar(ctxt, c) && (c != ':'))) {\n\tif (count++ > XML_PARSER_CHUNK_SIZE) {\n            if ((len > XML_MAX_NAME_LENGTH) &&\n                ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n                return(NULL);\n            }\n\t    count = 0;\n\t    GROW;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t}\n\tlen += l;\n\tNEXTL(l);\n\tend = ctxt->input->cur;\n\tc = CUR_CHAR(l);\n\tif (c == 0) {\n\t    count = 0;\n\t    ctxt->input->cur -= l;\n\t    GROW;\n\t    ctxt->input->cur += l;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t    end = ctxt->input->cur;\n\t    c = CUR_CHAR(l);\n\t}\n    }\n    if ((len > XML_MAX_NAME_LENGTH) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n        return(NULL);\n    }\n    return(xmlDictLookup(ctxt->dict, end - len, len));\n}", "target": 1}
{"code": "const AtomicString& HTMLInputElement::alt() const\n{\n    return fastGetAttribute(altAttr);\n}", "target": 0}
{"code": "static void process_constructors(RKernelCacheObj *obj, struct MACH0_(obj_t) *mach0, RList *ret, ut64 paddr, bool is_first, int mode, const char *prefix) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\tint type;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (section->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr (section->name, \"_mod_fini_func\") || strstr (section->name, \"_mod_term_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (strstr (section->name, \"_mod_init_func\")) {\n\t\t\ttype  = is_first ? 0 : R_BIN_ENTRY_TYPE_INIT;\n\t\t\tis_first = false;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsym->name = r_str_newf (\"%s.%s.%d\", prefix, (type == R_BIN_ENTRY_TYPE_INIT) ? \"init\" : \"fini\", count++);\n\t\t\t\tsym->vaddr = addr64;\n\t\t\t\tsym->paddr = paddr64;\n\t\t\t\tsym->size = 0;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"GLOBAL\";\n\t\t\t\tsym->type = \"FUNC\";\n\t\t\t\tr_list_append (ret, sym);\n\t\t\t}\n\t\t}\n\t\tfree (buf);\n\t}\n}", "target": 1}
{"code": "\t\tvoid CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());\n \t\t\tif (result.empty())\n \t\t\t\treturn;\n \t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}", "target": 1}
{"code": "  int Bind(const Node& node, int max_retry) override {\n    receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n    CHECK(receiver_ != NULL)\n        << \"create receiver socket failed: \" << zmq_strerror(errno);\n    int local = GetEnv(\"DMLC_LOCAL\", 0);\n    std::string addr = local ? \"ipc:\n    int port = node.port;\n    unsigned seed = static_cast<unsigned>(time(NULL)+port);\n    for (int i = 0; i < max_retry+1; ++i) {\n      auto address = addr + std::to_string(port);\n      if (zmq_bind(receiver_, address.c_str()) == 0) break;\n      if (i == max_retry) {\n        port = -1;\n      } else {\n        port = 10000 + rand_r(&seed) % 40000;\n      }\n    }\n    return port;\n  }", "target": 1}
{"code": "ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\tconst u_char *inblob, *outblob;\n\tsize_t inl, outl;\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n\t\tgoto out;\n\tif (inl == 0)\n\t\tstate->compression_in_started = 0;\n\telse if (inl != sizeof(state->compression_in_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_in_started = 1;\n\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n\t}\n\tif (outl == 0)\n\t\tstate->compression_out_started = 0;\n\telse if (outl != sizeof(state->compression_out_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_out_started = 1;\n\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "static s32 adpt_i2o_quiesce_hba(adpt_hba* pHba)\n{\n\tu32 msg[4];\n\tint ret;\n\tadpt_i2o_status_get(pHba);\n\tif((pHba->status_block->iop_state != ADAPTER_STATE_READY) &&\n   \t   (pHba->status_block->iop_state != ADAPTER_STATE_OPERATIONAL)){\n\t\treturn 0;\n\t}\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = I2O_CMD_SYS_QUIESCE<<24|HOST_TID<<12|ADAPTER_TID;\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {\n\t\tprintk(KERN_INFO\"dpti%d: Unable to quiesce (status=%#x).\\n\",\n\t\t\t\tpHba->unit, -ret);\n\t} else {\n\t\tprintk(KERN_INFO\"dpti%d: Quiesced.\\n\",pHba->unit);\n\t}\n\tadpt_i2o_status_get(pHba);\n\treturn ret;\n}", "target": 1}
{"code": "isdn_net_force_hangup(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\tstruct net_device *q;\n\tif (p) {\n\t\tif (p->local->isdn_device < 0)\n\t\t\treturn 1;\n\t\tq = p->local->slave;\n\t\twhile (q) {\n\t\t\tisdn_net_hangup(q);\n\t\t\tq = MASTER_TO_SLAVE(q);\n\t\t}\n\t\tisdn_net_hangup(p->dev);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}", "target": 0}
{"code": "poly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = TRUE;\n\tpath->dummy = 0;\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\tPG_RETURN_PATH_P(path);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MergeSort) {\n    addIndex(BSON(\"a\" << 1 << \"c\" << 1));\n    addIndex(BSON(\"b\" << 1 << \"c\" << 1));\n    runQuerySortProj(fromjson(\"{$or: [{a:1}, {b:1}]}\"), fromjson(\"{c:1}\"), BSONObj());\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {c: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {dir: 1}}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {a: 1, c: 1}}}, {ixscan: {pattern: {b: 1, c: 1}}}]}}}}\");\n}", "target": 0}
{"code": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n \tif (efi_enabled(EFI_OLD_MEMMAP))\n \t\treturn 0;\n \tei->efi_loader_signature = current_ei->efi_loader_signature;\n \tei->efi_systab = current_ei->efi_systab;\n \tei->efi_systab_hi = current_ei->efi_systab_hi;\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}", "target": 1}
{"code": "static void on_bytes_received(void* context, const unsigned char* buffer, size_t size)\n{\n    unsigned char* new_received_bytes;\n    HTTP_HANDLE_DATA* http_instance = (HTTP_HANDLE_DATA*)context;\n    if (http_instance != NULL)\n    {\n        if (buffer == NULL)\n        {\n            http_instance->is_io_error = 1;\n            LogError(\"NULL pointer error\");\n        }\n        else\n        {\n            new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, http_instance->received_bytes_count + size);\n            if (new_received_bytes == NULL)\n            {\n                http_instance->is_io_error = 1;\n                LogError(\"Error allocating memory for received data\");\n            }\n            else\n            {\n                http_instance->received_bytes = new_received_bytes;\n                if (memcpy(http_instance->received_bytes + http_instance->received_bytes_count, buffer, size) == NULL)\n                {\n                    http_instance->is_io_error = 1;\n                    LogError(\"Error copping received data to the HTTP bufffer\");\n                }\n                else\n                {\n                    http_instance->received_bytes_count += size;\n                }\n            }\n        }\n    }\n}", "target": 1}
{"code": "GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t\tif (ptr->location[ptr->size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "SPL_METHOD(Array, getChildren)\n{\n\tzval *object = getThis(), **entry, *flags;\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tHashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tif (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {\n\t\treturn;\n\t}\n\tif (zend_hash_get_current_data_ex(aht, (void **) &entry, &intern->pos) == FAILURE) {\n\t\treturn;\n\t}\n\tif (Z_TYPE_PP(entry) == IS_OBJECT) {\n\t\tif ((intern->ar_flags & SPL_ARRAY_CHILD_ARRAYS_ONLY) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (instanceof_function(Z_OBJCE_PP(entry), Z_OBJCE_P(getThis()) TSRMLS_CC)) {\n\t\t\tRETURN_ZVAL(*entry, 1, 0);\n\t\t}\n\t}\n\tMAKE_STD_ZVAL(flags);\n\tZVAL_LONG(flags, SPL_ARRAY_USE_OTHER | intern->ar_flags);\n\tspl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, *entry, flags TSRMLS_CC);\n\tzval_ptr_dtor(&flags);\n}", "target": 0}
{"code": "void HTPStateFree(void *state)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    if (s == NULL) {\n        SCReturn;\n    }\n    if (s->connp != NULL) {\n        SCLogDebug(\"freeing HTP state\");\n        uint64_t tx_id;\n        uint64_t total_txs = HTPStateGetTxCnt(state);\n        if (s->conn != NULL) {\n            for (tx_id = 0; tx_id < total_txs; tx_id++) {\n                htp_tx_t *tx = HTPStateGetTx(s, tx_id);\n                if (tx != NULL) {\n                    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n                    HtpTxUserDataFree(s, htud);\n                    htp_tx_set_user_data(tx, NULL);\n                }\n            }\n        }\n        htp_connp_destroy_all(s->connp);\n    }\n    FileContainerFree(s->files_ts);\n    FileContainerFree(s->files_tc);\n    HTPFree(s, sizeof(HtpState));\n#ifdef DEBUG\n    SCMutexLock(&htp_state_mem_lock);\n    htp_state_memcnt--;\n    htp_state_memuse -= sizeof(HtpState);\n    SCLogDebug(\"htp memory %\"PRIu64\" (%\"PRIu64\")\", htp_state_memuse, htp_state_memcnt);\n    SCMutexUnlock(&htp_state_mem_lock);\n#endif\n    SCReturn;\n}", "target": 1}
{"code": "userauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n\tsize_t len;\n\tu_char *doid = NULL;\n\tif (!authctxt->valid || authctxt->user == NULL)\n\t\treturn (0);\n\tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\tdo {\n\t\tmechs--;\n\t\tfree(doid);\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n\t\tif (ctxt != NULL)\n\t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\tauthctxt->methoddata = (void *)ctxt;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfree(doid);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\treturn (0);\n}", "target": 1}
{"code": "BOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *length); \n\tif (*length == 0x8000)\n\t{\n\t\trdp_read_flow_control_pdu(s, type);\n\t\t*channel_id = 0;\n\t\t*length = 8; \n\t\treturn TRUE;\n\t}\n\tif (((size_t)*length - 2) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *type); \n\t*type &= 0x0F;                \n\tif (*length > 4)\n\t\tStream_Read_UINT16(s, *channel_id); \n\telse\n\t\t*channel_id = 0; \n\treturn TRUE;\n}", "target": 1}
{"code": "static int nfs_readlink_reply(unsigned char *pkt, unsigned len)\n {\n \tuint32_t *data;\n \tchar *path;\n\tint rlen;\n \tint ret;\n \tret = rpc_check_reply(pkt, 1);\n\tif (ret)\n\t\treturn ret;\n\tdata = (uint32_t *)(pkt + sizeof(struct rpc_reply));\n\tdata++;\n \trlen = ntohl(net_read_uint32(data)); \n \tdata++;\n \tpath = (char *)data;\n\t} else {\n\t\tmemcpy(nfs_path, path, rlen);\n\t\tnfs_path[rlen] = 0;\n\t}", "target": 1}
{"code": "static int FNAME(cmpxchg_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t       pt_element_t __user *ptep_user, unsigned index,\n\t\t\t       pt_element_t orig_pte, pt_element_t new_pte)\n{\n\tint npages;\n\tpt_element_t ret;\n\tpt_element_t *table;\n\tstruct page *page;\n\tnpages = get_user_pages_fast((unsigned long)ptep_user, 1, FOLL_WRITE, &page);\n\tif (likely(npages == 1)) {\n\t\ttable = kmap_atomic(page);\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tkunmap_atomic(table);\n\t\tkvm_release_page_dirty(page);\n\t} else {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned long vaddr = (unsigned long)ptep_user & PAGE_MASK;\n\t\tunsigned long pfn;\n\t\tunsigned long paddr;\n\t\tmmap_read_lock(current->mm);\n\t\tvma = find_vma_intersection(current->mm, vaddr, vaddr + PAGE_SIZE);\n\t\tif (!vma || !(vma->vm_flags & VM_PFNMAP)) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tpfn = ((vaddr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\t\tpaddr = pfn << PAGE_SHIFT;\n\t\ttable = memremap(paddr, PAGE_SIZE, MEMREMAP_WB);\n\t\tif (!table) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tmemunmap(table);\n\t\tmmap_read_unlock(current->mm);\n\t}\n\treturn (ret != orig_pte);\n}", "target": 1}
{"code": "int jpc_pchglist_numpchgs(jpc_pchglist_t *pchglist)\n{\n\treturn pchglist->numpchgs;\n}", "target": 0}
{"code": "PassRefPtr<AccessibilityTextMarkerRange> AccessibilityUIElement::textMarkerRangeForMarkers(AccessibilityTextMarker* startMarker, AccessibilityTextMarker* endMarker)\n{\n    return 0;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, IndexBoundsOrOfNegations) {\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{$or: [{a: {$ne: 3}}, {a: {$ne: 4}}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a:1}, \"\n        \"bounds: {a: [['MinKey','MaxKey',true,true]]}}}}}\");\n}", "target": 0}
{"code": "static int vmci_transport_send_conn_request2(struct sock *sk, size_t size,\n\t\t\t\t\t     u16 version)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\tsk, VMCI_TRANSPORT_PACKET_TYPE_REQUEST2,\n\t\t\t\t\tsize, 0, NULL, version,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}", "target": 0}
{"code": "NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {\n    SSL *ssl;\n    CLI *c;\n    ssl=X509_STORE_CTX_get_ex_data(callback_ctx,\n        SSL_get_ex_data_X509_STORE_CTX_idx());\n    c=SSL_get_ex_data(ssl, index_ssl_cli);\n    if(!c->opt->option.verify_chain && !c->opt->option.verify_peer) {\n        s_log(LOG_INFO, \"Certificate verification disabled\");\n        return 1; \n    }\n    if(verify_checks(c, preverify_ok, callback_ctx)) {\n        SSL_SESSION *sess=SSL_get1_session(c->ssl);\n        if(sess) {\n            int ok=SSL_SESSION_set_ex_data(sess, index_session_authenticated,\n                (void *)(-1));\n            SSL_SESSION_free(sess);\n            if(!ok) {\n                sslerror(\"SSL_SESSION_set_ex_data\");\n                return 0; \n            }\n        }\n        return 1; \n    }\n    if(c->opt->option.client || c->opt->protocol)\n        return 0; \n    if(c->opt->redirect_addr.names)\n        return 1; \n    return 0; \n}", "target": 1}
{"code": "static int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar build[ATUSB_BUILD_SIZE + 1];\n\tint ret;\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "bool IsRelativeSymlinkSafe(CommandData *Cmd,const wchar *SrcName,const wchar *PrepSrcName,const wchar *TargetName)\n{\n  if (IsFullRootPath(SrcName) || IsFullRootPath(TargetName))\n    return false;\n  int UpLevels=0;\n  for (int Pos=0;*TargetName!=0;Pos++)\n  {\n    bool Dot2=TargetName[0]=='.' && TargetName[1]=='.' && \n              (IsPathDiv(TargetName[2]) || TargetName[2]==0) &&\n              (Pos==0 || IsPathDiv(*(TargetName-1)));\n    if (Dot2)\n      UpLevels++;\n    TargetName++;\n  }\n  if (UpLevels>0 && LinkInPath(PrepSrcName))\n    return false;\n  int AllowedDepth=CalcAllowedDepth(SrcName); \n  size_t ExtrPathLength=wcslen(Cmd->ExtrPath);\n  if (ExtrPathLength>0 && wcsncmp(PrepSrcName,Cmd->ExtrPath,ExtrPathLength)==0)\n  {\n    PrepSrcName+=ExtrPathLength;\n    while (IsPathDiv(*PrepSrcName))\n      PrepSrcName++;\n  }\n  int PrepAllowedDepth=CalcAllowedDepth(PrepSrcName);\n  return AllowedDepth>=UpLevels && PrepAllowedDepth>=UpLevels;\n}", "target": 1}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n \t\tnode = blk->bp->b_addr;\n \t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n \t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n \t\t\tbreak;\n \t\tblk->hashval = lasthash;\n \t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "bntseq_t *bns_restore(const char *prefix)\n{  \n\tchar ann_filename[1024], amb_filename[1024], pac_filename[1024], alt_filename[1024];\n\tFILE *fp;\n\tbntseq_t *bns;\n\tstrcat(strcpy(ann_filename, prefix), \".ann\");\n\tstrcat(strcpy(amb_filename, prefix), \".amb\");\n\tstrcat(strcpy(pac_filename, prefix), \".pac\");\n\tbns = bns_restore_core(ann_filename, amb_filename, pac_filename);\n\tif (bns == 0) return 0;\n\tif ((fp = fopen(strcat(strcpy(alt_filename, prefix), \".alt\"), \"r\")) != 0) { \n\t\tchar str[1024];\n\t\tkhash_t(str) *h;\n\t\tint c, i, absent;\n\t\tkhint_t k;\n\t\th = kh_init(str);\n\t\tfor (i = 0; i < bns->n_seqs; ++i) {\n\t\t\tk = kh_put(str, h, bns->anns[i].name, &absent);\n\t\t\tkh_val(h, k) = i;\n\t\t}\n\t\ti = 0;\n\t\twhile ((c = fgetc(fp)) != EOF) {\n\t\t\tif (c == '\\t' || c == '\\n' || c == '\\r') {\n\t\t\t\tstr[i] = 0;\n\t\t\t\tif (str[0] != '@') {\n\t\t\t\t\tk = kh_get(str, h, str);\n\t\t\t\t\tif (k != kh_end(h))\n\t\t\t\t\t\tbns->anns[kh_val(h, k)].is_alt = 1;\n\t\t\t\t}\n\t\t\t\twhile (c != '\\n' && c != EOF) c = fgetc(fp);\n\t\t\t\ti = 0;\n\t\t\t} else str[i++] = c; \n\t\t}\n\t\tkh_destroy(str, h);\n\t\tfclose(fp);\n\t}\n\treturn bns;\n}", "target": 1}
{"code": "lzss_size(struct lzss *lzss)\n{\n  return lzss->mask + 1;\n}", "target": 0}
{"code": "Status TransposeShapeFn(InferenceContext* c) {\n  ShapeHandle input = c->input(0);\n  ShapeHandle perm_shape = c->input(1);\n  const Tensor* perm = c->input_tensor(1);\n  DimensionHandle perm_elems = c->NumElements(perm_shape);\n  if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n    c->set_output(0, c->UnknownShape());\n    return Status::OK();\n  }\n  int64_t rank;\n  if (c->RankKnown(input)) {\n    rank = c->Rank(input);\n  } else if (c->ValueKnown(perm_elems)) {\n    rank = c->Value(perm_elems);\n  } else {\n    rank = perm->NumElements();\n  }\n  if (!c->RankKnown(input) && rank < 2) {\n    c->set_output(0, input);\n    return Status::OK();\n  }\n  std::vector<DimensionHandle> dims;\n  dims.resize(rank);\n  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n  TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n  if (perm != nullptr) {\n    std::vector<int64_t> data;\n    if (perm->dtype() == DT_INT32) {\n      data = AsInt64<int32>(perm, rank);\n    } else {\n      data = AsInt64<int64_t>(perm, rank);\n    }\n    for (int32_t i = 0; i < rank; ++i) {\n      int64_t in_idx = data[i];\n      if (in_idx >= rank) {\n        return errors::InvalidArgument(\"perm dim \", in_idx,\n                                       \" is out of range of input rank \", rank);\n      }\n      dims[i] = c->Dim(input, in_idx);\n    }\n  } else {\n    for (int i = 0; i < rank; ++i) {\n      dims[i] = c->UnknownDim();\n    }\n  }\n  c->set_output(0, c->MakeShape(dims));\n  return Status::OK();\n}", "target": 1}
{"code": "methodHandle LinkResolver::linktime_resolve_interface_method_or_null(\n                                                 const LinkInfo& link_info) {\n  EXCEPTION_MARK;\n  methodHandle method_result = linktime_resolve_interface_method(link_info, THREAD);\n  if (HAS_PENDING_EXCEPTION) {\n    CLEAR_PENDING_EXCEPTION;\n    return methodHandle();\n  } else {\n    return method_result;\n  }\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MaxMinBadHintSelectsReverseIndex) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"a\" << -1));\n    runInvalidQueryFull(BSONObj(),\n                        BSONObj(),\n                        BSONObj(),\n                        0,\n                        0,\n                        fromjson(\"{a: 1}\"),\n                        fromjson(\"{a: 8}\"),\n                        fromjson(\"{a: 2}\"));\n}", "target": 0}
{"code": "void SVGDocumentExtensions::serviceAnimations(double monotonicAnimationStartTime)\n{\n    WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> > timeContainers;\n    timeContainers.appendRange(m_timeContainers.begin(), m_timeContainers.end());\n    WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator end = timeContainers.end();\n    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr)\n        (*itr)->timeContainer()->serviceAnimations(monotonicAnimationStartTime);\n}", "target": 0}
{"code": "archive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\tsize_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\tif (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\twhile (*mbs && mbs_length > 0) {\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, wcs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, wcs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t++mbs;\n\t\t\t\t--mbs_length;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\twcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "void php_libxml_issue_error(int level, const char *msg TSRMLS_DC)\n{\n\tif (LIBXML(error_list)) {\n\t\t_php_list_set_error_structure(NULL, msg);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, level, \"%s\", msg);\n\t}\n}", "target": 0}
{"code": "AP_DECLARE(const char *) ap_context_prefix(request_rec *r)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    if (conf->context_prefix)\n        return conf->context_prefix;\n    else\n        return \"\";\n}", "target": 0}
{"code": "static bool net_tx_pkt_do_sw_fragmentation(struct NetTxPkt *pkt,\n    NetClientState *nc)\n{\n    struct iovec fragment[NET_MAX_FRAG_SG_LIST];\n    size_t fragment_len = 0;\n    bool more_frags = false;\n    void *l2_iov_base, *l3_iov_base;\n    size_t l2_iov_len, l3_iov_len;\n    int src_idx =  NET_TX_PKT_PL_START_FRAG, dst_idx;\n    size_t src_offset = 0;\n    size_t fragment_offset = 0;\n    l2_iov_base = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base;\n    l2_iov_len = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len;\n    l3_iov_base = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n    l3_iov_len = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len;\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_base = l2_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_len = l2_iov_len;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_base = l3_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_len = l3_iov_len;\n    do {\n        fragment_len = net_tx_pkt_fetch_fragment(pkt, &src_idx, &src_offset,\n            fragment, &dst_idx);\n        more_frags = (fragment_offset + fragment_len < pkt->payload_len);\n        eth_setup_ip4_fragmentation(l2_iov_base, l2_iov_len, l3_iov_base,\n            l3_iov_len, fragment_len, fragment_offset, more_frags);\n        eth_fix_ip4_checksum(l3_iov_base, l3_iov_len);\n        net_tx_pkt_sendv(pkt, nc, fragment, dst_idx);\n         fragment_offset += fragment_len;\n    } while (more_frags);\n     return true;\n }", "target": 1}
{"code": "void RenderView::didAcceptAutocompleteSuggestion(\n    const WebKit::WebInputElement& user_element) {\n#if defined(WEBKIT_BUG_41283_IS_FIXED)\n  bool result = password_autocomplete_manager_.FillPassword(user_element);\n  DCHECK(result);\n#endif\n}", "target": 0}
{"code": "njs_function_prototype_apply(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t         i, length;\n    njs_int_t       ret;\n    njs_frame_t     *frame;\n    njs_value_t     *this, *arr_like;\n    njs_array_t     *arr;\n    njs_function_t  *func;\n    if (!njs_is_function(njs_argument(args, 0))) {\n        njs_type_error(vm, \"\\\"this\\\" argument is not a function\");\n        return NJS_ERROR;\n    }\n    func = njs_function(njs_argument(args, 0));\n    this = njs_arg(args, nargs, 1);\n    arr_like = njs_arg(args, nargs, 2);\n    if (njs_is_null_or_undefined(arr_like)) {\n        length = 0;\n        goto activate;\n    } else if (njs_is_array(arr_like)) {\n        arr = arr_like->data.u.array;\n        args = arr->start;\n        length = arr->length;\n        goto activate;\n    } else if (njs_slow_path(!njs_is_object(arr_like))) {\n        njs_type_error(vm, \"second argument is not an array-like object\");\n        return NJS_ERROR;\n    }\n    ret = njs_object_length(vm, arr_like, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    arr = njs_array_alloc(vm, 1, length, NJS_ARRAY_SPARE);\n    if (njs_slow_path(arr == NULL)) {\n        return NJS_ERROR;\n    }\n    args = arr->start;\n    for (i = 0; i < length; i++) {\n        ret = njs_value_property_i64(vm, arr_like, i, &args[i]);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n    }\nactivate:\n    vm->top_frame->skip = 1;\n    frame = (njs_frame_t *) vm->top_frame;\n    ret = njs_function_frame(vm, func, this, args, length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_function_frame_invoke(vm, frame->native.retval);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    return NJS_DECLINED;\n}", "target": 1}
{"code": "static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tstruct dwc3_request\t\t*req;\n\tint\t\t\t\tstarting;\n\tint\t\t\t\tret;\n\tu32\t\t\t\tcmd;\n\tif (!dwc3_calc_trbs_left(dep))\n\t\treturn 0;\n\tstarting = !(dep->flags & DWC3_EP_BUSY);\n\tdwc3_prepare_trbs(dep);\n\treq = next_request(&dep->started_list);\n\tif (!req) {\n\t\tdep->flags |= DWC3_EP_PENDING_REQUEST;\n\t\treturn 0;\n\t}\n\tmemset(&params, 0, sizeof(params));\n\tif (starting) {\n\t\tparams.param0 = upper_32_bits(req->trb_dma);\n\t\tparams.param1 = lower_32_bits(req->trb_dma);\n\t\tcmd = DWC3_DEPCMD_STARTTRANSFER;\n\t\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\t\tcmd |= DWC3_DEPCMD_PARAM(dep->frame_number);\n\t} else {\n\t\tcmd = DWC3_DEPCMD_UPDATETRANSFER |\n\t\t\tDWC3_DEPCMD_PARAM(dep->resource_index);\n\t}\n\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\tif (ret < 0) {\n\t\tif (req->trb)\n\t\t\tmemset(req->trb, 0, sizeof(struct dwc3_trb));\n\t\tdep->queued_requests--;\n\t\tdwc3_gadget_giveback(dep, req, ret);\n\t\treturn ret;\n\t}\n\tdep->flags |= DWC3_EP_BUSY;\n\tif (starting) {\n\t\tdep->resource_index = dwc3_gadget_ep_get_transfer_index(dep);\n\t\tWARN_ON_ONCE(!dep->resource_index);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "_tiffReadProc(thandle_t hdata, tdata_t buf, tsize_t size) {\n    TIFFSTATE *state = (TIFFSTATE *)hdata;\n    tsize_t to_read;\n    TRACE((\"_tiffReadProc: %d \\n\", (int)size));\n    dump_state(state);\n    to_read = min(size, min(state->size, (tsize_t)state->eof) - (tsize_t)state->loc);\n    TRACE((\"to_read: %d\\n\", (int)to_read));\n    _TIFFmemcpy(buf, (UINT8 *)state->data + state->loc, to_read);\n    state->loc += (toff_t)to_read;\n    TRACE((\"location: %u\\n\", (uint)state->loc));\n    return to_read;\n}", "target": 1}
{"code": "ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) \n{\n\tzval *property;\n\tif (ce->type & ZEND_INTERNAL_CLASS) {\n\t\tALLOC_PERMANENT_ZVAL(property);\n\t} else {\n\t\tALLOC_ZVAL(property);\n\t}\n\tINIT_PZVAL(property);\n\tZVAL_DOUBLE(property, value);\n\treturn zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);\n}", "target": 0}
{"code": "tiff_document_get_page_size (EvDocument *document,\n\t\t\t     EvPage     *page,\n\t\t\t     double     *width,\n\t\t\t     double     *height)\n{\n\tguint32 w, h;\n\tgfloat x_res, y_res;\n\tTiffDocument *tiff_document = TIFF_DOCUMENT (document);\n\tg_return_if_fail (TIFF_IS_DOCUMENT (document));\n\tg_return_if_fail (tiff_document->tiff != NULL);\n\tpush_handlers ();\n\tif (TIFFSetDirectory (tiff_document->tiff, page->index) != 1) {\n\t\tpop_handlers ();\n\t\treturn;\n\t}\n\tTIFFGetField (tiff_document->tiff, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField (tiff_document->tiff, TIFFTAG_IMAGELENGTH, &h);\n\ttiff_document_get_resolution (tiff_document, &x_res, &y_res);\n\th = h * (x_res / y_res);\n\t*width = w;\n\t*height = h;\n\tpop_handlers ();\n}", "target": 0}
{"code": " void dvb_usbv2_disconnect(struct usb_interface *intf)\n {\n \tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = d->name;\n\tstruct device dev = d->udev->dev;\n \tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n \t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\tif (d->props->exit)\n\t\td->props->exit(d);\n \tdvb_usbv2_exit(d);\n\tdev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\n\t\t\tKBUILD_MODNAME, name);\n }", "target": 1}
{"code": "_cdf_tole2(uint16_t sv)\n{\n\tuint16_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv;\n\tuint8_t *d = (uint8_t *)(void *)&rv;\n\td[0] = s[1];\n\td[1] = s[0];\n\treturn rv;\n}", "target": 0}
{"code": "static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, addr, R_BUF_SET);\n\tmodule->base_of_image = r_buf_read_le64 (b);\n\tmodule->size_of_image = r_buf_read_le32 (b);\n\tmodule->check_sum = r_buf_read_le32 (b);\n\tmodule->time_date_stamp = r_buf_read_le32 (b);\n\tmodule->module_name_rva = r_buf_read_le32 (b);\n\tmodule->version_info.dw_signature = r_buf_read_le32 (b);\n\tmodule->version_info.dw_struc_version = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags_mask = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_os = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_type = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_subtype = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ls = r_buf_read_le32 (b);\n\tmodule->cv_record.data_size = r_buf_read_le32 (b);\n\tmodule->cv_record.rva = r_buf_read_le32 (b);\n\tmodule->misc_record.data_size = r_buf_read_le32 (b);\n\tmodule->misc_record.rva = r_buf_read_le32 (b);\n\tmodule->reserved_0 = r_buf_read_le64 (b);\n\tmodule->reserved_1 = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}", "target": 1}
{"code": "ldns_tsig_keydata(const ldns_tsig_credentials *tc)\n{\n\treturn tc->keydata;\n}", "target": 0}
{"code": "void gdImageGetClip (gdImagePtr im, int *x1P, int *y1P, int *x2P, int *y2P)\n{\n\t*x1P = im->cx1;\n\t*y1P = im->cy1;\n\t*x2P = im->cx2;\n\t*y2P = im->cy2;\n}", "target": 0}
{"code": "process_bitmap_updates(STREAM s)\n{\n\tuint16 num_updates;\n\tint i;\n\tin_uint16_le(s, num_updates);\t\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tprocess_bitmap_data(s);\n\t}\n}", "target": 0}
{"code": "Bool gf_sys_get_battery_state(Bool *onBattery, u32 *onCharge, u32*level, u32 *batteryLifeTime, u32 *batteryFullLifeTime)\n{\n#if defined(_WIN32_WCE)\n\tSYSTEM_POWER_STATUS_EX sps;\n\tGetSystemPowerStatusEx(&sps, 0);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? 0 : 1;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#elif defined(WIN32)\n\tSYSTEM_POWER_STATUS sps;\n\tGetSystemPowerStatus(&sps);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? GF_FALSE : GF_TRUE;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#endif\n\treturn GF_TRUE;\n}", "target": 0}
{"code": "test_validate_path_args (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (invalid_path_args); idx++)\n    {\n      g_autoptr(FlatpakContext) context = flatpak_context_new ();\n      g_autoptr(GError) local_error = NULL;\n      const char *path = invalid_path_args[idx];\n      context_parse_args (context, &local_error, path, NULL);\n      g_assert_error (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n      g_assert (strstr (local_error->message, \"Non-graphical character\"));\n    }\n}", "target": 0}
{"code": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\tint chk_addr_ret;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_l2tpip))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip_lock);\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n\t\tgoto out;\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  \n\tsk_dst_reset(sk);\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\nout:\n\trelease_sock(sk);\n\treturn ret;\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\treturn ret;\n}", "target": 1}
{"code": "static inline bool cpu_has_vmx_pml(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_ENABLE_PML;\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicy::Remove(int renderer_id) {\n  AutoLock lock(lock_);\n  if (!security_state_.count(renderer_id))\n    return;  \n  delete security_state_[renderer_id];\n  security_state_.erase(renderer_id);\n}", "target": 0}
{"code": "XML_MemMalloc(XML_Parser parser, size_t size)\n{\n  if (parser == NULL)\n    return NULL;\n  return MALLOC(parser, size);\n}", "target": 0}
{"code": "NodeListsNodeData& ContainerNode::ensureNodeLists()\n{\n    return ensureRareData().ensureNodeLists();\n}", "target": 0}
{"code": "void AsfVideo::decodeHeader() {\n  DataBuf nbHeadersBuf(DWORD + 1);\n  io_->read(nbHeadersBuf.data(), DWORD);\n  uint32_t nb_headers = Exiv2::getULong(nbHeadersBuf.data(), littleEndian);\n  Internal::enforce(nb_headers < std::numeric_limits<uint32_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  io_->seekOrThrow(io_->tell() + BYTE * 2, BasicIo::beg,\n                   ErrorCode::kerFailedToReadImageData);  \n  for (uint32_t i = 0; i < nb_headers; i++) {\n    decodeBlock();\n  }\n}", "target": 1}
{"code": "void kvm_arch_free_memslot(struct kvm_memory_slot *free,\n\t\t\t   struct kvm_memory_slot *dont)\n{\n\tint i;\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tif (!dont || free->arch.rmap[i] != dont->arch.rmap[i]) {\n\t\t\tkvm_kvfree(free->arch.rmap[i]);\n\t\t\tfree->arch.rmap[i] = NULL;\n\t\t}\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tif (!dont || free->arch.lpage_info[i - 1] !=\n\t\t\t     dont->arch.lpage_info[i - 1]) {\n\t\t\tkvm_kvfree(free->arch.lpage_info[i - 1]);\n\t\t\tfree->arch.lpage_info[i - 1] = NULL;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static inline void map_qs_metadata(struct req_state* s)\n{\n  const auto& params = const_cast<RGWHTTPArgs&>(s->info.args).get_params();\n  for (const auto& elt : params) {\n    std::string k = boost::algorithm::to_lower_copy(elt.first);\n    if (k.find(\"x-amz-meta-\") ==  0) {\n      add_amz_meta_header(s->info.x_meta_map, k, elt.second);\n    }\n  }\n}", "target": 0}
{"code": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length / 2; i++) {\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, 4); \n    s->has_trns = 1;\n    return 0;\n}", "target": 1}
{"code": "char **XListExtensions(\n    register Display *dpy,\n    int *nextensions)\t\n{\n\txListExtensionsReply rep;\n\tchar **list = NULL;\n\tchar *ch = NULL;\n\tchar *chend;\n\tint count = 0;\n\tregister unsigned i;\n\tregister int length;\n\t_X_UNUSED register xReq *req;\n\tunsigned long rlen = 0;\n\tLockDisplay(dpy);\n\tGetEmptyReq (ListExtensions, req);\n\tif (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\tif (rep.nExtensions) {\n\t    list = Xmalloc (rep.nExtensions * sizeof (char *));\n\t    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t\trlen = rep.length << 2;\n\t\tch = Xmalloc (rlen + 1);\n\t    }\n\t    if ((!list) || (!ch)) {\n\t\tXfree(list);\n\t\tXfree(ch);\n\t\t_XEatDataWords(dpy, rep.length);\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn (char **) NULL;\n\t    }\n\t    _XReadPad (dpy, ch, rlen);\n \t    chend = ch + rlen;\n\t    length = *ch;\n \t    for (i = 0; i < rep.nExtensions; i++) {\n \t\tif (ch + length < chend) {\n \t\t    list[i] = ch+1;  \n \t\t    ch += length + 1; \n\t\t    length = *ch;\n \t\t    *ch = '\\0'; \n \t\t    count++;\n \t\t} else\n\t\t    list[i] = NULL;\n\t    }\n\t}\n\t*nextensions = count;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (list);\n}", "target": 1}
{"code": "gimp_channel_get_memsize (GimpObject *object,\n                          gint64     *gui_size)\n{\n  GimpChannel *channel = GIMP_CHANNEL (object);\n  *gui_size += channel->num_segs_in  * sizeof (GimpBoundSeg);\n  *gui_size += channel->num_segs_out * sizeof (GimpBoundSeg);\n  return GIMP_OBJECT_CLASS (parent_class)->get_memsize (object, gui_size);\n}", "target": 0}
{"code": "void Clipboard::WriteText(const char* text_data, size_t text_len) {\n  char* data = new char[text_len];\n  memcpy(data, text_data, text_len);\n  InsertMapping(kMimeTypeText, data, text_len);\n  InsertMapping(\"TEXT\", data, text_len);\n  InsertMapping(\"STRING\", data, text_len);\n  InsertMapping(\"UTF8_STRING\", data, text_len);\n  InsertMapping(\"COMPOUND_TEXT\", data, text_len);\n}", "target": 0}
{"code": "PHP_METHOD(snmp, setSecurity)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tchar *a1 = \"\", *a2 = \"\", *a3 = \"\", *a4 = \"\", *a5 = \"\", *a6 = \"\", *a7 = \"\";\n\tsize_t a1_len = 0, a2_len = 0, a3_len = 0, a4_len = 0, a5_len = 0, a6_len = 0, a7_len = 0;\n\tint argc = ZEND_NUM_ARGS();\n\tsnmp_object = Z_SNMP_P(object);\n\tif (zend_parse_parameters(argc, \"s|ssssss\", &a1, &a1_len, &a2, &a2_len, &a3, &a3_len,\n\t\t&a4, &a4_len, &a5, &a5_len, &a6, &a6_len, &a7, &a7_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (netsnmp_session_set_security(snmp_object->session, a1, a2, a3, a4, a5, a6, a7)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "bool RenderView::allowImages(WebFrame* frame, bool enabled_per_settings) {\n  if (enabled_per_settings &&\n      AllowContentType(CONTENT_SETTINGS_TYPE_IMAGES))\n    return true;\n  if (IsWhitelistedForContentSettings(frame))\n    return true;\n  DidBlockContentType(CONTENT_SETTINGS_TYPE_IMAGES);\n  return false;  \n}", "target": 0}
{"code": "static void cleanup_async_copy(struct nfsd4_copy *copy)\n{\n\tnfs4_free_cp_state(copy);\n\tfput(copy->file_dst);\n\tfput(copy->file_src);\n\tspin_lock(&copy->cp_clp->async_lock);\n\tlist_del(&copy->copies);\n\tspin_unlock(&copy->cp_clp->async_lock);\n\tnfs4_put_copy(copy);\n}", "target": 0}
{"code": "static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n \t\tgoto err;\n \tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n \t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n \t\tgoto out;\n \t}\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\trcu_assign_pointer(*pp, p);\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "NCR_ModifyPolltarget(NCR_Instance inst, int new_poll_target)\n{\n  inst->poll_target = new_poll_target;\n  LOG(LOGS_INFO, LOGF_NtpCore, \"Source %s new polltarget %d\",\n      UTI_IPToString(&inst->remote_addr.ip_addr), new_poll_target);\n}", "target": 0}
{"code": "TEST(QuantizedPoolingOpTest, AveragePoolImageSize17) {\n  int image_size = 17;\n  QuantizedPoolingOpModel m(\n      BuiltinOperator_AVERAGE_POOL_2D,\n      {TensorType_UINT8, {1, image_size, image_size, 1}, 0, 16},\n      image_size,\n      image_size,\n      {TensorType_UINT8, {}, 0, 16});\n  std::vector<float> input(image_size * image_size, 16.f);\n  m.SetInput(input);\n  m.Invoke();\n  EXPECT_THAT(m.GetOutput(), ::testing::ElementsAre(255));\n}", "target": 0}
{"code": "void Shell::RotateFocus(Direction direction) {\n  focus_cycler_->RotateFocus(direction == FORWARD ? FocusCycler::FORWARD\n                                                  : FocusCycler::BACKWARD);\n}", "target": 0}
{"code": " int vfs_open(const struct path *path, struct file *file,\n \t     const struct cred *cred)\n {\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n \treturn do_dentry_open(file, inode, NULL, cred);\n }", "target": 1}
{"code": "static inline void show_node(struct zone *zone)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tprintk(\"Node %d \", zone_to_nid(zone));\n}", "target": 0}
{"code": "_eddsa_hash (const struct ecc_modulo *m,\n\t     mp_limb_t *rp, size_t digest_size, const uint8_t *digest)\n{\n  mp_size_t nlimbs = (8*digest_size + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;\n  mpn_set_base256_le (rp, nlimbs, digest, digest_size);\n  if (nlimbs > 2*m->size)\n    {\n      mp_limb_t hi = rp[2*m->size];\n      assert (nlimbs == 2*m->size + 1);\n      hi = mpn_addmul_1 (rp + m->size, m->B, m->size, hi);\n      assert (hi <= 1);\n      hi = mpn_cnd_add_n (hi, rp + m->size, rp + m->size, m->B, m->size);\n      assert (hi == 0);\n    }\n  m->mod (m, rp, rp);\n}", "target": 1}
{"code": "monitor_init(void)\n{\n\tstruct ssh *ssh = active_state;\t\t\t\n\tstruct monitor *mon;\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\tif (options.compression) {\n\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n\treturn mon;\n}", "target": 1}
{"code": "void base64_decode_xmlrpc(struct buffer_st *bfr, const char *source, int length)\n{\n    int i;\n    int offset = 0;\n    int endoffile;\n    int count;\n    buffer_new(bfr);\n    for (i = 0; i < 255; i++) {\n\tdtable[i] = 0x80;\n    }\n    for (i = 'A'; i <= 'Z'; i++) {\n        dtable[i] = 0 + (i - 'A');\n    }\n    for (i = 'a'; i <= 'z'; i++) {\n        dtable[i] = 26 + (i - 'a');\n    }\n    for (i = '0'; i <= '9'; i++) {\n        dtable[i] = 52 + (i - '0');\n    }\n    dtable['+'] = 62;\n    dtable['/'] = 63;\n    dtable['='] = 0;\n    endoffile = 0;\n    while (1) {\n\tunsigned char a[4], b[4], o[3];\n\tfor (i = 0; i < 4; i++) {\n\t    int c;\n\t    while (1) {\n\t      c = *(source++);\n\t      offset++;\n\t      if (offset > length) endoffile = 1;\n\t      if (isspace(c) || c == '\\n' || c == '\\r') continue;\n\t      break;\n\t    }\n\t    if (endoffile) {\n\t\treturn;\n\t    }\n\t    if (dtable[c] & 0x80) {\n\t      i--;\n\t      continue;\n\t    }\n\t    a[i] = (unsigned char) c;\n\t    b[i] = (unsigned char) dtable[c];\n\t}\n\to[0] = (b[0] << 2) | (b[1] >> 4);\n\to[1] = (b[1] << 4) | (b[2] >> 2);\n\to[2] = (b[2] << 6) | b[3];\n        i = a[2] == '=' ? 1 : (a[3] == '=' ? 2 : 3);\n\tcount = 0;\n\twhile (count < i) {\n\t  buffer_add(bfr, o[count++]);\n\t}\n\tif (i < 3) {\n\t    return;\n\t}\n    }\n}", "target": 1}
{"code": "static inline int ip_ufo_append_data(struct sock *sk,\n\t\t\tstruct sk_buff_head *queue,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\t       int odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int maxfraglen, unsigned int flags)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tif ((skb = skb_peek_tail(queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n \t\tskb->transport_header = skb->network_header + fragheaderlen;\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n \t\tskb->csum = 0;\n\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n \t\t__skb_queue_tail(queue, skb);\n \t}\n \treturn skb_append_datato_frags(sk, skb, getfrag, from,\n \t\t\t\t       (length - transhdrlen));\n }", "target": 1}
{"code": "  psh_glyph_find_strong_points( PSH_Glyph  glyph,\n                                FT_Int     dimension )\n  {\n    PSH_Hint_Table  table     = &glyph->hint_tables[dimension];\n    PS_Mask         mask      = table->hint_masks->masks;\n    FT_UInt         num_masks = table->hint_masks->num_masks;\n    FT_UInt         first     = 0;\n    FT_Int          major_dir = dimension == 0 ? PSH_DIR_VERTICAL\n                                               : PSH_DIR_HORIZONTAL;\n    PSH_Dimension   dim       = &glyph->globals->dimension[dimension];\n    FT_Fixed        scale     = dim->scale_mult;\n    FT_Int          threshold;\n    threshold = (FT_Int)FT_DivFix( PSH_STRONG_THRESHOLD, scale );\n    if ( threshold > PSH_STRONG_THRESHOLD_MAXIMUM )\n      threshold = PSH_STRONG_THRESHOLD_MAXIMUM;\n     if ( num_masks > 1 && glyph->num_points > 0 )\n     {\n      first = mask->end_point;\n       mask++;\n       for ( ; num_masks > 1; num_masks--, mask++ )\n       {\n        next  = mask->end_point;\n         FT_Int   count;\n        next  = mask->end_point;\n         count = next - first;\n         if ( count > 0 )\n         {\n                                             threshold, major_dir );\n        }\n        first = next;\n      }\n    }\n    if ( num_masks == 1 )\n    {\n      FT_UInt    count = glyph->num_points;\n      PSH_Point  point = glyph->points;\n      psh_hint_table_activate_mask( table, table->hint_masks->masks );\n      psh_hint_table_find_strong_points( table, point, count,\n                                         threshold, major_dir );\n    }\n    {\n      FT_UInt    count = glyph->num_points;\n      PSH_Point  point = glyph->points;\n      for ( ; count > 0; count--, point++ )\n        if ( point->hint && !psh_point_is_strong( point ) )\n          psh_point_set_strong( point );\n    }\n  }", "target": 1}
{"code": "static void kvm_get_wallclock(struct timespec *now)\n{\n\tstruct pvclock_vcpu_time_info *vcpu_time;\n\tint low, high;\n\tint cpu;\n\tlow = (int)__pa_symbol(&wall_clock);\n\thigh = ((u64)__pa_symbol(&wall_clock) >> 32);\n\tnative_write_msr(msr_kvm_wall_clock, low, high);\n\tcpu = get_cpu();\n\tvcpu_time = &hv_clock[cpu].pvti;\n\tpvclock_read_wallclock(&wall_clock, vcpu_time, now);\n\tput_cpu();\n}", "target": 0}
{"code": "static krb5_error_code hdb_samba4_lock(krb5_context context, HDB *db, int operation)\n{\n\treturn 0;\n}", "target": 0}
{"code": "static const char *req_path_info_field(request_rec *r)\n{\n    return r->path_info;\n}", "target": 0}
{"code": "dwarf_select_sections_by_names (const char *names)\n{\n  const char *p;\n  int result = 0;\n  p = names;\n  while (*p)\n    {\n      const debug_dump_long_opts *entry;\n      for (entry = debug_option_table; entry->option; entry++)\n\t{\n\t  size_t len = strlen (entry->option);\n\t  if (strncmp (p, entry->option, len) == 0\n\t      && (p[len] == ',' || p[len] == '\\0'))\n\t    {\n\t      * entry->variable = entry->val;\n\t      result |= entry->val;\n\t      p += len;\n\t      break;\n\t    }\n\t}\n      if (entry->option == NULL)\n\t{\n\t  warn (_(\"Unrecognized debug option '%s'\\n\"), p);\n\t  p = strchr (p, ',');\n\t  if (p == NULL)\n\t    break;\n\t}\n      if (*p == ',')\n\tp++;\n    }\n  if (do_debug_frames_interp)\n    do_debug_frames = 1;\n  return result;\n}", "target": 0}
{"code": "LogFilePrep(const char *fname, const char *backup, const char *idstring)\n{\n    char *logFileName = NULL;\n    if (asprintf(&logFileName, fname, idstring) == -1)\n        FatalError(\"Cannot allocate space for the log file name\\n\");\n    if (backup && *backup) {\n        struct stat buf;\n        if (!stat(logFileName, &buf) && S_ISREG(buf.st_mode)) {\n            char *suffix;\n            char *oldLog;\n            if ((asprintf(&suffix, backup, idstring) == -1) ||\n                (asprintf(&oldLog, \"%s%s\", logFileName, suffix) == -1)) {\n                FatalError(\"Cannot allocate space for the log file name\\n\");\n            }\n            free(suffix);\n            if (rename(logFileName, oldLog) == -1) {\n                FatalError(\"Cannot move old log file \\\"%s\\\" to \\\"%s\\\"\\n\",\n                           logFileName, oldLog);\n            }\n            free(oldLog);\n        }\n    }\n    else {\n        if (remove(logFileName) != 0 && errno != ENOENT) {\n            FatalError(\"Cannot remove old log file \\\"%s\\\": %s\\n\",\n                       logFileName, strerror(errno));\n        }\n    }\n    return logFileName;\n}", "target": 1}
{"code": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *mac_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\tint type = skb_shinfo(skb)->gso_type;\n\t\tif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n \tskb->ip_summed = CHECKSUM_NONE;\n\tif ((skb_headroom(skb) < frag_hdr_sz) &&\n \t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n \t\tgoto out;\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +\n\t\t     unfrag_ip6hlen;\n\tmac_start = skb_mac_header(skb);\n\tmemmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);\n\tskb->mac_header -= frag_hdr_sz;\n\tskb->network_header -= frag_hdr_sz;\n\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\tfptr->nexthdr = nexthdr;\n\tfptr->reserved = 0;\n\tipv6_select_ident(fptr);\n\tsegs = skb_segment(skb, features);\nout:\n\treturn segs;\n}", "target": 1}
{"code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\tif (line == NULL)\n\t\t\treturn;\n\t\tfilter_data(fs->id, line);\n\t\tgoto nextline;\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "zsetpagedevice(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    int code;\n    if (r_has_type(op, t_dictionary)) {\n        check_dict_read(*op);\n#if 0\t\n        if (!(r_is_local(op)))\n            return_error(gs_error_invalidaccess);\n#endif\t\n        code = zreadonly(i_ctx_p);\n        if (code < 0)\n            return code;\n    } else {\n        check_type(*op, t_null);\n    }\n    istate->pagedevice = *op;\n    pop(1);\n    return 0;\n}", "target": 0}
{"code": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n \tgpio_dev = platform_get_drvdata(pdev);\n \tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n \treturn 0;\n }", "target": 1}
{"code": "TEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4151 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)\n{\n    size_t realsize = 0;\n    connection_t *conn = NULL;\n    char *ptr = NULL;\n    conn = data;\n    ogs_assert(conn);\n    realsize = size * nmemb;\n    ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);\n    if(!ptr) {\n        ogs_fatal(\"not enough memory (realloc returned NULL)\");\n        ogs_assert_if_reached();\n        return 0;\n    }\n    conn->memory = ptr;\n    memcpy(&(conn->memory[conn->size]), contents, realsize);\n    conn->size += realsize;\n    conn->memory[conn->size] = 0;\n    return realsize;\n}", "target": 1}
{"code": "static void irda_connect_indication(void *instance, void *sap,\n\t\t\t\t    struct qos_info *qos, __u32 max_sdu_size,\n\t\t\t\t    __u8 max_header_size, struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tself = instance;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tself->max_header_size = max_header_size;\n\tself->max_sdu_size_tx = max_sdu_size;\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (max_sdu_size != 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size must be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif (max_sdu_size == 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size cannot be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = max_sdu_size;\n\t\tbreak;\n\tdefault:\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t}\n\tIRDA_DEBUG(2, \"%s(), max_data_size=%d\\n\", __func__,\n\t\t   self->max_data_size);\n\tmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_state_change(sk);\n}", "target": 0}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n \tint count, i;\n \tcount = be32_to_cpu(aclp->acl_cnt);\n \tacl = posix_acl_alloc(count, GFP_KERNEL);\n \tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "  Compound_Selector_Obj Parser::parse_compound_selector()\n  {\n    Compound_Selector_Obj seq = SASS_MEMORY_NEW(Compound_Selector, pstate);\n    seq->media_block(last_media_block);\n    lex< css_whitespace >();\n    while (true)\n    {\n      lex< delimited_by< slash_star, star_slash, false > >(false);\n      if (match < re_pseudo_selector >())\n      {\n        seq->append(parse_simple_selector());\n      }\n      else if (lex< exactly<'&'> >(false))\n      {\n        if (!allow_parent) error(\"Parent selectors aren't allowed here.\");\n        seq->has_parent_reference(true);\n        seq->append(SASS_MEMORY_NEW(Parent_Selector, pstate));\n        if (seq->length() > 1) {\n          ParserState state(pstate);\n          Simple_Selector_Obj cur = (*seq)[seq->length()-1];\n          Simple_Selector_Obj prev = (*seq)[seq->length()-2];\n          std::string sel(prev->to_string({ NESTED, 5 }));\n          std::string found(cur->to_string({ NESTED, 5 }));\n          if (lex < identifier >()) { found += std::string(lexed); }\n          error(\"Invalid CSS after \\\"\" + sel + \"\\\": expected \\\"{\\\", was \\\"\" + found + \"\\\"\\n\\n\"\n            \"\\\"\" + found + \"\\\" may only be used at the beginning of a compound selector.\", state);\n        }\n      }\n      else if (lex< re_type_selector >(false))\n      {\n        seq->append(SASS_MEMORY_NEW(Type_Selector, pstate, lexed));\n      }\n      else if (peek< spaces >()) break;\n      else if (peek< end_of_file >()) { break; }\n      else if (peek_css < class_char < selector_combinator_ops > >()) break;\n      else if (peek_css < class_char < complex_selector_delims > >()) break;\n      else {\n        Simple_Selector_Obj sel = parse_simple_selector();\n        if (!sel) return {};\n        seq->append(sel);\n      }\n    }\n    if (seq && !peek_css<alternatives<end_of_file,exactly<'{'>>>()) {\n      seq->has_line_break(peek_newline());\n    }\n    return seq;\n  }", "target": 0}
{"code": "set_num_712(unsigned char *p, char value)\n{\n\t*((char *)p) = value;\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::OnDisplayBoundsChanged(\n    const gfx::Display& display) {\n  gfx::Screen* screen = gfx::Screen::GetScreenFor(window_);\n  if (display.id() == screen->GetDisplayNearestWindow(window_).id()) {\n    UpdateScreenInfo(window_);\n    current_cursor_.SetDisplayInfo(display);\n    UpdateCursorIfOverSelf();\n  }\n}", "target": 0}
{"code": "BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\t\tif (stream_get_left(s) < 12)\n\t\t\treturn FALSE;\n\t\tstream_read_UINT16(s, len); \n\t\tstream_read_BYTE(s, version); \n\t\tstream_read_BYTE(s, pad);\n\t\tsig = s->p;\n\t\tstream_seek(s, 8);\t\n\t\tlength -= 12;\n\t\tif (!security_fips_decrypt(s->p, length, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: cannot decrypt\\n\");\n\t\t\treturn FALSE; \n\t\t}\n\t\tif (!security_fips_check_signature(s->p, length - pad, sig, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: invalid packet signature\\n\");\n\t\t\treturn FALSE; \n\t\t}\n\t\ts->size -= pad;\n\t\treturn TRUE;\n\t}\n\tif (stream_get_left(s) < 8)\n\t\treturn FALSE;\n\tstream_read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\tsecurity_decrypt(s->p, length, rdp);\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\n\telse\n\t\tsecurity_mac_signature(rdp, s->p, length, cmac);\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tprintf(\"WARNING: invalid packet signature\\n\");\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (!chip)\n\t\treturn -ENODEV;\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n \t\treturn -EBUSY;\n \t}\n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n \tif (chip->data_buffer == NULL) {\n \t\tclear_bit(0, &chip->is_open);\n \t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&chip->data_pending, 0);\n\tfile->private_data = chip;\n\treturn 0;\n}", "target": 1}
{"code": "hb_buffer_destroy (hb_buffer_t *buffer)\n{\n  HB_OBJECT_DO_DESTROY (buffer);\n  hb_unicode_funcs_destroy (buffer->unicode);\n  free (buffer->info);\n  free (buffer->pos);\n  free (buffer);\n}", "target": 0}
{"code": "IOBasicTypes::LongFilePositionType ObjectByteWriterWithPosition::GetCurrentPosition()\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"getCurrentPosition\")).ToLocalChecked();\n    if(value->IsUndefined())\n        return true;\n    Local<Function> func = Local<Function>::Cast(value);\n\treturn TO_NUMBER(func->Call(GET_CURRENT_CONTEXT, OBJECT_FROM_PERSISTENT(mObject), 0, NULL).ToLocalChecked())->Value();\n}", "target": 1}
{"code": "static void setup_private_mount(const char *snap_name)\n{\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tchar tmpdir[MAX_BUF] = { 0 };\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"/tmp/snap.%s_XXXXXX\", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie(\"cannot create temporary directory essential for private /tmp\");\n\t}\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"%s/tmp\", d);\n\tfree(d);\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie(\"cannot create temporary directory for private /tmp\");\n\t}\n\tumask(old_mask);\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie(\"cannot get current working directory\");\n\tif (chdir(\"/\") != 0)\n\t\tdie(\"cannot change directory to '/'\");\n\tsc_do_mount(tmpdir, \"/tmp\", NULL, MS_BIND, NULL);\n\tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n\tif (chown(\"/tmp/\", uid, gid) < 0) {\n\t\tdie(\"cannot change ownership of /tmp\");\n\t}\n\tif (chdir(pwd) != 0)\n\t\tdie(\"cannot change current working directory to the original directory\");\n\tfree(pwd);\n}", "target": 1}
{"code": "  bool empty() const override { return value_ == nullptr ? true : value_->empty(); }", "target": 0}
{"code": "int test(char *URL)\n{\n  int errors = 0;\n  (void)URL; \n  errors += test_weird_arguments();\n  errors += test_unsigned_short_formatting();\n  errors += test_signed_short_formatting();\n  errors += test_unsigned_int_formatting();\n  errors += test_signed_int_formatting();\n  errors += test_unsigned_long_formatting();\n  errors += test_signed_long_formatting();\n  errors += test_curl_off_t_formatting();\n  errors += test_string_formatting();\n  errors += test_float_formatting();\n  if(errors)\n    return TEST_ERR_MAJOR_BAD;\n  else\n    return 0;\n}", "target": 0}
{"code": "xfs_queue_eofblocks(\n\tstruct xfs_mount *mp)\n{\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_EOFBLOCKS_TAG))\n\t\tqueue_delayed_work(mp->m_eofblocks_workqueue,\n\t\t\t\t   &mp->m_eofblocks_work,\n\t\t\t\t   msecs_to_jiffies(xfs_eofb_secs * 1000));\n\trcu_read_unlock();\n}", "target": 0}
{"code": "static int ion_handle_put_nolock(struct ion_handle *handle)\n{\n\tint ret;\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\treturn ret;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 1}
{"code": "bool ParseAttrValue(StringPiece type, StringPiece text, AttrValue* out) {\n  string field_name;\n  bool is_list = absl::ConsumePrefix(&type, \"list(\");\n  if (absl::ConsumePrefix(&type, \"string\")) {\n    field_name = \"s\";\n  } else if (absl::ConsumePrefix(&type, \"int\")) {\n    field_name = \"i\";\n  } else if (absl::ConsumePrefix(&type, \"float\")) {\n    field_name = \"f\";\n  } else if (absl::ConsumePrefix(&type, \"bool\")) {\n    field_name = \"b\";\n  } else if (absl::ConsumePrefix(&type, \"type\")) {\n    field_name = \"type\";\n  } else if (absl::ConsumePrefix(&type, \"shape\")) {\n    field_name = \"shape\";\n  } else if (absl::ConsumePrefix(&type, \"tensor\")) {\n    field_name = \"tensor\";\n  } else if (absl::ConsumePrefix(&type, \"func\")) {\n    field_name = \"func\";\n  } else if (absl::ConsumePrefix(&type, \"placeholder\")) {\n    field_name = \"placeholder\";\n  } else {\n    return false;\n  }\n  if (is_list && !absl::ConsumePrefix(&type, \")\")) {\n    return false;\n  }\n  string to_parse;\n  if (is_list) {\n    StringPiece cleaned = text;\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    str_util::RemoveTrailingWhitespace(&cleaned);\n    if (cleaned.size() < 2 || cleaned[0] != '[' ||\n        cleaned[cleaned.size() - 1] != ']') {\n      return false;\n    }\n    cleaned.remove_prefix(1);\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    if (cleaned.size() == 1) {\n      out->Clear();\n      out->mutable_list();\n      return true;\n    }\n    to_parse = strings::StrCat(\"list { \", field_name, \": \", text, \" }\");\n  } else {\n    to_parse = strings::StrCat(field_name, \": \", text);\n  }\n  return ProtoParseFromString(to_parse, out);\n}", "target": 1}
{"code": "static int dns_stream_complete(DnsStream *s, int error) {\n        assert(s);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n        if (s->complete)\n                s->complete(s, error);\n        else \n                dns_stream_unref(s);\n        return 0;\n}", "target": 1}
{"code": "    Olympus2MnHeader::Olympus2MnHeader()\n    {\n        read(signature_, sizeOfSignature(), invalidByteOrder);\n    }", "target": 0}
{"code": "static int adis_update_scan_mode_burst(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tunsigned int burst_length;\n\tu8 *tx;\n\tburst_length = (indio_dev->num_channels - 1) * sizeof(u16);\n\tburst_length += adis->burst->extra_len;\n\tadis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\ttx = adis->buffer + burst_length;\n\ttx[0] = ADIS_READ_REG(adis->burst->reg_cmd);\n\ttx[1] = 0;\n\tadis->xfer[0].tx_buf = tx;\n\tadis->xfer[0].bits_per_word = 8;\n\tadis->xfer[0].len = 2;\n\tadis->xfer[1].rx_buf = adis->buffer;\n\tadis->xfer[1].bits_per_word = 8;\n\tadis->xfer[1].len = burst_length;\n\tspi_message_init(&adis->msg);\n\tspi_message_add_tail(&adis->xfer[0], &adis->msg);\n\tspi_message_add_tail(&adis->xfer[1], &adis->msg);\n\treturn 0;\n}", "target": 1}
{"code": "static void check_preempt_wakeup(struct rq *rq, struct task_struct *p)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(curr);\n\tstruct sched_entity *se = &curr->se, *pse = &p->se;\n\tunsigned long gran;\n\tif (unlikely(rt_prio(p->prio))) {\n\t\tupdate_rq_clock(rq);\n\t\tupdate_curr(cfs_rq);\n\t\tresched_task(curr);\n\t\treturn;\n\t}\n\tcfs_rq_of(pse)->next = pse;\n\tif (unlikely(p->policy == SCHED_BATCH))\n\t\treturn;\n\tif (!sched_feat(WAKEUP_PREEMPT))\n\t\treturn;\n\twhile (!is_same_group(se, pse)) {\n\t\tse = parent_entity(se);\n\t\tpse = parent_entity(pse);\n\t}\n\tgran = sysctl_sched_wakeup_granularity;\n\tif (unlikely(se->load.weight > NICE_0_LOAD))\n\t\tgran = calc_delta_fair(gran, &se->load);\n\tif (pse->vruntime + gran < se->vruntime)\n\t\tresched_task(curr);\n}", "target": 0}
{"code": "static inline void skb_init_secmark(struct sk_buff *skb)\n{ }", "target": 0}
{"code": "static void f_parser (lua_State *L, void *ud) {\n  int i;\n  Proto *tf;\n  Closure *cl;\n   struct SParser *p = cast(struct SParser *, ud);\n   int c = luaZ_lookahead(p->z);\n   luaC_checkGC(L);\n  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,\n                                                              &p->buff, p->name);\n   cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));\n   cl->l.p = tf;\n  for (i = 0; i < tf->nups; i++)  \n    cl->l.upvals[i] = luaF_newupval(L);\n  setclvalue(L, L->top, cl);\n  incr_top(L);\n}", "target": 1}
{"code": "fetch_indexed_string (dwarf_vma           idx,\n\t\t      struct cu_tu_set *  this_set,\n\t\t      dwarf_vma           offset_size,\n\t\t      bool                dwo,\n\t\t      dwarf_vma           str_offsets_base)\n{\n  enum dwarf_section_display_enum str_sec_idx = dwo ? str_dwo : str;\n  enum dwarf_section_display_enum idx_sec_idx = dwo ? str_index_dwo : str_index;\n  struct dwarf_section *index_section = &debug_displays [idx_sec_idx].section;\n  struct dwarf_section *str_section = &debug_displays [str_sec_idx].section;\n  dwarf_vma index_offset;\n  dwarf_vma str_offset;\n  const char * ret;\n  if (index_section->start == NULL)\n    return (dwo ? _(\"<no .debug_str_offsets.dwo section>\")\n\t\t: _(\"<no .debug_str_offsets section>\"));\n  if (str_section->start == NULL)\n    return (dwo ? _(\"<no .debug_str.dwo section>\")\n\t\t: _(\"<no .debug_str section>\"));\n  index_offset = idx * offset_size;\n  if (this_set != NULL)\n    index_offset += this_set->section_offsets [DW_SECT_STR_OFFSETS];\n  index_offset += str_offsets_base;\n  if (index_offset + offset_size > index_section->size)\n    {\n      warn (_(\"string index of %s converts to an offset of 0x%s which is too big for section %s\"),\n\t    dwarf_vmatoa (\"d\", idx),\n\t    dwarf_vmatoa (\"x\", index_offset),\n\t    str_section->name);\n      return _(\"<string index too big>\");\n    }\n  str_offset = byte_get (index_section->start + index_offset, offset_size);\n  str_offset -= str_section->address;\n  if (str_offset >= str_section->size)\n    {\n      warn (_(\"indirect offset too big: 0x%s\\n\"),\n\t    dwarf_vmatoa (\"x\", str_offset));\n      return _(\"<indirect index offset is too big>\");\n    }\n  ret = (const char *) str_section->start + str_offset;\n  if (strnlen (ret, str_section->size - str_offset)\n      == str_section->size - str_offset)\n    return _(\"<no NUL byte at end of section>\");\n  return ret;\n}", "target": 0}
{"code": "    void DateValue::setDate(const Date& src)\n    {\n        date_.year = src.year;\n        date_.month = src.month;\n        date_.day = src.day;\n    }", "target": 0}
{"code": "ospf6_print_lshdr(netdissect_options *ndo,\n                  register const struct lsa6_hdr *lshp, const u_char *dataend)\n{\n\tif ((const u_char *)(lshp + 1) > dataend)\n\t\tgoto trunc;\n\tND_TCHECK(lshp->ls_type);\n\tND_TCHECK(lshp->ls_seq);\n\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s, seq 0x%08x, age %us, length %u\",\n               ipaddr_string(ndo, &lshp->ls_router),\n               EXTRACT_32BITS(&lshp->ls_seq),\n               EXTRACT_16BITS(&lshp->ls_age),\n               EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr)));\n\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid);\n\treturn (0);\ntrunc:\n\treturn (1);\n}", "target": 1}
{"code": "JANET_CORE_FN(cfun_array_new_filled,\n              \"(array/new-filled count &opt value)\",\n              \"Creates a new array of `count` elements, all set to `value`, which defaults to nil. Returns the new array.\") {\n    janet_arity(argc, 1, 2);\n    int32_t count = janet_getinteger(argv, 0);\n    if (count < 0) janet_panic(\"expected positive integer\");\n    Janet x = (argc == 2) ? argv[1] : janet_wrap_nil();\n    JanetArray *array = janet_array(count);\n    for (int32_t i = 0; i < count; i++) {\n        array->data[i] = x;\n    }\n    array->count = count;\n    return janet_wrap_array(array);\n}", "target": 0}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "void OmniboxViewWin::RepaintDropHighlight(int position) {\n  if ((position != -1) && (position <= GetTextLength())) {\n    const POINT min_loc(PosFromChar(position));\n    const RECT highlight_bounds = {min_loc.x - 1, font_y_adjustment_,\n        min_loc.x + 2, font_.GetHeight() + font_y_adjustment_};\n    InvalidateRect(&highlight_bounds, false);\n  }\n}", "target": 0}
{"code": "__mem_cgroup_commit_charge_swapin(struct page *page, struct mem_cgroup *memcg,\n\t\t\t\t\tenum charge_type ctype)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tif (!memcg)\n\t\treturn;\n\tcgroup_exclude_rmdir(&memcg->css);\n\t__mem_cgroup_commit_charge_lrucare(page, memcg, ctype);\n\tif (do_swap_account && PageSwapCache(page)) {\n\t\tswp_entry_t ent = {.val = page_private(page)};\n\t\tstruct mem_cgroup *swap_memcg;\n\t\tunsigned short id;\n\t\tid = swap_cgroup_record(ent, 0);\n\t\trcu_read_lock();\n\t\tswap_memcg = mem_cgroup_lookup(id);\n\t\tif (swap_memcg) {\n\t\t\tif (!mem_cgroup_is_root(swap_memcg))\n\t\t\t\tres_counter_uncharge(&swap_memcg->memsw,\n\t\t\t\t\t\t     PAGE_SIZE);\n\t\t\tmem_cgroup_swap_statistics(swap_memcg, false);\n\t\t\tmem_cgroup_put(swap_memcg);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tcgroup_release_and_wakeup_rmdir(&memcg->css);\n}", "target": 0}
{"code": "void Huff_transmit (huff_t *huff, int ch, byte *fout) {\n\tint i;\n\tif (huff->loc[ch] == NULL) { \n\t\tHuff_transmit(huff, NYT, fout);\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tadd_bit((char)((ch >> i) & 0x1), fout);\n\t\t}\n\t} else {\n\t\tsend(huff->loc[ch], NULL, fout);\n\t}\n}", "target": 1}
{"code": "my_bool STDCALL mysql_stmt_free_result(MYSQL_STMT *stmt)\n{\n  DBUG_ENTER(\"mysql_stmt_free_result\");\n  DBUG_RETURN(reset_stmt_handle(stmt, RESET_LONG_DATA | RESET_STORE_RESULT |\n                                RESET_CLEAR_ERROR));\n}", "target": 0}
{"code": "int LibRaw::is_jpeg_thumb()\n{\n  return thumb_load_raw == 0 && write_thumb == &LibRaw::jpeg_thumb;\n}", "target": 0}
{"code": "atol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}", "target": 1}
{"code": "static int adpt_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tstruct adpt_device* d;\n\tint id;\n\tint chan;\n\tadpt_hba* pHba;\n\tint unit;\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->host == host) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tmutex_unlock(&adpt_configuration_lock);\n\tif (pHba == NULL) {\n\t\treturn 0;\n\t}\n\thost = pHba->host;\n\tseq_printf(m, \"Adaptec I2O RAID Driver Version: %s\\n\\n\", DPT_I2O_VERSION);\n\tseq_printf(m, \"%s\\n\", pHba->detail);\n\tseq_printf(m, \"SCSI Host=scsi%d  Control Node=/dev/%s  irq=%d\\n\", \n\t\t\tpHba->host->host_no, pHba->name, host->irq);\n\tseq_printf(m, \"\\tpost fifo size  = %d\\n\\treply fifo size = %d\\n\\tsg table size   = %d\\n\\n\",\n\t\t\thost->can_queue, (int) pHba->reply_fifo_size , host->sg_tablesize);\n\tseq_puts(m, \"Devices:\\n\");\n\tfor(chan = 0; chan < MAX_CHANNEL; chan++) {\n\t\tfor(id = 0; id < MAX_ID; id++) {\n\t\t\td = pHba->channel[chan].device[id];\n\t\t\twhile(d) {\n\t\t\t\tseq_printf(m,\"\\t%-24.24s\", d->pScsi_dev->vendor);\n\t\t\t\tseq_printf(m,\" Rev: %-8.8s\\n\", d->pScsi_dev->rev);\n\t\t\t\tunit = d->pI2o_dev->lct_data.tid;\n\t\t\t\tseq_printf(m, \"\\tTID=%d, (Channel=%d, Target=%d, Lun=%llu)  (%s)\\n\\n\",\n\t\t\t\t\t       unit, (int)d->scsi_channel, (int)d->scsi_id, d->scsi_lun,\n\t\t\t\t\t       scsi_device_online(d->pScsi_dev)? \"online\":\"offline\"); \n\t\t\t\td = d->next_lun;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "CONCRETE_IO_HANDLE socketio_create(void* io_create_parameters)\n{\n    SOCKETIO_CONFIG* socket_io_config = (SOCKETIO_CONFIG*)io_create_parameters;\n    SOCKET_IO_INSTANCE* result;\n    struct tcp_keepalive tcp_keepalive = { 0, 0, 0 };\n    if (socket_io_config == NULL)\n    {\n        LogError(\"Invalid argument: socket_io_config is NULL\");\n        result = NULL;\n    }\n    else\n    {\n        result = (SOCKET_IO_INSTANCE*)malloc(sizeof(SOCKET_IO_INSTANCE));\n        if (result != NULL)\n        {\n            (void)memset(result, 0, sizeof(SOCKET_IO_INSTANCE));\n            result->address_type = ADDRESS_TYPE_IP;\n            result->pending_io_list = singlylinkedlist_create();\n            if (result->pending_io_list == NULL)\n            {\n                LogError(\"Failure: singlylinkedlist_create unable to create pending list.\");\n                destroy_socket_io_instance(result);\n                result = NULL;\n            }\n            else\n            {\n                if (socket_io_config->hostname != NULL)\n                {\n                    result->hostname = (char*)malloc(strlen(socket_io_config->hostname) + 1);\n                    if (result->hostname != NULL)\n                    {\n                        (void)strcpy(result->hostname, socket_io_config->hostname);\n                    }\n                    result->socket = INVALID_SOCKET;\n                }\n                else\n                {\n                    result->hostname = NULL;\n                    result->socket = *((SOCKET*)socket_io_config->accepted_socket);\n                }\n                if ((result->hostname == NULL) && (result->socket == INVALID_SOCKET))\n                {\n                    LogError(\"Failure: hostname == NULL and socket is invalid.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else if ((result->addrInfo = calloc(1, sizeof(struct addrinfo))) == NULL)\n                {\n                    LogError(\"Failure: addrInfo == NULL.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->port = socket_io_config->port;\n                    result->on_io_open_complete = NULL;\n                    result->dns_resolver = dns_resolver_create(result->hostname, socket_io_config->port, NULL);\n                    result->on_bytes_received = NULL;\n                    result->on_io_error = NULL;\n                    result->on_bytes_received_context = NULL;\n                    result->on_io_error_context = NULL;\n                    result->io_state = IO_STATE_CLOSED;\n                    result->keep_alive = tcp_keepalive;\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Allocation Failure: SOCKET_IO_INSTANCE\");\n        }\n    }\n    return (XIO_HANDLE)result;\n}", "target": 1}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 1}
{"code": "void InstanceKlass::initialize_super_interfaces(TRAPS) {\n  assert (has_nonstatic_concrete_methods(), \"caller should have checked this\");\n  for (int i = 0; i < local_interfaces()->length(); ++i) {\n    InstanceKlass* ik = local_interfaces()->at(i);\n    if (ik->has_nonstatic_concrete_methods()) {\n      ik->initialize_super_interfaces(CHECK);\n    }\n    if (ik->should_be_initialized() && ik->declares_nonstatic_concrete_methods()) {\n      ik->initialize(CHECK);\n    }\n  }\n}", "target": 0}
{"code": "static void bdev_set_nr_sectors(struct block_device *bdev, sector_t sectors)\n{\n\tspin_lock(&bdev->bd_size_lock);\n\ti_size_write(bdev->bd_inode, (loff_t)sectors << SECTOR_SHIFT);\n\tspin_unlock(&bdev->bd_size_lock);\n}", "target": 0}
{"code": "static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen,\n\t\t\t\t       size_t *_dp, size_t *_len,\n\t\t\t\t       const char **_errmsg)\n{\n\tunsigned char tag, tmp;\n\tsize_t dp = *_dp, len, n;\n\tint indef_level = 1;\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n\ttag = data[dp++];\n\tif (tag == 0) {\n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n\tlen = data[dp++];\n\tif (len <= 0x7f) {\n\t\tdp += len;\n\t\tgoto next_tag;\n\t}\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(size_t) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tfor (len = 0; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\n\tdp += len;\n\tgoto next_tag;\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:\n\t*_errmsg = \"Invalid length EOC\";\n\tgoto error;\ndata_overrun_error:\n\t*_errmsg = \"Data overrun error\";\n\tgoto error;\nmissing_eoc:\n\t*_errmsg = \"Missing EOC in indefinite len cons\";\nerror:\n\t*_dp = dp;\n\treturn -1;\n}", "target": 1}
{"code": "    int Erase::eraseComment(Exiv2::Image* image) const\n    {\n        if (Params::instance().verbose_ && image->comment().size() > 0) {\n            std::cout << _(\"Erasing JPEG comment from the file\") << std::endl;\n        }\n        image->clearComment();\n        return 0;\n    }", "target": 0}
{"code": "ResponsePtr Server::ServeStatic(RequestPtr request) {\n  assert(request->method() == methods::kGet);\n  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n  fs::path path = doc_root_ / request->url().path();\n  try {\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n    auto response = std::make_shared<Response>(Status::kOK);\n    std::string extension = path.extension().string();\n    response->SetContentType(media_types::FromExtension(extension), \"\");\n    response->SetBody(body, true);\n    return response;\n  } catch (const Error& error) {\n    LOG_ERRO(\"File error: %s\", error.message().c_str());\n    return {};\n  }\n}", "target": 1}
{"code": "mm_sync_list(struct mmtree *oldtree, struct mmtree *newtree,\n    struct mm_master *mm, struct mm_master *mmold)\n{\n\tstruct mm_master *mmalloc = mm->mmalloc;\n\tstruct mm_share *mms, *new;\n\tRB_FOREACH(mms, mmtree, oldtree) {\n\t\tmm_memvalid(mmold, mms, sizeof(struct mm_share));\n\t\tmm_memvalid(mm, mms->address, mms->size);\n\t\tnew = mm_xmalloc(mmalloc, sizeof(struct mm_share));\n\t\tmemcpy(new, mms, sizeof(struct mm_share));\n\t\tRB_INSERT(mmtree, newtree, new);\n\t}\n}", "target": 1}
{"code": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n \tconst u_char *ep = ndo->ndo_snapend;\n \tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n \t\treturn (-1);\n\t}\n \tn = EXTRACT_32BITS(&prep->pp_n);\n \tps = (const struct pgstate *)(prep + 1);\n \twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (const struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (const struct pgstate *)io;\n\t}\n\treturn ((const u_char *)ps <= ep? 0 : -1);\n}", "target": 1}
{"code": "void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) \n{\n  if(recurs > 100) \n    throw MOADNSException(\"Loop\");\n  int pos = frompos;\n  for(;;) {\n    unsigned char labellen=content.at(frompos++);\n    if(!labellen) {\n      if(ret.empty())\n              ret.append(1,'.');\n      break;\n    }\n    else if((labellen & 0xc0) == 0xc0) {\n      uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);\n      if(offset >= pos)\n        throw MOADNSException(\"forward reference during label decompression\");\n      return getLabelFromContent(content, offset, ret, ++recurs);\n    }\n    else if(labellen > 63) \n      throw MOADNSException(\"Overly long label during label decompression (\"+lexical_cast<string>((unsigned int)labellen)+\")\");\n    else {\n      for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {\n        if(content.at(frompos)=='.' || content.at(frompos)=='\\\\') {\n          ret.append(1, '\\\\');\n          ret.append(1, content[frompos]);\n        }\n        else if(content.at(frompos)==' ') {\n          ret+=\"\\\\032\";\n        }\n        else \n          ret.append(1, content[frompos]);\n      }\n      ret.append(1,'.');\n    }\n    if (ret.length() > 1024)\n      throw MOADNSException(\"Total name too long\");\n  }\n}", "target": 1}
{"code": "    **/\n    CImg<T>& shift_object3d() {\n      if (_height!=3 || _depth>1 || _spectrum>1)\n        throw CImgInstanceException(_cimg_instance\n                                    \"shift_object3d(): Instance is not a set of 3d vertices.\",\n                                    cimg_instance);\n      CImg<T> xcoords = get_shared_row(0), ycoords = get_shared_row(1), zcoords = get_shared_row(2);\n      float\n        xm, xM = (float)xcoords.max_min(xm),\n        ym, yM = (float)ycoords.max_min(ym),\n        zm, zM = (float)zcoords.max_min(zm);\n      xcoords-=(xm + xM)/2; ycoords-=(ym + yM)/2; zcoords-=(zm + zM)/2;\n      return *this;", "target": 0}
{"code": "Method* InstanceKlass::find_instance_method(const Array<Method*>* methods,\n                                            const Symbol* name,\n                                            const Symbol* signature,\n                                            PrivateLookupMode private_mode) {\n  Method* const meth = InstanceKlass::find_method_impl(methods,\n                                                 name,\n                                                 signature,\n                                                 OverpassLookupMode::find,\n                                                 StaticLookupMode::skip,\n                                                 private_mode);\n  assert(((meth == NULL) || !meth->is_static()),\n    \"find_instance_method should have skipped statics\");\n  return meth;\n}", "target": 0}
{"code": "    std::string ExvImage::mimeType() const\n    {\n        return \"image/x-exv\";\n    }", "target": 0}
{"code": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif \n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif \n\t\tcap->device_caps = cap->capabilities = capabilities;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}", "target": 1}
{"code": "juniper_mfr_print(netdissect_options *ndo,\n                  const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        memset(&l2info, 0, sizeof(l2info));\n        l2info.pictype = DLT_JUNIPER_MFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie_len == 0) {\n            mfr_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        }\n        if (l2info.cookie_len == AS_PIC_COOKIE_LEN) {\n            switch(l2info.proto) {\n            case JUNIPER_LSQ_L3_PROTO_IPV4:\n                ip_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_IPV6:\n                ip6_print(ndo, p,l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_MPLS:\n                mpls_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_ISO:\n                isoclns_print(ndo, p, l2info.length, l2info.caplen);\n                return l2info.header_len;\n            default:\n                break;\n            }\n            return l2info.header_len;\n        }\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLCSAP_ISONS<<8 | LLCSAP_ISONS):\n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n    if (t < 0) {\n        t = 0;\n    }\n    days = t / 86400;\n    sec = t % 86400;\n    wday = (4 + days) % 7;\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n    days = days - (31 + 28) + 719527;\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n    mon = (yday + 31) * 10 / 306;\n    mday = yday - (367 * mon / 12 - 30) + 1;\n    if (yday >= 306) {\n        year++;\n        mon -= 10;\n    } else {\n        mon += 2;\n    }\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts ) {\n    const int plen = strlen( pattern )+1;\n    const int olen = strlen( opts )+1;\n    if ( bson_append_estart( b, BSON_REGEX, name, plen + olen ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_check_string( b, pattern, plen - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , pattern , plen );\n    bson_append( b , opts , olen );\n    return BSON_OK;\n}", "target": 1}
{"code": "ipmi_get_channel_cipher_suites(struct ipmi_intf *intf,\n                               const char *payload_type,\n                               uint8_t channel,\n                               struct cipher_suite_info *suites,\n                               size_t *count)\n{\n\tstruct ipmi_rs *rsp;\n\tstruct ipmi_rq req;\n\tuint8_t rqdata[3];\n\tuint8_t list_index = 0;\n\tuint8_t cipher_suite_data[MAX_CIPHER_SUITE_RECORD_OFFSET *\n\t                          MAX_CIPHER_SUITE_DATA_LEN];\n\tsize_t offset = 0;\n\tsize_t nr_suites = 0;\n\tif (!suites || !count || !*count)\n\t\treturn -1;\n\tnr_suites = *count;\n\t*count = 0;\n\tmemset(cipher_suite_data, 0, sizeof(cipher_suite_data));\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_APP;\n\treq.msg.cmd = IPMI_GET_CHANNEL_CIPHER_SUITES;\n\treq.msg.data = rqdata;\n\treq.msg.data_len = sizeof(rqdata);\n\trqdata[0] = channel;\n\trqdata[1] = ((strncmp(payload_type, \"ipmi\", 4) == 0)? 0: 1);\n\tdo {\n\t\trqdata[2] = LIST_ALGORITHMS_BY_CIPHER_SUITE | list_index;\n\t\trsp = intf->sendrecv(intf, &req);\n\t\tif (!rsp) {\n\t\t\tlprintf(LOG_ERR, \"Unable to Get Channel Cipher Suites\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (rsp->ccode || rsp->data_len < 1) {\n\t\t\tlprintf(LOG_ERR, \"Get Channel Cipher Suites failed: %s\",\n\t\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(cipher_suite_data + offset, rsp->data + 1, rsp->data_len - 1);\n\t\toffset += rsp->data_len - 1;\n\t\t++list_index;\n\t} while ((rsp->data_len == (sizeof(uint8_t) + MAX_CIPHER_SUITE_DATA_LEN))\n\t         && (list_index < MAX_CIPHER_SUITE_RECORD_OFFSET));\n\t*count = parse_channel_cipher_suite_data(cipher_suite_data, offset, suites,\n\t                                         nr_suites);\n\treturn 0;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_ping)\n{\n\tzval *pgsql_link;\n\tint id;\n\tPGconn *pgsql;\n\tPGresult *res;\n\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &pgsql_link) == SUCCESS) {\n\t\tid = -1;\n\t} else {\n\t\tpgsql_link = NULL;\n\t\tid = PGG(default_link);\n\t}\n\tif (pgsql_link == NULL && id == -1) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tres = PQexec(pgsql, \"SELECT 1;\");\n\tPQclear(res);\n\tif (PQstatus(pgsql) == CONNECTION_OK)\n\t\tRETURN_TRUE;\n\tPQreset(pgsql);\n\tif (PQstatus(pgsql) == CONNECTION_OK) {\n\t\tRETURN_TRUE;\n\t}\n\tRETURN_FALSE;\n}", "target": 0}
{"code": "TfLiteStatus EvalHashtableImport(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  const int resource_id = input_resource_id_tensor->data.i32[0];\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* value_tensor = GetInput(context, node, kValueTensor);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      lookup->CheckKeyAndValueTypes(context, key_tensor, value_tensor));\n  auto result = lookup->Import(context, key_tensor, value_tensor);\n  return result;\n}", "target": 1}
{"code": "static INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "GfxShading::GfxShading(int typeA)\n{\n    type = typeA;\n    colorSpace = nullptr;\n}", "target": 0}
{"code": "GF_Box *sgpd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupDescriptionBox, GF_ISOM_BOX_TYPE_SGPD);\n\ttmp->version = 1;\n\ttmp->group_descriptions = gf_list_new();\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static int sclp_ctl_ioctl_sccb(void __user *user_area)\n {\n \tstruct sclp_ctl_sccb ctl_sccb;\n \tstruct sccb_header *sccb;\n \tint rc;\n \tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n \tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n \tif (!sccb)\n \t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n \t\trc = -EFAULT;\n \t\tgoto out_free;\n \t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n \t\tgoto out_free;\n \t}\n \trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}", "target": 1}
{"code": "  virtual ~LibRaw_abstract_datastream(void) { }", "target": 0}
{"code": "void CleanupOutput(char *str)\n{\n    char *s, *t;\n    int period = 0;\n    s = t = str;\n    while ( *s && *s != '}' ) {\n        if ( *s == '\\n' ) *s = ' ';\n        if ( ( *s == ' ' || *s == '\\n' ) && ( s[1] == ' ' || s[1] == '\\n' ) ) s++;\n        else *t++ = *s++;\n    }\n    while ( *s ) *t++ = *s++;\n    *t = 0;\n    s = t = str;\n    while ( *s ) {\n        if ( *s == '.' ) { period = 1; *t++ = *s++; }\n        else if ( *s == '-' && s[1] == '0' && s[2] == ' ' ) { s++; }\n        else if ( *s <= '9' && *s >= '0' ) { *t++ = *s++; }\n        else if ( *s == '\\n' && ( t > str && t[-1] == '\\n' ) ) { s++; }\n        else if ( period ) {\n            while ( t > str && t[-1] == '0' ) t--;\n            if ( t > str && t[-1] == '.' ) t--;\n            while ( *s == ' ' && s[1] == ' ' ) s++;\n            period = 0; *t++ = *s++;\n        }\n        else if ( *s == ' ' && s[1] == ' ' ) s++;\n        else {\n            period = 0; *t++ = *s++;\n        }\n    }\n    *t = 0;\n    s = t = str;\n    while ( *s ) {\n        if ( *s == '-' && s[1] == '0' && s[2] == ' ' ) { s++; }\n        else *t++ = *s++;\n    }\n    *t = 0;\n}", "target": 1}
{"code": "get_number(int *numptr, int low, const char *names[], int ch, FILE *file,\n    const char *terms) {\n\tchar temp[MAX_TEMPSTR], *pc;\n\tint len, i;\n\tpc = temp;\n\tlen = 0;\n\twhile (isdigit((unsigned char)ch)) {\n\t\tif (++len >= MAX_TEMPSTR)\n\t\t\tgoto bad;\n\t\t*pc++ = ch;\n\t\tch = get_char(file);\n\t}\n\t*pc = '\\0';\n\tif (len != 0) {\n\t\tif (!strchr(terms, ch))\n\t\t\tgoto bad;\n\t\t*numptr = atoi(temp);\n\t\treturn (ch);\n\t}\n\tif (names) {\n\t\twhile (isalpha((unsigned char)ch)) {\n\t\t\tif (++len >= MAX_TEMPSTR)\n\t\t\t\tgoto bad;\n\t\t\t*pc++ = ch;\n\t\t\tch = get_char(file);\n\t\t}\n\t\t*pc = '\\0';\n\t\tif (len != 0 && strchr(terms, ch)) {\n\t\t\tfor (i = 0;  names[i] != NULL;  i++) {\n\t\t\t\tDebug(DPARS|DEXT,\n\t\t\t\t\t(\"get_num, compare(%s,%s)\\n\", names[i],\n\t\t\t\t\ttemp))\n\t\t\t\tif (!strcasecmp(names[i], temp)) {\n\t\t\t\t\t*numptr = i+low;\n\t\t\t\t\treturn (ch);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nbad:\n\tunget_char(ch, file);\n\treturn (EOF);\n}", "target": 1}
{"code": "char *Curl_all_content_encodings(void)\n{\n  return strdup(CONTENT_ENCODING_DEFAULT);  \n}", "target": 0}
{"code": "   Read the full structure of a message */\nPHP_FUNCTION(imap_fetchstructure)\n{\n\tzval *streamind;\n\tzend_long msgno, flags = 0;\n\tpils *imap_le_struct;\n\tBODY *body;\n\tint msgindex, argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc, \"rl|l\", &streamind, &msgno, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (flags && ((flags & ~FT_UID) != 0)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"invalid value for the options parameter\");\n\t\tRETURN_FALSE;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (msgno < 1) {\n\t\tRETURN_FALSE;\n\t}\n\tobject_init(return_value);\n\tif ((argc == 3) && (flags & FT_UID)) {\n\t\tmsgindex = mail_msgno(imap_le_struct->imap_stream, msgno);\n\t} else {\n\t\tmsgindex = msgno;\n\t}\n\tPHP_IMAP_CHECK_MSGNO(msgindex);\n\tmail_fetchstructure_full(imap_le_struct->imap_stream, msgno, &body , (argc == 3 ? flags : NIL));\n\tif (!body) {\n\t\tphp_error_docref(NULL, E_WARNING, \"No body information available\");\n\t\tRETURN_FALSE;\n\t}\n\t_php_imap_add_body(return_value, body);", "target": 0}
{"code": "static void io_init_new_worker(struct io_wqe *wqe, struct io_worker *worker,\n\t\t\t       struct task_struct *tsk)\n{\n\ttsk->pf_io_worker = worker;\n\tworker->task = tsk;\n\tset_cpus_allowed_ptr(tsk, wqe->cpu_mask);\n\ttsk->flags |= PF_NO_SETAFFINITY;\n\traw_spin_lock(&wqe->lock);\n\thlist_nulls_add_head_rcu(&worker->nulls_node, &wqe->free_list);\n\tlist_add_tail_rcu(&worker->all_list, &wqe->all_list);\n\tworker->flags |= IO_WORKER_F_FREE;\n\traw_spin_unlock(&wqe->lock);\n\twake_up_new_task(tsk);\n}", "target": 0}
{"code": "void GfxIndexedColorSpace::getDeviceNLine(unsigned char *in, unsigned char *out, int length)\n{\n    unsigned char *line;\n    int i, j, n;\n    n = base->getNComps();\n    line = (unsigned char *)gmallocn(length, n);\n    for (i = 0; i < length; i++)\n        for (j = 0; j < n; j++)\n            line[i * n + j] = lookup[in[i] * n + j];\n    base->getDeviceNLine(line, out, length);\n    gfree(line);\n}", "target": 0}
{"code": "                void writeMetadata()\n                {\n                }", "target": 0}
{"code": "void set_current_connection(struct st_connection *con)\n{\n  cur_con= con;\n  var_set_int(\"$mysql_get_server_version\",\n              mysql_get_server_version(con->mysql));\n  var_set_string(\"$CURRENT_CONNECTION\", con->name);\n}", "target": 0}
{"code": "static struct desc_struct *get_desc(unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc = NULL;\n\t\tstruct ldt_struct *ldt;\n\t\tsel >>= 3;\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries)\n\t\t\tdesc = &ldt->entries[sel];\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\t\treturn desc;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\tif (desc_base > gdt_desc.size)\n\t\treturn NULL;\n\treturn (struct desc_struct *)(gdt_desc.address + desc_base);\n}", "target": 1}
{"code": "void set_cron_watched(int fd) {\n\tpid_t pid = getpid();\n\tint i;\n\tif (fd < 0) {\n\t\tinotify_enabled = 0;\n\t\treturn;\n\t}\n\tfor (i = 0; i < sizeof (wd) / sizeof (wd[0]); ++i) {\n\t\tint w;\n\t\tif (open(watchpaths[i], O_RDONLY | O_NONBLOCK, 0) != -1) {\n\t\t\tw = inotify_add_watch(fd, watchpaths[i],\n\t\t\t\tIN_CREATE | IN_CLOSE_WRITE | IN_ATTRIB | IN_MODIFY | IN_MOVED_TO |\n\t\t\t\tIN_MOVED_FROM | IN_MOVE_SELF | IN_DELETE | IN_DELETE_SELF);\n\t\t\tif (w < 0) {\n\t\t\t\tif (wd[i] != -1) {\n\t\t\t\t\tlog_it(\"CRON\", pid, \"This directory or file can't be watched\",\n\t\t\t\t\t\twatchpaths[i], errno);\n\t\t\t\t\tlog_it(\"CRON\", pid, \"INFO\", \"running without inotify support\", 0);\n\t\t\t\t}\n\t\t\t\tinotify_enabled = 0;\n\t\t\t\tset_cron_unwatched(fd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twd[i] = w;\n\t\t}\n\t}\n\tif (!inotify_enabled) {\n\t\tlog_it(\"CRON\", pid, \"INFO\", \"running with inotify support\", 0);\n\t}\n\tinotify_enabled = 1;\n}", "target": 1}
{"code": "void GHASH::key_schedule(std::span<const uint8_t> key) {\n   m_H.assign(key.begin(), key.end());  \n   m_H_ad.resize(GCM_BS);\n   m_ad_len = 0;\n   m_text_len = 0;\n   uint64_t H0 = load_be<uint64_t>(m_H.data(), 0);\n   uint64_t H1 = load_be<uint64_t>(m_H.data(), 1);\n   const uint64_t R = 0xE100000000000000;\n   m_HM.resize(256);\n   for(size_t i = 0; i != 2; ++i) {\n      for(size_t j = 0; j != 64; ++j) {\n         m_HM[4 * j + 2 * i] = H0;\n         m_HM[4 * j + 2 * i + 1] = H1;\n         const uint64_t carry = R * (H1 & 1);\n         H1 = (H1 >> 1) | (H0 << 63);\n         H0 = (H0 >> 1) ^ carry;\n      }\n   }\n#if defined(BOTAN_HAS_GHASH_CLMUL_CPU)\n   if(CPUID::has_carryless_multiply()) {\n      m_H_pow.resize(8);\n      ghash_precompute_cpu(m_H.data(), m_H_pow.data());\n   }\n#endif\n}", "target": 1}
{"code": "    ImageType ImageFactory::getType(const std::wstring& wpath)\n    {\n        FileIo fileIo(wpath);\n        return getType(fileIo);\n    }", "target": 0}
{"code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n         return AVERROR(ENOMEM);\n     hdr = *phdr;\n    init_get_bits8(&gb, buf, size);\n     err = ff_ac3_parse_header(&gb, hdr);\n     if (err < 0)\n         return AVERROR_INVALIDDATA;\n    return get_bits_count(&gb);\n}", "target": 1}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "chop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n}", "target": 0}
{"code": "\tTEST_METHOD(7) {\n\t\tServerInstanceDir dir(parentDir + \"/passenger-test.1234\");\n\t\tServerInstanceDir::GenerationPtr generation = dir.newGeneration(true,\n\t\t\t\"nobody\", nobodyGroup, 0, 0);\n\t\tstring path = generation->getPath();\n\t\tgeneration.reset();\n\t\tensure_equals(getFileType(path), FT_NONEXISTANT);\n\t}", "target": 0}
{"code": "int rtp_packetize_xiph_config( sout_stream_id_sys_t *id, const char *fmtp,\n                               int64_t i_pts )\n{\n    if (fmtp == NULL)\n        return VLC_EGENERIC;\n    char *start = strstr(fmtp, \"configuration=\");\n    assert(start != NULL);\n    start += sizeof(\"configuration=\") - 1;\n    char *end = strchr(start, ';');\n    assert(end != NULL);\n    size_t len = end - start;\n    char b64[len + 1];\n    memcpy(b64, start, len);\n    b64[len] = '\\0';\n    int     i_max   = rtp_mtu (id) - 6; \n    uint8_t *p_orig, *p_data;\n    int i_data;\n    i_data = vlc_b64_decode_binary(&p_orig, b64);\n    if (i_data <= 9)\n    {\n        free(p_orig);\n        return VLC_EGENERIC;\n    }\n    p_data = p_orig + 9;\n    i_data -= 9;\n    int i_count = ( i_data + i_max - 1 ) / i_max;\n    for( int i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 18 + i_payload );\n        unsigned fragtype, numpkts;\n        if (i_count == 1)\n        {\n            fragtype = 0;\n            numpkts = 1;\n        }\n        else\n        {\n            numpkts = 0;\n            if (i == 0)\n                fragtype = 1;\n            else if (i == i_count - 1)\n                fragtype = 3;\n            else\n                fragtype = 2;\n        }\n        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |\n                          (fragtype << 6) | (1 << 4) | numpkts;\n        rtp_packetize_common( id, out, 0, i_pts );\n        SetDWBE( out->p_buffer + 12, header);\n        SetWBE( out->p_buffer + 16, i_payload);\n        memcpy( &out->p_buffer[18], p_data, i_payload );\n        out->i_dts    = i_pts;\n        rtp_packetize_send( id, out );\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n    free(p_orig);\n    return VLC_SUCCESS;\n}", "target": 1}
{"code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n \t}\n\tmsg->msg_namelen = sizeof(*sax);\n \tskb_free_datagram(sk, skb);\n \trelease_sock(sk);\n\treturn copied;\n}", "target": 1}
{"code": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\treturn threads;\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1}
{"code": "static bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    pb_bytes_array_t *bdest;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, PB_BYTES_ARRAY_T_ALLOCSIZE(size), 1))\n            return false;\n        bdest = *(pb_bytes_array_t**)dest;\n#endif\n    }\n    else\n    {\n        if (PB_BYTES_ARRAY_T_ALLOCSIZE(size) > field->data_size)\n            PB_RETURN_ERROR(stream, \"bytes overflow\");\n        bdest = (pb_bytes_array_t*)dest;\n    }\n    if (size > PB_SIZE_MAX)\n    {\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n    }\n    bdest->size = (pb_size_t)size;\n    return pb_read(stream, bdest->bytes, size);\n}", "target": 1}
{"code": "WebProcessProxy::WebProcessProxy(PassRefPtr<WebContext> context)\n    : ChildProcessProxy(this)\n    , m_responsivenessTimer(this)\n    , m_context(context)\n    , m_mayHaveUniversalFileReadSandboxExtension(false)\n#if ENABLE(CUSTOM_PROTOCOLS)\n    , m_customProtocolManagerProxy(this)\n#endif\n#if PLATFORM(MAC)\n    , m_processSuppressionEnabled(false)\n#endif\n{\n    connect();\n}", "target": 0}
{"code": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}", "target": 1}
{"code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n \tif (err < 0)\n \t\tgoto __err;\n \tkfree(tu->queue);\n \ttu->queue = NULL;\n \tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n      __err:\n\treturn err;\n}", "target": 1}
{"code": "static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\terr = udp_send_skb(skb, fl4);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": " static void make_response(struct xen_blkif_ring *ring, u64 id,\n \t\t\t  unsigned short op, int st)\n {\n\tstruct blkif_response  resp;\n \tunsigned long     flags;\n \tunion blkif_back_rings *blk_rings;\n \tint notify;\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n \tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n \tblk_rings = &ring->blk_rings;\n \tswitch (ring->blkif->blk_protocol) {\n \tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n \tblk_rings->common.rsp_prod_pvt++;\n \tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n \tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}", "target": 1}
{"code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\tmax_cmd = instance->max_mfi_cmds;\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!instance->cmd_list[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n \tif (megasas_create_frame_pool(instance)) {\n \t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n \t\tmegasas_free_cmds(instance);\n \t}\n \treturn 0;\n}", "target": 1}
{"code": "SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "void skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      prot.readBool(boolv);\n      return;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      prot.readByte(bytev);\n      return;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      prot.readI16(i16);\n      return;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      prot.readI32(i32);\n      return;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      prot.readI64(i64);\n      return;\n    }\n    case TType::T_DOUBLE: {\n      double dub;\n      prot.readDouble(dub);\n      return;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      prot.readFloat(flt);\n      return;\n    }\n    case TType::T_STRING: {\n      std::string str;\n      prot.readBinary(str);\n      return;\n    }\n    case TType::T_STRUCT: {\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      prot.readStructBegin(name);\n      while (true) {\n        prot.readFieldBegin(name, ftype, fid);\n        if (ftype == TType::T_STOP) {\n          break;\n        }\n        apache::thrift::skip(prot, ftype);\n        prot.readFieldEnd();\n      }\n      prot.readStructEnd();\n      return;\n    }\n    case TType::T_MAP: {\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      prot.readMapBegin(keyType, valType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, keyType);\n        apache::thrift::skip(prot, valType);\n      }\n      prot.readMapEnd();\n      return;\n    }\n    case TType::T_SET: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readSetBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readSetEnd();\n      return;\n    }\n    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}", "target": 1}
{"code": "ref_stack_allow_expansion(ref_stack_t *pstack, bool expand)\n{\n    pstack->params->allow_expansion = expand;\n}", "target": 0}
{"code": "is_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}", "target": 0}
{"code": "void InstanceKlass::eager_initialize(Thread *thread) {\n  if (!EagerInitialization) return;\n  if (this->is_not_initialized()) {\n    if (this->class_initializer() != NULL) return;\n    Klass* super_klass = super();\n    if (super_klass == NULL) return;\n    if (!InstanceKlass::cast(super_klass)->is_initialized()) return;\n    eager_initialize_impl();\n  }\n}", "target": 0}
{"code": "static void __spin_time_accum(u64 delta, u32 *array)\n{\n\tunsigned index;\n\tindex = ilog2(delta);\n\tcheck_zero();\n\tif (index < HISTO_BUCKETS)\n\t\tarray[index]++;\n\telse\n\t\tarray[HISTO_BUCKETS]++;\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::OnCompositingStarted(\n    ui::Compositor* compositor, base::TimeTicks start_time) {\n  last_draw_ended_ = start_time;\n}", "target": 0}
{"code": "static int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}", "target": 0}
{"code": "int xt_compat_check_entry_offsets(const void *base,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType DefineImageRegistry(const RegistryType type,\n  const char *option,ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    value[MagickPathExtent];\n  register char\n    *p;\n  assert(option != (const char *) NULL);\n  (void) CopyMagickString(key,option,MagickPathExtent);\n  for (p=key; *p != '\\0'; p++)\n    if (*p == '=')\n      break;\n  *value='\\0';\n  if (*p == '=')\n    (void) CopyMagickString(value,p+1,MagickPathExtent);\n  *p='\\0';\n  return(SetImageRegistry(type,key,value,exception));\n}", "target": 0}
{"code": "Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\tModularArithmetic modn(m_n);\n\tInteger r, rInv;\n\tdo {\t\n\t\tr.Randomize(rng, Integer::One(), m_n - Integer::One());\n\t\trInv = modn.MultiplicativeInverse(r);\n\t} while (rInv.IsZero());\n\tInteger re = modn.Square(r);\n\tre = modn.Multiply(re, x);\t\t\t\n\tInteger cp=re%m_p, cq=re%m_q;\n\tif (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)\n\t{\n\t\tcp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;\n\t\tcq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;\n\t}\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t\tcp = ModularSquareRoot(cp, m_p);\n\t\t\t#pragma omp section\n\t\t\t\tcq = ModularSquareRoot(cq, m_q);\n\t\t}\n\tInteger y = CRT(cq, m_q, cp, m_p, m_u);\n\ty = modn.Multiply(y, rInv);\t\t\t\t\n\ty = STDMIN(y, m_n-y);\n\tif (ApplyFunction(y) != x)\t\t\t\t\n\t\tthrow Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");\n\treturn y;\n}", "target": 1}
{"code": "static bool meta_set(RAnal *a, RAnalMetaType type, int subtype, ut64 from, ut64 to, const char *str) {\n\tif (to < from) {\n\t\treturn false;\n\t}\n\tRSpace *space = r_spaces_current (&a->meta_spaces);\n\tRIntervalNode *node = find_node_at (a, type, space, from);\n\tRAnalMetaItem *item = node ? node->data : R_NEW0 (RAnalMetaItem);\n\tif (!item) {\n\t\treturn false;\n\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\titem->str = str ? strdup (str) : NULL;\n\tif (str && !item->str) {\n\t\tif (!node) { \n\t\t\tfree (item);\n\t\t}\n\t\treturn false;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {\n\t\tr_interval_tree_resize (&a->meta, node, from, to);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 rowsperstrip;\n\tuint32 stripsperplane;\n\tuint32 stripinplane;\n\tuint16 plane;\n\tuint32 rows;\n\ttmsize_t stripsize;\n\tif (!TIFFCheckRead(tif,0))\n\t\treturn((tmsize_t)(-1));\n\tif (strip>=td->td_nstrips)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\n\t\t    (unsigned long)td->td_nstrips);\n\t\treturn((tmsize_t)(-1));\n\t}\n \trowsperstrip=td->td_rowsperstrip;\n \tif (rowsperstrip>td->td_imagelength)\n \t\trowsperstrip=td->td_imagelength;\n\tstripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip);\n \tstripinplane=(strip%stripsperplane);\n \tplane=(uint16)(strip/stripsperplane);\n \trows=td->td_imagelength-stripinplane*rowsperstrip;\n\tif (rows>rowsperstrip)\n\t\trows=rowsperstrip;\n\tstripsize=TIFFVStripSize(tif,rows);\n\tif (stripsize==0)\n\t\treturn((tmsize_t)(-1));\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= stripsize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,stripsize);\n        (*tif->tif_postdecode)(tif,buf,stripsize);\n        return (stripsize);\n    }\n\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\n\t\tstripsize=size;\n\tif (!TIFFFillStrip(tif,strip))\n\t\treturn((tmsize_t)(-1));\n\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n\t\treturn((tmsize_t)(-1));\n\t(*tif->tif_postdecode)(tif,buf,stripsize);\n\treturn(stripsize);\n}", "target": 1}
{"code": "ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {\n\tut64 addr = 0LL;\n\tstruct symbol_t *symbols;\n\tint i;\n\tif (!(symbols = MACH0_(get_symbols) (bin))) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!strcmp (symbols[i].name, \"_main\")) {\n\t\t\taddr = symbols[i].addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (symbols);\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n\t\t\treturn 0;\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\t\t\t}\n\t\t}\n\t}\n\treturn addr;\n}", "target": 1}
{"code": "static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }\n    for (int i = 1; i < rpl->ref_pic_num; ++i) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        if (delta_poc_st != 0)\n            strp_entry_sign_flag = get_bits(gb, 1);\n        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));\n    }\n    return 0;\n}", "target": 1}
{"code": "static bool translation_pre_enabled(struct intel_iommu *iommu)\n{\n\treturn (iommu->flags & VTD_FLAG_TRANS_PRE_ENABLED);\n}", "target": 0}
{"code": "void HTMLInputElement::listAttributeTargetChanged()\n{\n    m_inputTypeView->listAttributeTargetChanged();\n}", "target": 0}
{"code": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\tif (error)\n\t\treturn error;\n\tspin_lock_bh(&socket_client->lock);\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\tspin_unlock_bh(&socket_client->lock);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\tpacket_len = socket_packet->icmp_len;\n\tkfree(socket_packet);\n\tif (error)\n\t\treturn -EFAULT;\n\treturn packet_len;\n}", "target": 1}
{"code": "static void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}", "target": 0}
{"code": "static void kvm_sched_in(struct preempt_notifier *pn, int cpu)\n{\n\tstruct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);\n\tkvm_arch_vcpu_load(vcpu, cpu);\n}", "target": 0}
{"code": "int sock_initaddress(const char *host, const char *port,\n    struct addrinfo *hints, struct addrinfo **addrinfo, char *errbuf, int errbuflen)\n{\n\tint retval;\n\tretval = getaddrinfo(host, port == NULL ? \"0\" : port, hints, addrinfo);\n\tif (retval != 0)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tif (host != NULL && port != NULL) {\n\t\t\t\tint try_retval;\n\t\t\t\ttry_retval = getaddrinfo(host, NULL, hints,\n\t\t\t\t    addrinfo);\n\t\t\t\tif (try_retval == 0) {\n\t\t\t\t\tfreeaddrinfo(*addrinfo);\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, NULL, port);\n\t\t\t\t} else {\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, host, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tget_gai_errstring(errbuf, errbuflen, \"\",\n\t\t\t\t    retval, host, port);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_family != PF_INET) &&\n\t    ((*addrinfo)->ai_family != PF_INET6))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): socket type not supported\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_socktype == SOCK_STREAM) &&\n\t    (sock_ismcastaddr((*addrinfo)->ai_addr) == 0))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): multicast addresses are not valid when using TCP streams\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void pdf_run_BDC(fz_context *ctx, pdf_processor *proc, const char *tag, pdf_obj *raw, pdf_obj *cooked)\n{\n}", "target": 0}
{"code": "  explicit QuantizeAndDequantizeV2Op(OpKernelConstruction* ctx)\n      : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    string round_mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"round_mode\", &round_mode_string));\n    OP_REQUIRES(\n        ctx,\n        (round_mode_string == \"HALF_UP\" || round_mode_string == \"HALF_TO_EVEN\"),\n        errors::InvalidArgument(\"Round mode string must be \"\n                                \"'HALF_UP' or \"\n                                \"'HALF_TO_EVEN', is '\" +\n                                round_mode_string + \"'\"));\n    if (round_mode_string == \"HALF_UP\") {\n      round_mode_ = ROUND_HALF_UP;\n    } else if (round_mode_string == \"HALF_TO_EVEN\") {\n      round_mode_ = ROUND_HALF_TO_EVEN;\n    }\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n  }", "target": 1}
{"code": "int jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tint k;\n\tjas_seqent_t v;\n\tint c;\n\tjas_seqent_t *dr;\n\tjas_seqent_t *d;\n\tint drs;\n\tJAS_DBGLOG(100, (\"jas_image_readcmpt(%p, %d, %ld, %ld, %ld, %ld, %p)\\n\",\n\t  image, cmptno, JAS_CAST(long, x), JAS_CAST(long, y),\n\t  JAS_CAST(long, width), JAS_CAST(long, height), data));\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\tif (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {\n\t\treturn -1;\n\t}\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\tif (jas_matrix_resize(data, height, width)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = 0;\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv = (v << 8) | (c & 0xff);\n\t\t\t}\n\t\t\t*d = bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "u32 gf_isom_get_user_data_count(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tbin128 t;\n\tu32 i, count;\n\tif (!movie || !movie->moov) return 0;\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tcount = gf_list_count(map->boxes);\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) return count;\n\t\telse if (map->boxType == UserDataType) return count;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "    int FixIso::run(const std::string& path)\n    {\n        try {\n            if (!Exiv2::fileExists(path, true)) {\n                std::cerr << path << \": \" << _(\"Failed to open the file\\n\");\n                return -1;\n            }\n            Timestamp ts;\n            if (Params::instance().preserve_)\n                ts.read(path);\n            Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open(path);\n            image->readMetadata();\n            Exiv2::ExifData& exifData = image->exifData();\n            if (exifData.empty()) {\n                std::cerr << path << \": \" << _(\"No Exif data found in the file\\n\");\n                return -3;\n            }\n            auto md = Exiv2::isoSpeed(exifData);\n            if (md != exifData.end()) {\n                if (strcmp(md->key().c_str(), \"Exif.Photo.ISOSpeedRatings\") == 0) {\n                    if (Params::instance().verbose_) {\n                        std::cout << _(\"Standard Exif ISO tag exists; not modified\\n\");\n                    }\n                    return 0;\n                }\n                std::ostringstream os;\n                md->write(os, &exifData);\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"Setting Exif ISO value to\") << \" \" << os.str() << \"\\n\";\n                }\n                exifData[\"Exif.Photo.ISOSpeedRatings\"] = os.str();\n            }\n            image->writeMetadata();\n            if (Params::instance().preserve_)\n                ts.touch(path);\n            return 0;\n        } catch (const Exiv2::AnyError& e) {\n            std::cerr << \"Exiv2 exception in fixiso action for file \" << path << \":\\n\" << e << \"\\n\";\n            return 1;\n        }\n    }", "target": 0}
{"code": "static void nvme_select_iocs(NvmeCtrl *n)\n{\n    NvmeNamespace *ns;\n    int i;\n    for (i = 1; i <= NVME_MAX_NAMESPACES; i++) {\n        ns = nvme_ns(n, i);\n        if (!ns) {\n            continue;\n        }\n        nvme_select_iocs_ns(n, ns);\n    }\n}", "target": 0}
{"code": "smb3_handle_read_data(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tchar *buf = server->large_buf ? server->bigbuf : server->smallbuf;\n\treturn handle_read_data(server, mid, buf, server->pdu_size,\n\t\t\t\tNULL, 0, 0, false);\n}", "target": 0}
{"code": "fz_set_default_rgb(fz_context *ctx, fz_default_colorspaces *default_cs, fz_colorspace *cs)\n{\n\tif (cs->n == 3)\n\t{\n\t\tfz_drop_colorspace(ctx, default_cs->rgb);\n\t\tdefault_cs->rgb = fz_keep_colorspace(ctx, cs);\n\t}\n}", "target": 0}
{"code": " rs_filter_graph(RSFilter *filter)\n {\n \tg_return_if_fail(RS_IS_FILTER(filter));\n \tGString *str = g_string_new(\"digraph G {\\n\");\n \trs_filter_graph_helper(str, filter);\n \tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n \t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n \t\tg_warning(\"Calling gnome-open failed.\");\n \tg_string_free(str, TRUE);\n }", "target": 1}
{"code": "static void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)\n{\n\tunsigned long flags;\n\tstruct page *page, *h;\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry_safe(page, h, &n->partial, lru) {\n\t\tif (!page->inuse) {\n\t\t\tlist_del(&page->lru);\n\t\t\tdiscard_slab(s, page);\n\t\t\tn->nr_partial--;\n\t\t} else {\n\t\t\tlist_slab_objects(s, page,\n\t\t\t\t\"Objects remaining on kmem_cache_close()\");\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n}", "target": 0}
{"code": "GpuProcessHostUIShim* GpuProcessHostUIShim::Create(int host_id) {\n  DCHECK(!FromID(host_id));\n  return new GpuProcessHostUIShim(host_id);\n}", "target": 0}
{"code": "static void write_pmc(int idx, unsigned long val)\n{\n\tswitch (idx) {\n\tcase 1:\n\t\tmtspr(SPRN_PMC1, val);\n\t\tbreak;\n\tcase 2:\n\t\tmtspr(SPRN_PMC2, val);\n\t\tbreak;\n\tcase 3:\n\t\tmtspr(SPRN_PMC3, val);\n\t\tbreak;\n\tcase 4:\n\t\tmtspr(SPRN_PMC4, val);\n\t\tbreak;\n\tcase 5:\n\t\tmtspr(SPRN_PMC5, val);\n\t\tbreak;\n\tcase 6:\n\t\tmtspr(SPRN_PMC6, val);\n\t\tbreak;\n#ifdef CONFIG_PPC64\n\tcase 7:\n\t\tmtspr(SPRN_PMC7, val);\n\t\tbreak;\n\tcase 8:\n\t\tmtspr(SPRN_PMC8, val);\n\t\tbreak;\n#endif \n\tdefault:\n\t\tprintk(KERN_ERR \"oops trying to write PMC%d\\n\", idx);\n\t}\n}", "target": 0}
{"code": "gimp_channel_get_node (GimpFilter *filter)\n{\n  GimpDrawable *drawable = GIMP_DRAWABLE (filter);\n  GimpChannel  *channel  = GIMP_CHANNEL (filter);\n  GeglNode     *node;\n  GeglNode     *source;\n  GeglNode     *mode_node;\n  const Babl   *color_format;\n  node = GIMP_FILTER_CLASS (parent_class)->get_node (filter);\n  source = gimp_drawable_get_source_node (drawable);\n  gegl_node_add_child (node, source);\n  g_warn_if_fail (channel->color_node == NULL);\n  if (gimp_drawable_get_linear (drawable))\n    color_format = babl_format (\"RGBA float\");\n  else\n    color_format = babl_format (\"R'G'B'A float\");\n  channel->color_node = gegl_node_new_child (node,\n                                             \"operation\", \"gegl:color\",\n                                             \"format\",    color_format,\n                                             NULL);\n  gimp_gegl_node_set_color (channel->color_node,\n                            &channel->color);\n  g_warn_if_fail (channel->mask_node == NULL);\n  channel->mask_node = gegl_node_new_child (node,\n                                            \"operation\", \"gegl:opacity\",\n                                            NULL);\n  gegl_node_connect_to (channel->color_node, \"output\",\n                        channel->mask_node,  \"input\");\n  g_warn_if_fail (channel->invert_node == NULL);\n  channel->invert_node = gegl_node_new_child (node,\n                                              \"operation\", \"gegl:invert-linear\",\n                                              NULL);\n  if (channel->show_masked)\n    {\n      gegl_node_connect_to (source,               \"output\",\n                            channel->invert_node, \"input\");\n      gegl_node_connect_to (channel->invert_node, \"output\",\n                            channel->mask_node,   \"aux\");\n    }\n  else\n    {\n      gegl_node_connect_to (source,             \"output\",\n                            channel->mask_node, \"aux\");\n    }\n  mode_node = gimp_drawable_get_mode_node (drawable);\n  gegl_node_connect_to (channel->mask_node, \"output\",\n                        mode_node,          \"aux\");\n  return node;\n}", "target": 0}
{"code": "static void set_env( char* penv, const char* name )\n{\n    if( penv && *penv )\n        g_setenv( name, penv, TRUE);\n    else\n        g_unsetenv( name );\n}", "target": 0}
{"code": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}", "target": 1}
{"code": "START_TEST(test_log_long_msg)\n{\n\tint lpc;\n\tint rc;\n\tint i, max = 1000;\n\tchar *buffer = calloc(1, max);\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 1024);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(QB_LOG_BLACKBOX, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\tfor (lpc = 500; lpc < max; lpc++) {\n\t\tlpc++;\n\t\tfor(i = 0; i < max; i++) {\n\t\t\tbuffer[i] = 'a' + (i % 10);\n\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n        qb_log_blackbox_write_to_file(\"blackbox.dump\");\n        qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}", "target": 1}
{"code": "gs_heap_enable_free(gs_memory_t * mem, bool enable)\n{\n    if (enable)\n        mem->procs.free_object = gs_heap_free_object,\n            mem->procs.free_string = gs_heap_free_string;\n    else\n        mem->procs.free_object = gs_ignore_free_object,\n            mem->procs.free_string = gs_ignore_free_string;\n}", "target": 0}
{"code": "Method* ciEnv::lookup_method(ciInstanceKlass* accessor,\n                             ciKlass*         holder,\n                             Symbol*          name,\n                             Symbol*          sig,\n                             Bytecodes::Code  bc,\n                             constantTag      tag) {\n  InstanceKlass* accessor_klass = accessor->get_instanceKlass();\n  Klass* holder_klass = holder->get_Klass();\n  assert(check_klass_accessibility(accessor, holder_klass), \"holder not accessible\");\n  LinkInfo link_info(holder_klass, name, sig, accessor_klass,\n                     LinkInfo::AccessCheck::required,\n                     LinkInfo::LoaderConstraintCheck::required,\n                     tag);\n  switch (bc) {\n    case Bytecodes::_invokestatic:\n      return LinkResolver::resolve_static_call_or_null(link_info);\n    case Bytecodes::_invokespecial:\n      return LinkResolver::resolve_special_call_or_null(link_info);\n    case Bytecodes::_invokeinterface:\n      return LinkResolver::linktime_resolve_interface_method_or_null(link_info);\n    case Bytecodes::_invokevirtual:\n      return LinkResolver::linktime_resolve_virtual_method_or_null(link_info);\n    default:\n      fatal(\"Unhandled bytecode: %s\", Bytecodes::name(bc));\n      return NULL; \n  }\n}", "target": 0}
{"code": "void AudioManagerBase::Shutdown() {\n  scoped_ptr<base::Thread> audio_thread;\n  {\n    base::AutoLock lock(audio_thread_lock_);\n    audio_thread_.swap(audio_thread);\n  }\n  if (!audio_thread.get())\n    return;\n  CHECK_NE(MessageLoop::current(), audio_thread->message_loop());\n  audio_thread->message_loop()->PostTask(FROM_HERE, base::Bind(\n      &AudioManagerBase::ShutdownOnAudioThread,\n      base::Unretained(this)));\n  audio_thread->Stop();\n}", "target": 0}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "ImagingNew(const char* mode, int xsize, int ysize)\n{\n    int bytes;\n    Imaging im;\n    if (strlen(mode) == 1) {\n        if (mode[0] == 'F' || mode[0] == 'I')\n            bytes = 4;\n        else\n            bytes = 1;\n    } else\n        bytes = strlen(mode); \n    if ((int64_t) xsize * (int64_t) ysize <= THRESHOLD / bytes) {\n        im = ImagingNewBlock(mode, xsize, ysize);\n        if (im)\n            return im;\n        ImagingError_Clear();\n    }\n    return ImagingNewArray(mode, xsize, ysize);\n}", "target": 1}
{"code": "static void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n\tint offset, upb;\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\treturn;\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n}", "target": 1}
{"code": "  void addCopy(const LowerCaseString& key, absl::string_view value) override {\n    HeaderMapImpl::addCopy(key, value);\n  }", "target": 0}
{"code": "unsigned get_next_char(ASS_Renderer *render_priv, char **str)\n{\n    char *p = *str;\n    unsigned chr;\n    if (*p == '\\t') {\n        ++p;\n        *str = p;\n        return ' ';\n    }\n    if (*p == '\\\\') {\n        if ((p[1] == 'N') || ((p[1] == 'n') &&\n                              (render_priv->state.wrap_style == 2))) {\n            p += 2;\n            *str = p;\n            return '\\n';\n        } else if (p[1] == 'n') {\n            p += 2;\n            *str = p;\n            return ' ';\n        } else if (p[1] == 'h') {\n            p += 2;\n            *str = p;\n            return NBSP;\n        } else if (p[1] == '{') {\n            p += 2;\n            *str = p;\n            return '{';\n        } else if (p[1] == '}') {\n            p += 2;\n            *str = p;\n            return '}';\n        }\n    }\n    chr = ass_utf8_get_char((char **) &p);\n    *str = p;\n    return chr;\n}", "target": 0}
{"code": "RedVDIReadBuf::~RedVDIReadBuf()\n{\n    dev->priv->num_read_buf--;\n    if (dev->priv->agent_attached) {\n       dev->wakeup();\n    }\n}", "target": 0}
{"code": "node_new_no_newline(Node** node, ScanEnv* env)\n{\n  Node* n;\n  n = node_new_anychar_with_fixed_option(ONIG_OPTION_NONE);\n  CHECK_NULL_RETURN_MEMERR(n);\n  *node = n;\n  return 0;\n}", "target": 0}
{"code": "void FrameLoader::startIconLoader()\n{\n    if (!isLoadingMainFrame())\n        return;\n    if (!iconDatabase() || !iconDatabase()->isEnabled())\n        return;\n    KURL url(iconURL());\n    String urlString(url.string());\n    if (urlString.isEmpty())\n        return;\n    if (loadType() != FrameLoadTypeReload && loadType() != FrameLoadTypeReloadFromOrigin) {\n        IconLoadDecision decision = iconDatabase()->loadDecisionForIconURL(urlString, m_documentLoader.get());\n        if (decision == IconLoadNo) {\n            LOG(IconDatabase, \"FrameLoader::startIconLoader() - Told not to load this icon, committing iconURL %s to database for pageURL mapping\", urlString.ascii().data());\n            commitIconURLToIconDatabase(url);\n            if (!iconDatabase()->iconDataKnownForIconURL(urlString)) {\n                LOG(IconDatabase, \"Told not to load icon %s but icon data is not yet available - registering for notification and requesting load from disk\", urlString.ascii().data());\n                m_client->registerForIconNotification();\n                iconDatabase()->iconForPageURL(m_URL.string(), IntSize(0, 0));\n                iconDatabase()->iconForPageURL(originalRequestURL().string(), IntSize(0, 0));\n            } else\n                m_client->dispatchDidReceiveIcon();\n            return;\n        } \n        if (decision == IconLoadUnknown) {\n            LOG(IconDatabase, \"FrameLoader %p might load icon %s later\", this, urlString.ascii().data());\n            m_mayLoadIconLater = true;    \n            m_client->registerForIconNotification();\n            commitIconURLToIconDatabase(url);\n            return;\n        }\n    }\n    Settings* settings = m_frame->settings();\n    if (settings && !settings->loadsImagesAutomatically())\n        return;\n    if (!m_iconLoader)\n        m_iconLoader.set(IconLoader::create(m_frame).release());\n    m_iconLoader->startLoading();\n}", "target": 0}
{"code": "ZEND_API void zend_ts_hash_reverse_apply(TsHashTable *ht, apply_func_t apply_func TSRMLS_DC)\n{\n\tbegin_write(ht);\n\tzend_hash_reverse_apply(TS_HASH(ht), apply_func TSRMLS_CC);\n\tend_write(ht);\n}", "target": 0}
{"code": "bits_set(unsigned int *selector, size_t selsize, int *bits)\n{\nfor(; *bits != -1; ++bits)\n  BIT_SET(selector, selsize, *bits);\n}", "target": 0}
{"code": "\t\tSetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "GC_API GC_ATTR_MALLOC void * GC_CALL GC_calloc_explicitly_typed(size_t n,\n                                                        size_t lb, GC_descr d)\n{\n    word *op;\n    size_t lg;\n    GC_descr simple_descr;\n    complex_descriptor *complex_descr;\n    int descr_type;\n    struct LeafDescriptor leaf;\n    GC_ASSERT(GC_explicit_typing_initialized);\n    descr_type = GC_make_array_descriptor((word)n, (word)lb, d, &simple_descr,\n                                          &complex_descr, &leaf);\n    switch(descr_type) {\n        case NO_MEM: return(0);\n        case SIMPLE: return(GC_malloc_explicitly_typed(n*lb, simple_descr));\n        case LEAF:\n            lb *= n;\n            lb += sizeof(struct LeafDescriptor) + TYPD_EXTRA_BYTES;\n            break;\n        case COMPLEX:\n            lb *= n;\n            lb += TYPD_EXTRA_BYTES;\n            break;\n    }\n    op = GC_malloc_kind(lb, GC_array_kind);\n    if (EXPECT(NULL == op, FALSE))\n        return NULL;\n    lg = SMALL_OBJ(lb) ? GC_size_map[lb] : BYTES_TO_GRANULES(GC_size(op));\n    if (descr_type == LEAF) {\n       volatile struct LeafDescriptor * lp =\n           (struct LeafDescriptor *)\n               (op + GRANULES_TO_WORDS(lg)\n                - (BYTES_TO_WORDS(sizeof(struct LeafDescriptor)) + 1));\n       lp -> ld_tag = LEAF_TAG;\n       lp -> ld_size = leaf.ld_size;\n       lp -> ld_nelements = leaf.ld_nelements;\n       lp -> ld_descriptor = leaf.ld_descriptor;\n       ((volatile word *)op)[GRANULES_TO_WORDS(lg) - 1] = (word)lp;\n   } else {\n#    ifndef GC_NO_FINALIZATION\n       size_t lw = GRANULES_TO_WORDS(lg);\n       op[lw - 1] = (word)complex_descr;\n       if (EXPECT(GC_general_register_disappearing_link(\n                                                (void **)(op + lw - 1), op)\n                  == GC_NO_MEMORY, FALSE))\n#    endif\n       {\n            return GC_malloc(lb);\n       }\n   }\n   return op;\n}", "target": 1}
{"code": "static ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tmutex_lock(&file->mut);\n\tmc = ucma_alloc_multicast(ctx);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tif (ret)\n\t\tgoto err2;\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n \t\tgoto err3;\n \t}\n \tmutex_unlock(&file->mut);\n \tucma_put_ctx(ctx);\n \treturn 0;\nerr3:\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tucma_cleanup_mc_events(mc);\nerr2:\n\tmutex_lock(&mut);\n\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\tlist_del(&mc->list);\n\tkfree(mc);\nerr1:\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}", "target": 1}
{"code": "static int mb86a20s_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tint val;\n\t*status = 0;\n\tval = mb86a20s_readreg(state, 0x0a) & 0xf;\n\tif (val < 0)\n\t\treturn val;\n\tif (val >= 2)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (val >= 4)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (val >= 5)\n\t\t*status |= FE_HAS_VITERBI;\n\tif (val >= 7)\n\t\t*status |= FE_HAS_SYNC;\n\tif (val >= 8)\t\t\t\t\n\t\t*status |= FE_HAS_LOCK;\n\tdev_dbg(&state->i2c->dev, \"%s: Status = 0x%02x (state = %d)\\n\",\n\t\t __func__, *status, val);\n\treturn val;\n}", "target": 1}
{"code": "MagickExport Quantum *QueueAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  const int\n    id = GetOpenMPThreadId();\n  Quantum\n    *magick_restrict pixels;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    {\n      pixels=cache_info->methods.queue_authentic_pixels_handler(image,x,y,\n        columns,rows,exception);\n      return(pixels);\n    }\n  assert(id < (int) cache_info->number_threads);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}", "target": 0}
{"code": "static void timelib_eat_spaces(char **ptr)\n{\n\twhile (**ptr == ' ' || **ptr == '\\t') {\n\t\t++*ptr;\n\t}\n}", "target": 0}
{"code": "void HeaderMapImpl::addReference(const LowerCaseString& key, absl::string_view value) {\n  HeaderString ref_key(key);\n  HeaderString ref_value(value);\n  insertByKey(std::move(ref_key), std::move(ref_value));\n}", "target": 0}
{"code": "list_session(char *log_dir, regex_t *re, const char *user, const char *tty)\n{\n    char idbuf[7], *idstr, *cp;\n    struct eventlog *evlog = NULL;\n    const char *timestr;\n    int ret = -1;\n    debug_decl(list_session, SUDO_DEBUG_UTIL);\n    if ((evlog = iolog_parse_loginfo(-1, log_dir)) == NULL)\n\tgoto done;\n    if (evlog->command == NULL || evlog->submituser == NULL ||\n\t    evlog->runuser == NULL) {\n\tgoto done;\n    }\n    if (!STAILQ_EMPTY(&search_expr) && !match_expr(&search_expr, evlog, true))\n\tgoto done;\n    cp = log_dir + strlen(session_dir) + 1;\n    if (IS_IDLOG(cp)) {\n\tidbuf[0] = cp[0];\n\tidbuf[1] = cp[1];\n\tidbuf[2] = cp[3];\n\tidbuf[3] = cp[4];\n\tidbuf[4] = cp[6];\n\tidbuf[5] = cp[7];\n\tidbuf[6] = '\\0';\n\tidstr = idbuf;\n    } else {\n\tidstr = cp;\n    }\n    timestr = get_timestr(evlog->submit_time.tv_sec, 1);\n    printf(\"%s : %s : \", timestr ? timestr : \"invalid date\", evlog->submituser);\n    if (evlog->submithost != NULL)\n\tprintf(\"HOST=%s ; \", evlog->submithost);\n    if (evlog->ttyname != NULL)\n\tprintf(\"TTY=%s ; \", evlog->ttyname);\n    if (evlog->runchroot != NULL)\n\tprintf(\"CHROOT=%s ; \", evlog->runchroot);\n    if (evlog->runcwd != NULL || evlog->cwd != NULL)\n\tprintf(\"CWD=%s ; \", evlog->runcwd ? evlog->runcwd : evlog->cwd);\n    printf(\"USER=%s ; \", evlog->runuser);\n    if (evlog->rungroup != NULL)\n\tprintf(\"GROUP=%s ; \", evlog->rungroup);\n    printf(\"TSID=%s ; COMMAND=%s\\n\", idstr, evlog->command);\n    ret = 0;\ndone:\n    eventlog_free(evlog);\n    debug_return_int(ret);\n}", "target": 1}
{"code": "parse_CLEAR_ACTIONS(char *arg OVS_UNUSED, const struct ofpact_parse_params *pp)\n{\n    ofpact_put_CLEAR_ACTIONS(pp->ofpacts);\n    return NULL;\n}", "target": 0}
{"code": "ring_set_paused(const struct intel_engine_cs *engine, int state)\n{\n\tengine->status_page.addr[I915_GEM_HWS_PREEMPT] = state;\n\tif (state)\n\t\twmb();\n}", "target": 0}
{"code": "static WebGestureEvent fatTap(int x, int y)\n{\n    WebGestureEvent event;\n    event.type = WebInputEvent::GestureTap;\n    event.x = x;\n    event.y = y;\n    event.data.tap.width = 50;\n    event.data.tap.height = 50;\n    return event;\n}", "target": 0}
{"code": "static void ff_layout_put_mirror(struct nfs4_ff_layout_mirror *mirror)\n{\n\tif (mirror != NULL && refcount_dec_and_test(&mirror->ref))\n\t\tff_layout_free_mirror(mirror);\n}", "target": 0}
{"code": "int WebGraphicsContext3DDefaultImpl::sizeInBytes(int type)\n{\n    switch (type) {\n    case GL_BYTE:\n        return sizeof(GLbyte);\n    case GL_UNSIGNED_BYTE:\n        return sizeof(GLubyte);\n    case GL_SHORT:\n        return sizeof(GLshort);\n    case GL_UNSIGNED_SHORT:\n        return sizeof(GLushort);\n    case GL_INT:\n        return sizeof(GLint);\n    case GL_UNSIGNED_INT:\n        return sizeof(GLuint);\n    case GL_FLOAT:\n        return sizeof(GLfloat);\n    }\n    return 0;\n}", "target": 0}
{"code": "onig_get_callout_data(regex_t* reg, OnigMatchParam* mp,\n                      int callout_num, int slot,\n                      OnigType* type, OnigValue* val)\n{\n  OnigType t;\n  CalloutData* d;\n  if (callout_num <= 0) return ONIGERR_INVALID_ARGUMENT;\n  d = CALLOUT_DATA_AT_NUM(mp, callout_num);\n  if (d->last_match_at_call_counter != mp->match_at_call_counter) {\n    xmemset(d, 0, sizeof(*d));\n    d->last_match_at_call_counter = mp->match_at_call_counter;\n  }\n  t = d->slot[slot].type;\n  if (IS_NOT_NULL(type)) *type = t;\n  if (IS_NOT_NULL(val))  *val  = d->slot[slot].val;\n  return (t == ONIG_TYPE_VOID ? 1 : ONIG_NORMAL);\n}", "target": 0}
{"code": "static int find_subprog(struct bpf_verifier_env *env, int off)\n{\n\tstruct bpf_subprog_info *p;\n\tp = bsearch(&off, env->subprog_info, env->subprog_cnt,\n\t\t    sizeof(env->subprog_info[0]), cmp_subprogs);\n\tif (!p)\n\t\treturn -ENOENT;\n\treturn p - env->subprog_info;\n}", "target": 0}
{"code": "static int dwc3_qcom_acpi_register_core(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom\t*qcom = platform_get_drvdata(pdev);\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct resource\t\t*res, *child_res = NULL;\n\tstruct platform_device\t*pdev_irq = qcom->urs_usb ? qcom->urs_usb :\n\t\t\t\t\t\t\t    pdev;\n\tint\t\t\tirq;\n\tint\t\t\tret;\n\tqcom->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!qcom->dwc3)\n\t\treturn -ENOMEM;\n\tqcom->dwc3->dev.parent = dev;\n\tqcom->dwc3->dev.type = dev->type;\n\tqcom->dwc3->dev.dma_mask = dev->dma_mask;\n\tqcom->dwc3->dev.dma_parms = dev->dma_parms;\n\tqcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;\n\tchild_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL);\n\tif (!child_res)\n\t\treturn -ENOMEM;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to get memory resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tchild_res[0].flags = res->flags;\n\tchild_res[0].start = res->start;\n\tchild_res[0].end = child_res[0].start +\n\t\tqcom->acpi_pdata->dwc3_core_base_size;\n\tirq = platform_get_irq(pdev_irq, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out;\n\t}\n\tchild_res[1].flags = IORESOURCE_IRQ;\n\tchild_res[1].start = child_res[1].end = irq;\n\tret = platform_device_add_resources(qcom->dwc3, child_res, 2);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add resources\\n\");\n\t\tgoto out;\n\t}\n\tret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add properties\\n\");\n\t\tgoto out;\n\t}\n\tret = platform_device_add(qcom->dwc3);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add device\\n\");\n\t\tdevice_remove_software_node(&qcom->dwc3->dev);\n\t}\nout:\n\tkfree(child_res);\n\treturn ret;\n}", "target": 1}
{"code": "int mbedtls_asn1_write_null( unsigned char **p, unsigned char *start )\n{\n    int ret;\n    size_t len = 0;\n    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, 0) );\n    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_NULL ) );\n    return( (int) len );\n}", "target": 0}
{"code": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n \t\t\t\tstruct pipe_buffer *buf)\n {\n \tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n \tref->ref++;\n }", "target": 1}
{"code": "void InstanceKlass::mask_for(const methodHandle& method, int bci,\n  InterpreterOopMap* entry_for) {\n  OopMapCache* oop_map_cache = Atomic::load_acquire(&_oop_map_cache);\n  if (oop_map_cache == NULL) {\n    MutexLocker x(OopMapCacheAlloc_lock);\n    if ((oop_map_cache = _oop_map_cache) == NULL) {\n      oop_map_cache = new OopMapCache();\n      Atomic::release_store(&_oop_map_cache, oop_map_cache);\n    }\n  }\n  oop_map_cache->lookup(method, bci, entry_for);\n}", "target": 0}
{"code": "static long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG;\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(buf, (void *)arg, hdr.size_in)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "static void __exit packet_exit(void)\n{\n\tunregister_netdevice_notifier(&packet_netdev_notifier);\n\tunregister_pernet_subsys(&packet_net_ops);\n\tsock_unregister(PF_PACKET);\n\tproto_unregister(&packet_proto);\n}", "target": 0}
{"code": "    DateValue* DateValue::clone_() const\n    {\n        return new DateValue(*this);\n    }", "target": 0}
{"code": "vte_sequence_handler_kb (VteTerminal *terminal, GValueArray *params)\n{\n\tvte_sequence_handler_le (terminal, params);\n}", "target": 0}
{"code": "CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config,\n    Api::Api& api)\n    : ca_cert_(Config::DataSource::read(config.trusted_ca(), true, api)),\n      ca_cert_path_(Config::DataSource::getPath(config.trusted_ca())\n                        .value_or(ca_cert_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      certificate_revocation_list_(Config::DataSource::read(config.crl(), true, api)),\n      certificate_revocation_list_path_(\n          Config::DataSource::getPath(config.crl())\n              .value_or(certificate_revocation_list_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      subject_alt_name_matchers_(config.match_subject_alt_names().begin(),\n                                 config.match_subject_alt_names().end()),\n      verify_certificate_hash_list_(config.verify_certificate_hash().begin(),\n                                    config.verify_certificate_hash().end()),\n      verify_certificate_spki_list_(config.verify_certificate_spki().begin(),\n                                    config.verify_certificate_spki().end()),\n      allow_expired_certificate_(config.allow_expired_certificate()),\n      trust_chain_verification_(config.trust_chain_verification()),\n      custom_validator_config_(\n          config.has_custom_validator_config()\n              ? absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>(\n                    config.custom_validator_config())\n              : absl::nullopt),\n      api_(api), only_verify_leaf_cert_crl_(config.only_verify_leaf_cert_crl()) {\n  if (ca_cert_.empty() && custom_validator_config_ == absl::nullopt) {\n    if (!certificate_revocation_list_.empty()) {\n      throw EnvoyException(fmt::format(\"Failed to load CRL from {} without trusted CA\",\n                                       certificateRevocationListPath()));\n    }\n    if (!subject_alt_name_matchers_.empty()) {\n      throw EnvoyException(\"SAN-based verification of peer certificates without \"\n                           \"trusted CA is insecure and not allowed\");\n    }\n    if (allow_expired_certificate_) {\n      throw EnvoyException(\"Certificate validity period is always ignored without trusted CA\");\n    }\n  }\n}", "target": 1}
{"code": "std_term_source(j_decompress_ptr cinfo)\n{\n\t(void) cinfo;\n}", "target": 0}
{"code": "elf32_set_personality (void)\n{\n\tset_personality(PER_LINUX32);\n\tcurrent->thread.map_base  = IA32_PAGE_OFFSET/3;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto x = ctx->input(0);\n    auto i = ctx->input(1);\n    auto v = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(i.shape()),\n                errors::InvalidArgument(\"i must be a vector. \",\n                                        i.shape().DebugString()));\n    OP_REQUIRES(ctx, x.dims() == v.dims(),\n                errors::InvalidArgument(\n                    \"x and v shape doesn't match (ranks differ): \",\n                    x.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    for (int i = 1; i < x.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, x.dim_size(i) == v.dim_size(i),\n          errors::InvalidArgument(\"x and v shape doesn't match at index \", i,\n                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    Tensor y = x;  \n    if (x.NumElements() > 0 || v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }", "target": 1}
{"code": "int server_supports_v2(const char *c, int die_on_error)\n{\n\tint i;\n\tfor (i = 0; i < server_capabilities_v2.argc; i++) {\n\t\tconst char *out;\n\t\tif (skip_prefix(server_capabilities_v2.argv[i], c, &out) &&\n\t\t    (!*out || *out == '='))\n\t\t\treturn 1;\n\t}\n\tif (die_on_error)\n\t\tdie(_(\"server doesn't support '%s'\"), c);\n\treturn 0;\n}", "target": 0}
{"code": "static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,\n        Packet *p, Flow * const pflow)\n{\n    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_CLEANUP);\n    PacketPatternCleanup(det_ctx);\n     if (pflow != NULL) {\n        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL) {\n             StreamReassembleRawUpdateProgress(pflow->protoctx, p,\n                     det_ctx->raw_stream_progress);\n            DetectEngineCleanHCBDBuffers(det_ctx);\n        }\n    }\n    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_CLEANUP);\n    SCReturn;\n}", "target": 1}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}", "target": 1}
{"code": "    TiffComponent* newOlympusMn(uint16_t    tag,\n                                IfdId       group,\n                                IfdId       ,\n                                const byte* pData,\n                                uint32_t    size,\n                                ByteOrder   )\n    {\n        if (size < 10 ||   std::string(reinterpret_cast<const char*>(pData), 10)\n                        != std::string(\"OLYMPUS\\0II\", 10)) {\n            if (size < OlympusMnHeader::sizeOfSignature() + 18) return 0;\n            return newOlympusMn2(tag, group, olympusId);\n        }\n        if (size < Olympus2MnHeader::sizeOfSignature() + 18) return 0;\n        return newOlympus2Mn2(tag, group, olympus2Id);\n    }", "target": 0}
{"code": "int nfc_dev_up(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->rfkill && rfkill_blocked(dev->rfkill)) {\n\t\trc = -ERFKILL;\n\t\tgoto error;\n\t}\n\tif (dev->fw_download_in_progress) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_up)\n\t\trc = dev->ops->dev_up(dev);\n\tif (!rc)\n\t\tdev->dev_up = true;\n\tif (dev->ops->discover_se && dev->ops->discover_se(dev))\n\t\tpr_err(\"SE discovery failed\\n\");\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "fbStore_a1r1g1b1 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  pixel;\n        Splita(READ(values + i));\n        pixel = (((a >> 4) & 0x8) |\n                 ((r >> 5) & 0x4) |\n                 ((g >> 6) & 0x2) |\n                 ((b >> 7)      ));\n        Store4(bits, i + x, pixel);\n    }\n}", "target": 0}
{"code": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\nerr_out:\n\tkfree(rule_buf);\n\treturn ret;\n}", "target": 1}
{"code": " status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {\n     uint8_t nalUnitType = (data[0] >> 1) & 0x3f;\n     status_t err = OK;\n     switch (nalUnitType) {\n         case 32:  \n             err = parseVps(data + 2, size - 2);\n             break;\n         case 33:  \n             err = parseSps(data + 2, size - 2);\n             break;\n         case 34:  \n             err = parsePps(data + 2, size - 2);\n             break;\n         case 39:  \n case 40: \n break;\n default:\n            ALOGE(\"Unrecognized NAL unit type.\");\n return ERROR_MALFORMED;\n }\n if (err != OK) {\n return err;\n }\n    sp<ABuffer> buffer = ABuffer::CreateAsCopy(data, size);\n    buffer->setInt32Data(nalUnitType);\n    mNalUnits.push(buffer);\n return OK;\n}", "target": 1}
{"code": "get_text_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),\n                         ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),)\n  } else {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],\n                         ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],)\n  }\n  return 1;\n}", "target": 0}
{"code": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n\t\treturn -ENOMEM;\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(hx);\n\t\treturn ret;\n\t}\n\tif (ret == 0) {\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\tkfree(hx);\n\treturn ret;\n}", "target": 1}
{"code": "static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\n{\n  unsigned error = 0;\n  char *key = 0, *str = 0;\n  unsigned i;\n  while(!error) \n  {\n    unsigned length, string2_begin;\n    length = 0;\n    while(length < chunkLength && data[length] != 0) length++;\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); \n    key = (char*)malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); \n    key[length] = 0;\n    for(i = 0; i < length; i++) key[i] = (char)data[i];\n    string2_begin = length + 1; \n    length = chunkLength < string2_begin ? 0 : chunkLength - string2_begin;\n    str = (char*)malloc(length + 1);\n    if(!str) CERROR_BREAK(error, 83); \n    str[length] = 0;\n    for(i = 0; i < length; i++) str[i] = (char)data[string2_begin + i];\n    error = lodepng_add_text(info, key, str);\n    break;\n  }\n  free(key);\n  free(str);\n  return error;\n}", "target": 0}
{"code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n     darray_append(expr->keysym_list.symsNumEntries, numEntries);\n     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n     return expr;\n }", "target": 1}
{"code": "bool kvm_check_and_clear_guest_paused(void)\n{\n\tbool ret = false;\n\tstruct pvclock_vcpu_time_info *src;\n\tint cpu = smp_processor_id();\n\tif (!hv_clock)\n\t\treturn ret;\n\tsrc = &hv_clock[cpu].pvti;\n\tif ((src->flags & PVCLOCK_GUEST_STOPPED) != 0) {\n\t\tsrc->flags &= ~PVCLOCK_GUEST_STOPPED;\n\t\tpvclock_touch_watchdogs();\n\t\tret = true;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int em_clflush(struct x86_emulate_ctxt *ctxt)\n{\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static int idprime_select_idprime(sc_card_t *card)\n{\n\treturn iso_ops->select_file(card, &idprime_path, NULL);\n}", "target": 0}
{"code": "GF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;", "target": 0}
{"code": "   Return current UNIX timestamp */\nPHP_FUNCTION(time)\n{\n\tRETURN_LONG((long)time(NULL));", "target": 0}
{"code": "xmalloc (size_t size)\n{\n    void *ptr = malloc (size);\n    if (!ptr \n        && (size != 0))         \n    {\n        perror (\"xmalloc: Memory allocation failure\");\n        abort();\n    }\n    return ptr;\n}", "target": 1}
{"code": "static void bio_chain_endio(struct bio *bio)\n{\n\tbio_endio(__bio_chain_endio(bio));\n}", "target": 0}
{"code": "static void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval = 0;\n\tint port_number;\n\tint status = urb->status;\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\", __func__, status);\n\t}\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n \tport_number = edge_port->port->port_number;\n\tif (edge_port->lsr_event) {\n \t\tedge_port->lsr_event = 0;\n \t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n \t\t\t__func__, port_number, edge_port->lsr_mask, *data);\n\t\thandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\n\t\t--urb->actual_length;\n\t\t++data;\n\t}\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\t\tif (edge_port->close_pending)\n\t\t\tdev_dbg(dev, \"%s - close pending, dropping data on the floor\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\telse\n\t\t\tedge_tty_recv(edge_port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\tedge_port->port->icount.rx += urb->actual_length;\n\t}\nexit:\n\tspin_lock(&edge_port->ep_lock);\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\n\tspin_unlock(&edge_port->ep_lock);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\", __func__, retval);\n}", "target": 1}
{"code": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n         size2 = avio_rb32(pb);\n         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, mime);\n         if (ret < 0)\n             return ret;\n     }\n    return 0;\n}", "target": 1}
{"code": "void BrowserTitlebar::UpdateThrobber(TabContents* tab_contents) {\n  DCHECK(app_mode_favicon_);\n  if (tab_contents && tab_contents->is_loading()) {\n    GdkPixbuf* icon_pixbuf =\n        throbber_.GetNextFrame(tab_contents->waiting_for_response());\n    gtk_image_set_from_pixbuf(GTK_IMAGE(app_mode_favicon_), icon_pixbuf);\n  } else {\n    ResourceBundle& rb = ResourceBundle::GetSharedInstance();\n    if (browser_window_->browser()->type() == Browser::TYPE_APP) {\n      SkBitmap icon = browser_window_->browser()->GetCurrentPageIcon();\n      if (icon.empty()) {\n        gtk_image_set_from_pixbuf(GTK_IMAGE(app_mode_favicon_),\n            rb.GetPixbufNamed(IDR_PRODUCT_LOGO_16));\n      } else {\n        GdkPixbuf* icon_pixbuf = gfx::GdkPixbufFromSkBitmap(&icon);\n        gtk_image_set_from_pixbuf(GTK_IMAGE(app_mode_favicon_), icon_pixbuf);\n        g_object_unref(icon_pixbuf);\n      }\n    } else {\n      gtk_image_set_from_pixbuf(GTK_IMAGE(app_mode_favicon_),\n          rb.GetPixbufNamed(IDR_PRODUCT_LOGO_16));\n    }\n    throbber_.Reset();\n  }\n}", "target": 0}
{"code": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), len);\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n  return result;\n}", "target": 1}
{"code": "pxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\tint words = count / 4;\n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\tbuffer->length = words;\n\tbuffer->ptr[words] = 0x01000000;\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer->next = NULL;\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\tpriv->ready_last = buffer;\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\treturn words * 4;\n}", "target": 1}
{"code": "static inline unsigned long virt_to_dma_pfn(void *p)\n{\n\treturn page_to_dma_pfn(virt_to_page(p));\n}", "target": 0}
{"code": "fbStore_a1 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  *pixel = ((CARD32 *) bits) + ((i+x) >> 5);\n        CARD32  mask = FbStipMask((i+x) & 0x1f, 1);\n        CARD32 v = READ(values + i) & 0x80000000 ? mask : 0;\n        WRITE(pixel, (READ(pixel) & ~mask) | v);\n    }\n}", "target": 0}
{"code": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\tfree(originator);\n\tfree(target);\n\treturn c;\n}", "target": 1}
{"code": "KCleanup::KCleanup( QString\t\tid,\n\t\t    QString\t\tcommand,\n\t\t    QString\t\ttitle,\n\t\t    KActionCollection *\tparent\t)\n    : KAction( title,\n\t       parent)\n    , _id\t( id\t  )\n    , _command\t( command )\n    , _title\t( title\t  )\n{\n    _selection\t\t= 0;\n    _enabled\t\t= true;\n    _worksForDir\t= true;\n    _worksForFile\t= false;\n    _worksForDotEntry\t= false;\n    _worksLocalOnly\t= true;\n    _recurse\t\t= false;\n    _askForConfirmation\t= false;\n    _refreshPolicy\t= noRefresh;\n    KAction::setEnabled( false );\n    parent->addAction(id,this);\n    connect(this, SIGNAL(triggered()),\n            this, SLOT(executeWithSelection()));\n}", "target": 0}
{"code": "    void TimeValue::setTime( const Time& src )\n    {\n        std::memcpy(&time_, &src, sizeof(time_));\n    }", "target": 0}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n\tassert(bufsize >= 0);\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n \tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n \t  bufsize) {\n \t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "int infra_ip_ratelimit_inc(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint has_cookie, int backoff, struct sldns_buffer* buffer)\n{\n\tint max;\n\tstruct lruhash_entry* entry;\n\tif(!infra_ip_ratelimit) {\n\t\treturn 1;\n\t}\n\tentry = infra_find_ip_ratedata(infra, addr, addrlen, 1);\n\tif(entry) {\n\t\tint premax = infra_rate_max(entry->data, timenow, backoff);\n\t\tint* cur = infra_rate_give_second(entry->data, timenow);\n\t\t(*cur)++;\n\t\tmax = infra_rate_max(entry->data, timenow, backoff);\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn check_ip_ratelimit(addr, addrlen, buffer, premax, max,\n\t\t\thas_cookie);\n\t}\n\tinfra_ip_create_ratedata(infra, addr, addrlen, timenow);\n\treturn 1;\n}", "target": 1}
{"code": "bool extract_sockaddr(struct pool *pool, char *url)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\turl_begin = strstr(url, \"\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\tif (url_len < 1)\n\t\treturn false;\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\tif (port_len)\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\telse\n\t\tstrcpy(port, \"80\");\n\tfree(pool->stratum_port);\n\tpool->stratum_port = strdup(port);\n\tfree(pool->sockaddr_url);\n\tpool->sockaddr_url = strdup(url_address);\n\treturn true;\n}", "target": 1}
{"code": "static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newpos;\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\treturn m->pos_;\n}", "target": 1}
{"code": "static inline int pmd_soft_dirty(pmd_t pmd)\n{\n\treturn 0;\n}", "target": 0}
{"code": "static int open_fuse_device(char **devp)\n{\n\tint fd = try_open_fuse_device(devp);\n\tif (fd >= -1)\n\t\treturn fd;\n\tfprintf(stderr,\n\t\t\"%s: fuse device not found, try 'modprobe fuse' first\\n\",\n\t\tprogname);\n\treturn -1;\n}", "target": 0}
{"code": " static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n \tut8 op_MSB,op_LSB;\n \tint ret;\n\tif (!data)\n \t\treturn 0;\n \tmemset (op, '\\0', sizeof (RAnalOp));\n \top->addr = addr;\n \top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\top->size = 2;\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}", "target": 1}
{"code": "static int io_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 io_info = svm->vmcb->control.exit_info_1; \n\tint size, in, string;\n\tunsigned port;\n\t++svm->vcpu.stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn kvm_fast_pio_out(vcpu, size, port);\n}", "target": 0}
{"code": "static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\tint retval = 0;\n\tstruct file_handle f_handle;\n\tstruct file_handle *handle = NULL;\n\tif (!capable(CAP_DAC_READ_SEARCH)) {\n\t\tretval = -EPERM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\n\t\tretval = -EFAULT;\n\t\tgoto out_err;\n\t}\n\tif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\n\t    (f_handle.handle_bytes == 0)) {\n\t\tretval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(handle, ufh,\n\t\t\t   sizeof(struct file_handle) +\n\t\t\t   f_handle.handle_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_handle;\n\t}\n\tretval = do_handle_to_path(mountdirfd, handle, path);\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}", "target": 1}
{"code": "void bootp_input(struct mbuf *m)\n{\n    struct bootp_t *bp = mtod_check(m, sizeof(struct bootp_t));\n    if (bp && bp->bp_op == BOOTP_REQUEST) {\n        bootp_reply(m->slirp, bp, m_end(m));\n    }\n}", "target": 0}
{"code": "   Convert an 8-bit string to a quoted-printable string */\nPHP_FUNCTION(imap_8bit)\n{\n\tzend_string *text;\n\tchar *decode;\n\tunsigned long newlength;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"S\", &text) == FAILURE) {\n\t\treturn;\n\t}\n\tdecode = (char *) rfc822_8bit((unsigned char *) ZSTR_VAL(text), ZSTR_LEN(text), &newlength);\n\tif (decode == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(decode, newlength);\n\tfs_give((void**) &decode);", "target": 0}
{"code": "static inline u32 nfsd4_write_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + op_encode_verifier_maxsz) * sizeof(__be32);\n}", "target": 0}
{"code": "static int snd_usb_novation_boot_quirk(struct usb_device *dev)\n{\n\tusb_set_interface(dev, 0, 1);\n\treturn 0;\n}", "target": 0}
{"code": "QString Helper::temporaryMountDevice(const QString &device, const QString &name, bool readonly)\n{\n    QString mount_point = mountPoint(device);\n    if (!mount_point.isEmpty())\n        return mount_point;\n    mount_point = \"%1/.%2/mount/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n        return QString();\n    }\n    if (!mountDevice(device, mount_point, readonly)) {\n        dCError(\"Mount the device \\\"%s\\\" to \\\"%s\\\" failed\", qPrintable(device), qPrintable(mount_point));\n        return QString();\n    }\n    return mount_point;\n}", "target": 1}
{"code": " int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n {\n \tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n \t\treturn -ENOMEM;\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n \t\terr(\"could not stop the USB controller CPU.\");\n \twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n \t}\n \tif (ret < 0) {\n \t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(hx);\n \t\treturn ret;\n \t}\n \tif (ret == 0) {\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n \t\t\terr(\"could not restart the USB controller CPU.\");\n \t\t\tret = -EINVAL;\n \t\t}\n \t} else\n \t\tret = -EIO;\n\tkfree(hx);\n \treturn ret;\n }", "target": 1}
{"code": "static inline void __skb_queue_head(struct sk_buff_head *list,\n\t\t\t\t    struct sk_buff *newsk)\n{\n\t__skb_queue_after(list, (struct sk_buff *)list, newsk);\n}", "target": 0}
{"code": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}", "target": 1}
{"code": " void SetUpFontconfig() {\n  std::unique_ptr<Environment> env = Environment::Create();\n  if (!env->HasVar(\"FONTCONFIG_FILE\")) {\n    FilePath dir_module;\n    PathService::Get(DIR_MODULE, &dir_module);\n    FilePath font_cache = dir_module.Append(\"fontconfig_caches\");\n    FilePath test_fonts = dir_module.Append(\"test_fonts\");\n    std::string fonts_conf = ReplaceStringPlaceholders(\n        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);\n    FilePath fonts_conf_file_temp;\n    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));\n    CHECK(\n        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));\n    FilePath fonts_conf_file = dir_module.Append(\"fonts.conf\");\n    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));\n    env->SetVar(\"FONTCONFIG_FILE\", fonts_conf_file.value());\n  }\n  CHECK(FcInit());\n }", "target": 1}
{"code": "void InstanceKlass::mask_for(const methodHandle& method, int bci,\n  InterpreterOopMap* entry_for) {\n  OopMapCache* oop_map_cache = OrderAccess::load_acquire(&_oop_map_cache);\n  if (oop_map_cache == NULL) {\n    MutexLocker x(OopMapCacheAlloc_lock);\n    if ((oop_map_cache = _oop_map_cache) == NULL) {\n      oop_map_cache = new OopMapCache();\n      OrderAccess::release_store(&_oop_map_cache, oop_map_cache);\n    }\n  }\n  oop_map_cache->lookup(method, bci, entry_for);\n}", "target": 0}
{"code": "    int Insert::insertThumbnail(const std::string& path) const\n    {\n        std::string thumbPath = newFilePath(path, \"-thumb.jpg\");\n        if (!Exiv2::fileExists(thumbPath, true)) {\n            std::cerr << thumbPath << \": \" << _(\"Failed to open the file\\n\");\n            return -1;\n        }\n        if (!Exiv2::fileExists(path, true)) {\n            std::cerr << path << \": \" << _(\"Failed to open the file\\n\");\n            return -1;\n        }\n        Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open(path);\n        image->readMetadata();\n        Exiv2::ExifThumb exifThumb(image->exifData());\n        exifThumb.setJpegThumbnail(thumbPath);\n        image->writeMetadata();\n        return 0;\n    }", "target": 0}
{"code": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"sock=%p\\n\", sock);\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": " _prolog_error(batch_job_launch_msg_t *req, int rc)\n {\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n \t\t\treq->work_dir, err_name_ptr);\n \telse\n \t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n \t\treturn;\n \t}\n \tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}", "target": 1}
{"code": "mono_get_method (MonoImage *image, guint32 token, MonoClass *klass)\n{\n\treturn mono_get_method_full (image, token, klass, NULL);\n}", "target": 0}
{"code": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}", "target": 1}
{"code": "sc_get_iasecc_driver(void)\n{\n\treturn sc_get_driver();\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(date_create_from_format)\n{\n\tzval           *timezone_object = NULL;\n\tchar           *time_str = NULL, *format_str = NULL;\n\tint             time_str_len = 0, format_str_len = 0;\n\tzval            datetime_object;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|O\", &format_str, &format_str_len, &time_str, &time_str_len, &timezone_object, date_ce_timezone) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tphp_date_instantiate(date_ce_date, &datetime_object TSRMLS_CC);\n\tif (!php_date_initialize(zend_object_store_get_object(&datetime_object TSRMLS_CC), time_str, time_str_len, format_str, timezone_object, 0 TSRMLS_CC)) {\n\t\tzval_dtor(&datetime_object);\n\t\tRETURN_FALSE;\n\t} else {\n\t\tzval *datetime_object_ptr = &datetime_object;\n\t\tRETVAL_ZVAL(datetime_object_ptr, 0, 0);\n\t}", "target": 0}
{"code": "String Document::cookie(ExceptionState& exception_state) const {\n  if (GetSettings() && !GetSettings()->GetCookieEnabled())\n    return String();\n  UseCounter::Count(*this, WebFeature::kCookieGet);\n  if (!GetSecurityOrigin()->CanAccessCookies()) {\n    if (IsSandboxed(kSandboxOrigin))\n      exception_state.ThrowSecurityError(\n          \"The document is sandboxed and lacks the 'allow-same-origin' flag.\");\n    else if (Url().ProtocolIs(\"data\"))\n      exception_state.ThrowSecurityError(\n          \"Cookies are disabled inside 'data:' URLs.\");\n    else\n      exception_state.ThrowSecurityError(\"Access is denied for this document.\");\n    return String();\n  }\n  if (GetSecurityOrigin()->HasSuborigin() &&\n      !GetSecurityOrigin()->GetSuborigin()->PolicyContains(\n          Suborigin::SuboriginPolicyOptions::kUnsafeCookies))\n    return String();\n  KURL cookie_url = CookieURL();\n  if (cookie_url.IsEmpty())\n    return String();\n  return Cookies(this, cookie_url);\n}", "target": 0}
{"code": "static void __mcheck_cpu_init_generic(void)\n{\n\tenum mcp_flags m_fl = 0;\n\tmce_banks_t all_banks;\n\tu64 cap;\n\tif (!mca_cfg.bootlog)\n\t\tm_fl = MCP_DONTLOG;\n\tbitmap_fill(all_banks, MAX_NR_BANKS);\n\tmachine_check_poll(MCP_UC | m_fl, &all_banks);\n\tcr4_set_bits(X86_CR4_MCE);\n\trdmsrl(MSR_IA32_MCG_CAP, cap);\n\tif (cap & MCG_CTL_P)\n\t\twrmsr(MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);\n}", "target": 0}
{"code": "static int emsff_init(struct hid_device *hid)\n{\n\tstruct emsff_device *emsff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_first_entry(&hid->inputs,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\temsff = kzalloc(sizeof(struct emsff_device), GFP_KERNEL);\n\tif (!emsff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, emsff, emsff_play);\n\tif (error) {\n\t\tkfree(emsff);\n\t\treturn error;\n\t}\n\temsff->report = report;\n\temsff->report->field[0]->value[0] = 0x01;\n\temsff->report->field[0]->value[1] = 0x00;\n\temsff->report->field[0]->value[2] = 0x00;\n\temsff->report->field[0]->value[3] = 0x00;\n\temsff->report->field[0]->value[4] = 0x00;\n\temsff->report->field[0]->value[5] = 0x00;\n\temsff->report->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, emsff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"force feedback for EMS based devices by Ignaz Forster <ignaz.forster@gmx.de>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, SkipEvaluatesBeforeFetchForIndexedOr) {\n    addIndex(fromjson(\"{a: 1}\"));\n    runQuerySkipNToReturn(fromjson(\"{$or: [{a: 5}, {a: 7}]}\"), 8, 0);\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{skip: {n: 8, node: \"\n        \"{cscan: {dir: 1, filter: {$or: [{a: 5}, {a: 7}]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {skip: {n: 8, node: \"\n        \"{ixscan: {filter: null, pattern: {a: 1}}}}}}}\");\n}", "target": 0}
{"code": "is_html_type(char *type)\n{\n    return (type && (strcasecmp(type, \"text/html\") == 0 ||\n\t\t     strcasecmp(type, \"application/xhtml+xml\") == 0));\n}", "target": 0}
{"code": "mix_pool(unsigned char *pool)\n{\n  static unsigned char failsafe_digest[DIGESTLEN];\n  static int failsafe_digest_valid;\n  unsigned char *hashbuf = pool + POOLSIZE;\n  unsigned char *p, *pend;\n  int i, n;\n  SHA1_CONTEXT md;\n  unsigned int nburn;\n#if DIGESTLEN != 20\n#error must have a digest length of 20 for SHA-1\n#endif\n  gcry_assert (pool_is_locked);\n  _gcry_sha1_mixblock_init (&md);\n  pend = pool + POOLSIZE;\n  memcpy (hashbuf, pend - DIGESTLEN, DIGESTLEN );\n  memcpy (hashbuf+DIGESTLEN, pool, BLOCKLEN-DIGESTLEN);\n  nburn = _gcry_sha1_mixblock (&md, hashbuf);\n  memcpy (pool, hashbuf, DIGESTLEN);\n  if (failsafe_digest_valid && pool == rndpool)\n    {\n      for (i=0; i < DIGESTLEN; i++)\n        pool[i] ^= failsafe_digest[i];\n    }\n  p = pool;\n  for (n=1; n < POOLBLOCKS; n++)\n    {\n      memcpy (hashbuf, p, DIGESTLEN);\n      p += DIGESTLEN;\n      if (p+DIGESTLEN+BLOCKLEN < pend)\n        memcpy (hashbuf+DIGESTLEN, p+DIGESTLEN, BLOCKLEN-DIGESTLEN);\n      else\n        {\n          unsigned char *pp = p + DIGESTLEN;\n          for (i=DIGESTLEN; i < BLOCKLEN; i++ )\n            {\n              if ( pp >= pend )\n                pp = pool;\n              hashbuf[i] = *pp++;\n\t    }\n\t}\n      _gcry_sha1_mixblock (&md, hashbuf);\n      memcpy(p, hashbuf, DIGESTLEN);\n    }\n  if ( pool == rndpool)\n    {\n      _gcry_sha1_hash_buffer (failsafe_digest, pool, POOLSIZE);\n      failsafe_digest_valid = 1;\n    }\n  _gcry_burn_stack (nburn);\n}", "target": 1}
{"code": "  cf2_initGlobalRegionBuffer( CFF_Decoder*  decoder,\n                               CF2_UInt      idx,\n                               CF2_Buffer    buf )\n   {\n    FT_ASSERT( decoder && decoder->globals );\n     FT_ZERO( buf );\n    idx += decoder->globals_bias;\n     if ( idx >= decoder->num_globals )\n       return TRUE;     \n     buf->start =\n     buf->ptr   = decoder->globals[idx];\n     buf->end   = decoder->globals[idx + 1];\n  }", "target": 1}
{"code": "static MagickPixelPacket **DestroyPixelThreadSet(const Image *images,\n  MagickPixelPacket **pixels)\n{\n  ssize_t\n    i;\n  size_t\n    rows;\n  assert(pixels != (MagickPixelPacket **) NULL);\n  rows=MagickMax(GetImageListLength(images),\n    (size_t) GetMagickResourceLimit(ThreadResource));\n  for (i=0; i < (ssize_t) rows; i++)\n    if (pixels[i] != (MagickPixelPacket *) NULL)\n      pixels[i]=(MagickPixelPacket *) RelinquishMagickMemory(pixels[i]);\n  pixels=(MagickPixelPacket **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}", "target": 0}
{"code": "onigenc_property_list_add_property(UChar* name, const OnigCodePoint* prop,\n     hash_table_type **table, const OnigCodePoint*** plist, int *pnum,\n     int *psize)\n{\n#define PROP_INIT_SIZE     16\n  int r;\n  if (*psize <= *pnum) {\n    int new_size = (*psize == 0 ? PROP_INIT_SIZE : *psize * 2);\n    r = resize_property_list(new_size, plist, psize);\n    if (r != 0) return r;\n  }\n  (*plist)[*pnum] = prop;\n  if (ONIG_IS_NULL(*table)) {\n    *table = onig_st_init_strend_table_with_size(PROP_INIT_SIZE);\n    if (ONIG_IS_NULL(*table)) return ONIGERR_MEMORY;\n  }\n  *pnum = *pnum + 1;\n  onig_st_insert_strend(*table, name, name + strlen((char* )name),\n\t\t\t(hash_data_type )(*pnum + ONIGENC_MAX_STD_CTYPE));\n  return 0;\n}", "target": 0}
{"code": "string DebugString(gtl::ArraySlice<NodeDef> instantiated_func_nodes) {\n  std::vector<const NodeDef*> ptrs;\n  for (const NodeDef& n : instantiated_func_nodes) {\n    ptrs.push_back(&n);\n  }\n  return Print(ptrs);\n}", "target": 0}
{"code": "static RList *symbols(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn res;\n\t}\n\tbool found = false;\n\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\tht_uu_find (hash, sym->paddr, &found);\n\t\tif (found) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\tif (s) {\n\t\t\tr_list_append (res, s);\n\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}", "target": 1}
{"code": "bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t   int protocol, bufferlist& authorizer_data,\n\t\t\t\t   bufferlist& authorizer_reply,\n\t\t\t\t   bool& isvalid, CryptoKey& session_key)\n{\n  dout(10) << \"ms_verify_authorizer \" << con->get_peer_addr()\n\t   << \" \" << ceph_entity_type_name(peer_type)\n\t   << \" protocol \" << protocol << dendl;\n  if (is_shutdown())\n    return false;\n  if (peer_type == CEPH_ENTITY_TYPE_MON &&\n      auth_cluster_required.is_supported_auth(CEPH_AUTH_CEPHX)) {\n    isvalid = false;\n    if (protocol == CEPH_AUTH_CEPHX) {\n      bufferlist::iterator iter = authorizer_data.begin();\n      CephXServiceTicketInfo auth_ticket_info;\n      if (authorizer_data.length()) {\n\tbool ret = cephx_verify_authorizer(g_ceph_context, &keyring, iter,\n\t\t\t\t\t  auth_ticket_info, authorizer_reply);\n\tif (ret) {\n\t  session_key = auth_ticket_info.session_key;\n\t  isvalid = true;\n\t} else {\n\t  dout(0) << \"ms_verify_authorizer bad authorizer from mon \" << con->get_peer_addr() << dendl;\n        }\n      }\n    } else {\n      dout(0) << \"ms_verify_authorizer cephx enabled, but no authorizer (required for mon)\" << dendl;\n    }\n  } else {\n    isvalid = true;\n  }\n  return true;\n}", "target": 1}
{"code": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\tcard->cmdrsp_buf = skb;\n\treturn 0;\n}", "target": 1}
{"code": "static int formatIPTCfromBuffer(Image *ofile, char *s, ssize_t len)\n{\n  char\n    temp[MaxTextExtent];\n  unsigned int\n    foundiptc,\n    tagsfound;\n  unsigned char\n    recnum,\n    dataset;\n  unsigned char\n    *readable,\n    *str;\n  ssize_t\n    tagindx,\n    taglen;\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n  int\n    c;\n  foundiptc = 0; \n  tagsfound = 0; \n  while (len > 0)\n  {\n    c = *s++; len--;\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return -1;\n        else\n          continue;\n      }\n    c = *s++; len--;\n    if (len < 0) return -1;\n    dataset = (unsigned char) c;\n    c = *s++; len--;\n    if (len < 0) return -1;\n    recnum = (unsigned char) c;\n    for (i=0; i< tagcount; i++)\n      if (tags[i].id == (short) recnum)\n        break;\n    if (i < tagcount)\n      readable=(unsigned char *) tags[i].name;\n    else\n      readable=(unsigned char *) \"\";\n    c=(*s++);\n    len--;\n    if (len < 0)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        s--;\n        len++;\n        taglen=readWordFromBuffer(&s, &len);\n      }\n    if (taglen < 0)\n      return(-1);\n    if (taglen > 65535)\n      return(-1);\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MaxTextExtent),\n      sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      return 0;\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c = *s++; len--;\n      if (len < 0)\n        return(-1);\n      str[tagindx]=(unsigned char) c;\n    }\n    str[taglen]=0;\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MaxTextExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset,(unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MaxTextExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n    tagsfound++;\n  }\n  return ((int) tagsfound);\n}", "target": 1}
{"code": "MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "archive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\tzip = (struct zip *)(a->format->data);\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n \t\tinflateEnd(&zip->stream);\n #endif\n#if HAVA_LZMA_H && HAVE_LIBLZMA\n     if (zip->zipx_lzma_valid) {\n \t\tlzma_end(&zip->zipx_lzma_stream);\n \t}\n#endif\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\tfree(zip->uncompressed_buffer);\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}", "target": 1}
{"code": "static void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    end = (start + len) & (target_ulong)(-1);\n    if (start > end) {\n        return;\n    }\n    tb_invalidate_phys_range(uc, start, end);\n}", "target": 1}
{"code": "int irssi_ssl_handshake(GIOChannel *handle)\n{\n\tGIOSSLChannel *chan = (GIOSSLChannel *)handle;\n\tint ret, err;\n\tX509 *cert;\n\tconst char *errstr;\n\tret = SSL_connect(chan->ssl);\n\tif (ret <= 0) {\n\t\terr = SSL_get_error(chan->ssl, ret);\n\t\tswitch (err) {\n\t\t\tcase SSL_ERROR_WANT_READ:\n\t\t\t\treturn 1;\n\t\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\t\treturn 3;\n\t\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", \"server closed connection\");\n\t\t\t\treturn -1;\n\t\t\tcase SSL_ERROR_SYSCALL:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tif (errstr == NULL && ret == -1)\n\t\t\t\t\terrstr = strerror(errno);\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"server closed connection unexpectedly\");\n\t\t\t\treturn -1;\n\t\t\tdefault:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"unknown SSL error\");\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tcert = SSL_get_peer_certificate(chan->ssl);\n\tif (cert == NULL) {\n\t\tg_warning(\"SSL server supplied no certificate\");\n\t\treturn -1;\n\t}\n\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, cert);\n\tX509_free(cert);\n\treturn ret ? 0 : -1;\n}", "target": 1}
{"code": "PHP_FUNCTION(class_parents)\n{\n\tzval *obj;\n\tzend_class_entry *parent_class, *ce;\n\tzend_bool autoload = 1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|b\", &obj, &autoload) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (Z_TYPE_P(obj) != IS_OBJECT && Z_TYPE_P(obj) != IS_STRING) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"object or string expected\");\n\t\tRETURN_FALSE;\n\t}\n\tif (Z_TYPE_P(obj) == IS_STRING) {\n\t\tif (NULL == (ce = spl_find_ce_by_name(Z_STRVAL_P(obj), Z_STRLEN_P(obj), autoload TSRMLS_CC))) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tce = Z_OBJCE_P(obj);\n\t}\n\tarray_init(return_value);\n\tparent_class = ce->parent;\n\twhile (parent_class) {\n\t\tspl_add_class_name(return_value, parent_class, 0, 0 TSRMLS_CC);\n\t\tparent_class = parent_class->parent;\n\t}\n}", "target": 0}
{"code": " int dns_read_name(unsigned char *buffer, unsigned char *bufend,\n                  unsigned char *name, char *destination, int dest_len,\n                 int *offset)\n {\n        int nb_bytes = 0, n = 0;\n        int label_len;\n\tunsigned char *reader = name;\n\tchar *dest = destination;\n\twhile (1) {\n\t\tif ((*reader & 0xc0) == 0xc0) {\n                        if ((buffer + reader[1]) > reader)\n                                goto err;\n                        n = dns_read_name(buffer, bufend, buffer + reader[1],\n                                         dest, dest_len - nb_bytes, offset);\n                        if (n == 0)\n                                goto err;\n\t\t}\n\t\tlabel_len = *reader;\n\t\tif (label_len == 0)\n\t\t\tgoto out;\n\t\tif ((reader + label_len >= bufend) || (nb_bytes + label_len >= dest_len))\n\t\t\tgoto err;\n\t\tlabel_len++;\n\t\tmemcpy(dest, reader, label_len);\n\t\tdest     += label_len;\n\t\tnb_bytes += label_len;\n\t\treader   += label_len;\n\t}\n  out:\n\treader  = name;\n\t*offset = 0;\n\twhile (reader < bufend) {\n\t\tif ((reader[0] & 0xc0) == 0xc0) {\n\t\t\t*offset += 2;\n\t\t\tbreak;\n\t\t}\n\t\telse if (*reader == 0) {\n\t\t\t*offset += 1;\n\t\t\tbreak;\n\t\t}\n\t\t*offset += 1;\n\t\t++reader;\n\t}\n\treturn nb_bytes;\n  err:\n\treturn 0;\n}", "target": 1}
{"code": "  Address pending_message_obj_address() {\n    return reinterpret_cast<Address>(&thread_local_top_.pending_message_obj_);\n  }", "target": 0}
{"code": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n  real_tty_path += 5;\t\t\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n  return result;\n}", "target": 1}
{"code": "static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ahash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}", "target": 1}
{"code": " ip_printroute(netdissect_options *ndo,\n               register const u_char *cp, u_int length)\n {\n\tregister u_int ptr;\n\tregister u_int len;\n \tif (length < 3) {\n \t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\t\treturn;\n \t}\n \tif ((length + 1) & 3)\n \t\tND_PRINT((ndo, \" [bad length %u]\", length));\n \tptr = cp[2] - 1;\n \tif (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)\n \t\tND_PRINT((ndo, \" [bad ptr %u]\", cp[2]));\n \tfor (len = 3; len < length; len += 4) {\n \t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, &cp[len])));\n \t\tif (ptr > len)\n \t\t\tND_PRINT((ndo, \",\"));\n \t}\n }", "target": 1}
{"code": "void Cache::dumpLRULists(bool includeLive) const\n{\n    printf(\"LRU-SP lists in eviction order (Kilobytes decoded, Kilobytes encoded, Access count, Referenced):\\n\");\n    int size = m_allResources.size();\n    for (int i = size - 1; i >= 0; i--) {\n        printf(\"\\n\\nList %d: \", i);\n        CachedResource* current = m_allResources[i].m_tail;\n        while (current) {\n            CachedResource* prev = current->m_prevInAllResourcesList;\n            if (includeLive || !current->referenced())\n                printf(\"(%.1fK, %.1fK, %uA, %dR); \", current->decodedSize() / 1024.0f, current->encodedSize() / 1024.0f, current->accessCount(), current->referenced());\n            current = prev;\n        }\n    }\n}", "target": 0}
{"code": "void PasswordAutofillAgent::PasswordValueGatekeeper::RegisterElement(\n    blink::WebInputElement* element) {\n  if (was_user_gesture_seen_)\n    ShowValue(element);\n  else\n    elements_.push_back(*element);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ExistsFalseSparseIndex) {\n    addIndex(BSON(\"x\" << 1), false, true);\n    runQuery(fromjson(\"{x: {$exists: false}}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n}", "target": 0}
{"code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n    if (hdr->pt != RTCP_PSFB || hdr->count != 3)\n\treturn PJ_ENOTFOUND;\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "static BOOL recurse_check_bit(compiler_common *common, sljit_sw bit_index)\n{\nuint8_t *byte;\nuint8_t mask;\nSLJIT_ASSERT((bit_index & (sizeof(sljit_sw) - 1)) == 0);\nbit_index >>= SLJIT_WORD_SHIFT;\nmask = 1 << (bit_index & 0x7);\nbyte = common->recurse_bitset + (bit_index >> 3);\nif (*byte & mask)\n  return FALSE;\n*byte |= mask;\nreturn TRUE;\n}", "target": 0}
{"code": "void Module::setSource(Module *module) { m_source = module; }", "target": 0}
{"code": "static int nfs4_xdr_dec_rename(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       struct nfs_renameres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_savefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_rename(xdr, &res->old_cinfo, &res->new_cinfo);\nout:\n\treturn status;\n}", "target": 0}
{"code": "int LibRaw::cameraCount()\n{\n  return (sizeof(static_camera_list) / sizeof(static_camera_list[0])) - 1;\n}", "target": 0}
{"code": "void trep_box_del(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}", "target": 0}
{"code": "  void set_external_caught_exception(bool value) {\n    thread_local_top_.external_caught_exception_ = value;\n  }", "target": 0}
{"code": "  base::WeakPtr<Task> GetWeakPtr() { return weak_factory_.GetWeakPtr(); }", "target": 0}
{"code": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}", "target": 1}
{"code": "fill_record_n_invoke_before_triggers(THD *thd, TABLE *table, Field **ptr,\n                                     List<Item> &values, bool ignore_errors,\n                                     enum trg_event_type event)\n{\n  bool result;\n  Table_triggers_list *triggers= table->triggers;\n  result= fill_record(thd, table, ptr, values, ignore_errors, FALSE);\n  if (!result && triggers && *ptr)\n    result= triggers->process_triggers(thd, event, TRG_ACTION_BEFORE, TRUE) ||\n            not_null_fields_have_null_values(table);\n  if (!result && triggers && *ptr)\n  {\n    DBUG_ASSERT(table == (*ptr)->table);\n    if (table->vfield)\n      result= table->update_virtual_fields(table->file, VCOL_UPDATE_FOR_WRITE);\n  }\n  return result;\n}", "target": 0}
{"code": "void IndexedDBDatabase::DeleteIndexAbortOperation(\n    int64_t object_store_id,\n    IndexedDBIndexMetadata index_metadata) {\n  IDB_TRACE(\"IndexedDBDatabase::DeleteIndexAbortOperation\");\n  AddIndex(object_store_id, std::move(index_metadata),\n           IndexedDBIndexMetadata::kInvalidId);\n}", "target": 0}
{"code": "static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tstruct shash_alg *salg = __crypto_shash_alg(alg);\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"shash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = salg->digestsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "vte_sequence_handler_DO (VteTerminal *terminal, GValueArray *params)\n{\n\tvte_sequence_handler_multiple(terminal, params, vte_sequence_handler_do);\n}", "target": 0}
{"code": "void FrameLoader::addData(const char* bytes, int length)\n{\n    ASSERT(m_workingURL.isEmpty());\n    ASSERT(m_frame->document());\n    ASSERT(m_frame->document()->parsing());\n    write(bytes, length);\n}", "target": 0}
{"code": "static gboolean get_name_index(const EnumNames names[], const char *name, uint32_t *index)\n{\n    if (name) {\n        int i;\n        for (i = 0; names[i].name; i++) {\n            if (strcmp(name, names[i].name) == 0) {\n                *index = i;\n                return TRUE;\n            }\n        }\n    }\n    return FALSE;\n}", "target": 0}
{"code": "static void do_client_file_xfer(VirtioPort *vport,\n                                VDAgentMessage *message_header,\n                                uint8_t *data)\n{\n    uint32_t msg_type, id;\n    UdscsConnection *conn;\n    switch (message_header->type) {\n    case VD_AGENT_FILE_XFER_START: {\n        VDAgentFileXferStartMessage *s = (VDAgentFileXferStartMessage *)data;\n        if (!active_session_conn) {\n            send_file_xfer_status(vport,\n               \"Could not find an agent connection belonging to the \"\n               \"active session, cancelling client file-xfer request %u\",\n               s->id, VD_AGENT_FILE_XFER_STATUS_VDAGENT_NOT_CONNECTED, NULL, 0);\n            return;\n        } else if (session_info_session_is_locked(session_info)) {\n            syslog(LOG_DEBUG, \"Session is locked, skipping file-xfer-start\");\n            send_file_xfer_status(vport,\n               \"User's session is locked and cannot start file transfer. \"\n               \"Cancelling client file-xfer request %u\",\n               s->id, VD_AGENT_FILE_XFER_STATUS_SESSION_LOCKED, NULL, 0);\n            return;\n        }\n        msg_type = VDAGENTD_FILE_XFER_START;\n        id = s->id;\n        g_hash_table_insert(active_xfers, GUINT_TO_POINTER(id), active_session_conn);\n        break;\n    }\n    case VD_AGENT_FILE_XFER_STATUS: {\n        VDAgentFileXferStatusMessage *s = (VDAgentFileXferStatusMessage *)data;\n        msg_type = VDAGENTD_FILE_XFER_STATUS;\n        id = s->id;\n        break;\n    }\n    case VD_AGENT_FILE_XFER_DATA: {\n        VDAgentFileXferDataMessage *d = (VDAgentFileXferDataMessage *)data;\n        msg_type = VDAGENTD_FILE_XFER_DATA;\n        id = d->id;\n        break;\n    }\n    default:\n        g_return_if_reached(); \n    }\n    conn = g_hash_table_lookup(active_xfers, GUINT_TO_POINTER(id));\n    if (!conn) {\n        if (debug)\n            syslog(LOG_DEBUG, \"Could not find file-xfer %u (cancelled?)\", id);\n        return;\n    }\n    udscs_write(conn, msg_type, 0, 0, data, message_header->size);\n    if (message_header->type == VD_AGENT_FILE_XFER_STATUS) {\n        g_hash_table_remove(active_xfers, GUINT_TO_POINTER(id));\n    }\n}", "target": 1}
{"code": "SWFShape_getScaledPenX(SWFShape shape)\n{\n\treturn shape->xpos;\n}", "target": 0}
{"code": "parse_emph1(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\t\tif (i >= size) return 0;\n\t\tif (data[i] == c && !_isspace(data[i - 1])) {\n\t\t\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n\t\t\t\tif (i + i < size && _isalnum(data[i + 1]))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tif (rndr->ext_flags & MKDEXT_UNDERLINE && c == '_')\n\t\t\t\tr = rndr->cb.underline(ob, work, rndr->opaque);\n\t\t\telse\n\t\t\t\tr = rndr->cb.emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 1 : 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static MSUSB_PIPE_DESCRIPTOR** msusb_mspipes_read(wStream* s, UINT32 NumberOfPipes)\n{\n\tUINT32 pnum;\n\tMSUSB_PIPE_DESCRIPTOR** MsPipes;\n\tif (Stream_GetRemainingCapacity(s) < 12 * NumberOfPipes)\n\t\treturn NULL;\n\tMsPipes = (MSUSB_PIPE_DESCRIPTOR**)calloc(NumberOfPipes, sizeof(MSUSB_PIPE_DESCRIPTOR*));\n\tif (!MsPipes)\n\t\treturn NULL;\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t{\n\t\tMSUSB_PIPE_DESCRIPTOR* MsPipe = msusb_mspipe_new();\n\t\tif (!MsPipe)\n\t\t\tgoto out_error;\n\t\tStream_Read_UINT16(s, MsPipe->MaximumPacketSize);\n\t\tStream_Seek(s, 2);\n\t\tStream_Read_UINT32(s, MsPipe->MaximumTransferSize);\n\t\tStream_Read_UINT32(s, MsPipe->PipeFlags);\n\t\tMsPipes[pnum] = MsPipe;\n\t}\n\treturn MsPipes;\nout_error:\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t\tfree(MsPipes[pnum]);\n\tfree(MsPipes);\n\treturn NULL;\n}", "target": 1}
{"code": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static int fill_autodev(const struct lxc_rootfs *rootfs)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tint i;\n\tmode_t cmask;\n\tINFO(\"Creating initial consoles under container /dev\");\n\tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error calculating container /dev location\");\n\t\treturn -1;\n\t}\n\tif (!dir_exists(path))  \n\t\treturn 0;\n\tINFO(\"Populating container /dev\");\n\tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);\n\tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {\n\t\tconst struct lxc_devs *d = &lxc_devs[i];\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tret = mknod(path, d->mode, makedev(d->maj, d->min));\n\t\tif (ret && errno != EEXIST) {\n\t\t\tchar hostpath[MAXPATHLEN];\n\t\t\tFILE *pathfile;\n\t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tpathfile = fopen(path, \"wb\");\n\t\t\tif (!pathfile) {\n\t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(pathfile);\n\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n\t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n\t\t\t\t\td->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tumask(cmask);\n\tINFO(\"Populated container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": " void PrintWebViewHelper::OnPrintingDone(bool success) {\n  CHECK_LE(ipc_nesting_level_, 1);\n   notify_browser_of_print_failure_ = false;\n   if (!success)\n     LOG(ERROR) << \"Failure in OnPrintingDone\";\n  DidFinishPrinting(success ? OK : FAIL_PRINT);\n}", "target": 0}
{"code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\treturn 0;\n}", "target": 1}
{"code": "Item_func_null_predicate::add_key_fields(JOIN *join, KEY_FIELD **key_fields,\n                                         uint *and_level,\n                                         table_map usable_tables,\n                                         SARGABLE_PARAM **sargables)\n{\n  if (is_local_field(args[0]) && !(used_tables() & OUTER_REF_TABLE_BIT))\n  {\n    Item *tmp= new (join->thd->mem_root) Item_null(join->thd);\n    if (unlikely(!tmp))                       \n      return;\n    add_key_equal_fields(join, key_fields, *and_level, this,\n                         (Item_field*) args[0]->real_item(),\n                         functype() == Item_func::ISNULL_FUNC,\n                         &tmp, 1, usable_tables, sargables);\n  }\n}", "target": 0}
{"code": "int CF_LoadEncodedChunk(const CuckooFilter *cf, long long pos, const char *data, size_t datalen) {\n    if (datalen == 0) {\n        return REDISMODULE_ERR;\n    }\n    long long offset = pos - datalen - 1;\n    long long currentSize;\n    int filterIx = 0;\n    SubCF *filter = NULL;\n    for (; filterIx < cf->numFilters; ++filterIx) {\n        filter = cf->filters + filterIx;\n        currentSize = filter->bucketSize * filter->numBuckets;\n        if (offset < currentSize) {\n            break;\n        }\n        offset -= currentSize;\n    }\n    memcpy(filter->data + offset, data, datalen);\n    return REDISMODULE_OK;\n}", "target": 1}
{"code": "void WebGraphicsContext3DDefaultImpl::activeTexture(unsigned long texture)\n{\n    if (texture < GL_TEXTURE0 || texture > GL_TEXTURE0+32)\n        return;\n    makeContextCurrent();\n    glActiveTexture(texture);\n}", "target": 0}
{"code": "void LibRaw::getOlympus_CameraType2()\n{\n  if (OlyID != 0x0ULL)\n    return;\n  int i = 0;\n  fread(imOly.CameraType2, 6, 1, ifp);\n  imOly.CameraType2[5] = 0;\n  while ((i < 6) && imOly.CameraType2[i])\n  {\n    OlyID = OlyID << 8 | imOly.CameraType2[i];\n    if (i < 5 && isspace(imOly.CameraType2[i + 1]))\n      imOly.CameraType2[i + 1] = '\\0';\n    i++;\n  }\n  unique_id = OlyID;\n  setOlympusBodyFeatures(OlyID);\n  return;\n}", "target": 0}
{"code": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit;\n\t}\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\tskey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\tif (unlikely(size != tipc_aead_key_size(skey))) {\n\t\tkfree(skey);\n\t\tskey = NULL;\n\t\tgoto exit;\n\t}\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); \nexit:\n\tspin_unlock(&rx->lock);\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": " */\nstatic inline zval *add_next_index_object(zval *arg, zval *tmp)\n{\n\tHashTable *symtable;\n\tif (Z_TYPE_P(arg) == IS_OBJECT) {\n\t\tsymtable = Z_OBJPROP_P(arg);\n\t} else {\n\t\tsymtable = Z_ARRVAL_P(arg);\n\t}\n\treturn zend_hash_next_index_insert(symtable, tmp);", "target": 0}
{"code": "static void sctp_control_set_owner_w(struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sk_buff *skb = chunk->skb;\n\tskb->sk = asoc ? asoc->base.sk : NULL;\n\tskb->destructor = sctp_control_release_owner;\n}", "target": 0}
{"code": "static void _ewk_view_smart_changed(Ewk_View_Smart_Data* smartData)\n{\n    if (smartData->changed.any)\n        return;\n    smartData->changed.any = true;\n    evas_object_smart_changed(smartData->self);\n}", "target": 0}
{"code": "static void unmask_payload(handler_ctx *hctx) {\n    buffer * const b = hctx->frame.payload;\n    for (size_t i = 0, used = buffer_clen(b); i < used; ++i) {\n        b->ptr[i] ^= hctx->frame.ctl.mask[hctx->frame.ctl.mask_cnt];\n        hctx->frame.ctl.mask_cnt = (hctx->frame.ctl.mask_cnt + 1) % 4;\n    }\n}", "target": 0}
{"code": "setv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setv4key_principal((void *)handle, arg->princ,\n                                            arg->keyblock);\n    } else {\n        log_unauth(\"kadm5_setv4key_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setv4key_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "JankTimeBomb::JankTimeBomb(base::TimeDelta duration)\n    : weak_ptr_factory_(this) {\n  if (IsEnabled()) {\n    WatchDogThread::PostDelayedTask(\n        FROM_HERE,\n        base::Bind(&JankTimeBomb::Alarm,\n                   weak_ptr_factory_.GetWeakPtr(),\n                   base::PlatformThread::CurrentId()),\n        duration);\n  }\n}", "target": 0}
{"code": " struct task_struct * __cpuinit fork_idle(int cpu)\n {\n \tstruct task_struct *task;\n \tstruct pt_regs regs;\n \ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n \t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n \t\tinit_idle(task, cpu);\n \treturn task;\n }", "target": 1}
{"code": " static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,\n                               int nb_sectors)\n {\n     return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,\n                                    nb_sectors * BDRV_SECTOR_SIZE);\n }", "target": 1}
{"code": "WebMediaPlayer::CorsMode HTMLMediaElement::CorsMode() const {\n  const AtomicString& cross_origin_mode = FastGetAttribute(kCrossoriginAttr);\n  if (cross_origin_mode.IsNull())\n    return WebMediaPlayer::kCorsModeUnspecified;\n  if (DeprecatedEqualIgnoringCase(cross_origin_mode, \"use-credentials\"))\n    return WebMediaPlayer::kCorsModeUseCredentials;\n  return WebMediaPlayer::kCorsModeAnonymous;\n}", "target": 0}
{"code": "bool AccessibilityUIElement::isAttributeSupported(JSStringRef attribute)\n{\n    return false;\n}", "target": 0}
{"code": "static int test_x509_time(int idx)\n{\n    ASN1_TIME *t = NULL;\n    int result, rv = 0;\n    if (x509_format_tests[idx].set_string) {\n        t = ASN1_TIME_new();\n        if (t == NULL) {\n            TEST_info(\"test_x509_time(%d) failed: internal error\\n\", idx);\n            return 0;\n        }\n    }\n    result = ASN1_TIME_set_string_X509(t, x509_format_tests[idx].data);\n    if (!TEST_int_eq(result, x509_format_tests[idx].expected)) {\n        TEST_info(\"test_x509_time(%d) failed: expected %d, got %d\\n\",\n                idx, x509_format_tests[idx].expected, result);\n        goto out;\n    }\n    if (t != NULL && x509_format_tests[idx].expected_type != -1) {\n        if (!TEST_int_eq(t->type, x509_format_tests[idx].expected_type)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_type %d, got %d\\n\",\n                    idx, x509_format_tests[idx].expected_type, t->type);\n            goto out;\n        }\n    }\n    if (t != NULL && x509_format_tests[idx].expected_string) {\n        if (!TEST_str_eq((const char *)t->data,\n                    x509_format_tests[idx].expected_string)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_string %s, got %s\\n\",\n                    idx, x509_format_tests[idx].expected_string, t->data);\n            goto out;\n        }\n    }\n    rv = 1;\nout:\n    if (t != NULL)\n        ASN1_TIME_free(t);\n    return rv;\n}", "target": 1}
{"code": "int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n    return 0;\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n    return -1;\n}", "target": 1}
{"code": "static void sr_write_reg_async(struct usbnet *dev, u8 reg, u8 value)\n{\n\tusbnet_write_cmd_async(dev, SR_WR_REGS, SR_REQ_WR_REG,\n\t\t\t       value, reg, NULL, 0);\n}", "target": 0}
{"code": "static bool reds_send_link_error(RedLinkInfo *link, uint32_t error)\n{\n    struct {\n        SpiceLinkHeader header;\n        SpiceLinkReply reply;\n    } msg;\n    SPICE_VERIFY(sizeof(msg) == sizeof(SpiceLinkHeader) + sizeof(SpiceLinkReply));\n    msg.header.magic = SPICE_MAGIC;\n    msg.header.size = GUINT32_TO_LE(sizeof(msg.reply));\n    msg.header.major_version = GUINT32_TO_LE(SPICE_VERSION_MAJOR);\n    msg.header.minor_version = GUINT32_TO_LE(SPICE_VERSION_MINOR);\n    memset(&msg.reply, 0, sizeof(msg.reply));\n    msg.reply.error = GUINT32_TO_LE(error);\n    return red_stream_write_all(link->stream, &msg, sizeof(msg));\n}", "target": 0}
{"code": "free_indexed(fz_context *ctx, fz_colorspace *cs)\n{\n\tstruct indexed *idx = cs->data;\n\tfz_drop_colorspace(ctx, idx->base);\n\tfz_free(ctx, idx->lookup);\n\tfz_free(ctx, idx);\n}", "target": 0}
{"code": "static void spl_filesystem_dir_it_dtor(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tif (iterator->intern.data) {\n\t\tzval *object =  iterator->intern.data;\n\t\tzval_ptr_dtor(&object);\n\t}\n}", "target": 0}
{"code": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || \n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n\tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n\t    name, string_from_portable(pflags), mode);\n\tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n\t\tverbose(\"Refusing open request in read-only mode\");\n\t\tstatus = SSH2_FX_PERMISSION_DENIED;\n\t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, CacheDataFromTaggedTreeFailsOnBadInput) {\n    std::vector<IndexEntry> relevantIndices;\n    auto swIndexTree = QueryPlanner::cacheDataFromTaggedTree(NULL, relevantIndices);\n    ASSERT_NOT_OK(swIndexTree.getStatus());\n    relevantIndices.push_back(IndexEntry(BSON(\"a\" << 1)));\n    auto qr = stdx::make_unique<QueryRequest>(NamespaceString(\"test.collection\"));\n    qr->setFilter(BSON(\"a\" << 3));\n    auto statusWithCQ = CanonicalQuery::canonicalize(opCtx.get(), std::move(qr));\n    ASSERT_OK(statusWithCQ.getStatus());\n    std::unique_ptr<CanonicalQuery> scopedCq = std::move(statusWithCQ.getValue());\n    scopedCq->root()->setTag(new IndexTag(1));\n    swIndexTree = QueryPlanner::cacheDataFromTaggedTree(scopedCq->root(), relevantIndices);\n    ASSERT_NOT_OK(swIndexTree.getStatus());\n}", "target": 0}
{"code": "static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\tut64 offset = va2pa (hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\tut64 size = sizeof (cache_accel_t);\n\tcache_accel_t *accel = R_NEW0 (cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) accel, \"16il\", 1) != size) {\n\t\tR_FREE (accel);\n\t\treturn NULL;\n\t}\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\treturn accel;\n}", "target": 1}
{"code": "static void bundle_add_conn(struct connectbundle *bundle,\n                            struct connectdata *conn)\n{\n  Curl_llist_insert_next(&bundle->conn_list, bundle->conn_list.tail, conn,\n                         &conn->bundle_node);\n  conn->bundle = bundle;\n  bundle->num_connections++;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, EquivalentAndsOne) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    runQuery(fromjson(\"{$and: [{a: 1}, {b: {$all: [10, 20]}}]}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\"{cscan: {dir: 1, filter: {$and:[{a:1},{b:10},{b:20}]}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: \"\n        \"{filter: null, pattern: {a: 1, b: 1}}}}}\");\n}", "target": 0}
{"code": "    SigmaMnHeader::~SigmaMnHeader()\n    {\n    }", "target": 0}
{"code": "mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n \t\t\t\t\t    params->beacon.tail_len);\n \tif (vendor_ie) {\n \t\twmm_ie = vendor_ie;\n \t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n \t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n \t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}", "target": 1}
{"code": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  \n\tURI_CHAR * write = dest;\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\t\tqueryList = queryList->next;\n\t}\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; \n\t\t}\n\t}\n\treturn URI_SUCCESS;\n}", "target": 1}
{"code": "void snd_msndmidi_input_read(void *mpuv)\n{\n \tunsigned long flags;\n \tstruct snd_msndmidi *mpu = mpuv;\n \tvoid *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF;\n \tspin_lock_irqsave(&mpu->input_lock, flags);\n\twhile (readw(mpu->dev->MIDQ + JQS_wTail) !=\n\t       readw(mpu->dev->MIDQ + JQS_wHead)) {\n\t\tu16 wTmp, val;\n\t\tval = readw(pwMIDQData + 2 * readw(mpu->dev->MIDQ + JQS_wHead));\n\t\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER,\n\t\t\t\t     &mpu->mode))\n\t\t\t\tsnd_rawmidi_receive(mpu->substream_input,\n\t\t\t\t\t\t    (unsigned char *)&val, 1);\n\t\twTmp = readw(mpu->dev->MIDQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(mpu->dev->MIDQ + JQS_wSize))\n\t\t\twritew(0,  mpu->dev->MIDQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp,  mpu->dev->MIDQ + JQS_wHead);\n \t}\n \tspin_unlock_irqrestore(&mpu->input_lock, flags);\n }", "target": 1}
{"code": "int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n{\n\tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n\tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n\t\t\t\t\t hashbin_lock_depth++);\n\t}\n\tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\t\twhile (queue ) {\n\t\t\tif (free_func)\n\t\t\t\t(*free_func)(queue);\n\t\t\tqueue = dequeue_first(\n\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n\t\t}\n\t}\n\thashbin->hb_current = NULL;\n\thashbin->magic = ~HB_MAGIC;\n\tif ( hashbin->hb_type & HB_LOCK) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n#ifdef CONFIG_LOCKDEP\n\t\thashbin_lock_depth--;\n#endif\n\t}\n\tkfree(hashbin);\n\treturn 0;\n}", "target": 1}
{"code": "int js_isstring(js_State *J, int idx) { enum js_Type t = stackidx(J, idx)->type; return t == JS_TSHRSTR || t == JS_TLITSTR || t == JS_TMEMSTR; }", "target": 0}
{"code": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\tif (error)\n\t\treturn error;\n\tspin_lock_bh(&socket_client->lock);\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n \tspin_unlock_bh(&socket_client->lock);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\tpacket_len = socket_packet->icmp_len;\n \tkfree(socket_packet);\n \tif (error)\n\t\treturn -EFAULT;\n\treturn packet_len;\n}", "target": 1}
{"code": "flatpak_run_extend_ld_path (FlatpakBwrap *bwrap,\n                            const char *prepend,\n                            const char *append)\n{\n  g_autoptr(GString) ld_library_path = g_string_new (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"));\n  if (prepend != NULL && *prepend != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_prepend (ld_library_path, \":\");\n      g_string_prepend (ld_library_path, prepend);\n    }\n  if (append != NULL && *append != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_append (ld_library_path, \":\");\n      g_string_append (ld_library_path, append);\n    }\n  flatpak_bwrap_set_env (bwrap, \"LD_LIBRARY_PATH\", ld_library_path->str, TRUE);\n}", "target": 0}
{"code": "xfs_bmap_add_free(\n\tstruct xfs_mount\t\t*mp,\n\tstruct xfs_defer_ops\t\t*dfops,\n\txfs_fsblock_t\t\t\tbno,\n\txfs_filblks_t\t\t\tlen,\n\tstruct xfs_owner_info\t\t*oinfo)\n{\n\tstruct xfs_extent_free_item\t*new;\t\t\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xefi_startblock = bno;\n\tnew->xefi_blockcount = (xfs_extlen_t)len;\n\tif (oinfo)\n\t\tnew->xefi_oinfo = *oinfo;\n\telse\n\t\txfs_rmap_skip_owner_update(&new->xefi_oinfo);\n\ttrace_xfs_bmap_free_defer(mp, XFS_FSB_TO_AGNO(mp, bno), 0,\n\t\t\tXFS_FSB_TO_AGBNO(mp, bno), len);\n\txfs_defer_add(dfops, XFS_DEFER_OPS_TYPE_FREE, &new->xefi_list);\n}", "target": 0}
{"code": "int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;\n\t\t}\n\t\tif (dev->ops->check_presence)\n\t\t\tdel_timer_sync(&dev->check_pres_timer);\n\t\trc = dev->ops->im_transceive(dev, dev->active_target, skb, cb,\n\t\t\t\t\t     cb_context);\n\t\tif (!rc && dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t} else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) {\n\t\trc = dev->ops->tm_send(dev, skb);\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int proc_pid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer,\n#ifdef CONFIG_TASK_XACCT\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n#endif\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n#ifdef CONFIG_TASK_XACCT\n\t\t\t(unsigned long long)task->rchar,\n\t\t\t(unsigned long long)task->wchar,\n\t\t\t(unsigned long long)task->syscr,\n\t\t\t(unsigned long long)task->syscw,\n#endif\n\t\t\t(unsigned long long)task->ioac.read_bytes,\n\t\t\t(unsigned long long)task->ioac.write_bytes,\n\t\t\t(unsigned long long)task->ioac.cancelled_write_bytes);\n}", "target": 0}
{"code": "Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* g,\n                                                    ControlFlowInfo* cf_info) {\n  const int num_nodes = g->num_node_ids();\n  cf_info->frame_names.resize(num_nodes);\n  std::vector<Node*> parent_nodes;\n  parent_nodes.resize(num_nodes);\n  std::vector<bool> visited;\n  visited.resize(num_nodes);\n  string frame_name;\n  std::deque<Node*> ready;\n  for (Node* n : g->nodes()) {\n    if (n->in_edges().empty()) {\n      visited[n->id()] = true;\n      cf_info->unique_frame_names.insert(frame_name);\n      ready.push_back(n);\n    }\n  }\n  while (!ready.empty()) {\n    Node* curr_node = ready.front();\n    int curr_id = curr_node->id();\n    ready.pop_front();\n    Node* parent = nullptr;\n    if (IsEnter(curr_node)) {\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(curr_node->attrs(), \"frame_name\", &frame_name));\n      parent = curr_node;\n    } else if (IsExit(curr_node)) {\n      parent = parent_nodes[curr_id];\n      frame_name = cf_info->frame_names[parent->id()];\n      parent = parent_nodes[parent->id()];\n    } else {\n      parent = parent_nodes[curr_id];\n      frame_name = cf_info->frame_names[curr_id];\n    }\n    for (const Edge* out_edge : curr_node->out_edges()) {\n      Node* out = out_edge->dst();\n      if (IsSink(out)) continue;\n      const int out_id = out->id();\n      bool is_visited = visited[out_id];\n      if (!is_visited) {\n        ready.push_back(out);\n        visited[out_id] = true;\n        cf_info->frame_names[out_id] = frame_name;\n        parent_nodes[out_id] = parent;\n        cf_info->unique_frame_names.insert(frame_name);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "void EditorClientBlackBerry::textWillBeDeletedInTextField(Element*)\n{\n    notImplemented();\n}", "target": 0}
{"code": "static void vc_uniscr_putc(struct vc_data *vc, char32_t uc)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tif (uniscr)\n\t\tuniscr->lines[vc->vc_y][vc->vc_x] = uc;\n}", "target": 0}
{"code": "dump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[21];\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\tif (!level)\n\t\tfclose(fp);\n}", "target": 1}
{"code": "static int compareNumbersForQSort(const void* a, const void* b)\n{\n    double da = static_cast<const JSValue*>(a)->uncheckedGetNumber();\n    double db = static_cast<const JSValue*>(b)->uncheckedGetNumber();\n    return (da > db) - (da < db);\n}", "target": 0}
{"code": "int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n{\n\tCNetChunk Packet;\n\tif(!pMsg)\n\t\treturn -1;\n\tif(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))\n\t\treturn 0;\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\tPacket.m_ClientID = ClientID;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\tif(!(Flags&MSGFLAG_NORECORD))\n\t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t{\n\t\tif(ClientID == -1)\n\t\t{\n\t\t\tint i;\n\t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n\t\t\t\t{\n\t\t\t\t\tPacket.m_ClientID = i;\n\t\t\t\t\tm_NetServer.Send(&Packet);\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tm_NetServer.Send(&Packet);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   \n    size_t dsize;                  \n    unsigned char *buf = 0;\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}", "target": 1}
{"code": "static int oidc_cache_crypto_encrypt_impl(request_rec *r,\n\t\tunsigned char *plaintext, int plaintext_len, const unsigned char *aad,\n\t\tint aad_len, unsigned char *key, const unsigned char *iv, int iv_len,\n\t\tunsigned char *ciphertext, const unsigned char *tag, int tag_len) {\n\tEVP_CIPHER_CTX *ctx;\n\tint len;\n\tint ciphertext_len;\n\tif (!(ctx = EVP_CIPHER_CTX_new())) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_new\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptInit_ex(ctx, OIDC_CACHE_CIPHER, NULL, NULL, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_IVLEN, iv_len, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptInit_ex(ctx, NULL, NULL, key, iv)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptUpdate(ctx, NULL, &len, aad, aad_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate aad: aad_len=%d\",\n\t\t\t\taad_len);\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptUpdate ciphertext\");\n\t\treturn -1;\n\t}\n\tciphertext_len = len;\n\tif (!EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptFinal_ex\");\n\t\treturn -1;\n\t}\n\tciphertext_len += len;\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_GET_TAG, tag_len,\n\t\t\t(void *) tag)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tEVP_CIPHER_CTX_free(ctx);\n\treturn ciphertext_len;\n}", "target": 1}
{"code": "static void wdm_in_callback(struct urb *urb)\n {\n \tstruct wdm_device *desc = urb->context;\n \tint status = urb->status;\n \tspin_lock(&desc->iuspin);\n \tclear_bit(WDM_RESPONDING, &desc->flags);\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n \t}\n \tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\n skip_error:\n \twake_up(&desc->wait);\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}", "target": 1}
{"code": "char *BN_bn2dec(const BIGNUM *a)\n{\n    int i = 0, num, ok = 0;\n    char *buf = NULL;\n    char *p;\n    BIGNUM *t = NULL;\n    BN_ULONG *bn_data = NULL, *lp;\n    int bn_data_num;\n    i = BN_num_bits(a) * 3;\n    num = (i / 10 + i / 1000 + 1) + 1;\n    bn_data_num = num / BN_DEC_NUM + 1;\n    bn_data = OPENSSL_malloc(bn_data_num * sizeof(BN_ULONG));\n    buf = OPENSSL_malloc(num + 3);\n    if ((buf == NULL) || (bn_data == NULL)) {\n        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((t = BN_dup(a)) == NULL)\n        goto err;\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\n    p = buf;\n    lp = bn_data;\n    if (BN_is_zero(t)) {\n        *(p++) = '0';\n        *(p++) = '\\0';\n    } else {\n        if (BN_is_negative(t))\n            *p++ = '-';\n        i = 0;\n        while (!BN_is_zero(t)) {\n            *lp = BN_div_word(t, BN_DEC_CONV);\n            if (*lp == (BN_ULONG)-1)\n                goto err;\n            lp++;\n            if (lp - bn_data >= bn_data_num)\n                goto err;\n        }\n        lp--;\n        BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT1, *lp);\n        while (*p)\n            p++;\n        while (lp != bn_data) {\n            lp--;\n            BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT2, *lp);\n            while (*p)\n                p++;\n        }\n    }\n    ok = 1;\n err:\n    if (bn_data != NULL)\n        OPENSSL_free(bn_data);\n    if (t != NULL)\n        BN_free(t);\n    if (!ok && buf) {\n        OPENSSL_free(buf);\n        buf = NULL;\n    }\n    return (buf);\n}", "target": 1}
{"code": "void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct scm_timestamping tss;\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\tif (need_software_tstamp && skb->tstamp == 0)\n\t\t__net_timestamp(skb);\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts), &ts);\n\t\t}\n\t}\n\tmemset(&tss, 0, sizeof(tss));\n\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))\n\t\tempty = 0;\n\tif (!empty) {\n\t\tput_cmsg(msg, SOL_SOCKET,\n \t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n \t\tif (skb_is_err_queue(skb) && skb->len &&\n\t\t    (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS))\n \t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n \t\t\t\t skb->len, skb->data);\n \t}\n}", "target": 1}
{"code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0)\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}", "target": 0}
{"code": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n \t\t\tstruct vhost_scsi_tport, tport_wwn);\n \tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n \tint ret;\n \tif (strstr(name, \"tpgt_\") != name)\n \t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n \t\treturn ERR_PTR(-EINVAL);\n \ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\treturn &tpg->se_tpg;\n}", "target": 1}
{"code": "static void avrcp_handle_media_player_list_num_items(struct avrcp *session,\n\t\t\t\tstruct avrcp_browsing_header *pdu)\n{\n\tstruct avrcp_player *player = target_get_player(session);\n\tstruct get_total_number_of_items_rsp *rsp;\n\trsp = (void *)pdu->params;\n\trsp->status = AVRCP_STATUS_SUCCESS;\n\trsp->uid_counter = htons(player_get_uid_counter(player));\n\trsp->num_items = htonl(g_slist_length(session->server->players));\n\tpdu->param_len = htons(sizeof(*rsp));\n}", "target": 0}
{"code": "Adaptation::Ecap::FirstLineRep::protocol() const\n{\n    switch (theMessage.http_ver.protocol) {\n    case AnyP::PROTO_HTTP:\n        return libecap::protocolHttp;\n    case AnyP::PROTO_HTTPS:\n        return libecap::protocolHttps;\n    case AnyP::PROTO_FTP:\n        return libecap::protocolFtp;\n    case AnyP::PROTO_GOPHER:\n        return libecap::protocolGopher;\n    case AnyP::PROTO_WAIS:\n        return libecap::protocolWais;\n    case AnyP::PROTO_WHOIS:\n        return libecap::protocolWhois;\n    case AnyP::PROTO_URN:\n        return libecap::protocolUrn;\n    case AnyP::PROTO_ICP:\n        return protocolIcp;\n#if USE_HTCP\n    case AnyP::PROTO_HTCP:\n        return protocolHtcp;\n#endif\n    case AnyP::PROTO_CACHE_OBJECT:\n        return protocolCacheObj;\n    case AnyP::PROTO_ICY:\n        return protocolIcy;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS: \n    case AnyP::PROTO_AUTHORITY_FORM:\n    case AnyP::PROTO_SSL:\n    case AnyP::PROTO_TLS:\n    case AnyP::PROTO_UNKNOWN:\n        return protocolUnknown; \n    case AnyP::PROTO_NONE:\n        return Name();\n    case AnyP::PROTO_MAX:\n        break; \n    }\n    Must(false); \n    return Name();\n}", "target": 1}
{"code": "parse_SET_QUEUE(char *arg, const struct ofpact_parse_params *pp)\n{\n    return str_to_u32(arg, &ofpact_put_SET_QUEUE(pp->ofpacts)->queue_id);\n}", "target": 0}
{"code": "  void libraw_free_image(libraw_data_t *lr)\n  {\n    if (!lr)\n      return;\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    ip->free_image();\n  }", "target": 0}
{"code": "NativeModule::NativeModule(const std::string& filename) : init(nullptr) {\n\tif (uv_dlopen(filename.c_str(), &lib) != 0) {\n\t\tthrow RuntimeGenericError(\"Failed to load module\");\n\t}\n\tif (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) {\n\t\tuv_dlclose(&lib);\n\t\tthrow RuntimeGenericError(\"Module is not isolated-vm compatible\");\n\t}\n}", "target": 1}
{"code": "static Jsi_RC NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[500];\n    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK\n        || radix<2))\n        return JSI_ERROR;\n    if (argc==skip)\n        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    switch (radix) {\n        case 16: snprintf(buf, sizeof(buf), \"%\" PRIx64, (Jsi_Wide)num); break;\n        case 8: snprintf(buf, sizeof(buf), \"%\" PRIo64, (Jsi_Wide)num); break;\n        case 10: snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num); break;\n        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "static void date_period_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tdate_period_it   *iterator = (date_period_it *)iter;\n\titerator->current_index = 0;\n\tif (iterator->object->current) {\n\t\ttimelib_time_dtor(iterator->object->current);\n\t}\n\titerator->object->current = timelib_time_clone(iterator->object->start);\n\tdate_period_it_invalidate_current(iter TSRMLS_CC);", "target": 0}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "bool ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return false;\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return false;\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return false;\n  }\n  CHECK_EQ(1, outputs.size());\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return false;\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return false;\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return false;\n  }\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n  return shape.IsCompatibleWith(new_dims);\n}", "target": 1}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n \tstruct posix_acl_entry *acl_e;\n \tstruct posix_acl *acl;\n \tstruct xfs_acl_entry *ace;\n\tint count, i;\n \tcount = be32_to_cpu(aclp->acl_cnt);\n \tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "static int getnum (lua_State *L, const char **fmt, int df) {\n   if (!isdigit(**fmt))  \n     return df;  \n   else {\n     int a = 0;\n     do {\n      if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))\n        luaL_error(L, \"integral size overflow\");\n       a = a*10 + *((*fmt)++) - '0';\n     } while (isdigit(**fmt));\n     return a;\n  }\n}", "target": 1}
{"code": "static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n\tnla = nla_find((struct nlattr *) &skb->data[A], skb->len - A, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\treturn 0;\n}", "target": 1}
{"code": "static void exif_process_TIFF_in_JPEG(image_info_type *ImageInfo, char *CharBuf, size_t length, size_t displacement)\n{\n\tunsigned exif_value_2a, offset_of_ifd;\n\tif (memcmp(CharBuf, \"II\", 2) == 0) {\n\t\tImageInfo->motorola_intel = 0;\n\t} else if (memcmp(CharBuf, \"MM\", 2) == 0) {\n\t\tImageInfo->motorola_intel = 1;\n\t} else {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF alignment marker\");\n\t\treturn;\n\t}\n\tif (length < 8) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF start (1)\");\n\t\treturn;\n\t}\n\texif_value_2a = php_ifd_get16u(CharBuf+2, ImageInfo->motorola_intel);\n\toffset_of_ifd = php_ifd_get32u(CharBuf+4, ImageInfo->motorola_intel);\n\tif (exif_value_2a != 0x2a || offset_of_ifd < 0x08) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF start (1)\");\n\t\treturn;\n\t}\n\tif (offset_of_ifd > length) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid IFD start\");\n\t\treturn;\n\t}\n\tImageInfo->sections_found |= FOUND_IFD0;\n\texif_process_IFD_in_JPEG(ImageInfo, CharBuf+offset_of_ifd, CharBuf, length, displacement, SECTION_IFD0, 0);\n#ifdef EXIF_DEBUG\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process TIFF in JPEG done\");\n#endif\n\tif (ImageInfo->FocalplaneXRes != 0) {\n\t\tImageInfo->CCDWidth = (float)(ImageInfo->ExifImageWidth * ImageInfo->FocalplaneUnits / ImageInfo->FocalplaneXRes);\n\t}\n}", "target": 0}
{"code": "static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n\t\t\t\t\tstruct vsock_sock *vsk,\n\t\t\t\t\tstruct msghdr *msg, size_t len,\n\t\t\t\t\tint flags)\n{\n\tint err;\n\tint noblock;\n\tstruct vmci_datagram *dg;\n\tsize_t payload_len;\n\tstruct sk_buff *skb;\n\tnoblock = flags & MSG_DONTWAIT;\n \tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n \t\treturn -EOPNOTSUPP;\n \terr = 0;\n \tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\n\tif (err)\n\t\treturn err;\n\tif (!skb)\n\t\treturn -EAGAIN;\n\tdg = (struct vmci_datagram *)skb->data;\n\tif (!dg)\n\t\tgoto out;\n\tpayload_len = dg->payload_size;\n\tif (payload_len != skb->len - sizeof(*dg)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (payload_len > len) {\n\t\tpayload_len = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\n\t\tpayload_len);\n \tif (err)\n \t\tgoto out;\n\tmsg->msg_namelen = 0;\n \tif (msg->msg_name) {\n \t\tstruct sockaddr_vm *vm_addr;\n\t\tvm_addr = (struct sockaddr_vm *)msg->msg_name;\n\t\tvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\n\t\tmsg->msg_namelen = sizeof(*vm_addr);\n\t}\n\terr = payload_len;\nout:\n\tskb_free_datagram(&vsk->sk, skb);\n\treturn err;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList params_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"params_nested_splits\",\n                                                &params_nested_splits_in));\n    const Tensor& params_dense_values_in =\n        context->input(params_nested_splits_in.size());\n    const Tensor& indices_in =\n        context->input(params_nested_splits_in.size() + 1);\n    DCHECK_GT(params_nested_splits_in.size(), 0);  \n    SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;\n    OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));\n    OP_REQUIRES(context, params_dense_values_in.dims() > 0,\n                errors::InvalidArgument(\"params.rank must be nonzero\"));\n    SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);\n    std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;\n    SPLITS_TYPE num_values = 0;\n    std::vector<std::vector<SPLITS_TYPE>> out_splits;\n    OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,\n                                       num_params_dense_values, &out_splits,\n                                       &value_slices, &num_values));\n    OP_REQUIRES_OK(context, WriteSplits(out_splits, context));\n    OP_REQUIRES_OK(context,\n                   WriteValues(params_dense_values_in, value_slices,\n                               out_splits.size(), num_values, context));\n  }", "target": 1}
{"code": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\tret = security_task_getioprio(p);\n \tif (ret)\n \t\tgoto out;\n \tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n \tif (p->io_context)\n \t\tret = p->io_context->ioprio;\n out:\n \treturn ret;\n }", "target": 1}
{"code": "snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static u32 zipfileGetTime(sqlite3_value *pVal){\n  if( pVal==0 || sqlite3_value_type(pVal)==SQLITE_NULL ){\n    return zipfileTime();\n  }\n  return (u32)sqlite3_value_int64(pVal);\n}", "target": 0}
{"code": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n \tstruct context context;\n \tint rc = 0;\n \tif (!ss_initialized) {\n \t\tint i;\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\tif (force) {\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}", "target": 1}
{"code": "xfs_iunlink_init(\n\tstruct xfs_perag\t*pag)\n{\n\treturn rhashtable_init(&pag->pagi_unlinked_hash,\n\t\t\t&xfs_iunlink_hash_params);\n}", "target": 0}
{"code": "format_nstime_as_iso8601(gchar *buf, size_t buflen, const nstime_t *ns,\n    char *decimal_point, gboolean local, int precision)\n{\n\tstruct tm tm, *tmp;\n\tgchar *ptr;\n\tsize_t buf_remaining;\n\tint num_chars;\n\tif (local)\n\t\ttmp = ws_localtime_r(&ns->secs, &tm);\n\telse\n\t\ttmp = ws_gmtime_r(&ns->secs, &tm);\n\tif (tmp == NULL) {\n\t\tsnprintf(buf, buflen, \"Not representable\");\n\t\treturn;\n\t}\n\tptr = buf;\n\tbuf_remaining = buflen;\n\tnum_chars = snprintf(ptr, buf_remaining,\n\t    \"%04d-%02d-%02d %02d:%02d:%02d\",\n\t    tmp->tm_year + 1900,\n\t    tmp->tm_mon + 1,\n\t    tmp->tm_mday,\n\t    tmp->tm_hour,\n\t    tmp->tm_min,\n\t    tmp->tm_sec);\n\tif (num_chars < 0) {\n\t\tsnprintf(buf, buflen, \"snprintf() failed\");\n\t\treturn;\n\t}\n\tif ((unsigned int)num_chars >= buf_remaining) {\n\t\treturn;\n\t}\n\tptr += num_chars;\n\tbuf_remaining -= num_chars;\n\tif (precision == 0) {\n\t\treturn;\n\t}\n\tformat_fractional_part_nsecs(ptr, buf_remaining, (guint32)ns->nsecs, decimal_point, precision);\n}", "target": 1}
{"code": "static inline int check_user_page_hwpoison(unsigned long addr)\n{\n\tint rc, flags = FOLL_HWPOISON | FOLL_WRITE;\n\trc = get_user_pages(addr, 1, flags, NULL, NULL);\n\treturn rc == -EHWPOISON;\n}", "target": 0}
{"code": "int socketio_setoption(CONCRETE_IO_HANDLE socket_io, const char* optionName, const void* value)\n{\n    int result;\n    if (socket_io == NULL ||\n        optionName == NULL ||\n        value == NULL)\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        SOCKET_IO_INSTANCE* socket_io_instance = (SOCKET_IO_INSTANCE*)socket_io;\n        if (strcmp(optionName, \"tcp_keepalive\") == 0)\n        {\n            result = setsockopt(socket_io_instance->socket, SOL_SOCKET, SO_KEEPALIVE, value, sizeof(int));\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, \"tcp_keepalive_time\") == 0)\n        {\n#ifdef __APPLE__\n            result = setsockopt(socket_io_instance->socket, IPPROTO_TCP, TCP_KEEPALIVE, value, sizeof(int));\n#else\n            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPIDLE, value, sizeof(int));\n#endif\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, \"tcp_keepalive_interval\") == 0)\n        {\n            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPINTVL, value, sizeof(int));\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, OPTION_NET_INT_MAC_ADDRESS) == 0)\n        {\n#ifdef __APPLE__\n            LogError(\"option not supported.\");\n            result = MU_FAILURE;\n#else\n            if (strlen(value) == 0)\n            {\n                LogError(\"option value must be a valid mac address\");\n                result = MU_FAILURE;\n            }\n            else if ((socket_io_instance->target_mac_address = (char*)malloc(sizeof(char) * (strlen(value) + 1))) == NULL)\n            {\n                LogError(\"failed setting net_interface_mac_address option (malloc failed)\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(socket_io_instance->target_mac_address, value);\n                strtoup(socket_io_instance->target_mac_address);\n                result = 0;\n            }\n#endif\n        }\n        else if (strcmp(optionName, OPTION_ADDRESS_TYPE) == 0)\n        {\n            result = socketio_setaddresstype_option(socket_io_instance, (const char*)value);\n        }\n        else\n        {\n            result = MU_FAILURE;\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "  base::Time IncrementMockTime() {\n    ++mock_time_counter_;\n    return base::Time::FromDoubleT(mock_time_counter_ * 10.0);\n  }", "target": 0}
{"code": "  void set_db_disabled(bool db_disabled) {\n    db_disabled_ = db_disabled;\n  }", "target": 0}
{"code": "    long DataValue::count() const\n    {\n        return size();\n    }", "target": 0}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n    OP_REQUIRES(context, tensor_in.dims() == 5,\n                errors::InvalidArgument(\"tensor_in must be 5-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 5,\n                errors::InvalidArgument(\"tensor_out must be 5-dimensional\"));\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 5,\n        errors::InvalidArgument(\"out_grad_backprop must be 5-dimensional\"));\n    Pool3dParameters params{context,  ksize_,       stride_,\n                            padding_, data_format_, tensor_in.shape()};\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {2}, 0, tensor_out.shape(), &output));\n    LaunchMaxPooling3dGradGradOp<Device, T>::launch(\n        context, params, tensor_in, tensor_out, out_grad_backprop, output);\n  }", "target": 1}
{"code": "static int _snd_timer_stop(struct snd_timer_instance * timeri,\n\t\t\t   int keep_flag, int event)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n \t\tif (!keep_flag) {\n \t\t\tspin_lock_irqsave(&slave_active_lock, flags);\n \t\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n \t\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n \t\t}\n \t\tgoto __end;\n\t}\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\tif (!keep_flag)\n\t\ttimeri->flags &=\n\t\t\t~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n      __end:\n\tif (event != SNDRV_TIMER_EVENT_RESOLUTION)\n\t\tsnd_timer_notify1(timeri, event);\n\treturn 0;\n}", "target": 1}
{"code": "static inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\tdentry->d_inode = inode;\n\tsmp_wmb();\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tWRITE_ONCE(dentry->d_flags, flags);\n}", "target": 0}
{"code": "ospf_db_desc_save_current (struct ospf_neighbor *nbr,\n\t\t\t   struct ospf_db_desc *dd)\n{\n  nbr->last_recv.flags = dd->flags;\n  nbr->last_recv.options = dd->options;\n  nbr->last_recv.dd_seqnum = ntohl (dd->dd_seqnum);\n}", "target": 0}
{"code": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\tfast_pool->count = 0;\n\tcredit_entropy_bits(r, credit + 1);\n}", "target": 1}
{"code": "void AudioContext::rejectPendingResolvers()\n{\n    ASSERT(isMainThread());\n    for (auto& resolver : m_suspendResolvers) {\n        resolver->reject(DOMException::create(InvalidStateError, \"Audio context is going away\"));\n    }\n    m_suspendResolvers.clear();\n    for (auto& resolver : m_resumeResolvers) {\n        resolver->reject(DOMException::create(InvalidStateError, \"Audio context is going away\"));\n    }\n    m_resumeResolvers.clear();\n    m_isResolvingResumePromises = false;\n}", "target": 0}
{"code": "void HTMLSelectElement::recalcListItems(bool updateSelectedStates) const\n{\n    m_listItems.clear();\n    m_shouldRecalcListItems = false;\n    HTMLOptionElement* foundSelected = 0;\n    HTMLOptionElement* firstOption = 0;\n    for (Element* currentElement = ElementTraversal::firstWithin(*this); currentElement; ) {\n        if (!currentElement->isHTMLElement()) {\n            currentElement = ElementTraversal::nextSkippingChildren(*currentElement, this);\n            continue;\n        }\n        HTMLElement& current = toHTMLElement(*currentElement);\n        if (current.hasTagName(optgroupTag)) {\n            m_listItems.append(&current);\n            if (Element* nextElement = ElementTraversal::firstWithin(current)) {\n                currentElement = nextElement;\n                continue;\n            }\n        }\n        if (current.hasTagName(optionTag)) {\n            m_listItems.append(&current);\n            if (updateSelectedStates && !m_multiple) {\n                HTMLOptionElement& option = toHTMLOptionElement(current);\n                if (!firstOption)\n                    firstOption = &option;\n                if (option.selected()) {\n                    if (foundSelected)\n                        foundSelected->setSelectedState(false);\n                    foundSelected = &option;\n                } else if (m_size <= 1 && !foundSelected && !option.isDisabledFormControl()) {\n                    foundSelected = &option;\n                    foundSelected->setSelectedState(true);\n                }\n            }\n        }\n        if (current.hasTagName(hrTag))\n            m_listItems.append(&current);\n        currentElement = ElementTraversal::nextSkippingChildren(*currentElement, this);\n    }\n    if (!foundSelected && m_size <= 1 && firstOption && !firstOption->selected())\n        firstOption->setSelectedState(true);\n}", "target": 0}
{"code": "static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n\tif (disk != NULL) {\n\t\tconst int blocksize = 512; \n\t\tint ret;\n\t\tRIOBind *iob = disk->data;\n\t\tif (bio) iob = bio;\n\t\tret = iob->read_at (iob->io, delta+(blocksize*sector),\n\t\t\t(ut8*)buf, size*blocksize);\n\t\tif (ret == -1)\n\t\t\treturn 1;\n\t} else eprintf (\"oops. no disk\\n\");\n\treturn 0; \n}", "target": 1}
{"code": "SWFInput_rewind(SWFInput input)\n{\n\tSWFInput_seek(input, 0, SEEK_SET);\n}", "target": 0}
{"code": "int user_update(struct key *key, const void *data, size_t datalen)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tint ret;\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !data)\n\t\tgoto error;\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, data, datalen);\n\tzap = upayload;\n\tret = key_payload_reserve(key, datalen);\n\tif (ret == 0) {\n\t\tzap = key->payload.data;\n\t\trcu_assign_pointer(key->payload.data, upayload);\n\t\tkey->expiry = 0;\n\t}\n\tkfree_rcu(zap, rcu);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n    bs->read_only = 1;\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n    if (s->block_size % 512) {\n        error_setg(errp, \"block_size %u must be a multiple of 512\",\n                   s->block_size);\n        return -EINVAL;\n    }\n    if (s->block_size == 0) {\n        error_setg(errp, \"block_size cannot be zero\");\n        return -EINVAL;\n    }\n    if (s->block_size > MAX_BLOCK_SIZE) {\n        error_setg(errp, \"block_size %u must be %u MB or less\",\n                   s->block_size,\n                   MAX_BLOCK_SIZE / (1024 * 1024));\n        return -EINVAL;\n    }\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n     s->n_blocks = be32_to_cpu(s->n_blocks);\n     offsets_size = s->n_blocks * sizeof(uint64_t);\n     s->offsets = g_malloc(offsets_size);\n        if (i > 0) {\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n            if (size > max_compressed_block_size) {\n                max_compressed_block_size = size;\n            }\n        }\n    }", "target": 1}
{"code": "unsigned ContainerNode::countChildren() const\n{\n    unsigned count = 0;\n    Node* n;\n    for (n = firstChild(); n; n = n->nextSibling())\n        count++;\n    return count;\n}", "target": 0}
{"code": "static int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\tif (!sk)\n\t\treturn 0;\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\tlock_sock(sk);\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\tif (op->ifindex) {\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\t\tbcm_remove_op(op);\n\t}\n#if IS_ENABLED(CONFIG_PROC_FS)\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif \n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}", "target": 1}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape(ssm.shape());\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 1}
{"code": "static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newbufsize;\n\tlong newpos;\n\tassert(buf);\n\tassert(cnt >= 0);\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\tnewbufsize <<= 1;\n\t\t\tassert(newbufsize >= 0);\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %z\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %ul\\n\", m->bufsize_,\n\t\t  JAS_CAST(unsigned long, newbufsize)));\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}", "target": 1}
{"code": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tstruct minidump_directory entry;\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\tut64 rvadir = obj->hdr->stream_directory_rva;\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tut32 delta = i * sizeof (struct minidump_directory);\n\t\tint r = r_buf_read_at (obj->b, rvadir + delta, (ut8*) &entry, sizeof (struct minidump_directory));\n\t\tif (r) {\n\t\t\tr_bin_mdmp_init_directory_entry (obj, &entry);\n\t\t}\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static inline void RelinquishDCMMemory(DCMInfo *info,DCMMap *map,\n  DCMStreamInfo *stream_info,LinkedListInfo *stack,unsigned char *data)\n{\n  if (info->scale != (Quantum *) NULL)\n    info->scale=(Quantum *) RelinquishMagickMemory(info->scale);\n  if (map->gray != (int *) NULL)\n    map->gray=(int *) RelinquishMagickMemory(map->gray);\n  if (map->blue != (int *) NULL)\n    map->blue=(int *) RelinquishMagickMemory(map->blue);\n  if (map->green != (int *) NULL)\n    map->green=(int *) RelinquishMagickMemory(map->green);\n  if (map->red != (int *) NULL)\n    map->red=(int *) RelinquishMagickMemory(map->red);\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n      stream_info->offsets);\n  if (stream_info != (DCMStreamInfo *) NULL)\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (stack != (LinkedListInfo *) NULL)\n    stack=DestroyLinkedList(stack,RelinquishDCMInfo);\n  if (data != (unsigned char *) NULL)\n    data=(unsigned char *) RelinquishMagickMemory(data);\n}", "target": 0}
{"code": "static void _mysql_close(void *conn)\n{\n    mysql_close(conn);\n}", "target": 0}
{"code": "int __isolate_free_page(struct page *page, unsigned int order)\n{\n\tunsigned long watermark;\n\tstruct zone *zone;\n\tint mt;\n\tBUG_ON(!PageBuddy(page));\n\tzone = page_zone(page);\n\tmt = get_pageblock_migratetype(page);\n\tif (!is_migrate_isolate(mt)) {\n\t\twatermark = min_wmark_pages(zone) + (1UL << order);\n\t\tif (!zone_watermark_ok(zone, 0, watermark, 0, ALLOC_CMA))\n\t\t\treturn 0;\n\t\t__mod_zone_freepage_state(zone, -(1UL << order), mt);\n\t}\n\tlist_del(&page->lru);\n\tzone->free_area[order].nr_free--;\n\trmv_page_order(page);\n\tif (order >= pageblock_order - 1) {\n\t\tstruct page *endpage = page + (1 << order) - 1;\n\t\tfor (; page < endpage; page += pageblock_nr_pages) {\n\t\t\tint mt = get_pageblock_migratetype(page);\n\t\t\tif (!is_migrate_isolate(mt) && !is_migrate_cma(mt)\n\t\t\t    && !is_migrate_highatomic(mt))\n\t\t\t\tset_pageblock_migratetype(page,\n\t\t\t\t\t\t\t  MIGRATE_MOVABLE);\n\t\t}\n\t}\n\treturn 1UL << order;\n}", "target": 0}
{"code": "static inline struct page *__skb_alloc_pages(gfp_t gfp_mask,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      unsigned int order)\n{\n\tstruct page *page;\n\tgfp_mask |= __GFP_COLD;\n\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\tgfp_mask |= __GFP_MEMALLOC;\n\tpage = alloc_pages_node(NUMA_NO_NODE, gfp_mask, order);\n\tif (skb && page && page->pfmemalloc)\n\t\tskb->pfmemalloc = true;\n\treturn page;\n}", "target": 0}
{"code": "RoleName RoleName::parseFromBSON(const BSONElement& elem) {\n    auto obj = elem.embeddedObjectUserCheck();\n    std::array<BSONElement, 2> fields;\n    obj.getFields(\n        {AuthorizationManager::ROLE_NAME_FIELD_NAME, AuthorizationManager::ROLE_DB_FIELD_NAME},\n        &fields);\n    const auto& nameField = fields[0];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"user name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_NAME_FIELD_NAME,\n            nameField.type() == String);\n    const auto& dbField = fields[1];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"role name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_DB_FIELD_NAME,\n            nameField.type() == String);\n    return RoleName(nameField.valueStringData(), dbField.valueStringData());\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, SortSkipSoftLimit) {\n    runQuerySortProjSkipNToReturn(BSONObj(), fromjson(\"{a: 1}\"), BSONObj(), 2, 3);\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{skip: {n: 2, node: \"\n        \"{sort: {pattern: {a: 1}, limit: 5, node: {sortKeyGen: \"\n        \"{node: {cscan: {dir: 1}}}}}}}}\");\n}", "target": 0}
{"code": "static int virtio_net_ufo_pre_save(void *opaque)\n{\n    struct VirtIONetMigTmp *tmp = opaque;\n    tmp->has_ufo = tmp->parent->has_ufo;\n    return 0;\n}", "target": 0}
{"code": "DEATH_TEST(LteOp, InvalidEooOperand, \"Invariant failure _rhs\") {\n    BSONObj operand;\n    LTEMatchExpression lte(\"\", operand.firstElement());\n}", "target": 0}
{"code": "void HTMLSelectElement::dispatchBlurEvent(Element* newFocusedElement)\n{\n    if (usesMenuList())\n        dispatchChangeEventForMenuList();\n    HTMLFormControlElementWithState::dispatchBlurEvent(newFocusedElement);\n}", "target": 0}
{"code": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}", "target": 1}
{"code": "get_text_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = read_pbm_integer(cinfo, infile, maxval);\n      JSAMPLE g = read_pbm_integer(cinfo, infile, maxval);\n      JSAMPLE b = read_pbm_integer(cinfo, infile, maxval);\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      JSAMPLE g = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      JSAMPLE b = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "static int fts3ConnectMethod(\n  sqlite3 *db,                    \n  void *pAux,                     \n  int argc,                       \n  const char * const *argv,       \n  sqlite3_vtab **ppVtab,          \n  char **pzErr                    \n){\n  return fts3InitVtab(0, db, pAux, argc, argv, ppVtab, pzErr);\n}", "target": 0}
{"code": "static int __init setup_fail_page_alloc(char *str)\n{\n\treturn setup_fault_attr(&fail_page_alloc.attr, str);\n}", "target": 0}
{"code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\ttu = file->private_data;\n\tmutex_lock(&tu->tread_sem);\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t}\n      __err:\n      \tmutex_unlock(&tu->tread_sem);\n\treturn err;\n}", "target": 1}
{"code": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "PHPAPI zend_string *php_escape_shell_arg(char *str)\n{\n\tint x, y = 0, l = (int)strlen(str);\n\tzend_string *cmd;\n\tsize_t estimate = (4 * l) + 3;\n\tcmd = zend_string_alloc(4 * l + 2, 0); \n#ifdef PHP_WIN32\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\tfor (x = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (str[x]) {\n#ifdef PHP_WIN32\n\t\tcase '\"':\n\t\tcase '%':\n\t\tcase '!':\n\t\t\tZSTR_VAL(cmd)[y++] = ' ';\n\t\t\tbreak;\n#else\n\t\tcase '\\'':\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\t\tdefault:\n\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t}\n\t}\n#ifdef PHP_WIN32\n\tif (y > 0 && '\\\\' == ZSTR_VAL(cmd)[y - 1]) {\n\t\tint k = 0, n = y - 1;\n\t\tfor (; n >= 0 && '\\\\' == ZSTR_VAL(cmd)[n]; n--, k++);\n\t\tif (k % 2) {\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\tZSTR_VAL(cmd)[y] = '\\0';\n\tif ((estimate - y) > 4096) {\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\tZSTR_LEN(cmd) = y;\n\treturn cmd;\n}", "target": 1}
{"code": "MP4::Properties::length() const\n{\n  return d->length;\n}", "target": 0}
{"code": "void Texture::Create() {\n  ScopedGLErrorSuppressor suppressor(decoder_);\n  Destroy();\n  glGenTextures(1, &id_);\n  ScopedTexture2DBinder binder(decoder_, id_);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n  glTexImage2D(\n      GL_TEXTURE_2D, 0, GL_RGBA, 16, 16, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);\n  estimated_size_ = 16u * 16u * 4u;\n  decoder_->UpdateBackbufferMemoryAccounting();\n}", "target": 0}
{"code": "const GF_MasteringDisplayColourVolumeInfo *gf_isom_get_mastering_display_colour_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return NULL;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn NULL;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tGF_MasteringDisplayColourVolumeBox *mdcvb = (GF_MasteringDisplayColourVolumeBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\tif (!mdcvb) return NULL;\n\treturn &mdcvb->mdcv;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* reverse_index_map_t;\n    const Tensor* grad_values_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"reverse_index_map\", &reverse_index_map_t));\n    OP_REQUIRES_OK(context, context->input(\"grad_values\", &grad_values_t));\n    const CPUDevice& d = context->eigen_device<CPUDevice>();\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),\n        errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",\n                                reverse_index_map_t->shape().DebugString()));\n    const auto reverse_index_map = reverse_index_map_t->vec<int64>();\n    const auto grad_values = grad_values_t->vec<T>();\n    const int64 N = reverse_index_map_t->shape().dim_size(0);\n    const int64 N_full = grad_values_t->shape().dim_size(0);\n    Tensor* d_values_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"d_values\", TensorShape({N}), &d_values_t));\n    auto d_values = d_values_t->vec<T>();\n    Tensor* d_default_value_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"d_default_value\", TensorShape({}),\n                                            &d_default_value_t));\n    T& d_default_value = d_default_value_t->scalar<T>()();\n    d_default_value = T();\n    Tensor visited_t;\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(d) = visited.constant(false);\n    for (int i = 0; i < N; ++i) {\n      d_values(i) = grad_values(reverse_index_map(i));\n      visited(reverse_index_map(i)) = true;\n    }\n    for (int j = 0; j < N_full; ++j) {\n      if (!visited(j)) {\n        d_default_value += grad_values(j);\n      }\n    }\n  }", "target": 1}
{"code": "static bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; \n\tbool result = true;\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; \n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tgoto done;\nunref:\n\tgluster_cache_refresh(fs, path);\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\treturn result;\n}", "target": 1}
{"code": "TfLiteStatus StoreAllDecodedSequences(\n    TfLiteContext* context,\n    const std::vector<std::vector<std::vector<int>>>& sequences,\n    TfLiteNode* node, int top_paths) {\n  const int32_t batch_size = sequences.size();\n  std::vector<int32_t> num_entries(top_paths, 0);\n  for (const auto& batch_s : sequences) {\n    TF_LITE_ENSURE_EQ(context, batch_s.size(), top_paths);\n    for (int p = 0; p < top_paths; ++p) {\n      num_entries[p] += batch_s[p].size();\n    }\n  }\n  for (int p = 0; p < top_paths; ++p) {\n    const int32_t p_num = num_entries[p];\n    TfLiteTensor* indices = GetOutput(context, node, p);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num, 2}, indices));\n    TfLiteTensor* values = GetOutput(context, node, p + top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num}, values));\n    TfLiteTensor* decoded_shape = GetOutput(context, node, p + 2 * top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {2}, decoded_shape));\n    int32_t max_decoded = 0;\n    int32_t offset = 0;\n    int32_t* indices_data = GetTensorData<int32_t>(indices);\n    int32_t* values_data = GetTensorData<int32_t>(values);\n    int32_t* decoded_shape_data = GetTensorData<int32_t>(decoded_shape);\n    for (int b = 0; b < batch_size; ++b) {\n      auto& p_batch = sequences[b][p];\n      int32_t num_decoded = p_batch.size();\n      max_decoded = std::max(max_decoded, num_decoded);\n      std::copy_n(p_batch.begin(), num_decoded, values_data + offset);\n      for (int32_t t = 0; t < num_decoded; ++t, ++offset) {\n        indices_data[offset * 2] = b;\n        indices_data[offset * 2 + 1] = t;\n      }\n    }\n    decoded_shape_data[0] = batch_size;\n    decoded_shape_data[1] = max_decoded;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg;\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 1}
{"code": "z2save(i_ctx_t *i_ctx_p)\n{\n    if (!save_page_device(igs))\n        return zsave(i_ctx_p);\n    return push_callout(i_ctx_p, \"%savepagedevice\");\n}", "target": 0}
{"code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\treturn NF_ACCEPT;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}", "target": 1}
{"code": "callbacks_control_gerber_options_activate     (GtkMenuItem     *menuitem,\n                                        gpointer         user_data)\n{\n}", "target": 0}
{"code": "static const void *netdev_queue_namespace(struct kobject *kobj)\n{\n\tstruct netdev_queue *queue = to_netdev_queue(kobj);\n\tstruct device *dev = &queue->dev->dev;\n\tconst void *ns = NULL;\n\tif (dev->class && dev->class->ns_type)\n\t\tns = dev->class->namespace(dev);\n\treturn ns;", "target": 0}
{"code": "Opal::Call::OnReleased (OpalConnection & connection)\n{\n  parse_info (connection);\n  OpalCall::OnReleased (connection);\n}", "target": 0}
{"code": "TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,\n                          const TfLiteTensor* axis, TfLiteTensor* output) {\n  int axis_value;\n  if (axis->type == kTfLiteInt64) {\n    axis_value = static_cast<int>(*GetTensorData<int64_t>(axis));\n  } else {\n    axis_value = *GetTensorData<int>(axis);\n  }\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);\n  int j = 0;\n  for (int i = 0; i < NumDimensions(input); ++i) {\n    if (i != axis_value) {\n      output_dims->data[j] = SizeOfDimension(input, i);\n      ++j;\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 1}
{"code": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->err_code = buf[6] * 100 + buf[7];\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    pj_strdup(pool, &attr->reason, &value);\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "static void kvm_mmu_notifier_invalidate_page(struct mmu_notifier *mn,\n\t\t\t\t\t     struct mm_struct *mm,\n\t\t\t\t\t     unsigned long address)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tint need_tlb_flush, idx;\n\tidx = srcu_read_lock(&kvm->srcu);\n\tspin_lock(&kvm->mmu_lock);\n\tkvm->mmu_notifier_seq++;\n\tneed_tlb_flush = kvm_unmap_hva(kvm, address) | kvm->tlbs_dirty;\n\tspin_unlock(&kvm->mmu_lock);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tif (need_tlb_flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}", "target": 0}
{"code": "Eina_Bool ewk_view_zoom_weak_set(Evas_Object* ewkView, float zoom, Evas_Coord centerX, Evas_Coord centerY)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET(smartData, priv);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api->zoom_weak_set, false);\n    if (!priv->settings.zoomRange.userScalable) {\n        WRN(\"userScalable is false\");\n        return false;\n    }\n    if (zoom < priv->settings.zoomRange.minScale) {\n        WRN(\"zoom level is < %f : %f\", priv->settings.zoomRange.minScale, zoom);\n        return false;\n    }\n    if (zoom > priv->settings.zoomRange.maxScale) {\n        WRN(\"zoom level is > %f : %f\", priv->settings.zoomRange.maxScale, zoom);\n        return false;\n    }\n    smartData->animated_zoom.zoom.start = ewk_frame_page_zoom_get(smartData->main_frame);\n    smartData->animated_zoom.zoom.end = zoom;\n    smartData->animated_zoom.zoom.current = zoom;\n    return smartData->api->zoom_weak_set(smartData, zoom, centerX, centerY);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    const T min_as_quantized = FloatToQuantized<T>(0.0f, min_input, max_input);\n    const T max_as_quantized = FloatToQuantized<T>(6.0f, min_input, max_input);\n    if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n      auto input_ui8_array = input.flat<quint8>();\n      meta::Clamp(context, input_ui8_array.data(), input_ui8_array.size(),\n                  min_as_quantized, max_as_quantized,\n                  output->flat<quint8>().data());\n    } else {\n      output->flat<T>().device(context->eigen_cpu_device()) =\n          input.flat<T>()\n              .cwiseMax(min_as_quantized)\n              .cwiseMin(max_as_quantized)\n              .template cast<T>();\n    }\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "static void destroy_compound_hugetlb_page_for_demote(struct page *page,\n\t\t\t\t\tunsigned int order)\n{\n\t__destroy_compound_gigantic_page(page, order, true);\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* input_state = GetInput(context, node, kInputState);\n  const TfLiteTensor* gate_weight = GetInput(context, node, kGateWeight);\n  const TfLiteTensor* gate_bias = GetInput(context, node, kGateBias);\n  const TfLiteTensor* candidate_weight =\n      GetInput(context, node, kCandidateWeight);\n  const TfLiteTensor* candidate_bias = GetInput(context, node, kCandidateBias);\n  TfLiteTensor* output = GetOutput(context, node, kOutput);\n  TfLiteTensor* output_state = GetOutput(context, node, kOutputState);\n  TfLiteTensor* activation = GetTemporary(context, node, kActivation);\n  TfLiteTensor* concat = GetTemporary(context, node, kConcat);\n  auto cpu_backend_context = CpuBackendContext::GetFromContext(context);\n  if (gate_weight->type == kTfLiteFloat32) {\n    GruImpl(input, input_state, gate_weight, gate_bias, candidate_weight,\n            candidate_bias, output, output_state, activation, concat,\n            cpu_backend_context);\n  } else {\n    context->ReportError(context,\n                         \"Unsupported combination of data types for GruCell\");\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "    TimeValue* TimeValue::clone_() const\n    {\n        return new TimeValue(*this);\n    }", "target": 0}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n \tunsigned long flags;\n \tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n }", "target": 1}
{"code": "acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\treturn ret;\n}", "target": 1}
{"code": "xmlValidGetElemDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t            xmlNodePtr elem, int *extsubset) {\n    xmlElementPtr elemDecl = NULL;\n    const xmlChar *prefix = NULL;\n    if ((ctxt == NULL) || (doc == NULL) ||\n        (elem == NULL) || (elem->name == NULL))\n        return(NULL);\n    if (extsubset != NULL)\n\t*extsubset = 0;\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL))\n\tprefix = elem->ns->prefix;\n    if (prefix != NULL) {\n\telemDecl = xmlGetDtdQElementDesc(doc->intSubset,\n\t\t                         elem->name, prefix);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdQElementDesc(doc->extSubset,\n\t\t                             elem->name, prefix);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\telemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\txmlErrValidNode(ctxt, elem,\n\t\t\tXML_DTD_UNKNOWN_ELEM,\n\t       \"No declaration for element %s\\n\",\n\t       elem->name, NULL, NULL);\n    }\n    return(elemDecl);\n}", "target": 0}
{"code": "static bool get_build_id(\n Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {\n HdrType hdr;\n  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);\n if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,\n sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {\n return false;\n }\n for (size_t i = 0; i < hdr.e_phnum; i++) {\n PhdrType phdr;\n if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,\n reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {\n return false;\n }\n if (phdr.p_type == PT_NOTE) {\n size_t hdr_size = phdr.p_filesz;\n uintptr_t addr = base_addr + phdr.p_offset;\n while (hdr_size >= sizeof(NhdrType)) {\n NhdrType nhdr;\n if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {\n return false;\n }\n        addr += sizeof(nhdr);\n         if (nhdr.n_type == NT_GNU_BUILD_ID) {\n           addr += NOTE_ALIGN(nhdr.n_namesz);\n          uint8_t build_id_data[128];\n          if (nhdr.n_namesz > sizeof(build_id_data)) {\n            ALOGE(\"Possible corrupted note, name size value is too large: %u\",\n                  nhdr.n_namesz);\n             return false;\n           }\n           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {\n return false;\n }\n          build_id->clear();\n for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {\n *build_id += android::base::StringPrintf(\"%02x\", build_id_data[bytes]);\n }\n return true;\n } else {\n          hdr_size -= sizeof(nhdr);\n size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);\n          addr += skip_bytes;\n if (hdr_size < skip_bytes) {\n break;\n }\n          hdr_size -= skip_bytes;\n }\n }\n }\n }\n return false;\n}", "target": 1}
{"code": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}", "target": 1}
{"code": "bool Item_null::send(Protocol *protocol, String *packet)\n{\n  return protocol->store_null();\n}", "target": 0}
{"code": "  bool check_table_name_processor(void *arg)\n  {\n    Check_table_name_prm &p= *(Check_table_name_prm *) arg;\n    if (!field && p.table_name.length && table_name)\n    {\n      DBUG_ASSERT(p.db.length);\n      if ((db_name &&\n          my_strcasecmp(table_alias_charset, p.db.str, db_name)) ||\n          my_strcasecmp(table_alias_charset, p.table_name.str, table_name))\n      {\n        print(&p.field, (enum_query_type) (QT_ITEM_ORIGINAL_FUNC_NULLIF |\n                                          QT_NO_DATA_EXPANSION |\n                                          QT_TO_SYSTEM_CHARSET));\n        return true;\n      }\n    }\n    return false;\n  }", "target": 0}
{"code": "merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n                         output_buf + *out_row_ctr);\n  (*out_row_ctr)++;\n  (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "TEST(EqOp, Equality1) {\n    BSONObj operand = BSON(\"a\" << 5 << \"b\" << 5 << \"c\" << 4);\n    EqualityMatchExpression eq1(\"a\", operand[\"a\"]);\n    EqualityMatchExpression eq2(\"a\", operand[\"b\"]);\n    EqualityMatchExpression eq3(\"c\", operand[\"c\"]);\n    ASSERT(eq1.equivalent(&eq1));\n    ASSERT(eq1.equivalent(&eq2));\n    ASSERT(!eq1.equivalent(&eq3));\n}", "target": 0}
{"code": "void Browser::ExitFullscreenModeForTab(WebContents* web_contents) {\n  exclusive_access_manager_->fullscreen_controller()->ExitFullscreenModeForTab(\n      web_contents);\n}", "target": 0}
{"code": "char *php_date_full_day_name(timelib_sll y, timelib_sll m, timelib_sll d)\n{\n\ttimelib_sll day_of_week = timelib_day_of_week(y, m, d);\n\tif (day_of_week < 0) {\n\t\treturn \"Unknown\";\n\t} \n\treturn day_full_names[day_of_week];\t", "target": 0}
{"code": "void ssl3_cbc_copy_mac(unsigned char* out,\n\t\t       const SSL3_RECORD *rec,\n\t\t       unsigned md_size,unsigned orig_len)\n\t{\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n\tunsigned char rotated_mac_buf[EVP_MAX_MD_SIZE*2];\n\tunsigned char *rotated_mac;\n#else\n\tunsigned char rotated_mac[EVP_MAX_MD_SIZE];\n#endif\n\tunsigned mac_end = rec->length;\n\tunsigned mac_start = mac_end - md_size;\n\tunsigned scan_start = 0;\n\tunsigned i, j;\n\tunsigned div_spoiler;\n\tunsigned rotate_offset;\n\tOPENSSL_assert(orig_len >= md_size);\n\tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n\trotated_mac = (unsigned char*) (((intptr_t)(rotated_mac_buf + 64)) & ~63);\n#endif\n\tif (orig_len > md_size + 255 + 1)\n\t\tscan_start = orig_len - (md_size + 255 + 1);\n\tdiv_spoiler = md_size >> 1;\n\tdiv_spoiler <<= (sizeof(div_spoiler)-1)*8;\n\trotate_offset = (div_spoiler + mac_start - scan_start) % md_size;\n\tmemset(rotated_mac, 0, md_size);\n\tfor (i = scan_start, j = 0; i < orig_len; i++)\n\t\t{\n\t\tunsigned char mac_started = constant_time_ge(i, mac_start);\n\t\tunsigned char mac_ended = constant_time_ge(i, mac_end);\n\t\tunsigned char b = rec->data[i];\n\t\trotated_mac[j++] |= b & mac_started & ~mac_ended;\n\t\tj &= constant_time_lt(j,md_size);\n\t\t}\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n\tj = 0;\n\tfor (i = 0; i < md_size; i++)\n\t\t{\n\t\tout[j++] = rotated_mac[rotate_offset++];\n\t\trotate_offset &= constant_time_lt(rotate_offset,md_size);\n\t\t}\n#else\n\tmemset(out, 0, md_size);\n\trotate_offset = md_size - rotate_offset;\n\trotate_offset &= constant_time_lt(rotate_offset,md_size);\n\tfor (i = 0; i < md_size; i++)\n\t\t{\n\t\tfor (j = 0; j < md_size; j++)\n\t\t\tout[j] |= rotated_mac[i] & constant_time_eq_8(j, rotate_offset);\n\t\trotate_offset++;\n\t\trotate_offset &= constant_time_lt(rotate_offset,md_size);\n\t\t}\n#endif\n\t}", "target": 1}
{"code": "    void Modify::regNamespace(const ModifyCmd& modifyCmd)\n    {\n        if (Params::instance().verbose_) {\n            std::cout << _(\"Reg \") << modifyCmd.key_ << \"=\\\"\" << modifyCmd.value_ << \"\\\"\" << std::endl;\n        }\n        Exiv2::XmpProperties::registerNs(modifyCmd.value_, modifyCmd.key_);\n    }", "target": 0}
{"code": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}", "target": 1}
{"code": "static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n\t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n\t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n\t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static int em_bsf(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 zf;\n\t__asm__ (\"bsf %2, %0; setz %1\"\n\t\t : \"=r\"(ctxt->dst.val), \"=q\"(zf)\n\t\t : \"r\"(ctxt->src.val));\n\tctxt->eflags &= ~X86_EFLAGS_ZF;\n\tif (zf) {\n\t\tctxt->eflags |= X86_EFLAGS_ZF;\n\t\tctxt->dst.type = OP_NONE;\n\t}\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static void zynq_slcr_reset_exit(Object *obj)\n{\n    ZynqSLCRState *s = ZYNQ_SLCR(obj);\n    zynq_slcr_compute_clocks(s);\n    zynq_slcr_propagate_clocks(s);\n}", "target": 0}
{"code": "flatpak_run_add_journal_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *journal_socket_socket = g_strdup (\"/run/systemd/journal/socket\");\n  g_autofree char *journal_stdout_socket = g_strdup (\"/run/systemd/journal/stdout\");\n  if (g_file_test (journal_socket_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_socket_socket, journal_socket_socket,\n                              NULL);\n    }\n  if (g_file_test (journal_stdout_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_stdout_socket, journal_stdout_socket,\n                              NULL);\n    }\n}", "target": 0}
{"code": "void ACLosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    ULONG  x = m_ulX[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        LONG v;\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        if (m_Coder.Get(zset.S0)) {\n          LONG sz   = 0;\n          bool sign = m_Coder.Get(zset.SS); \n          if (m_Coder.Get((sign)?(zset.SN):(zset.SP))) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            while(m_Coder.Get(mset.X[i])) {\n              m <<= 1;\n              i++;\n            }\n            m >>= 1;\n            sz  = m;\n            while((m >>= 1)) {\n              if (m_Coder.Get(mset.M[i])) {\n                sz |= m;\n              }\n            }\n          }\n          if (sign) {\n            v = -sz - 1;\n          } else {\n            v =  sz + 1;\n          }\n        } else {\n          v = 0;\n        }\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}", "target": 1}
{"code": "static int dr_domain_init_resources(struct mlx5dr_domain *dmn)\n{\n\tint ret;\n\tdmn->ste_ctx = mlx5dr_ste_get_ctx(dmn->info.caps.sw_format_ver);\n\tif (!dmn->ste_ctx) {\n\t\tmlx5dr_err(dmn, \"SW Steering on this device is unsupported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tret = mlx5_core_alloc_pd(dmn->mdev, &dmn->pdn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate PD, ret: %d\", ret);\n\t\treturn ret;\n\t}\n\tdmn->uar = mlx5_get_uars_page(dmn->mdev);\n\tif (!dmn->uar) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate UAR\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_pd;\n\t}\n\tdmn->ste_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_STE);\n\tif (!dmn->ste_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_uar;\n\t}\n\tdmn->action_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_MODIFY_ACTION);\n\tif (!dmn->action_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get action icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_ste_icm_pool;\n\t}\n\tret = mlx5dr_send_ring_alloc(dmn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't create send-ring\\n\");\n\t\tgoto free_action_icm_pool;\n\t}\n\treturn 0;\nfree_action_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->action_icm_pool);\nfree_ste_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->ste_icm_pool);\nclean_uar:\n\tmlx5_put_uars_page(dmn->mdev, dmn->uar);\nclean_pd:\n\tmlx5_core_dealloc_pd(dmn->mdev, dmn->pdn);\n\treturn ret;\n}", "target": 1}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n {\n \tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n \t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "void Item_ref::update_used_tables()\n{\n  if (!get_depended_from())\n    (*ref)->update_used_tables();\n}", "target": 0}
{"code": "void EditorClientBlackBerry::enableSpellChecking(bool enable)\n{\n    m_spellCheckState = enable ? SpellCheckDefault : SpellCheckOff;\n}", "target": 0}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}", "target": 1}
{"code": "        Header readHeader(BasicIo& io)\n        {\n            byte header[2];\n            io.read(header, 2);\n            ByteOrder byteOrder = invalidByteOrder;\n            if (header[0] == 'I' && header[1] == 'I')\n                byteOrder = littleEndian;\n            else if (header[0] == 'M' && header[1] == 'M')\n                byteOrder = bigEndian;\n            if (byteOrder == invalidByteOrder)\n                return Header();\n            byte version[2];\n            io.read(version, 2);\n            const uint16_t magic = getUShort(version, byteOrder);\n            if (magic != 0x2A && magic != 0x2B)\n                return Header();\n            Header result;\n            if (magic == 0x2A)\n            {\n                byte buffer[4];\n                io.read(buffer, 4);\n                const uint32_t offset = getULong(buffer, byteOrder);\n                result = Header(byteOrder, magic, 4, offset);\n            }\n            else\n            {\n                byte buffer[8];\n                io.read(buffer, 2);\n                const int size = getUShort(buffer, byteOrder);\n                assert(size == 8);\n                io.read(buffer, 2); \n                io.read(buffer, 8);\n                const uint64_t offset = getULongLong(buffer, byteOrder);\n                result = Header(byteOrder, magic, size, offset);\n            }\n            return result;\n        }", "target": 1}
{"code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n \tif (flags & (MSG_OOB))\n \t\treturn -EOPNOTSUPP;\n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n \t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n \t\treturn err;\n \t}\n\tmsg->msg_namelen = 0;\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0)\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "float ewk_view_device_pixel_ratio_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, -1.0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, -1.0);\n    return priv->settings.devicePixelRatio;\n}", "target": 0}
{"code": "incomplete_transaction_log(uschar *what)\n{\nif (sender_address == NULL ||                 \n    !LOGGING(smtp_incomplete_transaction))\n  return;\nif (recipients_count > 0)\n  {\n  int i;\n  raw_recipients = store_get(recipients_count * sizeof(uschar *));\n  for (i = 0; i < recipients_count; i++)\n    raw_recipients[i] = recipients_list[i].address;\n  raw_recipients_count = recipients_count;\n  }\nlog_write(L_smtp_incomplete_transaction, LOG_MAIN|LOG_SENDER|LOG_RECIPIENTS,\n  \"%s incomplete transaction (%s)\", host_and_ident(TRUE), what);\n}", "target": 0}
{"code": "bool Unpack::ProcessDecoded(UnpackThreadData &D)\n{\n  UnpackDecodedItem *Item=D.Decoded,*Border=D.Decoded+D.DecodedSize;\n  while (Item<Border)\n  {\n    UnpPtr&=MaxWinMask;\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_LZ_MATCH+3 && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }\n    if (Item->Type==UNPDT_LITERAL)\n    {\n#if defined(LITTLE_ENDIAN) && defined(ALLOW_MISALIGNED)\n      if (Item->Length==3 && UnpPtr<MaxWinSize-4)\n      {\n        *(uint32 *)(Window+UnpPtr)=*(uint32 *)Item->Literal;\n        UnpPtr+=4;\n      }\n      else\n#endif\n        for (uint I=0;I<=Item->Length;I++)\n          Window[UnpPtr++ & MaxWinMask]=Item->Literal[I];\n    }\n    else\n      if (Item->Type==UNPDT_MATCH)\n      {\n        InsertOldDist(Item->Distance);\n        LastLength=Item->Length;\n        CopyString(Item->Length,Item->Distance);\n      }\n      else\n        if (Item->Type==UNPDT_REP)\n        {\n          uint Distance=OldDist[Item->Distance];\n          for (uint I=Item->Distance;I>0;I--)\n            OldDist[I]=OldDist[I-1];\n          OldDist[0]=Distance;\n          LastLength=Item->Length;\n          CopyString(Item->Length,Distance);\n        }\n        else\n          if (Item->Type==UNPDT_FULLREP)\n          {\n            if (LastLength!=0)\n              CopyString(LastLength,OldDist[0]);\n          }\n          else\n            if (Item->Type==UNPDT_FILTER)\n            {\n              UnpackFilter Filter;\n              Filter.Type=(byte)Item->Length;\n              Filter.BlockStart=Item->Distance;\n              Item++;\n              Filter.Channels=(byte)Item->Length;\n              Filter.BlockLength=Item->Distance;\n              AddFilter(Filter);\n            }\n    Item++;\n  }\n  return true;\n}", "target": 1}
{"code": "static int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, int aligned)\n{\n\tint buffers = 0, error = 0;\n\tdown_read(&current->mm->mmap_sem);\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\t\terror = -EFAULT;\n\t\tif (copy_from_user_mmap_sem(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (unlikely(!base))\n\t\t\tbreak;\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > PIPE_BUFFERS - buffers)\n\t\t\tnpages = PIPE_BUFFERS - buffers;\n\t\terror = get_user_pages(current, current->mm,\n\t\t\t\t       (unsigned long) base, npages, 0, 0,\n\t\t\t\t       &pages[buffers], NULL);\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\t\tif (len)\n\t\t\tbreak;\n\t\tif (error < npages || buffers == PIPE_BUFFERS)\n\t\t\tbreak;\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\tup_read(&current->mm->mmap_sem);\n\tif (buffers)\n\t\treturn buffers;\n\treturn error;\n}", "target": 1}
{"code": "xsltFreeNamespaceMap(xsltNsMapPtr item)\n{\n    xsltNsMapPtr tmp;\n    while (item) {\n\ttmp = item;\n\titem = item->next;\n\txmlFree(tmp);\n    } \n    return;\n}", "target": 0}
{"code": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\tstrlcpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "ChannelSplitterNode* AudioContext::createChannelSplitter(size_t numberOfOutputs, ExceptionState& exceptionState)\n{\n    ASSERT(isMainThread());\n    ChannelSplitterNode* node = ChannelSplitterNode::create(this, m_destinationNode->sampleRate(), numberOfOutputs);\n    if (!node) {\n        exceptionState.throwDOMException(\n            IndexSizeError,\n            \"number of outputs (\" + String::number(numberOfOutputs)\n            + \") must be between 1 and \"\n            + String::number(AudioContext::maxNumberOfChannels()) + \".\");\n        return 0;\n    }\n    return node;\n}", "target": 0}
{"code": "static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n\tfl6.saddr = transport->saddr.v6.sin6_addr;\n\tfl6.flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n\telse\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tif (np->opt && np->opt->srcrt) {\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n\t\tfl6.daddr = *rt0->addr;\n\t}\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6.saddr, &fl6.daddr);\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->local_df = 1;\n\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n}", "target": 1}
{"code": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\treturn opt;\n}", "target": 1}
{"code": "R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_read (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}", "target": 1}
{"code": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\task->private = ctx;\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\tsk->sk_destruct = skcipher_sock_destruct;\n\treturn 0;\n}", "target": 1}
{"code": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n        if (rom->romsize > rom->datasize) {\n            d += l;\n            l = rom->romsize - rom->datasize;\n            if ((d + l) > (dest + size)) {\n                l = dest - d;\n            }\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n    return (d + l) - dest;\n}", "target": 1}
{"code": "rpki_rtr_print(netdissect_options *ndo, register const u_char *pptr, register u_int len)\n{\n    u_int tlen, pdu_type, pdu_len;\n    const u_char *tptr;\n    const rpki_rtr_pdu *pdu_header;\n    tptr = pptr;\n    tlen = len;\n    if (!ndo->ndo_vflag) {\n\tND_PRINT((ndo, \", RPKI-RTR\"));\n\treturn;\n    }\n    while (tlen >= sizeof(rpki_rtr_pdu)) {\n        ND_TCHECK2(*tptr, sizeof(rpki_rtr_pdu));\n\tpdu_header = (const rpki_rtr_pdu *)tptr;\n        pdu_type = pdu_header->pdu_type;\n        pdu_len = EXTRACT_32BITS(pdu_header->length);\n        ND_TCHECK2(*tptr, pdu_len);\n        if (!pdu_type || !pdu_len) {\n            break;\n        }\n        if (tlen < pdu_len) {\n            goto trunc;\n        }\n\tif (rpki_rtr_pdu_print(ndo, tptr, 8))\n\t\tgoto trunc;\n        tlen -= pdu_len;\n        tptr += pdu_len;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t%s\", tstr));\n}", "target": 1}
{"code": "  bool simulator_initialized() { return simulator_initialized_; }", "target": 0}
{"code": "QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n    if (!cipher.ok())\n        return cipherText;\n    if (direction)\n        temp2 = byteToB64(temp2);\n    return temp2;\n}", "target": 1}
{"code": "static apr_byte_t oidc_validate_post_logout_url(request_rec *r, const char *url,\n\t\tchar **err_str, char **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"Logout URL malformed: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tc_host = oidc_get_current_url_host(r);\n\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if (strstr(url, \"/\") != url) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "RenderViewImpl* RenderViewImpl::Create(\n    int32 opener_id,\n    const RendererPreferences& renderer_prefs,\n    const WebPreferences& webkit_prefs,\n    SharedRenderViewCounter* counter,\n    int32 routing_id,\n    int32 surface_id,\n    int64 session_storage_namespace_id,\n    const string16& frame_name,\n    bool is_renderer_created,\n    bool swapped_out,\n    int32 next_page_id,\n    const WebKit::WebScreenInfo& screen_info,\n    AccessibilityMode accessibility_mode) {\n  DCHECK(routing_id != MSG_ROUTING_NONE);\n  RenderViewImplParams params(\n      opener_id,\n      renderer_prefs,\n      webkit_prefs,\n      counter,\n      routing_id,\n      surface_id,\n      session_storage_namespace_id,\n      frame_name,\n      is_renderer_created,\n      swapped_out,\n      next_page_id,\n      screen_info,\n      accessibility_mode);\n  if (g_create_render_view_impl)\n    return g_create_render_view_impl(&params);\n  return new RenderViewImpl(&params);\n}", "target": 0}
{"code": "struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk;\n\tsctp_chunkhdr_t *ch = NULL;\n\tif ((chunk = queue->in_progress)) {\n\t\tif (chunk->singleton ||\n\t\t    chunk->end_of_packet ||\n\t\t    chunk->pdiscard) {\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tchunk = queue->in_progress = NULL;\n \t\t} else {\n \t\t\tch = (sctp_chunkhdr_t *) chunk->chunk_end;\n\t\t\tskb_pull(chunk->skb,\n\t\t\t\t chunk->chunk_end - chunk->skb->data);\n\t\t\tif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {\n\t\t\t\tsctp_chunk_free(chunk);\n\t\t\t\tchunk = queue->in_progress = NULL;\n\t\t\t}\n \t\t}\n \t}\n\tif (!chunk) {\n\t\tstruct list_head *entry;\n\t\tif (list_empty(&queue->in_chunk_list))\n\t\t\treturn NULL;\n\t\tentry = queue->in_chunk_list.next;\n\t\tchunk = queue->in_progress =\n\t\t\tlist_entry(entry, struct sctp_chunk, list);\n\t\tlist_del_init(entry);\n\t\tchunk->singleton = 1;\n\t\tch = (sctp_chunkhdr_t *) chunk->skb->data;\n\t\tchunk->data_accepted = 0;\n\t}\n\tchunk->chunk_hdr = ch;\n\tchunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\tif (unlikely(skb_is_nonlinear(chunk->skb))) {\n\t\tif (chunk->chunk_end > skb_tail_pointer(chunk->skb))\n\t\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\t}\n \tskb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));\n \tchunk->subh.v = NULL; \n\tif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {\n \t\tchunk->singleton = 0;\n \t} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\n\t\tsctp_chunk_free(chunk);\n\t\tchunk = queue->in_progress = NULL;\n\t\treturn NULL;\n \t} else {\n\t\tchunk->end_of_packet = 1;\n\t}\n\tpr_debug(\"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\n\",\n\t\t chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\n\t\t ntohs(chunk->chunk_hdr->length), chunk->skb->len);\n\treturn chunk;\n}", "target": 1}
{"code": "static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\nskipabs:\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\treturn mount_entry_on_generic(mntent, path);\n}", "target": 1}
{"code": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n \t}\n \thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n \thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n \tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tPK11_FreeSlot(hash_slot);\n\treturn 0;\n}", "target": 1}
{"code": "void HTMLSelectElement::restoreFormControlState(const FormControlState& state)\n{\n    recalcListItems();\n    const Vector<HTMLElement*>& items = listItems();\n    size_t itemsSize = items.size();\n    if (!itemsSize)\n        return;\n    for (size_t i = 0; i < itemsSize; ++i) {\n        if (!items[i]->hasLocalName(optionTag))\n            continue;\n        toHTMLOptionElement(items[i])->setSelectedState(false);\n    }\n    if (!multiple()) {\n        size_t foundIndex = searchOptionsForValue(state[0], 0, itemsSize);\n        if (foundIndex != kNotFound)\n            toHTMLOptionElement(items[foundIndex])->setSelectedState(true);\n    } else {\n        size_t startIndex = 0;\n        for (size_t i = 0; i < state.valueSize(); ++i) {\n            const String& value = state[i];\n            size_t foundIndex = searchOptionsForValue(value, startIndex, itemsSize);\n            if (foundIndex == kNotFound)\n                foundIndex = searchOptionsForValue(value, 0, startIndex);\n            if (foundIndex == kNotFound)\n                continue;\n            toHTMLOptionElement(items[foundIndex])->setSelectedState(true);\n            startIndex = foundIndex + 1;\n        }\n    }\n    setOptionsChangedOnRenderer();\n    setNeedsValidityCheck();\n}", "target": 0}
{"code": "__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n \tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n \tload_sp0(tss, next);\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n \tsavesegment(fs, fsindex);\n \tsavesegment(gs, gsindex);\n \tload_TLS(next, cpu);\n \tarch_end_context_switch(next_p);\n \tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n \t\tloadsegment(fs, next->fsindex);\n \t\tif (fsindex)\n \t\t\tprev->fs = 0;\n \t}\n \tif (next->fs)\n \t\twrmsrl(MSR_FS_BASE, next->fs);\n \tprev->fsindex = fsindex;\n \tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n \t\tload_gs_index(next->gsindex);\n \t\tif (gsindex)\n \t\t\tprev->gs = 0;\n \t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\tswitch_fpu_finish(next_p, fpu);\n\tprev->usersp = this_cpu_read(old_rsp);\n\tthis_cpu_write(old_rsp, next->usersp);\n\tthis_cpu_write(current_task, next_p);\n\ttask_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);\n\tthis_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);\n\tthis_cpu_write(kernel_stack,\n\t\t  (unsigned long)task_stack_page(next_p) +\n\t\t  THREAD_SIZE - KERNEL_STACK_OFFSET);\n\tif (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||\n\t\t     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))\n\t\t__switch_to_xtra(prev_p, next_p, tss);\n\treturn prev_p;\n}", "target": 1}
{"code": "chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              FALSE, 0, NULL, arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,\n                                          arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n    if (ret.code != KADM5_AUTH_CHANGEPW) {\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": " INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n     }\n     return;\n }", "target": 1}
{"code": "static void free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n}", "target": 0}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "void spl_array_iterator_key(zval *object, zval *return_value TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tHashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\tif (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {\n\t\treturn;\n\t}\n\tzend_hash_get_current_key_zval_ex(aht, return_value, &intern->pos);\n}", "target": 0}
{"code": "bool OmniboxViewWin::IsCommandIdChecked(int command_id) const {\n  return false;\n}", "target": 0}
{"code": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval; \n}", "target": 1}
{"code": "TEST(LtOp, MatchesNull) {\n    BSONObj operand = BSON(\"$lt\" << BSONNULL);\n    LTMatchExpression lt(\"a\", operand[\"$lt\"]);\n    ASSERT(!lt.matchesBSON(BSONObj(), NULL));\n    ASSERT(!lt.matchesBSON(BSON(\"a\" << BSONNULL), NULL));\n    ASSERT(!lt.matchesBSON(BSON(\"a\" << 4), NULL));\n    ASSERT(!lt.matchesBSON(BSON(\"b\" << 4), NULL));\n}", "target": 0}
{"code": "wsemul_sun_output_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint oargs;\n\tint rc;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4': \n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';':\t\t\n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\t\t\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > SUN_EMUL_NARGS)\n\t\t\tedp->nargs = SUN_EMUL_NARGS;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "Bool gf_isom_has_segment(GF_ISOFile *file, u32 *brand, u32 *version)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tGF_Box *a;\n\ti = 0;\n\twhile (NULL != (a = (GF_Box*)gf_list_enum(file->TopBoxes, &i))) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (a->type == GF_ISOM_BOX_TYPE_STYP) {\n\t\t\tGF_FileTypeBox *styp = (GF_FileTypeBox *)a;\n\t\t\t*brand = styp->majorBrand;\n\t\t\t*version = styp->minorVersion;\n\t\t\treturn GF_TRUE;\n\t\t}\n#endif\n\t}\n#endif\n\treturn GF_FALSE;\n}", "target": 0}
{"code": "int gru_handle_user_call_os(unsigned long cb)\n{\n\tstruct gru_tlb_fault_handle *tfh;\n\tstruct gru_thread_state *gts;\n\tvoid *cbk;\n\tint ucbnum, cbrnum, ret = -EINVAL;\n\tSTAT(call_os);\n\tucbnum = get_cb_number((void *)cb);\n\tif ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)\n\t\treturn -EINVAL;\n\tgts = gru_find_lock_gts(cb);\n\tif (!gts)\n\t\treturn -EINVAL;\n\tgru_dbg(grudev, \"address 0x%lx, gid %d, gts 0x%p\\n\", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);\n\tif (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)\n\t\tgoto exit;\n\tgru_check_context_placement(gts);\n\tif (gts->ts_gru && gts->ts_force_cch_reload) {\n\t\tgts->ts_force_cch_reload = 0;\n\t\tgru_update_cch(gts);\n\t}\n\tret = -EAGAIN;\n\tcbrnum = thread_cbr_number(gts, ucbnum);\n\tif (gts->ts_gru) {\n\t\ttfh = get_tfh_by_index(gts->ts_gru, cbrnum);\n\t\tcbk = get_gseg_base_address_cb(gts->ts_gru->gs_gru_base_vaddr,\n\t\t\t\tgts->ts_ctxnum, ucbnum);\n\t\tret = gru_user_dropin(gts, tfh, cbk);\n\t}\nexit:\n\tgru_unlock_gts(gts);\n\treturn ret;\n}", "target": 1}
{"code": "xfs_inode_free_callback(\n\tstruct rcu_head\t\t*head)\n{\n\tstruct inode\t\t*inode = container_of(head, struct inode, i_rcu);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tswitch (VFS_I(ip)->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t\tbreak;\n\t}\n\tif (ip->i_afp)\n\t\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tif (ip->i_cowfp)\n\t\txfs_idestroy_fork(ip, XFS_COW_FORK);\n\tif (ip->i_itemp) {\n\t\tASSERT(!(ip->i_itemp->ili_item.li_flags & XFS_LI_IN_AIL));\n\t\txfs_inode_item_destroy(ip);\n\t\tip->i_itemp = NULL;\n\t}\n\tkmem_zone_free(xfs_inode_zone, ip);\n}", "target": 0}
{"code": "bool GLSurfaceOzoneSurfacelessSurfaceImpl::OnMakeCurrent(GLContext* context) {\n  DCHECK(!context_ || context == context_);\n  context_ = context;\n  if (!fbo_) {\n    glGenFramebuffersEXT(1, &fbo_);\n    if (!fbo_)\n      return false;\n    glGenTextures(arraysize(textures_), textures_);\n    if (!CreatePixmaps())\n      return false;\n  }\n  BindFramebuffer();\n  glBindFramebufferEXT(GL_FRAMEBUFFER, fbo_);\n  return SurfacelessEGL::OnMakeCurrent(context);\n}", "target": 0}
{"code": "url_escape_allow_passthrough (const char *s)\n{\n  return url_escape_1 (s, urlchr_unsafe, true);\n}", "target": 0}
{"code": "parseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "js_Regexp *js_toregexp(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CREGEXP)\n\t\treturn &v->u.object->u.r;\n\tjs_typeerror(J, \"not a regexp\");\n}", "target": 0}
{"code": "int ecall_start(struct ecall *ecall, enum icall_call_type call_type,\n\t\tbool audio_cbr)\n{\n\tint err;\n\tinfo(\"ecall(%p): start\\n\", ecall);\n\tif (!ecall)\n\t\treturn EINVAL;\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\tif (ecall->econn) {\n\t\tif (ECONN_PENDING_INCOMING == econn_current_state(ecall->econn)) {\n\t\t\treturn ecall_answer(ecall, call_type, audio_cbr);\n\t\t}\n\t\telse {\n\t\t\twarning(\"ecall: start: already in progress (econn=%s)\\n\",\n\t\t\t\teconn_state_name(econn_current_state(ecall->econn)));\n\t\t\treturn EALREADY;\n\t\t}\n\t}\n#if 0\n\tif (ecall->turnc == 0) {\n\t\twarning(\"ecall: start: no TURN servers -- cannot start\\n\");\n\t\treturn EINTR;\n\t}\n#endif\n\tecall->call_type = call_type;\n\terr = ecall_create_econn(ecall);\n\tif (err) {\n\t\twarning(\"ecall: start: create_econn failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\teconn_set_state(ecall_get_econn(ecall), ECONN_PENDING_OUTGOING);\n\terr = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, audio_cbr);\n\tif (err) {\n\t\twarning(\"ecall: start: alloc_flow failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n\tif (ecall->props_local &&\n\t    (call_type == ICALL_CALL_TYPE_VIDEO\n\t     && ecall->vstate == ICALL_VIDEO_STATE_STARTED)) {\n\t\tconst char *vstate_string = \"true\";\n\t\tint err2 = econn_props_update(ecall->props_local,\n\t\t\t\t\t      \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t}\n\t}\n\tecall->sdp.async = ASYNC_NONE;\n\terr = generate_offer(ecall);\n\tif (err) {\n\t\twarning(\"ecall(%p): start: generate_offer\"\n\t\t\t\" failed (%m)\\n\", ecall, err);\n\t\tgoto out;\n\t}\n\tecall->ts_started = tmr_jiffies();\n\tecall->call_setup_time = -1;\n out:\n\treturn err;\n}", "target": 1}
{"code": "static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint dio_credits;\n\text4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\tcreate = EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\tmax_blocks = DIO_MAX_BLOCKS;\n\tdio_credits = ext4_chunk_trans_blocks(inode, max_blocks);\n\thandle = ext4_journal_start(inode, dio_credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,\n\t\t\t      create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\text4_journal_stop(handle);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\t*bounce_buf_ret = bounce_buf;\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}", "target": 1}
{"code": "copy_opt_map_info(OptMapInfo* to, OptMapInfo* from)\n{\n  *to = *from;\n}", "target": 0}
{"code": "void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}", "target": 1}
{"code": "\tvirtual void describe()\n\t{\n\t\tgetDefaultPCMMapping(m_outChunk->f.sampleWidth,\n\t\t\tm_outChunk->f.pcm.slope,\n\t\t\tm_outChunk->f.pcm.intercept,\n\t\t\tm_outChunk->f.pcm.minClip,\n\t\t\tm_outChunk->f.pcm.maxClip);\n\t}", "target": 0}
{"code": "process_colour_pointer_common(STREAM s, int bpp)\n{\n\tuint16 width, height, cache_idx, masklen, datalen;\n\tuint16 x, y;\n\tuint8 *mask;\n\tuint8 *data;\n\tRD_HCURSOR cursor;\n\tin_uint16_le(s, cache_idx);\n\tin_uint16_le(s, x);\n\tin_uint16_le(s, y);\n\tin_uint16_le(s, width);\n\tin_uint16_le(s, height);\n\tin_uint16_le(s, masklen);\n\tin_uint16_le(s, datalen);\n\tin_uint8p(s, data, datalen);\n\tin_uint8p(s, mask, masklen);\n\tif ((width != 32) || (height != 32))\n\t{\n\t\twarning(\"process_colour_pointer_common: \" \"width %d height %d\\n\", width, height);\n\t}\n\tx = MIN(x, width - 1);\n\ty = MIN(y, height - 1);\n\tcursor = ui_create_cursor(x, y, width, height, mask, data, bpp);\n\tui_set_cursor(cursor);\n\tcache_put_cursor(cache_idx, cursor);\n}", "target": 0}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "static inline bool tok_white(const Token *x)\n{\n    return tok_type(x, TOK_WHITESPACE);\n}", "target": 0}
{"code": "void gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\tif (!gdImageTrueColor(im)) {\n\t\tzend_error(E_ERROR, \"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\tif (quantization == -1) {\n \t\tquantization = 80;\n \t}\n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n \t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quantization, &out);\n\tif (out_size == 0) {\n\t\tzend_error(E_ERROR, \"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\nfreeargb:\n\tgdFree(argb);\n}", "target": 1}
{"code": "bool DataObjectItem::HasFileSystemId() const {\n  return kind_ == kFileKind && !file_system_id_.IsEmpty();\n}", "target": 0}
{"code": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "static void bnx2x_set_requested_fc(struct bnx2x *bp)\n{\n\tif (CHIP_IS_E1x(bp) && (bp->dev->mtu > 5000))\n\t\tbp->link_params.req_fc_auto_adv = BNX2X_FLOW_CTRL_TX;\n\telse\n\t\tbp->link_params.req_fc_auto_adv = BNX2X_FLOW_CTRL_BOTH;\n}", "target": 0}
{"code": "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void RegionIter_destructor(JNIEnv* env, jobject, jlong pairHandle)\n{\n RgnIterPair* pair = reinterpret_cast<RgnIterPair*>(pairHandle);\n SkASSERT(pair);\n delete pair;\n}", "target": 0}
{"code": "bool WebContents::SendIPCMessageToFrame(bool internal,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 );\n  return true;\n}", "target": 1}
{"code": "  template <Type type> static const RegistrationMap& headers() {\n    ASSERT(mutableFinalized<type>());\n    return mutableRegistrationMap<type>();\n  }", "target": 0}
{"code": "nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(1);\t\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\t*p++ = cpu_to_be32(1);\t\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}", "target": 1}
{"code": " static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi)\n {\n     opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n        for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n                pi->resno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n    return OPJ_FALSE;\n}", "target": 1}
{"code": "dhcpv4_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint8_t type, optlen;\n     i = 0;\n     while (i < length) {\n         tlv = cp + i;\n         type = (uint8_t)tlv[0];\n         optlen = (uint8_t)tlv[1];\n        value = tlv + 2;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n         ND_PRINT((ndo, \"%s\", tok2str(dh4opt_str, \"Unknown\", type)));\n         ND_PRINT((ndo,\" (%u)\", optlen + 2 ));\n         switch (type) {\n         case DH4OPT_DNS_SERVERS:\n        case DH4OPT_NTP_SERVERS: {\n            if (optlen < 4 || optlen % 4 != 0) {\n                return -1;\n            }\n            for (t = 0; t < optlen; t += 4)\n                ND_PRINT((ndo, \" %s\", ipaddr_string(ndo, value + t)));\n        }\n            break;\n        case DH4OPT_DOMAIN_SEARCH: {\n            const u_char *tp = value;\n            while (tp < value + optlen) {\n                ND_PRINT((ndo, \" \"));\n                if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                    return -1;\n            }\n        }\n            break;\n        }\n        i += 2 + optlen;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\tusb_msg.dlc = cf->len;\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\treturn NETDEV_TX_OK;\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "     **/\n    CImg<T>& min(const T& val) {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=65536))\n      cimg_rof(*this,ptrd,T) *ptrd = std::min(*ptrd,val);\n      return *this;", "target": 0}
{"code": "  cid_parse_font_matrix( CID_Face     face,\n                         CID_Parser*  parser )\n  {\n    CID_FaceDict  dict;\n    FT_Face       root = (FT_Face)&face->root;\n    FT_Fixed      temp[6];\n    FT_Fixed      temp_scale;\n    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n     {\n       FT_Matrix*  matrix;\n       FT_Vector*  offset;\n       dict   = face->cid.font_dicts + parser->num_dict;\n       matrix = &dict->font_matrix;\n       offset = &dict->font_offset;\n      (void)cid_parser_to_fixed_array( parser, 6, temp, 3 );\n       temp_scale = FT_ABS( temp[3] );\n        temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = 0x10000L;\n      }\n      matrix->xx = temp[0];\n      matrix->yx = temp[1];\n      matrix->xy = temp[2];\n      matrix->yy = temp[3];\n         temp[2] = FT_DivFix( temp[2], temp_scale );\n         temp[4] = FT_DivFix( temp[4], temp_scale );\n         temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = 0x10000L;\n       }", "target": 1}
{"code": "int FrameLoader::numPendingOrLoadingRequests(bool recurse) const\n{\n    if (!recurse)\n        return m_frame->document()->fetcher()->requestCount();\n    int count = 0;\n    for (Frame* frame = m_frame; frame; frame = frame->tree()->traverseNext(m_frame))\n        count += frame->document()->fetcher()->requestCount();\n    return count;\n}", "target": 0}
{"code": "static void default_local_infile_end(void *ptr)\n{\n  default_local_infile_data *data= (default_local_infile_data *) ptr;\n  if (data)\t\t\t\t\t\n  {\n    if (data->fd >= 0)\n      my_close(data->fd, MYF(MY_WME));\n    my_free(ptr);\n  }\n}", "target": 0}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}", "target": 1}
{"code": "static void free_segment_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_segments; i++) {\n        av_free(pls->segments[i]->key);\n        av_free(pls->segments[i]->url);\n        av_free(pls->segments[i]);\n    }\n    av_freep(&pls->segments);\n    pls->n_segments = 0;\n}", "target": 0}
{"code": "void FrameLoader::begin()\n{\n    begin(KURL());\n}", "target": 0}
{"code": "static inline cputime_t virt_ticks(struct task_struct *p)\n{\n\treturn p->utime;\n}", "target": 0}
{"code": "static RList* sections(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinSection* sect = NULL;\n\tpsxexe_header psxheader = {0};\n\tut64 sz = 0;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tif (!(sect = R_NEW0 (RBinSection))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"Truncated Header\\n\");\n\t\tfree (sect);\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tsz = r_buf_size (bf->buf);\n\tsect->name = strdup (\"TEXT\");\n\tsect->paddr = PSXEXE_TEXTSECTION_OFFSET;\n\tsect->size = sz - PSXEXE_TEXTSECTION_OFFSET;\n\tsect->vaddr = psxheader.t_addr;\n\tsect->vsize = psxheader.t_size;\n\tsect->perm = R_PERM_RX;\n\tsect->add = true;\n\tsect->has_strings = true;\n\tr_list_append (ret, sect);\n\treturn ret;\n}", "target": 1}
{"code": "Status FunctionLibraryDefinition::AddGradientDef(const GradientDef& grad) {\n  mutex_lock l(mu_);\n  bool added;\n  return AddGradientDefHelper(grad, &added);\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::OnClose() {\n  ShutdownAndDestroyWidget(true);\n}", "target": 0}
{"code": "void OmniboxViewWin::OnKillFocus(HWND focus_wnd) {\n  if (m_hWnd == focus_wnd) {\n    SetMsgHandled(false);\n    return;\n  }\n  model_->OnWillKillFocus(focus_wnd);\n  ClosePopup();\n  GetSelection(saved_selection_for_focus_change_);\n  model_->OnKillFocus();\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  DefWindowProc(WM_KILLFOCUS, reinterpret_cast<WPARAM>(focus_wnd), 0);\n  SelectAll(true);\n  PlaceCaretAt(0);\n}", "target": 0}
{"code": "int snd_ctl_remove(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tif (snd_BUG_ON(!card || !kcontrol))\n\t\treturn -EINVAL;\n\tlist_del(&kcontrol->list);\n\tcard->controls_count -= kcontrol->count;\n\tid = kcontrol->id;\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_REMOVE, &id);\n\tsnd_ctl_free_one(kcontrol);\n\treturn 0;\n}", "target": 0}
{"code": "void AverageEvalFloat(TfLiteContext* context, TfLiteNode* node,\n                      TfLitePoolParams* params, OpData* data,\n                      const TfLiteTensor* input, TfLiteTensor* output) {\n  float activation_min, activation_max;\n  CalculateActivationRange(params->activation, &activation_min,\n                           &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                       \\\n  tflite::PoolParams op_params;                                          \\\n  op_params.stride_height = params->stride_height;                       \\\n  op_params.stride_width = params->stride_width;                         \\\n  op_params.filter_height = params->filter_height;                       \\\n  op_params.filter_width = params->filter_width;                         \\\n  op_params.padding_values.height = data->padding.height;                \\\n  op_params.padding_values.width = data->padding.width;                  \\\n  op_params.float_activation_min = activation_min;                       \\\n  op_params.float_activation_max = activation_max;                       \\\n  type::AveragePool(op_params, GetTensorShape(input),                    \\\n                    GetTensorData<float>(input), GetTensorShape(output), \\\n                    GetTensorData<float>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "static void __sched notrace preempt_schedule_common(void)\n{\n\tdo {\n\t\tpreempt_disable_notrace();\n\t\t__schedule(true);\n\t\tpreempt_enable_no_resched_notrace();\n\t} while (need_resched());\n}", "target": 0}
{"code": "    TiffComponent* newNikon2Mn2(uint16_t tag,\n                                IfdId    group,\n                                IfdId    mnGroup)\n    {\n        return new TiffIfdMakernote(tag, group, mnGroup, new Nikon2MnHeader);\n    }", "target": 0}
{"code": "void gf_fs_print_non_connected(GF_FilterSession *fsess)\n{\n\tgf_fs_print_not_connected_filters(fsess, NULL, GF_FALSE);\n}", "target": 0}
{"code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\tbool success = true;\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\tfree(buffer);\n\treturn success;\n}", "target": 1}
{"code": "static void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n = s->node[node];\n\t\tif (n && n != &s->local_node)\n\t\t\tkmem_cache_free(kmalloc_caches, n);\n\t\ts->node[node] = NULL;\n\t}\n}", "target": 0}
{"code": "FILE *LightProcess::LightPopenImpl(const char *cmd, const char *type,\n                                   const char *cwd) {\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  fprintf(g_procs[id].m_fout, \"popen\\n%s\\n%s\\n%s\\n\", type, cmd, cwd);\n  fflush(g_procs[id].m_fout);\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  if (strncmp(buf, \"error\", 5) == 0) {\n    return nullptr;\n  }\n  int64_t fptr = 0;\n  read_buf(g_procs[id].m_fin, buf);\n  sscanf(buf, \"%\" PRId64, &fptr);\n  if (!fptr) {\n    Logger::Error(\"Light process failed to return the file pointer.\");\n    return nullptr;\n  }\n  int fd = recv_fd(g_procs[id].m_afdt_fd);\n  if (fd < 0) {\n    Logger::Error(\"Light process failed to send the file descriptor.\");\n    return nullptr;\n  }\n  FILE *f = fdopen(fd, type);\n  g_procs[id].m_popenMap[(int64_t)f] = fptr;\n  return f;\n}", "target": 1}
{"code": "mm_append_debug(Buffer *m)\n{\n\tif (auth_debug_init && buffer_len(&auth_debug)) {\n\t\tdebug3(\"%s: Appending debug messages for child\", __func__);\n\t\tbuffer_append(m, buffer_ptr(&auth_debug),\n\t\t    buffer_len(&auth_debug));\n\t\tbuffer_clear(&auth_debug);\n\t}\n}", "target": 0}
{"code": "int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n \tstruct scsi_device *SDev;\n \tstruct scsi_sense_hdr sshdr;\n \tint result, err = 0, retries = 0;\n \tSDev = cd->device;\n       retry:\n \tif (!scsi_block_when_processing_errors(SDev)) {\n \t\terr = -ENODEV;\n \t\tgoto out;\n \t}\n \tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen,\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n \t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n \tif (driver_byte(result) != 0) {\n \t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n      out:\n\tcgc->stat = err;\n\treturn err;\n}", "target": 1}
{"code": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\tif (posix_timer_event(timr, si_private)) {\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += (unsigned int)\n\t\t\t\thrtimer_forward(timer, now,\n\t\t\t\t\t\ttimr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\tunlock_timer(timr, flags);\n\treturn ret;\n}", "target": 1}
{"code": "bool fixpath_ro(Computer *comp, const std::string& path) {\n    std::vector<std::string> elems = split(path, \"/\\\\\");\n    std::list<std::string> pathc;\n    for (std::string s : elems) {\n        if (s == \"..\") { if (pathc.empty()) return false; else pathc.pop_back(); }\n        else if (!s.empty() && !std::all_of(s.begin(), s.end(), [](const char c)->bool{return c == '.';})) {\n            s = s.substr(s.find_first_not_of(' '), s.find_last_not_of(' ') - s.find_first_not_of(' ') + 1);\n            s.erase(std::remove_if(s.begin(), s.end(), [](char c)->bool{return c=='\"'||c==':'||c=='<'||c=='>'||c=='?'||c=='|';}), s.end());\n            pathc.push_back(s);\n        }\n    }\n    while (!pathc.empty() && pathc.front().empty()) pathc.pop_front();\n    if (!pathc.empty() && pathc.back().size() > 255) {\n        std::string s = pathc.back().substr(0, 255);\n        pathc.pop_back();\n        s = s.substr(0, s.find_last_not_of(' '));\n        pathc.push_back(s);\n    }\n    std::pair<size_t, bool> max_path = std::make_pair(0, false);\n    for (const auto& m : comp->mounts)\n        if (pathc.size() >= std::get<0>(m).size() && std::get<0>(m).size() > max_path.first && std::equal(std::get<0>(m).begin(), std::get<0>(m).end(), pathc.begin()))\n            max_path = std::make_pair(std::get<0>(m).size(), std::get<2>(m));\n    return max_path.second;\n}", "target": 1}
{"code": "bool SVGDocumentExtensions::isElementPendingResource(Element* element, const AtomicString& id) const\n{\n    ASSERT(element);\n    if (!hasPendingResource(id))\n        return false;\n    return m_pendingResources.get(id)->contains(element);\n}", "target": 0}
{"code": "static int IsNewline(int enc ARG_UNUSED, int c)\n{\n  if (c == 0x0a) return 1;\n  return 0;\n}", "target": 0}
{"code": "void RenderFrameHostImpl::ExecuteJavaScript(\n     const base::string16& javascript,\n     const JavaScriptResultCallback& callback) {\n  static int next_id = 1;\n  int key = next_id++;\n  Send(new FrameMsg_JavaScriptExecuteRequest(routing_id_,\n                                             javascript,\n                                             key, true));\n  javascript_callbacks_.insert(std::make_pair(key, callback));\n}", "target": 0}
{"code": " static void ehci_advance_state(EHCIState *ehci, int async)\n {\n     EHCIQueue *q = NULL;\n     int again;\n     do {\n        case EST_WAITLISTHEAD:\n            again = ehci_state_waitlisthead(ehci, async);\n            break;\n        case EST_FETCHENTRY:\n            again = ehci_state_fetchentry(ehci, async);\n            break;\n        case EST_FETCHQH:\n            q = ehci_state_fetchqh(ehci, async);\n            if (q != NULL) {\n                assert(q->async == async);\n                again = 1;\n            } else {\n                again = 0;\n            }\n            break;\n         case EST_FETCHITD:\n             again = ehci_state_fetchitd(ehci, async);\n             break;\n         case EST_FETCHSITD:\n             again = ehci_state_fetchsitd(ehci, async);\n             break;\n         case EST_ADVANCEQUEUE:\n        case EST_FETCHQTD:\n            assert(q != NULL);\n            again = ehci_state_fetchqtd(q);\n            break;\n        case EST_HORIZONTALQH:\n            assert(q != NULL);\n            again = ehci_state_horizqh(q);\n            break;\n        case EST_EXECUTE:\n            assert(q != NULL);\n            again = ehci_state_execute(q);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            break;\n        case EST_EXECUTING:\n            assert(q != NULL);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            again = ehci_state_executing(q);\n            break;\n        case EST_WRITEBACK:\n            assert(q != NULL);\n            again = ehci_state_writeback(q);\n            if (!async) {\n                ehci->periodic_sched_active = PERIODIC_ACTIVE;\n            }\n            break;\n        default:\n            fprintf(stderr, \"Bad state!\\n\");\n            again = -1;\n            g_assert_not_reached();\n            break;\n        }\n             break;\n         }", "target": 1}
{"code": "GF_Err iSFM_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ISMASampleFormatBox *ptr = (GF_ISMASampleFormatBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->selective_encryption = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 7);\n\tptr->key_indicator_length = gf_bs_read_u8(bs);\n\tptr->IV_length = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart = 0, nend = 0; \n    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1),\n        *end = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_Obj *obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (n == 0) {\n        goto bail;\n    }\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto bail;\n    int i;\n    for (i = istart; i <= iend; i++)\n    {\n        if (obj->arr[i])\n            Jsi_ValueCopy(interp, obj->arr[i], value);\n        else\n            obj->arr[i] = Jsi_ValueDup(interp, value);\n    }\nbail:\n    if (_this != *ret) {\n        Jsi_ValueMove(interp, *ret, _this);\n    }\n    return rc;\n}", "target": 1}
{"code": "enum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method)\n{\n  char ibuf[LONG_STRING * 2], obuf[LONG_STRING];\n  unsigned char hmac_response[MD5_DIGEST_LEN];\n  int len;\n  int rc;\n  if (!mutt_bit_isset(idata->capabilities, ACRAM_MD5))\n    return IMAP_AUTH_UNAVAIL;\n  mutt_message(_(\"Authenticating (CRAM-MD5)...\"));\n  if (mutt_account_getlogin(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  imap_cmd_start(idata, \"AUTHENTICATE CRAM-MD5\");\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"Invalid response from server: %s\\n\", ibuf);\n    goto bail;\n  }\n  len = mutt_b64_decode(obuf, idata->buf + 2);\n  if (len == -1)\n  {\n    mutt_debug(1, \"Error decoding base64 response.\\n\");\n    goto bail;\n  }\n  obuf[len] = '\\0';\n  mutt_debug(2, \"CRAM challenge: %s\\n\", obuf);\n  hmac_md5(idata->conn->account.pass, obuf, hmac_response);\n  int off = snprintf(obuf, sizeof(obuf), \"%s \", idata->conn->account.user);\n  mutt_md5_toascii(hmac_response, obuf + off);\n  mutt_debug(2, \"CRAM response: %s\\n\", obuf);\n  mutt_b64_encode(ibuf, obuf, strlen(obuf), sizeof(ibuf) - 2);\n  mutt_str_strcat(ibuf, sizeof(ibuf), \"\\r\\n\");\n  mutt_socket_send(idata->conn, ibuf);\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  if (rc != IMAP_CMD_OK)\n  {\n    mutt_debug(1, \"Error receiving server response.\\n\");\n    goto bail;\n  }\n  if (imap_code(idata->buf))\n    return IMAP_AUTH_SUCCESS;\nbail:\n  mutt_error(_(\"CRAM-MD5 authentication failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 1}
{"code": "static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)\n{\n    int sig_nid, use_pc_sigalgs = 0;\n    size_t i;\n    const SIGALG_LOOKUP *sigalg;\n    size_t sigalgslen;\n    if (default_nid == -1)\n        return 1;\n    sig_nid = X509_get_signature_nid(x);\n    if (default_nid)\n        return sig_nid == default_nid ? 1 : 0;\n    if (SSL_IS_TLS13(s) && s->s3.tmp.peer_cert_sigalgs != NULL) {\n        sigalgslen = s->s3.tmp.peer_cert_sigalgslen;\n        use_pc_sigalgs = 1;\n    } else {\n        sigalgslen = s->shared_sigalgslen;\n    }\n    for (i = 0; i < sigalgslen; i++) {\n        sigalg = use_pc_sigalgs\n                 ? tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i])\n                 : s->shared_sigalgs[i];\n        if (sig_nid == sigalg->sigandhash)\n            return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "SPL_METHOD(Array, offsetUnset)\n{\n\tzval *index;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &index) == FAILURE) {\n\t\treturn;\n\t}\n\tspl_array_unset_dimension_ex(0, getThis(), index TSRMLS_CC);\n} ", "target": 0}
{"code": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}", "target": 1}
{"code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint i, j, ret;\n\tunsigned char count;\n\tif(flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 2;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\tif((scd->curbit + code_size) >= scd->lastbit) {\n\t\tif(scd->done) {\n\t\t\tif(scd->curbit >= scd->lastbit) {\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tscd->buf[0] = scd->buf[scd->last_byte - 2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte - 1];\n\t\tif((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {\n\t\t\tscd->done = TRUE;\n\t\t}\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2 + count) * 8;\n\t}\n\tif ((scd->curbit + code_size - 1) >= (CSD_BUF_SIZE * 8)) {\n\t\tret = -1;\n\t} else {\n\t\tret = 0;\n\t\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n\t\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t\t}\n\t}\n\tscd->curbit += code_size;\n\treturn ret;\n}", "target": 1}
{"code": "void OmniboxViewWin::GetSelection(CHARRANGE& sel) const {\n  GetSel(sel);\n  ITextDocument* const text_object_model = GetTextObjectModel();\n  if (!text_object_model)\n    return;\n  base::win::ScopedComPtr<ITextSelection> selection;\n  const HRESULT hr = text_object_model->GetSelection(selection.Receive());\n  DCHECK_EQ(S_OK, hr);\n  long flags;\n  selection->GetFlags(&flags);\n  if (flags & tomSelStartActive)\n    std::swap(sel.cpMin, sel.cpMax);\n}", "target": 0}
{"code": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkzfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "test_read_integer_error (xd3_stream *stream, usize_t trunto, const char *msg)\n{\n  uint64_t eval = 1ULL << 34;\n  uint32_t rval;\n  xd3_output *buf = NULL;\n  const uint8_t *max;\n  const uint8_t *inp;\n  int ret;\n  buf = xd3_alloc_output (stream, buf);\n  if ((ret = xd3_emit_uint64_t (stream, & buf, eval)))\n    {\n      goto fail;\n    }\n again:\n  inp = buf->base;\n  max = buf->base + buf->next - trunto;\n  if ((ret = xd3_read_uint32_t (stream, & inp, max, & rval)) != \n      XD3_INVALID_INPUT ||\n      !MSG_IS (msg))\n    {\n      ret = XD3_INTERNAL;\n    }\n  else if (trunto && trunto < buf->next)\n    {\n      trunto += 1;\n      goto again;\n    }\n  else\n    {\n      ret = 0;\n    }\n fail:\n  xd3_free_output (stream, buf);\n  return ret;\n}", "target": 1}
{"code": "_warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)\n{\n\tstruct warc_s *w = a->format->data;\n\tconst char *rab;\n\tssize_t nrd;\n\tif (w->cntoff >= w->cntlen) {\n\teof:\n\t\t*buf = NULL;\n\t\t*bsz = 0U;\n\t\t*off = w->cntoff + 4U;\n\t\tw->unconsumed = 0U;\n \t\treturn (ARCHIVE_EOF);\n \t}\n \trab = __archive_read_ahead(a, 1U, &nrd);\n \tif (nrd < 0) {\n \t\t*bsz = 0U;\n\t\treturn (int)nrd;\n\t} else if (nrd == 0) {\n\t\tgoto eof;\n\t} else if ((size_t)nrd > w->cntlen - w->cntoff) {\n\t\tnrd = w->cntlen - w->cntoff;\n\t}\n\t*off = w->cntoff;\n\t*bsz = nrd;\n\t*buf = rab;\n\tw->cntoff += nrd;\n\tw->unconsumed = (size_t)nrd;\n\treturn (ARCHIVE_OK);\n}", "target": 1}
{"code": "Extension::State ExtensionPrefs::GetExtensionState(\n    const std::string& extension_id) const {\n  const DictionaryValue* extension = GetExtensionPref(extension_id);\n  if (!extension)\n    return Extension::ENABLED;\n  int state = -1;\n  if (!extension->GetInteger(kPrefState, &state) ||\n      state < 0 || state >= Extension::NUM_STATES) {\n    LOG(ERROR) << \"Bad or missing pref 'state' for extension '\"\n               << extension_id << \"'\";\n    return Extension::ENABLED;\n  }\n  return static_cast<Extension::State>(state);\n}", "target": 0}
{"code": "static bool on_accept(private_stroke_socket_t *this, stream_t *stream)\n{\n\tstroke_msg_t *msg;\n\tuint16_t len;\n\tFILE *out;\n\tif (!stream->read_all(stream, &len, sizeof(len)))\n\t{\n\t\tif (errno != EWOULDBLOCK)\n\t\t{\n\t\t\tDBG1(DBG_CFG, \"reading length of stroke message failed: %s\",\n\t\t\t\t strerror(errno));\n                }\n                return FALSE;\n        }\n        msg = malloc(len + 1);\n\t\t\tDBG1(DBG_CFG, \"reading stroke message failed: %s\", strerror(errno));\n\t\t}", "target": 1}
{"code": "  friend bool operator==(const TensorKey& t1, const TensorKey& t2) {\n    if (t1.dtype() != t2.dtype() || t1.shape() != t2.shape()) {\n      return false;\n    }\n    if (DataTypeCanUseMemcpy(t1.dtype())) {\n      return t1.tensor_data() == t2.tensor_data();\n    }\n    if (t1.dtype() == DT_STRING) {\n      const auto s1 = t1.unaligned_flat<tstring>();\n      const auto s2 = t2.unaligned_flat<tstring>();\n      for (int64_t i = 0, n = t1.NumElements(); i < n; ++i) {\n        if (TF_PREDICT_FALSE(s1(i) != s2(i))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "target": 1}
{"code": "void ConnectDialogEdit::on_qbFill_clicked() {\n\tQ_ASSERT(m_si);\n\tqwInlineNotice->hide();\n\tadjustSize();\n\tqleName->setText(m_si->qsName);\n\tqleServer->setText(m_si->qsHostname);\n\tqleUsername->setText(m_si->qsUsername);\n\tqlePort->setText(QString::number(m_si->usPort));\n\tqlePassword->setText(m_si->qsPassword);\n\tdelete m_si;\n\tm_si = NULL;\n}", "target": 0}
{"code": "blkcpy(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = S[i];\n}", "target": 1}
{"code": "String StringUtil::Implode(const Variant& items, const String& delim,\n                           const bool checkIsContainer ) {\n  if (checkIsContainer && !isContainer(items)) {\n    throw_param_is_not_container();\n  }\n  int size = getContainerSize(items);\n  if (size == 0) return empty_string();\n  req::vector<String> sitems;\n  sitems.reserve(size);\n  int len = 0;\n  int lenDelim = delim.size();\n  for (ArrayIter iter(items); iter; ++iter) {\n    sitems.emplace_back(iter.second().toString());\n    len += sitems.back().size() + lenDelim;\n  }\n  len -= lenDelim; \n  assert(sitems.size() == size);\n  String s = String(len, ReserveString);\n  char *buffer = s.mutableData();\n  const char *sdelim = delim.data();\n  char *p = buffer;\n  String &init_str = sitems[0];\n  int init_len = init_str.size();\n  memcpy(p, init_str.data(), init_len);\n  p += init_len;\n  for (int i = 1; i < size; i++) {\n    String &item = sitems[i];\n    memcpy(p, sdelim, lenDelim);\n    p += lenDelim;\n    int lenItem = item.size();\n    memcpy(p, item.data(), lenItem);\n    p += lenItem;\n  }\n  assert(p - buffer == len);\n  s.setSize(len);\n  return s;\n}", "target": 1}
{"code": "FileInformation ImageReadJPEG(\n      Image& out,\n      String const& filename\n) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   int nchan = jpeg.cinfo().num_components;\n   jpeg.cinfo().out_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   out.ReForge( info.sizes, info.tensorElements, DT_UINT8, Option::AcceptDataTypeChange::DONT_ALLOW );\n   out.SetPixelSize( info.pixelSize );\n   out.SetColorSpace( info.colorSpace );\n   jpeg_start_decompress( jpeg.cinfoptr() );\n   std::vector< JSAMPLE > buffer( info.sizes[ 0 ] * static_cast< unsigned >( nchan )); \n   dip::uint8* imagedata = static_cast< dip::uint8* >( out.Origin() );\n   auto stride = out.Strides();\n   auto tStride = out.TensorStride();\n   for( dip::uint ii = 0; ii < info.sizes[ 1 ]; ++ii ) {\n      JSAMPLE* indata = buffer.data();\n      jpeg_read_scanlines( jpeg.cinfoptr(), &indata, 1 );\n      dip::uint8* outdata = imagedata;\n      if( nchan > 1 ) {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            for( int kk = 0; kk < nchan; ++kk ) {\n               *( outdata + kk * tStride ) = *indata;\n               ++indata;\n            }\n            outdata += stride[ 0 ];\n         }\n      } else {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            *outdata = *indata;\n            ++indata;\n            outdata += stride[ 0 ];\n         }\n      }\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_decompress( jpeg.cinfoptr() );\n   return info;\n}", "target": 1}
{"code": "    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        if(len < 1)\n        {\n            return alloc;\n        }\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n        if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n        alloc = std::string(attr_vals);\n        return alloc;\n    }", "target": 1}
{"code": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       n * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int tsize = pipe->ring_size - t;\n\t\t\tif (h > 0)\n\t\t\t\tmemcpy(bufs + tsize, pipe->bufs,\n\t\t\t\t       h * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       tsize * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\thead = n;\n\ttail = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}", "target": 1}
{"code": "static char* guess_timezone(const timelib_tzdb *tzdb TSRMLS_DC)\n{\n\tif (DATEG(timezone) && (strlen(DATEG(timezone))) > 0) {\n\t\treturn DATEG(timezone);\n\t}\n\tif (!DATEG(default_timezone)) {\n\t\tzval ztz;\n\t\tif (SUCCESS == zend_get_configuration_directive(\"date.timezone\", sizeof(\"date.timezone\"), &ztz)\n\t\t\t&& Z_TYPE(ztz) == IS_STRING && Z_STRLEN(ztz) > 0 && timelib_timezone_id_is_valid(Z_STRVAL(ztz), tzdb)) {\n\t\t\treturn Z_STRVAL(ztz);\n\t\t}\n\t} else if (*DATEG(default_timezone)) {\n\t\tif (DATEG(timezone_valid) == 1) {\n\t\t\treturn DATEG(default_timezone);\n\t\t}\n\t\tif (!timelib_timezone_id_is_valid(DATEG(default_timezone), tzdb)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid date.timezone value '%s', we selected the timezone 'UTC' for now.\", DATEG(default_timezone));\n\t\t\treturn \"UTC\";\n\t\t}\n\t\tDATEG(timezone_valid) = 1;\n\t\treturn DATEG(default_timezone);\n\t}\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, DATE_TZ_ERRMSG \"We selected the timezone 'UTC' for now, but please set date.timezone to select your timezone.\");\n\treturn \"UTC\";", "target": 0}
{"code": "static void vvc_parse_general_timing_hrd_parameters(GF_BitStream *bs, VVC_SPS *sps, VVC_VPS *vps, Bool *general_nal_hrd_params_present_flag, Bool *general_vcl_hrd_params_present_flag, Bool *general_du_hrd_params_present_flag, u32 *hrd_cpb_cnt_minus1)\n{\n\tsps->has_timing_info = 1;\n\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"timescale\");\n\t*general_du_hrd_params_present_flag = GF_FALSE;\n\t*general_nal_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_nal_hrd_params_present_flag\");\n\t*general_vcl_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_vcl_hrd_params_present_flag\");\n\tif (*general_nal_hrd_params_present_flag || *general_vcl_hrd_params_present_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"general_same_pic_timing_in_all_ols_flag\");\n\t\t*general_du_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_du_hrd_params_present_flag\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 8, \"tick_divisor_minus2\");\n\t\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_du_scale\");\n\t\t*hrd_cpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"hrd_cpb_cnt_minus1\");\n\t}\n}", "target": 0}
{"code": "moveToFreeBindingList(XML_Parser parser, BINDING *bindings) {\n  while (bindings) {\n    BINDING *b = bindings;\n    bindings = bindings->nextTagBinding;\n    b->nextTagBinding = parser->m_freeBindingList;\n    parser->m_freeBindingList = b;\n  }\n}", "target": 0}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\terror = git_stream_connect(t->io);\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n \tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n \t    git_stream_is_encrypted(t->io)) {\n \t\tgit_cert *cert;\n\t\tint is_valid;\n \t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n \t\t\treturn error;\n \t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n \t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n \t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int irda_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\treturn -ENOIOCTLCMD;\n}", "target": 0}
{"code": "static int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}", "target": 0}
{"code": "static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)\n{\n\tunsigned int i;\n\tstruct hash_cell *hc;\n\tsize_t len, needed = 0;\n\tstruct gendisk *disk;\n\tstruct dm_name_list *orig_nl, *nl, *old_nl = NULL;\n\tuint32_t *event_nr;\n\tdown_write(&_hash_lock);\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tneeded += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);\n\t\t\tneeded += align_val(sizeof(uint32_t));\n\t\t}\n\t}\n\tnl = orig_nl = get_result_buffer(param, param_size, &len);\n\tif (len < needed) {\n\t\tparam->flags |= DM_BUFFER_FULL_FLAG;\n\t\tgoto out;\n\t}\n\tparam->data_size = param->data_start + needed;\n\tnl->dev = 0;\t\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tif (old_nl)\n\t\t\t\told_nl->next = (uint32_t) ((void *) nl -\n\t\t\t\t\t\t\t   (void *) old_nl);\n\t\t\tdisk = dm_disk(hc->md);\n\t\t\tnl->dev = huge_encode_dev(disk_devt(disk));\n\t\t\tnl->next = 0;\n\t\t\tstrcpy(nl->name, hc->name);\n\t\t\told_nl = nl;\n\t\t\tevent_nr = align_ptr(nl->name + strlen(hc->name) + 1);\n\t\t\t*event_nr = dm_get_event_nr(hc->md);\n\t\t\tnl = align_ptr(event_nr + 1);\n\t\t}\n\t}\n\tBUG_ON((char *)nl - (char *)orig_nl != needed);\n out:\n\tup_write(&_hash_lock);\n\treturn 0;\n}", "target": 1}
{"code": "double JOIN::get_examined_rows()\n{\n  double examined_rows;\n  double prev_fanout= 1;\n  double records;\n  JOIN_TAB *tab= first_breadth_first_tab();\n  JOIN_TAB *prev_tab= tab;\n  records= (double)tab->get_examined_rows();\n  while ((tab= next_breadth_first_tab(first_breadth_first_tab(),\n                                      top_join_tab_count, tab)))\n  {\n    prev_fanout= COST_MULT(prev_fanout, prev_tab->records_read);\n    records=\n      COST_ADD(records,\n               COST_MULT((double) (tab->get_examined_rows()), prev_fanout));\n    prev_tab= tab;\n  }\n  examined_rows= (double)\n    (records > (double) HA_ROWS_MAX ? HA_ROWS_MAX : (ha_rows) records);\n  return examined_rows;\n}", "target": 0}
{"code": "size_t Parcel::getOpenAshmemSize() const\n{\n return mOpenAshmemSize;\n}", "target": 0}
{"code": "bool WebContentsImpl::IsActiveEntry(int32 page_id) {\n  NavigationEntryImpl* active_entry =\n      NavigationEntryImpl::FromNavigationEntry(controller_.GetActiveEntry());\n  return (active_entry != NULL &&\n          active_entry->site_instance() == GetSiteInstance() &&\n          active_entry->GetPageID() == page_id);\n}", "target": 0}
{"code": "static void load_creator_from_buf(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size)\n{\n    int   is_xml;\n    char *c;\n    if (!buf)\n      return;\n    if ((c = strstr(buf, \"/Type\")))\n      while (*c && !isspace(*c))\n        ++c;\n    is_xml = 0;\n    if (c && (*c == 'M'))\n      is_xml = 1;\n    if (is_xml)\n      load_creator_from_xml(xref, buf);\n    else\n      load_creator_from_old_format(fp, xref, buf, buf_size);\n}", "target": 0}
{"code": "void* leak_memalign(size_t alignment, size_t bytes)\n{\n    if (alignment <= MALLOC_ALIGNMENT)\n        return leak_malloc(bytes);\n    if (alignment & (alignment-1))\n        alignment = 1L << (31 - __builtin_clz(alignment));\n    size_t size = (alignment-MALLOC_ALIGNMENT) + bytes;\n    void* base = leak_malloc(size);\n    if (base != NULL) {\n        intptr_t ptr = (intptr_t)base;\n        if ((ptr % alignment) == 0)\n            return base;\n        ptr += ((-ptr) % alignment);\n        ((void**)ptr)[-1] = MEMALIGN_GUARD;\n        ((void**)ptr)[-2] = base;\n        return (void*)ptr;\n    }\n    return base;\n}", "target": 1}
{"code": "static void mptsas_soft_reset(MPTSASState *s)\n{\n    uint32_t save_mask;\n    trace_mptsas_reset(s);\n    save_mask = s->intr_mask;\n    s->intr_mask = MPI_HIM_DIM | MPI_HIM_RIM;\n    mptsas_update_interrupt(s);\n    qbus_reset_all(BUS(&s->bus));\n    s->intr_status = 0;\n    s->intr_mask = save_mask;\n    s->reply_free_tail = 0;\n    s->reply_free_head = 0;\n    s->reply_post_tail = 0;\n    s->reply_post_head = 0;\n    s->request_post_tail = 0;\n    s->request_post_head = 0;\n    qemu_bh_cancel(s->request_bh);\n    s->state = MPI_IOC_STATE_READY;\n}", "target": 0}
{"code": "int Item::save_time_in_field(Field *field)\n{\n  MYSQL_TIME ltime;\n  if (get_time(&ltime))\n    return set_field_to_null_with_conversions(field, 0);\n  field->set_notnull();\n  return field->store_time_dec(&ltime, decimals);\n}", "target": 0}
{"code": "static void init_vmcs_shadow_fields(void)\n{\n\tint i, j;\n\tfor (i = j = 0; i < max_shadow_read_write_fields; i++) {\n\t\tswitch (shadow_read_write_fields[i]) {\n\t\tcase GUEST_BNDCFGS:\n\t\t\tif (!vmx_mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (j < i)\n\t\t\tshadow_read_write_fields[j] =\n\t\t\t\tshadow_read_write_fields[i];\n\t\tj++;\n\t}\n\tmax_shadow_read_write_fields = j;\n\tfor (i = 0; i < max_shadow_read_write_fields; i++) {\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmwrite_bitmap);\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n\t}\n\tfor (i = 0; i < max_shadow_read_only_fields; i++)\n\t\tclear_bit(shadow_read_only_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n}", "target": 0}
{"code": "SYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}", "target": 1}
{"code": "int compat_dccp_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int optlen)\n{\n\tif (level != SOL_DCCP)\n\t\treturn inet_csk_compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t  optval, optlen);\n\treturn do_dccp_setsockopt(sk, level, optname, optval, optlen);\n}", "target": 0}
{"code": "static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n{\n    CURLState *s = ((CURLState*)opaque);\n    size_t realsize = size * nmemb;\n    int i;\n    DPRINTF(\"CURL: Just reading %zd bytes\\n\", realsize);\n    if (!s || !s->orig_buf)\n        goto read_end;\n    memcpy(s->orig_buf + s->buf_off, ptr, realsize);\n    s->buf_off += realsize;\n    for(i=0; i<CURL_NUM_ACB; i++) {\n        CURLAIOCB *acb = s->acb[i];\n        if (!acb)\n            continue;\n        if ((s->buf_off >= acb->end)) {\n            qemu_iovec_from_buf(acb->qiov, 0, s->orig_buf + acb->start,\n                                acb->end - acb->start);\n            acb->common.cb(acb->common.opaque, 0);\n            qemu_aio_release(acb);\n            s->acb[i] = NULL;\n        }\n    }\nread_end:\n    return realsize;\n}", "target": 1}
{"code": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\tif (!addr)\n\t\treturn -ENODEV;\n\tio->io_cleanup = port_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void preempt_notifier_dec(void)\n{\n\tstatic_key_slow_dec(&preempt_notifier_key);\n}", "target": 0}
{"code": "PHP_METHOD(snmp, set)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, SNMP_CMD_SET, (-1));\n}", "target": 0}
{"code": "void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) \n{\n  if(recurs > 1000) \n    throw MOADNSException(\"Loop\");\n  int pos = frompos;\n  for(;;) {\n    unsigned char labellen=content.at(frompos++);\n    if(!labellen) {\n      if(ret.empty())\n              ret.append(1,'.');\n      break;\n    }\n    else if((labellen & 0xc0) == 0xc0) {\n      uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);\n      if(offset >= pos-2)\n        throw MOADNSException(\"forward reference during label decompression\");\n      return getLabelFromContent(content, offset, ret, ++recurs);\n    }\n    else if(labellen > 63) \n      throw MOADNSException(\"Overly long label during label decompression (\"+lexical_cast<string>((unsigned int)labellen)+\")\");\n    else {\n      for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {\n        if(content.at(frompos)=='.' || content.at(frompos)=='\\\\') {\n          ret.append(1, '\\\\');\n          ret.append(1, content[frompos]);\n        }\n        else if(content.at(frompos)==' ') {\n          ret+=\"\\\\032\";\n        }\n        else \n          ret.append(1, content[frompos]);\n      }\n      ret.append(1,'.');\n    }\n  }\n}", "target": 1}
{"code": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif \n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif \n\t\tcap->device_caps = cap->capabilities = capabilities;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}", "target": 1}
{"code": "void ConnectDialog::on_qtwServers_customContextMenuRequested(const QPoint &mpos) {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->itemAt(mpos));\n\tqmPopup->clear();\n\tif (si != NULL && si->bParent) {\n\t\tsi = NULL;\n\t}\n\tif (si != NULL) {\n\t\tif (!g.s.disableConnectDialogEditing) {\n\t\t\tif (si->itType == ServerItem::FavoriteType) {\n\t\t\t\tqmPopup->addAction(qaFavoriteEdit);\n\t\t\t\tqmPopup->addAction(qaFavoriteRemove);\n\t\t\t} else {\n\t\t\t\tqmPopup->addAction(qaFavoriteAdd);\n\t\t\t}\n\t\t}\n\t\tif (!si->qsUrl.isEmpty()) {\n\t\t\tqmPopup->addAction(qaUrl);\n\t\t}\n\t}\n\tif (! qmPopup->isEmpty()) {\n\t\tqmPopup->addSeparator();\n\t}\n\tqmPopup->addMenu(qmFilters);\n\tqmPopup->popup(qtwServers->viewport()->mapToGlobal(mpos), NULL);\n}", "target": 0}
{"code": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n \tdentry = fhp->fh_dentry;\n \tinode = d_inode(dentry);\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n \tif (S_ISDIR(inode->i_mode))\n \t\tflags = NFS4_ACL_DIR;\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n \tif (host_error < 0)\n \t\tgoto out_nfserr;\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n \tif (host_error < 0)\n\t\tgoto out_release;\n \tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n \t}\nout_release:\n \tposix_acl_release(pacl);\n \tposix_acl_release(dpacl);\n out_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}", "target": 1}
{"code": "static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\t    struct msghdr *msg, size_t len, int noblock,\n\t\t\t    int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\tsock_recv_timestamp(msg, sk, skb);\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n \t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n \t\tlsa->l2tp_flowinfo = 0;\n \t\tlsa->l2tp_scope_id = 0;\n \t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n \t\t\tlsa->l2tp_scope_id = IP6CB(skb)->iif;\n \t}\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}", "target": 1}
{"code": "vte_sequence_handler_ho (VteTerminal *terminal, GValueArray *params)\n{\n\t_vte_terminal_home_cursor (terminal);\n}", "target": 0}
{"code": "void HTMLSelectElement::dispatchFocusEvent(Element* oldFocusedElement, FocusDirection direction)\n{\n    if (usesMenuList())\n        saveLastSelection();\n    HTMLFormControlElementWithState::dispatchFocusEvent(oldFocusedElement, direction);\n}", "target": 0}
{"code": "fbFetchPixel_a1b1g1r1 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32  pixel = Fetch4(bits, offset);\n    CARD32  a,r,g,b;\n    a = ((pixel & 0x8) * 0xff) << 21;\n    r = ((pixel & 0x4) * 0xff) >> 3;\n    g = ((pixel & 0x2) * 0xff) << 7;\n    b = ((pixel & 0x1) * 0xff) << 16;\n    return a|r|g|b;\n}", "target": 0}
{"code": "void SyncManager::SyncInternal::ShutdownOnSyncThread() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  weak_ptr_factory_.InvalidateWeakPtrs();\n  js_mutation_event_observer_.InvalidateWeakPtrs();\n  scheduler_.reset();\n  SetJsEventHandler(WeakHandle<JsEventHandler>());\n  RemoveObserver(&js_sync_manager_observer_);\n  RemoveObserver(&debug_info_event_listener_);\n  if (sync_notifier_.get()) {\n    sync_notifier_->RemoveObserver(this);\n  }\n  sync_notifier_.reset();\n  if (connection_manager_.get()) {\n    connection_manager_->RemoveListener(this);\n  }\n  connection_manager_.reset();\n  net::NetworkChangeNotifier::RemoveIPAddressObserver(this);\n  observing_ip_address_changes_ = false;\n  if (initialized_ && dir_manager()) {\n    {\n      ReadTransaction trans(FROM_HERE, GetUserShare());\n      trans.GetCryptographer()->RemoveObserver(this);\n    }\n    dir_manager()->FinalSaveChangesForAll();\n    dir_manager()->Close(username_for_share());\n  }\n  share_.dir_manager.reset();\n  setup_for_test_mode_ = false;\n  change_delegate_ = NULL;\n  registrar_ = NULL;\n  initialized_ = false;\n  change_observer_.Reset();\n  weak_handle_this_.Reset();\n}", "target": 0}
{"code": "static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css,\n\t\t\t\t  struct cftype *cft)\n{\n\treturn tg_get_cfs_quota(css_tg(css));\n}", "target": 0}
{"code": "  void ValidateOpDimensionsFromInputs(const int n, const int h, const int w,\n                                      const int c, const int kx, const int ky,\n                                      const int sx, const int sy,\n                                      const string& data_format,\n                                      const string& padding) {\n    OpContext op_context;\n    int ho;\n    int wo;\n    if (data_format == \"NHWC\") {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, h, w, c}, {1, kx, ky, 1},\n                                     {1, sx, sy, 1}, \"NHWC\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(1).size();\n      wo = op_context.op_info.outputs(0).shape().dim(2).size();\n    } else {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, c, h, w}, {1, 1, kx, ky},\n                                     {1, 1, sx, sy}, \"NCHW\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(2).size();\n      wo = op_context.op_info.outputs(0).shape().dim(3).size();\n    }\n    bool found_unknown_shapes;\n    auto dims = OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n    Padding padding_enum;\n    if (padding == \"VALID\") {\n      padding_enum = Padding::VALID;\n    } else {\n      padding_enum = Padding::SAME;\n    }\n    EXPECT_EQ(n, dims.batch);\n    EXPECT_EQ(h, dims.ix);\n    EXPECT_EQ(w, dims.iy);\n    EXPECT_EQ(c, dims.iz);\n    EXPECT_EQ(kx, dims.kx);\n    EXPECT_EQ(ky, dims.ky);\n    EXPECT_EQ(sx, dims.sx);\n    EXPECT_EQ(sy, dims.sy);\n    EXPECT_EQ(ho, dims.ox);\n    EXPECT_EQ(wo, dims.oy);\n    EXPECT_EQ(c, dims.oz);\n    EXPECT_EQ(padding_enum, dims.padding);\n  }", "target": 1}
{"code": "    CImg<T>& RGBtoHSV() {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"RGBtoHSV(): Instance is not a RGB image.\",\n                                    cimg_instance);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=256))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          R = (Tfloat)p1[N],\n          G = (Tfloat)p2[N],\n          B = (Tfloat)p3[N],\n          m = cimg::min(R,G,B),\n          M = cimg::max(R,G,B);\n        Tfloat H = 0, S = 0;\n        if (M!=m) {\n          const Tfloat\n            f = R==m?G - B:G==m?B - R:R - G,\n            i = R==m?3:G==m?5:1;\n          H = i - f/(M - m);\n          if (H>=6) H-=6;\n          H*=60;\n          S = (M - m)/M;\n        }\n        p1[N] = (T)cimg::cut(H,0,360);\n        p2[N] = (T)cimg::cut(S,0,1);\n        p3[N] = (T)cimg::cut(M/255,0,1);\n      }\n      return *this;", "target": 0}
{"code": "TEST(ExprMatchTest, IdenticalPostOptimizedExpressionsAreEquivalent) {\n    BSONObj expression = BSON(\"$expr\" << BSON(\"$multiply\" << BSON_ARRAY(2 << 2)));\n    BSONObj expressionEquiv = BSON(\"$expr\" << BSON(\"$const\" << 4));\n    BSONObj expressionNotEquiv = BSON(\"$expr\" << BSON(\"$const\" << 10));\n    const boost::intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());\n    std::unique_ptr<MatchExpression> matchExpr =\n        stdx::make_unique<ExprMatchExpression>(expression.firstElement(), expCtx);\n    matchExpr = MatchExpression::optimize(std::move(matchExpr));\n    std::unique_ptr<ExprMatchExpression> pipelineExpr(\n        dynamic_cast<ExprMatchExpression*>(matchExpr.release()));\n    ASSERT_TRUE(pipelineExpr);\n    ASSERT_TRUE(pipelineExpr->equivalent(pipelineExpr.get()));\n    ExprMatchExpression pipelineExprEquiv(expressionEquiv.firstElement(), expCtx);\n    ASSERT_TRUE(pipelineExpr->equivalent(&pipelineExprEquiv));\n    ExprMatchExpression pipelineExprNotEquiv(expressionNotEquiv.firstElement(), expCtx);\n    ASSERT_FALSE(pipelineExpr->equivalent(&pipelineExprNotEquiv));\n}", "target": 0}
{"code": "static void Sp_split_regexp(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint limit, len, k;\n\tconst char *p, *a, *b, *c, *e;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tre = js_toregexp(J, 1);\n\tlimit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;\n\tjs_newarray(J);\n\tlen = 0;\n\te = text + strlen(text);\n\tif (e == text) {\n\t\tif (js_regexec(re->prog, text, &m, 0)) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushliteral(J, \"\");\n\t\t\tjs_setindex(J, -2, 0);\n\t\t}\n\t\treturn;\n\t}\n\tp = a = text;\n\twhile (a < e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak; \n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\t\tif (b == p) {\n\t\t\t++a;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len == limit) return;\n\t\tjs_pushlstring(J, p, b - p);\n\t\tjs_setindex(J, -2, len++);\n\t\tfor (k = 1; k < m.nsub; ++k) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);\n\t\t\tjs_setindex(J, -2, len++);\n\t\t}\n\t\ta = p = c;\n\t}\n\tif (len == limit) return;\n\tjs_pushstring(J, p);\n\tjs_setindex(J, -2, len);\n}", "target": 1}
{"code": "void fz_cmm_init_profile(fz_context *ctx, fz_iccprofile *profile)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tctx->colorspace->cmm->init_profile(ctx->cmm_instance, profile);\n}", "target": 0}
{"code": "CellularNetwork::CellularNetwork(const ServiceInfo* service)\n    : WirelessNetwork(service) {\n  service_name_ = SafeString(service->name);\n  activation_state_ = service->activation_state;\n  network_technology_ = service->network_technology;\n  roaming_state_ = service->roaming_state;\n  restricted_pool_ = service->restricted_pool;\n  if (service->carrier_info) {\n    operator_name_ = SafeString(service->carrier_info->operator_name);\n    operator_code_ = SafeString(service->carrier_info->operator_code);\n    payment_url_ = SafeString(service->carrier_info->payment_url);\n  }\n  if (service->device_info) {\n    meid_ = SafeString(service->device_info->MEID);\n    imei_ = SafeString(service->device_info->IMEI);\n    imsi_ = SafeString(service->device_info->IMSI);\n    esn_ = SafeString(service->device_info->ESN);\n    mdn_ = SafeString(service->device_info->MDN);\n    min_ = SafeString(service->device_info->MIN);\n    model_id_ = SafeString(service->device_info->model_id);\n    manufacturer_ = SafeString(service->device_info->manufacturer);\n    firmware_revision_ = SafeString(service->device_info->firmware_revision);\n    hardware_revision_ = SafeString(service->device_info->hardware_revision);\n    last_update_ = SafeString(service->device_info->last_update);\n    prl_version_ = service->device_info->PRL_version;\n  }\n  type_ = TYPE_CELLULAR;\n}", "target": 0}
{"code": "static bool is_ctx_reg(struct bpf_verifier_env *env, int regno)\n{\n\tconst struct bpf_reg_state *reg = reg_state(env, regno);\n\treturn reg->type == PTR_TO_CTX;\n}", "target": 0}
{"code": "ip_printts(netdissect_options *ndo,\n           register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tint hoplen;\n\tconst char *type;\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \" TS{\"));\n\thoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n\tif ((length - 4) & (hoplen-1))\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tlen = 0;\n\tif (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)\n\t\tND_PRINT((ndo, \"[bad ptr %u]\", cp[2]));\n\tswitch (cp[3]&0xF) {\n\tcase IPOPT_TS_TSONLY:\n\t\tND_PRINT((ndo, \"TSONLY\"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\t\tND_PRINT((ndo, \"TS+ADDR\"));\n\t\tbreak;\n\tcase 2:\n\t\tND_PRINT((ndo, \"PRESPEC2.0\"));\n\t\tbreak;\n\tcase 3:\t\t\t\n\t\tND_PRINT((ndo, \"PRESPEC\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"[bad ts type %d]\", cp[3]&0xF));\n\t\tgoto done;\n\t}\n\ttype = \" \";\n\tfor (len = 4; len < length; len += hoplen) {\n\t\tif (ptr == len)\n\t\t\ttype = \" ^ \";\n\t\tND_PRINT((ndo, \"%s%d@%s\", type, EXTRACT_32BITS(&cp[len+hoplen-4]),\n\t\t       hoplen!=8 ? \"\" : ipaddr_string(ndo, &cp[len])));\n\t\ttype = \" \";\n\t}\ndone:\n\tND_PRINT((ndo, \"%s\", ptr == len ? \" ^ \" : \"\"));\n\tif (cp[3]>>4)\n\t\tND_PRINT((ndo, \" [%d hops not recorded]} \", cp[3]>>4));\n\telse\n\t\tND_PRINT((ndo, \"}\"));\n}", "target": 1}
{"code": "int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n{\n\tCNetChunk Packet;\n\tif(!pMsg)\n\t\treturn -1;\n\tif(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))\n\t\treturn 0;\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\tPacket.m_ClientID = ClientID;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\tif(!(Flags&MSGFLAG_NORECORD))\n\t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t{\n\t\tif(ClientID == -1)\n\t\t{\n\t\t\tint i;\n\t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n\t\t\t\t{\n\t\t\t\t\tPacket.m_ClientID = i;\n\t\t\t\t\tm_NetServer.Send(&Packet);\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tm_NetServer.Send(&Packet);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int adpt_system_info(void __user *buffer)\n{\n\tsysInfo_S si;\n\tmemset(&si, 0, sizeof(si));\n\tsi.osType = OS_LINUX;\n\tsi.osMajorVersion = 0;\n\tsi.osMinorVersion = 0;\n\tsi.osRevision = 0;\n\tsi.busType = SI_PCI_BUS;\n\tsi.processorFamily = DPTI_sig.dsProcessorFamily;\n#if defined __i386__\n\tadpt_i386_info(&si);\n#elif defined (__ia64__)\n\tadpt_ia64_info(&si);\n#elif defined(__sparc__)\n\tadpt_sparc_info(&si);\n#elif defined (__alpha__)\n\tadpt_alpha_info(&si);\n#else\n\tsi.processorType = 0xff ;\n#endif\n\tif (copy_to_user(buffer, &si, sizeof(si))){\n\t\tprintk(KERN_WARNING\"dpti: Could not copy buffer TO user\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "CallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n  ComputedPropertyDescriptor desc;\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}", "target": 1}
{"code": "void js_setproperty(js_State *J, int idx, const char *name)\n{\n\tjsR_setproperty(J, js_toobject(J, idx), name);\n\tjs_pop(J, 1);\n}", "target": 0}
{"code": "int fuse_fs_listxattr(struct fuse_fs *fs, const char *path, char *list,\n                      size_t size)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.listxattr)\n        return fs->op.listxattr(path, list, size);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "TEST(GteOp, MatchesDotNotationNull) {\n    BSONObj operand = BSON(\"$gte\" << BSONNULL);\n    GTEMatchExpression gte(\"a.b\", operand[\"$gte\"]);\n    ASSERT(gte.matchesBSON(BSONObj(), NULL));\n    ASSERT(gte.matchesBSON(BSON(\"a\" << BSONNULL), NULL));\n    ASSERT(gte.matchesBSON(BSON(\"a\" << 4), NULL));\n    ASSERT(gte.matchesBSON(BSON(\"a\" << BSONObj()), NULL));\n    ASSERT(gte.matchesBSON(BSON(\"a\" << BSON_ARRAY(BSON(\"b\" << BSONNULL))), NULL));\n    ASSERT(gte.matchesBSON(BSON(\"a\" << BSON_ARRAY(BSON(\"a\" << 4) << BSON(\"b\" << 4))), NULL));\n    ASSERT(!gte.matchesBSON(BSON(\"a\" << BSON_ARRAY(4)), NULL));\n    ASSERT(!gte.matchesBSON(BSON(\"a\" << BSON_ARRAY(BSON(\"b\" << 4))), NULL));\n}", "target": 0}
{"code": "const AtomicString& HTMLTextAreaElement::formControlType() const\n{\n    DEFINE_STATIC_LOCAL(const AtomicString, textarea, (\"textarea\", AtomicString::ConstructFromLiteral));\n    return textarea;\n}", "target": 0}
{"code": "static int sco_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n \tif (!addr || addr->sa_family != AF_BLUETOOTH)\n \t\treturn -EINVAL;\n \tlock_sock(sk);\n \tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tbacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);\n\tsk->sk_state = BT_BOUND;\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink)) {\n\t\t\t\tget_file(epi->ffd.file);\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "PHP_MINIT_FUNCTION(exif)\n{\n\tREGISTER_INI_ENTRIES();\n\tif (zend_hash_str_exists(&module_registry, \"mbstring\", sizeof(\"mbstring\")-1)) {\n\t\tREGISTER_LONG_CONSTANT(\"EXIF_USE_MBSTRING\", 1, CONST_CS | CONST_PERSISTENT);\n\t} else {\n\t\tREGISTER_LONG_CONSTANT(\"EXIF_USE_MBSTRING\", 0, CONST_CS | CONST_PERSISTENT);\n\t}\n\treturn SUCCESS;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::OnForwardCompositorProto(\n    const std::vector<uint8_t>& proto) {\n  if (delegate_)\n    delegate_->ForwardCompositorProto(this, proto);\n}", "target": 0}
{"code": "PingStats::~PingStats() {\n\tdelete asQuantile;\n}", "target": 0}
{"code": "static char *get_cert_prompt(TALLOC_CTX *mem_ctx,\n                             struct cert_auth_info *cert_info)\n{\n    int ret;\n    struct sss_certmap_ctx *ctx = NULL;\n    unsigned char *der = NULL;\n    size_t der_size;\n    char *prompt = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    ret = sss_certmap_init(mem_ctx, NULL, NULL, &ctx);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_init failed.\\n\");\n        return NULL;\n    }\n    ret = sss_certmap_add_rule(ctx, 10, \"KRB5:<ISSUER>.*\",\n                               \"LDAP:{subject_dn!nss}\", NULL);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_add_rule failed.\\n\");\n        goto done;\n    }\n    der = sss_base64_decode(mem_ctx, sss_cai_get_cert(cert_info), &der_size);\n    if (der == NULL) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_base64_decode failed.\\n\");\n        goto done;\n    }\n    ret = sss_certmap_get_search_filter(ctx, der, der_size, &filter, &domains);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_get_search_filter failed.\\n\");\n        goto done;\n    }\n    prompt = talloc_asprintf(mem_ctx, \"%s\\n%s\", sss_cai_get_label(cert_info),\n                                                filter);\n    if (prompt == NULL) {\n        DEBUG(SSSDBG_OP_FAILURE, \"talloc_strdup failed.\\n\");\n    }\ndone:\n    sss_certmap_free_filter_and_domains(filter, domains);\n    sss_certmap_free_ctx(ctx);\n    talloc_free(der);\n    return prompt;\n}", "target": 1}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tfree(context->planesBuffer);\n\tfree(context->pTempData);\n\tfree(context->deltaPlanesBuffer);\n\tfree(context->rlePlanesBuffer);\n\tcontext->planesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->pTempData = calloc(context->maxPlaneSize, 6);\n\tcontext->deltaPlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->rlePlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tif (!context->planesBuffer || !context->pTempData || !context->deltaPlanesBuffer ||\n\t    !context->rlePlanesBuffer)\n\t\treturn FALSE;\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}", "target": 1}
{"code": "void mce_log(struct mce *m)\n{\n\tif (!mce_gen_pool_add(m))\n\t\tirq_work_queue(&mce_irq_work);\n}", "target": 0}
{"code": "static int _process_tokenize(mcp_parser_t *pr, const size_t max) {\n    const char *s = pr->request;\n    int len = pr->reqlen - 2;\n    if (len > PARSER_MAXLEN) {\n        len = PARSER_MAXLEN;\n    }\n    const char *end = s + len;\n    int curtoken = 0;\n    int state = 0;\n    while (s != end) {\n        switch (state) {\n            case 0:\n                if (*s != ' ') {\n                    pr->tokens[curtoken] = s - pr->request;\n                    if (++curtoken == max) {\n                        s++;\n                        state = 2;\n                        break;\n                    }\n                    state = 1;\n                }\n                s++;\n                break;\n            case 1:\n                if (*s != ' ') {\n                    s++;\n                } else {\n                    state = 0;\n                }\n                break;\n            case 2:\n                if (*s == ' ') {\n                    goto endloop;\n                }\n                s++;\n                break;\n        }\n    }\nendloop:\n    pr->tokens[curtoken] = s - pr->request;\n    pr->ntokens = curtoken;\n    P_DEBUG(\"%s: cur_tokens: %d\\n\", __func__, curtoken);\n    return 0;\n}", "target": 1}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 1}
{"code": "void Item_string::print(String *str, enum_query_type query_type)\n{\n  const bool print_introducer=\n    !(query_type & QT_WITHOUT_INTRODUCERS) && is_cs_specified();\n  if (print_introducer)\n  {\n    str->append('_');\n    str->append(collation.collation->csname);\n  }\n  str->append('\\'');\n  if (query_type & QT_TO_SYSTEM_CHARSET)\n  {\n    if (print_introducer)\n    {\n      ErrConvString tmp(str_value.ptr(), str_value.length(), &my_charset_bin);\n      str->append(tmp.ptr());\n    }\n    else\n    {\n      if (my_charset_same(str_value.charset(), system_charset_info))\n        str_value.print(str); \n      else \n      {\n        THD *thd= current_thd;\n        LEX_STRING utf8_lex_str;\n        thd->convert_string(&utf8_lex_str,\n                            system_charset_info,\n                            str_value.c_ptr_safe(),\n                            str_value.length(),\n                            str_value.charset());\n        String utf8_str(utf8_lex_str.str,\n                        utf8_lex_str.length,\n                        system_charset_info);\n        utf8_str.print(str);\n      }\n    }\n  }\n  else\n  {\n    str_value.print(str);\n  }\n  str->append('\\'');\n}", "target": 0}
{"code": "translate_input(int forward_translation, char *table_name) {\n\tchar charbuf[BUFSIZE];\n\tuint8_t *outputbuf;\n\tsize_t outlen;\n\twidechar inbuf[BUFSIZE];\n\twidechar transbuf[BUFSIZE];\n\tint inlen;\n\tint translen;\n\tint k;\n\tint ch = 0;\n\tint result;\n\twhile (1) {\n\t\ttranslen = BUFSIZE;\n\t\tk = 0;\n\t\twhile ((ch = fgetc(input)) != '\\n' && ch != EOF && k < BUFSIZE - 1)\n\t\t\tcharbuf[k++] = ch;\n\t\tif (ch == EOF && k == 0) break;\n\t\tcharbuf[k] = 0;\n\t\tinlen = _lou_extParseChars(charbuf, inbuf);\n\t\tif (forward_translation)\n\t\t\tresult = lou_translateString(\n\t\t\t\t\ttable_name, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0);\n\t\telse\n\t\t\tresult = lou_backTranslateString(\n\t\t\t\t\ttable_name, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0);\n\t\tif (!result) break;\n#ifdef WIDECHARS_ARE_UCS4\n\t\toutputbuf = u32_to_u8(transbuf, translen, NULL, &outlen);\n#else\n\t\toutputbuf = u16_to_u8(transbuf, translen, NULL, &outlen);\n#endif\n\t\tprintf(ch == EOF ? \"%.*s\" : \"%.*s\\n\", (int)outlen, outputbuf);\n\t\tfree(outputbuf);\n\t}\n\tlou_free();\n}", "target": 1}
{"code": "BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, bitmapUpdate->number); \n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n \tif (bitmapUpdate->number > bitmapUpdate->count)\n \t{\n\t\tUINT16 count;\n\t\tBITMAP_DATA* newdata;\n\t\tcount = bitmapUpdate->number * 2;\n\t\tnewdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                                 sizeof(BITMAP_DATA) * count);\n \t\tif (!newdata)\n \t\t\tgoto fail;\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}", "target": 1}
{"code": "void AudioOutputController::DoCreate(AudioParameters params) {\n  DCHECK_EQ(message_loop_, MessageLoop::current());\n  if (state_ == kClosed)\n    return;\n  DCHECK(state_ == kEmpty);\n  if (!AudioManager::GetAudioManager())\n    return;\n  stream_ = AudioManager::GetAudioManager()->MakeAudioOutputStreamProxy(params);\n  if (!stream_) {\n    handler_->OnError(this, 0);\n    return;\n  }\n  if (!stream_->Open()) {\n    stream_->Close();\n    stream_ = NULL;\n    handler_->OnError(this, 0);\n    return;\n  }\n  stream_->SetVolume(volume_);\n  state_ = kCreated;\n  handler_->OnCreated(this);\n  if (!LowLatencyMode()) {\n    AutoLock auto_lock(lock_);\n    SubmitOnMoreData_Locked();\n  }\n}", "target": 0}
{"code": "UsageTracker::UsageTracker(const QuotaClientList& clients, StorageType type,\n                           SpecialStoragePolicy* special_storage_policy)\n    : type_(type),\n      callback_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {\n  for (QuotaClientList::const_iterator iter = clients.begin();\n      iter != clients.end();\n      ++iter) {\n    client_tracker_map_.insert(std::make_pair(\n        (*iter)->id(),\n        new ClientUsageTracker(this, *iter, type, special_storage_policy)));\n  }\n}", "target": 0}
{"code": "static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                return status;\n            }\n            else\n            {\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                return func(stream, iter->pos, pItem);\n            }\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}", "target": 1}
{"code": "static int multipart_buffer_headers(multipart_buffer *self, zend_llist *header TSRMLS_DC)\n{\n\tchar *line;\n\tmime_header_entry prev_entry = {0}, entry;\n\tint prev_len, cur_len;\n\tif (!find_boundary(self, self->boundary TSRMLS_CC)) {\n\t\treturn 0;\n\t}\n\twhile( (line = get_line(self TSRMLS_CC)) && strlen(line) > 0 )\n\t{\n\t\tchar *key = line;\n\t\tchar *value = NULL;\n\t\tif (php_rfc1867_encoding_translation(TSRMLS_C)) {\n\t\t\tself->input_encoding = zend_multibyte_encoding_detector(line, strlen(line), self->detect_order, self->detect_order_size TSRMLS_CC);\n\t\t}\n\t\tif (!isspace(line[0])) {\n\t\t\tvalue = strchr(line, ':');\n\t\t}\n\t\tif (value) {\n\t\t\t*value = 0;\n\t\t\tdo { value++; } while(isspace(*value));\n\t\t\tentry.value = estrdup(value);\n\t\t\tentry.key = estrdup(key);\n\t\t} else if (zend_llist_count(header)) { \n\t\t\tprev_len = strlen(prev_entry.value);\n\t\t\tcur_len = strlen(line);\n\t\t\tentry.value = emalloc(prev_len + cur_len + 1);\n\t\t\tmemcpy(entry.value, prev_entry.value, prev_len);\n\t\t\tmemcpy(entry.value + prev_len, line, cur_len);\n\t\t\tentry.value[cur_len + prev_len] = '\\0';\n\t\t\tentry.key = estrdup(prev_entry.key);\n\t\t\tzend_llist_remove_tail(header);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tzend_llist_add_element(header, &entry);\n\t\tprev_entry = entry;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  \n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  \n  else  \n    condmovestack(L,{},{});  \n  luaE_shrinkCI(L);  \n}", "target": 1}
{"code": "int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\treturn err;\n}", "target": 1}
{"code": "int MSG_ReadBits( msg_t *msg, int bits ) {\n\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n\tint\t\t\ti, nbits;\n\tvalue = 0;\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t\tsgn = qtrue;\n\t} else {\n\t\tsgn = qfalse;\n\t}\n\tif (msg->oob) {\n\t\tif(bits==8)\n\t\t{\n\t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\t}\n\t\telse if(bits==16)\n\t\t{\n\t\t\tshort temp;\n\t\t\tCopyLittleShort(&temp, &msg->data[msg->readcount]);\n\t\t\tvalue = temp;\n\t\t\tmsg->readcount += 2;\n\t\t\tmsg->bit += 16;\n\t\t}\n\t\telse if(bits==32)\n\t\t{\n\t\t\tCopyLittleLong(&value, &msg->data[msg->readcount]);\n\t\t\tmsg->readcount += 4;\n\t\t\tmsg->bit += 32;\n\t\t}\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n\t\tnbits = 0;\n\t\tif (bits&7) {\n\t\t\tnbits = bits&7;\n\t\t\tfor(i=0;i<nbits;i++) {\n\t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif (bits) {\n\t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);\n\t\t\t\tvalue |= (get<<(i+nbits));\n\t\t\t}\n\t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}\n\tif ( sgn && bits > 0 && bits < 32 ) {\n\t\tif ( value & ( 1 << ( bits - 1 ) ) ) {\n\t\t\tvalue |= -1 ^ ( ( 1 << bits ) - 1 );\n\t\t}\n\t}\n\treturn value;\n}", "target": 1}
{"code": "CotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n    assert (bufferSize > 4);\n    int readBytes;\n    if (bufPos < 4) {\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n        if (readBytes < 0)\n            goto exit_closed;\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n        bufPos += readBytes;\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n    if (readBytes < 0)\n        goto exit_closed;\n    bufPos += readBytes;\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\nexit_waiting:\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}", "target": 1}
{"code": "int __fastcall BatchSettings(TConsole * Console, TProgramParams * Params)\n{\n  int Result = RESULT_SUCCESS;\n  try\n  {\n    std::unique_ptr<TStrings> Arguments(new TStringList());\n    if (!DebugAlwaysTrue(Params->FindSwitch(L\"batchsettings\", Arguments.get())))\n    {\n      Abort();\n    }\n    else\n    {\n      if (Arguments->Count < 1)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_MASK));\n      }\n      else if (Arguments->Count < 2)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_SETTINGS));\n      }\n      else\n      {\n        TFileMasks Mask(Arguments->Strings[0]);\n        Arguments->Delete(0);\n        std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Arguments.get(), false));\n        int Matches = 0;\n        int Changes = 0;\n        for (int Index = 0; Index < StoredSessions->Count; Index++)\n        {\n          TSessionData * Data = StoredSessions->Sessions[Index];\n          if (!Data->IsWorkspace &&\n              Mask.Matches(Data->Name, false, false))\n          {\n            Matches++;\n            std::unique_ptr<TSessionData> OriginalData(new TSessionData(L\"\"));\n            OriginalData->CopyDataNoRecrypt(Data);\n            Data->ApplyRawSettings(OptionsStorage.get());\n            bool Changed = !OriginalData->IsSame(Data, false);\n            if (Changed)\n            {\n              Changes++;\n            }\n            UnicodeString StateStr = LoadStr(Changed ? BATCH_SET_CHANGED : BATCH_SET_NOT_CHANGED);\n            Console->PrintLine(FORMAT(L\"%s - %s\", (Data->Name, StateStr)));\n          }\n        }\n        StoredSessions->Save(false, true); \n        Console->PrintLine(FMTLOAD(BATCH_SET_SUMMARY, (Matches, Changes)));\n      }\n    }\n  }\n  catch (Exception & E)\n  {\n    Result = HandleException(Console, E);\n  }\n  Console->WaitBeforeExit();\n  return Result;\n}", "target": 1}
{"code": "static int validate_code_challenge(json_t * j_result_code, const char * code_verifier) {\n  int ret;\n  unsigned char code_verifier_hash[32] = {0}, code_verifier_hash_b64[64] = {0};\n  size_t code_verifier_hash_len = 32, code_verifier_hash_b64_len = 0;\n  gnutls_datum_t key_data;\n  if (!json_string_null_or_empty(json_object_get(j_result_code, \"code_challenge\"))) {\n    if (is_pkce_char_valid(code_verifier)) {\n      if (0 == o_strncmp(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX, json_string_value(json_object_get(j_result_code, \"code_challenge\")), o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX))) {\n        key_data.data = (unsigned char *)code_verifier;\n        key_data.size = (unsigned int)o_strlen(code_verifier);\n        if (gnutls_fingerprint(GNUTLS_DIG_SHA256, &key_data, code_verifier_hash, &code_verifier_hash_len) == GNUTLS_E_SUCCESS) {\n          if (o_base64url_encode(code_verifier_hash, code_verifier_hash_len, code_verifier_hash_b64, &code_verifier_hash_b64_len)) {\n            code_verifier_hash_b64[code_verifier_hash_b64_len] = '\\0';\n            if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\"))+o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX), (const char *)code_verifier_hash_b64)) {\n              ret = G_OK;\n            } else {\n              ret = G_ERROR_UNAUTHORIZED;\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"validate_code_challenge - Error o_base64url_encode\");\n            ret = G_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_code_challenge - Error gnutls_fingerprint\");\n          ret = G_ERROR;\n        }\n      } else {\n        if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\")), code_verifier)) {\n          ret = G_OK;\n        } else {\n          ret = G_ERROR_PARAM;\n        }\n      }\n    } else {\n      ret = G_ERROR_PARAM;\n    }\n  } else {\n    ret = G_OK;\n  }\n  return ret;\n}", "target": 1}
{"code": "set_loader_error (MonoLoaderError *error)\n{\n\tTlsSetValue (loader_error_thread_id, error);\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoColorMask(\n    GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {\n  mask_red_ = red;\n  mask_green_ = green;\n  mask_blue_ = blue;\n  mask_alpha_ = alpha;\n  glColorMask(red, green, blue, alpha);\n}", "target": 0}
{"code": "pktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n \tu_int length = h->len;\n \tif_printer printer;\n \tconst pktap_header_t *hdr;\n \tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n \t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n \tcase PKT_REC_PACKET:\n \t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n \t\t} else {\n \t\t\tif (!ndo->ndo_eflag)\n \t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (hdrlen);\n}", "target": 1}
{"code": "static int treo_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *swap_port;\n\tif (!((le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== HANDSPRING_VENDOR_ID) ||\n\t\t(le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== KYOCERA_VENDOR_ID)) ||\n \t\t(serial->num_interrupt_in == 0))\n \t\treturn 0;\n#define COPY_PORT(dest, src)\t\t\t\t\t\t\\\n\tdo { \\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {\t\\\n\t\t\tdest->read_urbs[i] = src->read_urbs[i];\t\t\\\n\t\t\tdest->read_urbs[i]->context = dest;\t\t\\\n\t\t\tdest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tdest->read_urb = src->read_urb;\t\t\t\t\\\n\t\tdest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\\\n\t\tdest->bulk_in_buffer = src->bulk_in_buffer;\t\t\\\n\t\tdest->bulk_in_size = src->bulk_in_size;\t\t\t\\\n\t\tdest->interrupt_in_urb = src->interrupt_in_urb;\t\t\\\n\t\tdest->interrupt_in_urb->context = dest;\t\t\t\\\n\t\tdest->interrupt_in_endpointAddress = \\\n\t\t\t\t\tsrc->interrupt_in_endpointAddress;\\\n\t\tdest->interrupt_in_buffer = src->interrupt_in_buffer;\t\\\n\t} while (0);\n\tswap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);\n\tif (!swap_port)\n\t\treturn -ENOMEM;\n\tCOPY_PORT(swap_port, serial->port[0]);\n\tCOPY_PORT(serial->port[0], serial->port[1]);\n\tCOPY_PORT(serial->port[1], swap_port);\n\tkfree(swap_port);\n\treturn 0;\n}", "target": 1}
{"code": "archive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\tsize_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\tif (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\twhile (*mbs && mbs_length > 0) {\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, wcs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, wcs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t++mbs;\n\t\t\t\t--mbs_length;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\twcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\tif (!(rcv->flags & IFF_UP))\n\t\tgoto tx_drop;\n\tif (dev->features & NETIF_F_NO_CSUM)\n\t\tskb->ip_summed = rcv_priv->ip_summed;\n\tlength = skb->len + ETH_HLEN;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\treturn NETDEV_TX_OK;\ntx_drop:\n\tkfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\nrx_drop:\n\tkfree_skb(skb);\n\trcv_stats->rx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "static void bnx2x_cnic_cfc_comp(struct bnx2x *bp, int cid, u8 err)\n{\n\tstruct cnic_ctl_info ctl = {0};\n\tctl.cmd = CNIC_CTL_COMPLETION_CMD;\n\tctl.data.comp.cid = cid;\n\tctl.data.comp.error = err;\n\tbnx2x_cnic_ctl_send_bh(bp, &ctl);\n\tbnx2x_cnic_sp_post(bp, 0);\n}", "target": 0}
{"code": "void mce_setup(struct mce *m)\n{\n\tmemset(m, 0, sizeof(struct mce));\n\tm->cpu = m->extcpu = smp_processor_id();\n\tm->time = get_seconds();\n\tm->cpuvendor = boot_cpu_data.x86_vendor;\n\tm->cpuid = cpuid_eax(1);\n\tm->socketid = cpu_data(m->extcpu).phys_proc_id;\n\tm->apicid = cpu_data(m->extcpu).initial_apicid;\n\trdmsrl(MSR_IA32_MCG_CAP, m->mcgcap);\n\tif (this_cpu_has(X86_FEATURE_INTEL_PPIN))\n\t\trdmsrl(MSR_PPIN, m->ppin);\n\tm->microcode = boot_cpu_data.microcode;\n}", "target": 0}
{"code": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n\tunsigned int assoclen = req->assoclen;\n\tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n\tint ilen, err;\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::IncrementInFlightEventCount() {\n  increment_in_flight_event_count();\n  if (!is_hidden_)\n    StartHangMonitorTimeout(hung_renderer_delay_);\n}", "target": 0}
{"code": "static struct sk_buff *xennet_get_rx_skb(struct netfront_queue *queue,\n\t\t\t\t\t RING_IDX ri)\n{\n\tint i = xennet_rxidx(ri);\n\tstruct sk_buff *skb = queue->rx_skbs[i];\n\tqueue->rx_skbs[i] = NULL;\n\treturn skb;\n}", "target": 0}
{"code": "lha_read_file_header_1(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint i, err, err2;\n\tint namelen, padding;\n\tunsigned char headersum, sum_calculated;\n\terr = ARCHIVE_OK;\n\tif ((p = __archive_read_ahead(a, H1_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tlha->header_size = p[H1_HEADER_SIZE_OFFSET] + 2;\n\theadersum = p[H1_HEADER_SUM_OFFSET];\n\tlha->compsize = archive_le32dec(p + H1_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H1_ORIG_SIZE_OFFSET);\n\tlha->mtime = lha_dos_time(p + H1_DOS_TIME_OFFSET);\n\tnamelen = p[H1_NAME_LEN_OFFSET];\n\tpadding = ((int)lha->header_size) - H1_FIXED_SIZE - namelen;\n\tif (namelen > 230 || padding < 0)\n\t\tgoto invalid;\n\tif ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tfor (i = 0; i < namelen; i++) {\n\t\tif (p[i + H1_FILE_NAME_OFFSET] == 0xff)\n\t\t\tgoto invalid;\n\t}\n\tarchive_strncpy(&lha->filename, p + H1_FILE_NAME_OFFSET, namelen);\n\tlha->crc = archive_le16dec(p + H1_FILE_NAME_OFFSET + namelen);\n\tlha->setflag |= CRC_IS_SET;\n\tsum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);\n\t__archive_read_consume(a, lha->header_size - 2);\n\terr2 = lha_read_file_extended_header(a, lha, NULL, 2,\n\t    (size_t)(lha->compsize + 2), &extdsize);\n\tif (err2 < ARCHIVE_WARN)\n\t\treturn (err2);\n\tif (err2 < err)\n\t\terr = err2;\n \tlha->compsize -= extdsize - 2;\n \tif (sum_calculated != headersum) {\n \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n \t\t    \"LHa header sum error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid LHa header\");\n\treturn (ARCHIVE_FATAL);\n}", "target": 1}
{"code": "static void create_layer_surface(struct swaylock_surface *surface) {\n\tstruct swaylock_state *state = surface->state;\n\tsurface->image = select_image(state, surface);\n\tsurface->surface = wl_compositor_create_surface(state->compositor);\n\tassert(surface->surface);\n\tsurface->child = wl_compositor_create_surface(state->compositor);\n\tassert(surface->child);\n\tsurface->subsurface = wl_subcompositor_get_subsurface(state->subcompositor, surface->child, surface->surface);\n\tassert(surface->subsurface);\n\twl_subsurface_set_sync(surface->subsurface);\n\tsurface->layer_surface = zwlr_layer_shell_v1_get_layer_surface(\n\t\t\tstate->layer_shell, surface->surface, surface->output,\n\t\t\tZWLR_LAYER_SHELL_V1_LAYER_OVERLAY, \"lockscreen\");\n\tassert(surface->layer_surface);\n\tzwlr_layer_surface_v1_set_size(surface->layer_surface, 0, 0);\n\tzwlr_layer_surface_v1_set_anchor(surface->layer_surface,\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT);\n\tzwlr_layer_surface_v1_set_exclusive_zone(surface->layer_surface, -1);\n\tzwlr_layer_surface_v1_set_keyboard_interactivity(\n\t\t\tsurface->layer_surface, true);\n\tzwlr_layer_surface_v1_add_listener(surface->layer_surface,\n\t\t\t&layer_surface_listener, surface);\n\tif (surface_is_opaque(surface) &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_CENTER &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_FIT) {\n\t\tstruct wl_region *region =\n\t\t\twl_compositor_create_region(surface->state->compositor);\n\t\twl_region_add(region, 0, 0, INT32_MAX, INT32_MAX);\n\t\twl_surface_set_opaque_region(surface->surface, region);\n\t\twl_region_destroy(region);\n\t}\n\twl_surface_commit(surface->surface);\n}", "target": 1}
{"code": "int qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n \tstruct qeth_cmd_buffer *iob;\n \tstruct qeth_ipa_cmd *cmd;\n \tstruct qeth_snmp_ureq *ureq;\n\tint req_len;\n \tstruct qeth_arp_query_info qinfo = {0, };\n \tint rc = 0;\n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n \tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n \t\treturn -EFAULT;\n \tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n \tif (IS_ERR(ureq)) {\n \t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}", "target": 1}
{"code": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n \t}\n \tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(sax));\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n\t}\n\tmsg->msg_namelen = sizeof(*sax);\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn copied;\n}", "target": 1}
{"code": "static struct dump_dir *open_directory_for_modification_of_element(\n    GDBusMethodInvocation *invocation,\n    uid_t caller_uid,\n    const char *problem_id,\n    const char *element)\n{\n    static const char *const protected_elements[] = {\n        FILENAME_TIME,\n        FILENAME_UID,\n        NULL,\n    };\n    for (const char *const *protected = protected_elements; *protected; ++protected)\n    {\n        if (strcmp(*protected, element) == 0)\n        {\n            log_notice(\"'%s' element of '%s' can't be modified\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' element can't be modified\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                        \"org.freedesktop.problems.ProtectedElement\",\n                                        error);\n            free(error);\n            return NULL;\n        }\n    }\n    if (!dump_dir_accessible_by_uid(problem_id, caller_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            log_notice(\"'%s' is not a valid problem directory\", problem_id);\n            return_InvalidProblemDir_error(invocation, problem_id);\n        }\n        else\n        {\n            log_notice(\"UID(%d) is not Authorized to access '%s'\", caller_uid, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.AuthFailure\",\n                                _(\"Not Authorized\"));\n        }\n        return NULL;\n    }\n    struct dump_dir *dd = dd_opendir(problem_id,  0);\n    if (!dd)\n    {   \n        log_notice(\"Can't access the problem '%s' for modification\", problem_id);\n        g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.Failure\",\n                                _(\"Can't access the problem for modification\"));\n        return NULL;\n    }\n    return dd;\n}", "target": 1}
{"code": "  HostQuotaCallback* NewWaitableHostQuotaCallback() {\n    ++waiting_callbacks_;\n    return callback_factory_.NewCallback(\n            &UsageAndQuotaDispatcherTask::DidGetHostQuota);\n  }", "target": 0}
{"code": "static int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: spn[%s] invalid with %u components\",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed alias uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\"SPN %s seems to be unique\\n\", spn);\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}", "target": 1}
{"code": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n  register ssize_t\n    x;\n  register Quantum\n    *q;\n  ssize_t\n    count;\n  unsigned char\n    *graydata;\n  XCFPixelInfo\n    *xcfdata,\n    *xcfodata;\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  \n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}", "target": 1}
{"code": "xmlWalkRemoveRef(const void *data, const void *user)\n{\n    xmlAttrPtr attr0 = ((xmlRefPtr)data)->attr;\n    xmlAttrPtr attr1 = ((xmlRemoveMemoPtr)user)->ap;\n    xmlListPtr ref_list = ((xmlRemoveMemoPtr)user)->l;\n    if (attr0 == attr1) { \n        xmlListRemoveFirst(ref_list, (void *)data);\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 1}
{"code": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; \n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n    rc = (digp && (p == pend)) ? 0 : -1;\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}", "target": 1}
{"code": "status_t SampleTable::setSampleToChunkParams(\n off64_t data_offset, size_t data_size) {\n if (mSampleToChunkOffset >= 0) {\n return ERROR_MALFORMED;\n }\n    mSampleToChunkOffset = data_offset;\n if (data_size < 8) {\n return ERROR_MALFORMED;\n }\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n    mNumSampleToChunkOffsets = U32_AT(&header[4]);\n if (data_size < 8 + mNumSampleToChunkOffsets * 12) {\n         return ERROR_MALFORMED;\n     }\n     mSampleToChunkEntries =\n         new SampleToChunkEntry[mNumSampleToChunkOffsets];\n for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {\n uint8_t buffer[12];\n if (mDataSource->readAt(\n                    mSampleToChunkOffset + 8 + i * 12, buffer, sizeof(buffer))\n != (ssize_t)sizeof(buffer)) {\n return ERROR_IO;\n }\n        CHECK(U32_AT(buffer) >= 1); \n        mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - 1;\n        mSampleToChunkEntries[i].samplesPerChunk = U32_AT(&buffer[4]);\n        mSampleToChunkEntries[i].chunkDesc = U32_AT(&buffer[8]);\n }\n return OK;\n}", "target": 1}
{"code": "check_mime_type(const gchar* uri,GError** error)\n{\n    GError * err = NULL;\n    const gchar* mimeFromFile;\n    mimeFromFile = ev_file_get_mime_type(uri, FALSE, &err);\n    if (mimeFromFile)\n    {\n        const gchar* mimetypes[] = {\"application/epub+zip\", \"application/x-booki+zip\", NULL};\n        guint i;\n        for (i = 0; i < g_strv_length (mimetypes); i++) {\n           if (strcmp(mimeFromFile, mimetypes[i]) == 0)\n                return TRUE;\n\t}\n        if (strcmp (mimeFromFile, \"application/zip\") == 0)\n        {\n            mimeFromFile = ev_file_get_mime_type (uri, TRUE, &err);\n            if (mimeFromFile)\n            {\n                for (i = 0; i < g_strv_length (mimetypes); i++) {\n                    if (g_strcmp0(mimeFromFile, mimetypes[i]) == 0)\n                        return TRUE;\n                }\n                g_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"Not an ePub document\"));\n                return FALSE;\n            }\n        }\n    }\n    if (err)\n        g_propagate_error (error, err);\n    else\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"Unknown MIME Type\"));\n    return FALSE;\n}", "target": 1}
{"code": "    int operator()(const Data& lhs, const Data& rhs) const {\n        return _valueComparator.compare(lhs.first, rhs.first);\n    }", "target": 0}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": "bool Capability::ChangeUnixUser(uid_t uid) {\n  if (setInitialCapabilities()) {\n    struct passwd *pw;\n    if ((pw = getpwuid(uid)) == nullptr) {\n      Logger::Error(\"unable to getpwuid(%d): %s\", uid,\n                    folly::errnoStr(errno).c_str());\n      return false;\n    }\n    if (pw->pw_gid == 0 || setgid(pw->pw_gid) < 0) {\n      Logger::Error(\"unable to drop gid privs: %s\",\n                    folly::errnoStr(errno).c_str());\n      return false;\n    }\n    if (uid == 0 || setuid(uid) < 0) {\n      Logger::Error(\"unable to drop uid privs: %s\",\n                    folly::errnoStr(errno).c_str());\n      return false;\n    }\n    if (!setMinimalCapabilities()) {\n      Logger::Error(\"unable to set minimal server capabiltiies\");\n      return false;\n    }\n    return true;\n  }\n  return false;\n}", "target": 1}
{"code": "PHP_FUNCTION(quoted_printable_encode)\n{\n\tchar *str, *new_str;\n\tint str_len;\n\tsize_t new_str_len;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &str, &str_len) != SUCCESS) {\n\t\treturn;\n\t}\n\tif (!str_len) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tnew_str = (char *)php_quot_print_encode((unsigned char *)str, (size_t)str_len, &new_str_len);\n\tRETURN_STRINGL(new_str, new_str_len, 0);\n}", "target": 0}
{"code": "op_format(\n    oparg_T\t*oap,\n    int\t\tkeep_cursor)\t\t\n{\n    long\told_line_count = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor = oap->cursor_start;\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n    curwin->w_cursor = oap->start;\n    if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_start = oap->start;\n    if (keep_cursor)\n\tsaved_cursor = oap->cursor_start;\n    format_lines(oap->line_count, keep_cursor);\n    if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t++curwin->w_cursor.lnum;\n    beginline(BL_WHITE | BL_FIX);\n    old_line_count = curbuf->b_ml.ml_line_count - old_line_count;\n    msgmore(old_line_count);\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_end = curwin->w_cursor;\n    if (keep_cursor)\n    {\n\tcurwin->w_cursor = saved_cursor;\n\tsaved_cursor.lnum = 0;\n    }\n    if (oap->is_VIsual)\n    {\n\twin_T\t*wp;\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_old_cursor_lnum != 0)\n\t    {\n\t\tif (wp->w_old_cursor_lnum > wp->w_old_visual_lnum)\n\t\t    wp->w_old_cursor_lnum += old_line_count;\n\t\telse\n\t\t    wp->w_old_visual_lnum += old_line_count;\n\t    }\n\t}\n    }\n}", "target": 1}
{"code": "mp_join_print(netdissect_options *ndo,\n              const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_join *mpj = (const struct mp_join *) opt;\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 16 && (flags & (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) &&\n            !(opt_len == 24 && flags & TH_ACK))\n                return 0;\n        if (opt_len != 24) {\n                if (mpj->sub_b & MP_JOIN_B)\n                        ND_PRINT((ndo, \" backup\"));\n                ND_PRINT((ndo, \" id %u\", mpj->addr_id));\n        }\n        switch (opt_len) {\n        case 12: \n                ND_PRINT((ndo, \" token 0x%x\" \" nonce 0x%x\",\n                        EXTRACT_32BITS(mpj->u.syn.token),\n                        EXTRACT_32BITS(mpj->u.syn.nonce)));\n                break;\n        case 16: \n                ND_PRINT((ndo, \" hmac 0x%\" PRIx64 \" nonce 0x%x\",\n                        EXTRACT_64BITS(mpj->u.synack.mac),\n                        EXTRACT_32BITS(mpj->u.synack.nonce)));\n                break;\n        case 24: {\n                size_t i;\n                ND_PRINT((ndo, \" hmac 0x\"));\n                for (i = 0; i < sizeof(mpj->u.ack.mac); ++i)\n                        ND_PRINT((ndo, \"%02x\", mpj->u.ack.mac[i]));\n        }\n        default:\n                break;\n        }\n        return 1;\n}", "target": 1}
{"code": "static unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\tarea = current->mm->uprobes_state.xol_area;\n\tsmp_read_barrier_depends();\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\treturn trampoline_vaddr;\n}", "target": 0}
{"code": "cif_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\tint line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int lnum;\n        byte *in = (byte *)gs_malloc(pdev->memory, line_size, 1, \"cif_print_page(in)\");\n        char *s;\n        int scanline, scanbyte;\n        int length, start; \n        if (in == 0)\n                return_error(gs_error_VMerror);\n        if ((s = strchr(pdev->fname, '.')) == NULL)\n                length = strlen(pdev->fname) + 1;\n        else\n                length = s - pdev->fname;\n        s = (char *)gs_malloc(pdev->memory, length, sizeof(char), \"cif_print_page(s)\");\n        strncpy(s, pdev->fname, length);\n        *(s + length) = '\\0';\n        gp_fprintf(prn_stream, \"DS1 25 1;\\n9 %s;\\nLCP;\\n\", s);\n        gs_free(pdev->memory, s, length, 1, \"cif_print_page(s)\");\n   for (lnum = 0; lnum < pdev->height; lnum++) {\n      gdev_prn_copy_scan_lines(pdev, lnum, in, line_size);\n      length = 0;\n      for (scanline = 0; scanline < line_size; scanline++)\n#ifdef TILE\t\t\t\n         for (scanbyte = 0; scanbyte < 8; scanbyte++)\n            if (((in[scanline] >> scanbyte) & 1) != 0)\n               gp_fprintf(prn_stream, \"B4 4 %d %d;\\n\",\n                  (scanline * 8 + (7 - scanbyte)) * 4,\n                  (pdev->height - lnum) * 4);\n#else\t\t\t\t\n         for (scanbyte = 7; scanbyte >= 0; scanbyte--)\n            if (((in[scanline] >> scanbyte) & 1) != 0) {\n               if (length == 0)\n                  start = (scanline * 8 + (7 - scanbyte));\n               length++;\n            } else {\n               if (length != 0)\n                  gp_fprintf(prn_stream, \"B%d 4 %d %d;\\n\", length * 4,\n                           start * 4 + length * 2,\n                           (pdev->height - lnum) * 4);\n               length = 0;\n            }\n#endif\n   }\n        gp_fprintf(prn_stream, \"DF;\\nC1;\\nE\\n\");\n        gs_free(pdev->memory, in, line_size, 1, \"cif_print_page(in)\");\n        return 0;\n}", "target": 1}
{"code": "hb_buffer_reference (hb_buffer_t *buffer)\n{\n  HB_OBJECT_DO_REFERENCE (buffer);\n}", "target": 0}
{"code": "int lowmem_reserve_ratio_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tproc_dointvec_minmax(table, write, buffer, length, ppos);\n\tsetup_per_zone_lowmem_reserve();\n\treturn 0;\n}", "target": 0}
{"code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n    trail = 0;\n    length = info->name.length;\n    if (dir != NULL) {\n        length = dir->length;\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n        trail = (dir->start[dir->length - 1] != '/');\n        if (trail) {\n            length++;\n        }\n    }\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n    p = &src[0];\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n    return NJS_OK;\n}", "target": 1}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n \t\tif (i < pos && i + insn->off + 1 > pos)\n \t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n \t\t\tinsn->off -= delta;\n \t}\n }", "target": 1}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 1}
{"code": " av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n     ff_idctdsp_init(&s->idsp, s->avctx);\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}", "target": 1}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n     if (nargs == 0)\n         return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n     buf = mp_buf_new(L);\n     for(i = 1; i <= nargs; i++) {\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 1}
{"code": "static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n\t\treturn err;\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tIRDA_DEBUG(2, \"%s(), Received truncated frame (%zd < %zd)!\\n\",\n\t\t\t   __func__, copied, size);\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tskb_free_datagram(sk, skb);\n\tif (self->rx_flow == FLOW_STOP) {\n\t\tif ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {\n\t\t\tIRDA_DEBUG(2, \"%s(), Starting IrTTP\\n\", __func__);\n\t\t\tself->rx_flow = FLOW_START;\n\t\t\tirttp_flow_request(self->tsap, FLOW_START);\n\t\t}\n\t}\n\treturn copied;\n}", "target": 1}
{"code": "static inline int unserialize_allowed_class(zend_string *class_name, HashTable *classes)\n{\n\tzend_string *lcname;\n\tint res;\n\tALLOCA_FLAG(use_heap)\n\tif(classes == NULL) {\n\t\treturn 1;\n\t}\n\tif(!zend_hash_num_elements(classes)) {\n\t\treturn 0;\n\t}\n\tSTR_ALLOCA_ALLOC(lcname, class_name->len, use_heap);\n\tzend_str_tolower_copy(lcname->val, class_name->val, class_name->len);\n\tres = zend_hash_exists(classes, lcname);\n\tSTR_ALLOCA_FREE(lcname, use_heap);\n\treturn res;\n}", "target": 0}
{"code": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\tBUG_ON(sig == -1);\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\tdo_notify_pidfd(tsk);\n\tif (sig != SIGCHLD) {\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\treturn autoreap;\n}", "target": 1}
{"code": "static int rfcomm_get_dev_list(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_list_req *dl;\n\tstruct rfcomm_dev_info *di;\n\tint n = 0, size, err;\n\tu16 dev_num;\n\tBT_DBG(\"\");\n\tif (get_user(dev_num, (u16 __user *) arg))\n\t\treturn -EFAULT;\n\tif (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))\n\t\treturn -EINVAL;\n \tsize = sizeof(*dl) + dev_num * sizeof(*di);\n\tdl = kmalloc(size, GFP_KERNEL);\n \tif (!dl)\n \t\treturn -ENOMEM;\n\tdi = dl->dev_info;\n\tspin_lock(&rfcomm_dev_lock);\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tcontinue;\n\t\t(di + n)->id      = dev->id;\n\t\t(di + n)->flags   = dev->flags;\n\t\t(di + n)->state   = dev->dlc->state;\n\t\t(di + n)->channel = dev->channel;\n\t\tbacpy(&(di + n)->src, &dev->src);\n\t\tbacpy(&(di + n)->dst, &dev->dst);\n\t\tif (++n >= dev_num)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&rfcomm_dev_lock);\n\tdl->dev_num = n;\n\tsize = sizeof(*dl) + n * sizeof(*di);\n\terr = copy_to_user(arg, dl, size);\n\tkfree(dl);\n\treturn err ? -EFAULT : 0;\n}", "target": 1}
{"code": "static int fts3DoclistCountDocids(char *aList, int nList){\n  int nDoc = 0;                   \n  if( aList ){\n    char *aEnd = &aList[nList];   \n    char *p = aList;              \n    while( p<aEnd ){\n      nDoc++;\n      while( (*p++)&0x80 );     \n      fts3PoslistCopy(0, &p);   \n    }\n  }\n  return nDoc;\n}", "target": 0}
{"code": "eval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n    rettv->v_type = VAR_UNKNOWN;\n    if (**arg == '{')\n    {\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ')')\n\t{\n\t    ++*arg;\n\t}\n\telse\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    ret = FAIL;\n\t}\n    }\n    if (ret != OK)\n\treturn FAIL;\n    else if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n    if (evaluate)\n\tclear_tv(&base);\n    return ret;\n}", "target": 1}
{"code": "static int options_open_fs(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, options_seq_show, PDE(inode)->data);\n}", "target": 0}
{"code": "euckr_mbc_to_code(const UChar* p, const UChar* end, OnigEncoding enc)\n{\n  return onigenc_mbn_mbc_to_code(enc, p, end);\n}", "target": 0}
{"code": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\t*num_xfrms = pols[0]->xfrm_nr;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  FT_Stream_EnterFrame( FT_Stream  stream,\n                        FT_ULong   count )\n  {\n    FT_Error  error = FT_Err_Ok;\n    FT_ULong  read_bytes;\n    FT_ASSERT( stream && stream->cursor == 0 );\n    if ( stream->read )\n    {\n      FT_Memory  memory = stream->memory;\n      if ( count > stream->size )\n      {\n        FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                   \" frame size (%lu) larger than stream size (%lu)\\n\",\n                   count, stream->size ));\n        error = FT_Err_Invalid_Stream_Operation;\n        goto Exit;\n      }\n#ifdef FT_DEBUG_MEMORY\n      stream->base = (unsigned char*)ft_mem_qalloc( memory, count, &error );\n      if ( error )\n        goto Exit;\n#else\n      if ( FT_QALLOC( stream->base, count ) )\n        goto Exit;\n#endif\n      read_bytes = stream->read( stream, stream->pos,\n                                 stream->base, count );\n      if ( read_bytes < count )\n      {\n        FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                   \" invalid read; expected %lu bytes, got %lu\\n\",\n                   count, read_bytes ));\n        FT_FREE( stream->base );\n        error = FT_Err_Invalid_Stream_Operation;\n      }\n      stream->cursor = stream->base;\n      stream->limit  = stream->cursor + count;\n      stream->pos   += read_bytes;\n    }\n    else\n     {\n       if ( stream->pos >= stream->size        ||\n           stream->pos + count > stream->size )\n       {\n         FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                    \" invalid i/o; pos = 0x%lx, count = %lu, size = 0x%lx\\n\",\n                   stream->pos, count, stream->size ));\n        error = FT_Err_Invalid_Stream_Operation;\n        goto Exit;\n      }\n      stream->cursor = stream->base + stream->pos;\n      stream->limit  = stream->cursor + count;\n      stream->pos   += count;\n    }\n  Exit:\n    return error;\n  }", "target": 1}
{"code": "TEST_F(QueryPlannerTest, ContainedOrCombineLeadingFields) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1 << \"a\" << 1));\n    runQuery(fromjson(\"{$and: [{a: {$gte: 0}}, {$or: [{a: {$lte: 10}}, {b: 6}]}]}\"));\n    assertNumSolutions(3);\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {or: {nodes: [\"\n        \"{ixscan: {pattern: {a: 1}, bounds: {a: [[0, 10, true, true]]}}},\"\n        \"{ixscan: {pattern: {b: 1, a: 1}, bounds: {b: [[6, 6, true, true]], a: [[0, Infinity, \"\n        \"true, true]]}}}\"\n        \"]}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$or: [{a: {$lte: 10}}, {b: 6}]}, node: \"\n        \"{ixscan: {pattern: {a: 1}, bounds: {a: [[0, Infinity, true, true]]}}}\"\n        \"}}\");\n    assertSolutionExists(\"{cscan: {dir: 1}}}}\");\n}", "target": 0}
{"code": "int LibRaw_buffer_datastream::jpeg_src(void *jpegdata)\n{\n#if defined(NO_JPEG) || !defined(USE_JPEG)\n  return -1;\n#else\n  j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;\n  jpeg_mem_src(cinfo, (unsigned char *)buf + streampos, streamsize - streampos);\n  return 0;\n#endif\n}", "target": 0}
{"code": "SProcRecordRegisterClients(ClientPtr client)\n{\n    REQUEST(xRecordRegisterClientsReq);\n    int status;\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xRecordRegisterClientsReq);\n    if ((status = SwapCreateRegister(client, (void *) stuff)) != Success)\n        return status;\n    return ProcRecordRegisterClients(client);\n}                               ", "target": 0}
{"code": "    virtual void didStopLoading()\n    {\n        m_stopLoadingCount++;\n    }", "target": 0}
{"code": "AcpiDsCreateOperands (\n    ACPI_WALK_STATE         *WalkState,\n    ACPI_PARSE_OBJECT       *FirstArg)\n{\n    ACPI_STATUS             Status = AE_OK;\n    ACPI_PARSE_OBJECT       *Arg;\n     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];\n     UINT32                  ArgCount = 0;\n     UINT32                  Index = WalkState->NumOperands;\n     UINT32                  i;\n    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);\n    Arg = FirstArg;\n    while (Arg)\n    {\n        if (Index >= ACPI_OBJ_NUM_OPERANDS)\n        {\n            return_ACPI_STATUS (AE_BAD_DATA);\n        }\n        Arguments[Index] = Arg;\n        WalkState->Operands [Index] = NULL;\n        Arg = Arg->Common.Next;\n        ArgCount++;\n        Index++;\n    }\n    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n        \"NumOperands %d, ArgCount %d, Index %d\\n\",\n        WalkState->NumOperands, ArgCount, Index));\n     Index--;\n     for (i = 0; i < ArgCount; i++)\n     {\n        Arg = Arguments[Index];\n        WalkState->OperandIndex = (UINT8) Index;\n        Status = AcpiDsCreateOperand (WalkState, Arg, Index);\n        if (ACPI_FAILURE (Status))\n        {\n            goto Cleanup;\n        }\n        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n            \"Created Arg #%u (%p) %u args total\\n\",\n            Index, Arg, ArgCount));\n        Index--;\n    }\n    return_ACPI_STATUS (Status);\nCleanup:\n    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);\n     ACPI_EXCEPTION ((AE_INFO, Status, \"While creating Arg %u\", Index));\n     return_ACPI_STATUS (Status);\n}", "target": 1}
{"code": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n\t    data[1] = new >> 4;\n\t} else {\n\t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n\t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n\t    else\n\t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}", "target": 1}
{"code": "void SyncManager::SyncInternal::OnIPAddressChanged() {\n  DVLOG(1) << \"IP address change detected\";\n  if (!observing_ip_address_changes_) {\n    DVLOG(1) << \"IP address change dropped.\";\n     return;\n   }\n#if defined (OS_CHROMEOS)\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&SyncInternal::OnIPAddressChangedImpl,\n                 weak_ptr_factory_.GetWeakPtr()),\n      kChromeOSNetworkChangeReactionDelayHackMsec);\n#else\n   OnIPAddressChangedImpl();\n#endif  \n }", "target": 1}
{"code": "static void pipe_advance(struct iov_iter *i, size_t size)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tint idx = i->idx;\n\tsize_t off = i->iov_offset, orig_sz;\n\tif (unlikely(i->count < size))\n\t\tsize = i->count;\n\torig_sz = size;\n\tif (size) {\n\t\tif (off) \n\t\t\tsize += off - pipe->bufs[idx].offset;\n\t\twhile (1) {\n\t\t\tbuf = &pipe->bufs[idx];\n\t\t\tif (size <= buf->len)\n\t\t\t\tbreak;\n\t\t\tsize -= buf->len;\n\t\t\tidx = next_idx(idx, pipe);\n\t\t}\n\t\tbuf->len = size;\n\t\ti->idx = idx;\n\t\toff = i->iov_offset = buf->offset + size;\n\t}\n\tif (off)\n\t\tidx = next_idx(idx, pipe);\n\tif (pipe->nrbufs) {\n\t\tint unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\twhile (idx != unused) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n\t}\n\ti->count -= orig_sz;\n}", "target": 1}
{"code": "  ipcp_value()\n    : sources (0), next (0), scc_next (0), topo_next (0),\n      spec_node (0), dfs (0), low_link (0), on_stack (false) {}", "target": 0}
{"code": "static inline void crst_table_init(unsigned long *crst, unsigned long entry)\n{\n\tclear_table(crst, entry, sizeof(unsigned long)*2048);\n}", "target": 0}
{"code": "void WebGraphicsContext3DDefaultImpl::getIntegerv(unsigned long pname, int* value)\n{\n    makeContextCurrent();\n    switch (pname) {\n    case IMPLEMENTATION_COLOR_READ_FORMAT:\n        *value = GL_RGB;\n        break;\n    case IMPLEMENTATION_COLOR_READ_TYPE:\n        *value = GL_UNSIGNED_BYTE;\n        break;\n    case MAX_FRAGMENT_UNIFORM_VECTORS:\n        glGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_COMPONENTS, value);\n        *value /= 4;\n        break;\n    case MAX_VERTEX_UNIFORM_VECTORS:\n        glGetIntegerv(GL_MAX_VERTEX_UNIFORM_COMPONENTS, value);\n        *value /= 4;\n        break;\n    case MAX_VARYING_VECTORS:\n        glGetIntegerv(GL_MAX_VARYING_FLOATS, value);\n        *value /= 4;\n        break;\n    default:\n        glGetIntegerv(pname, value);\n    }\n}", "target": 0}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": "TEST_F(HeaderToMetadataTest, BasicRequestDoubleHeadersTest) {\n  initializeFilter(request_config_yaml);\n  Http::TestRequestHeaderMapImpl incoming_headers{{\"X-VERSION\", \"foo\"}, {\"X-VERSION\", \"bar\"}};\n  std::map<std::string, std::string> expected = {{\"version\", \"foo,bar\"}};\n  EXPECT_CALL(decoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_, setDynamicMetadata(\"envoy.lb\", MapEq(expected)));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(incoming_headers, false));\n  Http::MetadataMap metadata_map{{\"metadata\", \"metadata\"}};\n  EXPECT_EQ(Http::FilterMetadataStatus::Continue, filter_->decodeMetadata(metadata_map));\n  Buffer::OwnedImpl data(\"data\");\n  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(data, false));\n  Http::TestRequestTrailerMapImpl incoming_trailers;\n  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(incoming_trailers));\n  filter_->onDestroy();\n}", "target": 0}
{"code": "static void power_pmu_disable(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuhw;\n\tunsigned long flags;\n\tif (!ppmu)\n\t\treturn;\n\tlocal_irq_save(flags);\n\tcpuhw = &__get_cpu_var(cpu_hw_events);\n\tif (!cpuhw->disabled) {\n\t\tcpuhw->disabled = 1;\n\t\tcpuhw->n_added = 0;\n\t\tif (!cpuhw->pmcs_enabled) {\n\t\t\tppc_enable_pmcs();\n\t\t\tcpuhw->pmcs_enabled = 1;\n\t\t}\n\t\tif (cpuhw->mmcr[2] & MMCRA_SAMPLE_ENABLE) {\n\t\t\tmtspr(SPRN_MMCRA,\n\t\t\t      cpuhw->mmcr[2] & ~MMCRA_SAMPLE_ENABLE);\n\t\t\tmb();\n\t\t}\n\t\twrite_mmcr0(cpuhw, mfspr(SPRN_MMCR0) | MMCR0_FC);\n\t\tmb();\n\t}\n\tlocal_irq_restore(flags);\n}", "target": 0}
{"code": "GF_Err btrt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_BitRateBox *ptr = (GF_BitRateBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->bufferSizeDB);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\treturn GF_OK;\n}", "target": 0}
{"code": "output_title_label_after_expose_event_cb (GtkWidget *widget, GdkEventExpose *event, gpointer data)\n{\n        g_assert (GTK_IS_LABEL (widget));\n        widget->state = GTK_STATE_INSENSITIVE;\n        return FALSE;\n}", "target": 0}
{"code": "static void jsonNewDString(Jsi_Interp *interp, Jsi_DString *dStr, const char* str, int len)\n{\n    char buf[100], *dp = buf;\n    const char *cp = str;\n    int ulen;\n    while ((cp-str)<len) {\n        if (*cp == '\\\\') {\n            switch (cp[1]) {\n                case 'b': *dp++ = '\\b'; break;\n                case 'n': *dp++ = '\\n'; break;\n                case 'r': *dp++ = '\\r'; break;\n                case 'f': *dp++ = '\\f'; break;\n                case 't': *dp++ = '\\t'; break;\n                case '\\\"': *dp++ = '\\\"'; break;\n                case '\\\\': *dp++ = '\\\\'; break;\n                case 'u': \n                    if ((ulen=Jsi_UtfDecode(cp+2, dp))) {\n                        dp += ulen;\n                        cp += 4;\n                    } else {                    \n                        *dp++ = '\\\\';\n                        *dp++ = 'u';\n                    }\n                    break;\n            }\n            cp+=2;\n        } else {\n            *dp++ = *cp++;\n        }\n        if ((dp-buf)>90) {\n            *dp = 0;\n            Jsi_DSAppendLen(dStr, buf, dp-buf);\n            dp = buf;\n        }\n    }\n    *dp = 0;\n    Jsi_DSAppendLen(dStr, buf, dp-buf);\n}", "target": 1}
{"code": "static void terminate(int sig)\n{\n    unlink(socket_file);\n    exit(0);\n}", "target": 0}
{"code": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\treturn ret;\n}", "target": 1}
{"code": "static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_pmd_page_dtor(virt_to_page(pmd));\n\tcrst_table_free(mm, (unsigned long *) pmd);\n}", "target": 0}
{"code": "bool RenderWidgetHostViewAura::LockMouse() {\n  aura::Window* root_window = window_->GetRootWindow();\n  if (!root_window)\n    return false;\n  if (mouse_locked_)\n    return true;\n  mouse_locked_ = true;\n#if !defined(OS_WIN)\n  window_->SetCapture();\n#endif\n  aura::client::CursorClient* cursor_client =\n      aura::client::GetCursorClient(root_window);\n  if (cursor_client) {\n    cursor_client->HideCursor();\n    cursor_client->LockCursor();\n  }\n  if (ShouldMoveToCenter()) {\n    synthetic_move_sent_ = true;\n    window_->MoveCursorTo(gfx::Rect(window_->bounds().size()).CenterPoint());\n  }\n  tooltip_disabler_.reset(new aura::client::ScopedTooltipDisabler(root_window));\n  root_window->GetDispatcher()->host()->ConfineCursorToRootWindow();\n  return true;\n}", "target": 0}
{"code": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n \t\t\tgoto out;\n \t\t}\n \t}\n \tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n \tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 1}
{"code": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n {\n     OPJ_UINT32 l_data_size;\n    l_data_size = (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                               (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n     if (l_data_size > p_code_block->data_size) {\n         if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}", "target": 1}
{"code": " static OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n \tOPCODE_DESC *opcode_desc;\n \tut16 ins = (buf[1] << 8) | buf[0];\n \tint fail;\n \tchar *t;\n\tmemset (op, 0, sizeof (RAnalOp));\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\tr_strbuf_init (&op->esil);\n\tfor (opcode_desc = opcodes; opcode_desc->handler; opcode_desc++) {\n\t\tif ((ins & opcode_desc->mask) == opcode_desc->selector) {\n\t\t\tfail = 0;\n\t\t\top->cycles = opcode_desc->cycles;\n\t\t\top->size = opcode_desc->size;\n\t\t\top->type = opcode_desc->type;\n\t\t\top->jump = UT64_MAX;\n\t\t\top->fail = UT64_MAX;\n\t\t\top->addr = addr;\n\t\t\tr_strbuf_setf (&op->esil, \"\");\n\t\t\topcode_desc->handler (anal, op, buf, len, &fail, cpu);\n\t\t\tif (fail) {\n\t\t\t\tgoto INVALID_OP;\n\t\t\t}\n\t\t\tif (op->cycles <= 0) {\n\t\t\t\topcode_desc->cycles = 2;\n\t\t\t}\n\t\t\top->nopcode = (op->type == R_ANAL_OP_TYPE_UNK);\n\t\t\tt = r_strbuf_get (&op->esil);\n\t\t\tif (t && strlen (t) > 1) {\n\t\t\t\tt += strlen (t) - 1;\n\t\t\t\tif (*t == ',') {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opcode_desc;\n\t\t}\n\t}\n\tif ((ins & 0xff00) == 0xff00 && (ins & 0xf) > 7) {\n\t\tgoto INVALID_OP;\n\t}\nINVALID_OP:\n\top->family = R_ANAL_OP_FAMILY_UNKNOWN;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->addr = addr;\n\top->fail = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->nopcode = 1;\n\top->cycles = 1;\n\top->size = 2;\n\tr_strbuf_set (&op->esil, \"1,$\");\n\treturn NULL;\n}", "target": 1}
{"code": "zzip_disk_entry_fopen(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)\n{\n    struct zzip_file_header *header =\n        zzip_disk_entry_to_file_header(disk, entry);\n    if (! header)\n        return 0; \n    ___ ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_DISK_FILE));\n    if (! file)\n        return 0; \n    file->buffer = disk->buffer;\n    file->endbuf = disk->endbuf;\n    file->avail = zzip_file_header_usize(header);\n    if (! file->avail || zzip_file_header_data_stored(header))\n    { \n         file->stored = zzip_file_header_to_data (header);\n         DBG2(\"stored size %i\", (int) file->avail);\n         if (file->stored + file->avail >= disk->endbuf)\n             goto error;\n         return file; \n    }\n    file->stored = 0;\n    file->zlib.opaque = 0;\n    file->zlib.zalloc = Z_NULL;\n    file->zlib.zfree = Z_NULL;\n    file->zlib.avail_in = zzip_file_header_csize(header);\n    file->zlib.next_in = zzip_file_header_to_data(header);\n    DBG2(\"compressed size %i\", (int) file->zlib.avail_in);\n    if (file->zlib.next_in + file->zlib.avail_in >= disk->endbuf)\n         goto error;\n    if (! zzip_file_header_data_deflated(header))\n        goto error;\n    if (inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)\n        goto error;\n    return file;\nerror:\n    free (file);\n    errno = EBADMSG;\n    return 0; \n    ____;\n}", "target": 1}
{"code": "static int write_empty_blocks(struct page *page, unsigned from, unsigned to,\n\t\t\t      int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned start, end, next, blksize;\n\tsector_t block = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tint ret;\n\tblksize = 1 << inode->i_blkbits;\n\tnext = end = 0;\n\twhile (next < from) {\n\t\tnext += blksize;\n\t\tblock++;\n\t}\n\tstart = next;\n\tdo {\n\t\tnext += blksize;\n\t\tret = needs_empty_write(block, inode);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tif (ret == 0) {\n\t\t\tif (end) {\n\t\t\t\tret = __block_write_begin(page, start, end - start,\n\t\t\t\t\t\t\t  gfs2_block_map);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tret = empty_write_end(page, start, end, mode);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tend = 0;\n\t\t\t}\n\t\t\tstart = next;\n\t\t}\n\t\telse\n\t\t\tend = next;\n\t\tblock++;\n\t} while (next < to);\n\tif (end) {\n\t\tret = __block_write_begin(page, start, end - start, gfs2_block_map);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = empty_write_end(page, start, end, mode);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": " static int get_refcount(BlockDriverState *bs, int64_t cluster_index)\n {\n     BDRVQcowState *s = bs->opaque;\n    int refcount_table_index, block_index;\n     int64_t refcount_block_offset;\n     int ret;\n     uint16_t *refcount_block;\n    uint16_t refcount;\n    refcount_table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n    if (refcount_table_index >= s->refcount_table_size)\n        return 0;\n    refcount_block_offset =\n        s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n    if (!refcount_block_offset)\n        return 0;\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, refcount_block_offset,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n    block_index = cluster_index &\n        ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n    refcount = be16_to_cpu(refcount_block[block_index]);\n    ret = qcow2_cache_put(bs, s->refcount_block_cache,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n    return refcount;\n}", "target": 1}
{"code": "vips_tracked_malloc( size_t size )\n{\n        void *buf;\n\tvips_tracked_init(); \n\tsize += 16;\n        if( !(buf = g_try_malloc( size )) ) {\n#ifdef DEBUG\n\t\tg_assert_not_reached();\n#endif \n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n                return( NULL );\n\t}\n\tg_mutex_lock( vips_tracked_mutex );\n\t*((size_t *)buf) = size;\n\tbuf = (void *) ((char *)buf + 16);\n\tvips_tracked_mem += size;\n\tif( vips_tracked_mem > vips_tracked_mem_highwater ) \n\t\tvips_tracked_mem_highwater = vips_tracked_mem;\n\tvips_tracked_allocs += 1;\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", buf, size ); \n#endif \n\tg_mutex_unlock( vips_tracked_mutex );\n\tVIPS_GATE_MALLOC( size ); \n        return( buf );\n}", "target": 1}
{"code": "void PDFiumEngine::PostPaint() {\n  for (size_t i = 0; i < progressive_paints_.size(); ++i) {\n    if (progressive_paints_[i].painted_)\n      continue;\n    FPDF_RenderPage_Close(\n        pages_[progressive_paints_[i].page_index]->GetPage());\n    FPDFBitmap_Destroy(progressive_paints_[i].bitmap);\n    progressive_paints_.erase(progressive_paints_.begin() + i);\n    --i;\n  }\n}", "target": 0}
{"code": "bool mysql_explain_union(THD *thd, SELECT_LEX_UNIT *unit, select_result *result)\n{\n  DBUG_ENTER(\"mysql_explain_union\");\n  bool res= 0;\n  SELECT_LEX *first= unit->first_select();\n  bool is_pushed_union= unit->derived && unit->derived->pushdown_derived;\n  for (SELECT_LEX *sl= first; sl; sl= sl->next_select())\n  {\n    sl->set_explain_type(FALSE);\n    sl->options|= SELECT_DESCRIBE;\n  }\n  if (unit->is_unit_op() || unit->fake_select_lex)\n  {\n    ulonglong save_options= 0;\n    if (unit->union_needs_tmp_table() && unit->fake_select_lex)\n    {\n      save_options= unit->fake_select_lex->options;\n      unit->fake_select_lex->select_number= FAKE_SELECT_LEX_ID; \n      unit->fake_select_lex->type= unit_operation_text[unit->common_op()];\n      unit->fake_select_lex->options|= SELECT_DESCRIBE;\n    }\n    if (!(res= unit->prepare(unit->derived, result,\n                             SELECT_NO_UNLOCK | SELECT_DESCRIBE)))\n    {\n      if (!is_pushed_union)\n        res= unit->exec();\n    }\n    if (unit->union_needs_tmp_table() && unit->fake_select_lex)\n      unit->fake_select_lex->options= save_options;\n  }\n  else\n  {\n    thd->lex->current_select= first;\n    unit->set_limit(unit->global_parameters());\n    res= mysql_select(thd, \n                      first->table_list.first,\n                      first->with_wild, first->item_list,\n                      first->where,\n                      first->order_list.elements + first->group_list.elements,\n                      first->order_list.first,\n                      first->group_list.first,\n                      first->having,\n                      thd->lex->proc_list.first,\n                      first->options | thd->variables.option_bits | SELECT_DESCRIBE,\n                      result, unit, first);\n  }\n  if (unit->derived && unit->derived->pushdown_derived)\n  {\n    delete unit->derived->pushdown_derived;\n    unit->derived->pushdown_derived= NULL;\n  }\n  DBUG_RETURN(res || thd->is_error());\n}", "target": 0}
{"code": "void __skb_tstamp_tx(struct sk_buff *orig_skb,\n\t\t     struct skb_shared_hwtstamps *hwtstamps,\n\t\t     struct sock *sk, int tstype)\n{\n\tstruct sk_buff *skb;\n\tbool tsonly;\n\tif (!sk)\n\t\treturn;\n\ttsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY;\n\tif (!skb_may_tx_timestamp(sk, tsonly))\n\t\treturn;\n\tif (tsonly) {\n#ifdef CONFIG_INET\n\t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&\n\t\t    sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tskb = tcp_get_timestamping_opt_stats(sk);\n\t\telse\n#endif\n\t\t\tskb = alloc_skb(0, GFP_ATOMIC);\n\t} else {\n\t\tskb = skb_clone(orig_skb, GFP_ATOMIC);\n\t}\n\tif (!skb)\n\t\treturn;\n\tif (tsonly) {\n\t\tskb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags;\n\t\tskb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey;\n\t}\n\tif (hwtstamps)\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\telse\n\t\tskb->tstamp = ktime_get_real();\n\t__skb_complete_tx_timestamp(skb, sk, tstype);", "target": 1}
{"code": "GF_Err gf_isom_freeze_order(GF_ISOFile *file)\n{\n\tu32 i=0;\n\tGF_Box *box;\n\tif (!file) return GF_BAD_PARAM;\n\twhile ((box=gf_list_enum(file->TopBoxes, &i))) {\n\t\tgf_isom_box_freeze_order(box);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int __adpt_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tint rcode;\n\tchar name[32];\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tstrncpy(name, pHba->name, sizeof(name));\n\tprintk(KERN_WARNING\"%s: Hba Reset: scsi id %d: tid: %d\\n\", name, cmd->device->channel, pHba->channel[cmd->device->channel].tid);\n\trcode =  adpt_hba_reset(pHba);\n\tif(rcode == 0){\n\t\tprintk(KERN_WARNING\"%s: HBA reset complete\\n\", name);\n\t\treturn SUCCESS;\n\t} else {\n\t\tprintk(KERN_WARNING\"%s: HBA reset failed (%x)\\n\", name, rcode);\n\t\treturn FAILED;\n\t}\n}", "target": 1}
{"code": "Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "void limit_output_verbosity(int level)\n{\n\tshort info_limits[COUNT_INFO], debug_limits[COUNT_DEBUG];\n\tint j;\n\tif (level > MAX_VERBOSITY)\n\t\treturn;\n\tmemset(info_limits, 0, sizeof info_limits);\n\tmemset(debug_limits, 0, sizeof debug_limits);\n\tfor (j = 1; j <= level; j++) {\n\t\tparse_output_words(info_words, info_limits, info_verbosity[j], LIMIT_PRIORITY);\n\t\tparse_output_words(debug_words, debug_limits, debug_verbosity[j], LIMIT_PRIORITY);\n\t}\n\tfor (j = 0; j < COUNT_INFO; j++) {\n\t\tif (info_levels[j] > info_limits[j])\n\t\t\tinfo_levels[j] = info_limits[j];\n\t}\n\tfor (j = 0; j < COUNT_DEBUG; j++) {\n\t\tif (debug_levels[j] > debug_limits[j])\n\t\t\tdebug_levels[j] = debug_limits[j];\n\t}\n}", "target": 0}
{"code": "static int mem_cgroup_charge_common(struct page *page, struct mm_struct *mm,\n\t\t\t\tgfp_t gfp_mask, enum charge_type ctype)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tunsigned int nr_pages = 1;\n\tstruct page_cgroup *pc;\n\tbool oom = true;\n\tint ret;\n\tif (PageTransHuge(page)) {\n\t\tnr_pages <<= compound_order(page);\n\t\tVM_BUG_ON(!PageTransHuge(page));\n\t\toom = false;\n\t}\n\tpc = lookup_page_cgroup(page);\n\tret = __mem_cgroup_try_charge(mm, gfp_mask, nr_pages, &memcg, oom);\n\tif (ret == -ENOMEM)\n\t\treturn ret;\n\t__mem_cgroup_commit_charge(memcg, page, nr_pages, pc, ctype);\n\treturn 0;\n}", "target": 0}
{"code": "    PreviewImage::PreviewImage(const PreviewImage& rhs)\n    {\n        properties_ = rhs.properties_;\n        pData_ = new byte[rhs.size_];\n        memcpy(pData_, rhs.pData_, rhs.size_);\n        size_ = rhs.size_;\n    }", "target": 0}
{"code": "*/\nPHP_FUNCTION(timezone_version_get)\n{\n\tconst timelib_tzdb *tzdb;\n\ttzdb = DATE_TIMEZONEDB;\n\tRETURN_STRING(tzdb->version, 1);", "target": 0}
{"code": "void WasmBinaryBuilder::visitRefFunc(RefFunc* curr) {\n  BYN_TRACE(\"zz node: RefFunc\\n\");\n  Index index = getU32LEB();\n  functionRefs[index].push_back(curr);\n  curr->finalize(Type(getTypeByFunctionIndex(index), NonNullable));\n}", "target": 0}
{"code": "midi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int offs, int count, int pmgr_flag)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\tleave_sysex(dev);\n\tif (!prefix_cmd(orig_dev, 0xf0))\n\t\treturn 0;\n\tif (format != SYSEX_PATCH)\n\t{\n\t\t  return -EINVAL;\n\t}\n\tif (count < hdr_size)\n\t{\n\t\treturn -EINVAL;\n\t}\n\tcount -= hdr_size;\n\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n\t\treturn -EFAULT;\n \tif (count < sysex.len)\n\t{\n\t\tsysex.len = count;\n\t}\n  \tleft = sysex.len;\n  \tsrc_offs = 0;\n\tfor (i = 0; i < left && !signal_pending(current); i++)\n\t{\n\t\tunsigned char   data;\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\t\teox_seen = (i > 0 && data & 0x80);\t\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}", "target": 1}
{"code": "int sysctl_schedstats(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_schedstats);\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_schedstats(state);\n\treturn err;\n}", "target": 0}
{"code": "TEST(HeaderMapImplTest, TestAppendHeader) {\n  {\n    TestRequestHeaderMapImpl headers;\n    LowerCaseString foo(\"key1\");\n    headers.addCopy(foo, \"some;\");\n    headers.appendCopy(foo, \"test\");\n    EXPECT_EQ(headers.get(foo)->value().getStringView(), \"some;,test\");\n  }\n  {\n    TestRequestHeaderMapImpl headers;\n    LowerCaseString key2(\"key2\");\n    headers.appendCopy(key2, \"my tag data\");\n    EXPECT_EQ(headers.get(key2)->value().getStringView(), \"my tag data\");\n  }\n  {\n    TestRequestHeaderMapImpl headers;\n    LowerCaseString key3(\"key3\");\n    headers.addCopy(key3, \"empty\");\n    headers.appendCopy(key3, \"\");\n    EXPECT_EQ(headers.get(key3)->value().getStringView(), \"empty\");\n  }\n  {\n    TestRequestHeaderMapImpl headers;\n    const std::string empty;\n    headers.setPath(empty);\n    headers.appendPath(\" \", \",\");\n    headers.setPath(0);\n    EXPECT_EQ(\"0\", headers.getPathValue());\n    EXPECT_EQ(1U, headers.Path()->value().size());\n  }\n  {\n    TestRequestHeaderMapImpl headers;\n    headers.addCopy(Headers::get().Via, \"1.0 fred\");\n    EXPECT_EQ(headers.getViaValue(), \"1.0 fred\");\n    headers.appendCopy(Headers::get().Via, \"1.1 p.example.net\");\n    EXPECT_EQ(headers.getViaValue(), \"1.0 fred,1.1 p.example.net\");\n    headers.appendVia(\"1.1 new.example.net\", \",\");\n    EXPECT_EQ(headers.getViaValue(), \"1.0 fred,1.1 p.example.net,1.1 new.example.net\");\n  }\n}", "target": 0}
{"code": "int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \"Count: \" << count << \" DataTypeSize: \" << size;\n  return count * size;\n}", "target": 1}
{"code": "GF_Err traf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tGF_Err e = gf_isom_box_array_read(s, bs, traf_on_child_box);\n\tif (e) return e;\n\tif (!ptr->tfhd) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackFragmentHeaderBox \\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "Value ExpressionRandom::evaluate(const Document& root, Variables* variables) const {\n    return Value(getRandomValue());\n}", "target": 0}
{"code": "static void blk_mq_add_queue_tag_set(struct blk_mq_tag_set *set,\n\t\t\t\t     struct request_queue *q)\n{\n\tq->tag_set = set;\n\tmutex_lock(&set->tag_list_lock);\n\tlist_add_tail(&q->tag_set_list, &set->tag_list);\n\tblk_mq_update_tag_set_depth(set);\n\tmutex_unlock(&set->tag_list_lock);\n}", "target": 0}
{"code": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  insertByKey(std::move(key), std::move(value));\n}", "target": 0}
{"code": "node_new_ctype(int type, int not, OnigOptionType options)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n  NODE_SET_TYPE(node, NODE_CTYPE);\n  CTYPE_(node)->ctype   = type;\n  CTYPE_(node)->not     = not;\n  CTYPE_(node)->options = options;\n  CTYPE_(node)->ascii_mode = IS_ASCII_MODE_CTYPE_OPTION(type, options);\n  return node;\n}", "target": 0}
{"code": "    template<typename t, typename tc>\n    CImg<T>& draw_axis(const int x, const CImg<t>& values_y,\n                       const tc *const color, const float opacity=1,\n                       const unsigned int pattern=~0U, const unsigned int font_height=13,\n                       const bool allow_zero=true) {\n      if (is_empty()) return *this;\n      int siz = (int)values_y.size() - 1;\n      CImg<charT> txt(32);\n      CImg<T> label;\n      if (siz<=0) { \n        draw_line(x,0,x,_height - 1,color,opacity,pattern);\n        if (!siz) {\n          cimg_snprintf(txt,txt._width,\"%g\",(double)*values_y);\n          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);\n          const int\n            _yt = (height() - label.height())/2,\n            yt = _yt<0?0:_yt + label.height()>=height()?height() - 1-label.height():_yt,\n            _xt = x - 2 - label.width(),\n            xt = _xt>=0?_xt:x + 3;\n          draw_point(x - 1,height()/2,color,opacity).draw_point(x + 1,height()/2,color,opacity);\n          if (allow_zero || *txt!='0' || txt[1]!=0)\n            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);\n        }\n      } else { \n        if (values_y[0]<values_y[siz]) draw_arrow(x,0,x,_height - 1,color,opacity,30,5,pattern);\n        else draw_arrow(x,_height - 1,x,0,color,opacity,30,5,pattern);\n        cimg_foroff(values_y,y) {\n          cimg_snprintf(txt,txt._width,\"%g\",(double)values_y(y));\n          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);\n          const int\n            yi = (int)(y*(_height - 1)/siz),\n            _yt = yi - label.height()/2,\n            yt = _yt<0?0:_yt + label.height()>=height()?height() - 1-label.height():_yt,\n            _xt = x - 2 - label.width(),\n            xt = _xt>=0?_xt:x + 3;\n          draw_point(x - 1,yi,color,opacity).draw_point(x + 1,yi,color,opacity);\n          if (allow_zero || *txt!='0' || txt[1]!=0)\n            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);\n        }\n      }\n      return *this;", "target": 0}
{"code": "bool OSD::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t       bool& isvalid, CryptoKey& session_key)\n{\n  AuthAuthorizeHandler *authorize_handler = 0;\n  switch (peer_type) {\n  case CEPH_ENTITY_TYPE_MDS:\n  case CEPH_ENTITY_TYPE_OSD:\n  case CEPH_ENTITY_TYPE_MGR:\n    authorize_handler = authorize_handler_cluster_registry->get_handler(protocol);\n    break;\n  default:\n    authorize_handler = authorize_handler_service_registry->get_handler(protocol);\n  }\n  if (!authorize_handler) {\n    dout(0) << \"No AuthAuthorizeHandler found for protocol \" << protocol << dendl;\n    isvalid = false;\n    return true;\n  }\n  AuthCapsInfo caps_info;\n  EntityName name;\n  uint64_t global_id;\n  uint64_t auid = CEPH_AUTH_UID_DEFAULT;\n  RotatingKeyRing *keys = monc->rotating_secrets.get();\n  if (keys) {\n    isvalid = authorize_handler->verify_authorizer(\n      cct, keys,\n      authorizer_data, authorizer_reply, name, global_id, caps_info, session_key,\n      &auid);\n  } else {\n    dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n    isvalid = false;\n  }\n  if (isvalid) {\n    Session *s = static_cast<Session *>(con->get_priv());\n    if (!s) {\n      s = new Session(cct);\n      con->set_priv(s->get());\n      s->con = con;\n      dout(10) << \" new session \" << s << \" con=\" << s->con << \" addr=\" << s->con->get_peer_addr() << dendl;\n    }\n    s->entity_name = name;\n    if (caps_info.allow_all)\n      s->caps.set_allow_all();\n    s->auid = auid;\n    if (caps_info.caps.length() > 0) {\n      bufferlist::iterator p = caps_info.caps.begin();\n      string str;\n      try {\n\t::decode(str, p);\n      }\n      catch (buffer::error& e) {\n      }\n      bool success = s->caps.parse(str);\n      if (success)\n\tdout(10) << \" session \" << s << \" \" << s->entity_name << \" has caps \" << s->caps << \" '\" << str << \"'\" << dendl;\n      else\n\tdout(10) << \" session \" << s << \" \" << s->entity_name << \" failed to parse caps '\" << str << \"'\" << dendl;\n    }\n    s->put();\n  }\n  return true;\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext   *ctx     = inlink->dst;\n    FieldOrderContext *s       = ctx->priv;\n    AVFilterLink      *outlink = ctx->outputs[0];\n    int h, plane, line_step, line_size, line;\n    uint8_t *data;\n    if (!frame->interlaced_frame ||\n        frame->top_field_first == s->dst_tff)\n        return ff_filter_frame(outlink, frame);\n    av_dlog(ctx,\n            \"picture will move %s one line\\n\",\n            s->dst_tff ? \"up\" : \"down\");\n    h = frame->height;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        line_step = frame->linesize[plane];\n        line_size = s->line_size[plane];\n        data = frame->data[plane];\n        if (s->dst_tff) {\n            for (line = 0; line < h; line++) {\n                if (1 + line < frame->height) {\n                    memcpy(data, data + line_step, line_size);\n                } else {\n                    memcpy(data, data - line_step - line_step, line_size);\n                }\n                data += line_step;\n            }\n        } else {\n            data += (h - 1) * line_step;\n            for (line = h - 1; line >= 0 ; line--) {\n                if (line > 0) {\n                    memcpy(data, data - line_step, line_size);\n                } else {\n                    memcpy(data, data + line_step + line_step, line_size);\n                }\n                data -= line_step;\n            }\n        }\n    }\n    frame->top_field_first = s->dst_tff;\n    return ff_filter_frame(outlink, frame);\n}", "target": 1}
{"code": "  explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES(\n        ctx, num_threads_ > 0,\n        errors::InvalidArgument(\"`num_threads` must be greater than zero.\"));\n  }", "target": 1}
{"code": "  virtual void visit_field(Item_field *item)\n  {\n    st_select_lex *sel;\n    for (sel= current_select;\n         sel ;\n         sel= (sel->context.outer_context ?\n               sel->context.outer_context->select_lex:\n               NULL))\n    {\n      List_iterator<TABLE_LIST> li(sel->leaf_tables);\n      TABLE_LIST *tbl;\n      while ((tbl= li++))\n      {\n        if (tbl->table == item->field->table)\n        {\n          if (sel != current_select)\n            mark_as_dependent(thd, sel, current_select, item, item);\n          return;\n        }\n      }\n    }\n  }", "target": 0}
{"code": "static CustomStreamInfo *TIFFAcquireCustomStreamForWriting(\n  PhotoshopProfile *profile,ExceptionInfo *exception)\n{\n  CustomStreamInfo\n    *custom_stream;\n  custom_stream=AcquireCustomStreamInfo(exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return(custom_stream);\n  SetCustomStreamData(custom_stream,(void *) profile);\n  SetCustomStreamWriter(custom_stream,TIFFWriteCustomStream);\n  SetCustomStreamSeeker(custom_stream,TIFFSeekCustomStream);\n  SetCustomStreamTeller(custom_stream,TIFFTellCustomStream);\n  return(custom_stream);\n}", "target": 0}
{"code": "static int tls12_find_nid(int id, tls12_lookup *table, size_t tlen)\n{\n    size_t i;\n    for (i = 0; i < tlen; i++) {\n        if ((table[i].id) == id)\n            return table[i].nid;\n    }\n    return NID_undef;\n}", "target": 0}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool IsReshapeOpSupported(const TfLiteRegistration* registration,\n                          const TfLiteNode* node, TfLiteContext* context,\n                          int coreml_version) {\n  if (coreml_version >= 3) {\n    return false;\n  }\n  if (node->inputs->size == 1) {\n    const auto* params =\n        reinterpret_cast<TfLiteReshapeParams*>(node->builtin_data);\n    return params->num_dimensions == 3 || params->num_dimensions == 4;\n  }\n  const int kShapeTensor = 1;\n  const auto* shape = GetInput(context, node, kShapeTensor);\n  if (shape->allocation_type != kTfLiteMmapRo) {\n    TF_LITE_KERNEL_LOG(context, \"Reshape has non-const shape.\");\n    return false;\n  }\n  const bool is_shape_tensor =\n      shape->dims->size == 1 && shape->type == kTfLiteInt32;\n  return is_shape_tensor &&\n         (shape->dims->data[0] == 3 || shape->dims->data[0] == 4);\n}", "target": 1}
{"code": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page->index,\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}", "target": 1}
{"code": "static void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MagickPathExtent];\n  ExceptionInfo\n    *exception;\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}", "target": 0}
{"code": "      static double mp_diag(_cimg_math_parser& mp) {\n        double *ptrd = &_mp_arg(1) + 1;\n        const double *ptrs = &_mp_arg(2) + 1;\n        const unsigned int k = (unsigned int)mp.opcode[3];\n        CImg<doubleT>(ptrd,k,k,1,1,true) = CImg<doubleT>(ptrs,1,k,1,1,true).get_diagonal();\n        return cimg::type<double>::nan();", "target": 0}
{"code": "static char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}", "target": 1}
{"code": "void FrameLoader::resetMultipleFormSubmissionProtection()\n{\n    m_submittedFormURL = KURL();\n}", "target": 0}
{"code": "RegexMatchExpression::RegexMatchExpression(StringData path, const BSONElement& e)\n    : LeafMatchExpression(REGEX, path),\n      _regex(e.regex()),\n      _flags(e.regexFlags()),\n      _re(new pcrecpp::RE(_regex.c_str(), flags2options(_flags.c_str()))) {\n    uassert(ErrorCodes::BadValue, \"regex not a regex\", e.type() == RegEx);\n    _init();\n}", "target": 0}
{"code": "    TiffIfdMakernote* TiffIfdMakernote::doClone() const\n    {\n        assert(false); \n        return 0;\n    }", "target": 0}
{"code": "void encode(ArgumentEncoder* encoder, CFNumberRef number)\n{\n    CFNumberType numberType = CFNumberGetType(number);\n    Vector<uint8_t> buffer(CFNumberGetByteSize(number));\n    bool result = CFNumberGetValue(number, numberType, buffer.data());\n    ASSERT_UNUSED(result, result);\n    encoder->encodeEnum(numberType);\n    encoder->encodeVariableLengthByteArray(buffer);\n}", "target": 0}
{"code": "static int decode_attr_security_label(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n\tuint32_t pi = 0;\n\tuint32_t lfs = 0;\n\t__u32 len;\n\t__be32 *p;\n\tint status = 0;\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_SECURITY_LABEL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlfs = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tpi = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tif (len < NFS4_MAXLABELLEN) {\n\t\t\tif (label) {\n\t\t\t\tmemcpy(label->label, p, len);\n\t\t\t\tlabel->len = len;\n\t\t\t\tlabel->pi = pi;\n\t\t\t\tlabel->lfs = lfs;\n\t\t\t\tstatus = NFS_ATTR_FATTR_V4_SECURITY_LABEL;\n\t\t\t}\n\t\t\tbitmap[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: label too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t}\n\tif (label && label->label)\n\t\tdprintk(\"%s: label=%s, len=%d, PI=%d, LFS=%d\\n\", __func__,\n\t\t\t(char *)label->label, label->len, label->pi, label->lfs);\n\treturn status;\n}", "target": 1}
{"code": "static pyc_object *get_long_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tbool neg = false;\n\tut32 tmp = 0;\n\tsize_t size;\n\tsize_t i, j = 0, left = 0;\n\tut32 n;\n\tchar *hexstr;\n\tchar digist2hex[] = \"0123456789abcdef\";\n\tst32 ndigits = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_LONG;\n\tif (ndigits < 0) {\n\t\tndigits = -ndigits;\n\t\tneg = true;\n\t}\n\tif (ndigits == 0) {\n\t\tret->data = strdup(\"0x0\");\n\t} else {\n\t\tsize = ndigits * 15;\n\t\tsize = (size - 1) / 4 + 1;\n\t\tsize += 4 + (neg ? 1 : 0);\n\t\thexstr = malloc(size);\n\t\tif (!hexstr) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemset(hexstr, 0x20, size);\n\t\tj = size - 1;\n\t\thexstr[j] = 0;\n\t\tfor (i = 0; i < ndigits; i++) {\n\t\t\tn = get_ut16(buffer, &error);\n\t\t\ttmp |= n << left;\n\t\t\tleft += 15;\n\t\t\twhile (left >= 4) {\n\t\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t\t\ttmp >>= 4;\n\t\t\t\tleft -= 4;\n\t\t\t}\n\t\t}\n\t\tif (tmp) {\n\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t}\n\t\thexstr[--j] = 'x';\n\t\thexstr[--j] = '0';\n\t\tif (neg) {\n\t\t\thexstr[--j] = '-';\n\t\t}\n\t\trz_str_trim(hexstr);\n\t\tret->data = hexstr;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "bool HTMLMediaElement::IsHLSURL(const KURL& url) {\n  if (url.IsNull() || url.IsEmpty())\n    return false;\n  if (!url.IsLocalFile() && !url.ProtocolIs(\"http\") && !url.ProtocolIs(\"https\"))\n    return false;\n  return url.GetString().Contains(\"m3u8\");\n}", "target": 0}
{"code": "ppp_unregister_channel(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tstruct ppp_net *pn;\n\tif (!pch)\n\t\treturn;\t\t\n\tchan->ppp = NULL;\n\tdown_write(&pch->chan_sem);\n\tspin_lock_bh(&pch->downl);\n\tpch->chan = NULL;\n\tspin_unlock_bh(&pch->downl);\n\tup_write(&pch->chan_sem);\n\tppp_disconnect_channel(pch);\n\tpn = ppp_pernet(pch->chan_net);\n \tspin_lock_bh(&pn->all_channels_lock);\n \tlist_del(&pch->list);\n \tspin_unlock_bh(&pn->all_channels_lock);\n \tpch->file.dead = 1;\n \twake_up_interruptible(&pch->file.rwait);\n\tif (atomic_dec_and_test(&pch->file.refcnt))\n\t\tppp_destroy_channel(pch);\n}", "target": 1}
{"code": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstrncpy(full_path, vol->UNC, unc_len);\n \tpos = full_path + unc_len;\n \tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n \t\tpos += pplen;\n \t}\n\t*pos = '\\0'; \n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}", "target": 1}
{"code": "const GURL& WebContentsImpl::GetURL() const {\n  NavigationEntry* entry = controller_.GetVisibleEntry();\n  return entry ? entry->GetVirtualURL() : GURL::EmptyGURL();\n}", "target": 0}
{"code": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n     }\n     if (oldcode == -1) {\n \t*(*fill)++ = suffix[code];\n \tfirstchar = oldcode = code;\n \treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n    incode = code;\n    if (code == avail) {      \n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}", "target": 1}
{"code": " void EnsureInitializeForAndroidLayoutTests() {\n  CHECK(CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree));\n   JNIEnv* env = base::android::AttachCurrentThread();\n   content::NestedMessagePumpAndroid::RegisterJni(env);\n   content::RegisterNativesImpl(env);\n  bool success = base::MessageLoop::InitMessagePumpForUIFactory(\n      &CreateMessagePumpForUI);\n  CHECK(success) << \"Unable to initialize the message pump for Android.\";\n  base::FilePath files_dir(GetTestFilesDirectory(env));\n  base::FilePath stdout_fifo(files_dir.Append(FILE_PATH_LITERAL(\"test.fifo\")));\n  EnsureCreateFIFO(stdout_fifo);\n  base::FilePath stderr_fifo(\n      files_dir.Append(FILE_PATH_LITERAL(\"stderr.fifo\")));\n  EnsureCreateFIFO(stderr_fifo);\n  base::FilePath stdin_fifo(files_dir.Append(FILE_PATH_LITERAL(\"stdin.fifo\")));\n  EnsureCreateFIFO(stdin_fifo);\n  success = base::android::RedirectStream(stdout, stdout_fifo, \"w\") &&\n            base::android::RedirectStream(stdin, stdin_fifo, \"r\") &&\n            base::android::RedirectStream(stderr, stderr_fifo, \"w\");\n  CHECK(success) << \"Unable to initialize the Android FIFOs.\";\n}", "target": 1}
{"code": "GF_Err vpcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\treturn gf_odf_vp_cfg_write_bs(ptr->config, bs, ptr->version == 0);\n}", "target": 0}
{"code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "int button_open(Button *b) {\n        char *p, name[256];\n        int r;\n        assert(b);\n        b->fd = safe_close(b->fd);\n        p = strjoina(\"/dev/input/\", b->name);\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n        (void) button_set_mask(b);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n        return 0;\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}", "target": 1}
{"code": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\tfq->flush_pending_idx ^= 1;\n\tblk_rq_init(q, flush_rq);\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\treturn blk_flush_queue_rq(flush_rq, false);\n}", "target": 1}
{"code": "char *enl_ipc_get(const char *msg_data)\n {\n \tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n \tchar buff[13], *ret_msg = NULL;\n \tregister unsigned char i;\n \tunsigned char blen;\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}", "target": 1}
{"code": "status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)\n{\n const sp<ProcessState> proc(ProcessState::self());\n status_t err;\n const uint8_t *data = parcel->mData;\n const binder_size_t *objects = parcel->mObjects;\n size_t size = parcel->mObjectsSize;\n int startPos = mDataPos;\n int firstIndex = -1, lastIndex = -2;\n if (len == 0) {\n return NO_ERROR;\n }\n if ((offset > parcel->mDataSize)\n || (len > parcel->mDataSize)\n || (offset + len > parcel->mDataSize)) {\n return BAD_VALUE;\n }\n     for (int i = 0; i < (int) size; i++) {\n         size_t off = objects[i];\n        if ((off >= offset) && (off < offset + len)) {\n             if (firstIndex == -1) {\n                 firstIndex = i;\n             }\n            lastIndex = i;\n }\n }\n int numObjects = lastIndex - firstIndex + 1;\n if ((mDataSize+len) > mDataCapacity) {\n        err = growData(len);\n if (err != NO_ERROR) {\n return err;\n }\n }\n    memcpy(mData + mDataPos, data + offset, len);\n    mDataPos += len;\n    mDataSize += len;\n    err = NO_ERROR;\n if (numObjects > 0) {\n if (mObjectsCapacity < mObjectsSize + numObjects) {\n int newSize = ((mObjectsSize + numObjects)*3)/2;\n binder_size_t *objects =\n (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));\n if (objects == (binder_size_t*)0) {\n return NO_MEMORY;\n }\n            mObjects = objects;\n            mObjectsCapacity = newSize;\n }\n int idx = mObjectsSize;\n for (int i = firstIndex; i <= lastIndex; i++) {\n size_t off = objects[i] - offset + startPos;\n            mObjects[idx++] = off;\n            mObjectsSize++;\n            flat_binder_object* flat\n = reinterpret_cast<flat_binder_object*>(mData + off);\n            acquire_object(proc, *flat, this);\n if (flat->type == BINDER_TYPE_FD) {\n                flat->handle = dup(flat->handle);\n                flat->cookie = 1;\n                mHasFds = mFdsKnown = true;\n if (!mAllowFds) {\n                    err = FDS_NOT_ALLOWED;\n }\n }\n }\n }\n return err;\n}", "target": 1}
{"code": "static void nested_mark_vmcs12_pages_dirty(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tgfn_t gfn;\n\tif (nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW)) {\n\t\tgfn = vmcs12->virtual_apic_page_addr >> PAGE_SHIFT;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n\tif (nested_cpu_has_posted_intr(vmcs12)) {\n\t\tgfn = vmcs12->posted_intr_desc_addr >> PAGE_SHIFT;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n}", "target": 0}
{"code": "unsigned char *base64decode(const char *buf, size_t *size)\n{\n\tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tsize_t l = 0;\n\tdo {\n\t\tptr += strspn(ptr, \"\\r\\n\\t \");\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tl = strcspn(ptr, \"\\r\\n\\t \");\n\t\tif (l > 3 && ptr+l <= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}", "target": 1}
{"code": "pkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n    *valid_kdcPkId = 0;\n     pkiDebug(\"found kdcPkId in AS REQ\\n\");\n     is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n     if (is == NULL)\n        goto cleanup;\n     status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n     if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n     }\n     retval = 0;\ncleanup:\n     X509_NAME_free(is->issuer);\n     ASN1_INTEGER_free(is->serial);\n     free(is);\n    return retval;\n}", "target": 1}
{"code": "lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n    return EXIT_FAILURE;\n}", "target": 1}
{"code": "onig_reg_init(regex_t* reg, OnigOptionType option,\n\t      OnigCaseFoldType case_fold_flag,\n\t      OnigEncoding enc, const OnigSyntaxType* syntax)\n{\n  if (! onig_inited)\n    onig_init();\n  if (IS_NULL(reg))\n    return ONIGERR_INVALID_ARGUMENT;\n  if (ONIGENC_IS_UNDEF(enc))\n    return ONIGERR_DEFAULT_ENCODING_IS_NOT_SETTED;\n  if ((option & (ONIG_OPTION_DONT_CAPTURE_GROUP|ONIG_OPTION_CAPTURE_GROUP))\n      == (ONIG_OPTION_DONT_CAPTURE_GROUP|ONIG_OPTION_CAPTURE_GROUP)) {\n    return ONIGERR_INVALID_COMBINATION_OF_OPTIONS;\n  }\n  (reg)->state = ONIG_STATE_MODIFY;\n  if ((option & ONIG_OPTION_NEGATE_SINGLELINE) != 0) {\n    option |= syntax->options;\n    option &= ~ONIG_OPTION_SINGLELINE;\n  }\n  else\n    option |= syntax->options;\n  (reg)->enc              = enc;\n  (reg)->options          = option;\n  (reg)->syntax           = syntax;\n  (reg)->optimize         = 0;\n  (reg)->exact            = (UChar* )NULL;\n  (reg)->int_map          = (int* )NULL;\n  (reg)->int_map_backward = (int* )NULL;\n  (reg)->chain            = (regex_t* )NULL;\n  (reg)->p                = (UChar* )NULL;\n  (reg)->alloc            = 0;\n  (reg)->used             = 0;\n  (reg)->name_table       = (void* )NULL;\n  (reg)->case_fold_flag   = case_fold_flag;\n  return 0;\n}", "target": 0}
{"code": "void nl80211_send_remain_on_channel_cancel(\n\tstruct cfg80211_registered_device *rdev,\n\tstruct wireless_dev *wdev,\n\tu64 cookie, struct ieee80211_channel *chan, gfp_t gfp)\n{\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}", "target": 0}
{"code": "  bool AddCallback(GetUsageAndQuotaCallback* callback, bool unlimited) {\n    if (unlimited)\n      unlimited_callbacks_.push_back(callback);\n    else\n      callbacks_.push_back(callback);\n    return (callbacks_.size() + unlimited_callbacks_.size() == 1);\n  }", "target": 0}
{"code": "int git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_buf tree = GIT_BUF_INIT;\n\tgit_odb *odb;\n\tassert(bld);\n\tgit_vector_sort(&bld->entries);\n\terror = git_buf_grow(&tree, bld->entries.length * 72);\n\tfor (i = 0; i < bld->entries.length && !error; ++i) {\n\t\tgit_tree_entry *entry = git_vector_get(&bld->entries, i);\n\t\tif (entry->removed)\n\t\t\tcontinue;\n\t\tgit_buf_printf(&tree, \"%o \", entry->attr);\n\t\tgit_buf_put(&tree, entry->filename, entry->filename_len + 1);\n\t\tgit_buf_put(&tree, (char *)entry->oid.id, GIT_OID_RAWSZ);\n\t\tif (git_buf_oom(&tree))\n\t\t\terror = -1;\n\t}\n\tif (!error &&\n\t\t!(error = git_repository_odb__weakptr(&odb, repo)))\n\t\terror = git_odb_write(oid, odb, tree.ptr, tree.size, GIT_OBJ_TREE);\n\tgit_buf_free(&tree);\n\treturn error;\n}", "target": 0}
{"code": "   static void  Ins_JMPR( INS_ARG )\n   {\n     CUR.IP      += (Int)(args[0]);\n     CUR.step_ins = FALSE;\n     * allow for simple cases here by just checking the preceding byte.\n     * Fonts with this problem are not uncommon.\n     */\n      CUR.IP -= 1;\n  }", "target": 1}
{"code": "  UpstreamWrapper(const StreamInfo::StreamInfo& info) : info_(info) {}", "target": 0}
{"code": "int Http2Stream::DoWrite(WriteWrap* req_wrap,\n                         uv_buf_t* bufs,\n                         size_t nbufs,\n                         uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n  Http2Scope h2scope(this);\n  if (!IsWritable() || IsDestroyed()) {\n    req_wrap->Done(UV_EOF);\n    return 0;\n  }\n  Debug(this, \"queuing %d buffers to send\", id_, nbufs);\n  for (size_t i = 0; i < nbufs; ++i) {\n    queue_.emplace(nghttp2_stream_write {\n      i == nbufs - 1 ? req_wrap : nullptr,\n      bufs[i]\n    });\n    IncrementAvailableOutboundLength(bufs[i].len);\n  }\n  CHECK_NE(nghttp2_session_resume_data(**session_, id_), NGHTTP2_ERR_NOMEM);\n  return 0;\n}", "target": 1}
{"code": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}", "target": 1}
{"code": "int FoFiTrueType::setupGSUB(const char *scriptName)\n{\n  return setupGSUB(scriptName, NULL);\n}", "target": 0}
{"code": "    MemIo::MemIo(const byte* data, size_t size)\n        : p_(new Impl(data, size))\n    {\n    }", "target": 0}
{"code": "void _WM_do_control_channel_pan(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].pan = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}", "target": 0}
{"code": "static void ucvector_cleanup(void* p)\n{\n  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;\n  free(((ucvector*)p)->data);\n  ((ucvector*)p)->data = NULL;\n}", "target": 0}
{"code": "static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t     u64 param3, u64 param4)\n{\n \tint rc;\n \tu64 base_addr, size;\n \tif (flags && (flags &\n \t\t~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))\n\t\treturn -EINVAL;\n\tif (!(param_extension || acpi5))\n\t\tgoto inject;\n\tif (type & ACPI5_VENDOR_BIT) {\n\t\tif (vendor_flags != SETWA_FLAGS_MEM)\n\t\t\tgoto inject;\n\t} else if (!(type & MEM_ERROR_MASK) && !(flags & SETWA_FLAGS_MEM))\n\t\tgoto inject;\n\tbase_addr = param1 & param2;\n\tsize = ~param2 + 1;\n\tif (((param2 & PAGE_MASK) != PAGE_MASK) ||\n\t    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)\n\t\t\t\t!= REGION_INTERSECTS) &&\n\t     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)\n\t\t\t\t!= REGION_INTERSECTS)))\n\t\treturn -EINVAL;\ninject:\n\tmutex_lock(&einj_mutex);\n\trc = __einj_error_inject(type, flags, param1, param2, param3, param4);\n\tmutex_unlock(&einj_mutex);\n\treturn rc;\n}", "target": 1}
{"code": "void CharCodeToUnicode::addMapping(CharCode code, char *uStr, int n,\n\t\t\t\t   int offset) {\n  CharCode oldLen, i;\n  Unicode u;\n  char uHex[5];\n  int j;\n  if (code >= mapLen) {\n    oldLen = mapLen;\n    mapLen = (code + 256) & ~255;\n    map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode));\n    for (i = oldLen; i < mapLen; ++i) {\n      map[i] = 0;\n    }\n  }\n  if (n <= 4) {\n    if (sscanf(uStr, \"%x\", &u) != 1) {\n      error(-1, \"Illegal entry in ToUnicode CMap\");\n      return;\n    }\n    map[code] = u + offset;\n  } else {\n    if (sMapLen >= sMapSize) {\n      sMapSize = sMapSize + 16;\n      sMap = (CharCodeToUnicodeString *)\n\t       greallocn(sMap, sMapSize, sizeof(CharCodeToUnicodeString));\n    }\n    map[code] = 0;\n    sMap[sMapLen].c = code;\n    sMap[sMapLen].len = n / 4;\n    for (j = 0; j < sMap[sMapLen].len && j < maxUnicodeString; ++j) {\n      strncpy(uHex, uStr + j*4, 4);\n      uHex[4] = '\\0';\n      if (sscanf(uHex, \"%x\", &sMap[sMapLen].u[j]) != 1) {\n\terror(-1, \"Illegal entry in ToUnicode CMap\");\n      }\n    }\n    sMap[sMapLen].u[sMap[sMapLen].len - 1] += offset;\n    ++sMapLen;\n  }\n}", "target": 1}
{"code": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}", "target": 1}
{"code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\tCloseHandle(Token);\n\treturn 0;\n#else\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n#ifdef HAVE_GETSPNAM\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\tuser_password = user->pw_passwd;\n#endif\n\tif (strcmp(user_password, (char *) crypt(password, user_password)) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}", "target": 0}
{"code": "static inline void sysfs_slab_remove(struct kmem_cache *s) { }", "target": 0}
{"code": "struct file *fget(unsigned int fd)\n{\n\treturn __fget(fd, FMODE_PATH, 1);\n}", "target": 0}
{"code": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n            if (op == self) {\n                continue;\n            }\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                break;\n            }\n        }\n    }\n}", "target": 1}
{"code": "bool TensorSliceReader::CopySliceData(const string& name,\n                                      const TensorSlice& slice, T* data) const {\n  std::vector<std::pair<TensorSlice, string>> details;\n  const TensorSliceSet* tss;\n  {\n    mutex_lock l(mu_);\n    tss = FindTensorSlice(name, slice, &details);\n    if (!tss && !all_shards_loaded_) {\n      VLOG(1) << \"Did not find slice in preferred shard, loading all shards.\"\n              << name << \": \" << slice.DebugString();\n      LoadAllShards();\n      tss = FindTensorSlice(name, slice, &details);\n    }\n    if (!tss) {\n      return false;\n    }\n  }\n  string value;\n  for (const auto& x : details) {\n    const TensorSlice& slice_s = x.first;\n    const string& fname = x.second;\n    int idx = gtl::FindWithDefault(fname_to_index_, fname, -1);\n    CHECK_GE(idx, 0) << \"Failed to find the index for filename \" << fname;\n    const string key = EncodeTensorNameSlice(name, slice_s);\n    if (!sss_[idx]->Get(key, &value)) {\n      VLOG(1) << \"Failed to seek to the record for tensor \" << name\n              << \", slice \" << slice_s.DebugString()\n              << \": computed key = \" << key;\n      return false;\n    }\n    SavedTensorSlices sts;\n    if (!ParseProtoUnlimited(&sts, value)) {\n      VLOG(1) << \"Failed to parse the record for tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": computed key = \" << key;\n      return false;\n    }\n    CopyDataFromTensorSliceToTensorSlice(\n        tss->shape(), slice_s, slice,\n        checkpoint::TensorProtoData<T>(sts.data().data()), data);\n  }\n  return true;\n}", "target": 1}
{"code": "ServerApp::help()\n{\n#if WINAPI_XWINDOWS\n#  define WINAPI_ARGS \\\n    \" [--display <display>] [--no-xinitthreads]\"\n#  define WINAPI_INFO \\\n    \"      --display <display>  connect to the X server at <display>\\n\" \\\n    \"      --no-xinitthreads    do not call XInitThreads()\\n\" \\\n    \"      --screen-change-script <path>\\n\" \\\n    \"                           full path to script to run on screen change\\n\" \\\n    \"                           first argument is the new screen name\\n\"\n#else\n#  define WINAPI_ARGS \"\"\n#  define WINAPI_INFO \"\"\n#endif\n    barrier::fs::path profile_path = argsBase().m_profileDirectory;\n    if (profile_path.empty()) {\n        profile_path = barrier::DataDirectories::profile();\n    }\n    auto usr_config_path = (profile_path / barrier::fs::u8path(USR_CONFIG_NAME)).u8string();\n    auto sys_config_path = (barrier::DataDirectories::systemconfig() /\n                            barrier::fs::u8path(SYS_CONFIG_NAME)).u8string();\n    std::ostringstream buffer;\n    buffer << \"Start the barrier server component.\\n\"\n           << \"\\n\"\n           << \"Usage: \" << args().m_exename\n           << \" [--address <address>]\"\n           << \" [--config <pathname>]\"\n           << WINAPI_ARGS << HELP_SYS_ARGS << HELP_COMMON_ARGS << \"\\n\"\n           << \"\\n\"\n           << \"Options:\\n\"\n           << \"  -a, --address <address>  listen for clients on the given address.\\n\"\n           << \"  -c, --config <pathname>  use the named configuration file instead.\\n\"\n           << HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\"\n           << \"Default options are marked with a *\\n\"\n           << \"\\n\"\n           << \"The argument for --address is of the form: [<hostname>][:<port>].  The\\n\"\n           << \"hostname must be the address or hostname of an interface on the system.\\n\"\n           << \"Placing brackets around an IPv6 address is required when also specifying \\n\"\n           << \"a port number and optional otherwise. The default is to listen on all\\n\"\n           << \"interfaces using port number \" << kDefaultPort << \".\\n\"\n           << \"\\n\"\n           << \"If no configuration file pathname is provided then the first of the\\n\"\n           << \"following to load successfully sets the configuration:\\n\"\n           << \"  \" << usr_config_path << \"\\n\"\n           << \"  \" << sys_config_path << \"\\n\";\n    LOG((CLOG_PRINT \"%s\", buffer.str().c_str()));\n}", "target": 1}
{"code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\tsalsa20_ivsetup(ctx, walk.iv);\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static void store_param_double(NET *net, MYSQL_BIND *param)\n{\n  double value= *(double*) param->buffer;\n  float8store(net->write_pos, value);\n  net->write_pos+= 8;\n}", "target": 0}
{"code": "bool allow_svhandler_flash_sector(const FlashSector* sector) {\n  return sector->use == FLASH_STORAGE1 ||\n         sector->use == FLASH_STORAGE2 ||\n         sector->use == FLASH_STORAGE3 ||\n         sector->use == FLASH_UNUSED0 ||\n         sector->use == FLASH_APP;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::OnResizeOrRepaintACK(\n    const ViewHostMsg_ResizeOrRepaint_ACK_Params& params) {\n  TRACE_EVENT0(\"renderer_host\", \"RenderWidgetHostImpl::OnResizeOrRepaintACK\");\n  TimeTicks paint_start = TimeTicks::Now();\n  current_size_ = params.view_size;\n  bool is_resize_ack =\n      ViewHostMsg_ResizeOrRepaint_ACK_Flags::is_resize_ack(params.flags);\n  if (is_resize_ack) {\n    DCHECK(!g_check_for_pending_resize_ack || resize_ack_pending_);\n    resize_ack_pending_ = false;\n  }\n  bool is_repaint_ack =\n      ViewHostMsg_ResizeOrRepaint_ACK_Flags::is_repaint_ack(params.flags);\n  if (is_repaint_ack) {\n    DCHECK(repaint_ack_pending_);\n    TRACE_EVENT_ASYNC_END0(\n        \"renderer_host\", \"RenderWidgetHostImpl::repaint_ack_pending_\", this);\n    repaint_ack_pending_ = false;\n    TimeDelta delta = TimeTicks::Now() - repaint_start_time_;\n    UMA_HISTOGRAM_TIMES(\"MPArch.RWH_RepaintDelta\", delta);\n  }\n  DCHECK(!params.view_size.IsEmpty());\n  DidCompleteResizeOrRepaint(params, paint_start);\n  last_auto_resize_request_number_ = params.sequence_number;\n  if (auto_resize_enabled_) {\n    bool post_callback = new_auto_size_.IsEmpty();\n    new_auto_size_ = params.view_size;\n    if (post_callback) {\n      base::ThreadTaskRunnerHandle::Get()->PostTask(\n          FROM_HERE, base::BindOnce(&RenderWidgetHostImpl::DelayedAutoResized,\n                                    weak_factory_.GetWeakPtr()));\n    }\n  }\n  TimeDelta delta = TimeTicks::Now() - paint_start;\n  UMA_HISTOGRAM_TIMES(\"MPArch.RWH_OnMsgResizeOrRepaintACK\", delta);\n}", "target": 0}
{"code": "void Document::FinishedParsing() {\n  DCHECK(!GetScriptableDocumentParser() || !parser_->IsParsing());\n  DCHECK(!GetScriptableDocumentParser() || ready_state_ != kLoading);\n  SetParsingState(kInDOMContentLoaded);\n  DocumentParserTiming::From(*this).MarkParserStop();\n  if (!document_timing_.DomContentLoadedEventStart())\n    document_timing_.MarkDomContentLoadedEventStart();\n  DispatchEvent(Event::CreateBubble(EventTypeNames::DOMContentLoaded));\n  if (!document_timing_.DomContentLoadedEventEnd())\n    document_timing_.MarkDomContentLoadedEventEnd();\n  SetParsingState(kFinishedParsing);\n  Microtask::PerformCheckpoint(V8PerIsolateData::MainThreadIsolate());\n  ScriptableDocumentParser* parser = GetScriptableDocumentParser();\n  well_formed_ = parser && parser->WellFormed();\n  if (LocalFrame* frame = GetFrame()) {\n    if (title_.IsEmpty())\n      DispatchDidReceiveTitle();\n    const bool main_resource_was_already_requested =\n        frame->Loader().StateMachine()->CommittedFirstRealDocumentLoad();\n    if (main_resource_was_already_requested)\n      UpdateStyleAndLayoutTree();\n    BeginLifecycleUpdatesIfRenderingReady();\n    frame->Loader().FinishedParsing();\n    TRACE_EVENT_INSTANT1(\"devtools.timeline\", \"MarkDOMContent\",\n                         TRACE_EVENT_SCOPE_THREAD, \"data\",\n                         InspectorMarkLoadEvent::Data(frame));\n    probe::domContentLoadedEventFired(frame);\n    frame->GetIdlenessDetector()->DomContentLoadedEventFired();\n  }\n  element_data_cache_clear_timer_.StartOneShot(10, BLINK_FROM_HERE);\n  fetcher_->ClearPreloads(ResourceFetcher::kClearSpeculativeMarkupPreloads);\n  if (!frame_ || frame_->GetSettings()->GetSavePreviousDocumentResources() ==\n                     SavePreviousDocumentResources::kUntilOnDOMContentLoaded) {\n    fetcher_->ClearResourcesFromPreviousFetcher();\n  }\n  if (IsPrefetchOnly())\n    WebPrerenderingSupport::Current()->PrefetchFinished();\n}", "target": 0}
{"code": "int nfc_dev_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->polling || dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_down)\n\t\tdev->ops->dev_down(dev);\n\tdev->dev_up = false;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "int ssh_bind_accept_fd(ssh_bind sshbind, ssh_session session, socket_t fd){\n    int i, rc;\n    if (session == NULL){\n        ssh_set_error(sshbind, SSH_FATAL,\"session is null\");\n        return SSH_ERROR;\n    }\n    session->server = 1;\n    session->version = 2;\n    for (i = 0; i < 10; ++i) {\n      if (sshbind->wanted_methods[i]) {\n        session->opts.wanted_methods[i] = strdup(sshbind->wanted_methods[i]);\n        if (session->opts.wanted_methods[i] == NULL) {\n          return SSH_ERROR;\n        }\n      }\n    }\n    if (sshbind->bindaddr == NULL)\n      session->opts.bindaddr = NULL;\n    else {\n      SAFE_FREE(session->opts.bindaddr);\n      session->opts.bindaddr = strdup(sshbind->bindaddr);\n      if (session->opts.bindaddr == NULL) {\n        return SSH_ERROR;\n      }\n    }\n    session->common.log_verbosity = sshbind->common.log_verbosity;\n    if(sshbind->banner != NULL)\n    \tsession->opts.custombanner = strdup(sshbind->banner);\n    ssh_socket_free(session->socket);\n    session->socket = ssh_socket_new(session);\n    if (session->socket == NULL) {\n      ssh_set_error_oom(sshbind);\n      return SSH_ERROR;\n    }\n    ssh_socket_set_fd(session->socket, fd);\n    ssh_socket_get_poll_handle_out(session->socket);\n    rc = ssh_bind_import_keys(sshbind);\n    if (rc != SSH_OK) {\n      return SSH_ERROR;\n    }\n#ifdef HAVE_ECC\n    if (sshbind->ecdsa) {\n        session->srv.ecdsa_key = ssh_key_dup(sshbind->ecdsa);\n        if (session->srv.ecdsa_key == NULL) {\n          ssh_set_error_oom(sshbind);\n          return SSH_ERROR;\n        }\n    }\n#endif\n    if (sshbind->dsa) {\n        session->srv.dsa_key = ssh_key_dup(sshbind->dsa);\n        if (session->srv.dsa_key == NULL) {\n          ssh_set_error_oom(sshbind);\n          return SSH_ERROR;\n        }\n    }\n    if (sshbind->rsa) {\n        session->srv.rsa_key = ssh_key_dup(sshbind->rsa);\n        if (session->srv.rsa_key == NULL) {\n          ssh_set_error_oom(sshbind);\n          return SSH_ERROR;\n        }\n    }\n    return SSH_OK;\n}", "target": 1}
{"code": "MONGO_EXPORT gridfs_offset gridfile_read( gridfile *gfile, gridfs_offset size, char *buf ) {\n    mongo_cursor *chunks;\n    bson chunk;\n    int first_chunk;\n    int last_chunk;\n    int total_chunks;\n    gridfs_offset chunksize;\n    gridfs_offset contentlength;\n    gridfs_offset bytes_left;\n    int i;\n    bson_iterator it;\n    gridfs_offset chunk_len;\n    const char *chunk_data;\n    contentlength = gridfile_get_contentlength( gfile );\n    chunksize = gridfile_get_chunksize( gfile );\n    size = ( contentlength - gfile->pos < size )\n           ? contentlength - gfile->pos\n           : size;\n    bytes_left = size;\n    first_chunk = ( gfile->pos )/chunksize;\n    last_chunk = ( gfile->pos+size-1 )/chunksize;\n    total_chunks = last_chunk - first_chunk + 1;\n    chunks = gridfile_get_chunks( gfile, first_chunk, total_chunks );\n    for ( i = 0; i < total_chunks; i++ ) {\n        mongo_cursor_next( chunks );\n        chunk = chunks->current;\n        bson_find( &it, &chunk, \"data\" );\n        chunk_len = bson_iterator_bin_len( &it );\n        chunk_data = bson_iterator_bin_data( &it );\n        if ( i == 0 ) {\n            chunk_data += ( gfile->pos )%chunksize;\n            chunk_len -= ( gfile->pos )%chunksize;\n        }\n        if ( bytes_left > chunk_len ) {\n            memcpy( buf, chunk_data, chunk_len );\n            bytes_left -= chunk_len;\n            buf += chunk_len;\n        }\n        else {\n            memcpy( buf, chunk_data, bytes_left );\n        }\n    }\n    mongo_cursor_destroy( chunks );\n    gfile->pos = gfile->pos + size;\n    return size;\n}", "target": 1}
{"code": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t\n \tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n \t\treturn -1;\n \tif (access(spath, F_OK) != 0)\n \t\treturn -1;\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\treturn 0;\n}", "target": 1}
{"code": "    constexpr uint32_t Nikon3MnHeader::sizeOfSignature()\n    {\n        return sizeof(signature_);\n    }", "target": 0}
{"code": "bool InstanceKlass::is_same_or_direct_interface(Klass *k) const {\n  if (this == k) return true;\n  assert(k->is_interface(), \"should be an interface class\");\n  for (int i = 0; i < local_interfaces()->length(); i++) {\n    if (local_interfaces()->at(i) == k) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const CTCBeamSearchDecoderParams* option =\n      reinterpret_cast<CTCBeamSearchDecoderParams*>(node->user_data);\n  const int top_paths = option->top_paths;\n  TF_LITE_ENSURE(context, option->beam_width >= top_paths);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 3 * top_paths + 1);\n  const TfLiteTensor* inputs = GetInput(context, node, kInputsTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(inputs), 3);\n  TF_LITE_ENSURE_EQ(context, inputs->type, kTfLiteFloat32);\n  const int batch_size = SizeOfDimension(inputs, 1);\n  const TfLiteTensor* sequence_length =\n      GetInput(context, node, kSequenceLengthTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(sequence_length), 1);\n  TF_LITE_ENSURE_EQ(context, NumElements(sequence_length), batch_size);\n  TF_LITE_ENSURE_EQ(context, sequence_length->type, kTfLiteInt32);\n  for (int i = 0; i < top_paths; ++i) {\n    TfLiteTensor* indices = GetOutput(context, node, i);\n    SetTensorToDynamic(indices);\n    TfLiteTensor* values = GetOutput(context, node, i + top_paths);\n    SetTensorToDynamic(values);\n    TfLiteTensor* output_shape = GetOutput(context, node, i + 2 * top_paths);\n    SetTensorToDynamic(output_shape);\n  }\n  TfLiteTensor* log_probability_output =\n      GetOutput(context, node, top_paths * 3);\n  TfLiteIntArray* log_probability_output_shape_array = TfLiteIntArrayCreate(2);\n  log_probability_output_shape_array->data[0] = batch_size;\n  log_probability_output_shape_array->data[1] = top_paths;\n  return context->ResizeTensor(context, log_probability_output,\n                               log_probability_output_shape_array);\n}", "target": 1}
{"code": "static bool anal_fcn_data (RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\treturn -EINVAL;\n\t}\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\treturn 0;\n}", "target": 1}
{"code": "static int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"nivaead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\", aead->geniv);\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static int generate_key(DH *dh)\n{\n     int ok = 0;\n     int generate_new_key = 0;\n     unsigned l;\n    BN_CTX *ctx;\n     BN_MONT_CTX *mont = NULL;\n     BIGNUM *pub_key = NULL, *priv_key = NULL;\n     ctx = BN_CTX_new();\n     if (ctx == NULL)\n         goto err;\n        generate_new_key = 1;\n    } else", "target": 1}
{"code": "static inline unsigned int unix_hash_fold(__wsum n)\n{\n\tunsigned int hash = (__force unsigned int)csum_fold(n);\n\thash ^= hash>>8;\n\treturn hash&(UNIX_HASH_SIZE-1);\n}", "target": 0}
{"code": "static lu_mem markbeingfnz (global_State *g) {\n  GCObject *o;\n  lu_mem count = 0;\n  for (o = g->tobefnz; o != NULL; o = o->next) {\n    count++;\n    markobject(g, o);\n  }\n  return count;\n}", "target": 0}
{"code": "status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {\n     ALOGV(\"setNextPlayer\");\n     Mutex::Autolock l(mLock);\n     sp<Client> c = static_cast<Client*>(player.get());\n     mNextClient = c;\n     if (c != NULL) {\n if (mAudioOutput != NULL) {\n            mAudioOutput->setNextOutput(c->mAudioOutput);\n } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {\n            ALOGE(\"no current audio output\");\n }\n if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {\n            mPlayer->setNextPlayer(mNextClient->getPlayer());\n }\n }\n return OK;\n}", "target": 1}
{"code": "struct mb2_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}", "target": 0}
{"code": "TEST(LteOp, MatchesMaxKey) {\n    BSONObj operand = BSON(\"a\" << MaxKey);\n    LTEMatchExpression lte(\"a\", operand[\"a\"]);\n    BSONObj minKeyObj = BSON(\"a\" << MinKey);\n    BSONObj maxKeyObj = BSON(\"a\" << MaxKey);\n    BSONObj numObj = BSON(\"a\" << 4);\n    ASSERT(lte.matchesBSON(minKeyObj, NULL));\n    ASSERT(lte.matchesBSON(maxKeyObj, NULL));\n    ASSERT(lte.matchesBSON(numObj, NULL));\n    ASSERT(lte.matchesSingleElement(minKeyObj.firstElement()));\n    ASSERT(lte.matchesSingleElement(maxKeyObj.firstElement()));\n    ASSERT(lte.matchesSingleElement(numObj.firstElement()));\n}", "target": 0}
{"code": "static MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n  size_t\n    length,\n    row_size;\n  ssize_t\n    count,\n    y;\n  unsigned char\n    *compact_pixels,\n    *pixels;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RLE compressed\");\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < sizes[y])\n      length=(size_t) sizes[y];\n  if (length > row_size + 256) \n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"InvalidLength\",\n        image->filename);\n    }\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels));\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n    count=ReadBlob(image,(size_t) sizes[y],compact_pixels);\n    if (count != (ssize_t) sizes[y])\n      break;\n    count=DecodePSDPixels((size_t) sizes[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n    status=ReadPSDChannelPixels(image,psd_info->channels,y,type,pixels,\n      exception);\n    if (status == MagickFalse)\n      break;\n  }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}", "target": 1}
{"code": " static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n \t\t\t\t struct param_mem *mem)\n {\n \tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n \tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n \tmem->offs = READ_ONCE(rmem->offs);\n \tmem->size = READ_ONCE(rmem->size);\n \treturn TEE_SUCCESS;\n }", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    if (dtypes.size() < size_t{1}) {\n      return errors::Internal(\"Expected a list of at least one dtype\");\n    }\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "size_t jsvGetString(const JsVar *v, char *str, size_t len) {\n  assert(len>0);\n  const char *s = jsvGetConstString(v);\n  if (s) {\n     len--;\n     int l = 0;\n    while (*s && l<len) {\n       str[l] = s[l];\n       l++;\n     }\n    str[l] = 0;\n    return l;\n  } else if (jsvIsInt(v)) {\n    itostr(v->varData.integer, str, 10);\n    return strlen(str);\n  } else if (jsvIsFloat(v)) {\n    ftoa_bounded(v->varData.floating, str, len);\n    return strlen(str);\n  } else if (jsvHasCharacterData(v)) {\n    assert(!jsvIsStringExt(v));\n    size_t l = len;\n    JsvStringIterator it;\n    jsvStringIteratorNewConst(&it, v, 0);\n    while (jsvStringIteratorHasChar(&it)) {\n      if (l--<=1) {\n        *str = 0;\n        jsvStringIteratorFree(&it);\n        return len;\n      }\n      *(str++) = jsvStringIteratorGetChar(&it);\n      jsvStringIteratorNext(&it);\n    }\n    jsvStringIteratorFree(&it);\n    *str = 0;\n    return len-l;\n  } else {\n    JsVar *stringVar = jsvAsString((JsVar*)v, false); \n    if (stringVar) {\n      size_t l = jsvGetString(stringVar, str, len); \n      jsvUnLock(stringVar);\n      return l;\n    } else {\n      str[0] = 0;\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n      return 0;\n    }\n  }\n}", "target": 1}
{"code": "extract_one_file(EpubDocument* epub_document,GError ** error)\n{\n    GFile * outfile ;\n    gsize writesize = 0;\n    GString * gfilepath ;\n    unz_file_info64 info ;\n    gchar* directory;\n    GString* dir_create;\n    GFileOutputStream * outstream ;\n    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )\n    {\n            return FALSE ;\n    }\n    gboolean result = TRUE;\n    gpointer currentfilename = g_malloc0(512);\n    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;\n    directory = g_strrstr(currentfilename,\"/\") ;\n    if ( directory != NULL )\n        directory++;\n    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n    g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n    if (directory != NULL && *directory == '\\0')\n    {\n        g_mkdir(gfilepath->str,0777);\n        goto out;\n    }\n    else if (directory != NULL && *directory != '\\0' ) {\n        gchar* createdir = currentfilename;\n        gchar *createdirname = g_malloc0(strlen(currentfilename));\n        gchar *createdirnametemp = createdirname;\n        while ( createdir != directory ) {\n            (*createdirnametemp) = (*createdir);\n            createdirnametemp++;\n            createdir++;\n        }\n        (*createdirnametemp) = '\\0';\n        dir_create = g_string_new(epub_document->tmp_archive_dir);\n        g_string_append_printf(dir_create,\"/%s\",createdirname);\n        g_free(createdirname);\n        g_mkdir_with_parents(dir_create->str,0777);\n        g_string_free(dir_create,TRUE);\n    }\n    outfile = g_file_new_for_path(gfilepath->str);\n    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n    gpointer buffer = g_malloc0(512);\n    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n    {\n        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )\n        {\n            result = FALSE;\n            break;\n        }\n    }\n    g_free(buffer);\n    g_output_stream_close((GOutputStream*)outstream,NULL,error);\n    g_object_unref(outfile) ;\n    g_object_unref(outstream) ;\nout:\n    unzCloseCurrentFile (epub_document->epubDocument) ;\n    g_string_free(gfilepath,TRUE);\n    g_free(currentfilename);\n    return result;\n}", "target": 1}
{"code": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}", "target": 1}
{"code": " static char *get_pid_environ_val(pid_t pid,char *val){\n  char temp[500];\n   int i=0;\n   int foundit=0;\n   FILE *fp;\n  sprintf(temp,\"/proc/%d/environ\",pid);\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n   for(;;){\n     temp[i]=fgetc(fp);    \n     if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }\n    switch(temp[i]){\n    case EOF:\n      fclose(fp);\n      return NULL;\n    case '=':\n      temp[i]=0;\n      if(!strcmp(temp,val)){\n\tfoundit=1;\n      }\n      i=0;\n      break;\n    case '\\0':\n      i=0;\n      break;\n    default:\n      i++;\n    }\n  }\n}", "target": 1}
{"code": "DataObjectItem::DataObjectItem(ItemKind kind,\n                               const String& type,\n                               uint64_t sequence_number)\n    : source_(kClipboardSource),\n      kind_(kind),\n      type_(type),\n      sequence_number_(sequence_number) {}", "target": 0}
{"code": "cleanup_bmc_device(struct kref *ref)\n{\n\tstruct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);\n\tschedule_work(&bmc->remove_work);\n}", "target": 0}
{"code": "gfx::Point RootWindowHostLinux::QueryMouseLocation() {\n  ::Window root_return, child_return;\n  int root_x_return, root_y_return, win_x_return, win_y_return;\n  unsigned int mask_return;\n  XQueryPointer(xdisplay_,\n                xwindow_,\n                &root_return,\n                &child_return,\n                &root_x_return, &root_y_return,\n                &win_x_return, &win_y_return,\n                &mask_return);\n  return gfx::Point(max(0, min(bounds_.width(), win_x_return)),\n                    max(0, min(bounds_.height(), win_y_return)));\n}", "target": 0}
{"code": "SPL_METHOD(SplObjectStorage, count)\n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(zend_hash_num_elements(&intern->storage));\n} ", "target": 0}
{"code": "static RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmElementEntry *ptr = NULL;\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmElementEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tut32 j = 0;\n\t\twhile (i < len && j < ptr->num_elem\t) {\n\t\t\tut32 e;\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &e, &i))) {\n\t\t\t\tfree (ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr += 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "GF_Err mfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, mfra_on_child_box);\n}", "target": 0}
{"code": "  virtual bool wifi_available() const {\n    return available_devices_ & (1 << TYPE_WIFI);\n  }", "target": 0}
{"code": "rdp_out_unknown_caps(STREAM s, uint16 id, uint16 length, uint8 * caps)\n{\n\tout_uint16_le(s, id);\n\tout_uint16_le(s, length);\n\tout_uint8p(s, caps, length - 4);\n}", "target": 0}
{"code": "static void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}", "target": 0}
{"code": "exim_nullstd(void)\n{\nint i;\nint devnull = -1;\nstruct stat statbuf;\nfor (i = 0; i <= 2; i++)\n  {\n  if (fstat(i, &statbuf) < 0 && errno == EBADF)\n    {\n    if (devnull < 0) devnull = open(\"/dev/null\", O_RDWR);\n    if (devnull < 0) log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\",\n      string_open_failed(errno, \"/dev/null\"));\n    if (devnull != i) (void)dup2(devnull, i);\n    }\n  }\nif (devnull > 2) (void)close(devnull);\n}", "target": 0}
{"code": "  explicit DataFormatDimMapOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string src_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n    string dst_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Source format must of length 4 or 5, received \"\n                    \"src_format = \",\n                    src_format)));\n    OP_REQUIRES(\n        context, dst_format.size() == 4 || dst_format.size() == 5,\n        errors::InvalidArgument(strings::StrCat(\n            \"Destination format must of length 4 or 5, received dst_format = \",\n            dst_format)));\n    dst_idx_ = Tensor(DT_INT32, {static_cast<int64>(src_format.size())});\n    for (int i = 0; i < src_format.size(); ++i) {\n      for (int j = 0; j < dst_format.size(); ++j) {\n        if (dst_format[j] == src_format[i]) {\n          dst_idx_.vec<int>()(i) = j;\n          break;\n        }\n      }\n    }\n  }", "target": 1}
{"code": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}", "target": 1}
{"code": "asmlinkage long compat_sys_ppoll(struct pollfd __user *ufds,\n\tunsigned int nfds, struct compat_timespec __user *tsp,\n\tconst compat_sigset_t __user *sigmask, compat_size_t sigsetsize)\n{\n\tcompat_sigset_t ss32;\n\tsigset_t ksigmask, sigsaved;\n\tstruct compat_timespec ts;\n\ts64 timeout = -1;\n\tint ret;\n\tif (tsp) {\n\t\tif (copy_from_user(&ts, tsp, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\t\ttimeout = ROUND_UP(ts.tv_nsec, 1000000000/HZ);\n\t\ttimeout += ts.tv_sec * HZ;\n\t}\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ss32, sigmask, sizeof(ss32)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&ksigmask, &ss32);\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\tret = do_sys_poll(ufds, nfds, &timeout);\n\tif (ret == -EINTR) {\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\tsizeof(sigsaved));\n\t\t\tset_thread_flag(TIF_RESTORE_SIGMASK);\n\t\t}\n\t\tret = -ERESTARTNOHAND;\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\tif (tsp && timeout >= 0) {\n\t\tstruct compat_timespec rts;\n\t\tif (current->personality & STICKY_TIMEOUTS)\n\t\t\tgoto sticky;\n\t\trts.tv_nsec = jiffies_to_usecs(do_div((*(u64*)&timeout), HZ)) *\n\t\t\t\t\t1000;\n\t\trts.tv_sec = timeout;\n\t\tif (compat_timespec_compare(&rts, &ts) >= 0)\n\t\t\trts = ts;\n\t\tif (copy_to_user(tsp, &rts, sizeof(rts))) {\nsticky:\n\t\t\tif (ret == -ERESTARTNOHAND && timeout >= 0)\n\t\t\t\tret = -EINTR;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\treturn ip_local_out(skb);\n}", "target": 1}
{"code": "  virtual ~FFmpegVideoDecoderTest() {}", "target": 0}
{"code": "static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n \t\tdouble dTotalWeight = 0.0;\n \t\tint iSrc;\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n \t\tif (iRight - iLeft + 1 > windows_size)  {\n \t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n \t\t\t}\n \t\t}\n \t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n \t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n \t\t}\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static void _ewk_view_zoom_animated_mark_stop(Ewk_View_Smart_Data* smartData)\n{\n    smartData->animated_zoom.zoom.start = 0.0;\n    smartData->animated_zoom.zoom.end = 0.0;\n    smartData->animated_zoom.zoom.current = 0.0;\n}", "target": 0}
{"code": "static const char *req_canonical_filename_field(request_rec *r)\n{\n    return r->canonical_filename;\n}", "target": 0}
{"code": "static inline ut64 dwarf_read_address(size_t size, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\t\tcase 2:\n\t\tresult = READ16 (*buf); break;\n\t\tcase 4:\n\t\tresult = READ32 (*buf); break;\n\t\tcase 8:\n\t\tresult = READ64 (*buf); break;\n\t\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf (\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn;\n\t}\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn;\n\t}\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\nfreeargb:\n\tgdFree(argb);\n}", "target": 1}
{"code": "unsigned AccessibilityUIElement::indexOfChild(AccessibilityUIElement* element)\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return 0;\n    Vector<RefPtr<AccessibilityUIElement> > children;\n    getChildren(children);\n    unsigned count = children.size();\n    for (unsigned i = 0; i < count; i++)\n        if (children[i]->isEqual(element))\n            return i;\n    return 0;\n}", "target": 0}
{"code": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n \tflush_altivec_to_thread(src);\n \tflush_vsx_to_thread(src);\n \tflush_spe_to_thread(src);\n \t*dst = *src;\n\tclear_task_ebb(dst);\n\treturn 0;\n}", "target": 1}
{"code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n \t\t    info->cmap.len || cmap->start < info->cmap.start)\n \t\t\treturn -EINVAL;\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n \t\tif (!entries)\n \t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}", "target": 1}
{"code": "u64 gf_isom_get_first_mdat_start(GF_ISOFile *movie)\n{\n\tu64 offset;\n\tif (!movie) return 0;\n\toffset = movie->first_data_toplevel_offset + 8;\n\tif (movie->first_data_toplevel_size > 0xFFFFFFFFUL)\n\t\toffset += 8;\n\treturn offset;\n}", "target": 0}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "static int __init init_vdso(void)\n{\n\tinit_vdso_image(&vdso_image_64);\n#ifdef CONFIG_X86_X32_ABI\n\tinit_vdso_image(&vdso_image_x32);\n#endif\n\tcpu_notifier_register_begin();\n\ton_each_cpu(vgetcpu_cpu_init, NULL, 1);\n\t__hotcpu_notifier(vgetcpu_cpu_notifier, 30);\n\tcpu_notifier_register_done();\n\treturn 0;\n}", "target": 0}
{"code": "bt_status_t btif_dm_pin_reply( const bt_bdaddr_t *bd_addr, uint8_t accept,\n                                uint8_t pin_len, bt_pin_code_t *pin_code)\n {\n     BTIF_TRACE_EVENT(\"%s: accept=%d\", __FUNCTION__, accept);\n    if (pin_code == NULL)\n         return BT_STATUS_FAIL;\n #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))\n if (pairing_cb.is_le_only)\n {\n int i;\n        UINT32 passkey = 0;\n int multi[] = {100000, 10000, 1000, 100, 10,1};\n        BD_ADDR remote_bd_addr;\n        bdcpy(remote_bd_addr, bd_addr->address);\n for (i = 0; i < 6; i++)\n {\n            passkey += (multi[i] * (pin_code->pin[i] - '0'));\n }\n        BTIF_TRACE_DEBUG(\"btif_dm_pin_reply: passkey: %d\", passkey);\n        BTA_DmBlePasskeyReply(remote_bd_addr, accept, passkey);\n }\n else\n {\n        BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\n if (accept)\n            pairing_cb.pin_code_len = pin_len;\n }\n#else\n    BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\n if (accept)\n        pairing_cb.pin_code_len = pin_len;\n#endif\n return BT_STATUS_SUCCESS;\n}", "target": 1}
{"code": "GF_Box *reftype_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceTypeBox, GF_ISOM_BOX_TYPE_REFT);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "bool IndexedDBDatabase::ValidateObjectStoreIdAndOptionalIndexId(\n    int64_t object_store_id,\n    int64_t index_id) const {\n  if (!ValidateObjectStoreId(object_store_id))\n    return false;\n  const IndexedDBObjectStoreMetadata& object_store_metadata =\n      metadata_.object_stores.find(object_store_id)->second;\n  if (index_id != IndexedDBIndexMetadata::kInvalidId &&\n      !base::ContainsKey(object_store_metadata.indexes, index_id)) {\n    DLOG(ERROR) << \"Invalid index_id\";\n    return false;\n  }\n  return true;\n}", "target": 0}
{"code": "static int adpt_i2o_systab_send(adpt_hba* pHba)\n{\n\tu32 msg[12];\n\tint ret;\n\tmsg[0] = I2O_MESSAGE_SIZE(12) | SGL_OFFSET_6;\n\tmsg[1] = I2O_CMD_SYS_TAB_SET<<24 | HOST_TID<<12 | ADAPTER_TID;\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tmsg[4] = (0<<16) | ((pHba->unit+2) << 12); \n\tmsg[5] = 0;\t\t\t\t   \n\tmsg[6] = 0x54000000 | sys_tbl_len;\n\tmsg[7] = (u32)sys_tbl_pa;\n\tmsg[8] = 0x54000000 | 0;\n\tmsg[9] = 0;\n\tmsg[10] = 0xD4000000 | 0;\n\tmsg[11] = 0;\n\tif ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 120))) {\n\t\tprintk(KERN_INFO \"%s: Unable to set SysTab (status=%#10x).\\n\", \n\t\t\tpHba->name, ret);\n\t}\n#ifdef DEBUG\n\telse {\n\t\tPINFO(\"%s: SysTab set.\\n\", pHba->name);\n\t}\n#endif\n\treturn ret;\t\n}", "target": 1}
{"code": "create_llao(uint8_t *llao, uint8_t type)\n{\n  llao[UIP_ND6_OPT_TYPE_OFFSET] = type;\n  llao[UIP_ND6_OPT_LEN_OFFSET] = UIP_ND6_OPT_LLAO_LEN >> 3;\n  memcpy(&llao[UIP_ND6_OPT_DATA_OFFSET], &uip_lladdr, UIP_LLADDR_LEN);\n  memset(&llao[UIP_ND6_OPT_DATA_OFFSET + UIP_LLADDR_LEN], 0,\n         UIP_ND6_OPT_LLAO_LEN - 2 - UIP_LLADDR_LEN);\n}", "target": 0}
{"code": "int iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tchar *tmpptr = key + strlen(key);\n\t\t\t\t*tmpptr = '=';\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tstart += strlen(key) + strlen(value) + 2;\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\tkfree(tmpbuf);\n\treturn 0;\n}", "target": 1}
{"code": "static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n \tstruct task_io_accounting acct = task->ioac;\n \tunsigned long flags;\n \tif (whole && lock_task_sighand(task, &flags)) {\n \t\tstruct task_struct *t = task;\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}", "target": 1}
{"code": "read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n{\n  register int ch;\n  register unsigned int val;\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n  return val;\n}", "target": 1}
{"code": "void Transform::interpolate_nearestneighbour( RawTile& in, unsigned int resampled_width, unsigned int resampled_height ){\n  unsigned char *input = (unsigned char*) in.data;\n  int channels = in.channels;\n  unsigned int width = in.width;\n  unsigned int height = in.height;\n  unsigned char *output;\n  bool new_buffer = false;\n  if( resampled_width*resampled_height > in.width*in.height ){\n    new_buffer = true;\n    output = new unsigned char[(unsigned long long)resampled_width*resampled_height*in.channels];\n  }\n  else output = (unsigned char*) in.data;\n  float xscale = (float)width / (float)resampled_width;\n  float yscale = (float)height / (float)resampled_height;\n  for( unsigned int j=0; j<resampled_height; j++ ){\n    for( unsigned int i=0; i<resampled_width; i++ ){\n      unsigned long ii = (unsigned int) floorf(i*xscale);\n      unsigned long jj = (unsigned int) floorf(j*yscale);\n      unsigned long pyramid_index = (unsigned int) channels * ( ii + jj*width );\n      unsigned long long resampled_index = (unsigned long long)(i + j*resampled_width)*channels;\n      for( int k=0; k<in.channels; k++ ){\n\toutput[resampled_index+k] = input[pyramid_index+k];\n      }\n    }\n  }\n  if( new_buffer ) delete[] (unsigned char*) input;\n  in.width = resampled_width;\n  in.height = resampled_height;\n  in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);\n  in.data = output;\n}", "target": 1}
{"code": "static int __init efi_load_efivars(void)\n{\n\tstruct platform_device *pdev;\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES))\n\t\treturn 0;\n\tpdev = platform_device_register_simple(\"efivars\", 0, NULL, 0);\n\treturn PTR_ERR_OR_ZERO(pdev);\n}", "target": 0}
{"code": "void V8Window::eventAttributeGetterCustom(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    LocalFrame* frame = toLocalDOMWindow(V8Window::toImpl(info.Holder()))->frame();\n    ExceptionState exceptionState(ExceptionState::GetterContext, \"event\", \"Window\", info.Holder(), info.GetIsolate());\n    if (!BindingSecurity::shouldAllowAccessToFrame(info.GetIsolate(), frame, exceptionState)) {\n        exceptionState.throwIfNeeded();\n        return;\n    }\n    ASSERT(frame);\n    v8::Local<v8::Context> context = toV8Context(frame, DOMWrapperWorld::current(info.GetIsolate()));\n    if (context.IsEmpty())\n        return;\n    v8::Handle<v8::Value> jsEvent = V8HiddenValue::getHiddenValue(info.GetIsolate(), context->Global(), V8HiddenValue::event(info.GetIsolate()));\n    if (jsEvent.IsEmpty())\n        return;\n    v8SetReturnValue(info, jsEvent);\n}", "target": 0}
{"code": "static void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint error = 0;\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, BasicSkipNoIndex) {\n    addIndex(BSON(\"a\" << 1));\n    runQuerySkipNToReturn(BSON(\"x\" << 5), 3, 0);\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\"{skip: {n: 3, node: {cscan: {dir: 1, filter: {x: 5}}}}}\");\n}", "target": 0}
{"code": "win_free_lsize(win_T *wp)\n{\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}", "target": 0}
{"code": "void RootWindow::OnWindowAddedToRootWindow(Window* attached) {\n  if (attached->IsVisible() &&\n      attached->ContainsPointInRoot(last_mouse_location_))\n    PostMouseMoveEventAfterWindowChange();\n}", "target": 0}
{"code": "void git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\tgit__free(entry);\n}", "target": 0}
{"code": "static int iommu_dummy(struct device *dev)\n{\n\treturn dev->archdata.iommu == DUMMY_DEVICE_DOMAIN_INFO;\n}", "target": 0}
{"code": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n {\n \tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n \t\treturn -EPERM;\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}", "target": 1}
{"code": "sock_set_v6only(int s)\n{\n#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)\n\tint on = 1;\n\tdebug3(\"%s: set socket %d IPV6_V6ONLY\", __func__, s);\n\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt IPV6_V6ONLY: %s\", strerror(errno));\n#endif\n}", "target": 0}
{"code": "void usbredirparser_init(struct usbredirparser *parser_pub,\n    const char *version, uint32_t *caps, int caps_len, int flags)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    struct usb_redir_hello_header hello = { { 0 }, };\n    parser->flags = (flags & ~usbredirparser_fl_no_hello);\n    if (parser->callb.alloc_lock_func) {\n        parser->lock = parser->callb.alloc_lock_func();\n    }\n    snprintf(hello.version, sizeof(hello.version), \"%s\", version);\n    if (caps_len > USB_REDIR_CAPS_SIZE) {\n        caps_len = USB_REDIR_CAPS_SIZE;\n    }\n    memcpy(parser->our_caps, caps, caps_len * sizeof(uint32_t));\n    if (!(flags & usbredirparser_fl_usb_host))\n        usbredirparser_caps_set_cap(parser->our_caps,\n                                    usb_redir_cap_device_disconnect_ack);\n    usbredirparser_verify_caps(parser, parser->our_caps, \"our\");\n    if (!(flags & usbredirparser_fl_no_hello))\n        usbredirparser_queue(parser_pub, usb_redir_hello, 0, &hello,\n                             (uint8_t *)parser->our_caps,\n                             USB_REDIR_CAPS_SIZE * sizeof(uint32_t));\n}", "target": 0}
{"code": " static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n {\n\tunsigned int len;\n\tunsigned long start=0, off;\n \tstruct au1200fb_device *fbdev = info->par;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; \n\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\t  vma->vm_end - vma->vm_start,\n\t\t\t\t  vma->vm_page_prot);\n }", "target": 1}
{"code": "return_zero_rows(JOIN *join, select_result *result, List<TABLE_LIST> &tables,\n\t\t List<Item> &fields, bool send_row, ulonglong select_options,\n\t\t const char *info, Item *having, List<Item> &all_fields)\n{\n  DBUG_ENTER(\"return_zero_rows\");\n  if (select_options & SELECT_DESCRIBE)\n  {\n    select_describe(join, FALSE, FALSE, FALSE, info);\n    DBUG_RETURN(0);\n  }\n  join->join_free();\n  if (send_row)\n  {\n    List_iterator<TABLE_LIST> ti(tables);\n    TABLE_LIST *table;\n    while ((table= ti++))\n    {\n      if (!table->is_jtbm())\n        mark_as_null_row(table->table);\t\t\n    }\n    List_iterator_fast<Item> it(all_fields);\n    Item *item;\n    while ((item= it++))\n      item->no_rows_in_result();\n    if (having && having->val_int() == 0)\n      send_row=0;\n  }\n  if (!join->send_row_on_empty_set())\n  {\n    join->thd->set_examined_row_count(0);\n    join->thd->limit_found_rows= 0;\n  }\n  if (!(result->send_result_set_metadata(fields,\n                              Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF)))\n  {\n    bool send_error= FALSE;\n    if (send_row)\n      send_error= result->send_data(fields) > 0;\n    if (likely(!send_error))\n      result->send_eof();\t\t\t\t\n  }\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "static void check_hostalias(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    return;\nfound:\n    r->server = s;\n}", "target": 1}
{"code": "    bool chunked() const { return has(Http::HdrType::TRANSFER_ENCODING); }", "target": 0}
{"code": "void RenderWidgetHostViewAura::UpdateCursor(const WebCursor& cursor) {\n  current_cursor_ = cursor;\n  const gfx::Display display = gfx::Screen::GetScreenFor(window_)->\n      GetDisplayNearestWindow(window_);\n  current_cursor_.SetDisplayInfo(display);\n  UpdateCursorIfOverSelf();\n}", "target": 0}
{"code": "MessageRouter* ChildThread::GetRouter() {\n  DCHECK(base::MessageLoop::current() == message_loop());\n  return &router_;\n}", "target": 0}
{"code": "    Rational Xmpdatum::toRational(long n) const\n    {\n        return p_->value_.get() == 0 ? Rational(-1, 1) : p_->value_->toRational(n);\n    }", "target": 0}
{"code": "   Get status info from a mailbox */\nPHP_FUNCTION(imap_status)\n{\n\tzval *streamind;\n\tzend_string *mbx;\n\tzend_long flags;\n\tpils *imap_le_struct;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rSl\", &streamind, &mbx, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tobject_init(return_value);\n\tif (mail_status(imap_le_struct->imap_stream, ZSTR_VAL(mbx), flags)) {\n\t\tadd_property_long(return_value, \"flags\", IMAPG(status_flags));\n\t\tif (IMAPG(status_flags) & SA_MESSAGES) {\n\t\t\tadd_property_long(return_value, \"messages\", IMAPG(status_messages));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_RECENT) {\n\t\t\tadd_property_long(return_value, \"recent\", IMAPG(status_recent));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UNSEEN) {\n\t\t\tadd_property_long(return_value, \"unseen\", IMAPG(status_unseen));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UIDNEXT) {\n\t\t\tadd_property_long(return_value, \"uidnext\", IMAPG(status_uidnext));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UIDVALIDITY) {\n\t\t\tadd_property_long(return_value, \"uidvalidity\", IMAPG(status_uidvalidity));\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 0}
{"code": "static struct sock *x25_make_new(struct sock *osk)\n{\n\tstruct sock *sk = NULL;\n\tstruct x25_sock *x25, *ox25;\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\tgoto out;\n\tif ((sk = x25_alloc_socket(sock_net(osk), 0)) == NULL)\n\t\tgoto out;\n\tx25 = x25_sk(sk);\n\tsk->sk_type        = osk->sk_type;\n\tsk->sk_priority    = osk->sk_priority;\n\tsk->sk_protocol    = osk->sk_protocol;\n\tsk->sk_rcvbuf      = osk->sk_rcvbuf;\n\tsk->sk_sndbuf      = osk->sk_sndbuf;\n\tsk->sk_state       = TCP_ESTABLISHED;\n\tsk->sk_backlog_rcv = osk->sk_backlog_rcv;\n\tsock_copy_flags(sk, osk);\n\tox25 = x25_sk(osk);\n\tx25->t21        = ox25->t21;\n\tx25->t22        = ox25->t22;\n\tx25->t23        = ox25->t23;\n\tx25->t2         = ox25->t2;\n\tx25->flags\t= ox25->flags;\n\tx25->facilities = ox25->facilities;\n\tx25->dte_facilities = ox25->dte_facilities;\n\tx25->cudmatchlength = ox25->cudmatchlength;\n\tclear_bit(X25_INTERRUPT_FLAG, &x25->flags);\n\tx25_init_timers(sk);\nout:\n\treturn sk;\n}", "target": 0}
{"code": "static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}", "target": 1}
{"code": "PHP_FUNCTION(fmod)\n{\n\tdouble num1, num2;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"dd\",  &num1, &num2) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_DOUBLE(fmod(num1, num2));\n}", "target": 0}
{"code": "void gdImageString (gdImagePtr im, gdFontPtr f, int x, int y, unsigned char *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen ((char *) s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageChar(im, f, x, y, s[i], color);\n\t\tx += f->w;\n\t}\n}", "target": 0}
{"code": "cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,\n                                       const char* Name,\n                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])\n{\n    cmsUInt32Number i;\n    if (NamedColorList == NULL) return FALSE;\n    if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {\n        if (!GrowNamedColorList(NamedColorList)) return FALSE;\n    }\n    for (i=0; i < NamedColorList ->ColorantCount; i++)\n        NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i];\n    for (i=0; i < 3; i++)\n        NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i];\n    if (Name != NULL) {\n        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,\n                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name));\n        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;\n    }\n    else\n        NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0;\n    NamedColorList ->nColors++;\n    return TRUE;\n}", "target": 1}
{"code": "static struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_hdr(skb);\n\tstruct sk_buff *pp = NULL;\n\tstruct udphdr *uh2;\n\tstruct sk_buff *p;\n\tif (!uh->check) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\tskb_gro_pull(skb, sizeof(struct udphdr));\n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\t\tuh2 = udp_hdr(p);\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (uh->len > uh2->len || skb_gro_receive(p, skb) ||\n\t\t    uh->len != uh2->len ||\n\t\t    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)\n\t\t\tpp = p;\n\t\treturn pp;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *m, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint ret;\n\tint copylen;\n\tret = -EOPNOTSUPP;\n\tif (m->msg_flags&MSG_OOB)\n\t\tgoto read_error;\n\tm->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n\tif (!skb)\n\t\tgoto read_error;\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\tret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);\n\tif (ret)\n\t\tgoto out_free;\n\tret = (flags & MSG_TRUNC) ? skb->len : copylen;\nout_free:\n\tskb_free_datagram(sk, skb);\n\tcaif_check_flow_release(sk);\n\treturn ret;\nread_error:\n\treturn ret;\n}", "target": 1}
{"code": "void unmarshallAudioAttributes(const Parcel& parcel, audio_attributes_t *attributes)\n{\n    attributes->usage = (audio_usage_t) parcel.readInt32();\n    attributes->content_type = (audio_content_type_t) parcel.readInt32();\n    attributes->source = (audio_source_t) parcel.readInt32();\n    attributes->flags = (audio_flags_mask_t) parcel.readInt32();\n const bool hasFlattenedTag = (parcel.readInt32() == kAudioAttributesMarshallTagFlattenTags);\n if (hasFlattenedTag) {\n String16 tags = parcel.readString16();\n ssize_t realTagSize = utf16_to_utf8_length(tags.string(), tags.size());\n if (realTagSize <= 0) {\n            strcpy(attributes->tags, \"\");\n } else {\n             size_t tagSize = realTagSize > AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 ?\n                     AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 : realTagSize;\n            utf16_to_utf8(tags.string(), tagSize, attributes->tags);\n         }\n     } else {\n         ALOGE(\"unmarshallAudioAttributes() received unflattened tags, ignoring tag values\");\n        strcpy(attributes->tags, \"\");\n }\n}", "target": 1}
{"code": "    template<typename tf>\n    CImg<floatT> get_isosurface3d(CImgList<tf>& primitives, const float isovalue,\n                                  const int size_x=-100, const int size_y=-100, const int size_z=-100) const {\n      if (_spectrum>1)\n        throw CImgInstanceException(_cimg_instance\n                                    \"get_isosurface3d(): Instance is not a scalar image.\",\n                                    cimg_instance);\n      primitives.assign();\n      if (is_empty()) return *this;\n      CImg<floatT> vertices;\n      if ((size_x==-100 && size_y==-100 && size_z==-100) || (size_x==width() && size_y==height() && size_z==depth())) {\n        const _functor3d_int func(*this);\n        vertices = isosurface3d(primitives,func,isovalue,0,0,0,width() - 1.0f,height() - 1.0f,depth() - 1.0f,\n                                width(),height(),depth());\n      } else {\n        const _functor3d_float func(*this);\n        vertices = isosurface3d(primitives,func,isovalue,0,0,0,width() - 1.0f,height() - 1.0f,depth() - 1.0f,\n                                size_x,size_y,size_z);\n      }\n      return vertices;", "target": 0}
{"code": "int InstanceKlass::find_method_by_name(const Symbol* name, int* end) const {\n  return find_method_by_name(methods(), name, end);\n}", "target": 0}
{"code": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\tgenl_lock_all();\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\tif (family == &genl_ctrl) {\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n \t\t\t       start, end + 1, GFP_KERNEL);\n \tif (family->id < 0) {\n \t\terr = family->id;\n\t\tgoto errout_locked;\n \t}\n \terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\tgenl_unlock_all();\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\treturn 0;\n errout_remove:\n \tidr_remove(&genl_fam_idr, family->id);\n \tkfree(family->attrbuf);\n errout_locked:\n \tgenl_unlock_all();\n\treturn err;\n}", "target": 1}
{"code": "_g_file_remove_directory (GFile         *directory,\n\t\t\t  GCancellable  *cancellable,\n\t\t\t  GError       **error)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *info;\n\tgboolean         error_occurred = FALSE;\n\tif (directory == NULL)\n\t\treturn TRUE;\n\tenumerator = g_file_enumerate_children (directory,\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n\t\t\t\t\t        0,\n\t\t\t\t\t        cancellable,\n\t\t\t\t\t        error);\n\twhile (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {\n\t\tGFile *child;\n\t\tchild = g_file_get_child (directory, g_file_info_get_name (info));\n\t\tswitch (g_file_info_get_file_type (info)) {\n\t\tcase G_FILE_TYPE_DIRECTORY:\n\t\t\tif (! _g_file_remove_directory (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (! g_file_delete (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tg_object_unref (child);\n\t\tg_object_unref (info);\n\t}\n\tif (! error_occurred && ! g_file_delete (directory, cancellable, error))\n \t\terror_occurred = TRUE;\n\tg_object_unref (enumerator);\n\treturn ! error_occurred;\n}", "target": 1}
{"code": "static gboolean discover_timeout(gpointer user_data)\n{\n\tGDHCPClient *dhcp_client = user_data;\n\tdhcp_client->retry_times++;\n\tg_dhcp_client_start(dhcp_client, NULL);\n\treturn FALSE;\n}", "target": 0}
{"code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n \tstruct snd_seq_port_info *info = arg;\n \tstruct snd_seq_client_port *port;\n \tstruct snd_seq_port_callback *callback;\n \tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n \t\treturn -ENOMEM;\n \tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n \t\treturn -EINVAL;\n \t}\n \tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\tinfo->addr = port->addr;\n \tsnd_seq_set_port_info(port, info);\n \tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n \treturn 0;\n }", "target": 1}
{"code": "append_utf8_value (const unsigned char *value, size_t length,\n                   struct stringbuf *sb)\n{\n  unsigned char tmp[6];\n  const unsigned char *s;\n  size_t n;\n  int i, nmore;\n  if (length && (*value == ' ' || *value == '#'))\n    {\n      tmp[0] = '\\\\';\n      tmp[1] = *value;\n      put_stringbuf_mem (sb, tmp, 2);\n      value++;\n      length--;\n    }\n  if (length && value[length-1] == ' ')\n    {\n      tmp[0] = '\\\\';\n      tmp[1] = ' ';\n      put_stringbuf_mem (sb, tmp, 2);\n       length--;\n     }\n   for (s=value, n=0;;)\n     {\n       for (value = s; n < length && !(*s & 0x80); n++, s++)\n      for (value = s; n < length && !(*s & 0x80); n++, s++)\n        ;\n         append_quoted (sb, value, s-value, 0);\n       if (n==length)\n         return; \n      assert ((*s & 0x80));\n      if ( (*s & 0xe0) == 0xc0 )      \n         nmore = 1;\n       else if ( (*s & 0xf0) == 0xe0 ) \n         nmore = 2;\n      else if ( (*s & 0xf8) == 0xf0 ) \n        nmore = 3;\n      else if ( (*s & 0xfc) == 0xf8 ) \n         nmore = 4;\n       else if ( (*s & 0xfe) == 0xfc ) \n         nmore = 5;\n      else \n        nmore = 5;  \n      if (n+nmore > length)\n        nmore = length - n; \n      tmp[0] = *s++; n++;\n      for (i=1; i <= nmore; i++)\n         {\n          if ( (*s & 0xc0) != 0x80)\n            break; \n          tmp[i] = *s++;\n          n++;\n         }\n      put_stringbuf_mem (sb, tmp, i);\n     }\n }", "target": 1}
{"code": "static int decode_preamble(void *p, struct ceph_frame_desc *desc)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tu32 crc, expected_crc;\n\tint i;\n\tcrc = crc32c(0, p, crcp - p);\n\texpected_crc = get_unaligned_le32(crcp);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad preamble crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\tmemset(desc, 0, sizeof(*desc));\n\tdesc->fd_tag = ceph_decode_8(&p);\n\tdesc->fd_seg_cnt = ceph_decode_8(&p);\n\tif (desc->fd_seg_cnt < 1 ||\n\t    desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT) {\n\t\tpr_err(\"bad segment count %d\\n\", desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = ceph_decode_32(&p);\n\t\tdesc->fd_aligns[i] = ceph_decode_16(&p);\n\t}\n\tif (!desc->fd_lens[desc->fd_seg_cnt - 1]) {\n\t\tpr_err(\"last segment empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[0] > CEPH_MSG_MAX_CONTROL_LEN) {\n\t\tpr_err(\"control segment too big %d\\n\", desc->fd_lens[0]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[1] > CEPH_MSG_MAX_FRONT_LEN) {\n\t\tpr_err(\"front segment too big %d\\n\", desc->fd_lens[1]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[2] > CEPH_MSG_MAX_MIDDLE_LEN) {\n\t\tpr_err(\"middle segment too big %d\\n\", desc->fd_lens[2]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[3] > CEPH_MSG_MAX_DATA_LEN) {\n\t\tpr_err(\"data segment too big %d\\n\", desc->fd_lens[3]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\t\tif (len >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\treturn ret;\n}", "target": 1}
{"code": "void RootWindow::OnWindowTransformed(Window* window, bool contained_mouse) {\n  if (contained_mouse ||\n      (window->IsVisible() &&\n       window->ContainsPointInRoot(last_mouse_location_))) {\n    PostMouseMoveEventAfterWindowChange();\n  }\n}", "target": 0}
{"code": "static void php_snmp_session_destructor(zend_resource *rsrc) \n{\n\tphp_snmp_session *session = (php_snmp_session *)rsrc->ptr;\n\tnetsnmp_session_free(&session);\n}", "target": 0}
{"code": "  static void NetworkManagerStatusChangedHandler(void* object,\n                                                 const char* path,\n                                                 const char* key,\n                                                 const Value* value) {\n    NetworkLibraryImpl* networklib = static_cast<NetworkLibraryImpl*>(object);\n    DCHECK(networklib);\n    networklib->UpdateNetworkManagerStatus();\n  }", "target": 0}
{"code": "add_header_value(VALUE hh, const char *key, int klen, const char *val, int vlen) {\n    if (sizeof(content_type) - 1 == klen && 0 == strncasecmp(key, content_type, sizeof(content_type) - 1)) {\n\trb_hash_aset(hh, content_type_val, rb_str_new(val, vlen));\n    } else if (sizeof(content_length) - 1 == klen && 0 == strncasecmp(key, content_length, sizeof(content_length) - 1)) {\n\trb_hash_aset(hh, content_length_val, rb_str_new(val, vlen));\n    } else {\n\tchar\t\thkey[1024];\n\tchar\t\t*k = hkey;\n\tvolatile VALUE\tsval = rb_str_new(val, vlen);\n\tstrcpy(hkey, \"HTTP_\");\n\tk = hkey + 5;\n\tif ((int)(sizeof(hkey) - 5) <= klen) {\n\t    klen = sizeof(hkey) - 6;\n\t}\n\tstrncpy(k, key, klen);\n\thkey[klen + 5] = '\\0';\n\tfor (k = hkey + 5; '\\0' != *k; k++) {\n\t    if ('-' == *k) {\n\t\t*k = '_';\n\t    } else {\n\t\t*k = toupper(*k);\n\t    }\n\t}\n\trb_hash_aset(hh, rb_str_new(hkey, klen + 5), sval);\n    }\n}", "target": 1}
{"code": "void AutoFillManager::ShowAutoFillDialog() {\n  ::ShowAutoFillDialog(tab_contents_->GetContentNativeView(),\n                       personal_data_,\n                       tab_contents_->profile()->GetOriginalProfile());\n}", "target": 0}
{"code": "static int midi_setup_trackname(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_trackname;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "cdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)\n{\n\tsize_t i;\n\tfor (i = 0; i < __arraycount(vn); i++)\n\t\tif (vn[i].v == p)\n\t\t\treturn snprintf(buf, bufsiz, \"%s\", vn[i].n);\n\treturn snprintf(buf, bufsiz, \"0x%x\", p);\n}", "target": 0}
{"code": "int bad_format(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == 's' || *ptr == 'S' || *ptr == '%')\n                ptr++;\n            else if (*ptr == 'c') {\n                ptr++;\n                n = 1;\n            }\n            else {\n                if (*ptr == ' ' || *ptr == '+' || *ptr == '-')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr == '.')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'e' || *ptr == 'f' || *ptr == 'g')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 1);\n}", "target": 1}
{"code": "struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n\t\t\t\t\t\tint port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n\tsnd_use_lock_init(&new_port->use_lock);\n\tport_subs_info_init(&new_port->c_src);\n\tport_subs_info_init(&new_port->c_dest);\n\tnum = port >= 0 ? port : 0;\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) \n\t\t\tnum = p->addr.port + 1;\n\t}\n\tlist_add_tail(&new_port->list, &p->list);\n\tclient->num_ports++;\n\tnew_port->addr.port = num;\t\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n\treturn new_port;\n}", "target": 1}
{"code": "static inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tnfsdstats.nfs4_opcount[opnum]++;\n}", "target": 0}
{"code": "bool RenderWidgetHostViewAura::CanFocus() {\n  return popup_type_ == blink::WebPopupTypeNone;\n}", "target": 0}
{"code": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tint ret = 0;\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}", "target": 1}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"xreader-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 1}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 0}
{"code": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,\n static int asn1_template_ex_d2i(ASN1_VALUE **pval,\n                                 const unsigned char **in, long len,\n                                 const ASN1_TEMPLATE *tt, char opt,\n                                ASN1_TLC *ctx);\n static int asn1_template_noexp_d2i(ASN1_VALUE **val,\n                                    const unsigned char **in, long len,\n                                    const ASN1_TEMPLATE *tt, char opt,\n                                   ASN1_TLC *ctx);\n static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,\n                                  const unsigned char **in, long len,\n                                  const ASN1_ITEM *it,\n    B_ASN1_OCTET_STRING, 0, 0, B_ASN1_UNKNOWN,\n    B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,\n    B_ASN1_UTF8STRING, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,\n    B_ASN1_SEQUENCE, 0, B_ASN1_NUMERICSTRING, B_ASN1_PRINTABLESTRING,\n    B_ASN1_T61STRING, B_ASN1_VIDEOTEXSTRING, B_ASN1_IA5STRING,\n    B_ASN1_UTCTIME, B_ASN1_GENERALIZEDTIME,\n    B_ASN1_GRAPHICSTRING, B_ASN1_ISO64STRING, B_ASN1_GENERALSTRING,\n    B_ASN1_UNIVERSALSTRING, B_ASN1_UNKNOWN, B_ASN1_BMPSTRING, B_ASN1_UNKNOWN,\n};\nunsigned long ASN1_tag2bit(int tag)\n{", "target": 1}
{"code": "newkeys_to_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b;\n\tstruct sshcipher_ctx *cc;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey;\n\tint r;\n\tif ((newkey = ssh->state->newkeys[mode]) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tenc = &newkey->enc;\n\tmac = &newkey->mac;\n\tcomp = &newkey->comp;\n\tcc = (mode == MODE_OUT) ? ssh->state->send_context :\n\t    ssh->state->receive_context;\n\tif ((r = cipher_get_keyiv(cc, enc->iv, enc->iv_len)) != 0)\n\t\treturn r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_cstring(b, enc->name)) != 0 ||\n\t    (r = sshbuf_put(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->enabled)) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->block_size)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->key, enc->key_len)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->iv, enc->iv_len)) != 0)\n\t\tgoto out;\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = sshbuf_put_cstring(b, mac->name)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, mac->enabled)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, mac->key, mac->key_len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_u32(b, comp->type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, comp->enabled)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, comp->name)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "int detach_capi_ctr(struct capi_ctr *ctr)\n{\n\tint err = 0;\n\tmutex_lock(&capi_controller_lock);\n\tctr_down(ctr, CAPI_CTR_DETACHED);\n\tif (capi_controller[ctr->cnr - 1] != ctr) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\tcapi_controller[ctr->cnr - 1] = NULL;\n\tncontrollers--;\n\tif (ctr->procent)\n\t\tremove_proc_entry(ctr->procfn, NULL);\n\tprintk(KERN_NOTICE \"kcapi: controller [%03d]: %s unregistered\\n\",\n\t       ctr->cnr, ctr->name);\nunlock_out:\n\tmutex_unlock(&capi_controller_lock);\n\treturn err;\n}", "target": 1}
{"code": "xsltFreeKeyTableList(xsltKeyTablePtr keyt) {\n    xsltKeyTablePtr cur;\n    while (keyt != NULL) {\n\tcur = keyt;\n\tkeyt = keyt->next;\n\txsltFreeKeyTable(cur);\n    }\n}", "target": 0}
{"code": "bool SSecurityTLS::processMsg(SConnection *sc)\n{\n  rdr::InStream* is = sc->getInStream();\n  rdr::OutStream* os = sc->getOutStream();\n  vlog.debug(\"Process security message (session %p)\", session);\n  if (!session) {\n    initGlobal();\n    if (gnutls_init(&session, GNUTLS_SERVER) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n    try {\n      setParams(session);\n    }\n    catch(...) {\n      os->writeU8(0);\n      throw;\n    }\n    os->writeU8(1);\n    os->flush();\n  }\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n    if (!gnutls_error_is_fatal(err)) {\n      vlog.debug(\"Deferring completion of TLS handshake: %s\", gnutls_strerror(err));\n      return false;\n    }\n    vlog.error(\"TLS Handshake failed: %s\", gnutls_strerror (err));\n    shutdown();\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n  vlog.debug(\"Handshake completed\");\n  sc->setStreams(fis = tlsis, fos = tlsos);\n  return true;\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::ProcessAckedTouchEvent(\n    const TouchEventWithLatencyInfo& touch, InputEventAckState ack_result) {\n  ScopedVector<ui::TouchEvent> events;\n  if (!MakeUITouchEventsFromWebTouchEvents(touch, &events,\n                                           SCREEN_COORDINATES))\n    return;\n  aura::WindowEventDispatcher* dispatcher = window_->GetDispatcher();\n  if (!dispatcher)\n    return;\n  ui::EventResult result = (ack_result ==\n      INPUT_EVENT_ACK_STATE_CONSUMED) ? ui::ER_HANDLED : ui::ER_UNHANDLED;\n  for (ScopedVector<ui::TouchEvent>::iterator iter = events.begin(),\n      end = events.end(); iter != end; ++iter) {\n    dispatcher->ProcessedTouchEvent((*iter), window_, result);\n  }\n}", "target": 0}
{"code": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnd->flags &= ~LOOKUP_PARENT;\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n \tfollow_mount(path);\n \terror = 0;\n out:\n\tterminate_walk(nd);\n\treturn error;\n}", "target": 1}
{"code": "void Shell::DeleteInstance() {\n  delete instance_;\n  instance_ = nullptr;\n}", "target": 0}
{"code": " static int smacker_decode_tree(BitstreamContext *bc, HuffContext *hc,\n                                uint32_t prefix, int length)\n {\n     if (!bitstream_read_bit(bc)) { \n         if(hc->current >= 256){\n             av_log(NULL, AV_LOG_ERROR, \"Tree size exceeded!\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if(length){\n            hc->bits[hc->current] = prefix;\n            hc->lengths[hc->current] = length;\n        } else {\n            hc->bits[hc->current] = 0;\n            hc->lengths[hc->current] = 0;\n        }\n        hc->values[hc->current] = bitstream_read(bc, 8);\n        hc->current++;\n        if(hc->maxlength < length)\n            hc->maxlength = length;\n        return 0;\n    } else { \n        int r;\n        length++;\n        r = smacker_decode_tree(bc, hc, prefix, length);\n        if(r)\n            return r;\n        return smacker_decode_tree(bc, hc, prefix | (1 << (length - 1)), length);\n    }\n}", "target": 1}
{"code": "int bt_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t    int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err == 0) {\n\t\tsock_recv_cmsgs(msg, sk, skb);\n\t\tif (msg->msg_name && bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "Goffset JPXStream::getPos() {\n  return priv->counter * priv->ncomps + priv->ccounter;\n}", "target": 0}
{"code": "void HTMLInputElement::setValueAsDate(double value, ExceptionState& exceptionState)\n{\n    m_inputType->setValueAsDate(value, exceptionState);\n}", "target": 0}
{"code": "gxps_images_guess_content_type (GXPSArchive *zip,\n\t\t\t\tconst gchar *image_uri)\n{\n\tGInputStream *stream;\n\tguchar        buffer[1024];\n\tgssize        bytes_read;\n\tgchar        *mime_type;\n\tstream = gxps_archive_open (zip, image_uri);\n\tif (!stream)\n\t\treturn NULL;\n\tbytes_read = g_input_stream_read (stream, buffer, 1024, NULL, NULL);\n\tmime_type = g_content_type_guess (NULL, buffer, bytes_read, NULL);\n\tg_object_unref (stream);\n\treturn mime_type;\n}", "target": 0}
{"code": "RootWindow* RootWindowHostLinux::GetRootWindow() {\n  return root_window_;\n}", "target": 0}
{"code": "uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,\n                                 const QString &app_icon, const QString &summary, const QString &body,\n                                 const QStringList &actions, const QVariantMap &hints, int timeout)\n{\n    uint partOf = 0;\n    const QString appRealName = hints[QStringLiteral(\"x-kde-appname\")].toString();\n    const QString eventId = hints[QStringLiteral(\"x-kde-eventId\")].toString();\n    const bool skipGrouping = hints[QStringLiteral(\"x-kde-skipGrouping\")].toBool();\n    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {\n        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();\n    }\n     qDebug() << \"Currrent active notifications:\" << m_activeNotifications;\n     qDebug() << \"Guessing partOf as:\" << partOf;\n     qDebug() << \" New Notification: \" << summary << body << timeout << \"& Part of:\" << partOf;\n    QString _body;\n     if (partOf > 0) {\n         const QString source = QStringLiteral(\"notification %1\").arg(partOf);\n         Plasma::DataContainer *container = containerForSource(source);\n         if (container) {\n            _body = container->data()[QStringLiteral(\"body\")].toString();\n            if (_body != body) {\n                _body.append(\"\\n\").append(body);\n            } else {\n                _body = body;\n             }\n             replaces_id = partOf;\n            CloseNotification(partOf);\n        }\n    }\n    uint id = replaces_id ? replaces_id : m_nextId++;\n    if (m_alwaysReplaceAppsList.contains(app_name)) {\n        if (m_notificationsFromReplaceableApp.contains(app_name)) {\n            id = m_notificationsFromReplaceableApp.value(app_name);\n        } else {\n            m_notificationsFromReplaceableApp.insert(app_name, id);\n        }\n    }\n    QString appname_str = app_name;\n    if (appname_str.isEmpty()) {\n        appname_str = i18n(\"Unknown Application\");\n    }\n    bool isPersistent = timeout == 0;\n     const int AVERAGE_WORD_LENGTH = 6;\n     const int WORD_PER_MINUTE = 250;\n    int count = summary.length() + body.length();\n        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;\n        timeout = 2000 + qMax(timeout, 3000);\n    }", "target": 1}
{"code": "mysql_stmt_row_tell(MYSQL_STMT *stmt)\n{\n  DBUG_ENTER(\"mysql_stmt_row_tell\");\n  DBUG_RETURN(stmt->data_cursor);\n}", "target": 0}
{"code": "dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}", "target": 1}
{"code": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\nfail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}", "target": 1}
{"code": "void zend_accel_shared_protect(int mode)\n{\n#ifdef HAVE_MPROTECT\n\tint i;\n\tif (mode) {\n\t\tmode = PROT_READ;\n\t} else {\n\t\tmode = PROT_READ|PROT_WRITE;\n\t}\n\tfor (i = 0; i < ZSMMG(shared_segments_count); i++) {\n\t\tmprotect(ZSMMG(shared_segments)[i]->p, ZSMMG(shared_segments)[i]->size, mode);\n\t}\n#endif\n}", "target": 0}
{"code": "static Token *make_tok_qstr_len(Token *next, const char *str, size_t len)\n{\n    char *p = nasm_quote(str, &len);\n    return new_Token_free(next, TOK_STRING, p, len);\n}", "target": 0}
{"code": "static void test_bug17309863()\n{\n  MYSQL *lmysql;\n  unsigned long thread_id;\n  char query[MAX_TEST_QUERY_LENGTH];\n  int rc;\n  myheader(\"test_bug17309863\");\n  if (!opt_silent)\n    fprintf(stdout, \"\\n Establishing a test connection ...\");\n  if (!(lmysql= mysql_client_init(NULL)))\n  {\n    myerror(\"mysql_client_init() failed\");\n    exit(1);\n  }\n  lmysql->reconnect= 1;\n  if (!(mysql_real_connect(lmysql, opt_host, opt_user,\n                           opt_password, current_db, opt_port,\n                           opt_unix_socket, 0)))\n  {\n    myerror(\"connection failed\");\n    exit(1);\n  }\n  if (!opt_silent)\n    fprintf(stdout, \"OK\");\n  thread_id= mysql_thread_id(lmysql);\n  sprintf(query, \"KILL %lu\", thread_id);\n  if (thread_query(query))\n    exit(1);\n  rc= mysql_query(lmysql, \"SELECT 'bug17309863'\");\n  myquery(rc);\n  mysql_close(lmysql);\n}", "target": 0}
{"code": "MonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\tMONO_ARCH_SAVE_REGS;\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\tklass = method->klass;\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);", "target": 1}
{"code": "TEST(PercentEncoding, ShouldCloseConnection) {\n  EXPECT_TRUE(HeaderUtility::shouldCloseConnection(Protocol::Http10,\n                                                   TestRequestHeaderMapImpl{{\"foo\", \"bar\"}}));\n  EXPECT_FALSE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http10, TestRequestHeaderMapImpl{{\"connection\", \"keep-alive\"}}));\n  EXPECT_FALSE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http10, TestRequestHeaderMapImpl{{\"connection\", \"foo, keep-alive\"}}));\n  EXPECT_FALSE(HeaderUtility::shouldCloseConnection(Protocol::Http11,\n                                                    TestRequestHeaderMapImpl{{\"foo\", \"bar\"}}));\n  EXPECT_TRUE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http11, TestRequestHeaderMapImpl{{\"connection\", \"close\"}}));\n  EXPECT_TRUE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http11, TestRequestHeaderMapImpl{{\"connection\", \"te,close\"}}));\n  EXPECT_TRUE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http11, TestRequestHeaderMapImpl{{\"proxy-connection\", \"close\"}}));\n  EXPECT_TRUE(HeaderUtility::shouldCloseConnection(\n      Protocol::Http11, TestRequestHeaderMapImpl{{\"proxy-connection\", \"foo,close\"}}));\n}", "target": 0}
{"code": "static int mbochs_probe(struct mdev_device *mdev)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\tif (type->mbytes + mbochs_used_mbytes > max_mbytes)\n\t\treturn -ENOMEM;\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\treturn -ENOMEM;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\tdev_info(dev, \"%s: %s, %d MB, %ld pages\\n\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\tmbochs_used_mbytes += type->mbytes;\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\nerr_mem:\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n\treturn ret;\n}", "target": 1}
{"code": "static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)\n{\n    int s = -1, rv;\n    char _port[6];  \n    struct addrinfo hints, *servinfo, *p;\n    snprintf(_port,6,\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = af;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;    \n    if (bindaddr && !strcmp(\"*\", bindaddr))\n        bindaddr = NULL;\n    if (af == AF_INET6 && bindaddr && !strcmp(\"::*\", bindaddr))\n        bindaddr = NULL;\n    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;\n        goto end;\n    }\n    if (p == NULL) {\n        anetSetError(err, \"unable to bind socket, errno: %d\", errno);\n        goto error;\n    }\nerror:\n    if (s != -1) close(s);\n    s = ANET_ERR;\nend:\n    freeaddrinfo(servinfo);\n    return s;\n}", "target": 1}
{"code": "bool PrintWebViewHelper::PrintPreviewContext::IsModifiable() {\n  return !PrintingNodeOrPdfFrame(source_frame(), source_node_);\n}", "target": 0}
{"code": "static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "timeout_response_cb (GtkDialog *dialog, int response_id, gpointer data)\n{\n        TimeoutDialog *timeout = data;\n        if (response_id == GTK_RESPONSE_DELETE_EVENT) {\n                timeout->response_id = GTK_RESPONSE_CANCEL;\n        } else\n                timeout->response_id = response_id;\n        gtk_main_quit ();\n}", "target": 0}
{"code": "read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n{\n\tint\t  ret;\n\tstatic uint32_t\t\tlen = 0;\n\tstatic char\t\tlen_buf[4];\n\tstatic int\t\tlen_buf_pos = 0;\n\tstatic char *\t\ttmpbuf = 0;\n\tstatic int\t\ttmpbuf_pos = 0;\n\tif (first) {\n\t\tlen_buf_pos = 0;\n\t\treturn -2;\n\t}\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\t\tif (ret == 0) {\t\t\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\treturn -1;\n\t\t}\n\t\tlen_buf_pos += ret;\n\t}\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\tlen = ntohl(*(uint32_t *)len_buf);\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\treturn -1;\n\t}\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\treturn -1;\n\t}\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\treturn -1;\n\t}\n\ttmpbuf_pos += ret;\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\treturn -2;\n}", "target": 1}
{"code": "static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\thci_send_sco(conn->hcon, skb);\n\treturn len;\n}", "target": 1}
{"code": "int fuse_fs_truncate(struct fuse_fs *fs, const char *path, off_t size)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.truncate)\n        return fs->op.truncate(path, size);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  \n\t\t|| cmdline_star > 0) \n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    \n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  \n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    redrawcmd();\n    return CMDLINE_NOT_CHANGED;\n}", "target": 1}
{"code": " static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n {\n \tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n \tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n \tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; \n}", "target": 1}
{"code": "static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i;\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = shinfo->frags + i;\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct page *page;\n\t\tu16 pending_idx;\n\t\tpending_idx = frag_get_pending_idx(frag);\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tpage = virt_to_page(idx_to_kaddr(netbk, pending_idx));\n\t\t__skb_fill_page_desc(skb, i, page, txp->offset, txp->size);\n\t\tskb->len += txp->size;\n\t\tskb->data_len += txp->size;\n\t\tskb->truesize += txp->size;\n\t\tget_page(netbk->mmap_pages[pending_idx]);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t}\n}", "target": 1}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink))\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n    return(1);\n    }", "target": 1}
{"code": "    CImg<ulongT> get_label(const bool is_high_connectivity=false,\n                           const Tfloat tolerance=0) const {\n      if (is_empty()) return CImg<ulongT>();\n      int dx[13], dy[13], dz[13], nb = 0;\n      dx[nb] = 1; dy[nb] = 0; dz[nb++] = 0;\n      dx[nb] = 0; dy[nb] = 1; dz[nb++] = 0;\n      if (is_high_connectivity) {\n        dx[nb] = 1; dy[nb] = 1; dz[nb++] = 0;\n        dx[nb] = 1; dy[nb] = -1; dz[nb++] = 0;\n      }\n      if (_depth>1) { \n        dx[nb] = 0; dy[nb] = 0; dz[nb++]=1;\n        if (is_high_connectivity) {\n          dx[nb] = 1; dy[nb] = 1; dz[nb++] = -1;\n          dx[nb] = 1; dy[nb] = 0; dz[nb++] = -1;\n          dx[nb] = 1; dy[nb] = -1; dz[nb++] = -1;\n          dx[nb] = 0; dy[nb] = 1; dz[nb++] = -1;\n          dx[nb] = 0; dy[nb] = 1; dz[nb++] = 1;\n          dx[nb] = 1; dy[nb] = -1; dz[nb++] = 1;\n          dx[nb] = 1; dy[nb] = 0; dz[nb++] = 1;\n          dx[nb] = 1; dy[nb] = 1; dz[nb++] = 1;\n        }\n      }\n      return _label(nb,dx,dy,dz,tolerance);", "target": 0}
{"code": "int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {\n  sftp_status_message status = NULL;\n  sftp_message msg = NULL;\n  sftp_attributes errno_attr = NULL;\n  struct sftp_attributes_struct attr;\n  ssh_buffer buffer;\n  ssh_string path;\n  uint32_t id;\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(sftp->session);\n    return -1;\n  }\n  path = ssh_string_from_char(directory);\n  if (path == NULL) {\n    ssh_set_error_oom(sftp->session);\n    ssh_buffer_free(buffer);\n    return -1;\n  }\n  ZERO_STRUCT(attr);\n  attr.permissions = mode;\n  attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;\n  id = sftp_get_new_id(sftp);\n  if (buffer_add_u32(buffer, id) < 0 ||\n      buffer_add_ssh_string(buffer, path) < 0 ||\n      buffer_add_attributes(buffer, &attr) < 0 ||\n      sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {\n    ssh_buffer_free(buffer);\n    ssh_string_free(path);\n  }\n  ssh_buffer_free(buffer);\n  ssh_string_free(path);\n  while (msg == NULL) {\n    if (sftp_read_and_dispatch(sftp) < 0) {\n      return -1;\n    }\n    msg = sftp_dequeue(sftp, id);\n  }\n  if (msg->packet_type == SSH_FXP_STATUS) {\n    status = parse_status_msg(msg);\n    sftp_message_free(msg);\n    if (status == NULL) {\n      return -1;\n    }\n    sftp_set_error(sftp, status->status);\n    switch (status->status) {\n      case SSH_FX_FAILURE:\n        errno_attr = sftp_lstat(sftp, directory);\n        if (errno_attr != NULL) {\n          SAFE_FREE(errno_attr);\n          sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);\n        }\n        break;\n      case SSH_FX_OK:\n        status_msg_free(status);\n        return 0;\n        break;\n      default:\n        break;\n    }\n    ssh_set_error(sftp->session, SSH_REQUEST_DENIED,\n        \"SFTP server: %s\", status->errormsg);\n    status_msg_free(status);\n    return -1;\n  } else {\n    ssh_set_error(sftp->session, SSH_FATAL,\n        \"Received message %d when attempting to make directory\",\n        msg->packet_type);\n    sftp_message_free(msg);\n  }\n  return -1;\n}", "target": 1}
{"code": "static void __meminit zone_init_free_lists(struct zone *zone)\n{\n\tunsigned int order, t;\n\tfor_each_migratetype_order(order, t) {\n\t\tINIT_LIST_HEAD(&zone->free_area[order].free_list[t]);\n\t\tzone->free_area[order].nr_free = 0;\n\t}\n}", "target": 0}
{"code": "static __exit void sctp_exit(void)\n{\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\tunregister_pernet_subsys(&sctp_net_ops);\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\trcu_barrier(); \n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}", "target": 1}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 0}
{"code": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n\t     void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tconst EVP_MD *type = NULL;\n\tunsigned char *buf_in=NULL;\n\tint ret= -1,inl;\n        int mdnid, pknid;\n        EVP_MD_CTX_init(&ctx);\n\tif (type == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\tif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\n\t\tgoto err;\n\t\t}\n\tif (!EVP_VerifyInit_ex(&ctx,type, NULL))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\tif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\n\t\t\t(unsigned int)signature->length,pkey) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}", "target": 1}
{"code": "TEST(LtOp, MatchesScalarEmptyKey) {\n    BSONObj operand = BSON(\"$lt\" << 5);\n    LTMatchExpression lt(\"\", operand[\"$lt\"]);\n    ASSERT(lt.matchesBSON(BSON(\"\" << 4.5), NULL));\n    ASSERT(!lt.matchesBSON(BSON(\"\" << 6), NULL));\n}", "target": 0}
{"code": "void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tkvm_put_guest_xcr0(vcpu);\n\tif (!vcpu->guest_fpu_loaded)\n\t\treturn;\n\tvcpu->guest_fpu_loaded = 0;\n\tfpu_save_init(&vcpu->arch.guest_fpu);\n\t__kernel_fpu_end();\n\t++vcpu->stat.fpu_reload;\n\tkvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);\n\ttrace_kvm_fpu(0);\n}", "target": 0}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4009 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if (length>0) {\n        buffer=malloc(length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "target": 1}
{"code": " std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {\n   std::string func_name = GetFunctionNameRaw(pc, offset);\n  if (!func_name.empty()) {\n#if defined(__APPLE__)\n    if (func_name[0] != '_') {\n      return func_name;\n    }\n#endif\n    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);\n    if (name) {\n      func_name = name;\n      free(name);\n    }\n  }\n   return func_name;\n }", "target": 1}
{"code": "date_s_rfc2822(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"Mon, 1 Jan -4712 00:00:00 +0000\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        if (!NIL_P(opt)) argv2[argc2++] = opt;\n\tVALUE hash = date_s__rfc2822(argc2, argv2, klass);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "bool HTMLSelectElement::anonymousIndexedSetter(unsigned index, PassRefPtr<HTMLOptionElement> value, ExceptionState& exceptionState)\n{\n    if (!value) {\n        exceptionState.throwTypeError(ExceptionMessages::failedToSet(String::number(index), \"HTMLSelectElement\", \"The value provided was not an HTMLOptionElement.\"));\n        return false;\n    }\n    setOption(index, value.get(), exceptionState);\n    return true;\n}", "target": 0}
{"code": "  void from_sync_policy_group(rgw::sal::RGWRadosStore *store,\n                              const rgw_sync_policy_group& group) {\n    bool enabled = (group.status == rgw_sync_policy_group::Status::ENABLED);\n    for (auto& pipe : group.pipes) {\n      auto& rule = rules.emplace_back();\n      rule.from_sync_policy_pipe(store, pipe, enabled);\n    }\n  }", "target": 0}
{"code": "static inline struct net *xt_net(const struct xt_action_param *par)\n{\n\treturn par->state->net;\n}", "target": 0}
{"code": "_pyfribidi_log2vis (PyObject * self, PyObject * args, PyObject * kw)\n{\n\tPyObject *logical = NULL;\t\n\tFriBidiParType base = FRIBIDI_TYPE_RTL;\t\n\tconst char *encoding = \"utf-8\";\t\n\tint clean = 0; \n\tint reordernsm = 1; \n\tstatic char *kwargs[] =\n\t        { \"logical\", \"base_direction\", \"encoding\", \"clean\", \"reordernsm\", NULL };\n        if (!PyArg_ParseTupleAndKeywords (args, kw, \"O|isii\", kwargs,\n\t\t\t\t\t  &logical, &base, &encoding, &clean, &reordernsm))\n\t\treturn NULL;\n\tif (!(base == FRIBIDI_TYPE_RTL ||\n\t      base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON))\n\t\treturn PyErr_Format (PyExc_ValueError,\n\t\t\t\t     \"invalid value %d: use either RTL, LTR or ON\",\n\t\t\t\t     base);\n\tif (PyUnicode_Check (logical))\n\t        return log2vis_unicode (logical, base, clean, reordernsm);\n\telse if (PyString_Check (logical))\n\t        return log2vis_encoded_string (logical, encoding, base, clean, reordernsm);\n\telse\n\t\treturn PyErr_Format (PyExc_TypeError,\n\t\t\t\t     \"expected unicode or str, not %s\",\n\t\t\t\t     logical->ob_type->tp_name);\n}", "target": 1}
{"code": "void WebContentsImpl::UpdateTargetURL(int32 page_id, const GURL& url) {\n  if (delegate_)\n    delegate_->UpdateTargetURL(this, page_id, url);\n}", "target": 0}
{"code": "void FrameLoader::didReceiveServerRedirectForProvisionalLoadForFrame()\n{\n    m_client->dispatchDidReceiveServerRedirectForProvisionalLoad();\n}", "target": 0}
{"code": "PS_SERIALIZER_DECODE_FUNC(php_binary) \n{\n\tconst char *p;\n\tchar *name;\n\tconst char *endptr = val + vallen;\n\tzval *current;\n\tint namelen;\n\tint has_value;\n\tphp_unserialize_data_t var_hash;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tfor (p = val; p < endptr; ) {\n\t\tzval **tmp;\n                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);\n                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {\n                        return FAILURE;\n                }\n\t\tname = estrndup(p + 1, namelen);\n\t\tp += namelen + 1;\n\t\tif (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {\n\t\t\tif ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {\n\t\t\t\tefree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (has_value) {\n\t\t\tALLOC_INIT_ZVAL(current);\n\t\t\tif (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {\n\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n\t\t}\n\t\tPS_ADD_VARL(name, namelen);\n\t\tefree(name);\n\t}\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn SUCCESS;\n}", "target": 1}
{"code": "  static void Launch(OpKernelContext* context, const Tensor& in_x,\n                     const Tensor& in_y, bool adjoint, bool lower,\n                     const MatMulBCast& bcast, Tensor* out) {\n    const int64 batch_size = bcast.output_batch_size();\n    const int64 cost_per_unit =\n        in_x.dim_size(1) * in_x.dim_size(2) * in_y.dim_size(2);\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n    using Matrix =\n        Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;\n    using ConstMatrixMap = Eigen::Map<const Matrix>;\n    using RealScalar = typename Eigen::NumTraits<Scalar>::Real;\n    auto matrix = ConstMatrixMap(in_x.flat<Scalar>().data(), in_x.dim_size(1),\n                                 in_x.dim_size(2));\n    RealScalar min_abs_pivot;\n    if (lower) {\n      min_abs_pivot = matrix.row(0).cwiseAbs().minCoeff();\n    } else {\n      min_abs_pivot = matrix.row(in_x.dim_size(1) - 1).cwiseAbs().minCoeff();\n    }\n    OP_REQUIRES(context, min_abs_pivot > RealScalar(0),\n                errors::InvalidArgument(\"Input matrix is not invertible.\"));\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          cost_per_unit,\n          [&in_x, &in_y, adjoint, lower, &bcast, out](int start, int limit) {\n            SequentialBandedTriangularSolveKernel<Scalar>::Run(\n                in_x, in_y, lower, adjoint, bcast, out, start, limit);\n          });\n  }", "target": 1}
{"code": "TranslateInfoBarDelegate* TranslateManager::GetTranslateInfoBarDelegate(\n    TabContents* tab) {\n  for (int i = 0; i < tab->infobar_delegate_count(); ++i) {\n    TranslateInfoBarDelegate* delegate =\n        tab->GetInfoBarDelegateAt(i)->AsTranslateInfoBarDelegate();\n    if (delegate)\n      return delegate;\n  }\n  return NULL;\n}", "target": 0}
{"code": "T2P* t2p_init()\n{\n\tT2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P));\n\tif(t2p==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate %lu bytes of memory for t2p_init\", \n\t\t\t(unsigned long) sizeof(T2P));\n\t\treturn( (T2P*) NULL );\n\t}\n\t_TIFFmemset(t2p, 0x00, sizeof(T2P));\n\tt2p->pdf_majorversion=1;\n\tt2p->pdf_minorversion=1;\n\tt2p->pdf_defaultxres=300.0;\n\tt2p->pdf_defaultyres=300.0;\n\tt2p->pdf_defaultpagewidth=612.0;\n\tt2p->pdf_defaultpagelength=792.0;\n\tt2p->pdf_xrefcount=3; \n\tt2p->tiff_maxdatasize = DEFAULT_MAX_MALLOC;\n\treturn(t2p);\n}", "target": 0}
{"code": "Jsi_Value *jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *keyval, Jsi_Value *value, int flag)\n{\n    int arrayindex = -1;\n    if (keyval->vt == JSI_VT_NUMBER && Jsi_NumberIsInteger(keyval->d.num) && keyval->d.num >= 0) {\n        arrayindex = (int)keyval->d.num;\n    }\n    if (arrayindex >= 0 && arrayindex < MAX_ARRAY_LIST &&\n        target->vt == JSI_VT_OBJECT && target->d.obj->arr) {\n        return jsi_ObjArraySetDup(interp, target->d.obj, value, arrayindex);\n    }\n    const char *kstr = Jsi_ValueToString(interp, keyval, NULL);\n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (Jsi_Strcmp(kstr, \"__proto__\")==0) {\n        Jsi_Obj *obj = target->d.obj;\n        obj->__proto__ = Jsi_ValueDup(interp, value);\n        return obj->__proto__;\n    }\n#endif\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    if (value)\n        Jsi_ValueCopy(interp, v, value);\n    jsi_ValueObjSet(interp, target, kstr, v, flag, (Jsi_ValueIsStringKey(interp, keyval)? JSI_OM_ISSTRKEY:0));\n    Jsi_DecrRefCount(interp, v);\n    return v;\n}", "target": 1}
{"code": "allocateCharacterClasses ()\n{\n  int k = 0;\n  characterClasses = NULL;\n  characterClassAttribute = 1;\n  while (characterClassNames[k])\n    {\n      widechar wname[MAXSTRING];\n      int length = strlen (characterClassNames[k]);\n      int kk;\n      for (kk = 0; kk < length; kk++)\n\twname[kk] = (widechar) characterClassNames[k][kk];\n      if (!addCharacterClass (NULL, wname, length))\n\t{\n\t  deallocateCharacterClasses ();\n\t  return 0;\n\t}\n      k++;\n    }\n  return 1;\n}", "target": 0}
{"code": "static void jsiSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv) {\n    SqlFunc *p = (SqlFunc*)sqlite3_user_data(context);\n    int i;\n    int rc;\n    Jsi_Interp *interp = p->interp;\n    Jsi_Value *vpargs, *itemsStatic[100], **items = itemsStatic, *ret;\n    if (argc>100)\n        items = (Jsi_Value**)Jsi_Calloc(argc, sizeof(Jsi_Value*));\n    for(i=0; i<argc; i++) {\n        items[i] = dbGetValueGet(interp, argv[i]);\n    }\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, argc, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, p->tocall, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (items != itemsStatic)\n        Jsi_Free(items);\n    bool b;\n    if( rc != JSI_OK) {\n        char buf[250];\n        snprintf(buf, sizeof(buf), \"error in function: %.200s\", p->zName);\n        sqlite3_result_error(context, buf, -1);\n    } else if (Jsi_ValueIsBoolean(interp, ret)) {\n        Jsi_GetBoolFromValue(interp, ret, &b);\n        sqlite3_result_int(context, b);\n    } else if (Jsi_ValueIsNumber(interp, ret)) {\n        Jsi_Number d;\n        Jsi_GetNumberFromValue(interp, ret, &d);\n        sqlite3_result_double(context, (double)d);\n    } else {\n        const char * data;\n        if (!(data = Jsi_ValueGetStringLen(interp, ret, &i))) {\n            data = Jsi_ValueToString(interp, ret, NULL);\n            i = Jsi_Strlen(data);\n        }\n        sqlite3_result_text(context, (char *)data, i, SQLITE_TRANSIENT );\n    }\n    Jsi_DecrRefCount(interp, ret);\n}", "target": 1}
{"code": " tbGetBuffer(unsigned size)\n {\n    char *rtrn;\n    if (size >= BUFFER_SIZE)\n        return NULL;\n    if ((BUFFER_SIZE - tbNext) <= size)\n        tbNext = 0;\n    rtrn = &textBuffer[tbNext];\n    tbNext += size;\n    return rtrn;\n }", "target": 1}
{"code": "void RenderView::didFinishResourceLoad(\n    WebFrame* frame, unsigned identifier) {\n  NavigationState* navigation_state =\n      NavigationState::FromDataSource(frame->dataSource());\n  if (!navigation_state->postpone_loading_data())\n    return;\n  const GURL& frame_url = frame->url();\n  const GURL& error_page_url = GetAlternateErrorPageURL(frame_url, HTTP_404);\n  DCHECK(error_page_url.is_valid());\n  WebURLError original_error;\n  original_error.unreachableURL = frame_url;\n  navigation_state->set_alt_error_page_fetcher(\n      new AltErrorPageResourceFetcher(\n          error_page_url, frame, original_error,\n          NewCallback(this, &RenderView::AltErrorPageFinished)));\n}", "target": 0}
{"code": "vte_sequence_handler_sc (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tscreen = terminal->pvt->screen;\n\tscreen->cursor_saved.col = screen->cursor_current.col;\n\tscreen->cursor_saved.row = CLAMP(screen->cursor_current.row -\n\t\t\t\t\t screen->insert_delta,\n\t\t\t\t\t 0, terminal->row_count - 1);\n}", "target": 0}
{"code": " void ip4_datagram_release_cb(struct sock *sk)\n {\n \tconst struct inet_sock *inet = inet_sk(sk);\n \tconst struct ip_options_rcu *inet_opt;\n \t__be32 daddr = inet->inet_daddr;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n \trcu_read_lock();\n \tinet_opt = rcu_dereference(inet->inet_opt);\n \tif (inet_opt && inet_opt->opt.srr)\n \t\tdaddr = inet_opt->opt.faddr;\n \trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n \t\t\t\t   inet->inet_saddr, inet->inet_dport,\n \t\t\t\t   inet->inet_sport, sk->sk_protocol,\n \t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n \trcu_read_unlock();\n }", "target": 1}
{"code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void stmt_update_metadata(MYSQL_STMT *stmt, MYSQL_ROWS *data)\n{\n  MYSQL_BIND  *my_bind, *end;\n  MYSQL_FIELD *field;\n  uchar *null_ptr, bit;\n  uchar *row= (uchar*) data->data;\n#ifndef DBUG_OFF\n  uchar *row_end= row + data->length;\n#endif\n  null_ptr= row;\n  row+= (stmt->field_count+9)/8;\t\t\n  bit= 4;\t\t\t\t\t\n  for (my_bind= stmt->bind, end= my_bind + stmt->field_count, field= stmt->fields ;\n       my_bind < end ;\n       my_bind++, field++)\n  {\n    if (!(*null_ptr & bit))\n      (*my_bind->skip_result)(my_bind, field, &row);\n    DBUG_ASSERT(row <= row_end);\n    if (!((bit<<=1) & 255))\n    {\n      bit= 1;\t\t\t\t\t\n      null_ptr++;\n    }\n  }\n}", "target": 0}
{"code": "xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size,\n                  const char *URL, const char *encoding, int options)\n{\n    xmlParserInputBufferPtr input;\n    xmlParserInputPtr stream;\n    if (ctxt == NULL)\n        return (NULL);\n    if (buffer == NULL)\n        return (NULL);\n    xmlInitParser();\n    xmlCtxtReset(ctxt);\n    input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n    if (input == NULL) {\n\treturn(NULL);\n    }\n    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);\n    if (stream == NULL) {\n\txmlFreeParserInputBuffer(input);\n\treturn(NULL);\n    }\n    inputPush(ctxt, stream);\n    return (xmlDoRead(ctxt, URL, encoding, options, 1));\n}", "target": 0}
{"code": "void RenderFrameHostImpl::OnDidFailProvisionalLoadWithError(\n    const FrameHostMsg_DidFailProvisionalLoadWithError_Params& params) {\n  frame_tree_node_->navigator()->DidFailProvisionalLoadWithError(this, params);\n}", "target": 0}
{"code": "bitset_is_empty(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) {\n    if (bs[i] != 0) return 0;\n  }\n  return 1;\n}", "target": 0}
{"code": "String StringUtil::Implode(const Variant& items, const String& delim,\n                           const bool checkIsContainer ) {\n  if (checkIsContainer && !isContainer(items)) {\n    throw_param_is_not_container();\n  }\n  int size = getContainerSize(items);\n  if (size == 0) return empty_string();\n  req::vector<String> sitems;\n  sitems.reserve(size);\n  int len = 0;\n  int lenDelim = delim.size();\n  for (ArrayIter iter(items); iter; ++iter) {\n    sitems.emplace_back(iter.second().toString());\n    len += sitems.back().size() + lenDelim;\n  }\n  len -= lenDelim; \n  assert(sitems.size() == size);\n  String s = String(len, ReserveString);\n  char *buffer = s.mutableData();\n  const char *sdelim = delim.data();\n  char *p = buffer;\n  String &init_str = sitems[0];\n  int init_len = init_str.size();\n  memcpy(p, init_str.data(), init_len);\n  p += init_len;\n  for (int i = 1; i < size; i++) {\n    String &item = sitems[i];\n    memcpy(p, sdelim, lenDelim);\n    p += lenDelim;\n    int lenItem = item.size();\n    memcpy(p, item.data(), lenItem);\n    p += lenItem;\n  }\n  assert(p - buffer == len);\n  s.setSize(len);\n  return s;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n    if (!batched_input_) {\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n    Tensor* encoded_vector;\n    int output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (int i = 0; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }", "target": 1}
{"code": "  Status ArgSortByRows(OpKernelContext* context, const GPUDevice& device,\n                       Tindex N, int rank, Tindex dense_rows,\n                       typename TTypes<Tindex>::ConstMatrix indices,\n                       Tensor* input_index_map_t) {\n    DataType index_type = DataTypeToEnum<Tindex>::value;\n    Tensor row_indices_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(index_type, TensorShape({N}), &row_indices_t));\n    auto row_indices = row_indices_t.flat<Tindex>();\n    TF_RETURN_IF_ERROR(wrap_kernel_call(CopyRowIndicesKernel<Tindex>,\n                                        device, N, rank,\n                                        indices, row_indices));\n    TF_RETURN_IF_ERROR(context->allocate_temp(index_type, TensorShape({N}),\n                                              input_index_map_t));\n    Tindex* input_index_map = input_index_map_t->flat<Tindex>().data();\n    return GpuRadixSort(context, N, row_indices.data(),\n                        static_cast<Tindex*>(nullptr),\n                        static_cast<Tindex*>(nullptr),\n                        input_index_map,\n                        Log2Ceiling64(dense_rows));\n  }", "target": 1}
{"code": "ExpressionFieldPath::ExpressionFieldPath(ExpressionContext* const expCtx,\n                                         const string& theFieldPath,\n                                         Variables::Id variable)\n    : Expression(expCtx), _fieldPath(theFieldPath), _variable(variable) {}", "target": 0}
{"code": "void WebContentsImpl::IncrementCapturerCount() {\n  DCHECK(!is_being_destroyed_);\n  ++capturer_count_;\n  DVLOG(1) << \"There are now \" << capturer_count_\n           << \" capturing(s) of WebContentsImpl@\" << this;\n}", "target": 0}
{"code": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n \tint ret;\n \tint chk_addr_ret;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n \tif (addr_len < sizeof(struct sockaddr_l2tpip))\n \t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n \tread_unlock_bh(&l2tp_ip_lock);\n \tlock_sock(sk);\n \tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n \t\tgoto out;\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  \n\tsk_dst_reset(sk);\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\nout:\n\trelease_sock(sk);\n\treturn ret;\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\treturn ret;\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::CreateBrowserAccessibilityManagerIfNeeded() {\n  if (GetBrowserAccessibilityManager())\n    return;\n#if defined(OS_WIN)\n  aura::WindowEventDispatcher* dispatcher = window_->GetDispatcher();\n  if (!dispatcher)\n    return;\n  HWND hwnd = dispatcher->host()->GetAcceleratedWidget();\n  gfx::NativeViewAccessible accessible_parent =\n      host_->GetParentNativeViewAccessible();\n  BrowserAccessibilityManager* manager = new BrowserAccessibilityManagerWin(\n      hwnd, accessible_parent,\n      BrowserAccessibilityManagerWin::GetEmptyDocument(), this);\n#else\n  BrowserAccessibilityManager* manager = BrowserAccessibilityManager::Create(\n      BrowserAccessibilityManager::GetEmptyDocument(), this);\n#endif\n  SetBrowserAccessibilityManager(manager);\n}", "target": 0}
{"code": "static void bnx2x_hw_enable_status(struct bnx2x *bp)\n{\n\tu32 val;\n\tval = REG_RD(bp, CFC_REG_WEAK_ENABLE_PF);\n\tDP(BNX2X_MSG_SP, \"CFC_REG_WEAK_ENABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, PBF_REG_DISABLE_PF);\n\tDP(BNX2X_MSG_SP, \"PBF_REG_DISABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSI_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSI_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_FUNC_MASK);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_FUNC_MASK is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER is 0x%x\\n\",\n\t   val);\n}", "target": 0}
{"code": "void FrameLoader::frameLoadCompleted()\n{\n    m_client->frameLoadCompleted();\n    history()->updateForFrameLoadCompleted();\n    if (m_documentLoader)\n        m_firstLayoutDone = true;\n}", "target": 0}
{"code": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->value = GETVAL32H(buf, 4);\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "remove_unless_decomposed_in_hash (gpointer key,\n                                  gpointer value,\n                                  gpointer user_data)\n{\n  GHashTable *table = user_data;\n  const FlatpakDecomposed *d = key;\n  return !g_hash_table_contains (table, d);\n}", "target": 0}
{"code": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n}", "target": 1}
{"code": "MONGO_EXPORT int mongo_insert_batch( mongo *conn, const char *ns,\n                                     const bson **bsons, int count, mongo_write_concern *custom_write_concern,\n                                     int flags ) {\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n    int i;\n    char *data;\n    int overhead =  16 + 4 + strlen( ns ) + 1;\n    int size = overhead;\n    if( mongo_validate_ns( conn, ns ) != MONGO_OK )\n        return MONGO_ERROR;\n    for( i=0; i<count; i++ ) {\n        size += bson_size( bsons[i] );\n        if( mongo_bson_valid( conn, bsons[i], 1 ) != MONGO_OK )\n            return MONGO_ERROR;\n    }\n    if( ( size - overhead ) > conn->max_bson_size ) {\n        conn->err = MONGO_BSON_TOO_LARGE;\n        return MONGO_ERROR;\n    }\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n    mm = mongo_message_create( size , 0 , 0 , MONGO_OP_INSERT );\n    data = &mm->data;\n    if( flags & MONGO_CONTINUE_ON_ERROR )\n        data = mongo_data_append32( data, &ONE );\n    else\n        data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n    for( i=0; i<count; i++ ) {\n        data = mongo_data_append( data, bsons[i]->data, bson_size( bsons[i] ) );\n    }\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}", "target": 1}
{"code": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n                      X509 **pissuer, int *pscore, unsigned int *preasons,\n                      STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_score, best_score = *pscore;\n    unsigned int reasons, best_reasons = 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl, *best_crl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n         crl = sk_X509_CRL_value(crls, i);\n         reasons = *preasons;\n         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n        if (crl_score < best_score)\n             continue;\n        if (crl_score == best_score) {\n             int day, sec;\n             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),\n                                X509_CRL_get_lastUpdate(crl)) == 0)\n                continue;\n            if (day <= 0 && sec <= 0)\n                continue;\n        }\n        best_crl = crl;\n        best_crl_issuer = crl_issuer;\n        best_score = crl_score;\n        best_reasons = reasons;\n    }\n    if (best_crl) {\n        if (*pcrl)\n            X509_CRL_free(*pcrl);\n        *pcrl = best_crl;\n        *pissuer = best_crl_issuer;\n        *pscore = best_score;\n        *preasons = best_reasons;\n        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n        if (*pdcrl) {\n            X509_CRL_free(*pdcrl);\n            *pdcrl = NULL;\n        }\n        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n    }\n    if (best_score >= CRL_SCORE_VALID)\n        return 1;\n    return 0;\n}", "target": 1}
{"code": "handle_ppp(netdissect_options *ndo,\n           u_int proto, const u_char *p, int length)\n{\n\tif ((proto & 0xff00) == 0x7e00) { \n\t\tppp_hdlc(ndo, p - 1, length);\n\t\treturn;\n\t}\n\tswitch (proto) {\n\tcase PPP_LCP: \n\tcase PPP_IPCP:\n\tcase PPP_OSICP:\n\tcase PPP_MPLSCP:\n\tcase PPP_IPV6CP:\n\tcase PPP_CCP:\n\tcase PPP_BACP:\n\t\thandle_ctrl_proto(ndo, proto, p, length);\n\t\tbreak;\n\tcase PPP_ML:\n\t\thandle_mlppp(ndo, p, length);\n\t\tbreak;\n\tcase PPP_CHAP:\n\t\thandle_chap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_PAP:\n\t\thandle_pap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_BAP:\t\t\n\t\thandle_bap(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IP:\t\n        case PPP_VJNC:\n\tcase PPP_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\t\n\tcase PPP_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPX:\t\n\tcase PPP_IPX:\n\t\tipx_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_OSI:\n\t\tisoclns_print(ndo, p, length, length);\n\t\tbreak;\n\tcase PPP_MPLS_UCAST:\n\tcase PPP_MPLS_MCAST:\n\t\tmpls_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_COMP:\n\t\tND_PRINT((ndo, \"compressed PPP data\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", proto)));\n\t\tprint_unknown_data(ndo, p, \"\\n\\t\", length);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t aliases_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", s->refcount < 0 ? 0 : s->refcount - 1);\n}", "target": 0}
{"code": "  virtual void ConnectToWifiNetwork(const WifiNetwork* network,\n                                    const std::string& password,\n                                    const std::string& identity,\n                                    const std::string& certpath) {}", "target": 0}
{"code": "*/\nPHP_FUNCTION(date_interval_create_from_date_string)\n{\n\tchar           *time_str = NULL;\n\tint             time_str_len = 0;\n\ttimelib_time   *time;\n\ttimelib_error_container *err = NULL;\n\tphp_interval_obj *diobj;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &time_str, &time_str_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tphp_date_instantiate(date_ce_interval, return_value TSRMLS_CC);\n\ttime = timelib_strtotime(time_str, time_str_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\tdiobj = (php_interval_obj *) zend_object_store_get_object(return_value TSRMLS_CC);\n\tdiobj->diff = timelib_rel_time_clone(&time->relative);\n\tdiobj->initialized = 1;\n\ttimelib_time_dtor(time);\n\ttimelib_error_container_dtor(err);", "target": 0}
{"code": "void close_cached_dir(struct cached_fid *cfid)\n{\n\tmutex_lock(&cfid->fid_mutex);\n\tkref_put(&cfid->refcount, smb2_close_cached_fid);\n\tmutex_unlock(&cfid->fid_mutex);\n}", "target": 0}
{"code": "static int sanity_check_raw_super(struct super_block *sb,\n\t\t\tstruct f2fs_super_block *raw_super)\n{\n\tunsigned int blocksize;\n\tif (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\tF2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn 1;\n\t}\n\tif (F2FS_BLKSIZE != PAGE_CACHE_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid page_cache_size (%lu), supports only 4KB\\n\",\n\t\t\tPAGE_CACHE_SIZE);\n\t\treturn 1;\n\t}\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid blocksize (%u), supports only 4KB\\n\",\n\t\t\tblocksize);\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "SPL_METHOD(Array, getFlags)\n{\n\tzval *object = getThis();\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(intern->ar_flags & ~SPL_ARRAY_INT_MASK);\n}", "target": 0}
{"code": "static void cmd_sdbk(Sdb *db, const char *input) {\n\tchar *out = (input[0] == ' ')\n\t\t? sdb_querys (db, NULL, 0, input + 1)\n\t\t: sdb_querys (db, NULL, 0, \"*\");\n\tif (out) {\n\t\tr_cons_println (out);\n\t\tfree (out);\n\t} else {\n\t\tR_LOG_ERROR (\"Usage: ask [query]\");\n\t}\n}", "target": 1}
{"code": "  String_Obj Parser::parse_url_function_string()\n  {\n    std::string prefix(\"\");\n    if (lex< uri_prefix >()) {\n      prefix = std::string(lexed);\n    }\n    lex < optional_spaces >();\n    String_Obj url_string = parse_url_function_argument();\n    std::string suffix(\"\");\n    if (lex< real_uri_suffix >()) {\n      suffix = std::string(lexed);\n    }\n    std::string uri(\"\");\n    if (url_string) {\n      uri = url_string->to_string({ NESTED, 5 });\n    }\n    if (String_Schema* schema = Cast<String_Schema>(url_string)) {\n      String_Schema_Obj res = SASS_MEMORY_NEW(String_Schema, pstate);\n      res->append(SASS_MEMORY_NEW(String_Constant, pstate, prefix));\n      res->append(schema);\n      res->append(SASS_MEMORY_NEW(String_Constant, pstate, suffix));\n      return res;\n    } else {\n      std::string res = prefix + uri + suffix;\n      return SASS_MEMORY_NEW(String_Constant, pstate, res);\n    }\n  }", "target": 0}
{"code": "static ha_rows get_quick_record_count(THD *thd, SQL_SELECT *select,\n\t\t\t\t      TABLE *table,\n\t\t\t\t      const key_map *keys,ha_rows limit)\n{\n  int error;\n  DBUG_ENTER(\"get_quick_record_count\");\n  uchar buff[STACK_BUFF_ALLOC];\n  if (check_stack_overrun(thd, STACK_MIN_SIZE, buff))\n    DBUG_RETURN(0);                           \n  if (select)\n  {\n    select->head=table;\n    table->reginfo.impossible_range=0;\n    if ((error= select->test_quick_select(thd, *(key_map *)keys,(table_map) 0,\n                                          limit, 0, FALSE, \n                                          TRUE )) == 1)\n      DBUG_RETURN(select->quick->records);\n    if (error == -1)\n    {\n      table->reginfo.impossible_range=1;\n      DBUG_RETURN(0);\n    }\n    DBUG_PRINT(\"warning\",(\"Couldn't use record count on const keypart\"));\n  }\n  DBUG_RETURN(HA_POS_ERROR);\t\t\t\n}", "target": 0}
{"code": "aspath_segment_add (struct aspath *as, int type)\n{\n  struct assegment *seg = as->segments;\n  struct assegment *new = assegment_new (type, 0);\n  if (seg)\n    {\n      while (seg->next)\n\tseg = seg->next;\n      seg->next = new;\n    }\n  else\n    as->segments = new;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* const context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &resource));\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features\",\n                                                &bucketized_features_list));\n    std::vector<tensorflow::TTypes<int32>::ConstMatrix> bucketized_features;\n    bucketized_features.reserve(bucketized_features_list.size());\n    ConvertVectorsToMatrices(bucketized_features_list, bucketized_features);\n    const int batch_size = bucketized_features[0].dimension(0);\n    Tensor* output_logits_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"logits\", {batch_size, logits_dimension_},\n                                &output_logits_t));\n    auto output_logits = output_logits_t->matrix<float>();\n    if (resource->num_trees() <= 0) {\n      output_logits.setZero();\n      return;\n    }\n    const int32 last_tree = resource->num_trees() - 1;\n    auto do_work = [&resource, &bucketized_features, &output_logits, last_tree,\n                    this](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        std::vector<float> tree_logits(logits_dimension_, 0.0);\n        int32 tree_id = 0;\n        int32 node_id = 0;\n        while (true) {\n          if (resource->is_leaf(tree_id, node_id)) {\n            const float tree_weight = resource->GetTreeWeight(tree_id);\n            const auto& leaf_logits = resource->node_value(tree_id, node_id);\n            DCHECK_EQ(leaf_logits.size(), logits_dimension_);\n            for (int32 j = 0; j < logits_dimension_; ++j) {\n              tree_logits[j] += tree_weight * leaf_logits[j];\n            }\n            if (tree_id == last_tree) {\n              break;\n            }\n            ++tree_id;\n            node_id = 0;\n          } else {\n            node_id =\n                resource->next_node(tree_id, node_id, i, bucketized_features);\n          }\n        }\n        for (int32 j = 0; j < logits_dimension_; ++j) {\n          output_logits(i, j) = tree_logits[j];\n        }\n      }\n    };\n    const int64 cost = (last_tree + 1) * 10;\n    thread::ThreadPool* const worker_threads =\n        context->device()->tensorflow_cpu_worker_threads()->workers;\n    Shard(worker_threads->NumThreads(), worker_threads, batch_size,\n          cost, do_work);\n  }", "target": 1}
{"code": "int nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)\n{\n\tint rc = 0;\n\tu8 *gb;\n\tsize_t gb_len;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s comm %d\\n\", dev_name(&dev->dev), comm_mode);\n\tif (!dev->ops->dep_link_up)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == true) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tgb = nfc_llcp_general_bytes(dev, &gb_len);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_index);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_up(dev, target, comm_mode, gb, gb_len);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "localtime_r(const time_t *t, struct tm *tm)\n{\n    auto struct tm *tmp = localtime(t);\n    if (tmp)\n\t*tm = *tmp;\n    return tmp;\n}", "target": 0}
{"code": "PackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "static const unsigned char *parse_object(cJSON *item, const unsigned char *value, const unsigned char **ep)\n{\n    cJSON *child = NULL;\n    if (*value != '{')\n    {\n        *ep = value;\n        goto fail;\n    }\n    item->type = cJSON_Object;\n    value = skip(value + 1);\n    if (*value == '}')\n    {\n        return value + 1;\n    }\n    child = cJSON_New_Item();\n    item->child = child;\n    if (!item->child)\n    {\n        goto fail;\n    }\n    value = skip(parse_string(child, skip(value), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n    child->string = child->valuestring;\n    child->valuestring = NULL;\n    if (*value != ':')\n    {\n        *ep = value;\n        goto fail;\n    }\n    value = skip(parse_value(child, skip(value + 1), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n    while (*value == ',')\n    {\n        cJSON *new_item = NULL;\n        if (!(new_item = cJSON_New_Item()))\n        {\n            goto fail;\n        }\n        child->next = new_item;\n        new_item->prev = child;\n        child = new_item;\n        value = skip(parse_string(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n        child->string = child->valuestring;\n        child->valuestring = NULL;\n        if (*value != ':')\n        {\n            *ep = value;\n            goto fail;\n        }\n        value = skip(parse_value(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n    }\n    if (*value == '}')\n    {\n        return value + 1;\n    }\n    *ep = value;\nfail:\n    if (item->child != NULL)\n    {\n        cJSON_Delete(child);\n        item->child = NULL;\n    }\n    return NULL;\n}", "target": 1}
{"code": "void EditorClientBlackBerry::undo()\n{\n    if (canUndo()) {\n        EditCommandStack::iterator back = --m_undoStack.end();\n        RefPtr<UndoStep> command(*back);\n        m_undoStack.remove(back);\n        command->unapply();\n    }\n}", "target": 0}
{"code": "file_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\tif (a->num_values)\n\t{\n \t    switch (a->name)\n \t    {\n \t    case MAPI_ATTACH_LONG_FILENAME:\n \t\tif (file->name) XFREE(file->name);\n \t\tfile->name = strdup( (char*)a->values[0].data.buf );\n \t\tbreak;\n \t    case MAPI_ATTACH_DATA_OBJ:\n \t\tfile->len = a->values[0].len;\n \t\tif (file->data) XFREE (file->data);\n \t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n \t\tmemmove (file->data, a->values[0].data.buf, file->len);\n \t\tbreak;\n              case MAPI_ATTACH_MIME_TAG:\n \t\tif (file->mime_type) XFREE (file->mime_type);\n \t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n \t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n \t\tbreak;\n                 case MAPI_ATTACH_CONTENT_ID:\n                     if (file->content_id) XFREE(file->content_id);\n                     file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                     memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\n                    break;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    }\n}", "target": 1}
{"code": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n     segment->nb_index_entries = avio_rb32(pb);\n     length = avio_rb32(pb);\n     if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n         !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n     }\n     for (i = 0; i < segment->nb_index_entries; i++) {\n         segment->temporal_offset_entries[i] = avio_r8(pb);\n         avio_r8(pb);                                        \n         segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}", "target": 1}
{"code": "ext4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}", "target": 1}
{"code": "void Document::ProcessBaseElement() {\n  UseCounter::Count(*this, WebFeature::kBaseElement);\n  const AtomicString* href = nullptr;\n  const AtomicString* target = nullptr;\n  for (HTMLBaseElement* base = Traversal<HTMLBaseElement>::FirstWithin(*this);\n       base && (!href || !target);\n       base = Traversal<HTMLBaseElement>::Next(*base)) {\n    if (!href) {\n      const AtomicString& value = base->FastGetAttribute(hrefAttr);\n      if (!value.IsNull())\n        href = &value;\n    }\n    if (!target) {\n      const AtomicString& value = base->FastGetAttribute(targetAttr);\n      if (!value.IsNull())\n        target = &value;\n    }\n    if (GetContentSecurityPolicy()->IsActive()) {\n      UseCounter::Count(*this,\n                        WebFeature::kContentSecurityPolicyWithBaseElement);\n    }\n  }\n  KURL base_element_url;\n  if (href) {\n    String stripped_href = StripLeadingAndTrailingHTMLSpaces(*href);\n    if (!stripped_href.IsEmpty())\n      base_element_url = KURL(FallbackBaseURL(), stripped_href);\n  }\n  if (!base_element_url.IsEmpty()) {\n    if (base_element_url.ProtocolIsData()) {\n      UseCounter::Count(*this, WebFeature::kBaseWithDataHref);\n      AddConsoleMessage(ConsoleMessage::Create(\n          kSecurityMessageSource, kErrorMessageLevel,\n          \"'data:' URLs may not be used as base URLs for a document.\"));\n    }\n    if (!GetSecurityOrigin()->CanRequest(base_element_url))\n      UseCounter::Count(*this, WebFeature::kBaseWithCrossOriginHref);\n  }\n  if (base_element_url != base_element_url_ &&\n      !base_element_url.ProtocolIsData() &&\n      GetContentSecurityPolicy()->AllowBaseURI(base_element_url)) {\n    base_element_url_ = base_element_url;\n    UpdateBaseURL();\n  }\n  if (target) {\n    if (target->Contains('\\n') || target->Contains('\\r'))\n      UseCounter::Count(*this, WebFeature::kBaseWithNewlinesInTarget);\n    if (target->Contains('<'))\n      UseCounter::Count(*this, WebFeature::kBaseWithOpenBracketInTarget);\n    base_target_ = *target;\n  } else {\n    base_target_ = g_null_atom;\n  }\n}", "target": 0}
{"code": "wb_id(netdissect_options *ndo,\n      const struct pkt_id *id, u_int len)\n{\n\tint i;\n\tconst char *cp;\n\tconst struct id_off *io;\n\tchar c;\n\tint nid;\n\tND_PRINT((ndo, \" wb-id:\"));\n\tif (len < sizeof(*id) || !ND_TTEST(*id))\n\t\treturn (-1);\n\tlen -= sizeof(*id);\n\tND_PRINT((ndo, \" %u/%s:%u (max %u/%s:%u) \",\n\t       EXTRACT_32BITS(&id->pi_ps.slot),\n\t       ipaddr_string(ndo, &id->pi_ps.page.p_sid),\n\t       EXTRACT_32BITS(&id->pi_ps.page.p_uid),\n\t       EXTRACT_32BITS(&id->pi_mslot),\n\t       ipaddr_string(ndo, &id->pi_mpage.p_sid),\n\t       EXTRACT_32BITS(&id->pi_mpage.p_uid)));\n\tnid = EXTRACT_16BITS(&id->pi_ps.nid);\n\tlen -= sizeof(*io) * nid;\n\tio = (struct id_off *)(id + 1);\n\tcp = (char *)(io + nid);\n\tif (!ND_TTEST2(cp, len)) {\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t\tfn_print(ndo, (u_char *)cp, (u_char *)cp + len);\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\tc = '<';\n\tfor (i = 0; i < nid && ND_TTEST(*io); ++io, ++i) {\n\t\tND_PRINT((ndo, \"%c%s:%u\",\n\t\t    c, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off)));\n\t\tc = ',';\n\t}\n\tif (i >= nid) {\n\t\tND_PRINT((ndo, \">\"));\n\t\treturn (0);\n\t}\n\treturn (-1);\n}", "target": 1}
{"code": "    void registerMockedHttpURLLoad(const std::string& fileName)\n    {\n        URLTestHelpers::registerMockedURLFromBaseURL(WebString::fromUTF8(m_baseURL.c_str()), WebString::fromUTF8(fileName.c_str()));\n    }", "target": 0}
{"code": "ChildProcessSecurityPolicyImpl* ChildProcessSecurityPolicyImpl::GetInstance() {\n  return Singleton<ChildProcessSecurityPolicyImpl>::get();\n}", "target": 0}
{"code": "static const char *set_cgi_var(cmd_parms *cmd, void *d_,\n                               const char *var, const char *rule_)\n{\n    core_dir_config *d = d_;\n    char *rule = apr_pstrdup(cmd->pool, rule_);\n    ap_str_tolower(rule);\n    if (!strcmp(var, \"REQUEST_URI\")) {\n        if (strcmp(rule, \"current-uri\") && strcmp(rule, \"original-uri\")) {\n            return \"Valid rules for REQUEST_URI are 'current-uri' and 'original-uri'\";\n        }\n    }\n    else {\n        return apr_pstrcat(cmd->pool, \"Unrecognized CGI variable: \\\"\",\n                           var, \"\\\"\", NULL);\n    }\n    if (!d->cgi_var_rules) {\n        d->cgi_var_rules = apr_hash_make(cmd->pool);\n    }\n    apr_hash_set(d->cgi_var_rules, var, APR_HASH_KEY_STRING, rule);\n    return NULL;\n}", "target": 0}
{"code": "static Jsi_RC DebugAddCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash)\n        interp->breakpointHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    int argc = Jsi_ValueGetLength(interp, args);\n    jsi_BreakPoint *bptr, bp = {};\n    Jsi_Number vnum;\n    if (argc>1 && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, 1), &bp.temp) != JSI_OK) \n        return Jsi_LogError(\"bad boolean\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueGetNumber(interp, v, &vnum) == JSI_OK) {\n        bp.line = (int)vnum;\n        bp.file = interp->curFile;\n    } else {\n        const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n        const char *cp;\n        if (isdigit(val[0])) {\n            if (Jsi_GetInt(interp, val, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            bp.file = interp->curFile;\n        } else if ((cp = Jsi_Strchr(val, ':'))) {\n            if (Jsi_GetInt(interp, cp+1, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            Jsi_DString dStr = {};\n            Jsi_DSAppendLen(&dStr, val, cp-val);\n            bp.file = Jsi_KeyAdd(interp, Jsi_DSValue(&dStr));\n            Jsi_DSFree(&dStr);\n        } else {\n            bp.func = Jsi_KeyAdd(interp, val);\n        }\n    }\n    if (bp.line<=0 && !bp.func) \n        return Jsi_LogError(\"bad number\");\n    char nbuf[100];\n    bp.id = ++interp->debugOpts.breakIdx;\n    bp.enabled = 1;\n    snprintf(nbuf, sizeof(nbuf), \"%d\", bp.id);\n    bptr = (jsi_BreakPoint*)Jsi_Malloc(sizeof(*bptr));\n    *bptr = bp;\n    Jsi_HashSet(interp->breakpointHash, (void*)nbuf, bptr);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)bp.id);\n    return JSI_OK;\n}", "target": 1}
{"code": "static int parse_video_info(AVIOContext *pb, AVStream *st)\n{\n    uint16_t size_asf; \n    uint32_t size_bmp; \n    unsigned int tag;\n    st->codecpar->width  = avio_rl32(pb);\n    st->codecpar->height = avio_rl32(pb);\n    avio_skip(pb, 1); \n    size_asf = avio_rl16(pb);\n    tag = ff_get_bmp_header(pb, st, &size_bmp);\n    st->codecpar->codec_tag = tag;\n    st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);\n    size_bmp = FFMAX(size_asf, size_bmp);\n    if (size_bmp > BMP_HEADER_SIZE) {\n        int ret;\n        st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;\n        if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +\n                                               AV_INPUT_BUFFER_PADDING_SIZE))) {\n            st->codecpar->extradata_size = 0;\n            return AVERROR(ENOMEM);\n        }\n        memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,\n               AV_INPUT_BUFFER_PADDING_SIZE);\n        if ((ret = avio_read(pb, st->codecpar->extradata,\n                             st->codecpar->extradata_size)) < 0)\n            return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "static ssize_t hid_debug_events_read(struct file *file, char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hid_debug_list *list = file->private_data;\n\tint ret = 0, len;\n\tDECLARE_WAITQUEUE(wait, current);\n\tmutex_lock(&list->read_mutex);\n\twhile (ret == 0) {\n\t\tif (list->head == list->tail) {\n\t\t\tadd_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\twhile (list->head == list->tail) {\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!list->hdev || !list->hdev->debug) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&list->read_mutex);\n\t\t\t\tschedule();\n\t\t\t\tmutex_lock(&list->read_mutex);\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t}\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\ncopy_rest:\n\t\tif (list->tail == list->head)\n\t\t\tgoto out;\n\t\tif (list->tail > list->head) {\n\t\t\tlen = list->tail - list->head;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\t\t\tif (copy_to_user(buffer + ret, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret += len;\n\t\t\tlist->head += len;\n\t\t} else {\n\t\t\tlen = HID_DEBUG_BUFSIZE - list->head;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\t\t\tif (copy_to_user(buffer, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlist->head = 0;\n\t\t\tret += len;\n\t\t\tcount -= len;\n\t\t\tif (count > 0)\n\t\t\t\tgoto copy_rest;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&list->read_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\t\tnewdst = 0;\n \t\trcu_read_lock();\n \t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n \t\t\tifa = indev->ifa_list;\n \t\t\tnewdst = ifa->ifa_local;\n \t\t}\n\t\trcu_read_unlock();\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}", "target": 1}
{"code": "static void clearSelect(sqlite3 *db, Select *p, int bFree){\n  while( p ){\n    Select *pPrior = p->pPrior;\n    sqlite3ExprListDelete(db, p->pEList);\n    sqlite3SrcListDelete(db, p->pSrc);\n    sqlite3ExprDelete(db, p->pWhere);\n    sqlite3ExprListDelete(db, p->pGroupBy);\n    sqlite3ExprDelete(db, p->pHaving);\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    sqlite3ExprDelete(db, p->pLimit);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( OK_IF_ALWAYS_TRUE(p->pWinDefn) ){\n      sqlite3WindowListDelete(db, p->pWinDefn);\n    }\n#endif\n    if( OK_IF_ALWAYS_TRUE(p->pWith) ) sqlite3WithDelete(db, p->pWith);\n    if( bFree ) sqlite3DbFreeNN(db, p);\n    p = pPrior;\n    bFree = 1;\n  }\n}", "target": 0}
{"code": "void HTMLMediaElement::CancelledRemotePlaybackRequest() {\n  if (RemotePlaybackClient())\n    RemotePlaybackClient()->PromptCancelled();\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    MaxPoolingOp<Device, T>::Compute(context);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "static plist_t parse_dict_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_i = 0, str_j = 0;\n    uint64_t index1, index2;\n    plist_data_t data = plist_new_plist_data();\n    const char *const end_data = bplist->data + bplist->size;\n    const char *index1_ptr = NULL;\n    const char *index2_ptr = NULL;\n    data->type = PLIST_DICT;\n    data->length = size;\n    plist_t node = node_create(NULL, data);\n    for (j = 0; j < data->length; j++) {\n        str_i = j * bplist->dict_size;\n        str_j = (j + size) * bplist->dict_size;\n        index1_ptr = (*bnode) + str_i;\n        index2_ptr = (*bnode) + str_j;\n        if ((index1_ptr < bplist->data || index1_ptr + bplist->dict_size >= end_data) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->dict_size >= end_data)) {\n            plist_free(node);\n            return NULL;\n        }\n        index1 = UINT_TO_HOST(index1_ptr, bplist->dict_size);\n        index2 = UINT_TO_HOST(index2_ptr, bplist->dict_size);\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        if (index2 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        plist_t key = parse_bin_node_at_index(bplist, index1);\n        if (!key) {\n            plist_free(node);\n            return NULL;\n        }\n        plist_get_data(key)->type = PLIST_KEY;\n        if (!plist_get_data(key)->strval) {\n            fprintf(stderr, \"ERROR: Malformed binary plist dict, invalid key node encountered!\\n\");\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n        plist_t val = parse_bin_node_at_index(bplist, index2);\n        if (!val) {\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n        node_attach(node, key);\n        node_attach(node, val);\n    }\n    return node;\n}", "target": 1}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 1}
{"code": "seamless_process(STREAM s)\n {\n \tunsigned int pkglen;\n \tchar *buf;\n \tpkglen = s->end - s->p;\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);\n\txfree(buf);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, NEOnMultikeyIndex) {\n    addIndex(BSON(\"a\" << 1), true);\n    runQuery(fromjson(\"{a: {$ne: 3}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {a:{$ne:3}}, node: {ixscan: {pattern: {a:1}, \"\n        \"bounds: {a: [['MinKey',3,true,false],\"\n        \"[3,'MaxKey',false,true]]}}}}}\");\n}", "target": 0}
{"code": "void Clipboard::WriteWebSmartPaste() {\n  InsertMapping(kMimeTypeWebkitSmartPaste, NULL, 0);\n}", "target": 0}
{"code": "void sock_update_classid(struct sock *sk)\n{\n\tu32 classid;\n\trcu_read_lock();  \n\tclassid = task_cls_classid(current);\n\trcu_read_unlock();\n\tif (classid && classid != sk->sk_classid)\n\t\tsk->sk_classid = classid;\n}", "target": 0}
{"code": "double AccessibilityUIElement::clickPointY()\n{\n    return 0.0f;\n}", "target": 0}
{"code": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n {\n\tstruct list_head *tmp;\n \tstruct cifsSesInfo *ses;\n \twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n \t\t++ses->ses_count;\n \t\twrite_unlock(&cifs_tcp_ses_lock);\n \t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 1}
{"code": "static inline int nla_put_u32(struct sk_buff *skb, int attrtype, u32 value)\n{\n\treturn nla_put(skb, attrtype, sizeof(u32), &value);\n}", "target": 0}
{"code": "GF_Err adkm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    OP_REQUIRES(context, params.depth_window == 1,\n                errors::Unimplemented(\"Non-spatial pooling is not \"\n                                      \"yet supported. Volunteers? :)\"));\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, params.forward_output_shape(), &output));\n    const int32_t highest = static_cast<int32>(Eigen::NumTraits<T>::highest());\n    const int32_t lowest = static_cast<int32>(Eigen::NumTraits<T>::lowest());\n    Tensor int32_output(DT_INT32, params.forward_output_shape());\n    Tensor int32_input(DT_INT32, tensor_in.shape());\n    int32_input.flat<int32>() = tensor_in.flat<T>().template cast<int32>();\n    SpatialAvgPool<Device, int32>(context, &int32_output, int32_input, params,\n                                  padding_);\n    output->flat<T>() = int32_output.flat<int32>()\n                            .cwiseMax(lowest)\n                            .cwiseMin(highest)\n                            .template cast<T>();\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "zend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object *dir_object;\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_tree_it_funcs;\n\t}\n\tzval_add_ref(&object);\n\treturn (zend_object_iterator*)iterator;\n}", "target": 0}
{"code": "static char *red_stream_get_local_address(RedStream *stream)\n{\n    return addr_to_string(\"%s;%s\", &stream->priv->info->laddr_ext,\n                          stream->priv->info->llen_ext);\n}", "target": 0}
{"code": "void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n{\n\tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n\t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}", "target": 1}
{"code": "static inline void *packet_previous_frame(struct packet_sock *po,\n\t\tstruct packet_ring_buffer *rb,\n\t\tint status)\n{\n\tunsigned int previous = rb->head ? rb->head - 1 : rb->frame_max;\n\treturn packet_lookup_frame(po, rb, previous, status);\n}", "target": 0}
{"code": "bgp_attr_finish (void)\n{\n  aspath_finish ();\n  attrhash_finish ();\n  community_finish ();\n  ecommunity_finish ();\n  cluster_finish ();\n  transit_finish ();\n}", "target": 0}
{"code": "wchar* ConvertPath(const wchar *SrcPath,wchar *DestPath,size_t DestSize)\n{\n  const wchar *DestPtr=SrcPath;\n  for (const wchar *s=DestPtr;*s!=0;s++)\n    if (IsPathDiv(s[0]) && s[1]=='.' && s[2]=='.' && IsPathDiv(s[3]))\n      DestPtr=s+4;\n  while (*DestPtr!=0)\n  {\n    const wchar *s=DestPtr;\n    if (s[0]!=0 && IsDriveDiv(s[1]))\n      s+=2;\n    if (s[0]=='\\\\' && s[1]=='\\\\')\n    {\n      const wchar *Slash=wcschr(s+2,'\\\\');\n      if (Slash!=NULL && (Slash=wcschr(Slash+1,'\\\\'))!=NULL)\n        s=Slash+1;\n    }\n    for (const wchar *t=s;*t!=0;t++)\n      if (IsPathDiv(*t))\n        s=t+1;\n      else\n        if (*t!='.')\n          break;\n    if (s==DestPtr)\n      break;\n    DestPtr=s;\n  }\n  if (DestPtr[0]=='.' && DestPtr[1]=='.' && DestPtr[2]==0)\n    DestPtr+=2;\n  if (DestPath!=NULL)\n  {\n    wchar TmpStr[NM];\n    wcsncpyz(TmpStr,DestPtr,ASIZE(TmpStr));\n    wcsncpyz(DestPath,TmpStr,DestSize);\n  }\n  return (wchar *)DestPtr;\n}", "target": 1}
{"code": "is_mbc_ambiguous(OnigCaseFoldType flag,\n\t\t const UChar** pp, const UChar* end)\n{\n  return onigenc_mbn_is_mbc_ambiguous(enc, flag, pp, end);\n}", "target": 0}
{"code": "sasl_handle_login(struct sasl_session *const restrict p, struct user *const u, struct myuser *mu)\n{\n\tbool was_killed = false;\n\tif (! mu)\n\t{\n\t\tif (! *p->authzeid)\n\t\t{\n\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an authzeid (BUG)\",\n\t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\t\t\treturn false;\n\t\t}\n\t\tif (! (mu = myuser_find_uid(p->authzeid)))\n\t\t{\n\t\t\tif (*p->authzid)\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",\n\t\t\t\t                                      p->authzid);\n\t\t\telse\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account dropped; login cancelled\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (u->myuser && u->myuser != mu)\n\t{\n\t\tif (is_soper(u->myuser))\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_ADMIN, \"DESOPER: \\2%s\\2 as \\2%s\\2\",\n\t\t\t                                                 u->nick, entity(u->myuser)->name);\n\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGOUT\");\n\t\tif (! (was_killed = ircd_on_logout(u, entity(u->myuser)->name)))\n\t\t{\n\t\t\tmowgli_node_t *n;\n\t\t\tMOWGLI_ITER_FOREACH(n, u->myuser->logins.head)\n\t\t\t{\n\t\t\t\tif (n->data == u)\n\t\t\t\t{\n\t\t\t\t\t(void) mowgli_node_delete(n, &u->myuser->logins);\n\t\t\t\t\t(void) mowgli_node_free(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu->myuser = NULL;\n\t\t}\n\t}\n\tif (! was_killed)\n\t{\n\t\tif (u->myuser != mu)\n\t\t{\n\t\t\t(void) myuser_login(saslsvs, u, mu, false);\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGIN (%s)\", p->mechptr->name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmu->lastlogin = CURRTIME;\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"REAUTHENTICATE (%s)\", p->mechptr->name);\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "ProtoValidationTypeString(const ServiceValidationResultsType t)\n{\n   switch (t) {\n   case VALIDATION_RESULTS_TYPE_NAMEPASSWORD:\n      return VGAUTH_USERHANDLE_TYPE_NAMEPASSWORD;\n   case VALIDATION_RESULTS_TYPE_SSPI:\n      return VGAUTH_USERHANDLE_TYPE_SSPI;\n   case VALIDATION_RESULTS_TYPE_SAML:\n      return VGAUTH_USERHANDLE_TYPE_SAML;\n   case VALIDATION_RESULTS_TYPE_SAML_INFO_ONLY:\n      return VGAUTH_USERHANDLE_TYPE_SAML_INFO_ONLY;\n   case VALIDATION_RESULTS_TYPE_UNKNOWN:\n   default:\n      ASSERT(0);\n      Warning(\"%s: Tried to convert a validationType of %d to a string\\n\",\n              __FUNCTION__, t);\n      return \"<UNKNOWN>\";\n   }\n}", "target": 0}
{"code": "static void _php_pgsql_notice_handler(void *resource_id, const char *message)\n{\n\tphp_pgsql_notice *notice;\n\tTSRMLS_FETCH();\n\tif (! PGG(ignore_notices)) {\n\t\tnotice = (php_pgsql_notice *)emalloc(sizeof(php_pgsql_notice));\n\t\tnotice->message = _php_pgsql_trim_message(message, (int *)&notice->len);\n\t\tif (PGG(log_notices)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"%s\", notice->message);\n\t\t}\n\t\tzend_hash_index_update(&PGG(notices), (ulong)resource_id, (void **)&notice, sizeof(php_pgsql_notice *), NULL);\n\t}\n}", "target": 0}
{"code": "void l2tp_packet_print(const struct l2tp_packet_t *pack,\n\t\t       void (*print)(const char *fmt, ...))\n{\n\tconst struct l2tp_attr_t *attr;\n\tconst struct l2tp_dict_value_t *val;\n\tif (pack->hdr.ver == 2) {\n\t\tprint(\"[L2TP tid=%u sid=%u\", ntohs(pack->hdr.tid), ntohs(pack->hdr.sid));\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t} else {\n\t\tprint(\"[L2TP cid=%u\", pack->hdr.cid);\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t}\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tprint(\" <%s\", attr->attr->name);\n\t\tval = l2tp_dict_find_value(attr->attr, attr->val);\n\t\tif (val)\n\t\t\tprint(\" %s\", val->name);\n\t\telse if (attr->H)\n\t\t\tprint(\" (hidden, %hu bytes)\", attr->length);\n\t\telse {\n\t\t\tswitch (attr->attr->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tprint(\" %i\", attr->val.int16);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tprint(\" %i\", attr->val.int32);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tprint(\" %s\", attr->val.string);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprint(\">\");\n\t}\n\tprint(\"]\\n\");\n}", "target": 1}
{"code": "void hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; \n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else \n            c+= sprintf(&str[c], \"   \");\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) \n                    str[c++] = ' ';\n                else if(isprint(mem[j])) \n                    str[c++] = 0xFF & mem[j];\n                else \n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, str);\n            c = 0;\n        }\n    }\n}", "target": 1}
{"code": "static void _WM_CheckEventMemoryPool(struct _mdi *mdi) {\n    if ((mdi->event_count + 1) >= mdi->events_size) {\n        mdi->events_size += MEM_CHUNK;\n        mdi->events = realloc(mdi->events,\n                              (mdi->events_size * sizeof(struct _event)));\n    }\n}", "target": 0}
{"code": "void cgit_snapshot_link(const char *name, const char *title, const char *class,\n\t\t\tconst char *head, const char *rev,\n\t\t\tconst char *archivename)\n{\n\treporevlink(\"snapshot\", name, title, class, head, rev, archivename);\n}", "target": 0}
{"code": "    Loader::Loader(PreviewId id, const Image &image)\n        : id_(id), image_(image),\n          width_(0), height_(0),\n          size_(0),\n          valid_(false)\n    {\n    }", "target": 0}
{"code": "static int getSingletonPos(const char* str)\n{\n\tint result =-1;\n\tint i=0;\n\tint len = 0;\n\tif( str && ((len=strlen(str))>0) ){\n\t\tfor( i=0; i<len ; i++){\n\t\t\tif( isIDSeparator(*(str+i)) ){\n\t\t\t\tif( i==1){\n\t\t\t\t\tresult =0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif( isIDSeparator(*(str+i+2)) ){\n\t\t\t\t\t\tresult = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "void sum_update(const char *p, int32 len)\n{\n\tswitch (cursum_type) {\n\t  case CSUM_MD5:\n\t\tmd5_update(&md, (uchar *)p, len);\n\t\tbreak;\n          case CSUM_MD4:\n          case CSUM_MD4_OLD:\n          case CSUM_MD4_BUSTED:\n                if (len + sumresidue < CSUM_CHUNK) {\n                        memcpy(md.buffer + sumresidue, p, len);\n                        sumresidue += len;\n\t\t}\n\t\tif (sumresidue) {\n\t\t\tint32 i = CSUM_CHUNK - sumresidue;\n\t\t\tmemcpy(md.buffer + sumresidue, p, i);\n\t\t\tmdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);\n\t\t\tlen -= i;\n\t\t\tp += i;\n\t\t}\n\t\twhile (len >= CSUM_CHUNK) {\n\t\t\tmdfour_update(&md, (uchar *)p, CSUM_CHUNK);\n\t\t\tlen -= CSUM_CHUNK;\n\t\t\tp += CSUM_CHUNK;\n\t\t}\n\t\tsumresidue = len;\n\t\tif (sumresidue)\n\t\t\tmemcpy(md.buffer, p, sumresidue);\n\t\tbreak;\n\t  case CSUM_NONE:\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "void\nPerl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren,\n\t\t\t\t\t\t\t SV const * const value)\n{\n    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE;\n    PERL_UNUSED_ARG(rx);\n    PERL_UNUSED_ARG(paren);\n    PERL_UNUSED_ARG(value);\n    if (!PL_localizing)\n        Perl_croak_no_modify();", "target": 0}
{"code": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  mutt_message(_(\"Logging in...\"));\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n  if (!rc)\n  {\n    mutt_clear_error(); \n    return IMAP_AUTH_SUCCESS;\n  }\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 1}
{"code": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) \n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}", "target": 1}
{"code": "static int nsim_bpf_verifier_prep(struct bpf_prog *prog)\n{\n\tstruct nsim_dev *nsim_dev =\n\t\t\tbpf_offload_dev_priv(prog->aux->offload->offdev);\n\tif (!nsim_dev->bpf_bind_accept)\n\t\treturn -EOPNOTSUPP;\n\treturn nsim_bpf_create_prog(nsim_dev, prog);\n}", "target": 0}
{"code": "PHP_FUNCTION(snmpwalk)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, (SNMP_CMD_WALK | SNMP_NUMERIC_KEYS), SNMP_VERSION_1);\n}", "target": 0}
{"code": "static void msf2_dma_tx(MSF2EmacState *s)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n    hwaddr desc = s->regs[R_DMA_TX_DESC];\n    uint8_t buf[MAX_PKT_SIZE];\n    EmacDesc d;\n    int size;\n    uint8_t pktcnt;\n    uint32_t status;\n    if (!(s->regs[R_CFG1] & R_CFG1_TX_EN_MASK)) {\n        return;\n    }\n    while (1) {\n        emac_load_desc(s, &d, desc);\n        if (d.pktsize & EMPTY_MASK) {\n            break;\n        }\n        size = d.pktsize & PKT_SIZE;\n        address_space_read(&s->dma_as, d.pktaddr, MEMTXATTRS_UNSPECIFIED,\n                           buf, size);\n        if (s->regs[R_CFG1] & R_CFG1_LB_EN_MASK) {\n            nc->info->receive(nc, buf, size);\n        } else {\n            qemu_send_packet(nc, buf, size);\n        }\n        d.pktsize |= EMPTY_MASK;\n        emac_store_desc(s, &d, desc);\n        status = s->regs[R_DMA_TX_STATUS];\n        pktcnt = FIELD_EX32(status, DMA_TX_STATUS, PKTCNT);\n        pktcnt++;\n        s->regs[R_DMA_TX_STATUS] = FIELD_DP32(status, DMA_TX_STATUS,\n                                              PKTCNT, pktcnt);\n        s->regs[R_DMA_TX_STATUS] |= R_DMA_TX_STATUS_PKT_SENT_MASK;\n        desc = d.next;\n    }\n    s->regs[R_DMA_TX_STATUS] |= R_DMA_TX_STATUS_UNDERRUN_MASK;\n    s->regs[R_DMA_TX_CTL] &= ~R_DMA_TX_CTL_EN_MASK;\n}", "target": 1}
{"code": "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\nerror:\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto value = ctx->input(0);\n    auto update = ctx->input(1);\n    OP_REQUIRES(\n        ctx, value.dims() == update.dims(),\n        errors::InvalidArgument(\"value and update shape doesn't match: \",\n                                value.shape().DebugString(), \" vs. \",\n                                update.shape().DebugString()));\n    for (int i = 1; i < value.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, value.dim_size(i) == update.dim_size(i),\n          errors::InvalidArgument(\"value and update shape doesn't match \",\n                                  value.shape().DebugString(), \" vs. \",\n                                  update.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, 1 == update.dim_size(0),\n                errors::InvalidArgument(\"update shape doesn't match: \",\n                                        update.shape().DebugString()));\n    Tensor output = value;  \n    const auto& d = ctx->eigen_device<Device>();\n    OP_REQUIRES_OK(\n        ctx, ::tensorflow::functor::DoParallelConcat(d, update, loc_, &output));\n    ctx->set_output(0, output);\n  }", "target": 1}
{"code": "static inline void sw_tx_timestamp(struct sk_buff *skb)\n{\n\tif (skb_shinfo(skb)->tx_flags & SKBTX_SW_TSTAMP &&\n\t    !(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))\n\t\tskb_tstamp_tx(skb, NULL);\n}", "target": 0}
{"code": "static bool is_maintenance_mode_cmd(struct kernel_ipmi_msg *msg)\n{\n\treturn (((msg->netfn == IPMI_NETFN_APP_REQUEST)\n\t\t && ((msg->cmd == IPMI_COLD_RESET_CMD)\n\t\t     || (msg->cmd == IPMI_WARM_RESET_CMD)))\n\t\t|| (msg->netfn == IPMI_NETFN_FIRMWARE_REQUEST));\n}", "target": 0}
{"code": "static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n \t\tcase 0xC0:\n \t\t\tl = p[1];\n \t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n \t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n \t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\treturn n;\n}", "target": 1}
{"code": "unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n\t\tif (optptr[0] == IPOPT_CIPSO)\n\t\t\treturn optptr;\n\t\ttaglen = optptr[1];\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "template <> HeaderMapImpl::StaticLookupTable<RequestHeaderMap>::StaticLookupTable() {\n#define REGISTER_DEFAULT_REQUEST_HEADER(name)                                                      \\\n  CustomInlineHeaderRegistry::registerInlineHeader<RequestHeaderMap::header_map_type>(             \\\n      Headers::get().name);\n  INLINE_REQ_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  INLINE_REQ_RESP_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  finalizeTable();\n  const auto handle =\n      CustomInlineHeaderRegistry::getInlineHeader<RequestHeaderMap::header_map_type>(\n          Headers::get().Host);\n  add(Headers::get().HostLegacy.get().c_str(), [handle](HeaderMapImpl& h) -> StaticLookupResponse {\n    return {&h.inlineHeaders()[handle.value().it_->second], &handle.value().it_->first};\n  });\n}", "target": 0}
{"code": "status_t Parcel::readUtf8FromUtf16(std::string* str) const {\n size_t utf16Size = 0;\n const char16_t* src = readString16Inplace(&utf16Size);\n if (!src) {\n return UNEXPECTED_NULL;\n }\n if (utf16Size == 0u) {\n        str->clear();\n        return NO_ERROR;\n     }\n    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size);\n    if (utf8Size < 0) {\n         return BAD_VALUE;\n     }\n    str->resize(utf8Size + 1);\n    utf16_to_utf8(src, utf16Size, &((*str)[0]));\n     str->resize(utf8Size);\n     return NO_ERROR;\n }", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 0}
{"code": "TIFFSetWriteOffset(TIFF* tif, toff_t off)\n{\n\ttif->tif_curoff = off;\n}", "target": 0}
{"code": "static irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\tif (sunkbd->reset <= -1) {\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tswitch (data) {\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_ALLUP: \n\t\tbreak;\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "void LibRaw::convert_to_rgb_loop(float out_cam[3][4]) {}", "target": 0}
{"code": "int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                    UINT32* pDstSize, UINT32 flags)\n {\n \tint status = -1;\n \tBYTE descriptor;\n \twStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);\n \tif (!stream)\n \t\treturn -1;\n\tif (Stream_GetRemainingLength(stream) < 1)\n\t\tgoto fail;\n\tStream_Read_UINT8(stream, descriptor); \n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t{\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n \t\t\tgoto fail;\n \t\t*ppDstData = NULL;\n \t\tif (zgfx->OutputCount > 0)\n \t\t\t*ppDstData = (BYTE*) malloc(zgfx->OutputCount);\n\t\tif (!*ppDstData)\n\t\t\tgoto fail;\n\t\t*pDstSize = zgfx->OutputCount;\n\t\tCopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);\n\t}\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t{\n\t\tUINT32 segmentSize;\n\t\tUINT16 segmentNumber;\n \t\tUINT16 segmentCount;\n \t\tUINT32 uncompressedSize;\n \t\tBYTE* pConcatenated;\n \t\tif (Stream_GetRemainingLength(stream) < 6)\n \t\t\tgoto fail;\n\t\tStream_Read_UINT16(stream, segmentCount); \n\t\tStream_Read_UINT32(stream, uncompressedSize); \n\t\tif (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))\n\t\t\tgoto fail;\n\t\tpConcatenated = (BYTE*) malloc(uncompressedSize);\n\t\tif (!pConcatenated)\n\t\t\tgoto fail;\n\t\t*ppDstData = pConcatenated;\n\t\t*pDstSize = uncompressedSize;\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(stream) < sizeof(UINT32))\n\t\t\t\tgoto fail;\n\t\t\tStream_Read_UINT32(stream, segmentSize); \n \t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n \t\t\t\tgoto fail;\n \t\t\tCopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);\n \t\t\tpConcatenated += zgfx->OutputCount;\n \t\t}\n \t}\n \telse\n\t{\n\t\tgoto fail;\n\t}\n\tstatus = 1;\nfail:\n\tStream_Free(stream, FALSE);\n\treturn status;\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::ImeConfirmComposition(\n    const base::string16& text,\n    const gfx::Range& replacement_range,\n    bool keep_selection) {\n  Send(new InputMsg_ImeConfirmComposition(\n        GetRoutingID(), text, replacement_range, keep_selection));\n}", "target": 0}
{"code": "static void fanout_release_data(struct packet_fanout *f)\n{\n\tswitch (f->type) {\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\t__fanout_set_data_bpf(f, NULL);\n\t};\n}", "target": 0}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                          const TfLiteTensor* indices, TfLiteTensor* output) {\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n    case kTfLiteUInt8:\n      return GatherNd<uint8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt16:\n      return GatherNd<int16_t, IndicesT>(params, indices, output);\n    case kTfLiteInt32:\n      return GatherNd<int32_t, IndicesT>(params, indices, output);\n    case kTfLiteInt64:\n      return GatherNd<int64_t, IndicesT>(params, indices, output);\n    case kTfLiteString:\n      return GatherNdString<IndicesT>(params, indices, output);\n    default:\n      context->ReportError(context,\n                           \"Params type '%s' are not supported by gather_nd.\",\n                           TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": " int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr)\n {\n \tstruct usb_descriptor_header *header;\n \twhile (size >= sizeof(struct usb_descriptor_header)) {\n \t\theader = (struct usb_descriptor_header *)buffer;\n\t\tif (header->bLength < 2) {\n \t\t\tprintk(KERN_ERR\n \t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n \t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n \t\t\treturn -1;\n \t\t}\n\t\tif (header->bDescriptorType == type) {\n \t\t\t*ptr = header;\n \t\t\treturn 0;\n \t\t}\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "static int thread_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\tstruct timespec *tp)\n{\n\treturn posix_cpu_clock_get(THREAD_CLOCK, tp);\n}", "target": 0}
{"code": "static void do_tx_packet(lan9118_state *s)\n{\n    int n;\n    uint32_t status;\n    if (s->phy_control & 0x4000)  {\n        lan9118_receive(qemu_get_queue(s->nic), s->txp->data, s->txp->len);\n    } else {\n        qemu_send_packet(qemu_get_queue(s->nic), s->txp->data, s->txp->len);\n    }\n    s->txp->fifo_used = 0;\n    if (s->tx_status_fifo_used == 512) {\n        return;\n    }\n    status = s->txp->cmd_b & 0xffff0000u;\n    DPRINTF(\"Sent packet tag:%04x len %d\\n\", status >> 16, s->txp->len);\n    n = (s->tx_status_fifo_head + s->tx_status_fifo_used) & 511;\n    s->tx_status_fifo[n] = status;\n    s->tx_status_fifo_used++;\n    if (s->tx_status_fifo_used == 512) {\n        s->int_sts |= TSFF_INT;\n    }\n}", "target": 1}
{"code": "MODULE_ENTRY (fill_vtable) (GdkPixbufModule *module)\n{\n\tmodule->begin_load = gdk_pixbuf__bmp_image_begin_load;\n\tmodule->stop_load = gdk_pixbuf__bmp_image_stop_load;\n\tmodule->load_increment = gdk_pixbuf__bmp_image_load_increment;\n\tmodule->save = gdk_pixbuf__bmp_image_save;\n\tmodule->save_to_callback = gdk_pixbuf__bmp_image_save_to_callback;\n}", "target": 0}
{"code": "static const char* ConvertOneFloat(PyObject* v, T* out) {\n  if (PyErr_Occurred()) {\n    return nullptr;\n  }\n  if (TF_PREDICT_TRUE(PyFloat_Check(v))) {\n    const double as_double = PyFloat_AS_DOUBLE(v);\n    *out = static_cast<T>(as_double);\n    if (TF_PREDICT_FALSE(sizeof(T) < sizeof(double) && std::isinf(*out) &&\n                         std::isfinite(as_double))) {\n      return ErrorOutOfRangeDouble;\n    }\n    return nullptr;\n  }\n#if PY_MAJOR_VERSION < 3\n  if (PyInt_Check(v)) {\n    *out = PyInt_AS_LONG(v);\n    return nullptr;\n  }\n#endif\n  if (PyLong_Check(v)) {\n    *out = PyLong_AsDouble(v);\n    if (PyErr_Occurred()) return ErrorOutOfRangeDouble;\n    return nullptr;\n  }\n  if (PyIsInstance(v, &PyFloatingArrType_Type)) {  \n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_float.get(), out);\n  }\n  if (PyIsInstance(v, &PyIntegerArrType_Type)) {  \n#if PY_MAJOR_VERSION < 3\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Int(v));\n#else\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Long(v));\n#endif\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_int.get(), out);\n  }\n  return ErrorMixedTypes;\n}", "target": 1}
{"code": "  static void  Ins_MDRP( INS_ARG )\n  {\n    Int         point;\n    TT_F26Dot6  distance,\n                org_dist;\n     point = (Int)args[0];\n    if ( BOUNDS( args[0], CUR.zp1.n_points ) )\n     {\n    org_dist = CUR_Func_dualproj( CUR.zp1.org_x[point] -\n                                    CUR.zp0.org_x[CUR.GS.rp0],\n                                  CUR.zp1.org_y[point] -\n                                    CUR.zp0.org_y[CUR.GS.rp0] );\n    if ( ABS(org_dist) < CUR.GS.single_width_cutin )\n    {\n      if ( org_dist >= 0 )\n        org_dist = CUR.GS.single_width_value;\n      else\n        org_dist = -CUR.GS.single_width_value;\n    }\n    if ( (CUR.opcode & 4) != 0 )\n      distance = CUR_Func_round( org_dist,\n                                 CUR.metrics.compensations[CUR.opcode & 3] );\n    else\n      distance = Round_None( EXEC_ARGS\n                             org_dist,\n                             CUR.metrics.compensations[CUR.opcode & 3]  );\n    if ( (CUR.opcode & 8) != 0 )\n    {\n      if ( org_dist >= 0 )\n      {\n        if ( distance < CUR.GS.minimum_distance )\n          distance = CUR.GS.minimum_distance;\n      }\n      else\n      {\n        if ( distance > -CUR.GS.minimum_distance )\n          distance = -CUR.GS.minimum_distance;\n      }\n    }\n    org_dist = CUR_Func_project( CUR.zp1.cur_x[point] -\n                                   CUR.zp0.cur_x[CUR.GS.rp0],\n                                 CUR.zp1.cur_y[point] -\n                                   CUR.zp0.cur_y[CUR.GS.rp0] );\n    CUR_Func_move( &CUR.zp1, point, distance - org_dist );\n    CUR.GS.rp1 = CUR.GS.rp0;\n    CUR.GS.rp2 = point;\n    if ( (CUR.opcode & 16) != 0 )\n      CUR.GS.rp0 = point;\n  }", "target": 1}
{"code": " long keyctl_set_reqkey_keyring(int reqkey_defl)\n {\n\tstruct cred *new;\n\tint ret, old_setting;\n\told_setting = current_cred_xxx(jit_keyring);\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n \tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n \t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto error;\n\t\t\tret = 0;\n\t\t}\n \t\tgoto set;\n \tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 1}
{"code": "static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n                         unsigned int epid, unsigned int streamid)\n{\n    XHCIEPContext *epctx;\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n    if (!xhci->slots[slotid-1].enabled) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled slot %d\\n\", slotid);\n        return;\n    }\n    epctx = xhci->slots[slotid-1].eps[epid-1];\n    if (!epctx) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\",\n                epid, slotid);\n        return;\n         return;\n     }\n     xhci_kick_epctx(epctx, streamid);\n }", "target": 1}
{"code": "CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)\n{\n  ssize_t i;\n  ssize_t si;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *scratch = data->state.scratch;\n  char *newscratch = NULL;\n  char *oldscratch = NULL;\n  size_t eob_sent;\n  if(!scratch || data->set.crlf) {\n    oldscratch = scratch;\n    scratch = newscratch = malloc(2 * data->set.buffer_size);\n    if(!newscratch) {\n      failf(data, \"Failed to alloc scratch buffer!\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  eob_sent = smtp->eob;\n  for(i = 0, si = 0; i < nread; i++) {\n    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {\n      smtp->eob++;\n      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)\n        smtp->trailing_crlf = TRUE;\n      else\n        smtp->trailing_crlf = FALSE;\n    }\n    else if(smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n      si += smtp->eob - eob_sent;\n      if(SMTP_EOB[0] == data->req.upload_fromhere[i])\n        smtp->eob = 1;\n      else\n        smtp->eob = 0;\n      eob_sent = 0;\n      smtp->trailing_crlf = FALSE;\n    }\n    if(SMTP_EOB_FIND_LEN == smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],\n             SMTP_EOB_REPL_LEN - eob_sent);\n      si += SMTP_EOB_REPL_LEN - eob_sent;\n      smtp->eob = 0;\n      eob_sent = 0;\n    }\n    else if(!smtp->eob)\n      scratch[si++] = data->req.upload_fromhere[i];\n  }\n  if(smtp->eob - eob_sent) {\n    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n    si += smtp->eob - eob_sent;\n  }\n  if(si != nread) {\n    data->req.upload_fromhere = scratch;\n    data->state.scratch = scratch;\n    free(oldscratch);\n    data->req.upload_present = si;\n  }\n  else\n    free(newscratch);\n  return CURLE_OK;\n}", "target": 1}
{"code": "int sldns_str2wire_dname_buf_origin(const char* str, uint8_t* buf, size_t* len,\n\tuint8_t* origin, size_t origin_len)\n{\n\tsize_t dlen = *len;\n\tint rel = 0;\n\tint s = sldns_str2wire_dname_buf_rel(str, buf, &dlen, &rel);\n\tif(s) return s;\n\tif(rel && origin && dlen > 0) {\n\t\tif(dlen + origin_len - 1 > LDNS_MAX_DOMAINLEN)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_DOMAINNAME_OVERFLOW,\n\t\t\t\tLDNS_MAX_DOMAINLEN);\n\t\tif(dlen + origin_len - 1 > *len)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL,\n\t\t\t\t*len);\n\t\tmemmove(buf+dlen-1, origin, origin_len);\n\t\t*len = dlen + origin_len - 1;\n\t} else\n\t\t*len = dlen;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 1}
{"code": "  void ValidateInputTensors(OpKernelContext* ctx, const Tensor& in0,\n                            const Tensor& in1) override {\n    OP_REQUIRES(\n        ctx, in0.dims() >= 2,\n        errors::InvalidArgument(\"In[0] ndims must be >= 2: \", in0.dims()));\n    OP_REQUIRES(\n        ctx, in1.dims() >= 2,\n        errors::InvalidArgument(\"In[0] ndims must be >= 2: \", in1.dims()));\n  }", "target": 1}
{"code": "const Hybrid_type_traits_integer *Hybrid_type_traits_integer::instance()\n{\n  return &integer_traits_instance;\n}", "target": 0}
{"code": "cfm_network_addr_print(netdissect_options *ndo,\n                       register const u_char *tptr)\n{\n    u_int network_addr_type;\n    u_int hexdump =  FALSE;\n    network_addr_type = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  Network Address Type %s (%u)\",\n           tok2str(af_values, \"Unknown\", network_addr_type),\n           network_addr_type));\n    switch(network_addr_type) {\n    case AFNUM_INET:\n        ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr + 1)));\n        break;\n    case AFNUM_INET6:\n        ND_PRINT((ndo, \", %s\", ip6addr_string(ndo, tptr + 1)));\n        break;\n    default:\n        hexdump = TRUE;\n        break;\n    }\n    return hexdump;\n}", "target": 1}
{"code": "int rad_packet_add_ipv6prefix(struct rad_packet_t *pack, const char *vendor_name, const char *name, struct in6_addr *prefix, int len)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\tif (pack->len + (vendor_name ? 8 : 2) + 18 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\tif (!attr)\n\t\treturn -1;\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 18;\n\tra->val.ipv6prefix.len = len;\n\tra->val.ipv6prefix.prefix = *prefix;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 18;\n\treturn 0;\n}", "target": 0}
{"code": "void Clipboard::ReadAsciiText(Clipboard::Buffer buffer,\n                              std::string* result) const {\n  GtkClipboard* clipboard = LookupBackingClipboard(buffer);\n  if (clipboard == NULL)\n    return;\n  result->clear();\n  gchar* text = gtk_clipboard_wait_for_text(clipboard);\n  if (text == NULL)\n    return;\n  result->assign(text);\n  g_free(text);\n}", "target": 0}
{"code": "create_tls_session(int csock, int type  )\n{\n    int rc = 0;\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n        case GNUTLS_SERVER:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_s);\n            break;\n        case GNUTLS_CLIENT:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_c);\n            break;\n    }\n    do {\n        rc = gnutls_handshake(*session);\n    } while (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN);\n    if (rc < 0) {\n        crm_err(\"Handshake failed: %s\", gnutls_strerror(rc));\n        gnutls_deinit(*session);\n        gnutls_free(session);\n        return NULL;\n    }\n    return session;\n}", "target": 1}
{"code": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n  call_once(flag, [this]() {\n    detail::AtFork::registerHandler(\n        this,\n         []() { return true; },\n         []() {},\n        []() {\n          using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n          auto& t = Single::get();\n          t.ptr_ = t.buffer_.get() + t.bufferSize_;\n        });\n  });\n}", "target": 0}
{"code": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!') ||\n\t    (bprm->recursion_depth > BINPRM_MAX_RECURSION))\n\t\treturn -ENOEXEC;\n\tbprm->recursion_depth++;\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; \n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval) return retval; \n\tbprm->argc++;\n\tbprm->interp = interp;\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}", "target": 1}
{"code": "static void blk_mq_freeze_queue_wait(struct request_queue *q)\n{\n\twait_event(q->mq_freeze_wq, percpu_ref_is_zero(&q->mq_usage_counter));\n}", "target": 0}
{"code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "copy_ciphersuites(gnutls_session_t session,\n\t\t  gnutls_buffer_st * cdata, int add_scsv)\n{\n\tint ret;\n\tuint8_t cipher_suites[MAX_CIPHERSUITE_SIZE + 2]; \n\tint cipher_suites_size;\n\tsize_t init_length = cdata->length;\n\tret =\n\t    _gnutls_supported_ciphersuites(session, cipher_suites,\n\t\t\t\t\t   sizeof(cipher_suites) - 2);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tret =\n\t    _gnutls_remove_unwanted_ciphersuites(session, cipher_suites,\n\t\t\t\t\t\t ret, NULL, 0);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tif (ret == 0)\n\t\treturn\n\t\t    gnutls_assert_val(GNUTLS_E_INSUFFICIENT_CREDENTIALS);\n\tcipher_suites_size = ret;\n\tif (add_scsv) {\n\t\tcipher_suites[cipher_suites_size] = 0x00;\n\t\tcipher_suites[cipher_suites_size + 1] = 0xff;\n\t\tcipher_suites_size += 2;\n\t\tret = _gnutls_ext_sr_send_cs(session);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\t}\n\tret =\n\t    _gnutls_buffer_append_data_prefix(cdata, 16, cipher_suites,\n\t\t\t\t\t      cipher_suites_size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tret = cdata->length - init_length;\n\treturn ret;\n}", "target": 1}
{"code": "tiff_save_close (thandle_t context)\n{\n        return 0;\n}", "target": 0}
{"code": "static TEE_Result do_alloc_publickey(struct rsa_public_key *s,\n\t\t\t\t     size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n)) {\n\t\tcrypto_bignum_free(s->e);\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "GF_Err mdia_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 cookie = gf_bs_get_cookie(bs);\n\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\te = gf_isom_box_array_read(s, bs, mdia_on_child_box);\n\tgf_bs_set_cookie(bs, cookie);\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void ttm_page_alloc_fini(void)\n{\n\tint i;\n\tpr_info(\"Finalizing pool allocator\\n\");\n\tttm_pool_mm_shrink_fini(_manager);\n\tfor (i = 0; i < NUM_POOLS; ++i)\n\t\tttm_page_pool_free(&_manager->pools[i], FREE_ALL_PAGES, true);\n\tkobject_put(&_manager->kobj);\n\t_manager = NULL;\n}", "target": 0}
{"code": "bool HTMLMediaElement::seeking() const {\n  return seeking_;\n}", "target": 0}
{"code": "void ide_atapi_cmd_reply_end(IDEState *s)\n{\n    int byte_count_limit, size, ret;\n    while (s->packet_transfer_size > 0) {\n        trace_ide_atapi_cmd_reply_end(s, s->packet_transfer_size,\n                                      s->elementary_transfer_size,\n                                      s->io_buffer_index);\n        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {\n            if (!s->elementary_transfer_size) {\n                ret = cd_read_sector(s);\n                if (ret < 0) {\n                    ide_atapi_io_error(s, ret);\n                }\n                return;\n            } else {\n                ret = cd_read_sector_sync(s);\n                if (ret < 0) {\n                    ide_atapi_io_error(s, ret);\n                    return;\n                }\n            }\n        }\n        if (s->elementary_transfer_size > 0) {\n            size = s->cd_sector_size - s->io_buffer_index;\n            if (size > s->elementary_transfer_size)\n                size = s->elementary_transfer_size;\n        } else {\n            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;\n            ide_set_irq(s->bus);\n            byte_count_limit = atapi_byte_count_limit(s);\n            trace_ide_atapi_cmd_reply_end_bcl(s, byte_count_limit);\n            size = s->packet_transfer_size;\n            if (size > byte_count_limit) {\n                if (byte_count_limit & 1)\n                    byte_count_limit--;\n                size = byte_count_limit;\n            }\n            s->lcyl = size;\n            s->hcyl = size >> 8;\n            s->elementary_transfer_size = size;\n            if (s->lba != -1) {\n                if (size > (s->cd_sector_size - s->io_buffer_index))\n                    size = (s->cd_sector_size - s->io_buffer_index);\n            }\n            trace_ide_atapi_cmd_reply_end_new(s, s->status);\n        }\n        s->packet_transfer_size -= size;\n        s->elementary_transfer_size -= size;\n        s->io_buffer_index += size;\n        if (!ide_transfer_start_norecurse(s,\n                                          s->io_buffer + s->io_buffer_index - size,\n                                          size, ide_atapi_cmd_reply_end)) {\n            return;\n        }\n    }\n    trace_ide_atapi_cmd_reply_end_eot(s, s->status);\n    ide_atapi_cmd_ok(s);\n    ide_set_irq(s->bus);\n}", "target": 1}
{"code": "  ~ScopedSendOnIOThread() {\n    if (!cancelled_) {\n      BrowserThread::PostTask(BrowserThread::IO,\n                              FROM_HERE,\n                              base::Bind(&SendOnIOThreadTask,\n                                         host_id_,\n                                         msg_.release()));\n    }\n  }", "target": 0}
{"code": "    bool PamBackend::start(const QString &user) {\n        bool result;\n        QString service = QStringLiteral(\"sddm\");\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n        return result;\n    }", "target": 1}
{"code": "static void asmlinkage smm_do_relocation(void *arg)\n{\n\tconst struct smm_module_params *p;\n\tconst struct smm_runtime *runtime;\n\tint cpu;\n\tuintptr_t curr_smbase;\n\tuintptr_t perm_smbase;\n\tp = arg;\n\truntime = p->runtime;\n\tcpu = p->cpu;\n\tcurr_smbase = runtime->smbase;\n\tif (cpu >= CONFIG_MAX_CPUS) {\n\t\tprintk(BIOS_CRIT,\n\t\t       \"Invalid CPU number assigned in SMM stub: %d\\n\", cpu);\n\t\treturn;\n\t}\n\tperm_smbase = mp_state.perm_smbase;\n\tperm_smbase -= cpu * runtime->save_state_size;\n\tprintk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);\n\tmp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);\n\tif (CONFIG(STM)) {\n\t\tuintptr_t mseg;\n\t\tmseg = mp_state.perm_smbase +\n\t\t\t(mp_state.perm_smsize - CONFIG_MSEG_SIZE);\n\t\tstm_setup(mseg, p->cpu,\n\t\t\t\tperm_smbase,\n\t\t\t\tmp_state.perm_smbase,\n\t\t\t\truntime->start32_offset);\n\t}\n}", "target": 1}
{"code": "void CheckAuthTest::TestValidToken(const std::string &auth_token,\n                                   const std::string &user_info) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([auth_token](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + auth_token;\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(auth_token)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .Times(2)\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1OpenIdUrl);\n        std::string body(kOpenIdContent);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1PubkeyUrl);\n        std::string body(kPubkey);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n  std::cout << \"need be replaced: \" << user_info << std::endl;\n  EXPECT_CALL(*raw_request_,\n              AddHeaderToBackend(kEndpointApiUserInfo, user_info))\n      .WillOnce(Return(utils::Status::OK));\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}", "target": 1}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg = NULL;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    goto error;\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "static float TIFFClampDoubleToFloat( double val )\n{\n    if( val > FLT_MAX )\n        return FLT_MAX;\n    if( val < -FLT_MAX )\n        return -FLT_MAX;\n    return (float)val;\n}", "target": 0}
{"code": "jinit_merged_upsampler(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample;\n  upsample = (my_upsample_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_upsampler));\n  cinfo->upsample = (struct jpeg_upsampler *)upsample;\n  upsample->pub.start_pass = start_pass_merged_upsample;\n  upsample->pub.need_context_rows = FALSE;\n  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;\n  if (cinfo->max_v_samp_factor == 2) {\n    upsample->pub.upsample = merged_2v_upsample;\n    if (jsimd_can_h2v2_merged_upsample())\n      upsample->upmethod = jsimd_h2v2_merged_upsample;\n    else\n      upsample->upmethod = h2v2_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v2_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v2_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = (JSAMPROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                (size_t)(upsample->out_row_width * sizeof(JSAMPLE)));\n  } else {\n    upsample->pub.upsample = merged_1v_upsample;\n    if (jsimd_can_h2v1_merged_upsample())\n      upsample->upmethod = jsimd_h2v1_merged_upsample;\n    else\n      upsample->upmethod = h2v1_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v1_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v1_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = NULL;\n  }\n  build_ycc_rgb_table(cinfo);\n}", "target": 1}
{"code": "__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n\tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n\tload_sp0(tss, next);\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\tsavesegment(fs, fsindex);\n\tsavesegment(gs, gsindex);\n\tload_TLS(next, cpu);\n\tarch_end_context_switch(next_p);\n\tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n\t\tloadsegment(fs, next->fsindex);\n\t\tif (fsindex)\n\t\t\tprev->fs = 0;\n\t}\n\tif (next->fs)\n\t\twrmsrl(MSR_FS_BASE, next->fs);\n\tprev->fsindex = fsindex;\n\tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n\t\tload_gs_index(next->gsindex);\n\t\tif (gsindex)\n\t\t\tprev->gs = 0;\n\t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\tswitch_fpu_finish(next_p, fpu);\n\tprev->usersp = this_cpu_read(old_rsp);\n\tthis_cpu_write(old_rsp, next->usersp);\n\tthis_cpu_write(current_task, next_p);\n\ttask_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);\n\tthis_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);\n\tthis_cpu_write(kernel_stack,\n\t\t  (unsigned long)task_stack_page(next_p) +\n\t\t  THREAD_SIZE - KERNEL_STACK_OFFSET);\n\tif (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||\n\t\t     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))\n\t\t__switch_to_xtra(prev_p, next_p, tss);\n\treturn prev_p;\n}", "target": 1}
{"code": "static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}", "target": 1}
{"code": "  SaveContext* save_context() {return thread_local_top_.save_context_; }", "target": 0}
{"code": "int sctp_auth_recv_cid(sctp_cid_t chunk, const struct sctp_association *asoc)\n{\n\tif (!sctp_auth_enable || !asoc)\n\t\treturn 0;\n\treturn __sctp_auth_cid(chunk,\n\t\t\t      (struct sctp_chunks_param *)asoc->c.auth_chunks);\n}", "target": 0}
{"code": "void __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tdrm_atomic_state_clear(state);\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    Tensor key(*key_tensor);\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }", "target": 1}
{"code": "static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t\n\t__u8 *fp;\n\tint n;\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\tfp = skb->data;\n \tn = 1;\n \tname_len = fp[n++];\n \tmemcpy(name, fp+n, name_len); n+=name_len;\n \tname[name_len] = '\\0';\n \tattr_len = fp[n++];\n \tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n \tattr[attr_len] = '\\0';\n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}", "target": 1}
{"code": "String localUserSpecificStorageDirectory()\n{\n    return cachedStorageDirectory(CSIDL_LOCAL_APPDATA);\n}", "target": 0}
{"code": "static void become_daemon(const char *pidfile)\n{\n#ifndef _WIN32\n    pid_t pid, sid;\n    pid = fork();\n    if (pid < 0) {\n        exit(EXIT_FAILURE);\n    }\n    if (pid > 0) {\n        exit(EXIT_SUCCESS);\n    }\n    if (pidfile) {\n        if (!ga_open_pidfile(pidfile)) {\n            g_critical(\"failed to create pidfile\");\n            exit(EXIT_FAILURE);\n         }\n     }\n    umask(0);\n     sid = setsid();\n     if (sid < 0) {\n         goto fail;\n    }\n    if ((chdir(\"/\")) < 0) {\n        goto fail;\n    }\n    reopen_fd_to_null(STDIN_FILENO);\n    reopen_fd_to_null(STDOUT_FILENO);\n    reopen_fd_to_null(STDERR_FILENO);\n    return;\nfail:\n    if (pidfile) {\n        unlink(pidfile);\n    }\n    g_critical(\"failed to daemonize\");\n    exit(EXIT_FAILURE);\n#endif\n}", "target": 1}
{"code": "  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; \n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }", "target": 1}
{"code": "MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &subtwolen );\n        bson_append_byte( b, type );\n        bson_append32( b, &len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "size_t Curl_conncache_size(struct Curl_easy *data)\n{\n  size_t num;\n  CONNCACHE_LOCK(data);\n  num = data->state.conn_cache->num_conn;\n  CONNCACHE_UNLOCK(data);\n  return num;\n}", "target": 0}
{"code": "static MagickBooleanType ForwardQuadrantSwap(const size_t width,\n  const size_t height,double *source_pixels,double *forward_pixels)\n{\n  MagickBooleanType\n    status;\n  register ssize_t\n    x;\n  ssize_t\n    center,\n    y;\n  center=(ssize_t) (width/2L)+1L;\n  status=RollFourier((size_t) center,height,0L,(ssize_t) height/2L,\n    source_pixels);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[y*width+x+width/2L]=source_pixels[y*center+x];\n  for (y=1; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[(height-y)*width+width/2L-x-1L]=\n        source_pixels[y*center+x+1L];\n  for (x=0L; x < (ssize_t) (width/2L); x++)\n    forward_pixels[width/2L-x-1L]=source_pixels[x+1L];\n  return(MagickTrue);\n}", "target": 0}
{"code": "void zend_shutdown_extensions(TSRMLS_D)\n{\n\tzend_llist_apply(&zend_extensions, (llist_apply_func_t) zend_extension_shutdown TSRMLS_CC);\n\tzend_llist_destroy(&zend_extensions);\n}", "target": 0}
{"code": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n  int i;\n  int count;\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n  array = object_as_array(object);\n   if (array->items == NULL)\n   {\n    count = yr_max(64, (index + 1) * 2);\n     array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n         sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n    array->items->count = count;\n  }\n   else if (index >= array->items->count)\n   {\n     count = array->items->count * 2;\n     array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n         array->items,\n         sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n    array->items->count = count;\n  }\n  item->parent = object;\n  array->items->objects[index] = item;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "void vsock_remove_bound(struct vsock_sock *vsk)\n{\n\tspin_lock_bh(&vsock_table_lock);\n\t__vsock_remove_bound(vsk);\n\tspin_unlock_bh(&vsock_table_lock);\n}", "target": 0}
{"code": "destroyBindings(BINDING *bindings, XML_Parser parser) {\n  for (;;) {\n    BINDING *b = bindings;\n    if (! b)\n      break;\n    bindings = b->nextTagBinding;\n    FREE(parser, b->uri);\n    FREE(parser, b);\n  }\n}", "target": 0}
{"code": "void set_task_comm(struct task_struct *tsk, char *buf)\n{\n\ttask_lock(tsk);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n}", "target": 0}
{"code": "fz_rendering_intent_name(int ri)\n{\n\tif (ri >= 0 && ri < nelem(fz_intent_names))\n\t\treturn (char*)fz_intent_names[ri];\n\treturn \"RelativeColorimetric\";\n}", "target": 0}
{"code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n \t\tsnd_timer_interrupt(substream->timer, 1);\n #endif\n  _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n \tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n }", "target": 1}
{"code": "static void dbEvalSetColumnJSON(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            Jsi_DSAppend(dStr, \"null\", NULL);\n            return;\n        }\n        Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_JSONQuote(interp, str?str:\"\", -1, dStr);\n}", "target": 1}
{"code": "bool PPB_URLLoader_Impl::RecordUploadProgress() const {\n  return request_data_.record_upload_progress;\n}", "target": 0}
{"code": "gs_errorinfo_put_string(i_ctx_t *i_ctx_p, const char *str)\n{\n    ref rstr;\n    ref *pderror;\n    int code = string_to_ref(str, &rstr, iimemory, \"gs_errorinfo_put_string\");\n    if (code < 0)\n        return code;\n    if (dict_find_string(systemdict, \"$error\", &pderror) <= 0 ||\n        !r_has_type(pderror, t_dictionary) ||\n        idict_put_string(pderror, \"errorinfo\", &rstr) < 0\n        )\n        return_error(gs_error_Fatal);\n    return 0;\n}", "target": 0}
{"code": "aubio_filterbank_get_coeffs (const aubio_filterbank_t * f)\n{\n  return f->filters;\n}", "target": 0}
{"code": "    std::string Iptcdatum::recordName() const\n    {\n        return key_.get() == 0 ? \"\" : key_->recordName();\n    }", "target": 0}
{"code": "bool HHVM_FUNCTION(krsort,\n                   VRefParam array,\n                   int sort_flags ) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_ksort(array, sort_flags, false, use_zend_sort);\n}", "target": 0}
{"code": "static void hugetlb_vm_op_open(struct vm_area_struct *vma)\n{\n\tstruct resv_map *resv = vma_resv_map(vma);\n\tif (resv && is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\tresv_map_dup_hugetlb_cgroup_uncharge_info(resv);\n\t\tkref_get(&resv->refs);\n\t}\n}", "target": 0}
{"code": "void rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip)\n{\n\tstruct rds6_info_message minfo6;\n \tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n \tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n \tif (flip) {\n \t\tminfo6.laddr = *daddr;\n\t\tminfo6.faddr = *saddr;\n\t\tminfo6.lport = inc->i_hdr.h_dport;\n\t\tminfo6.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo6.laddr = *saddr;\n\t\tminfo6.faddr = *daddr;\n\t\tminfo6.lport = inc->i_hdr.h_sport;\n \t\tminfo6.fport = inc->i_hdr.h_dport;\n \t}\n \trds_info_copy(iter, &minfo6, sizeof(minfo6));\n }", "target": 1}
{"code": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint i, j, ret;\n\tunsigned char count;\n\tif(flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\tif((scd->curbit + code_size) >= scd->lastbit) {\n\t\tif(scd->done) {\n\t\t\tif(scd->curbit >= scd->lastbit) {\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tscd->buf[0] = scd->buf[scd->last_byte - 2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte - 1];\n\t\tif((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {\n\t\t\tscd->done = TRUE;\n\t\t}\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2 + count) * 8;\n\t}\n\tret = 0;\n\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t}\n\tscd->curbit += code_size;\n\treturn ret;\n}", "target": 1}
{"code": "int LibRaw::flip_index(int row, int col)\n{\n  if (flip & 4)\n    SWAP(row, col);\n  if (flip & 2)\n    row = iheight - 1 - row;\n  if (flip & 1)\n    col = iwidth - 1 - col;\n  return row * iwidth + col;\n}", "target": 0}
{"code": "void ContainerNode::notifyNodeRemoved(Node& root)\n{\n    ScriptForbiddenScope forbidScript;\n    EventDispatchForbiddenScope assertNoEventDispatch;\n    for (Node& node : NodeTraversal::inclusiveDescendantsOf(root)) {\n        if (!node.isContainerNode() && !node.isInTreeScope())\n            continue;\n        node.removedFrom(this);\n        for (ShadowRoot* shadowRoot = node.youngestShadowRoot(); shadowRoot; shadowRoot = shadowRoot->olderShadowRoot())\n            notifyNodeRemoved(*shadowRoot);\n    }\n}", "target": 0}
{"code": "static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tbuf[len] = 0;\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \"No matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"Matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\ttype = strcasestr(buf, \"\\r\\nST:\");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \"No Search Type (ST:) found in M-SEARCH *, assuming \" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\t\t\tptr = strstr(type, \"\\r\\n\");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * ST: %s from %s port %d\", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * for unsupported ST: %s from %s\", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}", "target": 1}
{"code": "do_curl_clear(CurlObject *self)\n{\n#ifdef WITH_THREAD\n    assert(pycurl_get_thread_state(self) == NULL);\n#endif\n    util_curl_xdecref(self, PYCURL_MEMGROUP_ALL, self->handle);\n    return 0;\n}", "target": 0}
{"code": "    std::string Xmpdatum::key() const\n    {\n        return p_->key_.get() == 0 ? \"\" : p_->key_->key();\n    }", "target": 0}
{"code": "AP_DECLARE(void) ap_set_content_length(request_rec *r, apr_off_t clength)\n{\n    r->clength = clength;\n    apr_table_setn(r->headers_out, \"Content-Length\",\n                   apr_off_t_toa(r->pool, clength));\n}", "target": 0}
{"code": "Eina_Bool ewk_view_history_enable_set(Evas_Object* ewkView, Eina_Bool enable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    static_cast<WebCore::BackForwardListImpl*>(priv->page->backForwardList())->setEnabled(enable);\n    return true;\n}", "target": 0}
{"code": "void spl_filesystem_object_construct(INTERNAL_FUNCTION_PARAMETERS, zend_long ctor_flags) \n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint parsed;\n\tsize_t len;\n\tzend_long flags;\n\tzend_error_handling error_handling;\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling);\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_FLAGS)) {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_FILEINFO;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\", &path, &len, &flags);\n\t} else {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_SELF;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &path, &len);\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_SKIPDOTS)) {\n\t\tflags |= SPL_FILE_DIR_SKIPDOTS;\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_UNIXPATHS)) {\n\t\tflags |= SPL_FILE_DIR_UNIXPATHS;\n\t}\n\tif (parsed == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling);\n\t\treturn;\n\t}\n\tif (!len) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0, \"Directory name must not be empty.\");\n\t\tzend_restore_error_handling(&error_handling);\n\t\treturn;\n\t}\n\tintern = Z_SPLFILESYSTEM_P(getThis());\n\tif (intern->_path) {\n\t\tzend_restore_error_handling(&error_handling);\n\t\tphp_error_docref(NULL, E_WARNING, \"Directory object is already initialized\");\n\t\treturn;\n\t}\n\tintern->flags = flags;\n#ifdef HAVE_GLOB\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_GLOB) && strstr(path, \"glob:\n\t\tspprintf(&path, 0, \"glob:\n\t\tspl_filesystem_dir_open(intern, path);\n\t\tefree(path);\n\t} else\n#endif\n\t{\n\t\tspl_filesystem_dir_open(intern, path);\n\t}\n\tintern->u.dir.is_recursive = instanceof_function(intern->std.ce, spl_ce_RecursiveDirectoryIterator) ? 1 : 0;\n\tzend_restore_error_handling(&error_handling);\n}", "target": 1}
{"code": "print_distance_range(FILE* f, OnigDistance a, OnigDistance b)\n{\n  if (a == ONIG_INFINITE_DISTANCE)\n    fputs(\"inf\", f);\n  else\n    fprintf(f, \"(%\"PRIuPTR\")\", a);\n  fputs(\"-\", f);\n  if (b == ONIG_INFINITE_DISTANCE)\n    fputs(\"inf\", f);\n  else\n    fprintf(f, \"(%\"PRIuPTR\")\", b);\n}", "target": 0}
{"code": "static int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\tpr_debug(\"\\n\");\n#endif\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; \n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\tparams->resp_avail(params->v);\n\treturn 0;\n}", "target": 1}
{"code": " static int rename_in_ns(int pid, char *oldname, char **newnamep)\n {\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n \tbool grab_newname = false;\n \tofd = lxc_preserve_ns(getpid(), \"net\");\n \tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n \t}\n \tfd = lxc_preserve_ns(pid, \"net\");\n \tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n \t}\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n \t}\n\tclose(fd); fd = -1;\n \tif (!*newnamep) {\n \t\tgrab_newname = true;\n \t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n \t\t}\n \t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n \t}\n \tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n \t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n \t\t}\n \t\t*newnamep = strdup(namep);\n \t\tif (!*newnamep)\n\t\t\tgoto out_err;\n \t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n \t}\n\tclose(ofd);\n\treturn 0;\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n \tif (fd >= 0)\n \t\tclose(fd);\n\treturn -1;\n }", "target": 1}
{"code": "static void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINORIGIN;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.user);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.id = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.version = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.net_type);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.addr_type);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &ses->origin.addr);\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "bool initialise_control(rzip_control *control)\n{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; \n\tsize_t len;\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = \".lrz\";\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\tcontrol->threads = PROCESSORS;\t\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\tif (unlikely((now_t = time(NULL)) == ((time_t)-1)))\n\t\tfatal_return((\"Failed to call time in main\\n\"), false);\n\tif (unlikely(now_t < T_ZERO)) {\n\t\tprint_output(\"Warning your time reads before the year 2011, check your system clock\\n\");\n\t\tnow_t = T_ZERO;\n\t}\n\ttdiff = (now_t - T_ZERO) / 4;\n\tnow_t = T_ZERO + tdiff;\n\tcontrol->secs = now_t;\n\tcontrol->encloops = nloops(control->secs, control->salt, control->salt + 1);\n\tif (unlikely(!get_rand(control, control->salt + 2, 6)))\n\t\treturn false;\n\teptr = getenv(\"TMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TMP\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMP\");\n\tif (!eptr)\n\t\teptr = localeptr;\n\tlen = strlen(eptr);\n\tcontrol->tmpdir = malloc(len + 2);\n\tif (control->tmpdir == NULL)\n\t\tfatal_return((\"Failed to allocate for tmpdir\\n\"), false);\n\tstrcpy(control->tmpdir, eptr);\n\tif (control->tmpdir[len - 1] != '/') {\n\t\tcontrol->tmpdir[len] = '/'; \n\t\tcontrol->tmpdir[len + 1] = '\\0';\n\t}\n\treturn true;\n}", "target": 1}
{"code": "void cql_server::response::write_string(std::string_view s)\n{\n    write_short(cast_if_fits<uint16_t>(s.size()));\n    _body.write(bytes_view(reinterpret_cast<const int8_t*>(s.data()), s.size()));\n}", "target": 0}
{"code": "mptctl_replace_fw (unsigned long arg)\n{\n\tstruct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_replace_fw\t karg;\n\tMPT_ADAPTER\t\t *ioc;\n\tint\t\t\t iocnum;\n\tint\t\t\t newFwSize;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\"Unable to read in mpt_ioctl_replace_fw struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_replace_fw() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_replace_fw called.\\n\",\n\t    ioc->name));\n\tif (ioc->cached_fw == NULL)\n\t\treturn 0;\n\tmpt_free_fw_memory(ioc);\n\tnewFwSize = ALIGN(karg.newImageSize, 4);\n\tmpt_alloc_fw_memory(ioc, newFwSize);\n\tif (ioc->cached_fw == NULL)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\t\"Unable to read in mpt_ioctl_replace_fw image \"\n\t\t\t\t\"@ %p\\n\", ioc->name, __FILE__, __LINE__, uarg);\n\t\tmpt_free_fw_memory(ioc);\n\t\treturn -EFAULT;\n\t}\n\tioc->facts.FWImageSize = newFwSize;\n\treturn 0;\n}", "target": 1}
{"code": "void metx_box_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tgf_free(ptr);\n}", "target": 0}
{"code": "nsim_bpf_offload(struct netdevsim *ns, struct bpf_prog *prog, bool oldprog)\n{\n\tnsim_prog_set_loaded(ns->bpf_offloaded, false);\n\tWARN(!!ns->bpf_offloaded != oldprog,\n\t     \"bad offload state, expected offload %sto be active\",\n\t     oldprog ? \"\" : \"not \");\n\tns->bpf_offloaded = prog;\n\tns->bpf_offloaded_id = prog ? prog->aux->id : 0;\n\tnsim_prog_set_loaded(prog, true);\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t itlb_multihit_show_state(char *buf)\n{\n\tif (itlb_multihit_kvm_mitigation)\n\t\treturn sprintf(buf, \"KVM: Mitigation: Split huge pages\\n\");\n\telse\n\t\treturn sprintf(buf, \"KVM: Vulnerable\\n\");\n}", "target": 0}
{"code": "void disk_part_iter_init(struct disk_part_iter *piter, struct gendisk *disk,\n\t\t\t  unsigned int flags)\n{\n\tstruct disk_part_tbl *ptbl;\n\trcu_read_lock();\n\tptbl = rcu_dereference(disk->part_tbl);\n\tpiter->disk = disk;\n\tpiter->part = NULL;\n\tif (flags & DISK_PITER_REVERSE)\n\t\tpiter->idx = ptbl->len - 1;\n\telse if (flags & (DISK_PITER_INCL_PART0 | DISK_PITER_INCL_EMPTY_PART0))\n\t\tpiter->idx = 0;\n\telse\n\t\tpiter->idx = 1;\n\tpiter->flags = flags;\n\trcu_read_unlock();\n}", "target": 0}
{"code": "GF_Box *flxs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFlashAccessParamsBox, GF_ISOM_BOX_TYPE_FLXS);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}", "target": 0}
{"code": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n \tstruct media_entity *ent;\n \tstruct media_entity_desc u_ent;\n \tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n \t\treturn -EFAULT;\n\tent = find_entity(mdev, u_ent.id);\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "add_prefix_matches(lookup_state_t *state,\n                   const svn_stringbuf_t *segment,\n                   apr_array_header_t *prefixes)\n{\n  int i = svn_sort__bsearch_lower_bound(prefixes, segment->data,\n                                        compare_node_path_segment);\n  if (i < prefixes->nelts)\n    add_if_prefix_matches(state,\n                          &APR_ARRAY_IDX(prefixes, i, sorted_pattern_t),\n                          segment);\n  if (i > 0)\n    {\n      sorted_pattern_t *pattern;\n      for (pattern = &APR_ARRAY_IDX(prefixes, i - 1, sorted_pattern_t);\n           pattern;\n           pattern = pattern->next)\n        {\n          add_if_prefix_matches(state, pattern, segment);\n        }\n    }\n}", "target": 0}
{"code": "void snd_msndmidi_input_read(void *mpuv)\n{\n\tunsigned long flags;\n\tstruct snd_msndmidi *mpu = mpuv;\n\tvoid *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF;\n\tspin_lock_irqsave(&mpu->input_lock, flags);\n\twhile (readw(mpu->dev->MIDQ + JQS_wTail) !=\n\t       readw(mpu->dev->MIDQ + JQS_wHead)) {\n\t\tu16 wTmp, val;\n\t\tval = readw(pwMIDQData + 2 * readw(mpu->dev->MIDQ + JQS_wHead));\n\t\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER,\n\t\t\t\t     &mpu->mode))\n\t\t\t\tsnd_rawmidi_receive(mpu->substream_input,\n\t\t\t\t\t\t    (unsigned char *)&val, 1);\n\t\twTmp = readw(mpu->dev->MIDQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(mpu->dev->MIDQ + JQS_wSize))\n\t\t\twritew(0,  mpu->dev->MIDQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp,  mpu->dev->MIDQ + JQS_wHead);\n\t}\n\tspin_unlock_irqrestore(&mpu->input_lock, flags);\n}", "target": 1}
{"code": "    DataValue::DataValue(const byte* buf,\n              long len, ByteOrder byteOrder,TypeId typeId)\n        : Value(typeId)\n    {\n        read(buf, len, byteOrder);\n    }", "target": 0}
{"code": "static int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\tline += 3; \n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\t*out = (git_pkt *)pkt;\n\treturn 0;\nout_err:\n\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}", "target": 1}
{"code": "name_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n    if (s >= maxbuf)\n\treturn(-1);\t\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n \t    return(-1);\t\n \tND_TCHECK2(*s, 1);\n \ts += (*s) + 1;\n     }\n     return(PTR_DIFF(s, s0) + 1);\ntrunc:\n    return(-1);\t\n}", "target": 1}
{"code": "static void execlists_reset(struct intel_engine_cs *engine, bool stalled)\n{\n\tunsigned long flags;\n\tGEM_TRACE(\"%s\\n\", engine->name);\n\tspin_lock_irqsave(&engine->active.lock, flags);\n\t__execlists_reset(engine, stalled);\n\tspin_unlock_irqrestore(&engine->active.lock, flags);\n}", "target": 0}
{"code": "SYSCALL_DEFINE3(shmat, int, shmid, char __user *, shmaddr, int, shmflg)\n{\n\tunsigned long ret;\n\tlong err;\n\terr = do_shmat(shmid, shmaddr, shmflg, &ret, SHMLBA);\n\tif (err)\n\t\treturn err;\n\tforce_successful_syscall_return();\n\treturn (long)ret;\n}", "target": 0}
{"code": "static void rm_read_metadata(AVFormatContext *s, AVIOContext *pb, int wide)\n{\n    char buf[1024];\n    int i;\n    for (i=0; i<FF_ARRAY_ELEMS(ff_rm_metadata); i++) {\n        int len = wide ? avio_rb16(pb) : avio_r8(pb);\n        get_strl(pb, buf, sizeof(buf), len);\n        av_dict_set(&s->metadata, ff_rm_metadata[i], buf, 0);\n    }\n}", "target": 0}
{"code": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n  rtadv_event (zvrf, RTADV_READ, sock);\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n  return 0;\n}", "target": 1}
{"code": "SPL_METHOD(Array, append)\n{\n\tzval *value;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &value) == FAILURE) {\n\t\treturn;\n\t}\n\tspl_array_iterator_append(getThis(), value TSRMLS_CC);\n} ", "target": 0}
{"code": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\tif (!server)\n\t\treturn -1;\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\tserver->capture = shadow_capture_new(server);\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "read_file(gchar* filepath)\n{\n\tFILE * f;\n\tsize_t length;\n\tgchar *ret = NULL;\n\tf = fopen(filepath, \"rb\");\n\tif (f) {\n\t\tfseek(f, 0, SEEK_END);\n\t\tlength = (size_t)ftell(f);\n\t\tfseek(f, 0, SEEK_SET);\n\t\tret = MALLOC(length + 1);\n\t\tif (ret) {\n\t\t\tif (fread(ret, length, 1, f) != 1) {\n\t\t\t\tlog_message(LOG_INFO, \"Failed to read all of %s\", filepath);\n\t\t\t}\n\t\t\tret[length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to read Dbus file %s\", filepath);\n\t\tfclose(f);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "u64 gf_isom_get_media_original_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\treturn trak->Media->mediaHeader->original_duration;\n}", "target": 0}
{"code": "static int __init disable_acpi_irq(struct dmi_system_id *d)\n{\n\tif (!acpi_force) {\n\t\tprintk(KERN_NOTICE \"%s detected: force use of acpi=noirq\\n\",\n\t\t       d->ident);\n\t\tacpi_noirq_set();\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static PolygonInfo **DestroyPolygonThreadSet(PolygonInfo **polygon_info)\n{\n  ssize_t\n    i;\n  assert(polygon_info != (PolygonInfo **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (polygon_info[i] != (PolygonInfo *) NULL)\n      polygon_info[i]=DestroyPolygonInfo(polygon_info[i]);\n  polygon_info=(PolygonInfo **) RelinquishMagickMemory(polygon_info);\n  return(polygon_info);\n}", "target": 0}
{"code": "void LinkResolver::throw_abstract_method_error(const methodHandle& resolved_method,\n                                               const methodHandle& selected_method,\n                                               Klass *recv_klass, TRAPS) {\n  Klass *resolved_klass = resolved_method->method_holder();\n  ResourceMark rm(THREAD);\n  stringStream ss;\n  if (recv_klass != NULL) {\n    ss.print(\"Receiver class %s does not define or inherit an \"\n             \"implementation of the\",\n             recv_klass->external_name());\n  } else {\n    ss.print(\"Missing implementation of\");\n  }\n  assert(resolved_method.not_null(), \"Sanity\");\n  ss.print(\" resolved method '%s%s\",\n           resolved_method->is_abstract() ? \"abstract \" : \"\",\n           resolved_method->is_private()  ? \"private \"  : \"\");\n  resolved_method->signature()->print_as_signature_external_return_type(&ss);\n  ss.print(\" %s(\", resolved_method->name()->as_C_string());\n  resolved_method->signature()->print_as_signature_external_parameters(&ss);\n  ss.print(\")' of %s %s.\",\n           resolved_klass->external_kind(),\n           resolved_klass->external_name());\n  if (selected_method.not_null() && !(resolved_method == selected_method)) {\n    ss.print(\" Selected method is '%s%s\",\n             selected_method->is_abstract() ? \"abstract \" : \"\",\n             selected_method->is_private()  ? \"private \"  : \"\");\n    selected_method->print_external_name(&ss);\n    ss.print(\"'.\");\n  }\n  THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());\n}", "target": 0}
{"code": "static int __init ipgre_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\nout:\n\treturn err;\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}", "target": 1}
{"code": "rgb2bgr16(UINT8 *out_, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 4, out_ += 2) {\n        UINT16 v = ((((UINT16)in[0]) << 8) & 0xf800) +\n                   ((((UINT16)in[1]) << 3) & 0x07e0) +\n                   ((((UINT16)in[2]) >> 3) & 0x001f);\n        memcpy(out_, &v, sizeof(v));\n    }\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "long join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\tmutex_lock(&key_session_mutex);\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n \t\tret = PTR_ERR(keyring);\n \t\tgoto error2;\n \t} else if (keyring == new->session_keyring) {\n \t\tret = 0;\n \t\tgoto error2;\n \t}\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 1}
{"code": "SYSCALL_DEFINE1(time, time_t __user *, tloc)\n{\n\ttime_t i = get_seconds();\n\tif (tloc) {\n\t\tif (put_user(i,tloc))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn i;\n}", "target": 0}
{"code": "    TestOpaqueResourceDecoderImpl(absl::string_view name_field)\n        : Config::OpaqueResourceDecoderImpl<Current>(ProtobufMessage::getStrictValidationVisitor(),\n                                                     name_field) {}", "target": 0}
{"code": "mono_method_get_class (MonoMethod *method)\n{\n\treturn method->klass;\n}", "target": 0}
{"code": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n \t\treturn 0;\n \t}\n \tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n \t}\n \tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n \trc = jbd2_journal_stop(handle);\n \tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}", "target": 1}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n \tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n \tif (ret < 0) {\n\t\tops->destroy(dev);\n \t\tmutex_lock(&kvm->lock);\n \t\tlist_del(&dev->vm_node);\n \t\tmutex_unlock(&kvm->lock);\n \t\treturn ret;\n \t}\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 1}
{"code": "static int php_snmp_read_max_oids(php_snmp_object *snmp_object, zval *retval)\n{\n\tif (snmp_object->max_oids > 0) {\n\t\tZVAL_LONG(retval, snmp_object->max_oids);\n\t} else {\n\t\tZVAL_NULL(retval);\n\t}\n\treturn SUCCESS;\n}", "target": 0}
{"code": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\text2_xattr_put_super(sb);\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}", "target": 1}
{"code": "static void unclear_tables(JOIN *join, table_map *cleared_tables)\n{\n  for (uint i= 0 ; i < join->table_count ; i++)\n  {\n    if ((*cleared_tables) & (((table_map) 1) << i))\n    {\n      TABLE *table= join->table[i];\n      if (table->s->null_bytes)\n        memcpy(table->null_flags, table->record[1], table->s->null_bytes);\n      unmark_as_null_row(table);\n    }\n  }\n}", "target": 0}
{"code": "void free_cache_bitmap_order(rdpContext* context, CACHE_BITMAP_ORDER* order)\n{\n\tif (order)\n\t\tfree(order->bitmapDataStream);\n\tfree(order);\n}", "target": 0}
{"code": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int base64decode_block(unsigned char *target, const char *data, size_t data_size)\n{\n\tint w1,w2,w3,w4;\n\tint i;\n\tsize_t n;\n\tif (!data || (data_size <= 0)) {\n\t\treturn 0;\n\t}\n\tn = 0;\n\ti = 0;\n\twhile (n < data_size-3) {\n\t\tw1 = base64_table[(int)data[n]];\n\t\tw2 = base64_table[(int)data[n+1]];\n\t\tw3 = base64_table[(int)data[n+2]];\n\t\tw4 = base64_table[(int)data[n+3]];\n\t\tif (w2 >= 0) {\n\t\t\ttarget[i++] = (char)((w1*4 + (w2 >> 4)) & 255);\n\t\t}\n\t\tif (w3 >= 0) {\n\t\t\ttarget[i++] = (char)((w2*16 + (w3 >> 2)) & 255);\n\t\t}\n\t\tif (w4 >= 0) {\n\t\t\ttarget[i++] = (char)((w3*64 + w4) & 255);\n\t\t}\n\t\tn+=4;\n\t}\n\treturn i;\n}", "target": 1}
{"code": "static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void ContainerNode::removeBetween(Node* previousChild, Node* nextChild, Node& oldChild)\n{\n    EventDispatchForbiddenScope assertNoEventDispatch;\n    ASSERT(oldChild.parentNode() == this);\n    if (!oldChild.needsAttach())\n        oldChild.detach();\n    if (nextChild)\n        nextChild->setPreviousSibling(previousChild);\n    if (previousChild)\n        previousChild->setNextSibling(nextChild);\n    if (m_firstChild == &oldChild)\n        m_firstChild = nextChild;\n    if (m_lastChild == &oldChild)\n        m_lastChild = previousChild;\n    oldChild.setPreviousSibling(nullptr);\n    oldChild.setNextSibling(nullptr);\n    oldChild.setParentOrShadowHostNode(nullptr);\n    document().adoptIfNeeded(oldChild);\n}", "target": 0}
{"code": "mldv2_report_print(netdissect_options *ndo, const u_char *bp, u_int len)\n{\n    const struct icmp6_hdr *icp = (const struct icmp6_hdr *) bp;\n    u_int group, nsrcs, ngroups;\n    u_int i, j;\n    if (len < 8) {\n            ND_PRINT((ndo,\" [invalid len %d]\", len));\n            return;\n    }\n    ND_TCHECK(icp->icmp6_data16[1]);\n    ngroups = EXTRACT_16BITS(&icp->icmp6_data16[1]);\n    ND_PRINT((ndo,\", %d group record(s)\", ngroups));\n    if (ndo->ndo_vflag > 0) {\n\tgroup = 8;\n        for (i = 0; i < ngroups; i++) {\n\t    if (len < group + 20) {\n                    ND_PRINT((ndo,\" [invalid number of groups]\"));\n                    return;\n\t    }\n            ND_TCHECK2(bp[group + 4], sizeof(struct in6_addr));\n            ND_PRINT((ndo,\" [gaddr %s\", ip6addr_string(ndo, &bp[group + 4])));\n\t    ND_PRINT((ndo,\" %s\", tok2str(mldv2report2str, \" [v2-report-#%d]\",\n                                         bp[group])));\n            nsrcs = (bp[group + 2] << 8) + bp[group + 3];\n\t    if (len < group + 20 + (nsrcs * sizeof(struct in6_addr))) {\n                    ND_PRINT((ndo,\" [invalid number of sources %d]\", nsrcs));\n                    return;\n\t    }\n            if (ndo->ndo_vflag == 1)\n                    ND_PRINT((ndo,\", %d source(s)\", nsrcs));\n            else {\n                    ND_PRINT((ndo,\" {\"));\n                for (j = 0; j < nsrcs; j++) {\n                    ND_TCHECK2(bp[group + 20 + j * sizeof(struct in6_addr)],\n                            sizeof(struct in6_addr));\n\t\t    ND_PRINT((ndo,\" %s\", ip6addr_string(ndo, &bp[group + 20 + j * sizeof(struct in6_addr)])));\n\t\t}\n                ND_PRINT((ndo,\" }\"));\n            }\n            group += 20 + nsrcs * sizeof(struct in6_addr);\n\t    ND_PRINT((ndo,\"]\"));\n        }\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo,\"[|icmp6]\"));\n    return;\n}", "target": 1}
{"code": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char print_buffer[256];\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n      if(len > width) {\n        size_t cut = width-1;\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          cut = width-1;\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut + 1; \n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}", "target": 1}
{"code": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n    *passptr = NULL;\n}", "target": 1}
{"code": "static void svm_set_cr3(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tsvm->vmcb->save.cr3 = root;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tsvm_flush_tlb(vcpu);\n}", "target": 0}
{"code": "bool IsFullyConnectedOpSupported(const TfLiteRegistration* registration,\n                                 const TfLiteNode* node,\n                                 TfLiteContext* context) {\n  if (node->builtin_data == nullptr) return false;\n  const auto* fc_params =\n      reinterpret_cast<const TfLiteFullyConnectedParams*>(node->builtin_data);\n  const int kInput = 0;\n  const int kWeights = 1;\n  const int kBias = 2;\n  if (fc_params->weights_format != kTfLiteFullyConnectedWeightsFormatDefault) {\n    return false;\n  }\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* weights = GetInput(context, node, kWeights);\n  if (!IsFloatType(input->type)) {\n    return false;\n  }\n  if (!IsFloatType(weights->type) || !IsConstantTensor(weights)) {\n    return false;\n  }\n  if (input->dims->data[input->dims->size - 1] != NumElements(input)) {\n    return false;\n  }\n  if (node->inputs->size > 2) {\n    const TfLiteTensor* bias = GetInput(context, node, kBias);\n    if (!IsFloatType(bias->type) || !IsConstantTensor(bias)) {\n      return false;\n    }\n  }\n  TfLiteFusedActivation activation = fc_params->activation;\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, openflags, NULL, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (state->inode == dentry->d_inode) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state);\n\t\treturn 1;\n\t}\n\tnfs4_close_sync(&path, state, openflags);\nout_drop:\n\td_drop(dentry);\n\treturn 0;\n}", "target": 1}
{"code": "RGWOp* RGWHandler_REST_Obj_S3Website::get_obj_op(bool get_data)\n{\n  RGWGetObj_ObjStore_S3Website* op = new RGWGetObj_ObjStore_S3Website;\n  op->set_get_data(get_data);\n  return op;\n}", "target": 0}
{"code": "static pyc_object *get_set_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}", "target": 1}
{"code": " lookup_bytestring(netdissect_options *ndo, register const u_char *bs,\n \t\t  const unsigned int nlen)\n {\n\tstruct enamemem *tp;\n \tregister u_int i, j, k;\n \tif (nlen >= 6) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = (bs[4] << 8) | bs[5];\n\t} else if (nlen >= 4) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = 0;\n\t} else\n \t\ti = j = k = 0;\n \ttp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];\n\twhile (tp->e_nxt)\n\t\tif (tp->e_addr0 == i &&\n\t\t    tp->e_addr1 == j &&\n\t\t    tp->e_addr2 == k &&\n\t\t    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)\n \t\t\treturn tp;\n \t\telse\n\t\t\ttp = tp->e_nxt;\n\ttp->e_addr0 = i;\n\ttp->e_addr1 = j;\n\ttp->e_addr2 = k;\n\ttp->e_bs = (u_char *) calloc(1, nlen + 1);\n\tif (tp->e_bs == NULL)\n \t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\tmemcpy(tp->e_bs, bs, nlen);\n\ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));\n\tif (tp->e_nxt == NULL)\n \t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n \treturn tp;\n}", "target": 1}
{"code": "int gnutls_x509_crl_verify(gnutls_x509_crl_t crl,\n\t\t\t   const gnutls_x509_crt_t * CA_list,\n\t\t\t   int CA_list_length, unsigned int flags,\n\t\t\t   unsigned int *verify)\n{\n    int ret;\n    ret = _gnutls_verify_crl2(crl, CA_list, CA_list_length, flags, verify);\n    if (ret < 0) {\n\tgnutls_assert();\n\treturn ret;\n    }\n    return 0;\n}", "target": 0}
{"code": "static int calc_compression_level(RedsState *reds)\n{\n    spice_assert(reds_get_streaming_video(reds) != SPICE_STREAM_VIDEO_INVALID);\n    if ((reds_get_streaming_video(reds) != SPICE_STREAM_VIDEO_OFF) ||\n        (spice_server_get_image_compression(reds) != SPICE_IMAGE_COMPRESSION_QUIC)) {\n        return 0;\n    } else {\n        return 1;\n    }\n}", "target": 0}
{"code": "static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "int64 SavePackage::CurrentSpeed() const {\n  base::TimeDelta diff = base::TimeTicks::Now() - start_tick_;\n  int64 diff_ms = diff.InMilliseconds();\n  return diff_ms == 0 ? 0 : completed_count() * 1000 / diff_ms;\n}", "target": 0}
{"code": "Function *ESTreeIRGen::genGeneratorFunction(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode) {\n  assert(functionNode && \"Function AST cannot be null\");\n  auto *outerFn = Builder.createGeneratorFunction(\n      originalName,\n      Function::DefinitionKind::ES5Function,\n      ESTree::isStrict(functionNode->strictness),\n       nullptr);\n  auto *innerFn = genES5Function(\n      genAnonymousLabelName(originalName.isValid() ? originalName.str() : \"\"),\n      lazyClosureAlias,\n      functionNode,\n      true);\n  {\n    FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()};\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(outerFn),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::No);\n    auto *gen = Builder.createCreateGeneratorInst(innerFn);\n    if (!hasSimpleParams(functionNode)) {\n      Value *next = Builder.createLoadPropertyInst(gen, \"next\");\n      Builder.createCallInst(next, gen, {});\n    }\n    emitFunctionEpilogue(gen);\n  }\n  return outerFn;\n}", "target": 1}
{"code": "static void esp_do_nodma(ESPState *s)\n{\n    int to_device = ((s->rregs[ESP_RSTAT] & 7) == STAT_DO);\n    uint32_t cmdlen;\n    int len;\n    if (s->do_cmd) {\n        cmdlen = fifo8_num_used(&s->cmdfifo);\n        trace_esp_handle_ti_cmd(cmdlen);\n        s->ti_size = 0;\n        if ((s->rregs[ESP_RSTAT] & 7) == STAT_CD) {\n            if (s->cmdfifo_cdb_offset == fifo8_num_used(&s->cmdfifo)) {\n                return;\n            }\n            s->do_cmd = 0;\n            do_cmd(s);\n        } else {\n            s->cmdfifo_cdb_offset = fifo8_num_used(&s->cmdfifo);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n            s->rregs[ESP_RINTR] |= INTR_BS;\n            esp_raise_irq(s);\n        }\n        return;\n    }\n    if (!s->current_req) {\n        return;\n    }\n    if (s->async_len == 0) {\n        return;\n    }\n    if (to_device) {\n        len = MIN(fifo8_num_used(&s->fifo), ESP_FIFO_SZ);\n        esp_fifo_pop_buf(&s->fifo, s->async_buf, len);\n        s->async_buf += len;\n        s->async_len -= len;\n        s->ti_size += len;\n    } else {\n        if (fifo8_is_empty(&s->fifo)) {\n            fifo8_push(&s->fifo, s->async_buf[0]);\n            s->async_buf++;\n            s->async_len--;\n            s->ti_size--;\n        }\n    }\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        return;\n    }\n    s->rregs[ESP_RINTR] |= INTR_BS;\n    esp_raise_irq(s);\n}", "target": 1}
{"code": "bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),\n\t\t\t\tSERVICE_ALL_ACCESS,\t\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\tSERVICE_AUTO_START,\t\n\t\t\t\tSERVICE_ERROR_NORMAL,\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr );\t\t\t\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n\t\t}\n\t\treturn false;\n\t}\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n\treturn true;\n}", "target": 1}
{"code": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n \t\t\t  loff_t *ppos)\n {\n \tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n \tchar in_buffer[20];\n \tunsigned long flags;\n \tdev = file->private_data;\n \tmutex_lock(&dev->io_mutex);\n \tif (!dev->interface) {\t\t\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n \t}\n \tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n \tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\nexit:\n \tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n }", "target": 1}
{"code": "AutoFillManager::AutoFillManager(TabContents* tab_contents)\n    : tab_contents_(tab_contents),\n      personal_data_(NULL),\n      download_manager_(tab_contents_->profile()) {\n  DCHECK(tab_contents);\n  personal_data_ =\n      tab_contents_->profile()->GetOriginalProfile()->GetPersonalDataManager();\n  download_manager_.SetObserver(this);\n}", "target": 0}
{"code": "pci_emul_capwrite(struct pci_vdev *dev, int offset, int bytes, uint32_t val)\n{\n\tint capid;\n\tuint8_t capoff, nextoff;\n\tif ((offset & (bytes - 1)) != 0)\n\t\treturn;\n\tcapoff = CAP_START_OFFSET;\n\twhile (1) {\n\t\tnextoff = pci_get_cfgdata8(dev, capoff + 1);\n\t\tif (nextoff == 0)\n\t\t\tbreak;\n\t\tif (offset >= capoff && offset < nextoff)\n\t\t\tbreak;\n\t\tcapoff = nextoff;\n\t}\n\tassert(offset >= capoff);\n\tif (offset == capoff || offset == capoff + 1) {\n\t\tif (offset == capoff && bytes == 4) {\n\t\t\tbytes = 2;\n\t\t\toffset += 2;\n\t\t\tval >>= 16;\n\t\t} else\n\t\t\treturn;\n\t}\n\tcapid = pci_get_cfgdata8(dev, capoff);\n\tswitch (capid) {\n\tcase PCIY_MSI:\n\t\tmsicap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_MSIX:\n\t\tmsixcap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_EXPRESS:\n\t\tpciecap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tdefault:\n\t\tCFGWRITE(dev, offset, val, bytes);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "tiff12_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    gx_device_tiff *const tfdev = (gx_device_tiff *)pdev;\n    int code;\n    if (gdev_prn_file_is_new(pdev)) {\n        tfdev->tif = tiff_from_filep(pdev, pdev->dname, file, tfdev->BigEndian, tfdev->UseBigTIFF);\n        if (!tfdev->tif)\n            return_error(gs_error_invalidfileaccess);\n    }\n    code = gdev_tiff_begin_page(tfdev, file);\n    if (code < 0)\n        return code;\n    TIFFSetField(tfdev->tif, TIFFTAG_BITSPERSAMPLE, 4);\n    tiff_set_rgb_fields(tfdev);\n    TIFFCheckpointDirectory(tfdev->tif);\n    {\n        int y;\n        int size = gdev_prn_raster(pdev);\n        byte *data = gs_alloc_bytes(pdev->memory, size, \"tiff12_print_page\");\n        if (data == 0)\n            return_error(gs_error_VMerror);\n        memset(data, 0, size);\n        for (y = 0; y < pdev->height; ++y) {\n            const byte *src;\n            byte *dest;\n            int x;\n            code = gdev_prn_copy_scan_lines(pdev, y, data, size);\n            if (code < 0)\n                break;\n            for (src = data, dest = data, x = 0; x < size;\n                 src += 6, dest += 3, x += 6\n                ) {\n                dest[0] = (src[0] & 0xf0) | (src[1] >> 4);\n                dest[1] = (src[2] & 0xf0) | (src[3] >> 4);\n                dest[2] = (src[4] & 0xf0) | (src[5] >> 4);\n            }\n            TIFFWriteScanline(tfdev->tif, data, y, 0);\n        }\n        gs_free_object(pdev->memory, data, \"tiff12_print_page\");\n        TIFFWriteDirectory(tfdev->tif);\n    }\n    return code;\n}", "target": 1}
{"code": "mm_free(struct mm_master *mm, void *address)\n{\n\tstruct mm_share *mms, *prev, tmp;\n\ttmp.address = address;\n\tmms = RB_FIND(mmtree, &mm->rb_allocated, &tmp);\n\tif (mms == NULL)\n\t\tfatal(\"mm_free(%p): can not find %p\", mm, address);\n\tmemset(mms->address, 0xd0, mms->size);\n\tRB_REMOVE(mmtree, &mm->rb_allocated, mms);\n\tif (RB_INSERT(mmtree, &mm->rb_free, mms) != NULL)\n\t\tfatal(\"mm_free(%p): double address %p\", mm, address);\n\tprev = mms;\n\tif (RB_LEFT(prev, next)) {\n\t\tprev = RB_LEFT(prev, next);\n\t\twhile (RB_RIGHT(prev, next))\n\t\t\tprev = RB_RIGHT(prev, next);\n\t} else {\n\t\tif (RB_PARENT(prev, next) &&\n\t\t    (prev == RB_RIGHT(RB_PARENT(prev, next), next)))\n\t\t\tprev = RB_PARENT(prev, next);\n\t\telse {\n\t\t\twhile (RB_PARENT(prev, next) &&\n\t\t\t    (prev == RB_LEFT(RB_PARENT(prev, next), next)))\n\t\t\t\tprev = RB_PARENT(prev, next);\n\t\t\tprev = RB_PARENT(prev, next);\n\t\t}\n\t}\n\tif (prev != NULL && MM_ADDRESS_END(prev) > address)\n\t\tfatal(\"mm_free: memory corruption: %p(%zu) > %p\",\n\t\t    prev->address, prev->size, address);\n\tif (prev != NULL && MM_ADDRESS_END(prev) == address) {\n\t\tprev->size += mms->size;\n\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\t\tif (mm->mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mm->mmalloc, mms);\n\t} else\n\t\tprev = mms;\n\tif (prev == NULL)\n\t\treturn;\n\tmms = RB_NEXT(mmtree, &mm->rb_free, prev);\n\tif (mms == NULL)\n\t\treturn;\n\tif (MM_ADDRESS_END(prev) > mms->address)\n\t\tfatal(\"mm_free: memory corruption: %p < %p(%zu)\",\n\t\t    mms->address, prev->address, prev->size);\n\tif (MM_ADDRESS_END(prev) != mms->address)\n\t\treturn;\n\tprev->size += mms->size;\n\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\tif (mm->mmalloc == NULL)\n\t\tfree(mms);\n\telse\n\t\tmm_free(mm->mmalloc, mms);\n}", "target": 1}
{"code": "static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_byte = data[0];\n\tut64 offset = addr - java_get_method_start ();\n\tut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;\n\tif (op_byte == 0xaa) {\n\t\tif (pos + 8 > len) {\n\t\t\treturn op->size;\n\t\t}\n\t\tint min_val = (ut32)(UINT (data, pos + 4)),\n\t\t\tmax_val = (ut32)(UINT (data, pos + 8));\n\t\tut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;\n\t\top->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);\n\t\tRAnalCaseOp *caseop = NULL;\n\t\tpos += 12;\n\t\tif (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {\n\t\t\tfor (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {\n\t\t\t\tif (pos + 4 >= len) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));\n\t\t\t\tcaseop = r_anal_switch_op_add_case (op->switch_op,\n\t\t\t\t\taddr + pos, cur_case + min_val, addr + offset);\n\t\t\t\tif (caseop) {\n\t\t\t\t\tcaseop->bb_ref_to = addr+offset;\n\t\t\t\t\tcaseop->bb_ref_from = addr; \n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid switch boundaries at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\top->size = pos;\n\treturn op->size;\n}", "target": 1}
{"code": "xfs_perag_clear_reclaim_tag(\n\tstruct xfs_perag\t*pag)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tlockdep_assert_held(&pag->pag_ici_lock);\n\tif (--pag->pag_ici_reclaimable)\n\t\treturn;\n\tspin_lock(&mp->m_perag_lock);\n\tradix_tree_tag_clear(&mp->m_perag_tree, pag->pag_agno,\n\t\t\t     XFS_ICI_RECLAIM_TAG);\n\tspin_unlock(&mp->m_perag_lock);\n\ttrace_xfs_perag_clear_reclaim(mp, pag->pag_agno, -1, _RET_IP_);\n}", "target": 0}
{"code": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tQFileInfo outputInfo(outputFile);\n\tQDir dir=outputInfo.dir(); \n\tQFileInfo newFileNameInfo(name);\n\tbool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\tif (!okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}", "target": 1}
{"code": "bool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbPlaintextData_longlong;\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n    *pcbPlaintextData = pcbPlaintextData_longlong;\n    return nDecryptResult == 0;\n}", "target": 1}
{"code": "static void rxfilter_notify(NetClientState *nc)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    if (nc->rxfilter_notify_enabled) {\n        char *path = object_get_canonical_path(OBJECT(n->qdev));\n        qapi_event_send_nic_rx_filter_changed(!!n->netclient_name,\n                                              n->netclient_name, path);\n        g_free(path);\n        nc->rxfilter_notify_enabled = 0;\n    }\n}", "target": 0}
{"code": "static void parse_rtcp_bye(pjmedia_rtcp_session *sess,\n\t\t\t   const void *pkt,\n\t\t\t   pj_size_t size)\n{\n    pj_str_t reason = {\"-\", 1};\n    if (size > 8) {\n\treason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),\n                             *((pj_uint8_t*)pkt+8));\n\tpj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),\n\t\t  reason.slen);\n\treason.ptr = sess->stat.peer_sdes_buf_;\n    }\n    PJ_LOG(5, (sess->name, \"Received RTCP BYE, reason: %.*s\",\n\t       reason.slen, reason.ptr));\n}", "target": 1}
{"code": "void JSArray::put(ExecState* exec, unsigned i, JSValue value)\n{\n    checkConsistency();\n    ArrayStorage* storage = m_storage;\n    unsigned length = storage->m_length;\n    if (i >= length && i <= MAX_ARRAY_INDEX) {\n        length = i + 1;\n        storage->m_length = length;\n    }\n    if (i < m_vectorLength) {\n        WriteBarrier<Unknown>& valueSlot = storage->m_vector[i];\n        if (valueSlot) {\n            valueSlot.set(exec->globalData(), this, value);\n            checkConsistency();\n            return;\n        }\n        valueSlot.set(exec->globalData(), this, value);\n        ++storage->m_numValuesInVector;\n        checkConsistency();\n        return;\n    }\n    putSlowCase(exec, i, value);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MergeSortReverseSubtreeContainedOr) {\n    addIndex(BSON(\"a\" << 1 << \"e\" << 1));\n    addIndex(BSON(\"c\" << 1 << \"e\" << -1));\n    addIndex(BSON(\"d\" << 1 << \"e\" << -1));\n    runQueryAsCommand(fromjson(\n        \"{find: 'testns', filter: {$or: [{a: 1}, {b: 1, $or: [{c: 1}, {d: 1}]}]}, sort: {e: 1}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {e: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {dir: 1}}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {a: 1, e: 1}, dir: 1}}, {fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {c: 1, e: -1}, dir: -1}}, {ixscan: {pattern: {d: 1, e: -1}, dir: \"\n        \"-1}}]}}}}]}}}}\");\n}", "target": 0}
{"code": "png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n   if ((num_palette > 0 && palette == NULL) ||\n      (num_palette == 0\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\n#        endif\n      ))\n   {\n      png_error(png_ptr, \"Invalid palette\");\n   }\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n   if (num_palette > 0)\n      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n   info_ptr->free_me |= PNG_FREE_PLTE;\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "target": 1}
{"code": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n if (mSyncSampleOffset >= 0 || data_size < 8) {\n return ERROR_MALFORMED;\n }\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n uint32_t numSyncSamples = U32_AT(&header[4]);\n if (numSyncSamples < 2) {\n        ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n }\n uint64_t allocSize = (uint64_t)numSyncSamples * sizeof(uint32_t);\n if (allocSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size too large.\");\n return ERROR_OUT_OF_RANGE;\n }\n    mTotalSize += allocSize;\n if (mTotalSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size would make sample table too large.\\n\"\n \"    Requested sync sample table size = %llu\\n\"\n \"    Eventual sample table size >= %llu\\n\"\n \"    Allowed sample table size = %llu\\n\",\n (unsigned long long)allocSize,\n (unsigned long long)mTotalSize,\n (unsigned long long)kMaxTotalSize);\n return ERROR_OUT_OF_RANGE;\n }\n    mSyncSamples = new (std::nothrow) uint32_t[numSyncSamples];\n if (!mSyncSamples) {\n        ALOGE(\"Cannot allocate sync sample table with %llu entries.\",\n (unsigned long long)numSyncSamples);\n return ERROR_OUT_OF_RANGE;\n }\n     if (mDataSource->readAt(data_offset + 8, mSyncSamples,\n             (size_t)allocSize) != (ssize_t)allocSize) {\n        delete mSyncSamples;\n         mSyncSamples = NULL;\n         return ERROR_IO;\n     }\n for (size_t i = 0; i < numSyncSamples; ++i) {\n if (mSyncSamples[i] == 0) {\n            ALOGE(\"b/32423862, unexpected zero value in stss\");\n continue;\n }\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n }\n    mSyncSampleOffset = data_offset;\n    mNumSyncSamples = numSyncSamples;\n return OK;\n}", "target": 1}
{"code": "int button_open(Button *b) {\n        char *p, name[256];\n        int r;\n        assert(b);\n        b->fd = safe_close(b->fd);\n        p = strjoina(\"/dev/input/\", b->name);\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n        (void) button_set_mask(b);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n        return 0;\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}", "target": 1}
{"code": "Opal::Call::transfer (std::string uri)\n{\n  PSafePtr<OpalConnection> connection = get_remote_connection ();\n  if (connection != NULL)\n    connection->TransferConnection (uri);\n}", "target": 0}
{"code": "static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *lp = &smc->os;\n\tstruct s_skfp_ioctl ioc;\n\tint status = 0;\n\tif (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))\n\t\treturn -EFAULT;\n\tswitch (ioc.cmd) {\n\tcase SKFP_GET_STATS:\t\n\t\tioc.len = sizeof(lp->MacStat);\n\t\tstatus = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)\n\t\t\t\t? -EFAULT : 0;\n\t\tbreak;\n\tcase SKFP_CLR_STATS:\t\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\n\t\t} else {\n\t\t\tstatus = -EPERM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"ioctl for %s: unknow cmd: %04x\\n\", dev->name, ioc.cmd);\n\t\tstatus = -EOPNOTSUPP;\n\t}\t\t\t\n\treturn status;\n}\t\t\t\t", "target": 1}
{"code": "ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\t\tif (acl) {\n\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\t\tif (error < 0)\n\t\t\t\t\treturn error;\n\t\t\t\telse {\n\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\t\tif (error == 0)\n\t\t\t\t\t\tacl = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\treturn acl ? -EACCES : 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n \tif (acl) {\n\t\tvalue = ext2_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = ext2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n \t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n \t\t    rxent->client.s_addr == clip &&\n \t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&\n \t\t    rxent->dport == sport) {\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\treturn(0);\n}", "target": 1}
{"code": "GF_Err gf_fs_set_http_max_rate(GF_FilterSession *fs, u32 rate)\n{\n\tif (!fs) return GF_OK;\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return GF_OUT_OF_MEM;\n\t}\n\tgf_dm_set_data_rate(fs->download_manager, rate);\n\treturn GF_OK;\n}", "target": 0}
{"code": "  virtual void SetUp() {\n    URLRequest::RegisterProtocolFactory(chrome::kChromeUIScheme,\n                                        &URLRequestTestJob::Factory);\n  }", "target": 0}
{"code": "void reds_disable_mm_time(RedsState *reds)\n{\n    reds->mm_time_enabled = FALSE;\n}", "target": 0}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done);\n    Tensor group_assignment = c->input(2);\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment, REDUCTION_COLLECTIVE,\n                             resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();\n    col_params->final_op = final_op_.get();\n    VLOG(1) << \"CollectiveReduceV3 group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "GF_Box *dOps_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OpusSpecificBox, GF_ISOM_BOX_TYPE_DOPS);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "int fuse_fs_chown(struct fuse_fs *fs, const char *path, uid_t uid, gid_t gid)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.chown)\n        return fs->op.chown(path, uid, gid);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "void NetworkActionPredictor::ClearTransitionalMatches() {\n  transitional_matches_.clear();\n}", "target": 0}
{"code": "static inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}", "target": 0}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tkeyring = ERR_PTR(-EINVAL);\n\tif (!name)\n\t\tgoto error;\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    type_data.link\n\t\t\t\t    ) {\n\t\t\tif (keyring->user->user_ns != current_user_ns())\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_inc(&keyring->usage);\n\t\t\tread_unlock(&keyring_name_lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tread_unlock(&keyring_name_lock);\n\tkeyring = ERR_PTR(-ENOKEY);\n error:\n\treturn keyring;\n} ", "target": 1}
{"code": "resolveTable (const char *tableList, const char *base)\n{\n  return (*tableResolver) (tableList, base);\n}", "target": 0}
{"code": "_asn1_delete_list (void)\n{\n  list_type *listElement;\n  while (firstElement)\n    {\n      listElement = firstElement;\n      firstElement = firstElement->next;\n      free (listElement);\n    }\n}", "target": 0}
{"code": "void ftoa_bounded_extra(JsVarFloat val,char *str, size_t len, int radix, int fractionalDigits) {\n  const JsVarFloat stopAtError = 0.0000001;\n  if (isnan(val)) strncpy(str,\"NaN\",len);\n  else if (!isfinite(val)) {\n    if (val<0) strncpy(str,\"-Infinity\",len);\n    else strncpy(str,\"Infinity\",len);\n  } else {\n    if (val<0) {\n      if (--len <= 0) { *str=0; return; } \n      *(str++) = '-';\n      val = -val;\n    }\n    if (((JsVarInt)(val+stopAtError)) == (1+(JsVarInt)val))\n      val = (JsVarFloat)(1+(JsVarInt)val);\n    JsVarFloat d = 1;\n    while (d*radix <= val) d*=radix;\n    while (d >= 1) {\n      int v = (int)(val / d);\n      val -= v*d;\n      if (--len <= 0) { *str=0; return; } \n      *(str++) = itoch(v);\n      d /= radix;\n    }\n#ifndef USE_NO_FLOATS\n    if (((fractionalDigits<0) && val>0) || fractionalDigits>0) {\n      bool hasPt = false;\n      val*=radix;\n      while (((fractionalDigits<0) && (fractionalDigits>-12) && (val > stopAtError)) || (fractionalDigits > 0)) {\n        int v = (int)(val+((fractionalDigits==1) ? 0.4 : 0.00000001) );\n        val = (val-v)*radix;\n\tif (v==radix) v=radix-1;\n        if (!hasPt) {\t\n\t  hasPt = true;\n          if (--len <= 0) { *str=0; return; } \n          *(str++)='.';\n        }\n        if (--len <= 0) { *str=0; return; } \n        *(str++)=itoch(v);\n        fractionalDigits--;\n      }\n    }\n#endif\n    *(str++)=0;\n  }\n}", "target": 1}
{"code": "  void dumpState(std::ostream& os, int indent_level = 0) const override {\n    header_map_->dumpState(os, indent_level);\n  }", "target": 0}
{"code": "smb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n \tstruct socket *ssocket = server->ssocket;\n \tint val = 1;\n \tcFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);\n \tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\ttotal_len += sent;\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\ttotal_len += sent;\n\t}\nuncork:\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcFYI(1, \"partial send (wanted=%u sent=%zu): terminating \"\n\t\t\t\"session\", smb_buf_length + 4, total_len);\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\tif (rc < 0 && rc != -EINTR)\n\t\tcERROR(1, \"Error %d sending data on socket to server\", rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}", "target": 1}
{"code": "static int pit_get_out(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\treturn out;\n}", "target": 0}
{"code": "void sched_clock_idle_wakeup_event(u64 delta_ns)\n{\n\tif (timekeeping_suspended)\n\t\treturn;\n\tsched_clock_tick();\n\ttouch_softlockup_watchdog();\n}", "target": 0}
{"code": "static void blk_mq_queue_reinit(struct request_queue *q)\n{\n\tWARN_ON_ONCE(!atomic_read(&q->mq_freeze_depth));\n\tblk_mq_sysfs_unregister(q);\n\tblk_mq_update_queue_map(q->mq_map, q->nr_hw_queues);\n\tblk_mq_map_swqueue(q);\n\tblk_mq_sysfs_register(q);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, OrElemMatchObject) {\n    addIndex(BSON(\"a.b\" << 1), true);\n    runQuery(\n        fromjson(\"{$or: [{a: {$elemMatch: {b: {$lte: 1}}}},\"\n                 \"{a: {$elemMatch: {b: {$gte: 4}}}}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{or: {nodes: [\"\n        \"{fetch: {filter: {a:{$elemMatch:{b:{$gte:4}}}}, node: \"\n        \"{ixscan: {filter: null, pattern: {'a.b': 1}}}}},\"\n        \"{fetch: {filter: {a:{$elemMatch:{b:{$lte:1}}}}, node: \"\n        \"{ixscan: {filter: null, pattern: {'a.b': 1}}}}}]}}\");\n}", "target": 0}
{"code": "void TightDecoder::FilterGradient(const rdr::U8* inbuf,\n                                  const PixelFormat& pf, PIXEL_T* outbuf,\n                                  int stride, const Rect& r)\n{\n  int x, y, c;\n  static rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  static rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);\n    for (c = 0; c < 3; c++)\n      pix[c] += prevRow[c];\n    memcpy(thisRow, pix, sizeof(pix));\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 255) {\n          est[c] = 255;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n      }\n      pf.rgbFromBuffer(pix, &inbuf[y*rectWidth+x], 1);\n      for (c = 0; c < 3; c++)\n        pix[c] += est[c];\n      memcpy(&thisRow[x*3], pix, sizeof(pix));\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; \n  int restlen = srclen - chunks * chunklen; \n  int out_len = (chunks + 1) * endlen + srclen;\n  String ret(out_len, ReserveString);\n  char *dest = ret.bufferSlice().ptr;\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;\n  }\n  if (restlen) {\n    memcpy(q, p, restlen);\n    q += restlen;\n    memcpy(q, end, endlen);\n    q += endlen;\n  }\n  ret.setSize(q - dest);\n  return ret;\n}", "target": 1}
{"code": "bool ImageLoader::ShouldLoadImmediately(const KURL& url) const {\n  if (!url.IsNull()) {\n    Resource* resource = GetMemoryCache()->ResourceForURL(\n        url, element_->GetDocument().Fetcher()->GetCacheIdentifier());\n    if (resource && !resource->ErrorOccurred())\n      return true;\n  }\n  return (IsHTMLObjectElement(element_) || IsHTMLEmbedElement(element_));\n}", "target": 0}
{"code": "void LibRaw::process_Sony_0x0116(uchar *buf, ushort len, unsigned long long id)\n{\n  int i = 0;\n  if (((id == 0x101ULL) || \n       (id == 0x106ULL) || \n       (id == 0x10dULL) || \n       (id == 0x10eULL)    \n       ) &&\n      (len >= 2))\n    i = 1;\n  else if ((id >= 0x111ULL) && (len >= 3))\n    i = 2;\n  else\n    return;\n  imgdata.makernotes.common.BatteryTemperature = (float)(buf[i] - 32) / 1.8f;\n}", "target": 0}
{"code": "void HTMLMediaElement::SetNetworkState(NetworkState state) {\n  if (network_state_ == state)\n    return;\n  network_state_ = state;\n  if (GetMediaControls())\n    GetMediaControls()->NetworkStateChanged();\n}", "target": 0}
{"code": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}", "target": 1}
{"code": "static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tBYTE* rle = context->Planes;\n\tWINPR_ASSERT(rle);\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tconst UINT32 originalSize = context->OrgByteCount[i];\n\t\tconst UINT32 planeSize = context->PlaneByteCount[i];\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i],\n\t\t\t                    context->priv->PlaneBuffersLength, originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\t\trle += planeSize;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void HTMLMediaElement::SetSrcObject(MediaStreamDescriptor* src_object) {\n  BLINK_MEDIA_LOG << \"setSrcObject(\" << (void*)this << \")\";\n  src_object_ = src_object;\n  InvokeLoadAlgorithm();\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, EqCanUseHashedIndexWithRegex) {\n    addIndex(BSON(\"a\"\n                  << \"hashed\"));\n    runQuery(fromjson(\"{a: {$eq: /abc/}}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n}", "target": 0}
{"code": "static int handle_xsetbv(struct kvm_vcpu *vcpu)\n{\n\tu64 new_bv = kvm_read_edx_eax(vcpu);\n\tu32 index = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tif (kvm_set_xcr(vcpu, index, new_bv) == 0)\n\t\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}", "target": 1}
{"code": "gdk_pixbuf__ico_is_save_option_supported (const gchar *option_key)\n{\n        if (g_strcmp0 (option_key, \"depth\") == 0 ||\n            g_strcmp0 (option_key, \"x_hot\") == 0 ||\n            g_strcmp0 (option_key, \"y_hot\") == 0)\n                return TRUE;\n        return FALSE;\n}", "target": 0}
{"code": "static void fuse_lib_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                              size_t size)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    int res;\n    if (size) {\n        char *value = (char *) malloc(size);\n        if (value == NULL) {\n            reply_err(req, -ENOMEM);\n            return;\n        }\n        res = common_getxattr(f, req, ino, name, value, size);\n        if (res > 0)\n            fuse_reply_buf(req, value, res);\n        else\n            reply_err(req, res);\n        free(value);\n    } else {\n        res = common_getxattr(f, req, ino, name, NULL, 0);\n        if (res >= 0)\n            fuse_reply_xattr(req, res);\n        else\n            reply_err(req, res);\n    }\n}", "target": 0}
{"code": "static int mxf_uid_to_str(UID uid, char **str)\n{\n    int i;\n    char *p;\n    p = *str = av_mallocz(sizeof(UID) * 2 + 4 + 1);\n    if (!p)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < sizeof(UID); i++) {\n        snprintf(p, 2 + 1, \"%.2x\", uid[i]);\n        p += 2;\n        if (i == 3 || i == 5 || i == 7 || i == 9) {\n            snprintf(p, 1 + 1, \"-\");\n            p++;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static long __media_device_enum_links(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum *links)\n{\n\tstruct media_entity *entity;\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\tif (links->pads) {\n\t\tunsigned int p;\n \t\tfor (p = 0; p < entity->num_pads; p++) {\n \t\t\tstruct media_pad_desc pad;\n \t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n \t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n \t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tif (links->links) {\n\t\tstruct media_link_desc __user *ulink;\n\t\tunsigned int l;\n\t\tfor (l = 0, ulink = links->links; l < entity->num_links; l++) {\n\t\t\tstruct media_link_desc link;\n \t\t\tif (entity->links[l].source->entity != entity)\n \t\t\t\tcontinue;\n \t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n \t\t\t\t\t\t  &link.source);\n \t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,\n\t\t\t\t\t\t  &link.sink);\n\t\t\tlink.flags = entity->links[l].flags;\n\t\t\tif (copy_to_user(ulink, &link, sizeof(*ulink)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink++;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool VariableUnserializer::matchString(folly::StringPiece str) {\n  const char* p = m_buf;\n  assertx(p <= m_end);\n  int total = 0;\n  if (*p == 'S') {\n    total = 2 + 8 + 1;\n    if (p + total > m_end) return false;\n    p++;\n    if (*p++ != ':') return false;\n    auto const sd = *reinterpret_cast<StringData*const*>(p);\n    assertx(sd->isStatic());\n    if (str.compare(sd->slice()) != 0) return false;\n    p += size_t(8);\n  } else {\n    const auto ss = str.size();\n    if (ss >= 100) return false;\n    int digits = ss >= 10 ? 2 : 1;\n    total = 2 + digits + 2 + ss + 2;\n    if (p + total > m_end) return false;\n    if (*p++ != 's') return false;\n    if (*p++ != ':') return false;\n    if (digits == 2) {\n      if (*p++ != '0' + ss/10) return false;\n      if (*p++ != '0' + ss%10) return false;\n    } else {\n      if (*p++ != '0' + ss) return false;\n    }\n    if (*p++ != ':') return false;\n    if (*p++ != '\\\"') return false;\n    if (memcmp(p, str.data(), ss)) return false;\n    p += ss;\n    if (*p++ != '\\\"') return false;\n  }\n  if (*p++ != ';') return false;\n  assertx(m_buf + total == p);\n  m_buf = p;\n  return true;\n}", "target": 1}
{"code": "  Address pending_message_script_address() {\n    return reinterpret_cast<Address>(\n        &thread_local_top_.pending_message_script_);\n  }", "target": 0}
{"code": "static int ipip6_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\tiph = ip_hdr(skb);\n\tread_lock(&ipip6_lock);\n\tif ((tunnel = ipip6_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\t\tiph->saddr, iph->daddr)) != NULL) {\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tIPCB(skb)->flags = 0;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tif ((tunnel->dev->priv_flags & IFF_ISATAP) &&\n\t\t    !isatap_chksrc(skb, iph, tunnel)) {\n\t\t\ttunnel->stat.rx_errors++;\n\t\t\tread_unlock(&ipip6_lock);\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\ttunnel->stat.rx_packets++;\n\t\ttunnel->stat.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tdst_release(skb->dst);\n\t\tskb->dst = NULL;\n\t\tnf_reset(skb);\n\t\tipip6_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\tread_unlock(&ipip6_lock);\n\t\treturn 0;\n\t}\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\tkfree_skb(skb);\n\tread_unlock(&ipip6_lock);\nout:\n\treturn 0;\n}", "target": 1}
{"code": "trigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%i\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}", "target": 0}
{"code": "GF_Err srpp_on_child_box(GF_Box *s, GF_Box *a)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tif (ptr->info) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->info = (GF_SchemeInformationBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tif (ptr->scheme_type) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->scheme_type = (GF_SchemeTypeBox *)a;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void html_link_open(const char *url, const char *title, const char *class)\n{\n\thtml(\"<a href='\");\n\thtml_attr(url);\n\tif (title) {\n\t\thtml(\"' title='\");\n\t\thtml_attr(title);\n\t}\n\tif (class) {\n\t\thtml(\"' class='\");\n\t\thtml_attr(class);\n\t}\n\thtml(\"'>\");\n}", "target": 0}
{"code": "x509stack_push(struct cert_stack *stack, struct rpki_uri *uri, X509 *x509,\n    enum rpki_policy policy, enum cert_type type)\n{\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo, *head_repo;\n\tstruct defer_node *defer_separator;\n\tunsigned int work_repo_level;\n\tint ok;\n\tint error;\n\trepo = malloc(sizeof(struct repo_level_node));\n\tif (repo == NULL)\n\t\treturn pr_enomem();\n\trepo->level = 0;\n\twork_repo_level = working_repo_peek_level();\n\thead_repo = SLIST_FIRST(&stack->levels);\n\tif (head_repo != NULL && work_repo_level > head_repo->level)\n\t\trepo->level = work_repo_level;\n\tSLIST_INSERT_HEAD(&stack->levels, repo, next);\n\tmeta = malloc(sizeof(struct metadata_node));\n\tif (meta == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end3;\n\t}\n\tmeta->uri = uri;\n\turi_refget(uri);\n\tserial_numbers_init(&meta->serials);\n\tsubjects_init(&meta->subjects);\n\tmeta->resources = resources_create(false);\n\tif (meta->resources == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end4;\n\t}\n\tresources_set_policy(meta->resources, policy);\n\terror = certificate_get_resources(x509, meta->resources, type);\n\tif (error)\n\t\tgoto end5;\n\tif (type == TA && resources_empty(meta->resources)) {\n\t\terror = pr_val_err(\"Trust Anchor certificate does not define any number resources.\");\n\t\tgoto end5;\n\t}\n\tdefer_separator = malloc(sizeof(struct defer_node));\n\tif (defer_separator == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end5;\n\t}\n\tdefer_separator->type = DNT_SEPARATOR;\n\tok = sk_X509_push(stack->x509s, x509);\n\tif (ok <= 0) {\n\t\terror = val_crypto_err(\n\t\t    \"Could not add certificate to trusted stack: %d\", ok);\n\t\tgoto end5;\n\t}\n\tSLIST_INSERT_HEAD(&stack->defers, defer_separator, next);\n\tSLIST_INSERT_HEAD(&stack->metas, meta, next);\n\treturn 0;\nend5:\tresources_destroy(meta->resources);\nend4:\tsubjects_cleanup(&meta->subjects, subject_cleanup);\n\tserial_numbers_cleanup(&meta->serials, serial_cleanup);\n\turi_refput(meta->uri);\n\tfree(meta);\nend3:\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n\treturn error;\n}", "target": 1}
{"code": "get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)\n{\n    static gprincs_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gprincs_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST,\n                                                       NULL,\n                                                       NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_principals\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_principals((void *)handle,\n                                         arg->exp, &ret.princs,\n                                         &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_get_principals\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "void HTMLSelectElement::add(HTMLElement* element, HTMLElement* before, ExceptionState& exceptionState)\n{\n    RefPtr<HTMLElement> protectNewChild(element);\n    if (!element || !(element->hasLocalName(optionTag) || element->hasLocalName(hrTag)))\n        return;\n    insertBefore(element, before, exceptionState);\n    setNeedsValidityCheck();\n}", "target": 0}
{"code": "virSecuritySELinuxSetSecurityChardevCallback(virDomainDef *def,\n                                             virDomainChrDef *dev G_GNUC_UNUSED,\n                                             void *opaque)\n{\n    struct _virSecuritySELinuxChardevCallbackData *data = opaque;\n    return virSecuritySELinuxSetChardevLabel(data->mgr, def, dev->source,\n                                             data->chardevStdioLogd);\n}", "target": 0}
{"code": "matchCurrentInput(\n \t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n \tint k;\n \tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n \t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n \t\t\treturn 0;\n \treturn 1;\n}", "target": 1}
{"code": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\tdesc->len = sizeof(data->verdict);\n\treturn 0;\n}", "target": 1}
{"code": "InlineBox* InlineFlowBox::firstLeafChild() const\n{\n    InlineBox* leaf = 0;\n    for (InlineBox* child = firstChild(); child && !leaf; child = child->nextOnLine())\n        leaf = child->isLeaf() ? child : static_cast<InlineFlowBox*>(child)->firstLeafChild();\n    return leaf;\n}", "target": 0}
{"code": "flatpak_context_merge (FlatpakContext *context,\n                       FlatpakContext *other)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  context->shares &= ~other->shares_valid;\n  context->shares |= other->shares;\n  context->shares_valid |= other->shares_valid;\n  context->sockets &= ~other->sockets_valid;\n  context->sockets |= other->sockets;\n  context->sockets_valid |= other->sockets_valid;\n  context->devices &= ~other->devices_valid;\n  context->devices |= other->devices;\n  context->devices_valid |= other->devices_valid;\n  context->features &= ~other->features_valid;\n  context->features |= other->features;\n  context->features_valid |= other->features_valid;\n  g_hash_table_iter_init (&iter, other->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));\n  g_hash_table_iter_init (&iter, other->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->persistent, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->filesystems, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char **policy_values = (const char **) value;\n      int i;\n      for (i = 0; policy_values[i] != NULL; i++)\n        flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);\n    }\n}", "target": 1}
{"code": "find_file (const char *search_path, const char *base_name, char **pdir)\n{\n  FILE *file = 0;\n  foreach_dirinpath (search_path, base_name, find_file_callback, pdir, &file);\n  return file;\n}", "target": 0}
{"code": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n \tchar *host = NULL;\n #ifdef HAVE_IPV6\n\tchar *p;\n \tif (*(str) == '[' && str_len > 1) {\n\t\tp = memchr(str + 1, ']', str_len - 2);\n \t\tif (!p || *(p + 1) != ':') {\n \t\t\tif (get_err) {\n \t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n \t\t\t}\n \t\t\treturn NULL;\n \t\t}\n\t\t*portno = atoi(p + 2);\n \t\treturn estrndup(str + 1, p - str - 1);\n \t}\n #endif\n \tif (str_len) {\n \t\tcolon = memchr(str, ':', str_len - 1);\n \t} else {\n \t\tcolon = NULL;\n \t}\n \tif (colon) {\n\t\t*portno = atoi(colon + 1);\n\t\thost = estrndup(str, colon - str);\n\t} else {\n\t\tif (get_err) {\n\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n \t\t}\n\t\treturn NULL;\n \t}\n\treturn host;\n }", "target": 1}
{"code": "win_enter(win_T *wp, int undo_sync)\n{\n    win_enter_ext(wp, undo_sync, FALSE, FALSE, TRUE, TRUE);\n}", "target": 0}
{"code": "static void WriteBinaryGltfStream(std::ostream &stream,\n                                  const std::string &content,\n                                  const std::vector<unsigned char> &binBuffer) {\n  const std::string header = \"glTF\";\n  const int version = 2;\n  const uint32_t content_size = uint32_t(content.size());\n  const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n  const uint32_t length =\n      12 + 8 + content_size + content_padding_size +\n      (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);\n  stream.write(header.c_str(), std::streamsize(header.size()));\n  stream.write(reinterpret_cast<const char *>(&version), sizeof(version));\n  stream.write(reinterpret_cast<const char *>(&length), sizeof(length));\n  const uint32_t model_length = uint32_t(content.size()) + content_padding_size;\n  const uint32_t model_format = 0x4E4F534A;\n  stream.write(reinterpret_cast<const char *>(&model_length),\n               sizeof(model_length));\n  stream.write(reinterpret_cast<const char *>(&model_format),\n               sizeof(model_format));\n  stream.write(content.c_str(), std::streamsize(content.size()));\n  if (content_padding_size > 0) {\n    const std::string padding = std::string(size_t(content_padding_size), ' ');\n    stream.write(padding.c_str(), std::streamsize(padding.size()));\n  }\n  if (binBuffer.size() > 0) {\n    const uint32_t bin_length = uint32_t(binBuffer.size()) + bin_padding_size;\n    const uint32_t bin_format = 0x004e4942;\n    stream.write(reinterpret_cast<const char *>(&bin_length),\n                 sizeof(bin_length));\n    stream.write(reinterpret_cast<const char *>(&bin_format),\n                 sizeof(bin_format));\n    stream.write(reinterpret_cast<const char *>(binBuffer.data()),\n                 std::streamsize(binBuffer.size()));\n    if (bin_padding_size > 0) {\n      const std::vector<unsigned char> padding =\n          std::vector<unsigned char>(size_t(bin_padding_size), 0);\n      stream.write(reinterpret_cast<const char *>(padding.data()),\n                   std::streamsize(padding.size()));\n    }\n  }\n}", "target": 1}
{"code": "_jpeg_error_exit (j_common_ptr error)\n{\n\tj_decompress_ptr cinfo = (j_decompress_ptr)error;\n\tstruct _jpeg_src_mgr *src = (struct _jpeg_src_mgr *)cinfo->src;\n\tlongjmp (src->setjmp_buffer, 1);\n}", "target": 0}
{"code": "static void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tget_debugreg(vcpu->arch.dr6, 6);\n\tvcpu->arch.dr7 = vmcs_readl(GUEST_DR7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_MOV_DR_EXITING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}", "target": 0}
{"code": "void OfflineAudioDestinationHandler::PrepareTaskRunnerForRendering() {\n  DCHECK(IsMainThread());\n  AudioWorklet* audio_worklet = Context()->audioWorklet();\n  if (audio_worklet && audio_worklet->IsReady()) {\n    if (!render_thread_) {\n      if (!render_thread_task_runner_) {\n        render_thread_task_runner_ =\n            audio_worklet->GetMessagingProxy()->GetBackingWorkerThread()\n                         ->GetTaskRunner(TaskType::kMiscPlatformAPI);\n      }\n    } else {\n      render_thread_ = nullptr;\n      render_thread_task_runner_ =\n          audio_worklet->GetMessagingProxy()->GetBackingWorkerThread()\n                       ->GetTaskRunner(TaskType::kMiscPlatformAPI);\n    }\n  } else {\n    if (!render_thread_) {\n      render_thread_ = Platform::Current()->CreateThread(\n          ThreadCreationParams(WebThreadType::kOfflineAudioRenderThread));\n      render_thread_task_runner_ = render_thread_->GetTaskRunner();\n    }\n  }\n  DCHECK(render_thread_task_runner_);\n}", "target": 0}
{"code": "void menu_cache_remove_reload_notify(MenuCache* cache, MenuCacheNotifyId notify_id)\n{\n    MENU_CACHE_LOCK;\n    g_slice_free( CacheReloadNotifier, ((GSList*)notify_id)->data );\n    cache->notifiers = g_slist_delete_link( cache->notifiers, (GSList*)notify_id );\n    MENU_CACHE_UNLOCK;\n}", "target": 0}
{"code": "int nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_ENABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->enable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_ENABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "  explicit QuantizeAndDequantizeOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_min\", &input_min_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_max\", &input_max_));\n    if (range_given_) {\n      OP_REQUIRES(\n          ctx, input_min_ <= input_max_,\n          errors::InvalidArgument(\"Invalid range: input_min \", input_min_,\n                                  \" > input_max \", input_max_));\n    }\n  }", "target": 1}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if ((EncCP1254_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'I')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? DOTLESS_i : 'i';\n      else\n        code = ENC_CP1254_TO_LOWER_CASE(code);\n    }\n    else if (code == 0x83 || code == 0xAA || code == 0xBA || code == 0xB5)\n      ;\n    else if ((EncCP1254_CtypeTable[code] & BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'i')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? I_WITH_DOT_ABOVE : 'I';\n      else if (code == DOTLESS_i)\n\tcode = 'I';\n      else if (code == 0x9A || code == 0x9C || code == 0x9E)\n\tcode -= 0x10;\n      else if (code == 0xFF)\n\tcode -= 0x60;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "void luaV_concat (lua_State *L, int total) {\n  if (total == 1)\n    return;  \n  do {\n    StkId top = L->top;\n    int n = 2;  \n    if (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||\n        !tostring(L, s2v(top - 1)))\n      luaT_tryconcatTM(L);\n    else if (isemptystr(s2v(top - 1)))  \n      cast_void(tostring(L, s2v(top - 2)));  \n    else if (isemptystr(s2v(top - 2))) {  \n      setobjs2s(L, top - 2, top - 1);  \n    }\n    else {\n      size_t tl = vslen(s2v(top - 1));\n      TString *ts;\n      for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {\n        size_t l = vslen(s2v(top - n - 1));\n        if (l_unlikely(l >= (MAX_SIZE/sizeof(char)) - tl))\n          luaG_runerror(L, \"string length overflow\");\n        tl += l;\n      }\n      if (tl <= LUAI_MAXSHORTLEN) {  \n        char buff[LUAI_MAXSHORTLEN];\n        copy2buff(top, n, buff);  \n        ts = luaS_newlstr(L, buff, tl);\n      }\n      else {  \n        ts = luaS_createlngstrobj(L, tl);\n        copy2buff(top, n, getstr(ts));\n      }\n      setsvalue2s(L, top - n, ts);  \n    }\n    total -= n-1;  \n    L->top -= n-1;  \n  } while (total > 1);  \n}", "target": 1}
{"code": "key_set(const char *key) {\n    int\t\tlen = (int)strlen(key);\n    int64_t\th = calc_hash(key, &len);\n    Slot\t*bucket = get_bucketp(h);\n    Slot\ts;\n    if (NULL != (s = (Slot)AGOO_MALLOC(sizeof(struct _slot)))) {\n\ts->hash = h;\n\ts->klen = len;\n\ts->key = key;\n\ts->next = *bucket;\n\t*bucket = s;\n    }\n}", "target": 1}
{"code": "callbacks_move_layer_down_menu_activate (GtkMenuItem *menuitem, gpointer user_data) {\n\tcallbacks_move_layer_down_button_clicked(NULL, NULL);\n\tgtk_widget_grab_focus (screen.win.layerTree);\n}", "target": 0}
{"code": "static ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n    int n;\n    uint8_t *p;\n    uint32_t crc;\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return -1;\n    if (s->np >= 31) {\n        return 0;\n    }\n    DPRINTF(\"Received packet len=%zu\\n\", size);\n    n = s->next_packet + s->np;\n    if (n >= 31)\n        n -= 31;\n    s->np++;\n    s->rx[n].len = size + 6;\n    p = s->rx[n].data;\n    *(p++) = (size + 6);\n    *(p++) = (size + 6) >> 8;\n    memcpy (p, buf, size);\n    p += size;\n    crc = crc32(~0, buf, size);\n    *(p++) = crc;\n    *(p++) = crc >> 8;\n    *(p++) = crc >> 16;\n    *(p++) = crc >> 24;\n    if ((size & 3) != 2) {\n        memset(p, 0, (6 - size) & 3);\n    }\n    s->ris |= SE_INT_RX;\n    stellaris_enet_update(s);\n    return size;\n}", "target": 1}
{"code": "TEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}", "target": 0}
{"code": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\treturn 0;\n}", "target": 1}
{"code": "bool Item_cache_row::cache_value()\n{\n  if (!example)\n    return FALSE;\n  value_cached= TRUE;\n  null_value= 0;\n  example->bring_value();\n  for (uint i= 0; i < item_count; i++)\n  {\n    values[i]->cache_value();\n    null_value|= values[i]->null_value;\n  }\n  return TRUE;\n}", "target": 0}
{"code": "setup_remove_header(const uschar *hnames)\n{\nif (*hnames)\n  acl_removed_headers = acl_removed_headers\n    ? string_sprintf(\"%s : %s\", acl_removed_headers, hnames)\n    : string_copy(hnames);\n}", "target": 0}
{"code": "decompileCALLFRAME(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"callFrame(\");\n\tdecompilePUSHPARAM(pop(),1);\n\tprintln(\");\");\n\treturn 0;\n}", "target": 0}
{"code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t bytes = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client)\n    {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (strncasecmp (ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (strncasecmp (ptr, url->timelimit_header, url->timelimit_header_len) == 0)\n        {\n            unsigned int limit = 0;\n            sscanf ((char *)ptr+url->timelimit_header_len, \"%u\\r\\n\", &limit);\n            client->con->discon_time = time(NULL) + limit;\n        }\n        if (strncasecmp (ptr, \"icecast-auth-message: \", 22) == 0)\n        {\n            char *eol;\n            snprintf (url->errormsg, sizeof (url->errormsg), \"%s\", (char*)ptr+22);\n            eol = strchr (url->errormsg, '\\r');\n            if (eol == NULL)\n                eol = strchr (url->errormsg, '\\n');\n            if (eol)\n                *eol = '\\0';\n        }\n    }\n    return bytes;\n}", "target": 1}
{"code": "static void call_console_drivers(unsigned start, unsigned end)\n{\n\tunsigned cur_index, start_print;\n\tstatic int msg_level = -1;\n\tBUG_ON(((int)(start - end)) > 0);\n\tcur_index = start;\n \tstart_print = start;\n \twhile (cur_index != end) {\n \t\tif (msg_level < 0 && ((end - cur_index) > 2)) {\n\t\t\tcur_index += log_prefix(&LOG_BUF(cur_index), &msg_level, NULL);\n \t\t\tstart_print = cur_index;\n \t\t}\n \t\twhile (cur_index != end) {\n\t\t\tchar c = LOG_BUF(cur_index);\n\t\t\tcur_index++;\n\t\t\tif (c == '\\n') {\n\t\t\t\tif (msg_level < 0) {\n\t\t\t\t\tmsg_level = default_message_loglevel;\n\t\t\t\t}\n\t\t\t\t_call_console_drivers(start_print, cur_index, msg_level);\n\t\t\t\tmsg_level = -1;\n\t\t\t\tstart_print = cur_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_call_console_drivers(start_print, end, msg_level);\n}", "target": 1}
{"code": "user_local_get_object_path (User *user)\n{\n        return user->object_path;\n}", "target": 0}
{"code": "bool FrameLoader::isComplete() const\n{\n    return m_isComplete;\n}", "target": 0}
{"code": "static void nfs4_handle_setlk_error(struct nfs_server *server, struct nfs4_lock_state *lsp, int new_lock_owner, int error)\n{\n\tswitch (error) {\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\t\tif (new_lock_owner != 0 ||\n\t\t   test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0)\n\t\t\tnfs4_schedule_stateid_recovery(server, lsp->ls_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\tcase -NFS4ERR_EXPIRED:\n\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t};\n}", "target": 0}
{"code": "ospf_upd_list_clean (struct list *lsas)\n{\n  struct listnode *node, *nnode;\n  struct ospf_lsa *lsa;\n  for (ALL_LIST_ELEMENTS (lsas, node, nnode, lsa))\n    ospf_lsa_discard (lsa);\n  list_delete (lsas);\n}", "target": 0}
{"code": "fixExec2Error(int action,\n             u_char * var_val,\n             u_char var_val_type,\n             size_t var_val_len,\n             u_char * statP, oid * name, size_t name_len)\n{\n    netsnmp_old_extend *exten = NULL;\n    unsigned int idx;\n    idx = name[name_len-1] -1;\n    exten = &compatability_entries[ idx ];\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    switch (action) {\n    case MODE_SET_RESERVE1:\n        if (var_val_type != ASN_INTEGER) {\n            snmp_log(LOG_ERR, \"Wrong type != int\\n\");\n            return SNMP_ERR_WRONGTYPE;\n        }\n        idx = *((long *) var_val);\n        if (idx != 1) {\n            snmp_log(LOG_ERR, \"Wrong value != 1\\n\");\n            return SNMP_ERR_WRONGVALUE;\n        }\n        if (!exten || !exten->efix_entry) {\n            snmp_log(LOG_ERR, \"No command to run\\n\");\n            return SNMP_ERR_GENERR;\n        }\n        return SNMP_ERR_NOERROR;\n    case MODE_SET_COMMIT:\n        netsnmp_cache_check_and_reload( exten->efix_entry->cache );\n    }\n#endif \n    return SNMP_ERR_NOERROR;\n}", "target": 1}
{"code": "void setup_work_tree(void)\n{\n\tconst char *work_tree, *git_dir;\n\tstatic int initialized = 0;\n\tif (initialized)\n\t\treturn;\n\twork_tree = get_git_work_tree();\n\tgit_dir = get_git_dir();\n\tif (!is_absolute_path(git_dir))\n\t\tset_git_dir(make_absolute_path(git_dir));\n\tif (!work_tree || chdir(work_tree))\n\t\tdie(\"This operation must be run in a work tree\");\n\tinitialized = 1;\n}", "target": 0}
{"code": "static int put_chars(u32 vtermno, const char *buf, int count)\n {\n \tstruct port *port;\n \tstruct scatterlist sg[1];\n \tif (unlikely(early_put_chars))\n \t\treturn early_put_chars(vtermno, buf, count);\n\tport = find_port_by_vtermno(vtermno);\n \tif (!port)\n \t\treturn -EPIPE;\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n }", "target": 1}
{"code": "static inline u32 nfsd4_readdir_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.readdir.rd_maxcount, maxcount);\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz +\n\t\tXDR_QUADLEN(rlen)) * sizeof(__be32);\n}", "target": 0}
{"code": "static int hidp_setup_hid(struct hidp_session *session,\n\t\t\t\tstruct hidp_connadd_req *req)\n{\n\tstruct hid_device *hid;\n\tint err;\n\tsession->rd_data = kzalloc(req->rd_size, GFP_KERNEL);\n\tif (!session->rd_data)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {\n\t\terr = -EFAULT;\n\t\tgoto fault;\n\t}\n\tsession->rd_size = req->rd_size;\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\terr = PTR_ERR(hid);\n\t\tgoto fault;\n\t}\n\tsession->hid = hid;\n\thid->driver_data = session;\n\thid->bus     = BUS_BLUETOOTH;\n\thid->vendor  = req->vendor;\n\thid->product = req->product;\n \thid->version = req->version;\n \thid->country = req->country;\n\tstrncpy(hid->name, req->name, 128);\n \tsnprintf(hid->phys, sizeof(hid->phys), \"%pMR\",\n \t\t &bt_sk(session->ctrl_sock->sk)->src);\n\tsnprintf(hid->uniq, sizeof(hid->uniq), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->dst);\n\thid->dev.parent = &session->conn->dev;\n\thid->ll_driver = &hidp_hid_driver;\n\thid->hid_get_raw_report = hidp_get_raw_report;\n\thid->hid_output_raw_report = hidp_output_raw_report;\n\tif (hid_ignore(hid)) {\n\t\thid_destroy_device(session->hid);\n\t\tsession->hid = NULL;\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\nfault:\n\tkfree(session->rd_data);\n\tsession->rd_data = NULL;\n\treturn err;\n}", "target": 1}
{"code": "int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (!chip)\n\t\treturn -ENODEV;\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&chip->data_pending, 0);\n\tfile->private_data = chip;\n\treturn 0;\n}", "target": 1}
{"code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n \tif (!err && (iattr->ia_valid & ATTR_UID)) {\n \t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n \t}\n \treturn err;\n}", "target": 1}
{"code": "ahcp_time_print(netdissect_options *ndo,\n                const u_char *cp, uint8_t len)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tif (len != 4)\n\t\tgoto invalid;\n\tt = GET_BE_U_4(cp);\n\tif (NULL == (tm = gmtime(&t)))\n\t\tND_PRINT(\": gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\": strftime() error\");\n\telse\n\t\tND_PRINT(\": %s UTC\", buf);\n\treturn;\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}", "target": 1}
{"code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  \n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  \n    lua_assert(var->k != VVOID);  \n    codestring(&key, varname);  \n    luaK_indexed(fs, var, &key);  \n  }\n}", "target": 1}
{"code": "DLLIMPORT int cfg_setnstr(cfg_t *cfg, const char *name, const char *value, unsigned int index)\n{\n\tcfg_opt_t *opt;\n\topt = cfg_getopt(cfg, name);\n\tif (opt && opt->validcb2 && (*opt->validcb2)(cfg, opt, (void *)value) != 0)\n\t\treturn CFG_FAIL;\n\treturn cfg_opt_setnstr(opt, value, index);\n}", "target": 0}
{"code": "static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n \tBT_DBG(\"sock %p, sk %p\", sock, sk);\n \taddr->sa_family = AF_BLUETOOTH;\n \t*len = sizeof(struct sockaddr_l2);\n\tif (peer) {\n\t\tla->l2_psm = chan->psm;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\n\t\tla->l2_cid = cpu_to_le16(chan->dcid);\n\t} else {\n\t\tla->l2_psm = chan->sport;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\n\t\tla->l2_cid = cpu_to_le16(chan->scid);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "YCPBoolean IniAgent::Write(const YCPPath &path, const YCPValue& value, const YCPValue& arg)\n{\n    if (!parser.isStarted())\n    {\n\ty2warning(\"Can't execute Write before being mounted.\");\n\treturn YCPBoolean (false);\n    }\n    bool ok = false; \n    YCPBoolean b (true);\n    if (0 == path->length ())\n    {\n\tif (value->isString() && value->asString()->value() == \"force\")\n\t    parser.inifile.setDirty();\n\telse if (value->isString () && value->asString()->value() == \"clean\")\n\t    parser.inifile.clean ();\n\tif (0 != parser.write ())\n\t    b = false;\n\tok = true;\n    }\n    else\n    {\n\tif (( parser.repeatNames () && value->isList ()) ||\n\t    (!parser.repeatNames () &&  (value->isString () || value->isInteger())) ||\n\t    path->component_str(0) == \"all\"\n\t    )\n\t    {\n\t\tok = true;\n\t\tif (parser.inifile.Write (path, value, parser.HaveRewrites ()))\n\t\t    b = false;\n\t    }\n        else if (value->isVoid ())\n\t    {\n\t\tint wb  = -1;\n\t\tstring del_sec = \"\";\n\t\tok = true;\n\t\tif (2 == path->length ())\n\t\t{\n\t\t    string pc = path->component_str(0);\n\t\t    if (\"s\" == pc || \"section\" == pc)\n\t\t    {\t\n\t\t\tdel_sec = path->component_str (1);\n\t\t\twb = parser.inifile.getSubSectionRewriteBy (del_sec.c_str());\n\t\t    }\n\t\t}\n\t\tif (parser.inifile.Delete (path))\n\t\t    b = false;\n\t\telse if (del_sec != \"\")\n\t\t{\n\t\t    parser.deleted_sections.insert (parser.getFileName (del_sec, wb));\n\t\t}\n\t    }\n\telse\n\t{\n\t    ycp2error (\"Wrong value for path %s: %s\", path->toString ().c_str (), value->toString ().c_str ());\n\t    b = false;\n\t}\n    }\n    if (!ok)\n    {\n    \tycp2error ( \"Wrong path '%s' in Write().\", path->toString().c_str () );\n    }\n    return b;\n}", "target": 1}
{"code": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n \t\t   0x00, 0x00, 0x00, 0x00,\n \t\t   0x00, 0x00 };\n \tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n \tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\treturn 0;\n}", "target": 1}
{"code": "native_handle* Parcel::readNativeHandle() const\n{\n int numFds, numInts;\n status_t err;\n    err = readInt32(&numFds);\n if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n if (err != NO_ERROR) return 0;\n    native_handle* h = native_handle_create(numFds, numInts);\n if (!h) {\n return 0;\n }\n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n        if (h->data[i] < 0) err = BAD_VALUE;\n     }\n     err = read(h->data + numFds, sizeof(int)*numInts);\n     if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n }\n return h;\n}", "target": 1}
{"code": "    long XmpArrayValue::toLong(long n) const\n    {\n        return parseLong(value_[n], ok_);\n    }", "target": 0}
{"code": "static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)\n{\n    CPUState *cs = CPU(cpu);\n     CPUX86State *env = &cpu->env;\n     VAPICHandlers *handlers;\n     uint8_t opcode[2];\n    uint32_t imm32;\n     target_ulong current_pc = 0;\n     target_ulong current_cs_base = 0;\n     uint32_t current_flags = 0;\n    if (smp_cpus == 1) {\n        handlers = &s->rom_state.up;\n    } else {\n        handlers = &s->rom_state.mp;\n    }\n    if (!kvm_enabled()) {\n        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                             &current_flags);\n    }\n    pause_all_vcpus();\n    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);\n    switch (opcode[0]) {\n    case 0x89: \n        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  \n        patch_call(s, cpu, ip + 1, handlers->set_tpr);\n        break;\n    case 0x8b: \n        patch_byte(cpu, ip, 0x90);\n        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);\n        break;\n    case 0xa1: \n        patch_call(s, cpu, ip, handlers->get_tpr[0]);\n        break;\n    case 0xa3: \n        patch_call(s, cpu, ip, handlers->set_tpr_eax);\n        break;\n    case 0xc7: \n        patch_byte(cpu, ip, 0x68);  \n        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);\n        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);\n        patch_call(s, cpu, ip + 5, handlers->set_tpr);\n        break;\n    case 0xff: \n        patch_byte(cpu, ip, 0x50); \n        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);\n        break;\n    default:\n        abort();\n    }\n    resume_all_vcpus();\n    if (!kvm_enabled()) {\n        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);\n        cpu_resume_from_signal(cs, NULL);\n    }\n}", "target": 1}
{"code": "static zend_long firebird_handle_doer(pdo_dbh_t *dbh, const char *sql, size_t sql_len) \n{\n\tpdo_firebird_db_handle *H = (pdo_firebird_db_handle *)dbh->driver_data;\n\tisc_stmt_handle stmt = PDO_FIREBIRD_HANDLE_INITIALIZER;\n\tstatic char const info_count[] = { isc_info_sql_records };\n\tchar result[64];\n\tint ret = 0;\n\tXSQLDA in_sqlda, out_sqlda;\n\tin_sqlda.version = out_sqlda.version = PDO_FB_SQLDA_VERSION;\n\tin_sqlda.sqld = out_sqlda.sqld = 0;\n\tout_sqlda.sqln = 1;\n\tif (!firebird_alloc_prepare_stmt(dbh, sql, sql_len, &out_sqlda, &stmt, 0)) {\n\t\treturn -1;\n\t}\n\tif (isc_dsql_execute2(H->isc_status, &H->tr, &stmt, PDO_FB_SQLDA_VERSION, &in_sqlda, &out_sqlda)) {\n\t\tRECORD_ERROR(dbh);\n\t\tret = -1;\n\t\tgoto free_statement;\n\t}\n\tif (isc_dsql_sql_info(H->isc_status, &stmt, sizeof(info_count), const_cast(info_count),\n\t\t\tsizeof(result),\tresult)) {\n\t\tRECORD_ERROR(dbh);\n\t\tret = -1;\n\t\tgoto free_statement;\n\t}\n\tif (result[0] == isc_info_sql_records) {\n\t\tunsigned i = 3, result_size = isc_vax_integer(&result[1],2);\n\t\twhile (result[i] != isc_info_end && i < result_size) {\n\t\t\tshort len = (short)isc_vax_integer(&result[i+1],2);\n\t\t\tif (result[i] != isc_info_req_select_count) {\n\t\t\t\tret += isc_vax_integer(&result[i+3],len);\n\t\t\t}\n\t\t\ti += len+3;\n\t\t}\n\t}\n\tif (dbh->auto_commit && isc_commit_retaining(H->isc_status, &H->tr)) {\n\t\tRECORD_ERROR(dbh);\n\t}\nfree_statement:\n\tif (isc_dsql_free_statement(H->isc_status, &stmt, DSQL_drop)) {\n\t\tRECORD_ERROR(dbh);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": " void CLASS foveon_load_camf()\n {\n   unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n   fseek (ifp, meta_offset, SEEK_SET);\n   type = get4();  get4();  get4();\n   wide = get4();\n   high = get4();\n   if (type == 2) {\n     fread (meta_data, 1, meta_length, ifp);\n     for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);\n    merror (meta_data, \"foveon_load_camf()\");\n    foveon_huff (huff);\n    get4();\n    getbits(-1);\n    for (j=row=0; row < high; row++) {\n      for (col=0; col < wide; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse         hpred[col & 1] += diff;\n\tif (col & 1) {\n\t  meta_data[j++] = hpred[0] >> 4;\n\t  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n\t  meta_data[j++] = hpred[1];\n        }\n      }\n    }\n  } else\n    fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n}", "target": 1}
{"code": "bool WebContentsImpl::SavePage(const base::FilePath& main_file,\n                               const base::FilePath& dir_path,\n                               SavePageType save_type) {\n  Stop();\n  save_package_ = new SavePackage(this, save_type, main_file, dir_path);\n  return save_package_->Init(SavePackageDownloadCreatedCallback());\n}", "target": 0}
{"code": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}", "target": 1}
{"code": "int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n\tif (sec_attr == NULL) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\treturn 0;\n}", "target": 1}
{"code": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor)\n{\n\tstruct sk_buff *skb;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 seq = tp->copied_seq;\n\tu32 offset;\n\tint copied = 0;\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -ENOTCONN;\n\twhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\n\t\tif (offset < skb->len) {\n\t\t\tint used;\n\t\t\tsize_t len;\n\t\t\tlen = skb->len - offset;\n\t\t\tif (tp->urg_data) {\n\t\t\t\tu32 urg_offset = tp->urg_seq - seq;\n\t\t\t\tif (urg_offset < len)\n\t\t\t\t\tlen = urg_offset;\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused = recv_actor(desc, skb, offset, len);\n\t\t\tif (used < 0) {\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = used;\n\t\t\t\tbreak;\n\t\t\t} else if (used <= len) {\n\t\t\t\tseq += used;\n\t\t\t\tcopied += used;\n\t\t\t\toffset += used;\n\t\t\t}\n\t\t\tskb = tcp_recv_skb(sk, seq-1, &offset);\n\t\t\tif (!skb || (offset+1 != skb->len))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tcp_hdr(skb)->fin) {\n\t\t\tsk_eat_skb(sk, skb, 0);\n\t\t\t++seq;\n\t\t\tbreak;\n\t\t}\n \t\tsk_eat_skb(sk, skb, 0);\n \t\tif (!desc->count)\n \t\t\tbreak;\n \t}\n \ttp->copied_seq = seq;\n\ttcp_rcv_space_adjust(sk);\n\tif (copied > 0)\n\t\ttcp_cleanup_rbuf(sk, copied);\n\treturn copied;\n}", "target": 1}
{"code": "static void btrfs_rm_dev_replace_blocked(struct btrfs_fs_info *fs_info)\n{\n\tset_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\twait_event(fs_info->dev_replace.replace_wait, !percpu_counter_sum(\n\t\t   &fs_info->dev_replace.bio_counter));\n}", "target": 0}
{"code": "void AcceptRoutingHandler<Pipeline, R>::onRoutingData(\n    uint64_t connId,\n    typename RoutingDataHandler<R>::RoutingData& routingData) {\n  auto routingPipelineIter = routingPipelines_.find(connId);\n  if (routingPipelineIter == routingPipelines_.end()) {\n    VLOG(2) << \"Connection has already been closed, \"\n               \"or routed to a worker thread.\";\n    return;\n  }\n  auto routingPipeline = std::move(routingPipelineIter->second);\n  routingPipelines_.erase(routingPipelineIter);\n  auto socket = std::dynamic_pointer_cast<folly::AsyncSocket>(\n      routingPipeline->getTransport());\n  routingPipeline->transportInactive();\n  socket->detachEventBase();\n  uint64_t hash = std::hash<R>()(routingData.routingData);\n  auto acceptor = acceptors_[hash % acceptors_.size()];\n  acceptor->getEventBase()->runInEventBaseThread(\n      [ =, routingData = std::move(routingData) ]() mutable {\n        socket->attachEventBase(acceptor->getEventBase());\n        auto routingHandler =\n            routingPipeline->template getHandler<RoutingDataHandler<R>>();\n        DCHECK(routingHandler);\n        auto transportInfo = routingPipeline->getTransportInfo();\n        auto pipeline = childPipelineFactory_->newPipeline(\n            socket, routingData.routingData, routingHandler, transportInfo);\n        auto connection =\n            new typename ServerAcceptor<Pipeline>::ServerConnection(pipeline);\n        acceptor->addConnection(connection);\n        pipeline->transportActive();\n        pipeline->read(routingData.bufQueue);\n      });\n}", "target": 1}
{"code": "static void mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen) {\n    s32 op = 0, ip = 0;\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n    for (s32 i = 0; i < 32; ++i) {\n        c = in[ip++];\n        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;\n    }\n    while (op < outlen) {\n        c = in[ip++];\n        if (t[c]) {\n            for (run = 0; (pc = in[ip++]) == 255; run += 255)\n                ;\n            run += pc + 1;\n            for (; run > 0 && op < outlen; --run) out[op++] = c;\n        } else\n            out[op++] = c;\n    }\n}", "target": 1}
{"code": "void luaD_call (lua_State *L, StkId func, int nresults) {\n  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  \n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  \n      CallInfo *ci = next_ci(L);\n      checkstackp(L, LUA_MINSTACK, func);  \n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      L->ci = ci;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  \n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  \n      CallInfo *ci = next_ci(L);\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  \n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  \n      checkstackp(L, fsize, func);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  \n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  \n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  \n      break;\n    }\n    default: {  \n      checkstackp(L, 1, func);  \n      luaD_tryfuncTM(L, func);  \n      goto retry;  \n    }\n  }\n}", "target": 1}
{"code": "static StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n  ptrdiff_t oldtop = savestack(L, L->top);  \n  int delta = 0;\n  if (isLuacode(ci)) {\n    Proto *p = clLvalue(s2v(ci->func))->p;\n    if (p->is_vararg)\n      delta = ci->u.l.nextraargs + p->numparams + 1;\n    if (L->top < ci->top)\n      L->top = ci->top;  \n  }\n  if (L->hookmask & LUA_MASKRET) {  \n    int ftransfer;\n    ci->func += delta;  \n    ftransfer = cast(unsigned short, firstres - ci->func);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  \n    ci->func -= delta;\n  }\n  if (isLua(ci->previous))\n    L->oldpc = ci->previous->u.l.savedpc;  \n  return restorestack(L, oldtop);\n}", "target": 1}
{"code": "repodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n  if (!*schema)\n    return 0;\t\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}", "target": 1}
{"code": "epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}", "target": 1}
{"code": "get_val_across_arith_op (enum tree_code opcode,\n\t\t\t tree opnd1_type,\n\t\t\t tree opnd2,\n\t\t\t ipcp_value<tree> *src_val,\n\t\t\t tree res_type)\n{\n  tree opnd1 = src_val->value;\n  if (opnd1_type\n      && !useless_type_conversion_p (opnd1_type, TREE_TYPE (opnd1)))\n    return NULL_TREE;\n  return ipa_get_jf_arith_result (opcode, opnd1, opnd2, res_type);\n}", "target": 0}
{"code": "static void __unix_remove_socket(struct sock *sk)\n{\n\tsk_del_node_init(sk);\n}", "target": 0}
{"code": "  bool ignore_out_of_memory() {\n    return thread_local_top_.ignore_out_of_memory_;\n  }", "target": 0}
{"code": "void * pvPortMalloc( size_t xWantedSize )\n{\n    void * pvReturn = NULL;\n    static uint8_t * pucAlignedHeap = NULL;\n    #if ( portBYTE_ALIGNMENT != 1 )\n        {\n            if( xWantedSize & portBYTE_ALIGNMENT_MASK )\n            {\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n            }\n        }\n    #endif\n    vTaskSuspendAll();\n    {\n        if( pucAlignedHeap == NULL )\n        {\n            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\n        }\n        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\n            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) \n        {\n            pvReturn = pucAlignedHeap + xNextFreeByte;\n            xNextFreeByte += xWantedSize;\n        }\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n    return pvReturn;\n}", "target": 1}
{"code": "static Token *make_tok_num(Token *next, int64_t val)\n{\n    char numbuf[32];\n    int len = snprintf(numbuf, sizeof(numbuf), \"%\"PRId64\"\", val);\n    return new_Token(next, TOK_NUMBER, numbuf, len);\n}", "target": 0}
{"code": "void WavOutFile::write(const float *buffer, int numElems)\n{\n    int numBytes;\n    int bytesPerSample;\n    if (numElems == 0) return;\n    bytesPerSample = header.format.bits_per_sample / 8;\n    numBytes = numElems * bytesPerSample;\n    short *temp = (short*)getConvBuffer(numBytes);\n    switch (bytesPerSample)\n    {\n        case 1:\n        {\n            unsigned char *temp2 = (unsigned char *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                temp2[i] = (unsigned char)saturate(buffer[i] * 128.0f + 128.0f, 0.0f, 255.0f);\n            }\n            break;\n        }\n        case 2:\n        {\n            short *temp2 = (short *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                short value = (short)saturate(buffer[i] * 32768.0f, -32768.0f, 32767.0f);\n                temp2[i] = _swap16(value);\n            }\n            break;\n        }\n        case 3:\n        {\n            char *temp2 = (char *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                int value = saturate(buffer[i] * 8388608.0f, -8388608.0f, 8388607.0f);\n                *((int*)temp2) = _swap32(value);\n                temp2 += 3;\n            }\n            break;\n        }\n        case 4:\n        {\n            int *temp2 = (int *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                int value = saturate(buffer[i] * 2147483648.0f, -2147483648.0f, 2147483647.0f);\n                temp2[i] = _swap32(value);\n            }\n            break;\n        }\n        default:\n            assert(false);\n    }\n    int res = (int)fwrite(temp, 1, numBytes, fptr);\n    if (res != numBytes) \n    {\n        ST_THROW_RT_ERROR(\"Error while writing to a wav file.\");\n    }\n    bytesWritten += numBytes;\n}", "target": 1}
{"code": "int ldb_handler_fold(struct ldb_context *ldb, void *mem_ctx,\n\t\t\t    const struct ldb_val *in, struct ldb_val *out)\n{\n\tchar *s, *t;\n\tsize_t l;\n\tif (!in || !out || !(in->data)) {\n\t\treturn -1;\n\t}\n\tout->data = (uint8_t *)ldb_casefold(ldb, mem_ctx, (const char *)(in->data), in->length);\n\tif (out->data == NULL) {\n\t\tldb_debug(ldb, LDB_DEBUG_ERROR, \"ldb_handler_fold: unable to casefold string [%.*s]\", (int)in->length, (const char *)in->data);\n\t\treturn -1;\n\t}\n\ts = (char *)(out->data);\n\tl = strlen(s);\n\twhile (l > 0 && s[l - 1] == ' ') l--;\n\ts[l] = '\\0';\n\tif (*s == ' ') {\n\t\tfor (t = s; *s == ' '; s++) ;\n\t\tmemmove(t, s, l);\n\t\ts = t;\n\t}\n\twhile ((t = strchr(s, ' ')) != NULL) {\n\t\tfor (s = t; *s == ' '; s++) ;\n\t\tif ((s - t) > 1) {\n\t\t\tl = strlen(s);\n\t\t\tmemmove(t + 1, s, l);\n\t\t}\n\t}\n\tout->length = strlen((char *)out->data);\n\treturn 0;\n}", "target": 1}
{"code": "bool Item_ref::get_date(MYSQL_TIME *ltime,ulonglong fuzzydate)\n{\n  return (null_value=(*ref)->get_date_result(ltime,fuzzydate));\n}", "target": 0}
{"code": "static size_t php_pgsql_fd_read(php_stream *stream, char *buf, size_t count) \n{\n\treturn 0;\n}", "target": 0}
{"code": "void Shell::OnRootWindowAdded(aura::Window* root_window) {\n  FOR_EACH_OBSERVER(ShellObserver, observers_, OnRootWindowAdded(root_window));\n}", "target": 0}
{"code": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n     size_t noff, size_t doff, int *flags)\n {\n \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz == 16 || descsz == 20)) {\n \t\tuint8_t desc[20];\n \t\tuint32_t i;\n \t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tif (file_printf(ms, \", BuildID[%s]=\", descsz == 16 ? \"md5/uuid\" :\n\t\t    \"sha1\") == -1)\n \t\t\treturn 1;\n \t\t(void)memcpy(desc, &nbuf[doff], descsz);\n \t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err gf_filter_post_task(GF_Filter *filter, Bool (*task_execute) (GF_Filter *filter, void *callback, u32 *reschedule_ms), void *udta, const char *task_name)\n{\n\tGF_UserTask *utask;\n\tif (!filter || !task_execute) return GF_BAD_PARAM;\n\tGF_SAFEALLOC(utask, GF_UserTask);\n\tif (!utask) return GF_OUT_OF_MEM;\n\tutask->callback = udta;\n\tutask->task_execute_filter = task_execute;\n\tutask->fsess = filter->session;\n\tgf_fs_post_task(filter->session, gf_fs_user_task, filter, NULL, task_name ? task_name : \"user_task\", utask);\n\treturn GF_OK;\n}", "target": 0}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "static inline void skb_reset_inner_headers(struct sk_buff *skb)\n{\n\tskb->inner_mac_header = skb->mac_header;\n\tskb->inner_network_header = skb->network_header;\n\tskb->inner_transport_header = skb->transport_header;\n}", "target": 0}
{"code": "static int mxf_match_uid(const UID key, const UID uid, int len)\n{\n    int i;\n    for (i = 0; i < len; i++) {\n        if (i != 7 && key[i] != uid[i])\n            return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "    StringValue::StringValue(const std::string& buf)\n        : StringValueBase(string, buf)\n    {\n    }", "target": 0}
{"code": "static int tga_readheader(FILE *fp, unsigned int *bits_per_pixel,\n                          unsigned int *width, unsigned int *height, int *flip_image)\n{\n    int palette_size;\n    unsigned char tga[TGA_HEADER_SIZE];\n    unsigned char id_len,  image_type;\n    unsigned char pixel_depth, image_desc;\n    unsigned short  cmap_len, cmap_entry_size;\n    unsigned short  image_w, image_h;\n    if (!bits_per_pixel || !width || !height || !flip_image) {\n        return 0;\n    }\n    if (fread(tga, TGA_HEADER_SIZE, 1, fp) != 1) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0 ;\n    }\n    id_len = tga[0];\n    image_type = tga[2];\n    cmap_len = get_ushort(&tga[5]);\n    cmap_entry_size = tga[7];\n#if 0\n    x_origin = get_ushort(&tga[8]);\n    y_origin = get_ushort(&tga[10]);\n#endif\n    image_w = get_ushort(&tga[12]);\n    image_h = get_ushort(&tga[14]);\n    pixel_depth = tga[16];\n    image_desc  = tga[17];\n    *bits_per_pixel = (unsigned int)pixel_depth;\n    *width  = (unsigned int)image_w;\n    *height = (unsigned int)image_h;\n    if (id_len) {\n        unsigned char *id = (unsigned char *) malloc(id_len);\n        if (id == 0) {\n            fprintf(stderr, \"tga_readheader: memory out\\n\");\n            return 0;\n        }\n        if (!fread(id, id_len, 1, fp)) {\n            fprintf(stderr,\n                    \"\\nError: fread return a number of element different from the expected.\\n\");\n            free(id);\n            return 0 ;\n        }\n        free(id);\n    }\n    if (image_type > 8) {\n        fprintf(stderr, \"Sorry, compressed tga files are not currently supported.\\n\");\n        return 0 ;\n    }\n    *flip_image = !(image_desc & 32);\n    palette_size = cmap_len * (cmap_entry_size / 8);\n    if (palette_size > 0) {\n        fprintf(stderr, \"File contains a palette - not yet supported.\");\n        fseek(fp, palette_size, SEEK_CUR);\n    }\n    return 1;\n}", "target": 1}
{"code": "static UINT ExtractRunLengthRegularFgBg(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\trunLength = (*pbOrderHdr) & g_MaskRegularRunLength;\n\tif (runLength == 0)\n\t{\n\t\tif (!buffer_within_range(pbOrderHdr, 1, pbEnd))\n\t\t{\n\t\t\t*advance = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trunLength = *(pbOrderHdr + 1) + 1;\n\t\t(*advance)++;\n\t}\n\telse\n\t\trunLength = runLength * 8;\n\treturn runLength;\n}", "target": 1}
{"code": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n {\n \tstruct compat_timex tx32;\n \tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n \t\treturn -EFAULT;\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err gf_isom_get_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char **outName)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !outName) return GF_BAD_PARAM;\n\t*outName = trak->Media->handler->nameUTF8;\n\treturn GF_OK;\n}", "target": 0}
{"code": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n     int length;\n     length = strlen (filename);\n    if (length > 0)\n     {\n         if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n             return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}", "target": 1}
{"code": "void UpdateWebTouchEventAfterDispatch(blink::WebTouchEvent* event,\n                                      blink::WebTouchPoint* point) {\n  if (point->state != blink::WebTouchPoint::StateReleased &&\n      point->state != blink::WebTouchPoint::StateCancelled)\n    return;\n  --event->touchesLength;\n  for (unsigned i = point - event->touches;\n       i < event->touchesLength;\n       ++i) {\n    event->touches[i] = event->touches[i + 1];\n  }\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoTexParameterfv(\n    GLenum target, GLenum pname, const GLfloat* params) {\n  TextureManager::TextureInfo* info = GetTextureInfoForTarget(target);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glTexParameterfv: unknown texture\");\n    return;\n  }\n  if (!texture_manager()->SetParameter(\n      info, pname, static_cast<GLint>(params[0]))) {\n    SetGLError(GL_INVALID_ENUM, \"glTexParameterfv: param GL_INVALID_ENUM\");\n    return;\n  }\n  glTexParameterfv(target, pname, params);\n}", "target": 0}
{"code": "static inline void pmd_populate(struct mm_struct *mm,\n\t\t\t\tpmd_t *pmd, pgtable_t pte)\n{\n\tpmd_val(*pmd) = _SEGMENT_ENTRY + __pa(pte);\n}", "target": 0}
{"code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}", "target": 1}
{"code": "void RenderThreadImpl::Shutdown() {\n  FOR_EACH_OBSERVER(\n      RenderProcessObserver, observers_, OnRenderProcessShutdown());\n  ChildThread::Shutdown();\n  if (memory_observer_) {\n    message_loop()->RemoveTaskObserver(memory_observer_.get());\n    memory_observer_.reset();\n  }\n  if (webkit_platform_support_) {\n    WebView::willEnterModalLoop();\n    webkit_platform_support_->web_database_observer_impl()->\n        WaitForAllDatabasesToClose();\n    WebView::didExitModalLoop();\n  }\n  if (devtools_agent_message_filter_.get()) {\n    RemoveFilter(devtools_agent_message_filter_.get());\n    devtools_agent_message_filter_ = NULL;\n  }\n  RemoveFilter(audio_input_message_filter_.get());\n  audio_input_message_filter_ = NULL;\n#if defined(ENABLE_WEBRTC)\n  RTCPeerConnectionHandler::DestructAllHandlers();\n  peer_connection_factory_.reset();\n#endif\n  RemoveFilter(vc_manager_->video_capture_message_filter());\n  vc_manager_.reset();\n  RemoveFilter(db_message_filter_.get());\n  db_message_filter_ = NULL;\n  if (file_thread_)\n    file_thread_->Stop();\n  if (compositor_output_surface_filter_.get()) {\n    RemoveFilter(compositor_output_surface_filter_.get());\n    compositor_output_surface_filter_ = NULL;\n  }\n  media_thread_.reset();\n  RemoveFilter(audio_message_filter_.get());\n  audio_message_filter_ = NULL;\n  compositor_thread_.reset();\n  input_handler_manager_.reset();\n  if (input_event_filter_.get()) {\n    RemoveFilter(input_event_filter_.get());\n    input_event_filter_ = NULL;\n  }\n  embedded_worker_dispatcher_.reset();\n  main_thread_indexed_db_dispatcher_.reset();\n  main_thread_compositor_task_runner_ = NULL;\n  main_message_loop_.reset();\n  if (webkit_platform_support_)\n    blink::shutdown();\n  lazy_tls.Pointer()->Set(NULL);\n#if defined(OS_WIN)\n  NPChannelBase::CleanupChannels();\n#endif\n}", "target": 0}
{"code": "void HTMLMediaElement::SelectMediaResource() {\n  BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this << \")\";\n  enum Mode { kObject, kAttribute, kChildren, kNothing };\n  Mode mode = kNothing;\n  if (src_object_) {\n    mode = kObject;\n  } else if (FastHasAttribute(kSrcAttr)) {\n    mode = kAttribute;\n  } else if (HTMLSourceElement* element =\n                 Traversal<HTMLSourceElement>::FirstChild(*this)) {\n    mode = kChildren;\n    next_child_node_to_consider_ = element;\n    current_source_node_ = nullptr;\n  } else {\n    load_state_ = kWaitingForSource;\n    SetShouldDelayLoadEvent(false);\n    if (!GetWebMediaPlayer() || (ready_state_ < kHaveFutureData &&\n                                 ready_state_maximum_ < kHaveFutureData)) {\n      SetNetworkState(kNetworkEmpty);\n    } else {\n      UseCounter::Count(GetDocument(),\n                        WebFeature::kHTMLMediaElementEmptyLoadWithFutureData);\n    }\n    UpdateDisplayState();\n    BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                    << \"), nothing to load\";\n    return;\n  }\n  SetNetworkState(kNetworkLoading);\n  ScheduleEvent(event_type_names::kLoadstart);\n  switch (mode) {\n    case kObject:\n      LoadSourceFromObject();\n      BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                      << \", using 'srcObject' attribute\";\n      break;\n    case kAttribute:\n      LoadSourceFromAttribute();\n      BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                      << \"), using 'src' attribute url\";\n      break;\n    case kChildren:\n      LoadNextSourceChild();\n      BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                      << \"), using source element\";\n      break;\n    default:\n      NOTREACHED();\n  }\n}", "target": 0}
{"code": "Eina_Bool ewk_view_reload(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_reload(smartData->main_frame);\n}", "target": 0}
{"code": "static void hardware_disable_all_nolock(void)\n{\n\tBUG_ON(!kvm_usage_count);\n\tkvm_usage_count--;\n\tif (!kvm_usage_count)\n\t\ton_each_cpu(hardware_disable_nolock, NULL, 1);\n}", "target": 0}
{"code": "bool bnx2x_port_after_undi(struct bnx2x *bp)\n{\n\tstruct bnx2x_prev_path_list *entry;\n\tbool val;\n\tdown(&bnx2x_prev_sem);\n\tentry = bnx2x_prev_path_get_entry(bp);\n\tval = !!(entry && (entry->undi & (1 << BP_PORT(bp))));\n\tup(&bnx2x_prev_sem);\n\treturn val;\n}", "target": 0}
{"code": "void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev,\n    uint32_t max_frags, bool has_virt_hdr)\n{\n    struct NetTxPkt *p = g_malloc0(sizeof *p);\n     p->pci_dev = pci_dev;\n    p->vec = g_malloc((sizeof *p->vec) *\n        (max_frags + NET_TX_PKT_PL_START_FRAG));\n    p->raw = g_malloc((sizeof *p->raw) * max_frags);\n     p->max_payload_frags = max_frags;\n     p->max_raw_frags = max_frags;\n    p->max_raw_frags = max_frags;\n    p->has_virt_hdr = has_virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_len =\n        p->has_virt_hdr ? sizeof p->virt_hdr : 0;\n    p->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;\n    p->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr;\n    *pkt = p;\n}", "target": 1}
{"code": "user_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member *m)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name,\n\t\tdef_netgroup_tuple ? lhost : NULL,\n\t\tdef_netgroup_tuple ? shost : NULL, pw->pw_name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase USERGROUP:\n\t    if (usergr_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {\n\t\tconst int rc = userlist_matches(parse_tree, pw, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (userpw_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\tINFO(\"Mounting container /dev\");\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn false;\n\t}\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "static boolean jpeg_empty_output_buffer(j_compress_ptr cinfo)\n{\n    VncState *vs = cinfo->client_data;\n    Buffer *buffer = &vs->tight->jpeg;\n    buffer->offset = buffer->capacity;\n    buffer_reserve(buffer, 2048);\n    jpeg_init_destination(cinfo);\n    return TRUE;\n}", "target": 0}
{"code": "struct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\tpr_debug(\"No device found\\n\");\n\treturn NULL;\n}", "target": 1}
{"code": "void out_string(conn *c, const char *str) {\n    size_t len;\n    mc_resp *resp = c->resp;\n    assert(c != NULL);\n    resp_reset(resp);\n    if (c->noreply) {\n        resp->skip = true;\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n    len = strlen(str);\n    if ((len + 2) > WRITE_BUFFER_SIZE) {\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n    memcpy(resp->wbuf, str, len);\n    memcpy(resp->wbuf + len, \"\\r\\n\", 2);\n    resp_add_iov(resp, resp->wbuf, len + 2);\n    conn_set_state(c, conn_new_cmd);\n    return;\n}", "target": 1}
{"code": "static void zep_print_ts(netdissect_options *ndo, const u_char *p)\n{\n\tint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tfloat ff;\n\ti = GET_BE_U_4(p);\n\tuf = GET_BE_U_4(p + 4);\n\tff = (float) uf;\n\tif (ff < 0.0)           \n\t\tff += FMAXINT;\n\tff = (float) (ff / FMAXINT); \n\tf = (uint32_t) (ff * 1000000000.0);  \n\tND_PRINT(\"%u.%09d\", i, f);\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tstruct tm *tm;\n\t\tchar time_buf[128];\n\t\ttm = localtime(&seconds);\n\t\tstrftime(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\", tm);\n\t\tND_PRINT(\" (%s)\", time_buf);\n\t}\n}", "target": 1}
{"code": "void msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}", "target": 1}
{"code": "test_unit_v2v_iter2(VALUE (* conv1)(VALUE),\n\t\t    VALUE (* conv2)(VALUE))\n{\n    if (!test_unit_v2v(INT2FIX(0), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(1), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(2), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(3), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(11), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(65535), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2FIX(1073741823), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(INT2NUM(1073741824), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(rb_rational_new2(INT2FIX(0), INT2FIX(1)), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(rb_rational_new2(INT2FIX(1), INT2FIX(1)), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(rb_rational_new2(INT2FIX(1), INT2FIX(2)), conv1, conv2))\n\treturn 0;\n    if (!test_unit_v2v(rb_rational_new2(INT2FIX(2), INT2FIX(3)), conv1, conv2))\n\treturn 0;\n    return 1;\n}", "target": 0}
{"code": "int cfg80211_mgd_wext_giwessid(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\tdata->flags = 0;\n\twdev_lock(wdev);\n\tif (wdev->current_bss) {\n\t\tconst u8 *ie;\n\t\trcu_read_lock();\n\t\tie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t  WLAN_EID_SSID);\n\t\tif (ie) {\n\t\t\tdata->flags = 1;\n\t\t\tdata->length = ie[1];\n\t\t\tmemcpy(ssid, ie + 2, data->length);\n\t\t}\n\t\trcu_read_unlock();\n\t} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->wext.connect.ssid_len;\n\t\tmemcpy(ssid, wdev->wext.connect.ssid, data->length);\n\t}\n\twdev_unlock(wdev);\n\treturn 0;\n}", "target": 1}
{"code": "static int int_ptr_type_to_size(enum bpf_arg_type type)\n{\n\tif (type == ARG_PTR_TO_INT)\n\t\treturn sizeof(u32);\n\telse if (type == ARG_PTR_TO_LONG)\n\t\treturn sizeof(u64);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "void Browser::ScheduleUIUpdate(WebContents* source,\n                               unsigned changed_flags) {\n  DCHECK(source);\n  int index = tab_strip_model_->GetIndexOfWebContents(source);\n  DCHECK_NE(TabStripModel::kNoTab, index);\n  tracked_objects::ScopedTracker tracking_profile1(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"466285 Browser::ScheduleUIUpdate::Toolbar\"));\n  if (changed_flags & content::INVALIDATE_TYPE_URL) {\n    if (source == tab_strip_model_->GetActiveWebContents()) {\n      UpdateToolbar(false);\n    } else {\n      window_->ResetToolbarTabState(source);\n    }\n    changed_flags &= ~content::INVALIDATE_TYPE_URL;\n  }\n  tracked_objects::ScopedTracker tracking_profile2(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"466285 Browser::ScheduleUIUpdate::TabStripModel\"));\n  if (changed_flags & content::INVALIDATE_TYPE_LOAD) {\n    tab_strip_model_->UpdateWebContentsStateAt(\n        tab_strip_model_->GetIndexOfWebContents(source),\n        TabStripModelObserver::LOADING_ONLY);\n  }\n  if (changed_flags & content::INVALIDATE_TYPE_TITLE && !source->IsLoading()) {\n    tab_strip_model_->UpdateWebContentsStateAt(\n        tab_strip_model_->GetIndexOfWebContents(source),\n        TabStripModelObserver::TITLE_NOT_LOADING);\n  }\n  if (changed_flags == 0)\n    return;\n  scheduled_updates_[source] |= changed_flags;\n  if (!chrome_updater_factory_.HasWeakPtrs()) {\n    base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(\n        FROM_HERE, base::Bind(&Browser::ProcessPendingUIUpdates,\n                              chrome_updater_factory_.GetWeakPtr()),\n        base::TimeDelta::FromMilliseconds(kUIUpdateCoalescingTimeMS));\n  }\n}", "target": 0}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n \tcase MSR_MTRRdefType:\n \tcase MSR_IA32_CR_PAT:\n \t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n \t}\n \treturn false;\n }", "target": 1}
{"code": "void header_time(int stat, char *str, char *more)\n{\n  char buf[64];\n  xprintf(\"HTTP/1.1 %d %s\\r\\nServer: toybox httpd/%s\\r\\nDate: %s\\r\\n%s\"\n    \"Connection: close\\r\\n\\r\\n\", stat, str, TOYBOX_VERSION,\n    rfc1123(buf, time(0)), more ? : \"\");\n}", "target": 0}
{"code": "void ipmi_unregister_smi(struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_watcher *w;\n\tint intf_num = intf->intf_num, index;\n\tmutex_lock(&ipmi_interfaces_mutex);\n\tintf->intf_num = -1;\n\tintf->in_shutdown = true;\n\tlist_del_rcu(&intf->link);\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\tsynchronize_srcu(&ipmi_interfaces_srcu);\n\tmutex_lock(&smi_watchers_mutex);\n\tlist_for_each_entry(w, &smi_watchers, link)\n\t\tw->smi_gone(intf_num);\n\tmutex_unlock(&smi_watchers_mutex);\n\tindex = srcu_read_lock(&intf->users_srcu);\n\twhile (!list_empty(&intf->users)) {\n\t\tstruct ipmi_user *user =\n\t\t\tcontainer_of(list_next_rcu(&intf->users),\n\t\t\t\t     struct ipmi_user, link);\n\t\t_ipmi_destroy_user(user);\n\t}\n\tsrcu_read_unlock(&intf->users_srcu, index);\n\tif (intf->handlers->shutdown)\n\t\tintf->handlers->shutdown(intf->send_info);\n\tcleanup_smi_msgs(intf);\n\tipmi_bmc_unregister(intf);\n\tcleanup_srcu_struct(&intf->users_srcu);\n\tkref_put(&intf->refcount, intf_free);\n}", "target": 0}
{"code": "static struct ast_sip_endpoint *ip_identify(pjsip_rx_data *rdata)\n{\n\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n\tast_sockaddr_parse(&addr_with_tp.addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);\n\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->pkt_info.src_port);\n\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n}", "target": 1}
{"code": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}", "target": 1}
{"code": "*vidtv_s302m_encoder_init(struct vidtv_s302m_encoder_init_args args)\n{\n\tu32 priv_sz = sizeof(struct vidtv_s302m_ctx);\n\tstruct vidtv_s302m_ctx *ctx;\n\tstruct vidtv_encoder *e;\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\treturn NULL;\n\te->id = S302M;\n\tif (args.name)\n\t\te->name = kstrdup(args.name, GFP_KERNEL);\n\te->encoder_buf = vzalloc(VIDTV_S302M_BUF_SZ);\n\te->encoder_buf_sz = VIDTV_S302M_BUF_SZ;\n\te->encoder_buf_offset = 0;\n\te->sample_count = 0;\n\te->src_buf = (args.src_buf) ? args.src_buf : NULL;\n\te->src_buf_sz = (args.src_buf) ? args.src_buf_sz : 0;\n\te->src_buf_offset = 0;\n\te->is_video_encoder = false;\n\tctx = kzalloc(priv_sz, GFP_KERNEL);\n\tif (!ctx) {\n\t\tkfree(e);\n\t\treturn NULL;\n\t}\n\te->ctx = ctx;\n\tctx->last_duration = 0;\n\te->encode = vidtv_s302m_encode;\n\te->clear = vidtv_s302m_clear;\n\te->es_pid = cpu_to_be16(args.es_pid);\n\te->stream_id = cpu_to_be16(PES_PRIVATE_STREAM_1);\n\te->sync = args.sync;\n\te->sampling_rate_hz = S302M_SAMPLING_RATE_HZ;\n\te->last_sample_cb = args.last_sample_cb;\n\te->destroy = vidtv_s302m_encoder_destroy;\n\tif (args.head) {\n\t\twhile (args.head->next)\n\t\t\targs.head = args.head->next;\n\t\targs.head->next = e;\n\t}\n\te->next = NULL;\n\treturn e;\n}", "target": 1}
{"code": "offline_isolated_pages_cb(unsigned long start, unsigned long nr_pages,\n\t\t\tvoid *data)\n{\n\t__offline_isolated_pages(start, start + nr_pages);\n\treturn 0;\n}", "target": 0}
{"code": "static GF_Err gf_isom_svc_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool is_mvc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (is_mvc && entry->mvc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->mvc_config);\n\t\tentry->mvc_config = NULL;\n\t}\n\telse if (!is_mvc && entry->svc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->svc_config);\n\t\tentry->svc_config = NULL;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}", "target": 0}
{"code": "    uint32_t TiffBinaryElement::doWrite(IoWrapper& ioWrapper,\n                                        ByteOrder byteOrder,\n                                        int32_t   ,\n                                        uint32_t  ,\n                                        uint32_t  ,\n                                        uint32_t& )\n    {\n        Value const* pv = pValue();\n        if (!pv || pv->count() == 0) return 0;\n        DataBuf buf(pv->size());\n        pv->copy(buf.pData_, byteOrder);\n        ioWrapper.write(buf.pData_, buf.size_);\n        return (uint32_t)buf.size_;\n    } ", "target": 0}
{"code": "unsigned LibRaw::get4()\n{\n  uchar str[4] = {0xff, 0xff, 0xff, 0xff};\n  fread(str, 1, 4, ifp);\n  return sget4(str);\n}", "target": 0}
{"code": " static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n {\n \tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n \tstruct nat_entry *ne;\n\tint err;\n \tif (unlikely(nid == 0))\n \t\treturn false;\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n \ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n \ti->nid = nid;\n \ti->state = NID_NEW;\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n \tspin_lock(&nm_i->nid_list_lock);\n \terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n \tspin_unlock(&nm_i->nid_list_lock);\n \tradix_tree_preload_end();\n\tif (err) {\n \t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n }", "target": 1}
{"code": "bool AccessibilityUIElement::attributedStringRangeIsMisspelled(unsigned location, unsigned length)\n{\n    return false;\n}", "target": 0}
{"code": " int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n {\n \tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\tif (!domain)\n\t\treturn 0;\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n \t\tif (r) {\n \t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n \t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n \t\t\tgoto unmap_pages;\n \t\t}\n\t\tgfn += page_size >> PAGE_SHIFT;\n\t}\n \treturn 0;\n unmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn);\n \treturn r;\n }", "target": 1}
{"code": "char *QuotedString::extractFrom(char *input, char **endPtr) {\n  char firstChar = *input;\n  if (!isQuote(firstChar)) {\n    return NULL;\n  }\n  char stopChar = firstChar;  \n  char *startPtr = input + 1;  \n  char *readPtr = startPtr;\n  char *writePtr = startPtr;\n  char c;\n  for (;;) {\n    c = *readPtr++;\n    if (c == '\\0') {\n      return NULL;\n    }\n    if (c == stopChar) {\n      break;\n    }\n    if (c == '\\\\') {\n      c = unescapeChar(*readPtr++);\n    }\n    *writePtr++ = c;\n  }\n  *writePtr = '\\0';\n  *endPtr = readPtr;\n  return startPtr;\n}", "target": 1}
{"code": "int parse_submodule_config_option(const char *var, const char *value)\n{\n\treturn submodule_config_option(the_repository, var, value);\n}", "target": 0}
{"code": "    Jp2Image::Jp2Image(BasicIo::UniquePtr io, bool create)\n            : Image(ImageType::jp2, mdExif | mdIptc | mdXmp, std::move(io))\n    {\n        if (create)\n        {\n            if (io_->open() == 0)\n            {\n#ifdef DEBUG\n                std::cerr << \"Exiv2::Jp2Image:: Creating JPEG2000 image to memory\" << std::endl;\n#endif\n                IoCloser closer(*io_);\n                if (io_->write(Jp2Blank, sizeof(Jp2Blank)) != sizeof(Jp2Blank))\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::Jp2Image:: Failed to create JPEG2000 image on memory\" << std::endl;\n#endif\n                }\n            }\n        }\n    } ", "target": 0}
{"code": "ppm_load_read_header(FILE       *fp,\n                     pnm_struct *img)\n{\n    gchar *ptr;\n    gchar  header[MAX_CHARS_IN_ROW];\n    gint   maxval;\n    int    channel_count;\n    if (fgets (header, MAX_CHARS_IN_ROW, fp) == NULL ||\n        header[0] != ASCII_P ||\n        (header[1] != PIXMAP_ASCII_GRAY &&\n         header[1] != PIXMAP_ASCII &&\n         header[1] != PIXMAP_RAW_GRAY &&\n         header[1] != PIXMAP_RAW))\n      {\n        g_warning (\"Image is not a portable pixmap\");\n        return FALSE;\n      }\n    img->type = header[1];\n    if (img->type == PIXMAP_RAW_GRAY || img->type == PIXMAP_ASCII_GRAY)\n      channel_count = CHANNEL_COUNT_GRAY;\n    else\n      channel_count = CHANNEL_COUNT;\n    while((fgets (header, MAX_CHARS_IN_ROW, fp)) && (header[0] == '#'))\n      ;\n    errno = 0;\n    img->width = strtol (header, &ptr, 10);\n    if (errno)\n      {\n        g_warning (\"Error reading width: %s\", strerror(errno));\n        return FALSE;\n      }\n    else if (img->width < 0)\n      {\n        g_warning (\"Error: width is negative\");\n        return FALSE;\n      }\n    img->height = strtol (ptr, &ptr, 10);\n    if (errno)\n      {\n        g_warning (\"Error reading height: %s\", strerror(errno));\n        return FALSE;\n      }\n    else if (img->width < 0)\n      {\n        g_warning (\"Error: height is negative\");\n        return FALSE;\n      }\n    if (fgets (header, MAX_CHARS_IN_ROW, fp))\n      maxval = strtol (header, &ptr, 10);\n    else\n      maxval = 0;\n    if ((maxval != 255) && (maxval != 65535))\n      {\n        g_warning (\"Image is not an 8-bit or 16-bit portable pixmap\");\n        return FALSE;\n      }\n  switch (maxval)\n    {\n    case 255:\n      img->bpc = sizeof (guchar);\n      break;\n    case 65535:\n      img->bpc = sizeof (gushort);\n      break;\n    default:\n      g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n    }\n    if (!img->width || !img->height ||\n        G_MAXSIZE / img->width / img->height / CHANNEL_COUNT < img->bpc)\n      {\n        g_warning (\"Illegal width/height: %ld/%ld\", img->width, img->height);\n        return FALSE;\n      }\n    img->channels = channel_count;\n    img->numsamples = img->width * img->height * channel_count;\n    return TRUE;\n}", "target": 1}
{"code": "FrameLoader::FrameLoader(Frame* frame, FrameLoaderClient* client)\n    : m_frame(frame)\n    , m_client(client)\n    , m_history(frame)\n    , m_notifer(frame)\n    , m_icon(adoptPtr(new IconController(frame)))\n    , m_mixedContentChecker(frame)\n    , m_state(FrameStateProvisional)\n    , m_loadType(FrameLoadTypeStandard)\n    , m_inStopAllLoaders(false)\n    , m_isComplete(false)\n    , m_containsPlugins(false)\n    , m_checkTimer(this, &FrameLoader::checkTimerFired)\n    , m_shouldCallCheckCompleted(false)\n    , m_opener(0)\n    , m_didAccessInitialDocument(false)\n    , m_didAccessInitialDocumentTimer(this, &FrameLoader::didAccessInitialDocumentTimerFired)\n    , m_suppressOpenerInNewFrame(false)\n    , m_startingClientRedirect(false)\n    , m_forcedSandboxFlags(SandboxNone)\n{\n}", "target": 0}
{"code": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n \tif (old_len > vma->vm_end - addr)\n \t\tgoto Efault;\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n\t\tif (new_len > old_len)\n \t\t\tgoto Efault;\n \t}\n \tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\treturn vma;\nEfault:\t\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}", "target": 1}
{"code": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                            const uint8_t *name, uint8_t *dst, int dst_size)\n {\n     int namelen = strlen(name);\n     int len;\n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n     }\n    if (data_end - data < 3)\n         return -1;\n    data++;\n     for (;;) {\n        int size = bytestream_get_be16(&data);\n         if (!size)\n             break;\n        if (size < 0 || size >= data_end - data)\n             return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n             case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                 break;\n             case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                 break;\n             case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                 break;\n             default:\n                 return -1;\n             }\n             return 0;\n         }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n             return -1;\n        data += len;\n     }\n     return -1;\n }", "target": 1}
{"code": "strncmpic(uschar *s, uschar *t, int n)\n{\nwhile (n--)\n  {\n  int c = tolower(*s++) - tolower(*t++);\n  if (c) return c;\n  }\nreturn 0;\n}", "target": 0}
{"code": "  bool isReference() const { return type() == Type::Reference; }", "target": 0}
{"code": "static void __mcheck_cpu_init_timer(void)\n{\n\tstruct timer_list *t = this_cpu_ptr(&mce_timer);\n\ttimer_setup(t, mce_timer_fn, TIMER_PINNED);\n\tmce_start_timer(t);\n}", "target": 0}
{"code": "  void Cancel() { cancelled_ = true; }", "target": 0}
{"code": "static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\treturn err;\n}", "target": 1}
{"code": "bool chopOff(string &domain) \n{\n  if(domain.empty())\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot==string::npos) \n    domain=\"\";\n  else {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain); \n  }\n  return true;\n}", "target": 1}
{"code": "static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n\ttu = file->private_data;\n\tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n\tspin_lock_irq(&tu->qlock);\n\twhile ((long)count - result >= unit) {\n\t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n\t\t\tspin_unlock_irq(&tu->qlock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&tu->qlock);\n\t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n\t\ttu->qused--;\n\t\tspin_unlock_irq(&tu->qlock);\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->tread) {\n\t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_read)))\n\t\t\t\terr = -EFAULT;\n\t\t}\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tspin_lock_irq(&tu->qlock);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n\t}\n _error:\n\tspin_unlock_irq(&tu->qlock);\n\treturn result > 0 ? result : err;\n}", "target": 1}
{"code": "xps_true_callback_glyph_name(gs_font *pfont, gs_glyph glyph, gs_const_string *pstr)\n{\n    int table_length;\n     int table_offset;\n     ulong format;\n    uint numGlyphs;\n     uint glyph_name_index;\n     const byte *postp; \n     if ( pfont->FontType != ft_TrueType )\n     {\n            pstr->size = strlen((char*)pstr->data);\n            return 0;\n        }\n        else\n        {\n            return gs_throw1(-1, \"glyph index %lu out of range\", (ulong)glyph);\n        }\n    }", "target": 1}
{"code": "ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)\n{\n    ngx_int_t                  overwrite;\n    ngx_str_t                  uri, args;\n    ngx_table_elt_t           *location;\n    ngx_http_core_loc_conf_t  *clcf;\n    overwrite = err_page->overwrite;\n    if (overwrite && overwrite != NGX_HTTP_OK) {\n        r->expect_tested = 1;\n    }\n    if (overwrite >= 0) {\n        r->err_status = overwrite;\n    }\n    if (ngx_http_complex_value(r, &err_page->value, &uri) != NGX_OK) {\n        return NGX_ERROR;\n    }\n    if (uri.len && uri.data[0] == '/') {\n        if (err_page->value.lengths) {\n            ngx_http_split_args(r, &uri, &args);\n        } else {\n            args = err_page->args;\n        }\n        if (r->method != NGX_HTTP_HEAD) {\n            r->method = NGX_HTTP_GET;\n            r->method_name = ngx_http_core_get_method;\n        }\n        return ngx_http_internal_redirect(r, &uri, &args);\n    }\n    if (uri.len && uri.data[0] == '@') {\n        return ngx_http_named_location(r, &uri);\n    }\n    location = ngx_list_push(&r->headers_out.headers);\n    if (location == NULL) {\n        return NGX_ERROR;\n    }\n    if (overwrite != NGX_HTTP_MOVED_PERMANENTLY\n        && overwrite != NGX_HTTP_MOVED_TEMPORARILY\n        && overwrite != NGX_HTTP_SEE_OTHER\n        && overwrite != NGX_HTTP_TEMPORARY_REDIRECT\n        && overwrite != NGX_HTTP_PERMANENT_REDIRECT)\n    {\n        r->err_status = NGX_HTTP_MOVED_TEMPORARILY;\n    }\n    location->hash = 1;\n    ngx_str_set(&location->key, \"Location\");\n    location->value = uri;\n    ngx_http_clear_location(r);\n    r->headers_out.location = location;\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n    if (clcf->msie_refresh && r->headers_in.msie) {\n        return ngx_http_send_refresh(r);\n    }\n    return ngx_http_send_special_response(r, clcf, r->err_status\n                                                   - NGX_HTTP_MOVED_PERMANENTLY\n                                                   + NGX_HTTP_OFF_3XX);\n}", "target": 1}
{"code": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n     size_t noff, size_t doff, int *flags)\n {\n \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {\n \t\tuint8_t desc[20];\n \t\tconst char *btype;\n \t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING];\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n  if (!nserv || !line)\n    return 0;\n  if (sscanf(line, \"%s \" ANUM \" \" ANUM \" %c %[^\\n]\", group, &last, &first, &mod, desc) < 4)\n    return 0;\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}", "target": 1}
{"code": " int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n {\n\tu16 offset = sizeof(struct ipv6hdr);\n \tunsigned int packet_len = skb_tail_pointer(skb) -\n \t\tskb_network_header(skb);\n \tint found_rhdr = 0;\n \t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n \twhile (offset <= packet_len) {\n \t\tstruct ipv6_opt_hdr *exthdr;\n \t\tswitch (**nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n \t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n \t\t\t\t\t\t offset);\n\t\toffset += ipv6_optlen(exthdr);\n \t\t*nexthdr = &exthdr->nexthdr;\n \t}\n\treturn -EINVAL;\n}", "target": 1}
{"code": "gimp_channel_push_undo (GimpChannel *channel,\n                        const gchar *undo_desc)\n{\n  g_return_if_fail (GIMP_IS_CHANNEL (channel));\n  g_return_if_fail (gimp_item_is_attached (GIMP_ITEM (channel)));\n  gimp_image_undo_push_mask (gimp_item_get_image (GIMP_ITEM (channel)),\n                             undo_desc, channel);\n}", "target": 0}
{"code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "pim_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int len, const u_char *bp2)\n{\n\tregister const u_char *ep;\n\tregister const struct pim *pim = (const struct pim *)bp;\n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n#ifdef notyet\t\t\t\n\tND_TCHECK(pim->pim_rsv);\n#endif\n\tswitch (PIM_VER(pim->pim_typever)) {\n\tcase 2:\n\t\tif (!ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \"PIMv%u, %s, length %u\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever)),\n\t\t\t          len));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"PIMv%u, length %u\\n\\t%s\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          len,\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever))));\n\t\t\tpimv2_print(ndo, bp, len, bp2);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"PIMv%u, length %u\",\n\t\t          PIM_VER(pim->pim_typever),\n\t\t          len));\n\t\tbreak;\n\t}\n\treturn;\n}", "target": 1}
{"code": "snmp_oid_decode_oid(uint8_t *buf, uint32_t *buff_len, uint32_t *oid, uint32_t *oid_len)\n{\n  uint32_t *start;\n  uint8_t *buf_end, type;\n  uint8_t len;\n  div_t first;\n  start = oid;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL) {\n    return NULL;\n  }\n  if(type != SNMP_DATA_TYPE_OBJECT) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL) {\n    return NULL;\n  }\n  buf_end = buf + len;\n  (*buff_len)--;\n  first = div(*buf++, 40);\n  *oid++ = (uint32_t)first.quot;\n  *oid++ = (uint32_t)first.rem;\n  while(buf != buf_end) {\n    --(*oid_len);\n    if(*oid_len == 0) {\n      return NULL;\n    }\n    int i;\n    *oid = (uint32_t)(*buf & 0x7F);\n    for(i = 0; i < 4; i++) {\n      (*buff_len)--;\n      if((*buf++ & 0x80) == 0) {\n        break;\n      }\n      *oid <<= 7;\n      *oid |= (*buf & 0x7F);\n    }\n    ++oid;\n  }\n  *oid++ = ((uint32_t)-1);\n  *oid_len = (uint32_t)(oid - start);\n  return buf;\n}", "target": 1}
{"code": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}", "target": 1}
{"code": "static void execlists_submit_request(struct i915_request *request)\n{\n\tstruct intel_engine_cs *engine = request->engine;\n\tunsigned long flags;\n\tspin_lock_irqsave(&engine->active.lock, flags);\n\tqueue_request(engine, &request->sched, rq_prio(request));\n\tGEM_BUG_ON(RB_EMPTY_ROOT(&engine->execlists.queue.rb_root));\n\tGEM_BUG_ON(list_empty(&request->sched.link));\n\tsubmit_queue(engine, request);\n\tspin_unlock_irqrestore(&engine->active.lock, flags);\n}", "target": 0}
{"code": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}", "target": 1}
{"code": "int cg_write(const char *path, const char *buf, size_t size, off_t offset,\n\t     struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *localbuf = NULL;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *f = (struct file_info *)fi->fh;\n\tbool r;\n\tif (f->type != LXC_TYPE_CGFILE) {\n\t\tfprintf(stderr, \"Internal error: directory cache info used in cg_write\\n\");\n\t\treturn -EIO;\n\t}\n\tif (offset)\n\t\treturn 0;\n\tif (!fc)\n\t\treturn -EIO;\n\tlocalbuf = alloca(size+1);\n\tlocalbuf[size] = '\\0';\n\tmemcpy(localbuf, buf, size);\n\tif ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {\n\t\tsize = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\tif (!r)\n\t\tsize = -EINVAL;\nout:\n\tfree_key(k);\n\treturn size;\n}", "target": 1}
{"code": "Http::FilterMetadataStatus Context::onRequestMetadata() {\n  if (!wasm_->onRequestMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "socks_request_free(socks_request_t *req)\n{\n  if (!req)\n    return;\n  if (req->username) {\n    memwipe(req->username, 0x10, req->usernamelen);\n    tor_free(req->username);\n  }\n  if (req->password) {\n    memwipe(req->password, 0x04, req->passwordlen);\n    tor_free(req->password);\n  }\n  memwipe(req, 0xCC, sizeof(socks_request_t));\n  tor_free(req);\n}", "target": 0}
{"code": "static TEE_Result do_allocate_publickey(struct dsa_public_key *key,\n\t\t\t\t\tsize_t l_bits, size_t n_bits)\n{\n\tDSA_TRACE(\"DSA Allocate Public of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "resolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n        if (!list->child) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if (check_key(list, i, keys_str, len)) {\n            return -1;\n        }\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n        if (list->keys[i]->dflt) {\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n    return EXIT_SUCCESS;\n}", "target": 1}
{"code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                if (cid <= 0)\n                    continue;\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}", "target": 1}
{"code": "void RenderView::didNavigateWithinPage(\n    WebFrame* frame, bool is_new_navigation) {\n  NavigationState* state =\n    NavigationState::FromDataSource(frame->dataSource());\n  bool idle_scheduler_ran = state->user_script_idle_scheduler()->has_run();\n  didCreateDataSource(frame, frame->dataSource());\n  if (idle_scheduler_ran) {\n    NavigationState* new_state =\n        NavigationState::FromDataSource(frame->dataSource());\n    new_state->user_script_idle_scheduler()->set_has_run(true);\n  }\n  didCommitProvisionalLoad(frame, is_new_navigation);\n  UpdateTitle(frame, frame->view()->mainFrame()->dataSource()->pageTitle());\n}", "target": 0}
{"code": "DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)\n{\n    int i;\n    storeAppendPrintf(sentry, \"HTTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.http_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.http_read_hist[i],\n                          Math::doublePercent(stats.http_read_hist[i], stats.http_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"FTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.ftp_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.ftp_read_hist[i],\n                          Math::doublePercent(stats.ftp_read_hist[i], stats.ftp_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"Gopher I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.gopher_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.gopher_read_hist[i],\n                          Math::doublePercent(stats.gopher_read_hist[i], stats.gopher_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n}", "target": 1}
{"code": "void RenderView::assignIdentifierToRequest(\n    WebFrame* frame, unsigned identifier, const WebURLRequest& request) {\n}", "target": 0}
{"code": "cursor_up(\n    long\tn,\n    int\t\tupd_topline)\t    \n{\n    linenr_T\tlnum;\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\tif (lnum <= 1 || (n >= lnum && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (n >= lnum)\n\t    lnum = 1;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t{\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    while (n--)\n\t    {\n\t\t--lnum;\n\t\tif (lnum <= 1)\n\t\t    break;\n\t\tif (n > 0 || !((State & INSERT) || (fdo_flags & FDO_ALL)))\n\t\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    }\n\t    if (lnum < 1)\n\t\tlnum = 1;\n\t}\n\telse\n#endif\n\t    lnum -= n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n    coladvance(curwin->w_curswant);\n    if (upd_topline)\n\tupdate_topline();\t\n    return OK;\n}", "target": 0}
{"code": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n    if( *p + 2 > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n     n = ( (*p)[0] << 8 ) | (*p)[1];\n     *p += 2;\n    if( n < 1 || n > 65535 || *p + n > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n    *p += n;\n    return( 0 );\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.line_number_table_attr.line_number_table = r_list_newf (free);\n\tut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr->info.line_number_table_attr.line_number_table;\n\tif (linenum_len > sz) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->file_offset = curpos;\n\t\tlnattr->size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "isoclns_print(netdissect_options *ndo,\n              const uint8_t *p, u_int length, u_int caplen)\n {\n\tif (caplen <= 1) { \n \t\tND_PRINT((ndo, \"|OSI\"));\n \t\treturn;\n \t}\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"OSI NLPID %s (0x%02x): \", tok2str(nlpid_values, \"Unknown\", *p), *p));\n\tswitch (*p) {\n \tcase NLPID_CLNP:\n \t\tif (!clnp_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \tcase NLPID_ESIS:\n\t\tesis_print(ndo, p, length);\n\t\treturn;\n \tcase NLPID_ISIS:\n \t\tif (!isis_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \tcase NLPID_NULLNS:\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tbreak;\n\tcase NLPID_Q933:\n\t\tq933_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP:\n\t\tip_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_PPP:\n\t\tppp_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tdefault:\n \t\tif (!ndo->ndo_eflag)\n \t\t\tND_PRINT((ndo, \"OSI NLPID 0x%02x unknown\", *p));\n \t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tif (caplen > 1)\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \t}\n }", "target": 1}
{"code": "gs_font_map_glyph_to_unicode(gs_font *font, gs_glyph glyph, int ch, ushort *u, unsigned int length)\n{\n    font_data *pdata = pfont_data(font);\n    const ref *UnicodeDecoding;\n    uchar *unicode_return = (uchar *)u;\n    if (r_type(&pdata->GlyphNames2Unicode) == t_dictionary) {\n        int c = gs_font_map_glyph_by_dict(font->memory,\n                                              &pdata->GlyphNames2Unicode, glyph, u, length);\n        if (c != 0)\n            return c;\n        if (ch != -1) { \n            ref *v, n;\n            make_int(&n, ch);\n            if (dict_find(&pdata->GlyphNames2Unicode, &n, &v) > 0) {\n                if (r_has_type(v, t_string)) {\n                    int l = r_size(v);\n                    if (l > length)\n                        return l;\n                    memcpy(unicode_return, v->value.const_bytes, l * sizeof(short));\n                    return l;\n                }\n                if (r_type(v) == t_integer) {\n                    if (v->value.intval > 65535) {\n                        if (length < 4)\n                            return 4;\n                        unicode_return[0] = v->value.intval >> 24;\n                        unicode_return[1] = (v->value.intval & 0x00FF0000) >> 16;\n                        unicode_return[2] = (v->value.intval & 0x0000FF00) >> 8;\n                        unicode_return[3] = v->value.intval & 0xFF;\n                        return 4;\n                    } else {\n                        if (length < 2)\n                            return 2;\n                        unicode_return[0] = v->value.intval >> 8;\n                        unicode_return[1] = v->value.intval & 0xFF;\n                        return 2;\n                    }\n                }\n            }\n        }\n    }\n    if (glyph <= GS_MIN_CID_GLYPH) {\n        UnicodeDecoding = zfont_get_to_unicode_map(font->dir);\n        if (UnicodeDecoding != NULL && r_type(UnicodeDecoding) == t_dictionary)\n            return gs_font_map_glyph_by_dict(font->memory, UnicodeDecoding, glyph, u, length);\n    }\n    return 0; \n}", "target": 1}
{"code": "zzip_get_default_ext(void)\n{\n    static zzip_strings_t ext[] = {\n       \".zip\", \".ZIP\", \n#     ifdef ZZIP_USE_ZIPLIKES\n       \".pk3\", \".PK3\", \n       \".jar\", \".JAR\", \n#      endif\n        0\n    };\n    return ext;\n}", "target": 0}
{"code": "void WasmBinaryBuilder::visitDrop(Drop* curr) {\n  BYN_TRACE(\"zz node: Drop\\n\");\n  curr->value = popNonVoidExpression();\n  curr->finalize();\n}", "target": 0}
{"code": "rsa_compute_root_tr(const struct rsa_public_key *pub,\n\t\t    const struct rsa_private_key *key,\n\t\t    void *random_ctx, nettle_random_func *random,\n\t\t    mpz_t x, const mpz_t m)\n{\n  int res;\n  mpz_t t, mb, xb, ri;\n  mpz_init (mb);\n  mpz_init (xb);\n  mpz_init (ri);\n  mpz_init (t);\n  rsa_blind (pub, random_ctx, random, mb, ri, m);\n  rsa_compute_root (key, xb, mb);\n  mpz_powm_sec(t, xb, pub->e, pub->n);\n  res = (mpz_cmp(mb, t) == 0);\n  if (res)\n    rsa_unblind (pub, x, ri, xb);\n  mpz_clear (mb);\n  mpz_clear (xb);\n  mpz_clear (ri);\n  mpz_clear (t);\n  return res;\n}", "target": 1}
{"code": "bool PluginInfoMessageFilter::OnMessageReceived(const IPC::Message& message,\n                                                bool* message_was_ok) {\n  IPC_BEGIN_MESSAGE_MAP_EX(PluginInfoMessageFilter, message, *message_was_ok)\n    IPC_MESSAGE_HANDLER_DELAY_REPLY(ChromeViewHostMsg_GetPluginInfo,\n                                    OnGetPluginInfo)\n    IPC_MESSAGE_UNHANDLED(return false)\n  IPC_END_MESSAGE_MAP()\n  return true;\n}", "target": 0}
{"code": "create_surface_from_thumbnail_data (guchar *data,\n\t\t\t\t    gint    width,\n\t\t\t\t    gint    height,\n \t\t\t\t    gint    rowstride)\n {\n   guchar *cairo_pixels;\n   cairo_surface_t *surface;\n  static cairo_user_data_key_t key;\n   int j;\n  cairo_pixels = (guchar *)g_malloc (4 * width * height);\n  surface = cairo_image_surface_create_for_data ((unsigned char *)cairo_pixels,\n\t\t\t\t\t\t CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t width, height, 4 * width);\n  cairo_surface_set_user_data (surface, &key,\n\t\t\t       cairo_pixels, (cairo_destroy_func_t)g_free);\n   for (j = height; j; j--) {\n     guchar *p = data;\n     guchar *q = cairo_pixels;\n     guchar *end = p + 3 * width;\n     while (p < end) {\n #if G_BYTE_ORDER == G_LITTLE_ENDIAN\n       q[0] = p[2];\n       q[1] = p[1];\n       q[2] = p[0];\n#else\t  \n       q[1] = p[0];\n       q[2] = p[1];\n       q[3] = p[2];\n#endif\n      p += 3;\n      q += 4;\n     }\n     data += rowstride;\n    cairo_pixels += 4 * width;\n   }\n   return surface;\n}", "target": 1}
{"code": "static int nft_delflowtable_hook(struct nft_ctx *ctx,\n\t\t\t\t struct nft_flowtable *flowtable)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tLIST_HEAD(flowtable_del_list);\n\tstruct nft_hook *this, *hook;\n\tstruct nft_trans *trans;\n\tint err;\n\terr = nft_flowtable_parse_hook(ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, false);\n\tif (err < 0)\n\t\treturn err;\n\tlist_for_each_entry(this, &flowtable_hook.list, list) {\n\t\thook = nft_hook_list_find(&flowtable->hook_list, this);\n\t\tif (!hook) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_flowtable_del_hook;\n\t\t}\n\t\tlist_move(&hook->list, &flowtable_del_list);\n\t}\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_DELFLOWTABLE,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (!trans) {\n\t\terr = -ENOMEM;\n\t\tgoto err_flowtable_del_hook;\n\t}\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_flowtable_update(trans) = true;\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tlist_splice(&flowtable_del_list, &nft_trans_flowtable_hooks(trans));\n\tnft_flowtable_hook_release(&flowtable_hook);\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\nerr_flowtable_del_hook:\n\tlist_splice(&flowtable_del_list, &flowtable->hook_list);\n\tnft_flowtable_hook_release(&flowtable_hook);\n\treturn err;\n}", "target": 0}
{"code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\t(*header)->os_type = RAW_DATA(header, 23);\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "std::string CanonicalizeHost(const std::wstring& host,\n                             url_canon::CanonHostInfo* host_info) {\n  std::string converted_host;\n  WideToUTF8(host.c_str(), host.length(), &converted_host);\n  return CanonicalizeHost(converted_host, host_info);\n}", "target": 0}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "join_read_last(JOIN_TAB *tab)\n{\n  TABLE *table=tab->table;\n  int error= 0;\n  DBUG_ENTER(\"join_read_last\");\n  DBUG_ASSERT(table->no_keyread ||\n              !table->covering_keys.is_set(tab->index) ||\n              table->file->keyread == tab->index);\n  tab->table->status=0;\n  tab->read_record.read_record=join_read_prev;\n  tab->read_record.table=table;\n  tab->read_record.index=tab->index;\n  tab->read_record.record=table->record[0];\n  if (!table->file->inited)\n    error= table->file->ha_index_init(tab->index, 1);\n  if (!error)\n    error= table->file->prepare_index_scan();\n  if (error || (error= tab->table->file->ha_index_last(tab->table->record[0])))\n    DBUG_RETURN(report_error(table, error));\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "static int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count;\n    nut->avf = s;\n    pos = 0;\n    do {\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while (decode_main_header(nut) < 0);\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n        decode_info_header(nut);\n    }\n    ffformatcontext(s)->data_offset = pos - 8;\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n    return 0;\n}", "target": 1}
{"code": "void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)\n{\n    QList<QByteArray> params;\n    params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));\n    static const char *splitter = \" .,-!?\";\n    int maxSplitPos = message.count();\n    int splitPos = maxSplitPos;\n    int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);\n    if (overrun) {\n        maxSplitPos = message.count() - overrun -2;\n        splitPos = -1;\n        for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n            splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \n        }\n        if (splitPos <= 0 || splitPos > maxSplitPos)\n            splitPos = maxSplitPos;\n        params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));\n    }\n    net->putCmd(\"PRIVMSG\", params);\n    if (splitPos < message.count())\n        query(net, bufname, ctcpTag, message.mid(splitPos));\n}", "target": 1}
{"code": "int reds_on_migrate_dst_set_seamless(RedsState *reds, MainChannelClient *mcc, uint32_t src_version)\n{\n    if (reds->allow_multiple_clients  || src_version > SPICE_MIGRATION_PROTOCOL_VERSION) {\n        reds->dst_do_seamless_migrate = FALSE;\n    } else {\n        RedClient *client = mcc->get_client();\n        client->set_migration_seamless();\n        reds->dst_do_seamless_migrate = reds_link_mig_target_channels(reds, client);\n    }\n    return reds->dst_do_seamless_migrate;\n}", "target": 0}
{"code": "static void __reg_deduce_bounds(struct bpf_reg_state *reg)\n{\n\t__reg32_deduce_bounds(reg);\n\t__reg64_deduce_bounds(reg);\n}", "target": 0}
{"code": "void DevToolsDownloadManagerDelegate::Shutdown() {\n  if (proxy_download_delegate_)\n    proxy_download_delegate_->Shutdown();\n  download_manager_ = nullptr;\n}", "target": 0}
{"code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n\tchar *ptr;\n\tint err;\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n\tif (!file)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\tkfree(file);\n\treturn err;\n}", "target": 1}
{"code": "TfLiteStatus PrepareHashtableImport(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* value_tensor = GetInput(context, node, kValueTensor);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           value_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               value_tensor->type == kTfLiteInt64));\n  TF_LITE_ENSURE(context, HaveSameShapes(key_tensor, value_tensor));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static inline zend_long parse_iv(const unsigned char *p)\n{\n\treturn parse_iv2(p, NULL);\n}", "target": 0}
{"code": "compileWarning (FileInfo * nested, char *format, ...)\n{\n#ifndef __SYMBIAN32__\n  char buffer[MAXSTRING];\n  va_list arguments;\n  va_start (arguments, format);\n#ifdef _WIN32\n  _vsnprintf (buffer, sizeof (buffer), format, arguments);\n#else\n  vsnprintf (buffer, sizeof (buffer), format, arguments);\n#endif\n  va_end (arguments);\n  if (nested)\n    lou_logPrint (\"%s:%d: warning: %s\", nested->fileName,\n\t\t  nested->lineNumber, buffer);\n  else\n    lou_logPrint (\"warning: %s\", buffer);\n  warningCount++;\n#endif\n}", "target": 0}
{"code": "static void process_request(struct connection *conn) {\n    num_requests++;\n    if (!parse_request(conn)) {\n        default_reply(conn, 400, \"Bad Request\",\n            \"You sent a request that the server couldn't understand.\");\n    }\n    else if (is_https_redirect(conn)) {\n        redirect_https(conn);\n    }\n    else if (auth_key != NULL &&\n            (conn->authorization == NULL ||\n             strcmp(conn->authorization, auth_key)))\n    {\n        default_reply(conn, 401, \"Unauthorized\",\n            \"Access denied due to invalid credentials.\");\n    }\n    else if (strcmp(conn->method, \"GET\") == 0) {\n        process_get(conn);\n    }\n    else if (strcmp(conn->method, \"HEAD\") == 0) {\n        process_get(conn);\n        conn->header_only = 1;\n    }\n    else {\n        default_reply(conn, 501, \"Not Implemented\",\n                      \"The method you specified is not implemented.\");\n    }\n    conn->state = SEND_HEADER;\n    free(conn->request);\n    conn->request = NULL; \n}", "target": 1}
{"code": "void ContainerNode::notifyNodeInserted(Node& root, ChildrenChangeSource source)\n{\n    ASSERT(!EventDispatchForbiddenScope::isEventDispatchForbidden());\n    ASSERT(!root.isShadowRoot());\n    InspectorInstrumentation::didInsertDOMNode(&root);\n    RefPtrWillBeRawPtr<Node> protect(this);\n    RefPtrWillBeRawPtr<Node> protectNode(root);\n    NodeVector postInsertionNotificationTargets;\n    notifyNodeInsertedInternal(root, postInsertionNotificationTargets);\n    childrenChanged(ChildrenChange::forInsertion(root, source));\n    for (const auto& targetNode : postInsertionNotificationTargets) {\n        if (targetNode->inDocument())\n            targetNode->didNotifySubtreeInsertionsToDocument();\n    }\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* epsilon_t;\n    OP_REQUIRES_OK(context, context->input(kEpsilonName, &epsilon_t));\n    float epsilon = epsilon_t->scalar<float>()();\n    OP_REQUIRES(\n        context, epsilon > 0,\n        errors::InvalidArgument(\"An epsilon value of zero is not allowed.\"));\n    const Tensor* num_streams_t;\n    OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t));\n    int64_t num_streams = num_streams_t->scalar<int64>()();\n    auto result =\n        new QuantileStreamResource(epsilon, max_elements_, num_streams);\n    auto status = CreateResource(context, HandleFromInput(context, 0), result);\n    if (!status.ok() && status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES(context, false, status);\n    }\n  }", "target": 1}
{"code": "gfx::Rect OverlayWindowViews::GetVideoBounds() {\n  return video_bounds_;\n}", "target": 0}
{"code": "ZEND_API zend_extension *zend_get_extension(const char *extension_name)\n{\n\tzend_llist_element *element;\n\tfor (element = zend_extensions.head; element; element = element->next) {\n\t\tzend_extension *extension = (zend_extension *) element->data;\n\t\tif (!strcmp(extension->name, extension_name)) {\n\t\t\treturn extension;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "int x509_get_name( unsigned char **p, const unsigned char *end,\n                   x509_name *cur )\n{\n    int ret;\n    size_t len;\n    const unsigned char *end2;\n    x509_name *use;\n    if( ( ret = asn1_get_tag( p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SET ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_NAME + ret );\n    end2 = end;\n    end  = *p + len;\n    use = cur;\n    do\n    {\n        if( ( ret = x509_get_attr_type_value( p, end, use ) ) != 0 )\n            return( ret );\n        if( *p != end )\n        {\n            use->next = (x509_name *) polarssl_malloc(\n                    sizeof( x509_name ) );\n            if( use->next == NULL )\n                return( POLARSSL_ERR_X509_MALLOC_FAILED );\n            memset( use->next, 0, sizeof( x509_name ) );\n            use = use->next;\n        }\n    }\n    while( *p != end );\n    if( *p == end2 )\n        return( 0 );\n    cur->next = (x509_name *) polarssl_malloc(\n         sizeof( x509_name ) );\n    if( cur->next == NULL )\n        return( POLARSSL_ERR_X509_MALLOC_FAILED );\n    memset( cur->next, 0, sizeof( x509_name ) );\n    return( x509_get_name( p, end2, cur->next ) );\n}", "target": 1}
{"code": "    void operator=(GetResult&& rhs) noexcept { result_ = std::move(rhs.result_); }", "target": 0}
{"code": "build_principal_va(krb5_context context, krb5_principal princ,\n                   unsigned int rlen, const char *realm, va_list ap)\n{\n    krb5_error_code retval = 0;\n    char *r = NULL;\n    krb5_data *data = NULL;\n    krb5_int32 count = 0;\n    krb5_int32 size = 2;  \n    char *component = NULL;\n     data = malloc(size * sizeof(krb5_data));\n     if (!data) { retval = ENOMEM; }\n    if (!retval) {\n        r = strdup(realm);\n        if (!r) { retval = ENOMEM; }\n    }\n     while (!retval && (component = va_arg(ap, char *))) {\n         if (count == size) {\n            krb5_data *new_data = NULL;\n            size *= 2;\n            new_data = realloc(data, size * sizeof(krb5_data));\n            if (new_data) {\n                data = new_data;\n            } else {\n                retval = ENOMEM;\n            }\n        }\n        if (!retval) {\n            data[count].length = strlen(component);\n            data[count].data = strdup(component);\n            if (!data[count].data) { retval = ENOMEM; }\n            count++;\n        }\n    }\n    if (!retval) {\n        princ->type = KRB5_NT_UNKNOWN;\n        princ->magic = KV5M_PRINCIPAL;\n        princ->realm = make_data(r, rlen);\n        princ->data = data;\n        princ->length = count;\n        r = NULL;    \n        data = NULL; \n    }\n    if (data) {\n        while (--count >= 0) {\n            free(data[count].data);\n        }\n        free(data);\n    }\n    free(r);\n    return retval;\n}", "target": 1}
{"code": "int js_isregexp(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\treturn v->type == JS_TOBJECT && v->u.object->type == JS_CREGEXP;\n}", "target": 0}
{"code": "authdir_wants_to_reject_router(routerinfo_t *ri, const char **msg,\n                               int complain, int *valid_out)\n{\n  time_t now;\n  int severity = (complain && ri->contact_info) ? LOG_NOTICE : LOG_INFO;\n  uint32_t status = dirserv_router_get_status(ri, msg, severity);\n  tor_assert(msg);\n  if (status & FP_REJECT)\n    return -1; \n  now = time(NULL);\n  if (ri->cache_info.published_on > now+ROUTER_ALLOW_SKEW) {\n    log_fn(severity, LD_DIRSERV, \"Publication time for %s is too \"\n           \"far (%d minutes) in the future; possible clock skew. Not adding \"\n           \"(%s)\",\n           router_describe(ri),\n           (int)((ri->cache_info.published_on-now)/60),\n           esc_router_info(ri));\n    *msg = \"Rejected: Your clock is set too far in the future, or your \"\n      \"timezone is not correct.\";\n    return -1;\n  }\n  if (ri->cache_info.published_on < now-ROUTER_MAX_AGE_TO_PUBLISH) {\n    log_fn(severity, LD_DIRSERV,\n           \"Publication time for %s is too far \"\n           \"(%d minutes) in the past. Not adding (%s)\",\n           router_describe(ri),\n           (int)((now-ri->cache_info.published_on)/60),\n           esc_router_info(ri));\n    *msg = \"Rejected: Server is expired, or your clock is too far in the past,\"\n      \" or your timezone is not correct.\";\n    return -1;\n  }\n  if (dirserv_router_has_valid_address(ri) < 0) {\n    log_fn(severity, LD_DIRSERV,\n           \"Router %s has invalid address. Not adding (%s).\",\n           router_describe(ri),\n           esc_router_info(ri));\n    *msg = \"Rejected: Address is a private address.\";\n    return -1;\n  }\n  *valid_out = ! (status & FP_INVALID);\n  return 0;\n}", "target": 0}
{"code": "BOOL nego_read_request(rdpNego* nego, wStream* s)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\tif (!tpkt_read_header(s, &length))\n\t\treturn FALSE;\n\tif (!tpdu_read_connection_request(s, &li, length))\n\t\treturn FALSE;\n\tif (li != Stream_GetRemainingLength(s) + 6)\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect TPDU length indicator.\");\n\t\treturn FALSE;\n\t}\n\tif (!nego_read_request_token_or_cookie(nego, s))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse routing token or cookie.\");\n\t\treturn FALSE;\n\t}\n\tif (Stream_GetRemainingLength(s) >= 8)\n\t{\n\t\tStream_Read_UINT8(s, type); \n\t\tif (type != TYPE_RDP_NEG_REQ)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Incorrect negotiation request type %\" PRIu8 \"\", type);\n\t\t\treturn FALSE;\n\t\t}\n\t\tnego_process_negotiation_request(nego, s);\n\t}\n\treturn tpkt_ensure_stream_consumed(s, length);\n}", "target": 1}
{"code": "void LibRaw::lossy_dng_load_raw() {}", "target": 0}
{"code": "void RenderView::didCreateIsolatedScriptContext(WebFrame* frame) {\n  EventBindings::HandleContextCreated(frame, true);\n}", "target": 0}
{"code": "size_t util_path_encode(char *s, size_t len)\n{\n\tchar t[(len * 3)+1];\n\tsize_t i, j;\n\tfor (i = 0, j = 0; s[i] != '\\0'; i++) {\n\t\tif (s[i] == '/') {\n\t\t\tmemcpy(&t[j], \"\\\\x2f\", 4);\n\t\t\tj += 4;\n\t\t} else if (s[i] == '\\\\') {\n\t\t\tmemcpy(&t[j], \"\\\\x5c\", 4);\n\t\t\tj += 4;\n\t\t} else {\n\t\t\tt[j] = s[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tif (len == 0)\n\t\treturn j;\n\ti = (j < len - 1) ? j : len - 1;\n\tmemcpy(s, t, i);\n\ts[i] = '\\0';\n\treturn j;\n}", "target": 1}
{"code": "void IndexedDBDatabase::GetKeyGeneratorCurrentNumber(\n    IndexedDBTransaction* transaction,\n    int64_t object_store_id,\n    scoped_refptr<IndexedDBCallbacks> callbacks) {\n  DCHECK(transaction);\n  if (!ValidateObjectStoreId(object_store_id)) {\n    callbacks->OnError(CreateError(blink::kWebIDBDatabaseExceptionDataError,\n                                   \"Object store id not valid.\", transaction));\n    return;\n  }\n  transaction->ScheduleTask(\n      base::BindOnce(&IndexedDBDatabase::GetKeyGeneratorCurrentNumberOperation,\n                     this, object_store_id, callbacks));\n}", "target": 0}
{"code": "Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) {\n  DCHECK_EQ(t.args_size(), 3);\n  const auto& cont = t.args(0);\n  const auto& tmpl = t.args(1);\n  const auto& t_var = t.args(2);\n  StringPiece var_name = t_var.s();\n  if (!attrs.contains(var_name)) {\n    return Status(\n        error::INVALID_ARGUMENT,\n        absl::StrCat(\"could not find an attribute for key '\", var_name, \"'\"));\n  }\n  const AttrValue* attr = attrs.at(var_name);\n  FullTypeDef result;\n  result.set_type_id(cont.type_id());\n  const auto attr_type = attr->value_case();\n  if (attr_type == AttrValue::kType) {\n    FullTypeDef* target = result.add_args();\n    *target = tmpl;\n    TF_RETURN_WITH_CONTEXT_IF_ERROR(\n        SubstituteFromAttrs(attrs, *target), \"while substituting '\", var_name,\n        \"' from\\n\", attr->DebugString(), \"\\ninto \", target->DebugString());\n  } else if (attr_type == AttrValue::kList) {\n    const auto& attr_list = attr->list();\n    int tsize = attr_list.type_size();\n    if (tsize == 0) {\n      return Status(error::UNIMPLEMENTED,\n                    absl::StrCat(\"unsupported list attribute type\\n\",\n                                 attr_list.DebugString(), \"\\nkey=\", var_name));\n    }\n    AttrValue replacement;\n    attrs[var_name] = &replacement;\n    for (int i = 0; i < tsize; i++) {\n      replacement.set_type(attr_list.type(i));\n      FullTypeDef* target = result.add_args();\n      *target = tmpl;\n      TF_RETURN_WITH_CONTEXT_IF_ERROR(SubstituteFromAttrs(attrs, *target),\n                                      \"while substituting '\", var_name,\n                                      \"' from\\n\", attr->DebugString(), \"\\n[\", i,\n                                      \"] into\\n\", target->DebugString());\n    }\n    attrs[var_name] = attr;\n  } else {\n    return Status(error::UNIMPLEMENTED,\n                  absl::StrCat(\"unsupported attribute type\\n\",\n                               attr->DebugString(), \"\\nfor name \", var_name));\n  }\n  t = result;\n  return OkStatus();\n}", "target": 1}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n        ctx->cid = cid;\n    }\n    return 0;\n}", "target": 1}
{"code": "PassRefPtr<HTMLButtonElement> HTMLButtonElement::create(Document& document, HTMLFormElement* form)\n{\n    return adoptRef(new HTMLButtonElement(document, form));\n}", "target": 0}
{"code": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n  if (text[1] == EOF)\n     return 0;\n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n    if (text[2] == EOF)\n       return 0;\n     text[3] = RE_YY_INPUT(yyscanner);\n    if (text[3] == EOF)\n       return 0;\n   }\n  *escaped_char = escaped_char_value(text);\n  return 1;\n}", "target": 1}
{"code": "concat_opt_anc_info(OptAncInfo* to, OptAncInfo* left, OptAncInfo* right,\n\t\t    OnigDistance left_len, OnigDistance right_len)\n{\n  clear_opt_anc_info(to);\n  to->left_anchor = left->left_anchor;\n  if (left_len == 0) {\n    to->left_anchor |= right->left_anchor;\n  }\n  to->right_anchor = right->right_anchor;\n  if (right_len == 0) {\n    to->right_anchor |= left->right_anchor;\n  }\n  else {\n    to->right_anchor |= (left->right_anchor & ANCHOR_PREC_READ_NOT);\n  }\n}", "target": 0}
{"code": "static void coroutine_fn mirror_throttle(MirrorBlockJob *s)\n{\n    int64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n    if (now - s->last_pause_ns > BLOCK_JOB_SLICE_TIME) {\n        s->last_pause_ns = now;\n        job_sleep_ns(&s->common.job, 0);\n    } else {\n        job_pause_point(&s->common.job);\n    }\n}", "target": 0}
{"code": "static int vol_prc_lib_release(effect_handle_t handle)\n{\n     struct listnode *node, *temp_node_next;\n     vol_listener_context_t *context = NULL;\n     vol_listener_context_t *recv_contex = (vol_listener_context_t *)handle;\n    int status = -1;\n     bool recompute_flag = false;\n     int active_stream_count = 0;\n     ALOGV(\"%s context %p\", __func__, handle);\n     pthread_mutex_lock(&vol_listner_init_lock);\n     list_for_each_safe(node, temp_node_next, &vol_effect_list) {\n         context = node_to_item(node, struct vol_listener_context_s, effect_list_node);\n        if ((memcmp(&(context->desc->uuid), &(recv_contex->desc->uuid), sizeof(effect_uuid_t)) == 0)\n            && (context->session_id == recv_contex->session_id)\n            && (context->stream_type == recv_contex->stream_type)) {\n             ALOGV(\"--- Found something to remove ---\");\n            list_remove(&context->effect_list_node);\n             PRINT_STREAM_TYPE(context->stream_type);\n             if (context->dev_id && AUDIO_DEVICE_OUT_SPEAKER) {\n                 recompute_flag = true;\n }\n            free(context);\n            status = 0;\n } else {\n ++active_stream_count;\n }\n }\n     if (status != 0) {\n         ALOGE(\"something wrong ... <<<--- Found NOTHING to remove ... ???? --->>>>>\");\n     }\n if (active_stream_count == 0) {\n        current_gain_dep_cal_level = -1;\n        current_vol = 0.0;\n }\n if (recompute_flag) {\n        check_and_set_gain_dep_cal();\n }\n if (dumping_enabled) {\n        dump_list_l();\n }\n    pthread_mutex_unlock(&vol_listner_init_lock);\n return status;\n}", "target": 1}
{"code": "MONGO_EXPORT int mongo_run_command( mongo *conn, const char *db, const bson *command,\n                                    bson *out ) {\n    int ret = MONGO_OK;\n    bson response = {NULL, 0};\n    bson fields;\n    int sl = strlen( db );\n    char *ns = bson_malloc( sl + 5 + 1 ); \n    int res, success = 0;\n    strcpy( ns, db );\n    strcpy( ns+sl, \".$cmd\" );\n    res = mongo_find_one( conn, ns, command, bson_empty( &fields ), &response );\n    bson_free( ns );\n    if( res != MONGO_OK )\n        ret = MONGO_ERROR;\n    else {\n        bson_iterator it;\n        if( bson_find( &it, &response, \"ok\" ) )\n            success = bson_iterator_bool( &it );\n        if( !success ) {\n            conn->err = MONGO_COMMAND_FAILED;\n            bson_destroy( &response );\n            ret = MONGO_ERROR;\n        }\n        else {\n            if( out )\n                *out = response;\n            else\n                bson_destroy( &response );\n        }\n    }\n    return ret;\n}", "target": 1}
{"code": " static int uas_switch_interface(struct usb_device *udev,\n \t\t\t\tstruct usb_interface *intf)\n {\n\tint alt;\n \talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn alt;\n\treturn usb_set_interface(udev,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n }", "target": 1}
{"code": "TEST_F(QueryPlannerTest, SnapshotUseId) {\n    params.options = QueryPlannerParams::SNAPSHOT_USE_ID;\n    addIndex(BSON(\"a\" << 1));\n    runQuerySnapshot(fromjson(\"{a: {$gt: 0}}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{fetch: {filter: {a:{$gt:0}}, node: \"\n        \"{ixscan: {filter: null, pattern: {_id: 1}}}}}\");\n}", "target": 0}
{"code": "OPJ_FLOAT32 opj_j2k_get_default_stride (opj_tcp_t * p_tcp)\n{\n    (void)p_tcp;\n    return 0;\n}", "target": 0}
{"code": "createenv(const struct rule *rule)\n{\n\tstruct env *env;\n\tu_int i;\n\tenv = malloc(sizeof(*env));\n\tif (!env)\n\t\terr(1, NULL);\n\tRB_INIT(&env->root);\n\tenv->count = 0;\n\tif (rule->options & KEEPENV) {\n\t\textern char **environ;\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tstruct envnode *node;\n\t\t\tconst char *e, *eq;\n\t\t\tsize_t len;\n\t\t\tchar keybuf[1024];\n\t\t\te = environ[i];\n\t\t\tif ((eq = strchr(e, '=')) == NULL || eq == e)\n\t\t\t\tcontinue;\n\t\t\tlen = eq - e;\n\t\t\tif (len > sizeof(keybuf) - 1)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(keybuf, e, len);\n\t\t\tkeybuf[len] = '\\0';\n\t\t\tnode = createnode(keybuf, eq + 1);\n\t\t\tif (RB_INSERT(envtree, &env->root, node)) {\n\t\t\t\tfreenode(node);\n\t\t\t} else {\n\t\t\t\tenv->count++;\n\t\t\t}\n\t\t}\n\t}\n\treturn env;\n}", "target": 1}
{"code": "void dccp_shutdown(struct sock *sk, int how)\n{\n\tdccp_pr_debug(\"entry\\n\");\n}", "target": 0}
{"code": "static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pF;\n  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n    ExprList *pList = pF->pExpr->x.pList;\n    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n    sqlite3VdbeAddOp2(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0);\n    sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n  }\n}", "target": 0}
{"code": "ProcStoreNamedColor(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xStoreNamedColorReq);\n    REQUEST_FIXED_SIZE(xStoreNamedColorReq, stuff->nbytes);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,\n                                 client, DixWriteAccess);\n    if (rc == Success) {\n        xColorItem def;\n        if (OsLookupColor(pcmp->pScreen->myNum, (char *) &stuff[1],\n                          stuff->nbytes, &def.red, &def.green, &def.blue)) {\n            def.flags = stuff->flags;\n            def.pixel = stuff->pixel;\n            return StoreColors(pcmp, 1, &def, client);\n        }\n        return BadName;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "int __kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err gf_isom_get_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, u32 *refTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_ISOTrackID refTrackNum;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t*refTrack = 0;\n\tif (!trak || !trak->References) return GF_BAD_PARAM;\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\tif (!referenceIndex || (referenceIndex > dpnd->trackIDCount)) return GF_BAD_PARAM;\n\tif (dpnd->trackIDs[referenceIndex - 1] == 0) return GF_OK;\n\trefTrackNum = gf_isom_get_tracknum_from_id(movie->moov, dpnd->trackIDs[referenceIndex-1]);\n\tif (! refTrackNum) return GF_ISOM_INVALID_FILE;\n\t*refTrack = refTrackNum;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n    u32in();\n    u32in();\n    mp4config.frame.ents = u32in();\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n        mp4config.frame.data[cnt + 1] = ofs;\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n    return size;\n}", "target": 1}
{"code": "bool pch_copy (void)\n{\n  return p_copy[OLD] && p_copy[NEW]\n\t && p_name[OLD] && p_name[NEW];\n}", "target": 0}
{"code": "void Browser::NavigationStateChanged(WebContents* source,\n                                     content::InvalidateTypes changed_flags) {\n  tracked_objects::ScopedTracker tracking_profile1(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"466285 Browser::NavigationStateChanged::ScheduleUIUpdate\"));\n  if (changed_flags)\n    ScheduleUIUpdate(source, changed_flags);\n  tracked_objects::ScopedTracker tracking_profile2(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"466285 Browser::NavigationStateChanged::TabStateChanged\"));\n  if (changed_flags & (content::INVALIDATE_TYPE_URL |\n                       content::INVALIDATE_TYPE_LOAD |\n                       content::INVALIDATE_TYPE_TAB))\n    command_controller_->TabStateChanged();\n  if (hosted_app_controller_)\n    hosted_app_controller_->UpdateLocationBarVisibility(true);\n}", "target": 0}
{"code": "bool Item::cleanup_processor(uchar *arg)\n{\n  if (fixed)\n    cleanup();\n  return FALSE;\n}", "target": 0}
{"code": "static int fetch_uidl (char *line, void *data)\n{\n  int i, index;\n  CONTEXT *ctx = (CONTEXT *)data;\n  POP_DATA *pop_data = (POP_DATA *)ctx->data;\n  char *endp;\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n      return -1;\n  while (*endp == ' ')\n      endp++;\n  memmove(line, endp, strlen(endp) + 1);\n  for (i = 0; i < ctx->msgcount; i++)\n    if (!mutt_strcmp (line, ctx->hdrs[i]->data))\n      break;\n  if (i == ctx->msgcount)\n  {\n    dprint (1, (debugfile, \"pop_fetch_headers: new header %d %s\\n\", index, line));\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_new_header ();\n    ctx->hdrs[i]->data = safe_strdup (line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = 1;\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n  return 0;\n}", "target": 1}
{"code": "static av_cold void avcodec_init(void)\n{\n    static int initialized = 0;\n    if (initialized != 0)\n        return;\n    initialized = 1;\n    if (CONFIG_DSPUTIL)\n        ff_dsputil_static_init();\n}", "target": 0}
{"code": "    bool empty() const { return result_.empty(); }", "target": 0}
{"code": "bool IsDrag(const POINT& origin, const POINT& current) {\n  return views::View::ExceededDragThreshold(current.x - origin.x,\n                                            current.y - origin.y);\n}", "target": 0}
{"code": "void RenderView::InjectToolstripCSS() {\n  if (view_type_ != ViewType::EXTENSION_TOOLSTRIP)\n    return;\n  static const base::StringPiece toolstrip_css(\n      ResourceBundle::GetSharedInstance().GetRawDataResource(\n      IDR_EXTENSION_TOOLSTRIP_CSS));\n  std::string css = toolstrip_css.as_string();\n  InsertCSS(L\"\", css, \"ToolstripDefaultCSS\");\n}", "target": 0}
{"code": "rpa_read_buffer(pool_t pool, const unsigned char **data,\n\t\tconst unsigned char *end, unsigned char **buffer)\n{\n\tconst unsigned char *p = *data;\n\tunsigned int len;\n\tif (p > end)\n\t\treturn 0;\n\tlen = *p++;\n\tif (p + len > end)\n\t\treturn 0;\n\t*buffer = p_malloc(pool, len);\n\tmemcpy(*buffer, p, len);\n\t*data += 1 + len;\n\treturn len;\n}", "target": 1}
{"code": "Value ExpressionDateToString::evaluate(const Document& root, Variables* variables) const {\n    const Value date = _date->evaluate(root, variables);\n    Value formatValue;\n    if (_format) {\n        formatValue = _format->evaluate(root, variables);\n        if (!formatValue.nullish()) {\n            uassert(18533,\n                    str::stream() << \"$dateToString requires that 'format' be a string, found: \"\n                                  << typeName(formatValue.getType()) << \" with value \"\n                                  << formatValue.toString(),\n                    formatValue.getType() == BSONType::String);\n            TimeZone::validateToStringFormat(formatValue.getStringData());\n        }\n    }\n    auto timeZone =\n        makeTimeZone(getExpressionContext()->timeZoneDatabase, root, _timeZone.get(), variables);\n    if (date.nullish()) {\n        return _onNull ? _onNull->evaluate(root, variables) : Value(BSONNULL);\n    }\n    if (!timeZone) {\n        return Value(BSONNULL);\n    }\n    if (_format) {\n        if (formatValue.nullish()) {\n            return Value(BSONNULL);\n        }\n        return Value(uassertStatusOK(\n            timeZone->formatDate(formatValue.getStringData(), date.coerceToDate())));\n    }\n    return Value(\n        uassertStatusOK(timeZone->formatDate(Value::kISOFormatString, date.coerceToDate())));\n}", "target": 0}
{"code": "bool FrameLoader::shouldUsePlugin(const KURL& url, const String& mimeType, bool hasFallback, bool& useFallback)\n{\n    if (m_client->shouldUsePluginDocument(mimeType)) {\n        useFallback = false;\n        return true;\n    }\n    if (m_frame->page() && (mimeType == \"image/tiff\" || mimeType == \"image/tif\" || mimeType == \"image/x-tiff\")) {\n        const PluginData* pluginData = m_frame->page()->pluginData();\n        String pluginName = pluginData ? pluginData->pluginNameForMimeType(mimeType) : String();\n        if (!pluginName.isEmpty() && !pluginName.contains(\"QuickTime\", false)) \n            return true;\n    }\n    ObjectContentType objectType = m_client->objectContentType(url, mimeType);\n    useFallback = objectType == ObjectContentNone && hasFallback;\n    return objectType == ObjectContentNone || objectType == ObjectContentNetscapePlugin || objectType == ObjectContentOtherPlugin;\n}", "target": 0}
{"code": "zzip_dir_close(ZZIP_DIR * dir)\n{\n    dir->refcount &= ~0x10000000;       \n    return zzip_dir_free(dir);\n}", "target": 0}
{"code": "static void nfs_idmap_quit_keyring(void)\n{\n\tkey_revoke(id_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_id_resolver);\n\tunregister_key_type(&key_type_id_resolver_legacy);\n\tput_cred(id_resolver_cache);\n}", "target": 0}
{"code": "ciEnv::~ciEnv() {\n  GUARDED_VM_ENTRY(\n      CompilerThread* current_thread = CompilerThread::current();\n      _factory->remove_symbols();\n      current_thread->set_env(NULL);\n  )\n}", "target": 0}
{"code": "static int em_grp45(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tswitch (ctxt->modrm_reg) {\n\tcase 2:  {\n\t\tlong int old_eip;\n\t\told_eip = ctxt->_eip;\n\t\tctxt->_eip = ctxt->src.val;\n\t\tctxt->src.val = old_eip;\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\tcase 4: \n\t\tctxt->_eip = ctxt->src.val;\n\t\tbreak;\n\tcase 5: \n\t\trc = em_jmp_far(ctxt);\n\t\tbreak;\n\tcase 6:\t\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static int create_vcpu_fd(struct kvm_vcpu *vcpu)\n{\n\treturn anon_inode_getfd(\"kvm-vcpu\", &kvm_vcpu_fops, vcpu, O_RDWR);\n}", "target": 0}
{"code": "void WriteValue(Message* m, const Value* value, int recursion) {\n  bool result;\n  if (recursion > kMaxRecursionDepth) {\n    LOG(WARNING) << \"Max recursion depth hit in WriteValue.\";\n    return;\n  }\n  m->WriteInt(value->GetType());\n  switch (value->GetType()) {\n    case Value::TYPE_NULL:\n    break;\n    case Value::TYPE_BOOLEAN: {\n      bool val;\n      result = value->GetAsBoolean(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_INTEGER: {\n      int val;\n      result = value->GetAsInteger(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_DOUBLE: {\n      double val;\n      result = value->GetAsDouble(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_STRING: {\n      std::string val;\n      result = value->GetAsString(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_BINARY: {\n      const base::BinaryValue* binary =\n          static_cast<const base::BinaryValue*>(value);\n      m->WriteData(binary->GetBuffer(), static_cast<int>(binary->GetSize()));\n      break;\n    }\n    case Value::TYPE_DICTIONARY: {\n      const DictionaryValue* dict = static_cast<const DictionaryValue*>(value);\n      WriteParam(m, static_cast<int>(dict->size()));\n      for (DictionaryValue::key_iterator it = dict->begin_keys();\n           it != dict->end_keys(); ++it) {\n        const Value* subval;\n        if (dict->GetWithoutPathExpansion(*it, &subval)) {\n          WriteParam(m, *it);\n          WriteValue(m, subval, recursion + 1);\n        } else {\n          NOTREACHED() << \"DictionaryValue iterators are filthy liars.\";\n        }\n      }\n      break;\n    }\n    case Value::TYPE_LIST: {\n      const ListValue* list = static_cast<const ListValue*>(value);\n      WriteParam(m, static_cast<int>(list->GetSize()));\n      for (size_t i = 0; i < list->GetSize(); ++i) {\n        const Value* subval;\n        if (list->Get(i, &subval)) {\n          WriteValue(m, subval, recursion + 1);\n        } else {\n          NOTREACHED() << \"ListValue::GetSize is a filthy liar.\";\n        }\n      }\n      break;\n    }\n  }\n}", "target": 0}
{"code": "PHPAPI size_t php_printf(const char *format, ...)\n{\n\tva_list args;\n\tsize_t ret;\n\tchar *buffer;\n\tsize_t size;\n\tva_start(args, format);\n\tsize = vspprintf(&buffer, 0, format, args);\n\tret = PHPWRITE(buffer, size);\n\tefree(buffer);\n\tva_end(args);\n\treturn ret;\n}", "target": 0}
{"code": "mono_method_get_last_managed (void)\n{\n\tMonoMethod *m = NULL;\n\tstack_walk (last_managed, FALSE, &m);\n\treturn m;\n}", "target": 0}
{"code": "TEST(BitTestMatchExpression, DoesNotMatchBinary2) {\n    BSONArray bas = BSON_ARRAY(21 << 22 << 23 << 24 << 25);\n    BSONArray bac = BSON_ARRAY(20 << 23 << 21);\n    std::vector<uint32_t> bitPositionsSet = bsonArrayToBitPositions(bas);\n    std::vector<uint32_t> bitPositionsClear = bsonArrayToBitPositions(bac);\n    BSONObj match1 = fromjson(\"{a: {$binary: 'AANgAAAAAAAAAAAAAAAAAAAAAAAA', $type: '00'}}\");\n    BSONObj match2 = fromjson(\"{a: {$binary: 'JANgqwetkqwklEWRbWERKKJREtbq', $type: '00'}}\");\n    BitsAllSetMatchExpression balls(\"a\", bitPositionsSet);\n    BitsAllClearMatchExpression ballc(\"a\", bitPositionsClear);\n    BitsAnySetMatchExpression banys(\"a\", bitPositionsSet);\n    BitsAnyClearMatchExpression banyc(\"a\", bitPositionsClear);\n    ASSERT_EQ((size_t)5, balls.numBitPositions());\n    ASSERT_EQ((size_t)3, ballc.numBitPositions());\n    ASSERT_EQ((size_t)5, banys.numBitPositions());\n    ASSERT_EQ((size_t)3, banyc.numBitPositions());\n    ASSERT(!balls.matchesSingleElement(match1[\"a\"]));\n    ASSERT(!balls.matchesSingleElement(match2[\"a\"]));\n    ASSERT(!ballc.matchesSingleElement(match1[\"a\"]));\n    ASSERT(!ballc.matchesSingleElement(match2[\"a\"]));\n    ASSERT(banys.matchesSingleElement(match1[\"a\"]));\n    ASSERT(banys.matchesSingleElement(match2[\"a\"]));\n    ASSERT(banyc.matchesSingleElement(match1[\"a\"]));\n    ASSERT(banyc.matchesSingleElement(match2[\"a\"]));\n}", "target": 0}
{"code": "void WebContentsImpl::RendererUnresponsive(\n    RenderWidgetHostImpl* render_widget_host) {\n  for (auto& observer : observers_)\n    observer.OnRendererUnresponsive(render_widget_host->GetProcess());\n  if (ShouldIgnoreUnresponsiveRenderer())\n    return;\n  if (!render_widget_host->renderer_initialized())\n    return;\n  if (delegate_)\n    delegate_->RendererUnresponsive(this, render_widget_host);\n}", "target": 0}
{"code": "static RList* entries(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinAddr* addr = NULL;\n\tpsxexe_header psxheader;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tif (!(addr = R_NEW0 (RBinAddr))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"PSXEXE Header truncated\\n\");\n\t\tr_list_free (ret);\n\t\tfree (addr);\n\t\treturn NULL;\n\t}\n\taddr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;\n\taddr->vaddr = psxheader.pc0;\n\tr_list_append (ret, addr);\n\treturn ret;\n}", "target": 1}
{"code": "xmlCopyAttribute(xmlAttributePtr attr) {\n    xmlAttributePtr cur;\n    cur = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));\n    if (cur == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xmlAttribute));\n    cur->type = XML_ATTRIBUTE_DECL;\n    cur->atype = attr->atype;\n    cur->def = attr->def;\n    cur->tree = xmlCopyEnumeration(attr->tree);\n    if (attr->elem != NULL)\n\tcur->elem = xmlStrdup(attr->elem);\n    if (attr->name != NULL)\n\tcur->name = xmlStrdup(attr->name);\n    if (attr->prefix != NULL)\n\tcur->prefix = xmlStrdup(attr->prefix);\n    if (attr->defaultValue != NULL)\n\tcur->defaultValue = xmlStrdup(attr->defaultValue);\n    return(cur);\n}", "target": 0}
{"code": "void RenderView::SetNextPageID(int32 next_page_id) {\n  DCHECK_EQ(next_page_id_, 1);\n  DCHECK(next_page_id >= next_page_id_);\n  next_page_id_ = next_page_id;\n}", "target": 0}
{"code": "void getconsxy(struct vc_data *vc, unsigned char *p)\n{\n\tp[0] = min(vc->vc_x, 0xFFu);\n\tp[1] = min(vc->vc_y, 0xFFu);\n}", "target": 0}
{"code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\tif (!uid_valid(uid) || !gid_valid(gid))\n \t\treturn -EINVAL;\n \tif ((creds->pid == task_tgid_vnr(current) ||\n\t     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::SetSurfaceNotInUseByCompositor(\n    scoped_refptr<ui::Texture>) {\n}", "target": 0}
{"code": "  bool operator!=(const LowerCaseString& rhs) const { return string_ != rhs.string_; }", "target": 0}
{"code": "batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n \tkfree(entry);\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n \t\tkfree_skb(skb_out);\n \t\tskb_out = NULL;\n \t\tgoto free;\n\t}\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\nfree:\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}", "target": 1}
{"code": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                     return 0;\n                 }\n                 i+=2;\n                block_length = data[i] * 256 + data[i+1];\n             }\n         }\n     }\n    return -1;\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::AcceleratedSurfaceBuffersSwapped(\n    const GpuHostMsg_AcceleratedSurfaceBuffersSwapped_Params& params_in_pixel,\n    int gpu_host_id) {\n  BufferPresentedCallback ack_callback = base::Bind(\n      &AcknowledgeBufferForGpu,\n      params_in_pixel.route_id,\n      gpu_host_id,\n      params_in_pixel.mailbox_name);\n  BuffersSwapped(params_in_pixel.size,\n                 gfx::Rect(params_in_pixel.size),\n                 params_in_pixel.scale_factor,\n                 params_in_pixel.mailbox_name,\n                 params_in_pixel.latency_info,\n                 ack_callback);\n}", "target": 0}
{"code": "RGWOp* RGWHandler_REST_S3Website::op_head()\n{\n  return get_obj_op(false);\n}", "target": 0}
{"code": "void AccessibilityUIElement::getChildrenWithRange(Vector<RefPtr<AccessibilityUIElement> >& children, unsigned location, unsigned length)\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return;\n    unsigned end = location + length;\n    for (unsigned i = location; i < end; i++) {\n        AtkObject* child = atk_object_ref_accessible_child(ATK_OBJECT(m_element), i);\n        children.append(AccessibilityUIElement::create(child));\n    }\n}", "target": 0}
{"code": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->err_code = buf[6] * 100 + buf[7];\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    if (value.slen < 0)\n        value.slen = 0;\n    pj_strdup(pool, &attr->reason, &value);\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, InWithSortAndLimitTrailingField) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << -1 << \"c\" << 1));\n    runQuerySortProjSkipNToReturn(fromjson(\"{a: {$in: [1, 2]}, b: {$gte: 0}}\"),\n                                  fromjson(\"{b: -1}\"),\n                                  BSONObj(),  \n                                  0,          \n                                  -1);        \n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {b:-1}, limit: 1, node: {sortKeyGen: \"\n        \"{node: {cscan: {dir: 1}}}}}}\");\n    assertSolutionExists(\n        \"{limit: {n: 1, node: {fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {a:1,b:-1,c:1}}}, \"\n        \" {ixscan: {pattern: {a:1,b:-1,c:1}}}]}}}}}}\");\n}", "target": 0}
{"code": "void cgit_plain_link(const char *name, const char *title, const char *class,\n\t\t     const char *head, const char *rev, const char *path)\n{\n\treporevlink(\"plain\", name, title, class, head, rev, path);\n}", "target": 0}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command,\n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out,\n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}", "target": 0}
{"code": "static void ff_layout_write_release(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\tff_layout_write_record_layoutstats_done(&hdr->task, hdr);\n\tif (test_bit(NFS_IOHDR_RESEND_PNFS, &hdr->flags)) {\n\t\tff_layout_send_layouterror(hdr->lseg);\n\t\tff_layout_reset_write(hdr, true);\n\t} else if (test_bit(NFS_IOHDR_RESEND_MDS, &hdr->flags))\n\t\tff_layout_reset_write(hdr, false);\n\tpnfs_generic_rw_release(data);\n}", "target": 0}
{"code": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\tif (! kcontrol)\n\t\treturn err;\n \tif (snd_BUG_ON(!card || !kcontrol->info))\n \t\tgoto error;\n \tid = kcontrol->id;\n \tdown_write(&card->controls_rwsem);\n \tif (snd_ctl_find_id(card, &id)) {\n \t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}", "target": 1}
{"code": "ECDSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                    RandomNumberGenerator& rng)\n   {\n   BigInt m(msg, msg_len, m_group.get_order_bits());\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   const BigInt k = generate_rfc6979_nonce(m_x, m_group.get_order(), m, m_rfc6979_hash);\n#else\n   const BigInt k = m_group.random_scalar(rng);\n#endif\n   const BigInt k_inv = m_group.inverse_mod_order(k);\n   const BigInt r = m_group.mod_order(\n      m_group.blinded_base_point_multiply_x(k, rng, m_ws));\n   const BigInt xrm = m_group.mod_order(m_group.multiply_mod_order(m_x, r) + m);\n   const BigInt s = m_group.multiply_mod_order(k_inv, xrm);\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"During ECDSA signature generated zero r/s\");\n   return BigInt::encode_fixed_length_int_pair(r, s, m_group.get_order_bytes());\n   }", "target": 1}
{"code": "static int uio_mmap_physical(struct vm_area_struct *vma)\n {\n \tstruct uio_device *idev = vma->vm_private_data;\n \tint mi = uio_find_mem_index(vma);\n \tif (mi < 0)\n \t\treturn -EINVAL;\n\tvma->vm_ops = &uio_physical_vm_ops;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \treturn remap_pfn_range(vma,\n \t\t\t       vma->vm_start,\n\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n \t\t\t       vma->vm_end - vma->vm_start,\n \t\t\t       vma->vm_page_prot);\n }", "target": 1}
{"code": "void HTTPSession::onCertificate(uint16_t certId,\n                                std::unique_ptr<IOBuf> authenticator) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE on\" << *this << \", certId=\" << certId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  bool isValid = false;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::UPSTREAM,\n          certId,\n          std::move(authenticator));\n    } else {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::DOWNSTREAM,\n          certId,\n          std::move(authenticator));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (isValid) {\n    VLOG(4) << \"Successfully validated the authenticator provided by the peer.\";\n  } else {\n    VLOG(4) << \"Failed to validate the authenticator provided by the peer\";\n  }\n}", "target": 0}
{"code": "ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\nbad_block:\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\tentry = BFIRST(bh);\n\terror = ext4_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EFSCORRUPTED)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}", "target": 1}
{"code": "filesystem_list_open_files_completed_cb (DBusGMethodInvocation *context,\n                                         Device *device,\n                                         gboolean job_was_cancelled,\n                                         int status,\n                                         const char *stderr,\n                                         const char *stdout,\n                                         gpointer user_data)\n{\n  if ((WEXITSTATUS (status) == 0 || WEXITSTATUS (status) == 1) && !job_was_cancelled)\n    {\n      GPtrArray *processes;\n      processes = g_ptr_array_new ();\n      lsof_parse (stdout, processes);\n      dbus_g_method_return (context, processes);\n      g_ptr_array_foreach (processes, (GFunc) g_value_array_free, NULL);\n      g_ptr_array_free (processes, TRUE);\n    }\n  else\n    {\n      throw_error (context,\n                   ERROR_FAILED,\n                   \"Error listing open files: lsof exited with exit code %d: %s\",\n                   WEXITSTATUS (status),\n                   stderr);\n    }\n}", "target": 0}
{"code": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\ttuner_dbg(\"%s called\\n\", __func__);\n\tmutex_lock(&priv->lock);\n\tkfree(priv->ctrl.fname);\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\trc = -ENOMEM;\n\t}\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\treturn rc;\n}", "target": 1}
{"code": "void Item_cache::print(String *str, enum_query_type query_type)\n{\n  if (value_cached)\n  {\n    print_value(str);\n    return;\n  }\n  str->append(STRING_WITH_LEN(\"<cache>(\"));\n  if (example)\n    example->print(str, query_type);\n  else\n    Item::print(str, query_type);\n  str->append(')');\n}", "target": 0}
{"code": "void bio_chain(struct bio *bio, struct bio *parent)\n{\n\tBUG_ON(bio->bi_private || bio->bi_end_io);\n\tbio->bi_private = parent;\n\tbio->bi_end_io\t= bio_chain_endio;\n\tbio_inc_remaining(parent);\n}", "target": 0}
{"code": "ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {\n  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();\n#if BUILDFLAG(USE_ALLOCATOR_SHIM)\n  if (cmdline->HasSwitch(switches::kMemlog) ||\n      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {\n    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {\n      LOG(ERROR) << \"--\" << switches::kEnableHeapProfiling\n                 << \" specified with --\" << switches::kMemlog\n                 << \"which are not compatible. Memlog will be disabled.\";\n      return Mode::kNone;\n    }\n    std::string mode;\n    if (cmdline->HasSwitch(switches::kMemlog)) {\n      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);\n    } else {\n      mode = base::GetFieldTrialParamValueByFeature(\n           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);\n     }\n    if (mode == switches::kMemlogModeAll)\n      return Mode::kAll;\n    if (mode == switches::kMemlogModeMinimal)\n      return Mode::kMinimal;\n    if (mode == switches::kMemlogModeBrowser)\n      return Mode::kBrowser;\n    if (mode == switches::kMemlogModeGpu)\n      return Mode::kGpu;\n    if (mode == switches::kMemlogModeRendererSampling)\n      return Mode::kRendererSampling;\n    DLOG(ERROR) << \"Unsupported value: \\\"\" << mode << \"\\\" passed to --\"\n                << switches::kMemlog;\n   }\n   return Mode::kNone;\n #else\n  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))\n      << \"--\" << switches::kMemlog\n      << \" specified but it will have no effect because the use_allocator_shim \"\n      << \"is not available in this build.\";\n  return Mode::kNone;\n #endif\n }", "target": 1}
{"code": "void OmniboxViewWin::OnLButtonDown(UINT keys, const CPoint& point) {\n  TrackMousePosition(kLeft, point);\n  if (gaining_focus_.get()) {\n    saved_selection_for_focus_change_.cpMin = -1;\n    DefWindowProc(WM_LBUTTONDOWN, keys, MAKELPARAM(point.x, point.y));\n    DefWindowProc(WM_LBUTTONUP, keys, MAKELPARAM(point.x, point.y));\n  }\n  const bool is_triple_click = tracking_double_click_ &&\n      views::NativeTextfieldWin::IsDoubleClick(double_click_point_, point,\n          GetCurrentMessage()->time - double_click_time_);\n  tracking_double_click_ = false;\n  if (!gaining_focus_.get() && !is_triple_click)\n    OnPossibleDrag(point);\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  OnBeforePossibleChange();\n  DefWindowProc(WM_LBUTTONDOWN, keys,\n                MAKELPARAM(ClipXCoordToVisibleText(point.x, is_triple_click),\n                           point.y));\n  OnAfterPossibleChange();\n  gaining_focus_.reset();\n}", "target": 0}
{"code": "static int mptctl_do_reset(unsigned long arg)\n{\n\tstruct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;\n\tstruct mpt_ioctl_diag_reset krinfo;\n\tMPT_ADAPTER\t\t*iocp;\n\tif (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_do_reset - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_diag_reset struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, urinfo);\n\t\treturn -EFAULT;\n\t}\n\tif (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s@%d::mptctl_do_reset - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, krinfo.hdr.iocnum);\n\t\treturn -ENODEV; \n\t}\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"mptctl_do_reset called.\\n\",\n\t    iocp->name));\n\tif (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) {\n\t\tprintk (MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_reset - reset failed.\\n\",\n\t\t\tiocp->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void SavePackage::StopObservation() {\n  DCHECK(download_);\n  DCHECK(download_manager_);\n  download_->RemoveObserver(this);\n  download_ = NULL;\n  download_manager_ = NULL;\n}", "target": 0}
{"code": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n    clear(); \n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n    return response();\n}", "target": 1}
{"code": "magic_stream(struct magic_set *ms, php_stream *stream)\n{\n\tif (ms == NULL)\n\t\treturn NULL;\n\treturn file_or_stream(ms, NULL, stream);\n}", "target": 0}
{"code": "static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n \tint newly_acked_sacked = prior_unsacked -\n \t\t\t\t (tp->packets_out - tp->sacked_out);\n \ttp->prr_delivered += newly_acked_sacked;\n \tif (delta < 0) {\n \t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}", "target": 1}
{"code": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(rng);\n\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n\tif (oalg->rng_make_random) {\n\t\trng->generate = generate;\n\t\trng->seed = rngapi_reset;\n\t\trng->seedsize = oalg->seedsize;\n\t\treturn 0;\n\t}\n\trng->generate = alg->generate;\n\trng->seed = alg->seed;\n\trng->seedsize = alg->seedsize;\n\treturn 0;\n}", "target": 1}
{"code": "        void dump_xml(Formatter *f) const {\n          encode_xml(\"Key\", key, f);\n          encode_xml(\"Value\", value, f);\n        }", "target": 0}
{"code": "size_t TensorSliceWriter::MaxBytesPerElement(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      LOG(FATAL) << \"MaxBytesPerElement not implemented for dtype: \" << dt;\n  }\n  return 0;\n}", "target": 1}
{"code": "static long cec_adap_g_log_addrs(struct cec_adapter *adap,\n\t\t\t\t struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\tmutex_lock(&adap->lock);\n\tlog_addrs = adap->log_addrs;\n\tif (!adap->is_configured)\n\t\tmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\n\t\t       sizeof(log_addrs.log_addr));\n\tmutex_unlock(&adap->lock);\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "uipbuf_get_len_field(struct uip_ip_hdr *hdr)\n{\n  return ((uint16_t)(hdr->len[0]) << 8) + hdr->len[1];\n}", "target": 0}
{"code": "static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)\n{\n\tsize_t offset;\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\toffset = ntlm_av_pair_get_next_offset(pAvPair);\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}", "target": 1}
{"code": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), std::min(len, buffer_received.size()));\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n  return result;\n}", "target": 1}
{"code": "static int print_branch_option(const char *refname, const struct object_id *oid,\n\t\t\t       int flags, void *cb_data)\n{\n\tchar *name = (char *)refname;\n\thtml_option(name, name, ctx.qry.head);\n\treturn 0;\n}", "target": 0}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n \tsize_t len;\n \tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n \t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n \t\t    malloc(len) :\n \t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "Status MakeArgTuple(const PyCall* call, TFE_Context* ctx, PyObject** tuple) {\n  int64_t n = call->ins.size();\n  PyObject* lst = PyList_New(n);\n  CHECK(lst);\n  const char* device_name = nullptr;\n  if (call->device != nullptr && !IsCPUDevice(call->device))\n    device_name = call->device->name().c_str();\n  for (int64_t i = 0; i < n; ++i) {\n    PyObject* arg = nullptr;\n    if (call->eager) {\n      Tensor t = call->ins[i];\n      arg = EagerTensorFromHandle(tensorflow::wrap(\n          tensorflow::unwrap(ctx)->CreateLocalHandleFromTFTensor(t,\n                                                                 device_name)));\n      if (arg == nullptr) {\n        Py_DECREF(lst);\n        return errors::Internal(\"Unable to procure EagerTensor from Tensor.\");\n      }\n    } else {\n      Status s = TensorToNdarray(call->ins[i], &arg);\n      if (!s.ok()) {\n        Py_DECREF(lst);\n        return s;\n      }\n      arg = PyArray_Return(reinterpret_cast<PyArrayObject*>(arg));\n    }\n    PyList_SetItem(lst, i, arg);\n  }\n  *tuple = Py_BuildValue(\"(ssN)\", call->token.c_str(), device_name, lst);\n  CHECK(*tuple);\n  return OkStatus();\n}", "target": 1}
{"code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRDyldCache *cache = R_NEW0 (RDyldCache);\n\tmemcpy (cache->magic, \"dyldcac\", 7);\n\tcache->buf = r_buf_ref (buf);\n\tpopulate_cache_headers (cache);\n\tif (!cache->hdr) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->locsym = r_dyld_locsym_new (cache);\n\tcache->rebase_infos = get_rebase_infos (bf, cache);\n\tif (cache->rebase_infos) {\n\t\tif (!rebase_infos_get_slide (cache)) {\n\t\t\tif (!pending_bin_files) {\n\t\t\t\tpending_bin_files = r_list_new ();\n\t\t\t\tif (!pending_bin_files) {\n\t\t\t\t\tr_dyldcache_free (cache);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_push (pending_bin_files, bf);\n\t\t\tswizzle_io_read (cache, bf->rbin->iob.io);\n\t\t}\n\t}\n\t*bin_obj = cache;\n\treturn true;\n}", "target": 1}
{"code": "static void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}", "target": 0}
{"code": "sec_connect(char *server, char *username, char *domain, char *password, RD_BOOL reconnect)\n{\n\tuint32 selected_proto;\n\tstruct stream mcs_data;\n\tif (!mcs_connect_start(server, username, domain, password, reconnect, &selected_proto))\n\t\treturn False;\n\tmcs_data.size = 512;\n\tmcs_data.p = mcs_data.data = (uint8 *) xmalloc(mcs_data.size);\n\tsec_out_mcs_data(&mcs_data, selected_proto);\n\tif (!mcs_connect_finalize(&mcs_data))\n\t\treturn False;\n\tif (g_encryption)\n\t\tsec_establish_key();\n\txfree(mcs_data.data);\n\treturn True;\n}", "target": 0}
{"code": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  \n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n    if (name != NULL)\n    {\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n    return match;\n}", "target": 1}
{"code": "static int __init setup_acpi_rsdp(char *arg)\n{\n\tif (kstrtoul(arg, 16, &acpi_rsdp))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "bool ParseAttrValue(StringPiece type, StringPiece text, AttrValue* out) {\n  string field_name;\n  bool is_list = absl::ConsumePrefix(&type, \"list(\");\n  if (absl::ConsumePrefix(&type, \"string\")) {\n    field_name = \"s\";\n  } else if (absl::ConsumePrefix(&type, \"int\")) {\n    field_name = \"i\";\n  } else if (absl::ConsumePrefix(&type, \"float\")) {\n    field_name = \"f\";\n  } else if (absl::ConsumePrefix(&type, \"bool\")) {\n    field_name = \"b\";\n  } else if (absl::ConsumePrefix(&type, \"type\")) {\n    field_name = \"type\";\n  } else if (absl::ConsumePrefix(&type, \"shape\")) {\n    field_name = \"shape\";\n  } else if (absl::ConsumePrefix(&type, \"tensor\")) {\n    field_name = \"tensor\";\n  } else if (absl::ConsumePrefix(&type, \"func\")) {\n    field_name = \"func\";\n  } else if (absl::ConsumePrefix(&type, \"placeholder\")) {\n    field_name = \"placeholder\";\n  } else {\n    return false;\n  }\n  if (is_list && !absl::ConsumePrefix(&type, \")\")) {\n    return false;\n  }\n  string to_parse;\n  if (is_list) {\n    StringPiece cleaned = text;\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    str_util::RemoveTrailingWhitespace(&cleaned);\n    if (cleaned.size() < 2 || cleaned[0] != '[' ||\n        cleaned[cleaned.size() - 1] != ']') {\n      return false;\n    }\n    cleaned.remove_prefix(1);\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    if (cleaned.size() == 1) {\n      out->Clear();\n      out->mutable_list();\n      return true;\n    }\n    to_parse = strings::StrCat(\"list { \", field_name, \": \", text, \" }\");\n  } else {\n    to_parse = strings::StrCat(field_name, \": \", text);\n  }\n  return ProtoParseFromString(to_parse, out);\n}", "target": 1}
{"code": "Jsi_RC Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr)\n{\n    Jsi_Regex *re;\n    int regexec_flags = 0;\n    if (rc)\n        *rc = 0;\n    if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) \n        return Jsi_LogError(\"expected pattern\");\n    re = pattern->d.obj->d.robj;\n    regex_t *reg = &re->reg;\n    regmatch_t pos = {};\n    if (dStr)\n        Jsi_DSInit(dStr);\n    int r  = regexec(reg, v, 1, &pos, regexec_flags);\n    if (r >= REG_BADPAT) {\n        char buf[100];\n        regerror(r, reg, buf, sizeof(buf));\n        return Jsi_LogError(\"error while matching pattern: %s\", buf);\n    }\n    if (r != REG_NOMATCH) {\n        if (rc) *rc = 1;\n        if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 &&  pos.rm_eo >= pos.rm_so)\n            Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "void FrameLoader::applyUserAgent(ResourceRequest& request)\n{\n    String userAgent = this->userAgent(request.url());\n    ASSERT(!userAgent.isNull());\n    request.setHTTPUserAgent(userAgent);\n}", "target": 0}
{"code": "static void kvm_pv_disable_apf(void)\n{\n\tif (!__this_cpu_read(apf_reason.enabled))\n\t\treturn;\n\twrmsrl(MSR_KVM_ASYNC_PF_EN, 0);\n\t__this_cpu_write(apf_reason.enabled, 0);\n\tprintk(KERN_INFO\"Unregister pv shared memory for cpu %d\\n\",\n\t       smp_processor_id());\n}", "target": 0}
{"code": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 1 );\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 1}
{"code": "PHPAPI char *php_replace_controlchars(char *str)\n{\n\treturn php_replace_controlchars_ex(str, strlen(str));\n}", "target": 0}
{"code": "xfs_ioctl_setattr_prepare_dax(\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode            *inode = VFS_I(ip);\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn;\n\tif (xfs_has_dax_always(mp) || xfs_has_dax_never(mp))\n\t\treturn;\n\tif (((fa->fsx_xflags & FS_XFLAG_DAX) &&\n\t    !(ip->i_diflags2 & XFS_DIFLAG2_DAX)) ||\n\t    (!(fa->fsx_xflags & FS_XFLAG_DAX) &&\n\t     (ip->i_diflags2 & XFS_DIFLAG2_DAX)))\n\t\td_mark_dontcache(inode);\n}", "target": 0}
{"code": "static GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  \n          lua_assert(isgray(curr));\n          gray2black(curr);  \n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  \n        }\n        else {  \n          if (!iswhite(curr)) {  \n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  \n              changeage(curr, G_TOUCHED2, G_OLD);  \n            gray2black(curr);  \n          }\n          *p = *next;  \n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  \n          *p = th->gclist;  \n        else  \n          p = &th->gclist;  \n        break;\n      }\n      default: lua_assert(0);  \n    }\n  }\n  return p;\n}", "target": 1}
{"code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid *buf;\n\tint err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (memcpy_from_msg(buf, msg, len)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, buf, len, msg->msg_flags);\n\telse\n\t\terr = -ENOTCONN;\n\trelease_sock(sk);\n\tkfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "void AudioOutputSpeech::addFrameToBuffer(const QByteArray &qbaPacket, unsigned int iSeq) {\n\tQMutexLocker lock(&qmJitter);\n\tif (qbaPacket.size() < 2)\n\t\treturn;\n\tPacketDataStream pds(qbaPacket);\n\tpds.next();\n\tint samples = 0;\n\tif (umtType == MessageHandler::UDPVoiceOpus) {\n\t\tint size;\n\t\tpds >> size;\n\t\tsize &= 0x1fff;\n\t\tconst QByteArray &qba = pds.dataBlock(size);\n\t\tconst unsigned char *packet = reinterpret_cast<const unsigned char*>(qba.constData());\n#ifdef USE_OPUS\n\t\tint frames = opus_packet_get_nb_frames(packet, size);\n\t\tsamples = frames * opus_packet_get_samples_per_frame(packet, SAMPLE_RATE);\n#else\n\t\treturn;\n#endif\n\t\tQ_ASSERT(samples % iFrameSize == 0);\n\t} else {\n\t\tunsigned int header = 0;\n\t\tdo {\n\t\t\theader = static_cast<unsigned char>(pds.next());\n\t\t\tsamples += iFrameSize;\n\t\t\tpds.skip(header & 0x7f);\n\t\t} while ((header & 0x80) && pds.isValid());\n\t}\n\tif (pds.isValid()) {\n\t\tJitterBufferPacket jbp;\n\t\tjbp.data = const_cast<char *>(qbaPacket.constData());\n\t\tjbp.len = qbaPacket.size();\n\t\tjbp.span = samples;\n\t\tjbp.timestamp = iFrameSize * iSeq;\n#ifdef REPORT_JITTER\n\t\tif (g.s.bUsage && (umtType != MessageHandler::UDPVoiceSpeex) && p && ! p->qsHash.isEmpty() && (p->qlTiming.count() < 3000)) {\n\t\t\tQMutexLocker qml(& p->qmTiming);\n\t\t\tClientUser::JitterRecord jr;\n\t\t\tjr.iSequence = iSeq;\n\t\t\tjr.iFrames = frames;\n\t\t\tjr.uiElapsed = p->tTiming.restart();\n\t\t\tif (! p->qlTiming.isEmpty()) {\n\t\t\t\tjr.iFrames -= p->iFrames;\n\t\t\t\tjr.iSequence -= p->iSequence + p->iFrames;\n\t\t\t}\n\t\t\tp->iFrames = frames;\n\t\t\tp->iSequence = iSeq;\n\t\t\tp->qlTiming.append(jr);\n\t\t}\n#endif\n\t\tjitter_buffer_put(jbJitter, &jbp);\n\t}\n}", "target": 1}
{"code": "TEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *attrs = NULL;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n \tif (!type_props)\n \t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tattrs = malloc(sizeof(TEE_Attribute) * attr_count);\n \tif (!attrs)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n \tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n \t\t\t    attrs);\n \tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\nout:\n\tfree(attrs);\n\treturn res;\n}", "target": 1}
{"code": "AP_DECLARE(const char *) ap_get_useragent_host(request_rec *r,\n                                               int type, int *str_is_ip)\n{\n    conn_rec *conn = r->connection;\n    int hostname_lookups;\n    int ignored_str_is_ip;\n    if (!r->useragent_addr || (r->useragent_addr == conn->client_addr)) {\n        return ap_get_remote_host(conn, r->per_dir_config, type, str_is_ip);\n    }\n    if (!str_is_ip) { \n        str_is_ip = &ignored_str_is_ip;\n    }\n    *str_is_ip = 0;\n    hostname_lookups = ((core_dir_config *)\n                        ap_get_core_module_config(r->per_dir_config))\n                            ->hostname_lookups;\n    if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {\n        hostname_lookups = HOSTNAME_LOOKUP_OFF;\n    }\n    if (type != REMOTE_NOLOOKUP\n        && r->useragent_host == NULL\n        && (type == REMOTE_DOUBLE_REV\n        || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {\n        if (apr_getnameinfo(&r->useragent_host, r->useragent_addr, 0)\n            == APR_SUCCESS) {\n            ap_str_tolower(r->useragent_host);\n            if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {\n                r->double_reverse = do_double_reverse(r->double_reverse,\n                                                      r->useragent_host,\n                                                      r->useragent_addr,\n                                                      r->pool);\n                if (r->double_reverse != 1) {\n                    r->useragent_host = NULL;\n                }\n            }\n        }\n        if (r->useragent_host == NULL) {\n            r->useragent_host = \"\";\n        }\n    }\n    if (type == REMOTE_DOUBLE_REV) {\n        r->double_reverse = do_double_reverse(r->double_reverse,\n                                              r->useragent_host,\n                                              r->useragent_addr, r->pool);\n        if (r->double_reverse == -1) {\n            return NULL;\n        }\n    }\n    if (r->useragent_host != NULL && r->useragent_host[0] != '\\0') {\n        return r->useragent_host;\n    }\n    else {\n        if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {\n            return NULL;\n        }\n        else {\n            *str_is_ip = 1;\n            return r->useragent_ip;\n        }\n    }\n}", "target": 0}
{"code": "int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n{\n    struct yyguts_t dummy_yyguts;\n    re_yyset_extra (yy_user_defined, &dummy_yyguts);\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n    return yy_init_globals ( *ptr_yy_globals );", "target": 1}
{"code": "base::string16 GetRelyingPartyIdString(\n    AuthenticatorRequestDialogModel* dialog_model) {\n  static constexpr char kRpIdUrlPrefix[] = \"https:\n  static constexpr int kDialogWidth = 300;\n   const auto& rp_id = dialog_model->relying_party_id();\n   DCHECK(!rp_id.empty());\n   GURL rp_id_url(kRpIdUrlPrefix + rp_id);\n  auto max_static_string_length = gfx::GetStringWidthF(\n      l10n_util::GetStringUTF16(IDS_WEBAUTHN_GENERIC_TITLE), gfx::FontList(),\n      gfx::Typesetter::DEFAULT);\n  return url_formatter::ElideHost(rp_id_url, gfx::FontList(),\n                                  kDialogWidth - max_static_string_length);\n }", "target": 1}
{"code": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n {\n \tconst struct aodv_hello *ah;\n \tswitch (ep->type) {\n \tcase AODV_EXT_HELLO:\n \t\tah = (const struct aodv_hello *)(const void *)ep;\n \t\tND_TCHECK(*ah);\n \t\tif (length < sizeof(struct aodv_hello))\n \t\t\tgoto trunc;\n \t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n \t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n \t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}", "target": 1}
{"code": "bool InstanceKlass::should_be_initialized() const {\n  return !is_initialized();\n}", "target": 0}
{"code": "int adis_update_scan_mode(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tconst struct iio_chan_spec *chan;\n\tunsigned int scan_count;\n\tunsigned int i, j;\n\t__be16 *tx, *rx;\n\tkfree(adis->xfer);\n\tkfree(adis->buffer);\n\tif (adis->burst && adis->burst->en)\n\t\treturn adis_update_scan_mode_burst(indio_dev, scan_mask);\n\tscan_count = indio_dev->scan_bytes / 2;\n\tadis->xfer = kcalloc(scan_count + 1, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\trx = adis->buffer;\n\ttx = rx + scan_count;\n\tspi_message_init(&adis->msg);\n\tfor (j = 0; j <= scan_count; j++) {\n\t\tadis->xfer[j].bits_per_word = 8;\n\t\tif (j != scan_count)\n\t\t\tadis->xfer[j].cs_change = 1;\n\t\tadis->xfer[j].len = 2;\n\t\tadis->xfer[j].delay_usecs = adis->data->read_delay;\n\t\tif (j < scan_count)\n\t\t\tadis->xfer[j].tx_buf = &tx[j];\n\t\tif (j >= 1)\n\t\t\tadis->xfer[j].rx_buf = &rx[j - 1];\n\t\tspi_message_add_tail(&adis->xfer[j], &adis->msg);\n\t}\n\tchan = indio_dev->channels;\n\tfor (i = 0; i < indio_dev->num_channels; i++, chan++) {\n\t\tif (!test_bit(chan->scan_index, scan_mask))\n\t\t\tcontinue;\n\t\tif (chan->scan_type.storagebits == 32)\n\t\t\t*tx++ = cpu_to_be16((chan->address + 2) << 8);\n\t\t*tx++ = cpu_to_be16(chan->address << 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool Archive::Close()\n{\n#ifdef USE_ARCMEM\n  if (ArcMem.Unload())\n    return true;\n#endif\n  return File::Close();\n}", "target": 0}
{"code": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\tgenl_lock_all();\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\tif (family == &genl_ctrl) {\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_locked;\n\t}\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\tgenl_unlock_all();\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\treturn 0;\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}", "target": 1}
{"code": "static void umocktypes_free_bool_ptr(bool** value)\n{\n    if (*value != NULL)\n    {\n        my_gballoc_free(*value);\n    }\n}", "target": 0}
{"code": "bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=(size_t)Arc.FileHead.PackSize;\n    if (DataSize>ASIZE(Target)-1)\n      return false;\n    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)\n      return false;\n    Target[DataSize]=0;\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n    wchar TargetW[NM];\n    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n      return false;\n    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n        !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))\n      return false;\n    return UnixSymlink(Cmd,Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}", "target": 1}
{"code": "CbrDetectorRemote::Result CbrDetectorRemote::Decrypt(cricket::MediaType media_type,\n\t\t\t\t\t\tconst std::vector<uint32_t>& csrcs,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> additional_data,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> encrypted_frame,\n\t\t\t\t\t\trtc::ArrayView<uint8_t> frame)\n{\n\tconst uint8_t *src = encrypted_frame.data();\n\tuint8_t *dst = frame.data();\n\tuint32_t data_len = encrypted_frame.size();\n\tif (media_type == cricket::MEDIA_TYPE_AUDIO) {\n\t\tif (data_len == frame_size && frame_size >= 40) {\n\t\t\tframe_count++;\n\t\t\tif (frame_count > 200 && !detected) {\n\t\t\t\tinfo(\"CBR detector: remote cbr detected\\n\");\n\t\t\t\tdetected = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tframe_count = 0;\n\t\t\tframe_size = data_len;\n\t\t\tif (detected) {\n\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");\n\t\t\t\tdetected = false;\n\t\t\t}\n\t\t}\n\t}\n\tmemcpy(dst, src, data_len);\nout:\n\treturn CbrDetectorRemote::Result(CbrDetectorRemote::Status::kOk, data_len);\n}", "target": 1}
{"code": "videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\tdprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}", "target": 1}
{"code": "TfLiteStatus PrepareHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 0);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n  TF_LITE_ENSURE(context, !params->table_name.empty());\n  TF_LITE_ENSURE(context, (params->key_dtype == kTfLiteInt64 &&\n                           params->value_dtype == kTfLiteString) ||\n                              (params->key_dtype == kTfLiteString &&\n                               params->value_dtype == kTfLiteInt64));\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  TF_LITE_ENSURE(context, resource_handle_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, resource_handle_tensor->type, kTfLiteInt32);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, resource_handle_tensor, outputSize);\n}", "target": 1}
{"code": "std::unique_ptr<MatchExpression> InMatchExpression::shallowClone() const {\n    auto next = stdx::make_unique<InMatchExpression>(path());\n    next->setCollator(_collator);\n    if (getTag()) {\n        next->setTag(getTag()->clone());\n    }\n    next->_hasNull = _hasNull;\n    next->_hasEmptyArray = _hasEmptyArray;\n    next->_equalitySet = _equalitySet;\n    next->_originalEqualityVector = _originalEqualityVector;\n    for (auto&& regex : _regexes) {\n        std::unique_ptr<RegexMatchExpression> clonedRegex(\n            static_cast<RegexMatchExpression*>(regex->shallowClone().release()));\n        next->_regexes.push_back(std::move(clonedRegex));\n    }\n    return std::move(next);\n}", "target": 0}
{"code": "InlineBoxPosition AdjustInlineBoxPositionForPrimaryDirection(\n    InlineBox* inline_box,\n    int caret_offset) {\n  if (caret_offset == inline_box->CaretRightmostOffset()) {\n    InlineBox* const next_box = inline_box->NextLeafChild();\n    if (!next_box || next_box->BidiLevel() >= inline_box->BidiLevel())\n      return InlineBoxPosition(inline_box, caret_offset);\n    const unsigned level = next_box->BidiLevel();\n    InlineBox* const prev_box =\n        InlineBoxTraversal::FindLeftBidiRun(*inline_box, level);\n    if (prev_box && prev_box->BidiLevel() == level)\n      return InlineBoxPosition(inline_box, caret_offset);\n    InlineBox* const result_box =\n        InlineBoxTraversal::FindRightBoundaryOfEntireBidiRun(*inline_box,\n                                                             level);\n    return InlineBoxPosition(result_box, result_box->CaretRightmostOffset());\n  }\n  if (IsStartOfDifferentDirection(inline_box))\n    return InlineBoxPosition(inline_box, caret_offset);\n  const unsigned level = inline_box->PrevLeafChild()->BidiLevel();\n  InlineBox* const next_box =\n      InlineBoxTraversal::FindRightBidiRun(*inline_box, level);\n  if (next_box && next_box->BidiLevel() == level)\n    return InlineBoxPosition(inline_box, caret_offset);\n  InlineBox* const result_box =\n      InlineBoxTraversal::FindLeftBoundaryOfEntireBidiRun(*inline_box, level);\n  return InlineBoxPosition(result_box, result_box->CaretLeftmostOffset());\n}", "target": 0}
{"code": "static inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\treturn !kmem_cache_debug(s);\n#else\n\treturn false;\n#endif\n}", "target": 0}
{"code": "DefragTracker *DefragGetTrackerFromHash (Packet *p)\n{\n    DefragTracker *dt = NULL;\n    uint32_t key = DefragHashGetKey(p);\n    DefragTrackerHashRow *hb = &defragtracker_hash[key];\n    DRLOCK_LOCK(hb);\n    if (hb->head == NULL) {\n        dt = DefragTrackerGetNew(p);\n        if (dt == NULL) {\n            DRLOCK_UNLOCK(hb);\n            return NULL;\n        }\n        hb->head = dt;\n        hb->tail = dt;\n        DefragTrackerInit(dt,p);\n        DRLOCK_UNLOCK(hb);\n        return dt;\n    }\n    dt = hb->head;\n    if (dt->remove || DefragTrackerCompare(dt, p) == 0) {\n        DefragTracker *pdt = NULL; \n        while (dt) {\n            pdt = dt;\n            dt = dt->hnext;\n            if (dt == NULL) {\n                dt = pdt->hnext = DefragTrackerGetNew(p);\n                if (dt == NULL) {\n                    DRLOCK_UNLOCK(hb);\n                    return NULL;\n                }\n                hb->tail = dt;\n                dt->hprev = pdt;\n                DefragTrackerInit(dt,p);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n            if (DefragTrackerCompare(dt, p) != 0) {\n                if (dt->hnext) {\n                    dt->hnext->hprev = dt->hprev;\n                }\n                if (dt->hprev) {\n                    dt->hprev->hnext = dt->hnext;\n                }\n                if (dt == hb->tail) {\n                    hb->tail = dt->hprev;\n                }\n                dt->hnext = hb->head;\n                dt->hprev = NULL;\n                hb->head->hprev = dt;\n                hb->head = dt;\n                SCMutexLock(&dt->lock);\n                (void) DefragTrackerIncrUsecnt(dt);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n        }\n    }\n    SCMutexLock(&dt->lock);\n    (void) DefragTrackerIncrUsecnt(dt);\n    DRLOCK_UNLOCK(hb);\n    return dt;\n}", "target": 1}
{"code": "  bool IsViewFocused(ViewID vid) {\n    return ui_test_utils::IsViewFocused(browser(), vid);\n  }", "target": 0}
{"code": "char *suhosin_decrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key, char **where TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n    int o_name_len = name_len;\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n\tint l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\ndecrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n            memcpy(*where, name, o_name_len);\n            *where += o_name_len;\n            **where = '='; *where +=1;\n\t        memcpy(*where, value, value_len);\n\t        *where += value_len;\n\t\t\treturn *where;\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto decrypt_return_plain;\n\t\t}\n\t}\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\tvalue_len = php_url_decode(buf2, value_len);\n\td = suhosin_decrypt_string(buf2, value_len, buf, name_len, key, &l, SUHOSIN_G(cookie_checkraddr) TSRMLS_CC);\n    if (d == NULL) {\n        goto skip_cookie;\n    }\n\td_url = php_url_encode(d, l, &l);\n\tefree(d);\n    memcpy(*where, name, o_name_len);\n    *where += o_name_len;\n    **where = '=';*where += 1;\n\tmemcpy(*where, d_url, l);\n\t*where += l;\n\tefree(d_url);\nskip_cookie:\n\tif (buf != buffer) {\n\t\tefree(buf);\n\t}\n\tif (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn *where;\n}", "target": 1}
{"code": "write(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& unionId =\n        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        unionId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == unionId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}", "target": 1}
{"code": "build_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "target": 1}
{"code": "static void adpt_i2o_post_wait_complete(u32 context, int status)\n{\n\tstruct adpt_i2o_post_wait_data *p1 = NULL;\n\tcontext &= 0x7fff;\n\tspin_lock(&adpt_post_wait_lock);\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tif(p1->id == context) {\n\t\t\tp1->status = status;\n\t\t\tspin_unlock(&adpt_post_wait_lock);\n\t\t\twake_up_interruptible(p1->wq);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&adpt_post_wait_lock);\n\tprintk(KERN_DEBUG\"dpti: Could Not find task %d in wait queue\\n\",context);\n\tprintk(KERN_DEBUG\"      Tasks in wait queue:\\n\");\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tprintk(KERN_DEBUG\"           %d\\n\",p1->id);\n\t}\n\treturn;\n}", "target": 1}
{"code": "static char *exif_get_sectionlist(int sectionlist)\n{\n\tint i, len, ml = 0;\n\tchar *sections;\n\tfor(i=0; i<SECTION_COUNT; i++) {\n\t\tml += strlen(exif_get_sectionname(i))+2;\n\t}\n\tsections = safe_emalloc(ml, 1, 1);\n\tsections[0] = '\\0';\n\tlen = 0;\n\tfor(i=0; i<SECTION_COUNT; i++) {\n\t\tif (sectionlist&(1<<i)) {\n\t\t\tsnprintf(sections+len, ml-len, \"%s, \", exif_get_sectionname(i));\n\t\t\tlen = strlen(sections);\n\t\t}\n\t}\n\tif (len>2)\n\t\tsections[len-2] = '\\0';\n\treturn sections;\n}", "target": 0}
{"code": "is_mbc_ambiguous(OnigCaseFoldType flag,\n\t\t const UChar** pp, const UChar* end)\n{\n  int v;\n  const UChar* p = *pp;\n  if (*p == SHARP_s && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    (*pp)++;\n    return TRUE;\n  }\n  (*pp)++;\n  v = (EncISO_8859_1_CtypeTable[*p] & (BIT_CTYPE_UPPER | BIT_CTYPE_LOWER));\n  if ((v | BIT_CTYPE_LOWER) != 0) {\n    if (*p >= 0xaa && *p <= 0xba)\n      return FALSE;\n    else\n      return TRUE;\n  }\n  return (v != 0 ? TRUE : FALSE);\n}", "target": 0}
{"code": "V4L2JpegEncodeAccelerator::JobRecord::JobRecord(\n    scoped_refptr<VideoFrame> input_frame,\n    scoped_refptr<VideoFrame> output_frame,\n    int quality,\n    int32_t task_id,\n    BitstreamBuffer* exif_buffer)\n    : input_frame(input_frame),\n       output_frame(output_frame),\n       quality(quality),\n       task_id(task_id),\n      output_shm(base::SharedMemoryHandle(), 0, true),  \n       exif_shm(nullptr) {\n   if (exif_buffer) {\n     exif_shm.reset(new UnalignedSharedMemory(exif_buffer->TakeRegion(),\n                                             exif_buffer->size(), false));\n    exif_offset = exif_buffer->offset();\n  }\n}", "target": 1}
{"code": "batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n\tkfree(entry);\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n\t\tkfree_skb(skb_out);\n\t\tskb_out = NULL;\n\t\tgoto free;\n\t}\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\nfree:\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}", "target": 1}
{"code": "void IndexedDBDatabase::RegisterAndScheduleTransaction(\n    IndexedDBTransaction* transaction) {\n  IDB_TRACE1(\"IndexedDBDatabase::RegisterAndScheduleTransaction\", \"txn.id\",\n             transaction->id());\n  std::vector<ScopesLockManager::ScopeLockRequest> lock_requests;\n  lock_requests.reserve(1 + transaction->scope().size());\n  lock_requests.emplace_back(\n      kDatabaseRangeLockLevel, GetDatabaseLockRange(id()),\n      transaction->mode() == blink::mojom::IDBTransactionMode::VersionChange\n          ? ScopesLockManager::LockType::kExclusive\n          : ScopesLockManager::LockType::kShared);\n  ScopesLockManager::LockType lock_type =\n      transaction->mode() == blink::mojom::IDBTransactionMode::ReadOnly\n          ? ScopesLockManager::LockType::kShared\n          : ScopesLockManager::LockType::kExclusive;\n  for (int64_t object_store : transaction->scope()) {\n    lock_requests.emplace_back(kObjectStoreRangeLockLevel,\n                               GetObjectStoreLockRange(id(), object_store),\n                               lock_type);\n  }\n  lock_manager_->AcquireLocks(\n      std::move(lock_requests),\n      base::BindOnce(&IndexedDBTransaction::Start, transaction->AsWeakPtr()));\n}", "target": 0}
{"code": "int get_netnsid_from_name(const char *name)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct rtgenmsg g;\n\t\tchar            buf[1024];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST,\n\t\t.n.nlmsg_type = RTM_GETNSID,\n\t\t.g.rtgen_family = AF_UNSPEC,\n\t};\n\tstruct nlmsghdr *answer;\n\tstruct rtattr *tb[NETNSA_MAX + 1];\n\tstruct rtgenmsg *rthdr;\n\tint len, fd;\n\tnetns_nsid_socket_init();\n\tfd = netns_get_fd(name);\n\tif (fd < 0)\n\t\treturn fd;\n\taddattr32(&req.n, 1024, NETNSA_FD, fd);\n\tif (rtnl_talk(&rtnsh, &req.n, &answer) < 0) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tclose(fd);\n\tif (answer->nlmsg_type == NLMSG_ERROR)\n\t\tgoto err_out;\n\trthdr = NLMSG_DATA(answer);\n\tlen = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr));\n\tif (len < 0)\n\t\tgoto err_out;\n\tparse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len);\n\tif (tb[NETNSA_NSID]) {\n\t\tfree(answer);\n\t\treturn rta_getattr_u32(tb[NETNSA_NSID]);\n\t}\nerr_out:\n\tfree(answer);\n\treturn -1;\n}", "target": 1}
{"code": " chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n {\n \tu_int proto;\n \tproto = EXTRACT_16BITS(&p[2]);\n \tif (ndo->ndo_eflag) {\n                 ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n \t\tbreak;\n         case ETHERTYPE_ISO:\n                 if (*(p+1) == 0x81 ||\n                     *(p+1) == 0x82 ||\n                     *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n \t}\n \treturn (CHDLC_HDRLEN);\n }", "target": 1}
{"code": "static xmlParserInputPtr _php_libxml_pre_ext_ent_loader(const char *URL,\n\t\tconst char *ID, xmlParserCtxtPtr context)\n{\n\tTSRMLS_FETCH();\n\tif (xmlGenericError == php_libxml_error_handler && PG(modules_activated)) {\n\t\treturn _php_libxml_external_entity_loader(URL, ID, context);\n\t} else {\n\t\treturn _php_libxml_default_entity_loader(URL, ID, context);\n\t}\n}", "target": 0}
{"code": " ImageLoader::ImageLoader(Element* element)\n     : m_element(element),\n      m_derefElementTimer(TaskRunnerHelper::get(TaskType::Networking,\n                                                element->document().frame()),\n                          this,\n                          &ImageLoader::timerFired),\n       m_hasPendingLoadEvent(false),\n       m_hasPendingErrorEvent(false),\n       m_imageComplete(true),\n      m_loadingImageDocument(false),\n      m_elementIsProtected(false),\n      m_suppressErrorEvents(false) {\n  RESOURCE_LOADING_DVLOG(1) << \"new ImageLoader \" << this;\n}", "target": 0}
{"code": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint err;\n\tstruct sock_diag_req *req = nlmsg_data(nlh);\n\tconst struct sock_diag_handler *hndl;\n \tif (nlmsg_len(nlh) < sizeof(*req))\n \t\treturn -EINVAL;\n \thndl = sock_diag_lock_handler(req->sdiag_family);\n \tif (hndl == NULL)\n \t\terr = -ENOENT;\n\telse\n\t\terr = hndl->dump(skb, nlh);\n\tsock_diag_unlock_handler(hndl);\n\treturn err;\n}", "target": 1}
{"code": "    uint32_t SonyMnHeader::ifdOffset() const\n    {\n        return start_;\n    }", "target": 0}
{"code": "auth_line_is_valid (guint8 *line, guint8 *line_end)\n{\n  guint8 *p;\n  for (p = line; p < line_end; p++)\n    {\n      if (!_DBUS_ISASCII(*p))\n        return FALSE;\n      if (*p < ' ')\n        return FALSE;\n    }\n  if (line[0] < 'A' || line[0] > 'Z')\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "static int ms_init_ff(struct hid_device *hdev)\n{\n\tstruct hid_input *hidinput = list_entry(hdev->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *input_dev = hidinput->input;\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\tif (!(ms->quirks & MS_QUIRK_FF))\n\t\treturn 0;\n\tms->hdev = hdev;\n\tINIT_WORK(&ms->ff_worker, ms_ff_worker);\n\tms->output_report_dmabuf = devm_kzalloc(&hdev->dev,\n\t\t\t\t\t\tsizeof(struct xb1s_ff_report),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (ms->output_report_dmabuf == NULL)\n\t\treturn -ENOMEM;\n\tinput_set_capability(input_dev, EV_FF, FF_RUMBLE);\n\treturn input_ff_create_memless(input_dev, NULL, ms_play_effect);\n}", "target": 1}
{"code": "int is_bare_repository(void)\n{\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}", "target": 0}
{"code": "GF_Err gf_isom_get_current_top_box_offset(GF_ISOFile *movie, u64 *current_top_box_offset)\n{\n\tif (!movie || !movie->moov || !current_top_box_offset) return GF_BAD_PARAM;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t*current_top_box_offset = movie->current_top_box_start;\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}", "target": 0}
{"code": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\tStream_Read_UINT16(s, updateType); \n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\nfail:\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static void cleanup_key_data(context, count, data)\n    krb5_context   context;\n    int                    count;\n    krb5_key_data        * data;\n{\n    int i, j;\n    for (i = 0; i < count; i++)\n        for (j = 0; j < data[i].key_data_ver; j++)\n            if (data[i].key_data_length[j])\n                krb5_db_free(context, data[i].key_data_contents[j]);\n    krb5_db_free(context, data);\n}", "target": 0}
{"code": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n out_cleanup:\n \tovl_cleanup(wdir, newdentry);\n\tgoto out;\n }", "target": 1}
{"code": "void V8Window::namedPropertyGetterCustom(v8::Local<v8::Name> name, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    if (!name->IsString())\n        return;\n    auto nameString = name.As<v8::String>();\n    LocalDOMWindow* window = toLocalDOMWindow(V8Window::toImpl(info.Holder()));\n    if (!window)\n        return;\n    LocalFrame* frame = window->frame();\n    if (!frame)\n        return;\n    AtomicString propName = toCoreAtomicString(nameString);\n    Frame* child = frame->tree().scopedChild(propName);\n    if (child) {\n        v8SetReturnValueFast(info, child->domWindow(), window);\n        return;\n    }\n     if (!info.Holder()->GetRealNamedProperty(nameString).IsEmpty())\n         return;\n    frame = window->frame();\n    if (!frame)\n        return;\n     Document* doc = frame->document();\n    if (doc && doc->isHTMLDocument()) {\n        if (toHTMLDocument(doc)->hasNamedItem(propName) || doc->hasElementWithId(propName)) {\n            RefPtrWillBeRawPtr<HTMLCollection> items = doc->windowNamedItems(propName);\n            if (!items->isEmpty()) {\n                if (items->hasExactlyOneItem()) {\n                    v8SetReturnValueFast(info, items->item(0), window);\n                    return;\n                }\n                v8SetReturnValueFast(info, items.release(), window);\n                return;\n            }\n        }\n    }\n}", "target": 0}
{"code": "R_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) {\n#if __UNIX__\n\tint ret, flags;\n#endif\n\tif (!s) {\n\t\treturn false;\n\t}\n#if __UNIX__\n\tflags = fcntl (s->fd, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn false;\n\t}\n\tret = fcntl (s->fd, F_SETFL, block?\n\t\t\t(flags & ~O_NONBLOCK):\n\t\t\t(flags | O_NONBLOCK));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n#elif __WINDOWS__\n\tioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);\n#endif\n\tif (sec > 0 || usec > 0) {\n\t\tstruct timeval tv = {0};\n\t\ttv.tv_sec = sec;\n\t\ttv.tv_usec = usec;\n\t\tif (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tint ret;\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tif (p->sel.prefixlen_d > 32 || p->sel.prefixlen_s > 32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (p->sel.prefixlen_d > 128 || p->sel.prefixlen_s > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tret = verify_policy_dir(p->dir);\n\tif (ret)\n\t\treturn ret;\n\tif (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static void sta_ps_end(struct sta_info *sta)\n{\n\tps_dbg(sta->sdata, \"STA %pM aid %d exits power save mode\\n\",\n\t       sta->sta.addr, sta->sta.aid);\n\tif (test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {\n\t\tclear_sta_flag(sta, WLAN_STA_PS_STA);\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d driver-ps-blocked\\n\",\n\t\t       sta->sta.addr, sta->sta.aid);\n\t\treturn;\n\t}\n\tset_sta_flag(sta, WLAN_STA_PS_DELIVER);\n\tclear_sta_flag(sta, WLAN_STA_PS_STA);\n\tieee80211_sta_ps_deliver_wakeup(sta);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MinValid) {\n    addIndex(BSON(\"a\" << 1));\n    runQueryHintMinMax(BSONObj(), BSONObj(), fromjson(\"{a: 1}\"), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{fetch: {filter: null, \"\n        \"node: {ixscan: {filter: null, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "void WebContentsImpl::OnSetSelectedColorInColorChooser(int color_chooser_id,\n                                                       SkColor color) {\n  if (color_chooser_ &&\n      color_chooser_id == color_chooser_identifier_)\n    color_chooser_->SetSelectedColor(color);\n}", "target": 0}
{"code": "ptp_unpack_OPL (PTPParams *params, unsigned char* data, MTPProperties **pprops, unsigned int len)\n{ \n\tuint32_t prop_count = dtoh32a(data);\n\tMTPProperties *props = NULL;\n\tunsigned int offset = 0, i;\n\t*pprops = NULL;\n\tif (prop_count == 0)\n\t\treturn 0;\n\tif (prop_count >= INT_MAX/sizeof(MTPProperties)) {\n\t\tptp_debug (params ,\"prop_count %d is too large\", prop_count);\n\t\treturn 0;\n\t}\n\tptp_debug (params ,\"Unpacking MTP OPL, size %d (prop_count %d)\", len, prop_count);\n\tdata += sizeof(uint32_t);\n\tlen -= sizeof(uint32_t);\n\tprops = malloc(prop_count * sizeof(MTPProperties));\n\tif (!props) return 0;\n\tfor (i = 0; i < prop_count; i++) {\n\t\tif (len <= 0) {\n\t\t\tptp_debug (params ,\"short MTP Object Property List at property %d (of %d)\", i, prop_count);\n\t\t\tptp_debug (params ,\"device probably needs DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL\");\n\t\t\tptp_debug (params ,\"or even DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\t\tprops[i].ObjectHandle = dtoh32a(data);\n\t\tdata += sizeof(uint32_t);\n\t\tlen -= sizeof(uint32_t);\n\t\tprops[i].property = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\t\tprops[i].datatype = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\t\toffset = 0;\n\t\tif (!ptp_unpack_DPV(params, data, &offset, len, &props[i].propval, props[i].datatype)) {\n\t\t\tptp_debug (params ,\"unpacking DPV of property %d encountered insufficient buffer. attack?\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\t\tdata += offset;\n\t\tlen -= offset;\n\t}\n\tqsort (props, prop_count, sizeof(MTPProperties),_compare_func);\n\t*pprops = props;\n\treturn prop_count;\n}", "target": 1}
{"code": "void forward_cancel_request(PgSocket *server)\n{\n\tbool res;\n\tPgSocket *req = first_socket(&server->pool->cancel_req_list);\n\tAssert(req != NULL && req->state == CL_CANCEL);\n\tAssert(server->state == SV_LOGIN);\n\tSEND_CancelRequest(res, server, req->cancel_key);\n\tchange_client_state(req, CL_JUSTFREE);\n}", "target": 0}
{"code": "get_AT_name (unsigned long attribute)\n{\n  const char *name;\n  if (attribute == 0)\n    return \"DW_AT value: 0\";\n  if (attribute == DW_AT_MIPS_fde)\n    return \"DW_AT_MIPS_fde or DW_AT_HP_unmodifiable\";\n  name = get_DW_AT_name (attribute);\n  if (name == NULL)\n    {\n      static char buffer[100];\n      snprintf (buffer, sizeof (buffer), _(\"Unknown AT value: %lx\"),\n\t\tattribute);\n      return buffer;\n    }\n  return name;\n}", "target": 0}
{"code": "copy_opt_anc_info(OptAncInfo* to, OptAncInfo* from)\n{\n  *to = *from;\n}", "target": 0}
{"code": "int fz_colorspace_device_n_has_only_cmyk(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && ((cs->flags & FZ_CS_HAS_CMYK_AND_SPOTS) == FZ_CS_HAS_CMYK);\n}", "target": 0}
{"code": "lexer_process_char_literal (parser_context_t *context_p, \n                            const uint8_t *char_p, \n                            size_t length, \n                            uint8_t literal_type, \n                            bool has_escape) \n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  uint32_t literal_index = 0;\n  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_STRING_LITERAL);\n  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);\n  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == literal_type\n        && literal_p->prop.length == length\n        && memcmp (literal_p->u.char_p, char_p, length) == 0)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);\n      return;\n    }\n    literal_index++;\n  }\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n   }\n   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n   literal_p->prop.length = (uint16_t) length;\n   literal_p->type = literal_type;\n  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;\n  if (has_escape)\n  {\n    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);\n    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);\n  }\n  else\n  {\n    literal_p->u.char_p = char_p;\n  }\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n  context_p->literal_count++;\n} ", "target": 1}
{"code": "long keyctl_negate_key(key_serial_t id, unsigned timeout, key_serial_t ringid)\n{\n\treturn keyctl_reject_key(id, timeout, ENOKEY, ringid);\n}", "target": 0}
{"code": "ext2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tif (!header->h_hash)\n\t\treturn NULL;  \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode->i_sb, \"ext2_xattr_cache_find\",\n\t\t\t\t\"inode %ld: block %ld read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\tif (le32_to_cpu(HDR(bh)->h_refcount) >\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, \"block %ld refcount %d>%d\",\n\t\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)->h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, \"b_count=%d\",\n\t\t\t\t\t  atomic_read(&(bh->b_count)));\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MagickPathExtent];\n  const char\n    *option;\n  graph_t\n    *graph;\n  Image\n    *image;\n  ImageInfo\n    *read_info;\n  MagickBooleanType\n    status;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}", "target": 1}
{"code": "static void mce_start_timer(struct timer_list *t)\n{\n\tunsigned long iv = check_interval * HZ;\n\tif (mca_cfg.ignore_ce || !iv)\n\t\treturn;\n\tthis_cpu_write(mce_next_interval, iv);\n\t__start_timer(t, iv);\n}", "target": 0}
{"code": "static ssize_t module_gzip_decompress(struct load_info *info,\n\t\t\t\t      const void *buf, size_t size)\n{\n\tstruct z_stream_s s = { 0 };\n\tsize_t new_size = 0;\n\tsize_t gzip_hdr_len;\n\tssize_t retval;\n\tint rc;\n\tgzip_hdr_len = module_gzip_header_len(buf, size);\n\tif (!gzip_hdr_len) {\n\t\tpr_err(\"not a gzip compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\ts.next_in = buf + gzip_hdr_len;\n\ts.avail_in = size - gzip_hdr_len;\n\ts.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!s.workspace)\n\t\treturn -ENOMEM;\n\trc = zlib_inflateInit2(&s, -MAX_WBITS);\n\tif (rc != Z_OK) {\n\t\tpr_err(\"failed to initialize decompressor: %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_inflate_end;\n\t\t}\n\t\ts.next_out = kmap_local_page(page);\n\t\ts.avail_out = PAGE_SIZE;\n\t\trc = zlib_inflate(&s, 0);\n\t\tkunmap_local(s.next_out);\n\t\tnew_size += PAGE_SIZE - s.avail_out;\n\t} while (rc == Z_OK);\n\tif (rc != Z_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out_inflate_end;\n\t}\n\tretval = new_size;\nout_inflate_end:\n\tzlib_inflateEnd(&s);\nout:\n\tkfree(s.workspace);\n\treturn retval;\n}", "target": 1}
{"code": "setup_new_fields(THD *thd, List<Item> &fields,\n\t\t List<Item> &all_fields, ORDER *new_field)\n{\n  Item\t  **item;\n  uint counter;\n  enum_resolution_type not_used;\n  DBUG_ENTER(\"setup_new_fields\");\n  thd->mark_used_columns= MARK_COLUMNS_READ;       \n  for (; new_field ; new_field= new_field->next)\n  {\n    if ((item= find_item_in_list(*new_field->item, fields, &counter,\n\t\t\t\t IGNORE_ERRORS, &not_used)))\n      new_field->item=item;\t\t\t\n    else\n    {\n      thd->where=\"procedure list\";\n      if ((*new_field->item)->fix_fields(thd, new_field->item))\n\tDBUG_RETURN(1); \n      all_fields.push_front(*new_field->item, thd->mem_root);\n      new_field->item=all_fields.head_ref();\n    }\n  }\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\tRRBNode head; \n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; \n\tRRBNode *p = NULL, *q = tree->root; \n\tint dir = 0, last = 0; \n\t_set_link (parent, q, 1);\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\ttree->root = head.link[1];\nout_exit:\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\treturn inserted;\n}", "target": 1}
{"code": "generatePreview (const char inFileName[],\n\t\t float exposure,\n\t\t int previewWidth,\n\t\t int &previewHeight,\n\t\t Array2D <PreviewRgba> &previewPixels)\n{\n    RgbaInputFile in (inFileName);\n    Box2i dw = in.dataWindow();\n    float a = in.pixelAspectRatio();\n    int w = dw.max.x - dw.min.x + 1;\n    int h = dw.max.y - dw.min.y + 1;\n    Array2D <Rgba> pixels (h, w);\n    in.setFrameBuffer (ComputeBasePointer (&pixels[0][0], dw), 1, w);\n    in.readPixels (dw.min.y, dw.max.y);\n    previewHeight = max (int (h / (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n    float fx = (previewWidth  > 0)? (float (w - 1) / (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 0)? (float (h - 1) / (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)\n\t{\n\t    PreviewRgba &preview = previewPixels[y][x];\n\t    const Rgba &pixel = pixels[int (y * fy + .5f)][int (x * fx + .5f)];\n\t    preview.r = gamma (pixel.r, m);\n\t    preview.g = gamma (pixel.g, m);\n\t    preview.b = gamma (pixel.b, m);\n\t    preview.a = int (IMATH_NAMESPACE::clamp (pixel.a * 255.f, 0.f, 255.f) + .5f);\n\t}\n    }\n}", "target": 1}
{"code": "static int adpt_device_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tu32 msg[4];\n\tu32 rcode;\n\tint old_state;\n\tstruct adpt_device* d = cmd->device->hostdata;\n\tpHba = (void*) cmd->device->host->hostdata[0];\n\tprintk(KERN_INFO\"%s: Trying to reset device\\n\",pHba->name);\n\tif (!d) {\n\t\tprintk(KERN_INFO\"%s: Reset Device: Device Not found\\n\",pHba->name);\n\t\treturn FAILED;\n\t}\n\tmemset(msg, 0, sizeof(msg));\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = (I2O_DEVICE_RESET<<24|HOST_TID<<12|d->tid);\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\told_state = d->state;\n\td->state |= DPTI_DEV_RESET;\n\trcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);\n\td->state = old_state;\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tif(rcode == -EOPNOTSUPP ){\n\t\t\tprintk(KERN_INFO\"%s: Device reset not supported\\n\",pHba->name);\n\t\t\treturn FAILED;\n\t\t}\n\t\tprintk(KERN_INFO\"%s: Device reset failed\\n\",pHba->name);\n\t\treturn FAILED;\n\t} else {\n\t\tprintk(KERN_INFO\"%s: Device reset successful\\n\",pHba->name);\n\t\treturn SUCCESS;\n\t}\n}", "target": 1}
{"code": "void sk_free(struct sock *sk)\n{\n\tif (atomic_dec_and_test(&sk->sk_wmem_alloc))\n\t\t__sk_free(sk);\n}", "target": 0}
{"code": "bool Item_default_value::fix_fields(THD *thd, Item **items)\n{\n  Item *real_arg;\n  Item_field *field_arg;\n  Field *def_field;\n  DBUG_ASSERT(fixed == 0);\n  if (!arg)\n  {\n    fixed= 1;\n    return FALSE;\n  }\n  if (!arg->fixed && arg->fix_fields(thd, &arg))\n    goto error;\n  real_arg= arg->real_item();\n  if (real_arg->type() != FIELD_ITEM)\n  {\n    my_error(ER_NO_DEFAULT_FOR_FIELD, MYF(0), arg->name);\n    goto error;\n  }\n  field_arg= (Item_field *)real_arg;\n  if (field_arg->field->flags & NO_DEFAULT_VALUE_FLAG)\n  {\n    my_error(ER_NO_DEFAULT_FOR_FIELD, MYF(0), field_arg->field->field_name);\n    goto error;\n  }\n  if (!(def_field= (Field*) sql_alloc(field_arg->field->size_of())))\n    goto error;\n  memcpy((void *)def_field, (void *)field_arg->field, field_arg->field->size_of());\n  def_field->move_field_offset((my_ptrdiff_t)\n                               (def_field->table->s->default_values -\n                                def_field->table->record[0]));\n  set_field(def_field);\n  return FALSE;\nerror:\n  context->process_error(thd);\n  return TRUE;\n}", "target": 0}
{"code": "ProcFreeGC(ClientPtr client)\n{\n    GC *pGC;\n    int rc;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupGC(&pGC, stuff->id, client, DixDestroyAccess);\n    if (rc != Success)\n        return rc;\n    FreeResource(stuff->id, RT_NONE);\n    return Success;\n}", "target": 0}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,\n\t\t\t\t       struct sof_ipc_ctrl_data *cdata,\n\t\t\t\t       struct sof_ipc_ctrl_data_params *sparams,\n\t\t\t\t       bool send)\n{\n\tstruct sof_ipc_ctrl_data *partdata;\n\tsize_t send_bytes;\n\tsize_t offset = 0;\n\tsize_t msg_bytes;\n\tsize_t pl_size;\n\tint err;\n\tint i;\n\tpartdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!partdata)\n\t\treturn -ENOMEM;\n\tif (send)\n\t\terr = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,\n\t\t\t\t\t       sparams);\n\telse\n\t\terr = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,\n\t\t\t\t\t       sparams);\n\tif (err < 0)\n\t\treturn err;\n\tmsg_bytes = sparams->msg_bytes;\n\tpl_size = sparams->pl_size;\n\tmemcpy(partdata, cdata, sparams->hdr_bytes);\n\tmutex_lock(&sdev->ipc->tx_mutex);\n\tfor (i = 0; i < sparams->num_msg; i++) {\n\t\tsend_bytes = min(msg_bytes, pl_size);\n\t\tpartdata->num_elems = send_bytes;\n\t\tpartdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;\n\t\tpartdata->msg_index = i;\n\t\tmsg_bytes -= send_bytes;\n\t\tpartdata->elems_remaining = msg_bytes;\n\t\tif (send)\n\t\t\tmemcpy(sparams->dst, sparams->src + offset, send_bytes);\n\t\terr = sof_ipc_tx_message_unlocked(sdev->ipc,\n\t\t\t\t\t\t  partdata->rhdr.hdr.cmd,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (!send)\n\t\t\tmemcpy(sparams->dst + offset, sparams->src, send_bytes);\n\t\toffset += pl_size;\n\t}\n\tmutex_unlock(&sdev->ipc->tx_mutex);\n\tkfree(partdata);\n\treturn err;\n}", "target": 1}
{"code": "static CURLcode imap_state_fetch_resp(struct connectdata *conn, int imapcode,\n                                      imapstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct pingpong *pp = &imapc->pp;\n  const char *ptr = data->state.buffer;\n  bool parsed = FALSE;\n  curl_off_t size = 0;\n  (void)instate; \n  if(imapcode != '*') {\n    Curl_pgrsSetDownloadSize(data, -1);\n    state(conn, IMAP_STOP);\n    return CURLE_REMOTE_FILE_NOT_FOUND; \n  }\n  while(*ptr && (*ptr != '{'))\n    ptr++;\n  if(*ptr == '{') {\n    char *endptr;\n    if(!curlx_strtoofft(ptr + 1, &endptr, 10, &size)) {\n      if(endptr - ptr > 1 && endptr[0] == '}' &&\n         endptr[1] == '\\r' && endptr[2] == '\\0')\n        parsed = TRUE;\n    }\n  }\n  if(parsed) {\n    infof(data, \"Found %\" CURL_FORMAT_CURL_OFF_TU \" bytes to download\\n\",\n          size);\n    Curl_pgrsSetDownloadSize(data, size);\n    if(pp->cache) {\n      size_t chunk = pp->cache_size;\n      if(chunk > (size_t)size)\n        chunk = (size_t)size;\n      result = Curl_client_write(conn, CLIENTWRITE_BODY, pp->cache, chunk);\n      if(result)\n        return result;\n      data->req.bytecount += chunk;\n      infof(data, \"Written %\" CURL_FORMAT_CURL_OFF_TU\n            \" bytes, %\" CURL_FORMAT_CURL_OFF_TU\n            \" bytes are left for transfer\\n\", (curl_off_t)chunk,\n            size - chunk);\n      if(pp->cache_size > chunk) {\n        memmove(pp->cache, pp->cache + chunk, pp->cache_size - chunk);\n        pp->cache_size -= chunk;\n      }\n      else {\n        Curl_safefree(pp->cache);\n        pp->cache_size = 0;\n      }\n    }\n    if(data->req.bytecount == size)\n      Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n    else {\n      data->req.maxdownload = size;\n      Curl_setup_transfer(conn, FIRSTSOCKET, size, FALSE, NULL, -1, NULL);\n    }\n  }\n  else {\n    failf(pp->conn->data, \"Failed to parse FETCH response.\");\n    result = CURLE_WEIRD_SERVER_REPLY;\n  }\n  state(conn, IMAP_STOP);\n  return result;\n}", "target": 1}
{"code": "Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,\n                 string* init_op_name) {\n  const auto& sig_def_map = meta_graph_def.signature_def();\n  const auto& init_op_sig_it =\n      meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);\n  if (init_op_sig_it != sig_def_map.end()) {\n    *init_op_name = init_op_sig_it->second.outputs()\n                        .find(kSavedModelInitOpSignatureKey)\n                        ->second.name();\n    return Status::OK();\n  }\n  const auto& collection_def_map = meta_graph_def.collection_def();\n  string init_op_collection_key;\n  if (collection_def_map.find(kSavedModelMainOpKey) !=\n      collection_def_map.end()) {\n    init_op_collection_key = kSavedModelMainOpKey;\n  } else {\n    init_op_collection_key = kSavedModelLegacyInitOpKey;\n  }\n  const auto init_op_it = collection_def_map.find(init_op_collection_key);\n  if (init_op_it != collection_def_map.end()) {\n    if (init_op_it->second.node_list().value_size() != 1) {\n      return errors::FailedPrecondition(\n          strings::StrCat(\"Expected exactly one main op in : \", export_dir));\n    }\n    *init_op_name = init_op_it->second.node_list().value(0);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s->lossless = 0;\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n    update_canvas_size(avctx, avctx->width, avctx->height);\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }", "target": 1}
{"code": "GF_Err vmhd_box_size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}", "target": 0}
{"code": "bool WebContentsImpl::IsLoading() const {\n  return is_loading_;\n}", "target": 0}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n {\n \tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n \t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n }", "target": 1}
{"code": "void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)\n{\n    hal_info *info = getHalInfo(handle);\n char buf[64];\n    info->cleaned_up_handler = handler;\n if (write(info->cleanup_socks[0], \"Exit\", 4) < 1) {\n        ALOGE(\"could not write to the cleanup socket\");\n } else {\n        memset(buf, 0, sizeof(buf));\n int result = read(info->cleanup_socks[0], buf, sizeof(buf));\n        ALOGE(\"%s: Read after POLL returned %d, error no = %d\", __FUNCTION__, result, errno);\n if (strncmp(buf, \"Done\", 4) == 0) {\n            ALOGE(\"Event processing terminated\");\n } else {\n            ALOGD(\"Rx'ed %s\", buf);\n }\n }\n    info->clean_up = true;\n    pthread_mutex_lock(&info->cb_lock);\n int bad_commands = 0;\n for (int i = 0; i < info->num_event_cb; i++) {\n        cb_info *cbi = &(info->event_cb[i]);\n WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;\n        ALOGI(\"Command left in event_cb %p:%s\", cmd, (cmd ? cmd->getType(): \"\"));\n }\n while (info->num_cmd > bad_commands) {\n int num_cmd = info->num_cmd;\n        cmd_info *cmdi = &(info->cmd[bad_commands]);\n WifiCommand *cmd = cmdi->cmd;\n if (cmd != NULL) {\n            ALOGI(\"Cancelling command %p:%s\", cmd, cmd->getType());\n             pthread_mutex_unlock(&info->cb_lock);\n             cmd->cancel();\n             pthread_mutex_lock(&info->cb_lock);\n            cmd->releaseRef();\n             if (num_cmd == info->num_cmd) {\n                 ALOGI(\"Cancelling command %p:%s did not work\", cmd, (cmd ? cmd->getType(): \"\"));\n                 bad_commands++;\n             }\n         }\n     }\n for (int i = 0; i < info->num_event_cb; i++) {\n        cb_info *cbi = &(info->event_cb[i]);\n WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;\n        ALOGE(\"Leaked command %p\", cmd);\n }\n    pthread_mutex_unlock(&info->cb_lock);\n    internal_cleaned_up_handler(handle);\n}", "target": 1}
{"code": "void ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n   JpegOutput jpeg( filename );\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );\n   jpeg.cinfo().density_unit = 2; \n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); \n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}", "target": 1}
{"code": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n    i = 10; \n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    bi_clear_cache(ctx);\n    return bir;\n}", "target": 1}
{"code": "void InstanceKlass::check_prohibited_package(Symbol* class_name,\n                                             ClassLoaderData* loader_data,\n                                             TRAPS) {\n  if (!loader_data->is_boot_class_loader_data() &&\n      !loader_data->is_platform_class_loader_data() &&\n      class_name != NULL && class_name->utf8_length() >= 5) {\n    ResourceMark rm(THREAD);\n    bool prohibited;\n    const u1* base = class_name->base();\n    if ((base[0] | base[1] | base[2] | base[3] | base[4]) & 0x80) {\n      prohibited = is_prohibited_package_slow(class_name);\n    } else {\n      char* name = class_name->as_C_string();\n      prohibited = (strncmp(name, JAVAPKG, JAVAPKG_LEN) == 0 && name[JAVAPKG_LEN] == '/');\n    }\n    if (prohibited) {\n      TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);\n      assert(pkg_name != NULL, \"Error in parsing package name starting with 'java/'\");\n      char* name = pkg_name->as_C_string();\n      const char* class_loader_name = loader_data->loader_name_and_id();\n      StringUtils::replace_no_expand(name, \"/\", \".\");\n      const char* msg_text1 = \"Class loader (instance of): \";\n      const char* msg_text2 = \" tried to load prohibited package name: \";\n      size_t len = strlen(msg_text1) + strlen(class_loader_name) + strlen(msg_text2) + strlen(name) + 1;\n      char* message = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, len);\n      jio_snprintf(message, len, \"%s%s%s%s\", msg_text1, class_loader_name, msg_text2, name);\n      THROW_MSG(vmSymbols::java_lang_SecurityException(), message);\n    }\n  }\n  return;\n}", "target": 0}
{"code": "static int emulator_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct x86_instruction_info *info,\n\t\t\t      enum x86_intercept_stage stage)\n{\n\treturn kvm_x86_ops->check_intercept(emul_to_vcpu(ctxt), info, stage);\n}", "target": 0}
{"code": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}", "target": 1}
{"code": "TEST_F(ExprMatchTest, EqWithTwoConstantsMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: {$eq: [3, 4]}}\"));\n    ASSERT_FALSE(matches(BSON(\"x\" << 3)));\n}", "target": 0}
{"code": "  static bool TryLock(Isolate* isolate) {\n    return isolate->break_access_->TryLock();\n  }", "target": 0}
{"code": "RsaAdjustPrimeCandidate(\n\t\t\tbigNum          prime,\n\t\t\tSEED_COMPAT_LEVEL seedCompatLevel  \n\t\t\t)\n{\n    switch (seedCompatLevel) {\n    case SEED_COMPAT_LEVEL_ORIGINAL:\n        RsaAdjustPrimeCandidate_PreRev155(prime);\n        break;\n    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:\n        RsaAdjustPrimeCandidate_New(prime);\n        break;\n    default:\n        FAIL(FATAL_ERROR_INTERNAL);\n    }\n}", "target": 1}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n \tstruct sockaddr_llc sllc;\n \tstruct sock *sk = sock->sk;\n \tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n \tmemset(&sllc, 0, sizeof(sllc));\n \tlock_sock(sk);\n \tif (sock_flag(sk, SOCK_ZAPPED))\n \t\tgoto out;\n \t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n \tif (peer) {\n \t\trc = -ENOTCONN;\n \t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n      if (jsvHasChildren(parent)) {\n        if (jsvIsArray(parent)) {\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}", "target": 1}
{"code": "void DelegatedFrameHost::ResetCompositorFrameSinkSupport() {\n  if (!support_)\n    return;\n  if (compositor_)\n    compositor_->RemoveFrameSink(frame_sink_id_);\n  support_.reset();\n}", "target": 0}
{"code": "void RenderViewTest::SetFocused(const blink::WebNode& node) {\n  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);\n  impl->FocusedNodeChanged(blink::WebNode(), node);\n}", "target": 0}
{"code": "static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_report_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "  ~RGWCreateBucketParser() override {}", "target": 0}
{"code": "void TightDecoder::FilterGradient(const rdr::U8* inbuf,\n                                  const PixelFormat& pf, PIXEL_T* outbuf,\n                                  int stride, const Rect& r)\n{\n  int x, y, c;\n  static rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  static rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);\n    for (c = 0; c < 3; c++)\n      pix[c] += prevRow[c];\n    memcpy(thisRow, pix, sizeof(pix));\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 255) {\n          est[c] = 255;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n      }\n      pf.rgbFromBuffer(pix, &inbuf[y*rectWidth+x], 1);\n      for (c = 0; c < 3; c++)\n        pix[c] += est[c];\n      memcpy(&thisRow[x*3], pix, sizeof(pix));\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n \tif (!err) {\n \t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n \t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n \t}\n \treturn err;\n }", "target": 1}
{"code": "Status ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return errors::Internal(\"Node \", node.name(), \" is not a Reshape node\");\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return errors::Internal(\"Node \", node.name(), \" has shape \",\n                            new_shape->DebugString(),\n                            \" which is not a constant\");\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return errors::Internal(\"Could not evaluate node \", node.name());\n  }\n  CHECK_EQ(1, outputs.size());\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return errors::Internal(\"Node \", node.name(), \" has no properties\");\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return errors::Internal(\"Node \", node.name(), \" has property \",\n                            prop.DebugString(), \" with invalid dtype\");\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return errors::Internal(\"Node \", node.name(), \" has property \",\n                            prop.DebugString(), \" with shape \",\n                            shape.DebugString(), \" which is not fully defined\");\n  }\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n  if (!shape.IsCompatibleWith(new_dims)) {\n    return errors::Internal(\"Expected shape \", shape.DebugString(),\n                            \"to be compatible with \", new_dims.DebugString());\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static zval **incomplete_class_get_property_ptr_ptr(zval *object, zval *member, const zend_literal *key TSRMLS_DC) \n{\n\tincomplete_class_message(object, E_NOTICE TSRMLS_CC);\n\treturn &EG(error_zval_ptr);\n}", "target": 0}
{"code": "zdeletefile(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    gs_parsed_file_name_t pname;\n    int code = parse_real_file_name(op, &pname, imemory, \"deletefile\");\n    if (code < 0)\n        return code;\n    if (pname.iodev == iodev_default(imemory)) {\n        if ((code = check_file_permissions(i_ctx_p, pname.fname, pname.len,\n                pname.iodev, \"PermitFileControl\")) < 0 &&\n                 !file_is_tempfile(i_ctx_p, op->value.bytes, r_size(op))) {\n            return code;\n        }\n    }\n    code = (*pname.iodev->procs.delete_file)(pname.iodev, pname.fname);\n    gs_free_file_name(&pname, \"deletefile\");\n    if (code < 0)\n        return code;\n    pop(1);\n    return 0;\n}", "target": 0}
{"code": "void InstanceKlass::set_implementor(Klass* k) {\n  assert_lock_strong(Compile_lock);\n  assert(is_interface(), \"not interface\");\n  Klass** addr = adr_implementor();\n  assert(addr != NULL, \"null addr\");\n  if (addr != NULL) {\n    *addr = k;\n  }\n}", "target": 0}
{"code": "int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\tvma->anon_vma = NULL;\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\tif (vma->anon_vma)\n\t\treturn 0;\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\tget_anon_vma(anon_vma->root);\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\treturn 0;\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "static void *HttpMultiBufHeaderThreadDataInit(void *data)\n{\n    HttpMultiBufHeaderThreadData *td = SCCalloc(1, sizeof(*td));\n    return td;\n}", "target": 0}
{"code": "static void ulaw2linear_buf (const uint8_t *ulaw, int16_t *linear, int nsamples)\n{\n\tfor (int i=0; i < nsamples; i++)\n\t\tlinear[i] = _af_ulaw2linear(ulaw[i]);\n}", "target": 0}
{"code": "acceptableEncoding()\n{\n    static Str encodings = NULL;\n    struct compression_decoder *d;\n    TextList *l;\n    char *p;\n    if (encodings != NULL)\n\treturn encodings->ptr;\n    l = newTextList();\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tif (check_command(d->cmd, d->auxbin_p)) {\n\t    pushText(l, d->encoding);\n\t}\n    }\n    encodings = Strnew();\n    while ((p = popText(l)) != NULL) {\n\tif (encodings->length)\n\t    Strcat_charp(encodings, \", \");\n\tStrcat_charp(encodings, p);\n    }\n    return encodings->ptr;\n}", "target": 0}
{"code": "Opal::Call::send_dtmf (const char dtmf)\n{\n  PSafePtr<OpalConnection> connection = get_remote_connection ();\n  if (connection != NULL) {\n    connection->SendUserInputTone (dtmf, 180);\n  }\n}", "target": 0}
{"code": "bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n    pop_finished_files();\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n        free = BSIZE - copy;\n    }\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n    return true;\n}", "target": 1}
{"code": "    uint32_t TiffEntryBase::doWriteData(IoWrapper&,\n                                        ByteOrder ,\n                                        int32_t   ,\n                                        uint32_t  ,\n                                        uint32_t& ) const\n    {\n        return 0;\n    } ", "target": 0}
{"code": "static BOOL rdp_redirection_read_base64_wchar(UINT32 flag, wStream* s, UINT32* pLength,\n                                              BYTE** pData)\n{\n\tBOOL rc = FALSE;\n\tchar buffer[64] = { 0 };\n\tconst BYTE* ptr = NULL;\n\tif (!rdp_redirection_get_data(s, pLength, &ptr))\n\t\treturn FALSE;\n\tconst WCHAR* wchar = (const WCHAR*)ptr;\n\tsize_t utf8_len = 0;\n\tchar* utf8 = ConvertWCharNToUtf8Alloc(wchar, *pLength, &utf8_len);\n\tif (!utf8)\n\t\tgoto fail;\n\tredirection_free_data(pData, NULL);\n\tutf8_len = strnlen(utf8, utf8_len);\n\t*pData = calloc(utf8_len, sizeof(BYTE));\n\tif (!*pData)\n\t\tgoto fail;\n\tsize_t rlen = utf8_len;\n\tsize_t wpos = 0;\n\tchar* tok = strtok(utf8, \"\\r\\n\");\n\twhile (tok)\n\t{\n\t\tconst size_t len = strnlen(tok, rlen);\n\t\trlen -= len;\n\t\tsize_t bplen = 0;\n\t\tBYTE* bptr = NULL;\n\t\tcrypto_base64_decode(tok, len, &bptr, &bplen);\n\t\tif (!bptr)\n\t\t\tgoto fail;\n\t\tmemcpy(&(*pData)[wpos], bptr, bplen);\n\t\twpos += bplen;\n\t\tfree(bptr);\n\t\ttok = strtok(NULL, \"\\r\\n\");\n\t}\n\t*pLength = wpos;\n\tWLog_DBG(TAG, \"%s:\", rdp_redirection_flags_to_string(flag, buffer, sizeof(buffer)));\n\trc = TRUE;\nfail:\n\tif (!rc)\n\t\tWLog_ERR(TAG, \"failed to read base64 data\");\n\tfree(utf8);\n\treturn rc;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, CantUseHashedIndexToProvideSort) {\n    addIndex(BSON(\"x\"\n                  << \"hashed\"));\n    runQuerySortProj(BSONObj(), BSON(\"x\" << 1), BSONObj());\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\n        \"{sort: {pattern: {x: 1}, limit: 0, node: {sortKeyGen:\"\n        \"{node: {cscan: {dir: 1, filter: {}}}}}}}\");\n}", "target": 0}
{"code": "void\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }", "target": 1}
{"code": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n  MagickOffsetType\n    offset;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n       {\n         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n         w = DIV2(w);\n         h = DIV2(h);\n       }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "  void connectErr(const AsyncSocketException& ex) noexcept override {\n    FAIL() << ex.what();\n  }", "target": 0}
{"code": "print_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n   ND_TCHECK2(data[0],length);\n   switch(attr_code)\n    {\n       case TUNNEL_PASS:\n            if (length < 3)\n           {\n              ND_PRINT((ndo, \"%s\", tstr));\n              return;\n           }\n            if (*data && (*data <=0x1F) )\n               ND_PRINT((ndo, \"Tag[%u] \", *data));\n            else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n            if (*data <= 0x1F)\n            {\n               if (length < 1)\n              {\n                 ND_PRINT((ndo, \"%s\", tstr));\n                 return;\n              }\n               if (*data)\n                 ND_PRINT((ndo, \"Tag[%u] \", *data));\n               else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n            }\n         break;\n       case EGRESS_VLAN_NAME:\n            ND_PRINT((ndo, \"%s (0x%02x) \",\n                   tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                   *data));\n           data++;\n           length--;\n         break;\n    }\n   for (i=0; *data && i < length ; i++, data++)\n        ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n    return;\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\tretval = sctp_make_reconf(asoc, outlen + inlen);\n\tif (!retval)\n\t\treturn NULL;\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\treturn retval;\n}", "target": 1}
{"code": " static void pipe_advance(struct iov_iter *i, size_t size)\n {\n \tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tint idx = i->idx;\n\tsize_t off = i->iov_offset, orig_sz;\n \tif (unlikely(i->count < size))\n \t\tsize = i->count;\n\torig_sz = size;\n \tif (size) {\n \t\tif (off) \n\t\t\tsize += off - pipe->bufs[idx].offset;\n \t\twhile (1) {\n \t\t\tbuf = &pipe->bufs[idx];\n\t\t\tif (size <= buf->len)\n \t\t\t\tbreak;\n\t\t\tsize -= buf->len;\n \t\t\tidx = next_idx(idx, pipe);\n \t\t}\n\t\tbuf->len = size;\n \t\ti->idx = idx;\n\t\toff = i->iov_offset = buf->offset + size;\n\t}\n\tif (off)\n\t\tidx = next_idx(idx, pipe);\n\tif (pipe->nrbufs) {\n\t\tint unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\twhile (idx != unused) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n \t}\n\ti->count -= orig_sz;\n }", "target": 1}
{"code": "static void rcu_free_slab(struct rcu_head *h)\n{\n\tstruct page *page = container_of(h, struct page, rcu_head);\n\t__free_slab(page->slab_cache, page);\n}", "target": 0}
{"code": "static s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)\n{\n\tu32 m = EMPTY_QUEUE;\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 30*HZ;\n\tdo {\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif (m != EMPTY_QUEUE) {\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_WARNING\"dpti%d: Timeout waiting for message frame!\\n\", pHba->unit);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t} while(m == EMPTY_QUEUE);\n\tmsg = pHba->msg_addr_virt + m;\n\tmemcpy_toio(msg, data, len);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "void Document::ImplicitClose() {\n  DCHECK(!InStyleRecalc());\n  DCHECK(parser_);\n  load_event_progress_ = kLoadEventInProgress;\n  DetachParser();\n  if (SvgExtensions())\n    AccessSVGExtensions().DispatchSVGLoadEventToOutermostSVGElements();\n  if (domWindow())\n    domWindow()->DocumentWasClosed();\n  if (GetFrame()) {\n    GetFrame()->Client()->DispatchDidHandleOnloadEvents();\n    Loader()->GetApplicationCacheHost()->StopDeferringEvents();\n  }\n  if (!GetFrame()) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (GetFrame()->GetNavigationScheduler().LocationChangePending() &&\n      ElapsedTime() < kCLayoutScheduleThreshold) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (!LocalOwner() || (LocalOwner()->GetLayoutObject() &&\n                        !LocalOwner()->GetLayoutObject()->NeedsLayout())) {\n    UpdateStyleAndLayoutTree();\n    if (View() && !GetLayoutViewItem().IsNull() &&\n        (!GetLayoutViewItem().FirstChild() ||\n         GetLayoutViewItem().NeedsLayout()))\n      View()->UpdateLayout();\n  }\n  load_event_progress_ = kLoadEventCompleted;\n  if (GetFrame() && !GetLayoutViewItem().IsNull() &&\n      GetSettings()->GetAccessibilityEnabled()) {\n    if (AXObjectCache* cache = GetOrCreateAXObjectCache()) {\n      if (this == &AXObjectCacheOwner())\n        cache->HandleLoadComplete(this);\n      else\n        cache->HandleLayoutComplete(this);\n    }\n  }\n  if (SvgExtensions())\n    AccessSVGExtensions().StartAnimations();\n}", "target": 0}
{"code": "change_refs_to_tmp_fields(THD *thd, Ref_ptr_array ref_pointer_array,\n\t\t\t  List<Item> &res_selected_fields,\n\t\t\t  List<Item> &res_all_fields, uint elements,\n\t\t\t  List<Item> &all_fields)\n{\n  List_iterator_fast<Item> it(all_fields);\n  Item *item, *new_item;\n  res_selected_fields.empty();\n  res_all_fields.empty();\n  uint i, border= all_fields.elements - elements;\n  for (i= 0; (item= it++); i++)\n  {\n    if (item->type() == Item::SUM_FUNC_ITEM && item->const_item())\n      new_item= item;\n    else\n      new_item= item->get_tmp_table_item(thd); \n    res_all_fields.push_back(new_item, thd->mem_root);\n    ref_pointer_array[((i < border)? all_fields.elements-i-1 : i-border)]=\n      new_item;\n  }\n  List_iterator_fast<Item> itr(res_all_fields);\n  for (i= 0; i < border; i++)\n    itr++;\n  itr.sublist(res_selected_fields, elements);\n  return thd->is_fatal_error;\n}", "target": 0}
{"code": "TEST(QuantizedInt8PoolingOpTest16, MaxPool) {\n  const float ulp = 1.f / 4096.f;\n  SymmetricQuantizedPoolingOpModel16 m(\n      BuiltinOperator_MAX_POOL_2D,\n      {TensorType_INT16, {1, 2, 4, 1}, 0, 16 - ulp},\n      2, 2,\n      {TensorType_INT16, {}, 0, 16 - ulp});\n  m.SetInput({\n      0, 6, 2, 4,   \n      3, 2, 10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({6, 10})));\n  EXPECT_THAT(m.GetOutput(),\n              ElementsAreArray({(96 - 128) * 256, (160 - 128) * 256}));\n}", "target": 0}
{"code": "void GfxDeviceCMYKColorSpace::getCMYKLine(unsigned char *in, unsigned char *out, int length)\n{\n    for (int i = 0; i < length; i++) {\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = *in++;\n    }\n}", "target": 0}
{"code": "static int adpt_abort(struct scsi_cmnd * cmd)\n{\n\tadpt_hba* pHba = NULL;\t\n\tstruct adpt_device* dptdevice;\t\n\tu32 msg[5];\n\tint rcode;\n\tpHba = (adpt_hba*) cmd->device->host->hostdata[0];\n\tprintk(KERN_INFO\"%s: Trying to Abort\\n\",pHba->name);\n\tif ((dptdevice = (void*) (cmd->device->hostdata)) == NULL) {\n\t\tprintk(KERN_ERR \"%s: Unable to abort: No device in cmnd\\n\",pHba->name);\n\t\treturn FAILED;\n\t}\n\tmemset(msg, 0, sizeof(msg));\n\tmsg[0] = FIVE_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid;\n\tmsg[2] = 0;\n\tmsg[3]= 0;\n\tmsg[4] = scsi_cmd_to_rq(cmd)->tag + 1;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\trcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER);\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tif(rcode == -EOPNOTSUPP ){\n\t\t\tprintk(KERN_INFO\"%s: Abort cmd not supported\\n\",pHba->name);\n\t\t\treturn FAILED;\n\t\t}\n\t\tprintk(KERN_INFO\"%s: Abort failed.\\n\",pHba->name);\n\t\treturn FAILED;\n\t} \n\tprintk(KERN_INFO\"%s: Abort complete.\\n\",pHba->name);\n\treturn SUCCESS;\n}", "target": 1}
{"code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 1}
{"code": "int rta_addattr16(struct rtattr *rta, int maxlen, int type, __u16 data)\n{\n\treturn rta_addattr_l(rta, maxlen, type, &data, sizeof(__u16));\n}", "target": 0}
{"code": "static void init_macros(void)\n{\n}", "target": 0}
{"code": "writepid (const char* pidfile, pid_t pid)\n{\n\tFILE* f;\n\tif ((f = fopen(pidfile, \"w\")) ==  NULL ) {\n\t\tlog_err(\"cannot open pidfile %s: %s\", \n\t\t\tpidfile, strerror(errno));\n\t\treturn;\n\t}\n\tif(fprintf(f, \"%lu\\n\", (unsigned long)pid) < 0) {\n\t\tlog_err(\"cannot write to pidfile %s: %s\", \n\t\t\tpidfile, strerror(errno));\n\t}\n\tfclose(f);\n}", "target": 1}
{"code": "      _cimg_math_parser(const _cimg_math_parser& mp):\n        mem(mp.mem),code(mp.code),p_code_end(mp.p_code_end),p_break(mp.p_break),\n        imgin(mp.imgin),listin(mp.listin),imgout(mp.imgout),listout(mp.listout),img_stats(mp.img_stats),\n        list_stats(mp.list_stats),list_median(mp.list_median),debug_indent(0),result_dim(mp.result_dim),\n        break_type(0),constcache_size(0),is_parallelizable(mp.is_parallelizable),is_fill(mp.is_fill),\n        need_input_copy(mp.need_input_copy), result(mem._data + (mp.result - mp.mem._data)),calling_function(0) {\n#ifdef cimg_use_openmp\n        mem[17] = omp_get_thread_num();\n#endif\n        opcode.assign();\n        opcode._is_shared = true;", "target": 0}
{"code": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\twait_for_completion(&fcomp.comp);\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\tkfree(fcstats);\n\treturn hstats;\n}", "target": 1}
{"code": "ptaReadStream(FILE  *fp)\n{\nchar       typestr[128];\nl_int32    i, n, ix, iy, type, version;\nl_float32  x, y;\nPTA       *pta;\n    PROCNAME(\"ptaReadStream\");\n    if (!fp)\n        return (PTA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n    if (fscanf(fp, \"\\n Pta Version %d\\n\", &version) != 1)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (version != PTA_VERSION_NUMBER)\n        return (PTA *)ERROR_PTR(\"invalid pta version\", procName, NULL);\n    if (fscanf(fp, \" Number of pts = %d; format = %s\\n\", &n, typestr) != 2)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (!strcmp(typestr, \"float\"))\n        type = 0;\n    else  \n        type = 1;\n    if ((pta = ptaCreate(n)) == NULL)\n        return (PTA *)ERROR_PTR(\"pta not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  \n            if (fscanf(fp, \"   (%f, %f)\\n\", &x, &y) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading floats\", procName, NULL);\n            }\n            ptaAddPt(pta, x, y);\n        } else {   \n            if (fscanf(fp, \"   (%d, %d)\\n\", &ix, &iy) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading ints\", procName, NULL);\n            }\n            ptaAddPt(pta, ix, iy);\n        }\n    }\n    return pta;\n}", "target": 1}
{"code": "static void dtls1_set_handshake_header(SSL *s, int htype, unsigned long len)\n{\n    unsigned char *p = (unsigned char *)s->init_buf->data;\n    dtls1_set_message_header(s, p, htype, len, 0, len);\n    s->init_num = (int)len + DTLS1_HM_HEADER_LENGTH;\n    s->init_off = 0;\n    dtls1_buffer_message(s, 0);\n}", "target": 0}
{"code": "static void FNAME_DECL(compress_row0)(const PIXEL *cur_row, unsigned int width)\n{\n    DECLARE_STATE_VARIABLES;\n    const unsigned int bpc_mask = BPC_MASK;\n    int pos = 0;\n    while ((DEFwmimax > (int)state->wmidx) && (state->wmileft <= width)) {\n        if (state->wmileft) {\n            FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + state->wmileft,\n                                          bppmask[state->wmidx], bpc_mask);\n            width -= state->wmileft;\n            pos += state->wmileft;\n        }\n        state->wmidx++;\n        set_wm_trigger(state);\n        state->wmileft = DEFwminext;\n    }\n    if (width) {\n        FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + width,\n                                      bppmask[state->wmidx], bpc_mask);\n        if (DEFwmimax > (int)state->wmidx) {\n            state->wmileft -= width;\n        }\n    }\n    spice_assert((int)state->wmidx <= DEFwmimax);\n    spice_assert(state->wmidx <= 32);\n    spice_assert(DEFwminext > 0);\n}", "target": 0}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 1}
{"code": "GF_Err trgt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\ts->type = ptr->group_type;\n\te = gf_isom_full_box_write(s, bs);\n\ts->type = GF_ISOM_BOX_TYPE_TRGT;\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->track_group_id);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n \t\tgoto out;\n \tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n \tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n \tif (error)\n\t\tgoto out_drop_write;\n \tfh_drop_write(fh);\n\tnfserr = fh_getattr(fh, &resp->stat);\nout:\n \tposix_acl_release(argp->acl_access);\n \tposix_acl_release(argp->acl_default);\n \treturn nfserr;\nout_drop_write:\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);\n\tgoto out;\n}", "target": 1}
{"code": "void AdsIntegrationTest::initializeAds(const bool rate_limiting) {\n  config_helper_.addRuntimeOverride(\"envoy.restart_features.explicit_wildcard_resource\",\n                                    oldDssOrNewDss() == OldDssOrNewDss::Old ? \"false\" : \"true\");\n  config_helper_.addConfigModifier([this, &rate_limiting](\n                                       envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n    auto* ads_config = bootstrap.mutable_dynamic_resources()->mutable_ads_config();\n    if (rate_limiting) {\n      ads_config->mutable_rate_limit_settings();\n    }\n    auto* grpc_service = ads_config->add_grpc_services();\n    setGrpcService(*grpc_service, \"ads_cluster\", xds_upstream_->localAddress());\n    auto* ads_cluster = bootstrap.mutable_static_resources()->add_clusters();\n    ads_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);\n    ads_cluster->set_name(\"ads_cluster\");\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext context;\n    auto* validation_context = context.mutable_common_tls_context()->mutable_validation_context();\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    validation_context->add_match_subject_alt_names()->set_suffix(\"lyft.com\");\n    if (clientType() == Grpc::ClientType::GoogleGrpc) {\n      auto* google_grpc = grpc_service->mutable_google_grpc();\n      auto* ssl_creds = google_grpc->mutable_channel_credentials()->mutable_ssl_credentials();\n      ssl_creds->mutable_root_certs()->set_filename(\n          TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    }\n    ads_cluster->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");\n    ads_cluster->mutable_transport_socket()->mutable_typed_config()->PackFrom(context);\n  });\n  HttpIntegrationTest::initialize();\n  if (xds_stream_ == nullptr) {\n    createXdsConnection();\n    AssertionResult result = xds_connection_->waitForNewStream(*dispatcher_, xds_stream_);\n    RELEASE_ASSERT(result, result.message());\n    xds_stream_->startGrpcStream();\n  }\n}", "target": 1}
{"code": "bluetooth_client_get_connectable(const char **uuids)\n{\n\tint i, j;\n\tfor (i = 0; uuids && uuids[i] != NULL; i++) {\n\t\tfor (j = 0; j < G_N_ELEMENTS (connectable_uuids); j++) {\n\t\t\tif (g_str_equal (connectable_uuids[j], uuids[i]))\n\t\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "gfx::AcceleratedWidget RootWindowHostWin::GetAcceleratedWidget() {\n  return hwnd();\n}", "target": 0}
{"code": "static int rfcomm_sock_debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, rfcomm_sock_debugfs_show, inode->i_private);\n}", "target": 0}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "struct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n \ttpgt_str += 5; \n \ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n\tif (tpgt > TL_TPGS_PER_HBA) {\n \t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n \t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n \t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\treturn &tl_tpg->tl_se_tpg;\n}", "target": 1}
{"code": "fbFetch_a1b1g1r1 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  p = Fetch4(bits, i + x);\n        CARD32  a,r,g,b;\n        a = ((p & 0x8) * 0xff) << 21;\n        r = ((p & 0x4) * 0xff) >> 3;\n        g = ((p & 0x2) * 0xff) << 7;\n        b = ((p & 0x1) * 0xff) << 16;\n        WRITE(buffer++, a|r|g|b);\n    }\n}", "target": 0}
{"code": "xmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n if (RAW != '%')\n return;\n    NEXT;\n    name = xmlParseName(ctxt);\n if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n \"xmlParsePEReference: no name\\n\");\n return;\n }\n if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n return;\n }\n    NEXT;\n    ctxt->nbentities++;\n if ((ctxt->sax != NULL) &&\n (ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n if (ctxt->instate == XML_PARSER_EOF)\n return;\n if (entity == NULL) {\n if ((ctxt->standalone == 1) ||\n ((ctxt->hasExternalSubset == 0) &&\n (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n } else {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n \"PEReference: %%%s; not found\\n\",\n\t\t\t  name, NULL);\n\t    ctxt->valid = 0;\n }\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n } else {\n if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n } else if (ctxt->input->free != deallocblankswrapper) {\n\t    input = xmlNewBlanksWrapperInputStream(ctxt, entity);\n \t    if (xmlPushInput(ctxt, input) < 0)\n \t\treturn;\n \t} else {\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n if (xmlPushInput(ctxt, input) < 0)\n return;\n if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n (CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n (IS_BLANK_CH(NXT(5)))) {\n\t\txmlParseTextDecl(ctxt);\n if (ctxt->errNo ==\n\t\t    XML_ERR_UNSUPPORTED_ENCODING) {\n\t\t    xmlHaltParser(ctxt);\n return;\n }\n }\n }\n }\n    ctxt->hasPErefs = 1;\n}", "target": 1}
{"code": "static int cipso_v4_delopt(struct ip_options **opt_ptr)\n{\n\tint hdr_delta = 0;\n\tstruct ip_options *opt = *opt_ptr;\n\tif (opt->srr || opt->rr || opt->ts || opt->router_alert) {\n\t\tu8 cipso_len;\n\t\tu8 cipso_off;\n\t\tunsigned char *cipso_ptr;\n\t\tint iter;\n\t\tint optlen_new;\n\t\tcipso_off = opt->cipso - sizeof(struct iphdr);\n\t\tcipso_ptr = &opt->__data[cipso_off];\n\t\tcipso_len = cipso_ptr[1];\n\t\tif (opt->srr > opt->cipso)\n\t\t\topt->srr -= cipso_len;\n\t\tif (opt->rr > opt->cipso)\n\t\t\topt->rr -= cipso_len;\n\t\tif (opt->ts > opt->cipso)\n\t\t\topt->ts -= cipso_len;\n\t\tif (opt->router_alert > opt->cipso)\n\t\t\topt->router_alert -= cipso_len;\n\t\topt->cipso = 0;\n\t\tmemmove(cipso_ptr, cipso_ptr + cipso_len,\n\t\t\topt->optlen - cipso_off - cipso_len);\n\t\titer = 0;\n\t\toptlen_new = 0;\n\t\twhile (iter < opt->optlen)\n\t\t\tif (opt->__data[iter] != IPOPT_NOP) {\n\t\t\t\titer += opt->__data[iter + 1];\n\t\t\t\toptlen_new = iter;\n\t\t\t} else\n\t\t\t\titer++;\n\t\thdr_delta = opt->optlen;\n\t\topt->optlen = (optlen_new + 3) & ~3;\n\t\thdr_delta -= opt->optlen;\n\t} else {\n\t\t*opt_ptr = NULL;\n\t\thdr_delta = opt->optlen;\n\t\tkfree(opt);\n\t}\n\treturn hdr_delta;\n}", "target": 1}
{"code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n\t    wp += n + stride - 1;\t\n\t    ip += n + stride - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "target": 1}
{"code": "void Shell::OnWindowActivated(\n    aura::client::ActivationChangeObserver::ActivationReason reason,\n    aura::Window* gained_active,\n    aura::Window* lost_active) {\n  if (gained_active)\n    target_root_window_ = gained_active->GetRootWindow();\n}", "target": 0}
{"code": "void iwjson_ftoa(long double val, char buf[static IWNUMBUF_SIZE], size_t *out_len) {\n  int len = snprintf(buf, 64, \"%.8Lf\", val);\n  if (len <= 0) {\n    buf[0] = '\\0';\n    *out_len = 0;\n    return;\n  }\n  while (len > 0 && buf[len - 1] == '0') { \n    buf[len - 1] = '\\0';\n    len--;\n  }\n  if ((len > 0) && (buf[len - 1] == '.')) {\n    buf[len - 1] = '\\0';\n    len--;\n  }\n  *out_len = (size_t) len;\n}", "target": 1}
{"code": "Opal::Call::~Call ()\n{\n}", "target": 0}
{"code": " bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[1024];\n   GooString *gfileName = new GooString (srcFileName);\n   PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n    firstPage = 1;\n  if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n    sprintf (pathName, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n     int errCode = doc->savePageAs(gpageName, pageNo);\n     if ( errCode != errNone) {\n      delete gpageName;\n      delete gfileName;\n      return false;\n    }\n    delete gpageName;\n  }\n  delete gfileName;\n  return true;\n}", "target": 1}
{"code": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\treturn gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n}", "target": 0}
{"code": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n     av_bprint_init(bp, 0, -1);\n     while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n             ret = AVERROR(ENOMEM);\n             goto fail;\n         }\n         zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n         ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n         if (ret != Z_OK && ret != Z_STREAM_END) {\n             ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}", "target": 1}
{"code": "static void wasm_sec_free(RBinWasmSection *sec) {\n\tif (sec) {\n\t\tfree (sec->name);\n\t\tfree (sec);\n\t}\n}", "target": 0}
{"code": "static int nft_set_desc_concat_parse(const struct nlattr *attr,\n\t\t\t\t     struct nft_set_desc *desc)\n{\n\tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n\tu32 len;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n\t\t\t\t\t  nft_concat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_SET_FIELD_LEN])\n\t\treturn -EINVAL;\n\tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n\tif (len * BITS_PER_BYTE / 32 > NFT_REG32_COUNT)\n\t\treturn -E2BIG;\n\tdesc->field_len[desc->field_count++] = len;\n\treturn 0;\n}", "target": 1}
{"code": "do_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "parsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "zsetcolor(i_ctx_t * i_ctx_p)\n{\n    os_ptr                  op = osp;\n    es_ptr ep;\n    const gs_color_space *  pcs = gs_currentcolorspace(igs);\n    gs_client_color         cc;\n    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;\n    PS_colour_space_t *space;\n    cc.pattern = 0;\n    if ((n_comps = cs_num_components(pcs)) < 0) {\n        n_comps = -n_comps;\n         if (r_has_type(op, t_dictionary)) {\n             ref     *pImpl, pPatInst;\n            code = dict_find_string(op, \"Implementation\", &pImpl);\n            if (code != 0) {\n                 code = array_get(imemory, pImpl, 0, &pPatInst);\n                 if (code < 0)\n                     return code;\n                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)\n                      ? n_comps - 1\n                      : 0 );\n            } else\n                n_numeric_comps = 0;\n        } else\n            n_numeric_comps = 0;\n        num_offset = 1;\n    } else\n        n_numeric_comps = n_comps;\n    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);\n    if (code < 0)\n        return code;\n    memset(cc.paint.values + n_numeric_comps, 0,\n            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);\n    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);\n    if (code < 0)\n        return code;\n    if (space->validatecomponents) {\n        code = space->validatecomponents(i_ctx_p,\n                                         &istate->colorspace[0].array,\n                                         cc.paint.values, n_numeric_comps);\n        if (code < 0)\n            return code;\n    }\n    if ((code = gs_setcolor(igs, &cc)) >= 0) {\n        if (n_comps > n_numeric_comps) {\n            istate->pattern[0] = *op;      \n        }\n    }\n    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);\n    if (code < 0)\n        return code;\n    check_estack(5);\n    ep = esp += 1;\n    make_int(ep, 0);\n    ep = esp += 1;\n    make_int(ep, 0);\n    ep = esp += 1;\n    make_int(ep, 0);\n    ep = esp += 1;\n    *ep = istate->colorspace[0].array;\n    push_op_estack(setcolor_cont);\n    return o_push_estack;\n}", "target": 1}
{"code": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n#ifdef CONFIG_SND_CTL_DEBUG\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "CompileResult generateBytecodeForExecution(\n    Module &M,\n    const BytecodeGenerationOptions &genOptions) {\n  std::shared_ptr<Context> context = M.shareContext();\n  CompileResult result{Success};\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    result.bytecodeProvider = hbc::BCProviderFromSrc::createBCProviderFromSrc(\n        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions));\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind for execution\");\n    result = InvalidFlags;\n  }\n  return result;\n}", "target": 1}
{"code": "string handleGet(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n  if (uri.compare(\"/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    body = getLogin();\n  } else if (uri.compare(\"/cal\") == 0 && uid != -1) {\n    cout << \"cal page\" << endl;\n    string username = userNameById(uid);\n    body = getHeader(username);\n    body += getEmptyCalendar();\n    body += getFooter();\n  } else if (uri.compare(\"/getEvents\") == 0 && uid != -1) {\n    body = getEventsJson(uid);\n    resHeaders[\"Content-Type\"] = \"application/json; charset=UTF-8\";\n  } else {\n    cout << \"error page\" << endl;\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}", "target": 1}
{"code": "void QuotaManager::DidGetAvailableSpaceForEviction(\n    QuotaStatusCode status,\n    int64 available_space) {\n  eviction_context_.get_usage_and_quota_callback->Run(status,\n      eviction_context_.usage,\n      eviction_context_.unlimited_usage,\n      eviction_context_.quota, available_space);\n  eviction_context_.get_usage_and_quota_callback.reset();\n}", "target": 0}
{"code": "bool FrameLoaderClient::hasHTMLView() const\n{\n    return true;\n}", "target": 0}
{"code": "static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\tif (len == S_HELLO_LEN && memcmp(data, \"sorbo\", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\t\tprintf(\"Inet check by %s %d\\n\",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n \t*cmd++ = htons(S_CMD_PACKET);\n \t*cmd++ = *pid;\n \tplen = len - 2;\n \tlast_id = ntohs(*pid);\n \tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\tprintf(\"Got packet %d %d\", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\" (DUP)\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\");\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "bool WebGraphicsContext3DDefaultImpl::supportsBGRA()\n{\n    return false;\n}", "target": 0}
{"code": "check_SET_MPLS_TTL(const struct ofpact_mpls_ttl *a OVS_UNUSED,\n                   struct ofpact_check_params *cp)\n{\n    return check_set_mpls(cp);\n}", "target": 0}
{"code": "get_bounding_box (GeglOperation *operation)\n{\n  GeglRectangle result = {0,0,0,0};\n  GeglProperties   *o = GEGL_PROPERTIES (operation);\n  gint width, height;\n  load_cache (o);\n  g_object_get (o->user_data, \"width\", &width,\n                               \"height\", &height, NULL);\n  result.width  = width;\n  result.height = height;\n  return result;\n}", "target": 0}
{"code": "static int date_object_compare_date(zval *d1, zval *d2 TSRMLS_DC)\n{\n\tphp_date_obj *o1 = zend_object_store_get_object(d1 TSRMLS_CC);\n\tphp_date_obj *o2 = zend_object_store_get_object(d2 TSRMLS_CC);\n\tif (!o1->time || !o2->time) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to compare an incomplete DateTime or DateTimeImmutable object\");\n\t\treturn 1;\n\t}\n\tif (!o1->time->sse_uptodate) {\n\t\ttimelib_update_ts(o1->time, o1->time->tz_info);\n\t}\n\tif (!o2->time->sse_uptodate) {\n\t\ttimelib_update_ts(o2->time, o2->time->tz_info);\n\t}\n\treturn (o1->time->sse == o2->time->sse) ? 0 : ((o1->time->sse < o2->time->sse) ? -1 : 1);", "target": 0}
{"code": "pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)\n{\n\tint error;\n\tstruct pci_emul_dummy *dummy;\n\tdummy = calloc(1, sizeof(struct pci_emul_dummy));\n\tdev->arg = dummy;\n\tpci_set_cfgdata16(dev, PCIR_DEVICE, 0x0001);\n\tpci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD);\n\tpci_set_cfgdata8(dev, PCIR_CLASS, 0x02);\n\terror = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\treturn 0;\n}", "target": 1}
{"code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain == 0) {\n\t\t\treturn 0; \n\t\t}\n\t\trlen = remain;\n\t}\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "void ssl_update_cache(SSL *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(s, s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "  static void *operator new(size_t size, MEM_ROOT *mem_root)\n  {\n    return alloc_root(mem_root, size);\n  }", "target": 0}
{"code": "  cff_charset_load( CFF_Charset  charset,\n                    FT_UInt      num_glyphs,\n                    FT_Stream    stream,\n                    FT_ULong     base_offset,\n                    FT_ULong     offset,\n                    FT_Bool      invert )\n  {\n    FT_Memory  memory = stream->memory;\n    FT_Error   error  = CFF_Err_Ok;\n    FT_UShort  glyph_sid;\n    if ( offset > 2 )\n    {\n      FT_UInt  j;\n      charset->offset = base_offset + offset;\n      if ( FT_STREAM_SEEK( charset->offset ) ||\n           FT_READ_BYTE( charset->format )   )\n        goto Exit;\n      if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n        goto Exit;\n      charset->sids[0] = 0;\n      switch ( charset->format )\n      {\n      case 0:\n        if ( num_glyphs > 0 )\n        {\n          if ( FT_FRAME_ENTER( ( num_glyphs - 1 ) * 2 ) )\n             goto Exit;\n           for ( j = 1; j < num_glyphs; j++ )\n            charset->sids[j] = FT_GET_USHORT();\n           FT_FRAME_EXIT();\n         }\n            if ( FT_READ_USHORT( glyph_sid ) )\n              goto Exit;\n            if ( charset->format == 2 )\n            {\n              if ( FT_READ_USHORT( nleft ) )\n                goto Exit;\n            }\n            else\n            {\n              if ( FT_READ_BYTE( nleft ) )\n                goto Exit;\n            }\n            for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ )\n              charset->sids[j] = glyph_sid;\n          }\n        }\n        break;\n      default:\n        FT_ERROR(( \"cff_charset_load: invalid table format!\\n\" ));\n        error = CFF_Err_Invalid_File_Format;\n                 goto Exit;\n             }", "target": 1}
{"code": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n{\n\tchar* path = NULL;\n\tint status;\n\tUINT32 PathLength;\n\tStream_Seek(irp->input, 28);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,\n\t                            &path, 0, NULL, NULL);\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "void CorePageLoadMetricsObserver::OnCommit(\n    content::NavigationHandle* navigation_handle) {\n  transition_ = navigation_handle->GetPageTransition();\n  initiated_by_user_gesture_ = navigation_handle->HasUserGesture();\n}", "target": 0}
{"code": "void FrameLoader::checkIfDisplayInsecureContent(SecurityOrigin* context, const KURL& url)\n{\n    if (!isMixedContent(context, url))\n        return;\n    String message = String::format(\"The page at %s displayed insecure content from %s.\\n\",\n        m_URL.string().utf8().data(), url.string().utf8().data());\n    m_frame->domWindow()->console()->addMessage(HTMLMessageSource, LogMessageType, WarningMessageLevel, message, 1, String());\n    m_client->didDisplayInsecureContent();\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::SetPageFocus(bool focused) {\n  is_focused_ = focused;\n  if (!focused) {\n    if (IsMouseLocked())\n      view_->UnlockMouse();\n    if (touch_emulator_)\n      touch_emulator_->CancelTouch();\n  }\n  GetWidgetInputHandler()->SetFocus(focused);\n  if (RenderViewHost::From(this) && delegate_)\n    delegate_->ReplicatePageFocus(focused);\n}", "target": 0}
{"code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n \tif (!uid_valid(uid) || !gid_valid(gid))\n \t\treturn -EINVAL;\n\tif ((creds->pid == task_tgid_vnr(current) || nsown_capable(CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}", "target": 1}
{"code": "static int llcp_raw_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\tlock_sock(sk);\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\tsk->sk_state = LLCP_BOUND;\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 1}
{"code": "gfx::SwapResult GLSurfaceOzoneSurfaceless::PostSubBuffer(int x,\n                                                         int y,\n                                                         int width,\n                                                         int height) {\n  NOTREACHED();\n  return gfx::SwapResult::SWAP_FAILED;\n}", "target": 0}
{"code": "void HTMLInputElement::setValue(const String& value, TextFieldEventBehavior eventBehavior)\n{\n    if (!m_inputType->canSetValue(value))\n        return;\n    RefPtr<HTMLInputElement> protector(this);\n    EventQueueScope scope;\n    String sanitizedValue = sanitizeValue(value);\n    bool valueChanged = sanitizedValue != this->value();\n    setLastChangeWasNotUserEdit();\n    setFormControlValueMatchesRenderer(false);\n    m_suggestedValue = String(); \n    m_inputType->setValue(sanitizedValue, valueChanged, eventBehavior);\n    if (valueChanged && eventBehavior == DispatchNoEvent)\n        setTextAsOfLastFormControlChangeEvent(sanitizedValue);\n    if (!valueChanged)\n        return;\n    notifyFormStateChanged();\n}", "target": 0}
{"code": "static void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\tvmx->nested.vmxon = false;\n\tfree_vpid(vmx->nested.vpid02);\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tif (vmx->nested.pi_desc_page) {\n\t\tkunmap(vmx->nested.pi_desc_page);\n\t\tnested_release_page(vmx->nested.pi_desc_page);\n\t\tvmx->nested.pi_desc_page = NULL;\n\t\tvmx->nested.pi_desc = NULL;\n\t}\n\tnested_free_all_saved_vmcss(vmx);\n}", "target": 0}
{"code": "static int qrtr_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\tsize_t size, int flags)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, msg->msg_name);\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tint copied, rc;\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\trelease_sock(sk);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb) {\n\t\trelease_sock(sk);\n\t\treturn rc;\n\t}\n\tcb = (struct qrtr_cb *)skb->cb;\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\trc = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = copied;\n\tif (addr) {\n\t\taddr->sq_family = AF_QIPCRTR;\n\t\taddr->sq_node = cb->src_node;\n\t\taddr->sq_port = cb->src_port;\n\t\tmsg->msg_namelen = sizeof(*addr);\n\t}\nout:\n\tif (cb->confirm_rx)\n\t\tqrtr_send_resume_tx(cb);\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "static int domain_update_iommu_superpage(struct intel_iommu *skip)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tint mask = 0xf;\n\tif (!intel_iommu_superpage) {\n\t\treturn 0;\n\t}\n\trcu_read_lock();\n\tfor_each_active_iommu(iommu, drhd) {\n\t\tif (iommu != skip) {\n\t\t\tmask &= cap_super_page_val(iommu->cap);\n\t\t\tif (!mask)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn fls(mask);\n}", "target": 0}
{"code": "llsec_key_alloc(const struct ieee802154_llsec_key *template)\n{\n\tconst int authsizes[3] = { 4, 8, 16 };\n\tstruct mac802154_llsec_key *key;\n\tint i;\n\tkey = kzalloc(sizeof(*key), GFP_KERNEL);\n\tif (!key)\n\t\treturn NULL;\n\tkref_init(&key->ref);\n\tkey->key = *template;\n\tBUILD_BUG_ON(ARRAY_SIZE(authsizes) != ARRAY_SIZE(key->tfm));\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++) {\n\t\tkey->tfm[i] = crypto_alloc_aead(\"ccm(aes)\", 0,\n\t\t\t\t\t\tCRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(key->tfm[i]))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setkey(key->tfm[i], template->key,\n\t\t\t\t       IEEE802154_LLSEC_KEY_SIZE))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setauthsize(key->tfm[i], authsizes[i]))\n\t\t\tgoto err_tfm;\n\t}\n\tkey->tfm0 = crypto_alloc_sync_skcipher(\"ctr(aes)\", 0, 0);\n\tif (IS_ERR(key->tfm0))\n\t\tgoto err_tfm;\n\tif (crypto_sync_skcipher_setkey(key->tfm0, template->key,\n\t\t\t\t   IEEE802154_LLSEC_KEY_SIZE))\n\t\tgoto err_tfm0;\n\treturn key;\nerr_tfm0:\n\tcrypto_free_sync_skcipher(key->tfm0);\nerr_tfm:\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\n\t\tif (key->tfm[i])\n\t\t\tcrypto_free_aead(key->tfm[i]);\n\tkfree_sensitive(key);\n\treturn NULL;\n}", "target": 1}
{"code": "static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int i_head = i->head;\n\tsize_t off;\n\tif (unlikely(bytes > i->count))\n\t\tbytes = i->count;\n\tif (unlikely(!bytes))\n\t\treturn 0;\n\tif (!sanity(i))\n\t\treturn 0;\n\toff = i->iov_offset;\n\tbuf = &pipe->bufs[i_head & p_mask];\n\tif (off) {\n\t\tif (offset == off && buf->page == page) {\n\t\t\tbuf->len += bytes;\n\t\t\ti->iov_offset += bytes;\n\t\t\tgoto out;\n\t\t}\n\t\ti_head++;\n\t\tbuf = &pipe->bufs[i_head & p_mask];\n\t}\n\tif (pipe_full(i_head, p_tail, pipe->max_usage))\n\t\treturn 0;\n\tbuf->ops = &page_cache_pipe_buf_ops;\n\tget_page(page);\n\tbuf->page = page;\n\tbuf->offset = offset;\n\tbuf->len = bytes;\n\tpipe->head = i_head + 1;\n\ti->iov_offset = offset + bytes;\n\ti->head = i_head;\nout:\n\ti->count -= bytes;\n\treturn bytes;\n}", "target": 1}
{"code": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\tstate->dev = dev;\n\tsd = &state->sd;\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"aead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t aead->geniv ?: \"<built-in>\");\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static TEE_Result do_alloc_keypair(struct rsa_keypair *s,\n\t\t\t\t   size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->qp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dq))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "  tt_sbit_decoder_init( TT_SBitDecoder       decoder,\n                        TT_Face              face,\n                        FT_ULong             strike_index,\n                        TT_SBit_MetricsRec*  metrics )\n  {\n    FT_Error   error;\n    FT_Stream  stream = face->root.stream;\n    FT_ULong   ebdt_size;\n    error = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\n    if ( error )\n      goto Exit;\n    decoder->face    = face;\n    decoder->stream  = stream;\n    decoder->bitmap  = &face->root.glyph->bitmap;\n    decoder->metrics = metrics;\n    decoder->metrics_loaded   = 0;\n    decoder->bitmap_allocated = 0;\n    decoder->ebdt_start = FT_STREAM_POS();\n    decoder->ebdt_size  = ebdt_size;\n    decoder->eblc_base  = face->sbit_table;\n    decoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n    {\n      FT_Byte*  p;\n      if ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n      {\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n      p = decoder->eblc_base + 8 + 48 * strike_index;\n      decoder->strike_index_array = FT_NEXT_ULONG( p );\n      p                          += 4;\n      decoder->strike_index_count = FT_NEXT_ULONG( p );\n       p                          += 34;\n       decoder->bit_depth          = *p;\n      if ( decoder->strike_index_array > face->sbit_table_size             ||\n           decoder->strike_index_array + 8 * decoder->strike_index_count >\n             face->sbit_table_size                                         )\n         error = FT_THROW( Invalid_File_Format );\n     }\n  }", "target": 1}
{"code": "const std::string& WebContentsImpl::GetEncoding() const {\n  return encoding_;\n}", "target": 0}
{"code": "pa2l(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 4) {\n        *out++ = L(&palette[in[0] * 4]) / 1000;\n    }\n}", "target": 0}
{"code": "void AudioContext::notifyNodeStartedProcessing(AudioNode* node)\n{\n    refNode(node);\n}", "target": 0}
{"code": "rb_reg_init_str(VALUE re, VALUE s, int options)\n{\n    onig_errmsg_buffer err = \"\";\n    if (rb_reg_initialize_str(re, s, options, err, NULL, 0) != 0) {\n\trb_reg_raise_str(s, options, err);\n    }\n    return re;\n}", "target": 0}
{"code": "SAPI_API int sapi_force_http_10(TSRMLS_D)\n{\n\tif (sapi_module.force_http_10) {\n\t\treturn sapi_module.force_http_10(TSRMLS_C);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}", "target": 0}
{"code": "atol8(const char *p, size_t char_cnt)\n {\n \tint64_t l;\n \tint digit;\n \tl = 0;\n \twhile (char_cnt-- > 0) {\n \t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}", "target": 1}
{"code": "void WebProcessProxy::addMessageReceiver(CoreIPC::StringReference messageReceiverName, CoreIPC::MessageReceiver* messageReceiver)\n{\n    m_messageReceiverMap.addMessageReceiver(messageReceiverName, messageReceiver);\n}", "target": 0}
{"code": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\t*errsv = 0;\n\tif (!type)\n\t\treturn 0;\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tuid = getuid();\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}", "target": 1}
{"code": "static void do_free_keypair(struct rsa_keypair *s)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_object_t k_object = { };\n\tuint32_t key_id = 0;\n\tif (!s)\n\t\treturn;\n\tkey_id = se050_rsa_keypair_from_nvm(s);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::DecrementInFlightEventCount() {\n  if (decrement_in_flight_event_count() <= 0) {\n    StopHangMonitorTimeout();\n  } else {\n    if (!is_hidden_)\n      RestartHangMonitorTimeout();\n  }\n}", "target": 0}
{"code": "my_bool STDCALL mysql_commit(MYSQL * mysql)\n{\n  DBUG_ENTER(\"mysql_commit\");\n  DBUG_RETURN((my_bool) mysql_real_query(mysql, \"commit\", 6));\n}", "target": 0}
{"code": "int sub__add(struct mosquitto *context, const char *sub, uint8_t qos, uint32_t identifier, int options)\n{\n\tint rc = 0;\n\tstruct mosquitto__subhier *subhier;\n\tconst char *sharename = NULL;\n\tchar *local_sub;\n\tchar **topics;\n\tsize_t topiclen;\n\tassert(sub);\n\trc = sub__topic_tokenise(sub, &local_sub, &topics, &sharename);\n\tif(rc) return rc;\n\ttopiclen = strlen(topics[0]);\n\tif(topiclen > UINT16_MAX){\n\t\tmosquitto__free(local_sub);\n\t\tmosquitto__free(topics);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\tHASH_FIND(hh, db.subs, topics[0], topiclen, subhier);\n\tif(!subhier){\n\t\tsubhier = sub__add_hier_entry(NULL, &db.subs, topics[0], (uint16_t)topiclen);\n\t\tif(!subhier){\n\t\t\tmosquitto__free(local_sub);\n\t\t\tmosquitto__free(topics);\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n\trc = sub__add_context(context, sub, qos, identifier, options, subhier, topics, sharename);\n\tmosquitto__free(local_sub);\n\tmosquitto__free(topics);\n\treturn rc;\n}", "target": 1}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n\t\t}\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n\t}\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "bool FrameLoader::isProcessingUserGesture()\n{\n    Frame* frame = m_frame->tree()->top();\n    if (!frame->script()->isEnabled())\n        return true; \n    return frame->script()->processingUserGesture(); \n}", "target": 0}
{"code": "status_t Camera3Device::createDefaultRequest(int templateId,\n         CameraMetadata *request) {\n     ATRACE_CALL();\n     ALOGV(\"%s: for template %d\", __FUNCTION__, templateId);\n     Mutex::Autolock il(mInterfaceLock);\n     Mutex::Autolock l(mLock);\n switch (mStatus) {\n case STATUS_ERROR:\n            CLOGE(\"Device has encountered a serious error\");\n return INVALID_OPERATION;\n case STATUS_UNINITIALIZED:\n            CLOGE(\"Device is not initialized!\");\n return INVALID_OPERATION;\n case STATUS_UNCONFIGURED:\n case STATUS_CONFIGURED:\n case STATUS_ACTIVE:\n break;\n default:\n            SET_ERR_L(\"Unexpected status: %d\", mStatus);\n return INVALID_OPERATION;\n }\n if (!mRequestTemplateCache[templateId].isEmpty()) {\n *request = mRequestTemplateCache[templateId];\n return OK;\n }\n const camera_metadata_t *rawRequest;\n    ATRACE_BEGIN(\"camera3->construct_default_request_settings\");\n    rawRequest = mHal3Device->ops->construct_default_request_settings(\n        mHal3Device, templateId);\n    ATRACE_END();\n if (rawRequest == NULL) {\n        ALOGI(\"%s: template %d is not supported on this camera device\",\n              __FUNCTION__, templateId);\n return BAD_VALUE;\n }\n *request = rawRequest;\n    mRequestTemplateCache[templateId] = rawRequest;\n return OK;\n}", "target": 1}
{"code": "fbCombineDisjointAtopReverseC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    fbCombineDisjointGeneralC (dest, src, mask, width, CombineBAtop);\n}", "target": 0}
{"code": "void Statement::Work_AfterReset(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { env.Null() };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n    STATEMENT_END();\n}", "target": 0}
{"code": "static int vmx_vm_has_apicv(struct kvm *kvm)\n{\n\treturn enable_apicv && irqchip_in_kernel(kvm);\n}", "target": 0}
{"code": "exit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in_shape = context->input(0);\n    const Tensor& out_backprop = context->input(1);\n    OP_REQUIRES(\n        context,\n        tensor_in_shape.dims() == 1 && tensor_in_shape.NumElements() == 5,\n        errors::InvalidArgument(\"tensor_in must be 1-dimensional and 5 \"\n                                \"elements\"));\n    OP_REQUIRES(context, out_backprop.dims() == 5,\n                errors::InvalidArgument(\"out_backprop must be 5-dimensional\"));\n    TensorShape output_shape;\n    auto shape_vec = tensor_in_shape.vec<int32>();\n    for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) {\n      output_shape.AddDim(shape_vec(i));\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    std::array<int64_t, 3> input_size{\n        {GetTensorDim(output_shape, data_format_, '2'),\n         GetTensorDim(output_shape, data_format_, '1'),\n         GetTensorDim(output_shape, data_format_, '0')}};\n    std::array<int64_t, 3> window{{GetTensorDim(ksize_, data_format_, '2'),\n                                   GetTensorDim(ksize_, data_format_, '1'),\n                                   GetTensorDim(ksize_, data_format_, '0')}};\n    std::array<int64_t, 3> stride{{GetTensorDim(stride_, data_format_, '2'),\n                                   GetTensorDim(stride_, data_format_, '1'),\n                                   GetTensorDim(stride_, data_format_, '0')}};\n    std::array<int64_t, 3> padding, out;\n    OP_REQUIRES_OK(context, Get3dOutputSize(input_size, window, stride,\n                                            padding_, &out, &padding));\n    LaunchAvgPooling3dGradOp<Device, T>::launch(\n        context, output_shape, out_backprop, window, stride, out, padding,\n        data_format_, output);\n  }", "target": 1}
{"code": "void HTMLTextAreaElement::updateFocusAppearance(bool restorePreviousSelection)\n{\n    if (!restorePreviousSelection || !hasCachedSelection()) {\n        setSelectionRange(0, 0);\n    } else\n        restoreCachedSelection();\n    if (document().frame())\n        document().frame()->selection().revealSelection();\n}", "target": 0}
{"code": "TEST_F(ExtractorTest, TestDefaultHeaderLocation) {\n  auto headers = TestRequestHeaderMapImpl{{\"Authorization\", \"Bearer jwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 1);\n  EXPECT_EQ(tokens[0]->token(), \"jwt_token\");\n  EXPECT_TRUE(tokens[0]->isIssuerSpecified(\"issuer1\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer2\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer3\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer4\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer5\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"unknown_issuer\"));\n  tokens[0]->removeJwt(headers);\n  EXPECT_FALSE(headers.has(Http::CustomHeaders::get().Authorization));\n}", "target": 0}
{"code": "  Expression_Obj Parser::lex_almost_any_value_chars()\n  {\n    const char* match =\n    lex <\n      one_plus <\n        alternatives <\n          sequence <\n            exactly <'\\\\'>,\n            any_char\n          >,\n          sequence <\n            negate <\n              sequence <\n                exactly < url_kwd >,\n                exactly <'('>\n              >\n            >,\n            neg_class_char <\n              almost_any_value_class\n            >\n          >,\n          sequence <\n            exactly <'/'>,\n            negate <\n              alternatives <\n                exactly <'/'>,\n                exactly <'*'>\n              >\n            >\n          >,\n          sequence <\n            exactly <'\\\\'>,\n            exactly <'#'>,\n            negate <\n              exactly <'{'>\n            >\n          >,\n          sequence <\n            exactly <'!'>,\n            negate <\n              alpha\n            >\n          >\n        >\n      >\n    >(false);\n    if (match) {\n      return SASS_MEMORY_NEW(String_Constant, pstate, lexed);\n    }\n    return {};\n  }", "target": 0}
{"code": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems;\n\tint error;\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\t\tgoto out;\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\tnsems = sma->sem_nsems;\n\tipc_rcu_getref(sma);\n\trcu_read_unlock();\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tif (un) {\n\t\tkfree(new);\n\t\tgoto success;\n\t}\n\tnew->semadj = (short *) &new[1];\n\tnew->ulp = ulp;\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma);\nout:\n\treturn un;\n}", "target": 1}
{"code": "  void SetInput(std::initializer_list<float> data) {\n    QuantizeAndPopulate<uint8_t>(input_, data);\n  }", "target": 0}
{"code": "void RGWGetBucketLogging_ObjStore_S3::send_response()\n{\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n  s->formatter->open_object_section_in_ns(\"BucketLoggingStatus\", XMLNS_AWS_S3);\n  s->formatter->close_section();\n  rgw_flush_formatter_and_reset(s, s->formatter);\n}", "target": 0}
{"code": "bool chopOffDotted(string &domain)\n{\n  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot == string::npos)\n    return false;\n  if(fdot==domain.size()-1) \n    domain=\".\";\n  else  {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain);\n  }\n  return true;\n}", "target": 1}
{"code": "static struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}", "target": 0}
{"code": "  StatusOr<std::vector<int64_t>> GetKernelSize(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return ksize_;\n    }\n    const TensorShape ksize_shape = ctx->InputShape(1);\n    if (!TensorShapeUtils::IsVector(ksize_shape)) {\n      return errors::InvalidArgument(\"ksize must be a vector, not shape \",\n                                     ksize_shape.DebugString());\n    }\n    if (ksize_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window ksize field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> ksize;\n    auto status = ctx->ConstantInputAsIntVector(1, &ksize);\n    if (!status.ok()) {\n      return status;\n    }\n    return ksize;\n  }", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    ReshapeOp::Compute(ctx);\n    const float input_min_float = ctx->input(2).flat<float>()(0);\n    const float input_max_float = ctx->input(3).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n    output_max->flat<float>()(0) = input_max_float;\n  }", "target": 1}
{"code": "  virtual INT64 size() { return _fsize; }", "target": 0}
{"code": "dump_threads(void)\n{\n\tFILE *fp;\n\tchar time_buf[26];\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *file_name;\n\tfile_name = make_file_name(\"/tmp/thread_dump.dat\",\n\t\t\t\t\t\"vrrp\",\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\tglobal_data->instance_name);\n\tfp = fopen(file_name, \"a\");\n\tFREE(file_name);\n\tset_time_now();\n\tctime_r(&time_now.tv_sec, time_buf);\n\tfprintf(fp, \"\\n%.19s.%6.6ld: Thread dump\\n\", time_buf, time_now.tv_usec);\n\tdump_thread_data(master, fp);\n\tfprintf(fp, \"alloc = %lu\\n\", master->alloc);\n\tfprintf(fp, \"\\n\");\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tctime_r(&vrrp->sands.tv_sec, time_buf);\n\t\tfprintf(fp, \"VRRP instance %s, sands %.19s.%6.6lu, status %s\\n\", vrrp->iname, time_buf, vrrp->sands.tv_usec,\n\t\t\t\tvrrp->state == VRRP_STATE_INIT ? \"INIT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_BACK ? \"BACKUP\" :\n\t\t\t\tvrrp->state == VRRP_STATE_MAST ? \"MASTER\" :\n\t\t\t\tvrrp->state == VRRP_STATE_FAULT ? \"FAULT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_STOP ? \"STOP\" :\n\t\t\t\tvrrp->state == VRRP_DISPATCHER ? \"DISPATCHER\" : \"unknown\");\n\t}\n\tfclose(fp);\n}", "target": 1}
{"code": "void FreeMenuItem(const PP_Flash_MenuItem* menu_item) {\n  if (menu_item->name)\n    delete [] menu_item->name;\n  if (menu_item->submenu)\n    FreeMenu(menu_item->submenu);\n}", "target": 0}
{"code": "PLIST_API void plist_from_bin(const char *plist_bin, uint32_t length, plist_t * plist)\n{\n    char *trailer = NULL;\n    uint8_t offset_size = 0;\n    uint8_t dict_size = 0;\n    uint64_t num_objects = 0;\n    uint64_t root_object = 0;\n    uint64_t offset_table_index = 0;\n    char *offset_table = NULL;\n    if (!(length >= BPLIST_MAGIC_SIZE + BPLIST_VERSION_SIZE + BPLIST_TRL_SIZE))\n        return;\n    if (memcmp(plist_bin, BPLIST_MAGIC, BPLIST_MAGIC_SIZE) != 0)\n        return;\n    if (memcmp(plist_bin + BPLIST_MAGIC_SIZE, BPLIST_VERSION, BPLIST_VERSION_SIZE) != 0)\n        return;\n    trailer = (char *) (plist_bin + (length - BPLIST_TRL_SIZE));\n    offset_size = trailer[BPLIST_TRL_OFFSIZE_IDX];\n    dict_size = trailer[BPLIST_TRL_PARMSIZE_IDX];\n    num_objects = be64dec(trailer + BPLIST_TRL_NUMOBJ_IDX);\n    root_object = be64dec(trailer + BPLIST_TRL_ROOTOBJ_IDX);\n    offset_table_index = be64dec(trailer + BPLIST_TRL_OFFTAB_IDX);\n    offset_table = (char *) (plist_bin + offset_table_index);\n    if (num_objects == 0)\n        return;\n    if (root_object >= num_objects)\n        return;\n    if (offset_table < plist_bin || offset_table >= plist_bin + length)\n        return;\n    if (offset_table + num_objects * offset_size >= plist_bin + length)\n        return;\n    if (sizeof(uint32_t) * num_objects < num_objects)\n        return;\n    struct bplist_data bplist;\n    bplist.data = plist_bin;\n    bplist.size = length;\n    bplist.num_objects = num_objects;\n    bplist.dict_size = dict_size;\n    bplist.offset_size = offset_size;\n    bplist.offset_table = offset_table;\n    bplist.level = 0;\n    bplist.used_indexes = (uint32_t*)malloc(sizeof(uint32_t) * num_objects);\n    if (!bplist.used_indexes)\n        return;\n    *plist = parse_bin_node_at_index(&bplist, root_object);\n    free(bplist.used_indexes);\n}", "target": 1}
{"code": "static inline int ReadPropertyByte(const unsigned char **p,size_t *length)\n{\n  int\n    c;\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}", "target": 0}
{"code": "coolkey_get_public_key(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj, CK_KEY_TYPE key_type)\n{\n\tsc_pkcs15_pubkey_t *key;\n\tkey = coolkey_make_public_key(p15card->card, obj, key_type);\n\tif (key) {\n\t\treturn key;\n\t}\n\treturn coolkey_get_public_key_from_certificate(p15card, obj);\n}", "target": 0}
{"code": "void acpi_os_printf(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tacpi_os_vprintf(fmt, args);\n\tva_end(args);\n}", "target": 0}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}", "target": 0}
{"code": "ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_create_iv, int size, int source ) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      iv[--size] = (char)(255.0 * rand() / RAND_MAX);\n    }\n  }\n  return String(iv, n, AttachString);\n}", "target": 1}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 1}
{"code": "UsageTracker::~UsageTracker() {\n  STLDeleteValues(&client_tracker_map_);\n}", "target": 0}
{"code": "rb_handle_timestamp(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t    struct rb_event_info *info)\n{\n\tWARN_ONCE(info->delta > (1ULL << 59),\n\t\t  KERN_WARNING \"Delta way too big! %llu ts=%llu write stamp = %llu\\n%s\",\n\t\t  (unsigned long long)info->delta,\n\t\t  (unsigned long long)info->ts,\n\t\t  (unsigned long long)cpu_buffer->write_stamp,\n\t\t  sched_clock_stable() ? \"\" :\n\t\t  \"If you just came from a suspend/resume,\\n\"\n\t\t  \"please switch to the trace global clock:\\n\"\n\t\t  \"  echo global > /sys/kernel/debug/tracing/trace_clock\\n\");\n\tinfo->add_timestamp = 1;\n}", "target": 0}
{"code": "static NO_INLINE JsVar *jspGetNamedFieldInParents(JsVar *object, const char* name, bool returnName) {\n  JsVar * child = jspeiFindChildFromStringInParents(object, name);\n  if (!child) {\n    child = jswFindBuiltInFunction(object, name);\n  }\n  if (child && returnName) {\n    if (jsvIsName(child)) {\n      JsVar *t = jsvGetValueOfName(child);\n      jsvUnLock(child);\n      child = t;\n    }\n    JsVar *nameVar = jsvNewFromString(name);\n    JsVar *newChild = jsvCreateNewChild(object, nameVar, child);\n    jsvUnLock2(nameVar, child);\n    child = newChild;\n  }\n  if (!child) {\n    if (jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {\n      JsVar *proto = jsvNewObject();\n      jsvObjectSetChild(proto, JSPARSE_CONSTRUCTOR_VAR, object);\n      child = jsvAddNamedChild(object, proto, JSPARSE_PROTOTYPE_VAR);\n      jspEnsureIsPrototype(object, child);\n      jsvUnLock(proto);\n    } else if (strcmp(name, JSPARSE_INHERITS_VAR)==0) {\n      const char *objName = jswGetBasicObjectName(object);\n      if (objName) {\n        child = jspNewPrototype(objName);\n      }\n    }\n  }\n  return child;\n}", "target": 1}
{"code": "bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {\n size_t oldSize = mSize;\n size_t offset = 0;\n while (mSize >= 10 && offset <= mSize - 10) {\n if (!memcmp(&mData[offset], \"\\0\\0\\0\\0\", 4)) {\n break;\n }\n size_t dataSize;\n if (iTunesHack) {\n            dataSize = U32_AT(&mData[offset + 4]);\n } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {\n return false;\n }\n if (dataSize > mSize - 10 - offset) {\n return false;\n }\n uint16_t flags = U16_AT(&mData[offset + 8]);\n uint16_t prevFlags = flags;\n if (flags & 1) {\n if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {\n return false;\n }\n            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);\n            mSize -= 4;\n            dataSize -= 4;\n             flags &= ~1;\n         }\n        if (flags & 2) {\n size_t readOffset = offset + 11;\n size_t writeOffset = offset + 11;\n for (size_t i = 0; i + 1 < dataSize; ++i) {\n if (mData[readOffset - 1] == 0xff\n && mData[readOffset] == 0x00) {\n ++readOffset;\n --mSize;\n --dataSize;\n }\n                 mData[writeOffset++] = mData[readOffset++];\n             }\n            memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);\n            flags &= ~2;\n         }\n         if (flags != prevFlags || iTunesHack) {\n             WriteSyncsafeInteger(&mData[offset + 4], dataSize);\n             mData[offset + 8] = flags >> 8;\n            mData[offset + 9] = flags & 0xff;\n }\n        offset += 10 + dataSize;\n }\n    memset(&mData[mSize], 0, oldSize - mSize);\n return true;\n}", "target": 1}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tresult = Unmaybe(object->Delete(context_handle, key->CopyInto()));\n\t\t}", "target": 1}
{"code": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n \tstruct oz_app_hdr *app_hdr;\n \tstruct oz_serial_ctx *ctx;\n \tspin_lock_bh(&g_cdev.lock);\n \tpd = g_cdev.active_pd;\n \tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}", "target": 1}
{"code": "  TextureManager::TextureInfo* GetTextureInfoForTarget(GLenum target) {\n    TextureUnit& unit = texture_units_[active_texture_unit_];\n    TextureManager::TextureInfo* info = NULL;\n    switch (target) {\n      case GL_TEXTURE_2D:\n        info = unit.bound_texture_2d;\n        break;\n      case GL_TEXTURE_CUBE_MAP:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:\n        info = unit.bound_texture_cube_map;\n        break;\n      default:\n        NOTREACHED();\n        return NULL;\n    }\n    return (info && !info->IsDeleted()) ? info : NULL;\n  }", "target": 0}
{"code": "rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n\t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n\t\t    rxent->client.s_addr == clip &&\n\t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&\n\t\t    rxent->dport == sport) {\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\treturn(0);\n}", "target": 1}
{"code": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n  m_requestParams[key] = value;\n}", "target": 1}
{"code": "rgb2rgba(UINT8 *out, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++) {\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = 255;\n        in++;\n    }\n}", "target": 0}
{"code": "int con_clear_unimap(struct vc_data *vc)\n{\n\tint ret;\n\tconsole_lock();\n\tret = con_do_clear_unimap(vc);\n\tconsole_unlock();\n\treturn ret;\n}", "target": 0}
{"code": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n                 case SIOCFINDIPDDPRT:\n \t\t\tspin_lock_bh(&ipddp_route_lock);\n \t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp)\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n \t\t\tspin_unlock_bh(&ipddp_route_lock);\n \t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n                default:\n                        return -EINVAL;\n        }\n}", "target": 1}
{"code": "gs_heap_alloc_string(gs_memory_t * mem, uint nbytes, client_name_t cname)\n{\n    return gs_heap_alloc_bytes(mem, nbytes, cname);\n}", "target": 0}
{"code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                   (unsigned long) strip, (unsigned long)rows);\n                         return 0;\n                 }\n                bufp += bytes_read;\n         }\n         return 1;\n} ", "target": 1}
{"code": "    long IptcData::size() const\n    {\n        size_t newSize = 0;\n        const_iterator iter = iptcMetadata_.begin();\n        const_iterator end = iptcMetadata_.end();\n        for ( ; iter != end; ++iter) {\n            newSize += 5;\n            size_t dataSize = iter->size();\n            newSize += dataSize;\n            if (dataSize > 32767) {\n                newSize += 4;\n            }\n        }\n        return (long)newSize;\n    }", "target": 0}
{"code": "int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": "void SocketLineReader::dataReceived()\n{\n    while (m_socket->canReadLine()) {\n        const QByteArray line = m_socket->readLine();\n        if (line.length() > 1) { \n            m_packets.enqueue(line);\n        }\n    }\n    if (m_socket->bytesAvailable() > 0) {\n        QMetaObject::invokeMethod(this, \"dataReceived\", Qt::QueuedConnection);\n        return;\n    }\n    if (!m_packets.isEmpty()) {\n        Q_EMIT readyRead();\n    }\n}", "target": 1}
{"code": "void fli_read_brun(FILE *f, s_fli_header *fli_header, unsigned char *framebuf)\n{\n\tunsigned short yc;\n\tunsigned char *pos;\n\tfor (yc=0; yc < fli_header->height; yc++) {\n\t\tunsigned short xc, pc, pcnt;\n\t\tpc=fli_read_char(f);\n\t\txc=0;\n\t\tpos=framebuf+(fli_header->width * yc);\n\t\tfor (pcnt=pc; pcnt>0; pcnt--) {\n\t\t\tunsigned short ps;\n\t\t\tps=fli_read_char(f);\n\t\t\tif (ps & 0x80) {\n\t\t\t\tunsigned short len;\n\t\t\t\tfor (len=-(signed char)ps; len>0; len--) {\n\t\t\t\t\tpos[xc++]=fli_read_char(f);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunsigned char val;\n\t\t\t\tval=fli_read_char(f);\n\t\t\t\tmemset(&(pos[xc]), val, ps);\n\t\t\t\txc+=ps;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "uint_t aubio_tempo_set_delay_ms(aubio_tempo_t * o, smpl_t delay) {\n  o->delay = 1000. * delay * o->samplerate;\n  return AUBIO_OK;\n}", "target": 0}
{"code": "int yr_object_copy(\n    YR_OBJECT* object,\n    YR_OBJECT** object_copy)\n{\n  YR_OBJECT* copy;\n  YR_OBJECT* o;\n  YR_STRUCTURE_MEMBER* structure_member;\n  YR_OBJECT_FUNCTION* func;\n  YR_OBJECT_FUNCTION* func_copy;\n  int i;\n  *object_copy = NULL;\n  FAIL_ON_ERROR(yr_object_create(\n      object->type,\n      object->identifier,\n      NULL,\n      &copy));\n  switch(object->type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      ((YR_OBJECT_INTEGER*) copy)->value = UNDEFINED;\n      break;\n    case OBJECT_TYPE_STRING:\n      ((YR_OBJECT_STRING*) copy)->value = NULL;\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      func = (YR_OBJECT_FUNCTION*) object;\n      func_copy = (YR_OBJECT_FUNCTION*) copy;\n      FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_object_copy(func->return_obj, &func_copy->return_obj),\n        yr_object_destroy(copy));\n      for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        func_copy->prototypes[i] = func->prototypes[i];\n      break;\n    case OBJECT_TYPE_STRUCTURE:\n      structure_member = ((YR_OBJECT_STRUCTURE*) object)->members;\n      while (structure_member != NULL)\n      {\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_copy(structure_member->object, &o),\n            yr_object_destroy(copy));\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(copy, o),\n            yr_free(o);\n            yr_object_destroy(copy));\n        structure_member = structure_member->next;\n      }\n      break;\n    case OBJECT_TYPE_ARRAY:\n      yr_object_copy(\n        ((YR_OBJECT_ARRAY *) object)->prototype_item,\n        &o);\n      ((YR_OBJECT_ARRAY *)copy)->prototype_item = o;\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      yr_object_copy(\n        ((YR_OBJECT_DICTIONARY *) object)->prototype_item,\n        &o);\n      ((YR_OBJECT_DICTIONARY *)copy)->prototype_item = o;\n      break;\n    default:\n      assert(FALSE);\n  }\n  *object_copy = copy;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "attr_unknown_count (void)\n{\n  return transit_hash->count;\n}", "target": 0}
{"code": "static int rx_flow_is_on(struct caifsock *cf_sk)\n{\n\treturn test_bit(RX_FLOW_ON_BIT,\n\t\t\t(void *) &cf_sk->flow_state);\n}", "target": 0}
{"code": "void cql_server::response::write_byte(uint8_t b)\n{\n    auto s = reinterpret_cast<const int8_t*>(&b);\n    _body.write(bytes_view(s, sizeof(b)));\n}", "target": 0}
{"code": "static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)\n{\n    node->isVisited = false;\n    node->childIndex = 0;\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n        tr_variantInitDict(&node->sorted, n);\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted.val.l.vals[i] = *tmp[i].val;\n        }\n        node->sorted.val.l.count = n;\n        tr_free(tmp);\n        node->v = &node->sorted;\n    }\n    else\n    {\n        node->v = v;\n    }\n}", "target": 1}
{"code": "parse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\t*ret_username = NULL;\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\tptr = user_input;\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\tif (*ptr == '\\0') {\n\t\treturn (PAM_BUF_ERR);\n\t}\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t'))\n\t\t\tbreak;\n\t\telse {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\tif ((*ret_username = malloc(index + 1)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\t(void) strcpy(*ret_username, username);\n\treturn (PAM_SUCCESS);\n}", "target": 1}
{"code": "    TiffComponent* newPentaxDngMn2(uint16_t tag,\n                                IfdId    group,\n                                IfdId    mnGroup)\n    {\n        return new TiffIfdMakernote(tag, group, mnGroup, new PentaxDngMnHeader);\n    }", "target": 0}
{"code": "static int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n \tstruct udphdr *uh;\n \tstruct udp_sock  *up = udp_sk(sk);\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n \tint err = 0;\n \tint is_udplite = IS_UDPLITE(sk);\n \t__wsum csum = 0;\n \tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n \t\tgoto out;\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { \n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "  void NotifyNetworkChanged(Network* network) {\n    DCHECK(network);\n    NetworkObserverMap::const_iterator iter = network_observers_.find(\n        network->service_path());\n    if (iter != network_observers_.end()) {\n      FOR_EACH_OBSERVER(NetworkObserver,\n                        *(iter->second),\n                        OnNetworkChanged(this, network));\n    } else {\n      NOTREACHED() <<\n          \"There weren't supposed to be any property change observers of \" <<\n           network->service_path();\n    }\n  }", "target": 0}
{"code": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    for (const std::string& input : node.input())\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder, tfgDialect));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(\n          tf_type::FullTypeAttr type,\n          ConvertAttribute(node.experimental_type(), builder, tfgDialect));\n      state.addAttribute(fulltype_attr, type);\n    }\n    Operation* op = builder.create(state);\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "parse_UNROLL_XLATE(char *arg OVS_UNUSED,\n                   const struct ofpact_parse_params *pp OVS_UNUSED)\n{\n    return xasprintf(\"UNROLL is an internal action \"\n                     \"that shouldn't be used via OpenFlow\");\n}", "target": 0}
{"code": "    inline double log2(const double x) {\n      const double base = std::log(2.0);\n      return std::log(x)/base;", "target": 0}
{"code": "static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)\n{\n    FILE *fp = fopen(dest_filename, \"w\");\n    if (!fp)\n        return false;\n    unsigned fd = 0;\n    while (fd <= 99999) \n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    fclose(fp);\n    return true;\n}", "target": 1}
{"code": "const char *get_errname_from_code(uint error_code)\n{\n  const char *name;\n  if ((name= get_errname_from_code(error_code, global_error_names)) !=\n      unknown_error)\n    return name;\n  return get_errname_from_code(error_code, handler_error_names);\n}", "target": 0}
{"code": "static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)\n{\n\tunsigned char *tmp = skb_tail_pointer(skb);\n\tSKB_LINEAR_ASSERT(skb);\n\tskb->tail += len;\n\tskb->len  += len;\n\treturn tmp;\n}", "target": 0}
{"code": "zrcheck(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    int code = access_check(i_ctx_p, a_read, false);\n    if (code >= 0)\n        make_bool(op, code), code = 0;\n    return code;\n}", "target": 0}
{"code": "static int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,\n\t\t\t\t       struct sof_ipc_ctrl_data *cdata,\n\t\t\t\t       struct sof_ipc_ctrl_data_params *sparams,\n\t\t\t\t       bool send)\n{\n\tstruct sof_ipc_ctrl_data *partdata;\n\tsize_t send_bytes;\n\tsize_t offset = 0;\n\tsize_t msg_bytes;\n\tsize_t pl_size;\n\tint err;\n\tint i;\n\tpartdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!partdata)\n\t\treturn -ENOMEM;\n\tif (send)\n\t\terr = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,\n\t\t\t\t\t       sparams);\n\telse\n\t\terr = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,\n\t\t\t\t\t       sparams);\n\tif (err < 0)\n\t\treturn err;\n\tmsg_bytes = sparams->msg_bytes;\n\tpl_size = sparams->pl_size;\n\tmemcpy(partdata, cdata, sparams->hdr_bytes);\n\tmutex_lock(&sdev->ipc->tx_mutex);\n\tfor (i = 0; i < sparams->num_msg; i++) {\n\t\tsend_bytes = min(msg_bytes, pl_size);\n\t\tpartdata->num_elems = send_bytes;\n\t\tpartdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;\n\t\tpartdata->msg_index = i;\n\t\tmsg_bytes -= send_bytes;\n\t\tpartdata->elems_remaining = msg_bytes;\n\t\tif (send)\n\t\t\tmemcpy(sparams->dst, sparams->src + offset, send_bytes);\n\t\terr = sof_ipc_tx_message_unlocked(sdev->ipc,\n\t\t\t\t\t\t  partdata->rhdr.hdr.cmd,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (!send)\n\t\t\tmemcpy(sparams->dst + offset, sparams->src, send_bytes);\n\t\toffset += pl_size;\n\t}\n\tmutex_unlock(&sdev->ipc->tx_mutex);\n\tkfree(partdata);\n\treturn err;\n}", "target": 1}
{"code": "    JpegImage::JpegImage(BasicIo::AutoPtr io, bool create)\n        : JpegBase(ImageType::jpeg, io, create, blank_, sizeof(blank_))\n    {\n    }", "target": 0}
{"code": "R_API size_t r_str_ansi_strip(char *str) {\n\tsize_t i = 0;\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\tr_str_cpy (str + i + 1, str + i + chlen);\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}", "target": 1}
{"code": "void set_device_ro(struct block_device *bdev, int flag)\n{\n\tbdev->bd_part->policy = flag;\n}", "target": 0}
{"code": "PassRefPtrWillBeRawPtr<Element> ContainerNode::querySelector(const AtomicString& selectors, ExceptionState& exceptionState)\n{\n    if (selectors.isEmpty()) {\n        exceptionState.throwDOMException(SyntaxError, \"The provided selector is empty.\");\n        return nullptr;\n    }\n    SelectorQuery* selectorQuery = document().selectorQueryCache().add(selectors, document(), exceptionState);\n    if (!selectorQuery)\n        return nullptr;\n    NthIndexCache nthIndexCache(document());\n    return selectorQuery->queryFirst(*this);\n}", "target": 0}
{"code": "DocumentLoader* FrameLoader::activeDocumentLoader() const\n{\n    if (m_state == FrameStateProvisional)\n        return m_provisionalDocumentLoader.get();\n    return m_documentLoader.get();\n}", "target": 0}
{"code": "int Item::save_str_value_in_field(Field *field, String *result)\n{\n  if (null_value)\n    return set_field_to_null(field);\n  field->set_notnull();\n  return field->store(result->ptr(), result->length(),\n\t\t      collation.collation);\n}", "target": 0}
{"code": "static bool __is_pointer_value(bool allow_ptr_leaks,\n\t\t\t       const struct bpf_reg_state *reg)\n{\n\tif (allow_ptr_leaks)\n\t\treturn false;\n\treturn reg->type != SCALAR_VALUE;\n}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::HandleDrawArrays(\n    uint32 immediate_data_size, const gles2::DrawArrays& c) {\n  return DoDrawArrays(false,\n                      static_cast<GLenum>(c.mode),\n                      static_cast<GLint>(c.first),\n                      static_cast<GLsizei>(c.count),\n                      0);\n}", "target": 0}
{"code": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n \tstruct ext4_group_desc *gdp = NULL;\n \text4_group_t flex_group_count;\n \text4_group_t flex_group;\n\tint groups_per_flex = 0;\n \tsize_t size;\n \tint i;\n \tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex < 2) {\n \t\tsbi->s_log_groups_per_flex = 0;\n \t\treturn 1;\n \t}\n \tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\treturn 1;\nfailed:\n\treturn 0;\n}", "target": 1}
{"code": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\tdefault:\n\t\t{\n \t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n \t\t\tu64 redir_content;\n\t\t\tASSERT(redir_index < IOAPIC_NUM_PINS);\n\t\t\tredir_content = ioapic->redirtbl[redir_index].bits;\n \t\t\tresult = (ioapic->ioregsel & 0x1) ?\n \t\t\t    (redir_content >> 32) & 0xffffffff :\n \t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static int do_i2c_crc(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t      char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tint\tcount;\n\tuchar\tbyte;\n\tulong\tcrc;\n\tulong\terr;\n\tint ret = 0;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc < 4)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\tcount = hextoul(argv[3], NULL);\n\tprintf (\"CRC32 for %08lx ... %08lx ==> \", addr, addr + count - 1);\n\tcrc = 0;\n\terr = 0;\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, &byte, 1);\n#else\n\t\tret = i2c_read(chip, addr, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\terr++;\n\t\tcrc = crc32(crc, &byte, 1);\n\t\taddr++;\n\t}\n\tif (err > 0)\n\t\ti2c_report_err(ret, I2C_ERR_READ);\n\telse\n\t\tprintf (\"%08lx\\n\", crc);\n\treturn 0;\n}", "target": 1}
{"code": "void php_snmp_add_property(HashTable *h, const char *name, size_t name_length, php_snmp_read_t read_func, php_snmp_write_t write_func)\n{\n\tphp_snmp_prop_handler p;\n\tp.name = (char*) name;\n\tp.name_length = name_length;\n\tp.read_func = (read_func) ? read_func : NULL;\n\tp.write_func = (write_func) ? write_func : NULL;\n\tzend_hash_str_add_mem(h, (char *)name, name_length, &p, sizeof(php_snmp_prop_handler));\n}", "target": 0}
{"code": "GtkWidget* MenuGtk::BuildMenuItemWithImage(const std::string& label,\n                                           const SkBitmap& icon) {\n  std::string converted_label = ConvertAcceleratorsFromWindowsStyle(label);\n  GtkWidget* menu_item =\n      gtk_image_menu_item_new_with_mnemonic(converted_label.c_str());\n  GdkPixbuf* pixbuf = gfx::GdkPixbufFromSkBitmap(&icon);\n  gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item),\n                                gtk_image_new_from_pixbuf(pixbuf));\n  g_object_unref(pixbuf);\n  if (delegate_->AlwaysShowImages())\n    gtk_util::SetAlwaysShowImage(menu_item);\n  return menu_item;\n}", "target": 0}
{"code": "smp_fetch_url_port(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                   const struct arg *args, struct sample *smp)\n{\n\tstruct http_txn *txn = l7;\n\tCHECK_HTTP_MESSAGE_FIRST();\n\turl2sa(txn->req.chn->buf->p + txn->req.sl.rq.u, txn->req.sl.rq.u_l, &l4->req->cons->conn->addr.to);\n\tsmp->type = SMP_T_UINT;\n\tsmp->data.uint = ntohs(((struct sockaddr_in *)&l4->req->cons->conn->addr.to)->sin_port);\n\tif (px->options & PR_O_HTTP_PROXY)\n\t\tl4->flags |= SN_ADDR_SET;\n\tsmp->flags = 0;\n\treturn 1;\n}", "target": 0}
{"code": "pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len;\n\tuint16_t idx;\n\tsc = vsc;\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\twhile (vq_has_descs(vq)) {\n\t\tvq_getchain(vq, &idx, &iov, 1, NULL);\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n\t\tassert(len > 0);\n\t\tvq_relchain(vq, idx, (uint32_t)len);\n\t}\n\tvq_endchains(vq, 1);\t\n}", "target": 1}
{"code": "void QuotaManager::GetLRUOrigin(\n    StorageType type,\n    GetLRUOriginCallback* callback) {\n  LazyInitialize();\n  DCHECK(!lru_origin_callback_.get());\n  lru_origin_callback_.reset(callback);\n  if (db_disabled_) {\n    lru_origin_callback_->Run(GURL());\n    lru_origin_callback_.reset();\n    return;\n  }\n  scoped_refptr<GetLRUOriginTask> task(new GetLRUOriginTask(\n      this, type, origins_in_use_,\n      origins_in_error_, callback_factory_.NewCallback(\n          &QuotaManager::DidGetDatabaseLRUOrigin)));\n  task->Start();\n}", "target": 0}
{"code": "  TfLiteRegistration CancelOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      cancellation_data_.is_cancelled = true;\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "WebUI* WebContentsImpl::GetCommittedWebUI() const {\n  return render_manager_.web_ui();\n}", "target": 0}
{"code": "TEST(BasicFlatBufferModel, TestBuildFromNullAllocation) {\n  TestErrorReporter reporter;\n  std::unique_ptr<Allocation> model_allocation;\n  auto model =\n      FlatBufferModel::BuildFromAllocation(std::move(model_allocation));\n  ASSERT_FALSE(model);\n}", "target": 0}
{"code": "int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tkey_check(key);\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\tdown_write(&key->sem);\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}", "target": 1}
{"code": "SpiceMsgChannels *reds_msg_channels_new(RedsState *reds)\n{\n    SpiceMsgChannels* channels_info;\n    spice_assert(reds != NULL);\n    channels_info = (SpiceMsgChannels *)g_malloc(sizeof(SpiceMsgChannels)\n                            + reds->channels.size() * sizeof(SpiceChannelId));\n    reds_fill_channels(reds, channels_info);\n    return channels_info;\n}", "target": 0}
{"code": "static void process_fd_request(void)\n{\n\tcont = &rw_cont;\n\tschedule_bh(redo_fd_request);\n}", "target": 0}
{"code": "static int em_btc(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV_nobyte(ctxt, \"btc\");\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static int handle_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\terr = kvm_rdpmc(vcpu);\n\tkvm_complete_insn_gp(vcpu, err);\n\treturn 1;\n}", "target": 0}
{"code": "std::string RestAuthHandler::generateJwt(std::string const& username,\n                                         std::string const& password) {\n  AuthenticationFeature* af = AuthenticationFeature::instance();\n  TRI_ASSERT(af != nullptr);\n  return fuerte::jwt::generateUserToken(af->tokenCache().jwtSecret(), username, _validFor);\n}", "target": 1}
{"code": "SAPI_API void sapi_shutdown(void)\n{\n#ifdef ZTS\n\tts_free_id(sapi_globals_id);\n#else\n\tsapi_globals_dtor(&sapi_globals);\n#endif\n\treentrancy_shutdown();\n\tvirtual_cwd_shutdown();\n#ifdef PHP_WIN32\n\ttsrm_win32_shutdown();\n#endif\n}", "target": 0}
{"code": "WebContentsImpl* WebContentsImpl::CreateWithOpener(\n    const WebContents::CreateParams& params,\n    WebContentsImpl* opener) {\n  TRACE_EVENT0(\"browser\", \"WebContentsImpl::CreateWithOpener\");\n  WebContentsImpl* new_contents = new WebContentsImpl(\n      params.browser_context, opener);\n  new_contents->Init(params);\n  return new_contents;\n}", "target": 0}
{"code": "sshkey_load_file(int fd, struct sshbuf *blob)\n{\n \tu_char buf[1024];\n \tsize_t len;\n \tstruct stat st;\n\tint r;\n \tif (fstat(fd, &st) < 0)\n \t\treturn SSH_ERR_SYSTEM_ERROR;\n \tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n \t    st.st_size > MAX_KEY_FILE_SIZE)\n \t\treturn SSH_ERR_INVALID_FORMAT;\n \tfor (;;) {\n \t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n \t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}", "target": 1}
{"code": "vte_sequence_handler_mk (VteTerminal *terminal, GValueArray *params)\n{\n\tterminal->pvt->screen->defaults.attr.invisible = 1;\n}", "target": 0}
{"code": "static int lookup1_values(int entries, int dim)\n{\n    int r = (int) floor(exp((float) log((float) entries) / dim));\n    if ((int) floor(pow((float) r+1, dim)) <= entries)   \n       ++r;                                              \n   assert(pow((float) r+1, dim) > entries);\n   assert((int) floor(pow((float) r, dim)) <= entries); \n    return r;\n }", "target": 1}
{"code": "JSON_read(int fd)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    cJSON *json = NULL;\n    int rc;\n    if (Nread(fd, (char*) &nsize, sizeof(nsize), Ptcp) >= 0) {\n\thsize = ntohl(nsize);\n\tstr = (char *) calloc(sizeof(char), hsize+1);\t\n\tif (str != NULL) {\n\t    rc = Nread(fd, str, hsize, Ptcp);\n\t    if (rc >= 0) {\n\t\tif (rc == hsize) {\n\t\t    json = cJSON_Parse(str);\n\t\t}\n\t\telse {\n\t\t    printf(\"WARNING:  Size of data read does not correspond to offered length\\n\");\n\t\t}\n\t    }\n\t}\n\tfree(str);\n    }\n    return json;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_field_name)\n{\n\tphp_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_NAME);\n}", "target": 0}
{"code": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\treturn 0;\n\t}\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\treturn 0;\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}", "target": 1}
{"code": "void rdma_unlock_handler(struct rdma_cm_id *id)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(id, struct rdma_id_private, id);\n\tmutex_unlock(&id_priv->handler_mutex);\n}", "target": 0}
{"code": "static int em_bt(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_NONE;\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n\temulate_2op_SrcV_nobyte(ctxt, \"bt\");\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "change_refs_to_tmp_fields(THD *thd, Ref_ptr_array ref_pointer_array,\n\t\t\t  List<Item> &res_selected_fields,\n\t\t\t  List<Item> &res_all_fields, uint elements,\n\t\t\t  List<Item> &all_fields)\n{\n  List_iterator_fast<Item> it(all_fields);\n  Item *item, *new_item;\n  res_selected_fields.empty();\n  res_all_fields.empty();\n  uint i, border= all_fields.elements - elements;\n  for (i= 0; (item= it++); i++)\n  {\n    if (item->type() == Item::SUM_FUNC_ITEM && item->const_item())\n      new_item= item;\n    else\n    {\n      if (!(new_item= item->get_tmp_table_item(thd)))\n        return 1;\n    }\n    if (res_all_fields.push_back(new_item, thd->mem_root))\n      return 1;\n    ref_pointer_array[((i < border)? all_fields.elements-i-1 : i-border)]=\n      new_item;\n  }\n  List_iterator_fast<Item> itr(res_all_fields);\n  for (i= 0; i < border; i++)\n    itr++;\n  itr.sublist(res_selected_fields, elements);\n  return thd->is_fatal_error;\n}", "target": 0}
{"code": "const char* menu_cache_item_get_file_basename( MenuCacheItem* item )\n{\n    return item->file_name;\n}", "target": 0}
{"code": "void bnx2x__init_func_obj(struct bnx2x *bp)\n{\n\tbnx2x_setup_dmae(bp);\n\tbnx2x_init_func_obj(bp, &bp->func_obj,\n\t\t\t    bnx2x_sp(bp, func_rdata),\n\t\t\t    bnx2x_sp_mapping(bp, func_rdata),\n\t\t\t    bnx2x_sp(bp, func_afex_rdata),\n\t\t\t    bnx2x_sp_mapping(bp, func_afex_rdata),\n\t\t\t    &bnx2x_func_sp_drv);\n}", "target": 0}
{"code": "    TiffVisitor::~TiffVisitor()\n    {\n    }", "target": 0}
{"code": "blockmix_salsa8(__m128i * Bin, __m128i * Bout, __m128i * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[8 * r - 4], 64);\n  for (i = 0; i < r; i++) {\n    blkxor(X, &Bin[i * 8], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 4], X, 64);\n    blkxor(X, &Bin[i * 8 + 4], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[(r + i) * 4], X, 64);\n  }\n}", "target": 1}
{"code": "static void mcf_fec_do_tx(mcf_fec_state *s)\n{\n    uint32_t addr;\n    mcf_fec_bd bd;\n    int frame_size;\n    int len;\n    uint8_t frame[FEC_MAX_FRAME_SIZE];\n    uint8_t *ptr;\n    DPRINTF(\"do_tx\\n\");\n    ptr = frame;\n    frame_size = 0;\n    addr = s->tx_descriptor;\n    while (1) {\n        mcf_fec_read_bd(&bd, addr);\n        DPRINTF(\"tx_bd %x flags %04x len %d data %08x\\n\",\n                addr, bd.flags, bd.length, bd.data);\n        if ((bd.flags & FEC_BD_R) == 0) {\n            break;\n        }\n        len = bd.length;\n        if (frame_size + len > FEC_MAX_FRAME_SIZE) {\n            len = FEC_MAX_FRAME_SIZE - frame_size;\n            s->eir |= FEC_INT_BABT;\n        }\n        cpu_physical_memory_read(bd.data, ptr, len);\n        ptr += len;\n        frame_size += len;\n        if (bd.flags & FEC_BD_L) {\n            DPRINTF(\"Sending packet\\n\");\n            qemu_send_packet(qemu_get_queue(s->nic), frame, len);\n            ptr = frame;\n            frame_size = 0;\n            s->eir |= FEC_INT_TXF;\n        }\n        s->eir |= FEC_INT_TXB;\n        bd.flags &= ~FEC_BD_R;\n        mcf_fec_write_bd(&bd, addr);\n        if ((bd.flags & FEC_BD_W) != 0) {\n            addr = s->etdsr;\n        } else {\n            addr += 8;\n        }\n    }\n    s->tx_descriptor = addr;\n}", "target": 1}
{"code": "bool PrintMsg_Print_Params_IsValid(const PrintMsg_Print_Params& params) {\n  return !params.content_size.IsEmpty() && !params.page_size.IsEmpty() &&\n         !params.printable_area.IsEmpty() && params.document_cookie &&\n         params.desired_dpi && params.max_shrink && params.min_shrink &&\n         params.dpi && (params.margin_top >= 0) && (params.margin_left >= 0) &&\n         params.dpi > kMinDpi && params.document_cookie != 0;\n}", "target": 0}
{"code": "struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n\t\t\t\t\tconst struct sockaddr_in *addr, int H,\n\t\t\t\t\tconst char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack = mempool_alloc(pack_pool);\n\tif (!pack)\n\t\treturn NULL;\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\tpack->hdr.ver = ver;\n\tpack->hdr.T = 1;\n\tpack->hdr.L = 1;\n\tpack->hdr.S = 1;\n\tmemcpy(&pack->addr, addr, sizeof(*addr));\n\tpack->hide_avps = H;\n\tpack->secret = secret;\n\tpack->secret_len = secret_len;\n\tif (msg_type) {\n\t\tif (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {\n\t\t\tmempool_free(pack);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn pack;\n}", "target": 1}
{"code": "    WebFrameTest()\n        : m_baseURL(\"http:\n        , m_chromeURL(\"chrome:\n        , m_webView(0)\n    {\n    }", "target": 0}
{"code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n {\n \tUINT32 SrcSize = length;\n \trdpGdi* gdi = context->gdi;\n \tbitmap->compressed = FALSE;\n \tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n \tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n \tif (!bitmap->data)\n\t\treturn FALSE;\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "WebContentsImpl::GetRendererManagementDelegate() {\n  return &render_manager_;\n}", "target": 0}
{"code": "int ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {\n  u_int ret = 0, len, idx = in_len, out_idx = 0;\n  len = (*in++)/2;\n  out_len--;\n  out[out_idx] = 0;\n  if((len > out_len) || (len < 1) || ((2*len) > in_len))\n    return(-1);\n  while((len--) && (out_idx < out_len)) {\n    if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {\n      out[out_idx] = 0;\n      break;\n    }\n    out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');\n    in += 2, idx -= 2;\n    if(isprint(out[out_idx]))\n      out_idx++, ret++;\n  }\n  if(out_idx > 0) {\n    out[out_idx] = 0;\n    out_idx--;\n    while((out_idx > 0) && (out[out_idx] == ' ')) {\n      out[out_idx] = 0;\n      out_idx--;\n    }\n  }\n  return(ret);\n}", "target": 1}
{"code": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  response->waitForEndStream();\n  return response;\n}", "target": 1}
{"code": "  AudioSourceProviderClientLockScope(HTMLMediaElement& element)\n      : client_(element.AudioSourceNode()) {\n    if (client_)\n      client_->lock();\n  }", "target": 0}
{"code": "void RenderWidgetHostImpl::DidUpdateBackingStore(\n    const ViewHostMsg_UpdateRect_Params& params,\n    const TimeTicks& paint_start) {\n  TRACE_EVENT0(\"renderer_host\", \"RenderWidgetHostImpl::DidUpdateBackingStore\");\n  TimeTicks update_start = TimeTicks::Now();\n  if (view_)\n    view_->MovePluginWindows(params.plugin_window_moves);\n  NotificationService::current()->Notify(\n      NOTIFICATION_RENDER_WIDGET_HOST_DID_UPDATE_BACKING_STORE,\n      Source<RenderWidgetHost>(this),\n      NotificationService::NoDetails());\n  if (is_hidden_)\n    return;\n  bool is_resize_ack =\n      ViewHostMsg_UpdateRect_Flags::is_resize_ack(params.flags);\n  if (is_resize_ack)\n    WasResized();\n  TimeTicks now = TimeTicks::Now();\n  TimeDelta delta = now - update_start;\n  UMA_HISTOGRAM_TIMES(\"MPArch.RWH_DidUpdateBackingStore\", delta);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    Tensor val;\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->GetTensor(name, &val));\n    ctx->set_output(0, val);\n  }", "target": 1}
{"code": "static void _ewk_view_on_focus_in(void* data, Evas* eventType, Evas_Object* callback, void* eventInfo)\n{\n    Ewk_View_Smart_Data* smartData = static_cast<Ewk_View_Smart_Data*>(data);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api->focus_in);\n    smartData->api->focus_in(smartData);\n}", "target": 0}
{"code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n {\n \tconst u8 *in = inbuf;\n \tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n \tint i, count = 0;\n\tmemset(outbuf, 0, outlen);\n\tin++;\n \tif (outlen < octets_left)\n \t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n \tif (inlen < 1)\n \t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n \twhile (octets_left) {\n\t\tint bits_to_go;\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}", "target": 1}
{"code": "void SavePackage::ContinueGetSaveInfo(const FilePath& suggested_path,\n                                      bool can_save_as_complete) {\n  if (!web_contents() || !download_manager_->GetDelegate())\n    return;\n  FilePath::StringType default_extension;\n  if (can_save_as_complete)\n    default_extension = kDefaultHtmlExtension;\n  download_manager_->GetDelegate()->ChooseSavePath(\n      web_contents(),\n      suggested_path,\n      default_extension,\n      can_save_as_complete,\n      base::Bind(&SavePackage::OnPathPicked, AsWeakPtr()));\n}", "target": 0}
{"code": "static void dtls1_clear_queues(SSL *s)\n\t{\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n\tDTLS1_RECORD_DATA *rdata;\n    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n \twhile ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)\n \t\t{\n\t\tfrag = (hm_fragment *)item->data;\n\t\tOPENSSL_free(frag->fragment);\n\t\tOPENSSL_free(frag);\n \t\tpitem_free(item);\n \t\t}\n \t}", "target": 1}
{"code": "static struct nfs4_ff_layout_mirror *ff_layout_alloc_mirror(gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tmirror = kzalloc(sizeof(*mirror), gfp_flags);\n\tif (mirror != NULL) {\n\t\tspin_lock_init(&mirror->lock);\n\t\trefcount_set(&mirror->ref, 1);\n\t\tINIT_LIST_HEAD(&mirror->mirrors);\n\t}\n\treturn mirror;\n}", "target": 0}
{"code": "void sigsegvHandler(int sig, siginfo_t *info, void *secret) {\n    UNUSED(secret);\n    UNUSED(info);\n    bugReportStart();\n    serverLog(LL_WARNING,\n        \"Redis %s crashed by signal: %d, si_code: %d\", REDIS_VERSION, sig, info->si_code);\n    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getMcontextEip(uc);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n    logStackTrace(getMcontextEip(uc), 1);\n    logRegisters(uc);\n#endif\n    printCrashReport();\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif\n    bugReportEnd(1, sig);\n}", "target": 1}
{"code": "TEST_F(LuaHeaderMapWrapperTest, ModifyAfterIteration) {\n  const std::string SCRIPT{R\"EOF(\n    function callMe(object)\n      for key, value in pairs(object) do\n        testPrint(string.format(\"'%s' '%s'\", key, value))\n      end\n      object:add(\"hello\", \"world\")\n      for key, value in pairs(object) do\n        testPrint(string.format(\"'%s' '%s'\", key, value))\n      end\n    end\n  )EOF\"};\n  InSequence s;\n  setup(SCRIPT);\n  Http::TestRequestHeaderMapImpl headers{{\"foo\", \"bar\"}};\n  HeaderMapWrapper::create(coroutine_->luaState(), headers, []() { return true; });\n  EXPECT_CALL(printer_, testPrint(\"'foo' 'bar'\"));\n  EXPECT_CALL(printer_, testPrint(\"'foo' 'bar'\"));\n  EXPECT_CALL(printer_, testPrint(\"'hello' 'world'\"));\n  start(\"callMe\");\n}", "target": 0}
{"code": "EnableLimitedSchedulingLatency(void)\n{\n    ++SmartScheduleLatencyLimited;\n    SmartScheduleSlice = SmartScheduleInterval;\n}", "target": 0}
{"code": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 1}
{"code": "int STDCALL mysql_server_init(int argc __attribute__((unused)),\n\t\t\t      char **argv __attribute__((unused)),\n\t\t\t      char **groups __attribute__((unused)))\n{\n  int result= 0;\n  if (!mysql_client_init)\n  {\n    mysql_client_init=1;\n    org_my_init_done=my_init_done;\n    if (my_init())\t\t\t\t\n      return 1;\n    init_client_errs();\n    if (mysql_client_plugin_init())\n      return 1;\n    if (!mysql_port)\n    {\n      char *env;\n      struct servent *serv_ptr __attribute__((unused));\n      mysql_port = MYSQL_PORT;\n#if MYSQL_PORT_DEFAULT == 0\n      if ((serv_ptr= getservbyname(\"mysql\", \"tcp\")))\n        mysql_port= (uint) ntohs((ushort) serv_ptr->s_port);\n#endif\n      if ((env= getenv(\"MYSQL_TCP_PORT\")))\n        mysql_port=(uint) atoi(env);\n    }\n    if (!mysql_unix_port)\n    {\n      char *env;\n#ifdef __WIN__\n      mysql_unix_port = (char*) MYSQL_NAMEDPIPE;\n#else\n      mysql_unix_port = (char*) MYSQL_UNIX_ADDR;\n#endif\n      if ((env = getenv(\"MYSQL_UNIX_PORT\")))\n\tmysql_unix_port = env;\n    }\n    mysql_debug(NullS);\n#if defined(SIGPIPE) && !defined(__WIN__)\n    (void) signal(SIGPIPE, SIG_IGN);\n#endif\n#ifdef EMBEDDED_LIBRARY\n    if (argc > -1)\n       result= init_embedded_server(argc, argv, groups);\n#endif\n  }\n  else\n    result= (int)my_thread_init();         \n  return result;\n}", "target": 0}
{"code": "prompt_text(void)\n{\n    if (curbuf->b_prompt_text == NULL)\n\treturn (char_u *)\"% \";\n    return curbuf->b_prompt_text;\n}", "target": 0}
{"code": "pipe_setup (Pipe *pipe, FILE *logf, gpointer user_data)\n{\n\tGIOFlags flags = 0;\n\tpipe->logf = logf;\n\tpipe->buf = g_string_sized_new (512);\n\tpipe->channel = g_io_channel_unix_new (pipe->fd);\n\tg_io_channel_set_encoding (pipe->channel, NULL, NULL);\n\tflags = g_io_channel_get_flags (pipe->channel);\n\tg_io_channel_set_flags (pipe->channel, flags | G_IO_FLAG_NONBLOCK, NULL);\n\tg_io_channel_set_buffered (pipe->channel, FALSE);\n\tpipe->watch = g_io_add_watch (pipe->channel,\n\t                              G_IO_IN | G_IO_ERR | G_IO_PRI,\n\t                              data_available,\n\t                              user_data);\n}", "target": 0}
{"code": "int hugetlb_report_node_meminfo(char *buf, int len, int nid)\n{\n\tstruct hstate *h = &default_hstate;\n\tif (!hugepages_supported())\n\t\treturn 0;\n\treturn sysfs_emit_at(buf, len,\n\t\t\t     \"Node %d HugePages_Total: %5u\\n\"\n\t\t\t     \"Node %d HugePages_Free:  %5u\\n\"\n\t\t\t     \"Node %d HugePages_Surp:  %5u\\n\",\n\t\t\t     nid, h->nr_huge_pages_node[nid],\n\t\t\t     nid, h->free_huge_pages_node[nid],\n\t\t\t     nid, h->surplus_huge_pages_node[nid]);\n}", "target": 0}
{"code": "void PDFiumEngine::RotateClockwise() {\n  current_rotation_ = (current_rotation_ + 1) % 4;\n  RotateInternal();\n}", "target": 0}
{"code": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n\t\t\t struct nf_conntrack_expect *exp)\n{\n\tchar buffer[sizeof(\"4294967296 65635\")];\n\tu_int16_t port;\n\tunsigned int ret;\n\texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n\texp->dir = IP_CT_DIR_REPLY;\n\texp->expectfn = nf_nat_follow_master;\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n\t\treturn NF_DROP;\n\t}\n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n\tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n\t\tnf_ct_unexpect_related(exp);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "ZEND_METHOD(exception, getLine)\n{\n\tDEFAULT_0_PARAMS;\n\t_default_exception_get_entry(getThis(), \"line\", sizeof(\"line\")-1, return_value TSRMLS_CC);\n}", "target": 0}
{"code": "JOIN::add_sorting_to_table(JOIN_TAB *tab, ORDER *order)\n{\n  tab->filesort= \n    new (thd->mem_root) Filesort(order, HA_POS_ERROR, tab->keep_current_rowid,\n                                 tab->select);\n  if (!tab->filesort)\n    return true;\n  if (tab->select)\n  {\n    tab->select= NULL;\n    tab->set_select_cond(NULL, __LINE__);\n  }\n  tab->read_first_record= join_init_read_record;\n  return false;\n}", "target": 0}
{"code": "xsltFreePrincipalStylesheetData(xsltPrincipalStylesheetDataPtr data)\n{\n    if (data == NULL)\n\treturn;\n    if (data->inScopeNamespaces != NULL) {\n\tint i;\n\txsltNsListContainerPtr nsi;\n\txsltPointerListPtr list =\n\t    (xsltPointerListPtr) data->inScopeNamespaces;\n\tfor (i = 0; i < list->number; i++) {\n\t    nsi = (xsltNsListContainerPtr) list->items[i];\n\t    if (nsi->list != NULL)\n\t\txmlFree(nsi->list);\n\t    xmlFree(nsi);\n\t}\n\txsltPointerListFree(list);\n\tdata->inScopeNamespaces = NULL;\n    }\n    if (data->exclResultNamespaces != NULL) {\n\tint i;\n\txsltPointerListPtr list = (xsltPointerListPtr)\n\t    data->exclResultNamespaces;\t\n\tfor (i = 0; i < list->number; i++)\n\t    xsltPointerListFree((xsltPointerListPtr) list->items[i]);\n\txsltPointerListFree(list);\n\tdata->exclResultNamespaces = NULL;\n    }\n    if (data->extElemNamespaces != NULL) {\n\txsltPointerListPtr list = (xsltPointerListPtr)\n\t    data->extElemNamespaces;\n\tint i;\n\tfor (i = 0; i < list->number; i++)\n\t    xsltPointerListFree((xsltPointerListPtr) list->items[i]);\n\txsltPointerListFree(list);\n\tdata->extElemNamespaces = NULL;\n    }\n    if (data->effectiveNs) {\n\txsltLREEffectiveNsNodesFree(data->effectiveNs);\n\tdata->effectiveNs = NULL;\n    }\n#ifdef XSLT_REFACTORED_XSLT_NSCOMP\n    xsltFreeNamespaceMap(data->nsMap);\n#endif\n    xmlFree(data);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }", "target": 1}
{"code": "static RzList  *__io_maps(RzDebug *dbg) {\n\tRzList *list = rz_list_new();\n\tchar *str = dbg->iob.system(dbg->iob.io, \"dm\");\n\tif (!str) {\n\t\trz_list_free(list);\n\t\treturn NULL;\n\t}\n\tchar *ostr = str;\n\tut64 map_start, map_end;\n\tchar perm[32];\n\tchar name[512];\n\tfor (;;) {\n\t\tchar *nl = strchr(str, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t\t*name = 0;\n\t\t\t*perm = 0;\n\t\t\tmap_start = map_end = 0LL;\n\t\t\tif (!strncmp(str, \"sys \", 4)) {\n\t\t\t\tchar *sp = strchr(str + 4, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\tstr = sp + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *_s_ = strstr(str, \" s \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\t_s_ = strstr(str, \" ? \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %s %s\",\n\t\t\t\t&map_start, &map_end, perm, name);\n\t\t\tif (map_end != 0LL) {\n\t\t\t\tRzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm), 0);\n\t\t\t\trz_list_append(list, map);\n\t\t\t}\n\t\t\tstr = nl + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(ostr);\n\trz_cons_reset();\n\treturn list;\n}", "target": 1}
{"code": "GF_EXPORT\nBool gf_isom_has_keep_utc_times(GF_ISOFile *file)\n{\n\tif (!file) return GF_FALSE;\n\treturn file->keep_utc;", "target": 0}
{"code": "static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint len;\n \tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n \t\trfcomm_dlc_accept(d);\n \t\treturn 0;\n \t}\n\tlen = bt_sock_stream_recvmsg(iocb, sock, msg, size, flags);\n\tlock_sock(sk);\n\tif (!(flags & MSG_PEEK) && len > 0)\n\t\tatomic_sub(len, &sk->sk_rmem_alloc);\n\tif (atomic_read(&sk->sk_rmem_alloc) <= (sk->sk_rcvbuf >> 2))\n\t\trfcomm_dlc_unthrottle(rfcomm_pi(sk)->dlc);\n\trelease_sock(sk);\n\treturn len;\n}", "target": 1}
{"code": "void Shell::DoInitialWorkspaceAnimation() {\n  return GetPrimaryRootWindowController()->workspace_controller()->\n      DoInitialAnimation();\n}", "target": 0}
{"code": "GF_Err sbgp_box_size(GF_Box *s)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\tp->size += 8;\n\tif (p->grouping_type_parameter) p->version=1;\n\tif (p->version==1) p->size += 4;\n\tp->size += 8*p->entry_count;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmGlobalEntry *ptr = NULL;\n\tint buflen = bin->buf->length;\n\tif (sec->payload_data + 32 > buflen) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n}", "target": 1}
{"code": "  virtual EthernetNetwork* ethernet_network() { return ethernet_; }", "target": 0}
{"code": "void zone_pcp_reset(struct zone *zone)\n{\n\tunsigned long flags;\n\tint cpu;\n\tstruct per_cpu_pageset *pset;\n\tlocal_irq_save(flags);\n\tif (zone->pageset != &boot_pageset) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tpset = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tdrain_zonestat(zone, pset);\n\t\t}\n\t\tfree_percpu(zone->pageset);\n\t\tzone->pageset = &boot_pageset;\n\t}\n\tlocal_irq_restore(flags);\n}", "target": 0}
{"code": "  explicit HashContext(const HashContext* ctx) {\n    assert(ctx->ops);\n    assert(ctx->ops->context_size >= 0);\n    ops = ctx->ops;\n    context = malloc(ops->context_size);\n    ops->hash_copy(context, ctx->context);\n    options = ctx->options;\n    key = ctx->key ? strdup(ctx->key) : nullptr;\n  }", "target": 1}
{"code": "ikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse\n\t\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}", "target": 1}
{"code": "GF_Err jp2h_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}", "target": 0}
{"code": "Http::FilterDataStatus Context::onRequestBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onRequestBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onRequestBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                               static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}", "target": 1}
{"code": "void SetBuildInfoAnnotations(std::map<std::string, std::string>* annotations) {\n  base::android::BuildInfo* info = base::android::BuildInfo::GetInstance();\n   (*annotations)[\"android_build_id\"] = info->android_build_id();\n   (*annotations)[\"android_build_fp\"] = info->android_build_fp();\n   (*annotations)[\"device\"] = info->device();\n   (*annotations)[\"model\"] = info->model();\n   (*annotations)[\"brand\"] = info->brand();\n  (*annotations)[\"board\"] = info->board();\n  (*annotations)[\"installer_package_name\"] = info->installer_package_name();\n  (*annotations)[\"abi_name\"] = info->abi_name();\n  (*annotations)[\"custom_themes\"] = info->custom_themes();\n  (*annotations)[\"resources_verison\"] = info->resources_version();\n  (*annotations)[\"gms_core_version\"] = info->gms_version_code();\n  if (info->firebase_app_id()[0] != '\\0') {\n    (*annotations)[\"package\"] = std::string(info->firebase_app_id()) + \" v\" +\n                                info->package_version_code() + \" (\" +\n                                info->package_version_name() + \")\";\n  }\n}", "target": 1}
{"code": "static bool ok_jpg_decode_restart_if_needed(ok_jpg_decoder *decoder) {\n    if (decoder->restart_intervals_remaining > 0) {\n        decoder->restart_intervals_remaining--;\n        if (decoder->restart_intervals_remaining == 0) {\n            ok_jpg_dump_bits(decoder);\n            if (decoder->next_marker != 0) {\n                if (decoder->next_marker == 0xD0 + decoder->next_restart) {\n                    decoder->next_marker = 0;\n                } else {\n                    ok_jpg_error(decoder->jpg, OK_JPG_ERROR_INVALID, \"Invalid restart marker (1)\");\n                    return false;\n                }\n            } else {\n                uint8_t buffer[2];\n                if (!ok_read(decoder, buffer, 2)) {\n                    return false;\n                }\n                if (!(buffer[0] == 0xff && buffer[1] == 0xD0 + decoder->next_restart)) {\n                    ok_jpg_error(decoder->jpg, OK_JPG_ERROR_INVALID, \"Invalid restart marker (2)\");\n                    return false;\n                }\n            }\n            decoder->next_restart = (decoder->next_restart + 1) & 7;\n            ok_jpg_decode_restart(decoder);\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "    Classifier (const char *&ptr, int size)\n    {\n        if (size <= 0) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        {\n            char suffix[Name::SIZE+1];\n            memset (suffix, 0, Name::SIZE+1);\n            Xdr::read<CharPtrIO> (ptr, std::min(size, Name::SIZE-1), suffix);\n            _suffix = std::string(suffix);\n        }\n        if (static_cast<size_t>(size) < _suffix.length() + 1 + 2*Xdr::size<char>()) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        char value;\n        Xdr::read<CharPtrIO> (ptr, value);\n        _cscIdx = (int)(value >> 4) - 1;\n        if (_cscIdx < -1 || _cscIdx >= 3) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt cscIdx rule).\");\n        _scheme = (CompressorScheme)((value >> 2) & 3);\n        if (_scheme < 0 || _scheme >= NUM_COMPRESSOR_SCHEMES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt scheme rule).\");\n        _caseInsensitive = (value & 1 ? true : false);\n        Xdr::read<CharPtrIO> (ptr, value);\n        if (value < 0 || value >= NUM_PIXELTYPES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt rule).\");\n        _type = (PixelType)value;\n    }", "target": 0}
{"code": "R_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tr_return_val_if_fail (io, false);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn false;\n\t}\n\tRIOSubMap fake_sm = {{0}};\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (R_LIKELY (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr))) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tmemset (buf, io->Oxff, len);\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_R)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int read_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tif (map->perm & R_PERM_RELOC) {\n\t\t\tret &= map->reloc_map->read (io, map, addr + buf_off, &buf[buf_off], read_len);\n\t\t} else {\n\t\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\t\tret &= (r_io_fd_read_at (io, map->fd, paddr, &buf[buf_off], read_len) == read_len);\n\t\t}\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void HTMLInputElement::defaultEventHandler(Event* evt)\n{\n    if (evt->isMouseEvent() && evt->type() == EventTypeNames::click && toMouseEvent(evt)->button() == LeftButton) {\n        m_inputTypeView->handleClickEvent(toMouseEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isTouchEvent()) {\n        m_inputTypeView->handleTouchEvent(toTouchEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isKeyboardEvent() && evt->type() == EventTypeNames::keydown) {\n        m_inputTypeView->handleKeydownEvent(toKeyboardEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    bool callBaseClassEarly = isTextField() && (evt->type() == EventTypeNames::keydown || evt->type() == EventTypeNames::keypress);\n    if (callBaseClassEarly) {\n        HTMLTextFormControlElement::defaultEventHandler(evt);\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->type() == EventTypeNames::DOMActivate) {\n        m_inputType->handleDOMActivateEvent(evt);\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isKeyboardEvent() && evt->type() == EventTypeNames::keypress) {\n        m_inputTypeView->handleKeypressEvent(toKeyboardEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isKeyboardEvent() && evt->type() == EventTypeNames::keyup) {\n        m_inputTypeView->handleKeyupEvent(toKeyboardEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (m_inputTypeView->shouldSubmitImplicitly(evt)) {\n        if (isSearchField())\n            onSearch();\n        if (wasChangedSinceLastFormControlChangeEvent())\n            dispatchFormControlChangeEvent();\n        RefPtr<HTMLFormElement> formForSubmission = m_inputTypeView->formForSubmission();\n        if (formForSubmission)\n            formForSubmission->submitImplicitly(evt, canTriggerImplicitSubmission());\n        evt->setDefaultHandled();\n        return;\n    }\n    if (evt->isBeforeTextInsertedEvent())\n        m_inputTypeView->handleBeforeTextInsertedEvent(static_cast<BeforeTextInsertedEvent*>(evt));\n    if (evt->isMouseEvent() && evt->type() == EventTypeNames::mousedown) {\n        m_inputTypeView->handleMouseDownEvent(toMouseEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    m_inputTypeView->forwardEvent(evt);\n    if (!callBaseClassEarly && !evt->defaultHandled())\n        HTMLTextFormControlElement::defaultEventHandler(evt);\n}", "target": 0}
{"code": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n    jsonp_free(hashtable->buckets);\n    hashtable->num_buckets++;\n    new_size = num_buckets(hashtable);\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n    return 0;\n}", "target": 1}
{"code": "static PHP_INI_MH(OnChangeMemoryLimit)\n{\n\tif (new_value) {\n\t\tPG(memory_limit) = zend_atol(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));\n\t} else {\n\t\tPG(memory_limit) = 1<<30;\t\t\n\t}\n\treturn zend_set_memory_limit(PG(memory_limit));\n}", "target": 0}
{"code": "rgb2hsv(UINT8 *out, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 4, out += 4) {\n        rgb2hsv_row(out, in);\n        out[3] = in[3];\n    }\n}", "target": 0}
{"code": "int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info)\n{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t  type->policy, NULL);\n\tif (err < 0)\n\t\tgoto err_nla_parse;\n\tinfo->attr = nla;\n\tinfo->ops = type->inner_ops;\n\treturn 0;\nerr_nla_parse:\n\treturn err;\n}", "target": 1}
{"code": "flac_read_loop (SF_PRIVATE *psf, unsigned len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tpflac->pos = 0 ;\n\tpflac->len = len ;\n\tpflac->remain = len ;\n\tif (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)\n\t\tflac_buffer_copy (psf) ;\n\twhile (pflac->pos < pflac->len)\n\t{\tif (FLAC__stream_decoder_process_single (pflac->fsd) == 0)\n\t\t\tbreak ;\n\t\tif (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)\n\t\t\tbreak ;\n\t\t} ;\n\tpflac->ptr = NULL ;\n\treturn pflac->pos ;\n} ", "target": 1}
{"code": "static inline void map_to_unicode(unsigned code, const enc_to_uni *table, unsigned *res)\n{\n\t*res = table->inner[ENT_ENC_TO_UNI_STAGE1(code)]->uni_cp[ENT_ENC_TO_UNI_STAGE2(code)];\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::OnSnapshotDataReceivedAsync(\n    int snapshot_id,\n    scoped_refptr<base::RefCountedBytes> png_data) {\n  if (png_data.get())\n    OnSnapshotDataReceived(snapshot_id, png_data->front(), png_data->size());\n  else\n    OnSnapshotDataReceived(snapshot_id, NULL, 0);\n}", "target": 0}
{"code": "generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name,\n        service_name;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if (! (ret.code = check_handle((void *)handle))) {\n        ret.api_version = handle->api_version;\n    }\n    free_server_handle(handle);\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (ret.code != 0)\n        errmsg = krb5_get_error_message(NULL, ret.code);\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n    krb5_klog_syslog(LOG_NOTICE, _(\"Request: kadm5_init, %.*s%s, %s, \"\n                                   \"client=%.*s%s, service=%.*s%s, addr=%s, \"\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    return(&ret);\n}", "target": 1}
{"code": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n \t\tstruct xfrm_user_tmpl *up = &vec[i];\n \t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n \t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n \t\tup->family = kp->encap_family;\n \t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteTensor* hits;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &hits));\n  const TfLiteTensor* lookup;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &lookup));\n  const TfLiteTensor* key;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &key));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &value));\n  const int num_rows = SizeOfDimension(value, 0);\n  const int row_bytes = value->bytes / num_rows;\n  void* pointer = nullptr;\n  DynamicBuffer buf;\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = -1;\n    pointer = bsearch(&(lookup->data.i32[i]), key->data.i32, num_rows,\n                      sizeof(int32_t), greater);\n    if (pointer != nullptr) {\n      idx = (reinterpret_cast<char*>(pointer) - (key->data.raw)) /\n            sizeof(int32_t);\n    }\n    if (idx >= num_rows || idx < 0) {\n      if (output->type == kTfLiteString) {\n        buf.AddString(nullptr, 0);\n      } else {\n        memset(output->data.raw + i * row_bytes, 0, row_bytes);\n      }\n      hits->data.uint8[i] = 0;\n    } else {\n      if (output->type == kTfLiteString) {\n        buf.AddString(GetString(value, idx));\n      } else {\n        memcpy(output->data.raw + i * row_bytes,\n               value->data.raw + idx * row_bytes, row_bytes);\n      }\n      hits->data.uint8[i] = 1;\n    }\n  }\n  if (output->type == kTfLiteString) {\n    buf.WriteToTensorAsVector(output);\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void free_kvm_area(void)\n{\n\tint cpu;\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}", "target": 0}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n     len = (*p)[0] << 8 | (*p)[1];\n     *p += 2;\n    if( (*p) + len > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                     \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 1}
{"code": "name_appeared_handler (GDBusConnection *connection,\n                       const gchar     *name,\n                       const gchar     *name_owner,\n                       gpointer         user_data)\n{\n  A11yBusLauncher *app = user_data;\n  register_client (app);\n}", "target": 0}
{"code": "static void nvme_mmio_write(void *opaque, hwaddr addr, uint64_t data,\n                            unsigned size)\n{\n    NvmeCtrl *n = (NvmeCtrl *)opaque;\n    trace_pci_nvme_mmio_write(addr, data, size);\n    if (addr < sizeof(n->bar)) {\n        nvme_write_bar(n, addr, data, size);\n    } else {\n        nvme_process_db(n, addr, data);\n    }\n}", "target": 0}
{"code": "void ParamTraits<content::Referrer>::Log(\n    const param_type& p, std::string* l) {\n  l->append(\"(\");\n  LogParam(p.url, l);\n  l->append(\",\");\n  LogParam(p.policy, l);\n  l->append(\")\");\n}", "target": 0}
{"code": "DNS::DNS()\n{\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::DNS\");\n\tmemset(Classes,0,sizeof(Classes));\n\tmemset(requests,0,sizeof(requests));\n\tcurrid = 0;\n\tthis->cache = NULL;\n\tthis->SetFd(-1);\n\tthis->Rehash();\n\tthis->PruneTimer = new CacheTimer(this);\n\tServerInstance->Timers->AddTimer(this->PruneTimer);\n}", "target": 0}
{"code": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= user_match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\tsprintf(description, \"%x\", target_id);\n\tauthkey_ref = search_process_keyrings(&ctx);\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\nerror:\n\treturn authkey;\n}", "target": 1}
{"code": "static void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}", "target": 1}
{"code": "INST_HANDLER (sbrx) {\t\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\n\t\t\t: \"!,!,\");\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "TIFFjpeg_create_decompress(JPEGState* sp)\n{\n\tsp->cinfo.d.err = jpeg_std_error(&sp->err);\n\tsp->err.error_exit = TIFFjpeg_error_exit;\n\tsp->err.output_message = TIFFjpeg_output_message;\n\tsp->cinfo.d.client_data = NULL;\n\treturn CALLVJPEG(sp, jpeg_create_decompress(&sp->cinfo.d));\n}", "target": 0}
{"code": "void VideoRendererBase::Flush(const base::Closure& callback) {\n  base::AutoLock auto_lock(lock_);\n  DCHECK_EQ(state_, kPaused);\n  flush_cb_ = callback;\n  state_ = kFlushingDecoder;\n  base::AutoUnlock auto_unlock(lock_);\n  decoder_->Reset(base::Bind(&VideoRendererBase::OnDecoderFlushDone, this));\n}", "target": 0}
{"code": "pa2ycbcr(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    pa2rgb(out, in, xsize, palette);\n    ImagingConvertRGB2YCbCr(out, out, xsize);\n}", "target": 0}
{"code": "zend_object_iterator *spl_filesystem_dir_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object   *dir_object;\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_dir_it_funcs;\n\t\titerator->current = object;\n\t}\n\tzval_add_ref(&object);\n\treturn (zend_object_iterator*)iterator;\n}", "target": 0}
{"code": "static int sip_endpoint_identifier_str2type(const char *str)\n{\n\tint method;\n\tif (!strcasecmp(str, \"username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME;\n\t} else if (!strcasecmp(str, \"auth_username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME;\n\t} else if (!strcasecmp(str, \"ip\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_IP;\n\t} else if (!strcasecmp(str, \"header\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER;\n\t} else if (!strcasecmp(str, \"request_uri\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI;\n\t} else if (!strcasecmp(str, \"transport\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT;\n\t} else {\n\t\tmethod = -1;\n\t}\n\treturn method;\n}", "target": 1}
{"code": "void AudioContext::removeAutomaticPullNode(AudioNode* node)\n{\n    ASSERT(isGraphOwner());\n    if (m_automaticPullNodes.contains(node)) {\n        m_automaticPullNodes.remove(node);\n        m_automaticPullNodesNeedUpdating = true;\n    }\n}", "target": 0}
{"code": "void PDFiumEngine::Paint(const pp::Rect& rect,\n                         pp::ImageData* image_data,\n                         std::vector<pp::Rect>* ready,\n                         std::vector<pp::Rect>* pending) {\n  DCHECK(image_data);\n  DCHECK(ready);\n  DCHECK(pending);\n  pp::Rect leftover = rect;\n  for (size_t i = 0; i < visible_pages_.size(); ++i) {\n    int index = visible_pages_[i];\n    pp::Rect page_rect = pages_[index]->rect();\n    pp::Rect page_rect_in_screen = GetPageScreenRect(index);\n    pp::Rect dirty_in_screen = page_rect_in_screen.Intersect(leftover);\n    if (dirty_in_screen.IsEmpty())\n      continue;\n    if (i == 0) {\n      pp::Rect blank_space_in_screen = dirty_in_screen;\n      blank_space_in_screen.set_y(0);\n      blank_space_in_screen.set_height(dirty_in_screen.y());\n      leftover = leftover.Subtract(blank_space_in_screen);\n    }\n    leftover = leftover.Subtract(dirty_in_screen);\n    if (pages_[index]->available()) {\n      int progressive = GetProgressiveIndex(index);\n      if (progressive != -1) {\n        DCHECK_GE(progressive, 0);\n        DCHECK_LT(static_cast<size_t>(progressive), progressive_paints_.size());\n        if (progressive_paints_[progressive].rect != dirty_in_screen) {\n          pending->push_back(dirty_in_screen);\n          continue;\n        }\n      }\n      if (progressive == -1) {\n        progressive = StartPaint(index, dirty_in_screen);\n        progressive_paint_timeout_ = kMaxInitialProgressivePaintTimeMs;\n      } else {\n        progressive_paint_timeout_ = kMaxProgressivePaintTimeMs;\n      }\n      progressive_paints_[progressive].painted_ = true;\n      if (ContinuePaint(progressive, image_data)) {\n        FinishPaint(progressive, image_data);\n        ready->push_back(dirty_in_screen);\n      } else {\n        pending->push_back(dirty_in_screen);\n      }\n    } else {\n      PaintUnavailablePage(index, dirty_in_screen, image_data);\n      ready->push_back(dirty_in_screen);\n    }\n  }\n}", "target": 0}
{"code": "nfsd4_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_copy *copy)\n{\n\tstruct file *src, *dst;\n\t__be32 status;\n\tssize_t bytes;\n\tstatus = nfsd4_verify_copy(rqstp, cstate, &copy->cp_src_stateid, &src,\n\t\t\t\t   &copy->cp_dst_stateid, &dst);\n\tif (status)\n\t\tgoto out;\n\tbytes = nfsd_copy_file_range(src, copy->cp_src_pos,\n\t\t\tdst, copy->cp_dst_pos, copy->cp_count);\n\tif (bytes < 0)\n\t\tstatus = nfserrno(bytes);\n\telse {\n\t\tcopy->cp_res.wr_bytes_written = bytes;\n\t\tcopy->cp_res.wr_stable_how = NFS_UNSTABLE;\n\t\tcopy->cp_consecutive = 1;\n\t\tcopy->cp_synchronous = 1;\n\t\tgen_boot_verifier(&copy->cp_res.wr_verifier, SVC_NET(rqstp));\n\t\tstatus = nfs_ok;\n\t}\n\tfput(src);\n\tfput(dst);\nout:\n\treturn status;\n}", "target": 0}
{"code": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 1}
{"code": "snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned char *out, uint32_t *out_len)\n{\n  static snmp_header_t header;\n  static snmp_varbind_t varbinds[SNMP_MAX_NR_VALUES];\n  static uint32_t varbind_length = SNMP_MAX_NR_VALUES;\n  buff = snmp_message_decode(buff, buff_len, &header, varbinds, &varbind_length);\n  if(buff == NULL) {\n    return NULL;\n  }\n  if(header.version != SNMP_VERSION_1) {\n    if(strncmp(header.community.community, SNMP_COMMUNITY, header.community.length)) {\n      LOG_ERR(\"Request with invalid community\\n\");\n      return NULL;\n    }\n  }\n  switch(header.pdu_type) {\n  case SNMP_DATA_TYPE_PDU_GET_REQUEST:\n    if(snmp_engine_get(&header, varbinds, varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  case SNMP_DATA_TYPE_PDU_GET_NEXT_REQUEST:\n    if(snmp_engine_get_next(&header, varbinds, varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  case SNMP_DATA_TYPE_PDU_GET_BULK:\n    if(snmp_engine_get_bulk(&header, varbinds, &varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  default:\n    LOG_ERR(\"Invalid request type\");\n    return NULL;\n  }\n  header.pdu_type = SNMP_DATA_TYPE_PDU_GET_RESPONSE;\n  out = snmp_message_encode(out, out_len, &header, varbinds, varbind_length);\n  return ++out;\n}", "target": 1}
{"code": "  void GrantRequestOfSpecificFile(const FilePath &file) {\n    request_file_set_.insert(file.StripTrailingSeparators());\n  }", "target": 0}
{"code": "static void prio_changed_fair(struct rq *rq, struct task_struct *p,\n\t\t\t      int oldprio, int running)\n{\n\tif (running) {\n\t\tif (p->prio > oldprio)\n\t\t\tresched_task(rq->curr);\n\t} else\n\t\tcheck_preempt_curr(rq, p);\n}", "target": 0}
{"code": "loop_pop(codegen_scope *s, int val)\n{\n  if (val) {\n    genop_1(s, OP_LOADNIL, cursp());\n  }\n  dispatch_linked(s, s->loop->pc2);\n  s->loop = s->loop->prev;\n  if (val) push();\n}", "target": 0}
{"code": "static int present_and_same_family(const struct sadb_address *src,\n\t\t\t\t   const struct sadb_address *dst)\n{\n\tconst struct sockaddr *s_addr, *d_addr;\n\tif (!src || !dst)\n\t\treturn 0;\n\ts_addr = (const struct sockaddr *)(src + 1);\n\td_addr = (const struct sockaddr *)(dst + 1);\n\tif (s_addr->sa_family != d_addr->sa_family)\n\t\treturn 0;\n\tif (s_addr->sa_family != AF_INET\n#if IS_ENABLED(CONFIG_IPV6)\n\t    && s_addr->sa_family != AF_INET6\n#endif\n\t\t)\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "  void GrantBindings(int bindings) {\n    enabled_bindings_ |= bindings;\n  }", "target": 0}
{"code": "vhost_user_set_log_base(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tint fd = msg->fds[0];\n\tuint64_t size, off;\n\tvoid *addr;\n\tif (validate_msg_fds(msg, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (fd < 0) {\n\t\tVHOST_LOG_CONFIG(ERR, \"invalid log fd: %d\\n\", fd);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tif (msg->size != sizeof(VhostUserLog)) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid log base msg size: %\"PRId32\" != %d\\n\",\n\t\t\tmsg->size, (int)sizeof(VhostUserLog));\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tsize = msg->payload.log.mmap_size;\n\toff  = msg->payload.log.mmap_offset;\n\tif (off > size) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"log offset %#\"PRIx64\" exceeds log size %#\"PRIx64\"\\n\",\n\t\t\toff, size);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"log mmap size: %\"PRId64\", offset: %\"PRId64\"\\n\",\n\t\tsize, off);\n\taddr = mmap(0, size + off, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\tclose(fd);\n\tif (addr == MAP_FAILED) {\n\t\tVHOST_LOG_CONFIG(ERR, \"mmap log base failed!\\n\");\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tif (dev->log_addr) {\n\t\tmunmap((void *)(uintptr_t)dev->log_addr, dev->log_size);\n\t}\n\tdev->log_addr = (uint64_t)(uintptr_t)addr;\n\tdev->log_base = dev->log_addr + off;\n\tdev->log_size = size;\n\tmsg->size = 0;\n\tmsg->fd_num = 0;\n\treturn RTE_VHOST_MSG_RESULT_REPLY;\n}", "target": 1}
{"code": "int lg2ff_init(struct hid_device *hid)\n{\n\tstruct lg2ff_device *lg2ff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);\n\tif (!report)\n\t\treturn -ENODEV;\n\tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n\tif (!lg2ff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, lg2ff, play_effect);\n\tif (error) {\n\t\tkfree(lg2ff);\n\t\treturn error;\n\t}\n\tlg2ff->report = report;\n\treport->field[0]->value[0] = 0xf3;\n\treport->field[0]->value[1] = 0x00;\n\treport->field[0]->value[2] = 0x00;\n\treport->field[0]->value[3] = 0x00;\n\treport->field[0]->value[4] = 0x00;\n\treport->field[0]->value[5] = 0x00;\n\treport->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force feedback for Logitech variant 2 rumble devices by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "  double sessionTimeout() const { return _sessionTimeout; }", "target": 0}
{"code": "lua_text_pattern::lua_text_pattern(const string &_pattern)\n    : translated(false), isvalid(true), pattern(_pattern),\n      lua_fn_name(new_fn_name())\n{\n}", "target": 0}
{"code": "static void drive_file_fix_path(WCHAR* path)\n{\n\tsize_t i;\n\tsize_t length = _wcslen(path);\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (path[i] == L'\\\\')\n\t\t\tpath[i] = L'/';\n\t}\n#ifdef WIN32\n\tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n\t\treturn;\n#else\n\tif ((length == 1) && (path[0] == L'/'))\n\t\treturn;\n#endif\n\tif ((length > 0) && (path[length - 1] == L'/'))\n\t\tpath[length - 1] = L'\\0';\n}", "target": 1}
{"code": "static int old_dsa_priv_encode(const EVP_PKEY *pkey, unsigned char **pder)\n{\n    return i2d_DSAPrivateKey(pkey->pkey.dsa, pder);\n}", "target": 0}
{"code": "DECLAREContigPutFunc(putRGBAAcontig8bittile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    while (h-- > 0) {\n\tUNROLL8(w, NOP,\n\t    *cp++ = PACK4(pp[0], pp[1], pp[2], pp[3]);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 0}
{"code": "u32 gf_isom_get_chunk_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_ChunkOffsetBox *stco;\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov || !trackNumber) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->ChunkOffset ) return 0;\n\tstco = (GF_ChunkOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\tif (stco->type == GF_ISOM_BOX_TYPE_STCO)\n\t\treturn stco->nb_entries;\n\tif (stco->type == GF_ISOM_BOX_TYPE_CO64)\n\t\treturn ((GF_ChunkLargeOffsetBox *) stco)->nb_entries;\n\treturn 0;\n}", "target": 0}
{"code": "int adis_update_scan_mode(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tconst struct iio_chan_spec *chan;\n\tunsigned int scan_count;\n\tunsigned int i, j;\n\t__be16 *tx, *rx;\n\tkfree(adis->xfer);\n\tkfree(adis->buffer);\n\tif (adis->burst && adis->burst->en)\n\t\treturn adis_update_scan_mode_burst(indio_dev, scan_mask);\n\tscan_count = indio_dev->scan_bytes / 2;\n\tadis->xfer = kcalloc(scan_count + 1, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\trx = adis->buffer;\n\ttx = rx + scan_count;\n\tspi_message_init(&adis->msg);\n\tfor (j = 0; j <= scan_count; j++) {\n\t\tadis->xfer[j].bits_per_word = 8;\n\t\tif (j != scan_count)\n\t\t\tadis->xfer[j].cs_change = 1;\n\t\tadis->xfer[j].len = 2;\n\t\tadis->xfer[j].delay_usecs = adis->data->read_delay;\n\t\tif (j < scan_count)\n\t\t\tadis->xfer[j].tx_buf = &tx[j];\n\t\tif (j >= 1)\n\t\t\tadis->xfer[j].rx_buf = &rx[j - 1];\n\t\tspi_message_add_tail(&adis->xfer[j], &adis->msg);\n\t}\n\tchan = indio_dev->channels;\n\tfor (i = 0; i < indio_dev->num_channels; i++, chan++) {\n\t\tif (!test_bit(chan->scan_index, scan_mask))\n\t\t\tcontinue;\n\t\tif (chan->scan_type.storagebits == 32)\n\t\t\t*tx++ = cpu_to_be16((chan->address + 2) << 8);\n\t\t*tx++ = cpu_to_be16(chan->address << 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n \t    data[1] = new >> 4;\n \t} else {\n \t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n \t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n \t    else\n \t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}", "target": 1}
{"code": "static inline unsigned char *PopLongPixel(const EndianType endian,\n  const unsigned int pixel,unsigned char *pixels)\n{\n  register unsigned int\n    quantum;\n  quantum=(unsigned int) pixel;\n  if (endian == LSBEndian)\n    {\n      *pixels++=(unsigned char) (quantum);\n      *pixels++=(unsigned char) (quantum >> 8);\n      *pixels++=(unsigned char) (quantum >> 16);\n      *pixels++=(unsigned char) (quantum >> 24);\n      return(pixels);\n    }\n  *pixels++=(unsigned char) (quantum >> 24);\n  *pixels++=(unsigned char) (quantum >> 16);\n  *pixels++=(unsigned char) (quantum >> 8);\n  *pixels++=(unsigned char) (quantum);\n  return(pixels);\n}", "target": 0}
{"code": "static void put_prev_entity(struct cfs_rq *cfs_rq, struct sched_entity *prev)\n{\n\tif (prev->on_rq)\n\t\tupdate_curr(cfs_rq);\n\tcheck_spread(cfs_rq, prev);\n\tif (prev->on_rq) {\n\t\tupdate_stats_wait_start(cfs_rq, prev);\n\t\t__enqueue_entity(cfs_rq, prev);\n\t}\n\tcfs_rq->curr = NULL;\n}", "target": 0}
{"code": "static inline unsigned long rb_page_write(struct buffer_page *bpage)\n{\n\treturn local_read(&bpage->write) & RB_WRITE_MASK;\n}", "target": 0}
{"code": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\tmsg->msg_namelen = 0;\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\tkfree_skb(skb);\nend:\n\treturn err;\n}", "target": 1}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "absl::optional<CelValue> RequestWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Headers) {\n    return CelValue::CreateMap(&headers_);\n  } else if (value == Time) {\n    return CelValue::CreateTimestamp(absl::FromChrono(info_.startTime()));\n  } else if (value == Size) {\n    if (headers_.value_ != nullptr && headers_.value_->ContentLength() != nullptr) {\n      int64_t length;\n      if (absl::SimpleAtoi(headers_.value_->ContentLength()->value().getStringView(), &length)) {\n        return CelValue::CreateInt64(length);\n      }\n    } else {\n      return CelValue::CreateInt64(info_.bytesReceived());\n    }\n  } else if (value == Duration) {\n    auto duration = info_.requestComplete();\n    if (duration.has_value()) {\n      return CelValue::CreateDuration(absl::FromChrono(duration.value()));\n    }\n  }\n  if (headers_.value_ != nullptr) {\n    if (value == Path) {\n      return convertHeaderEntry(headers_.value_->Path());\n    } else if (value == UrlPath) {\n      absl::string_view path = headers_.value_->Path()->value().getStringView();\n      size_t query_offset = path.find('?');\n      if (query_offset == absl::string_view::npos) {\n        return CelValue::CreateString(path);\n      }\n      return CelValue::CreateString(path.substr(0, query_offset));\n    } else if (value == Host) {\n      return convertHeaderEntry(headers_.value_->Host());\n    } else if (value == Scheme) {\n      return convertHeaderEntry(headers_.value_->Scheme());\n    } else if (value == Method) {\n      return convertHeaderEntry(headers_.value_->Method());\n    } else if (value == Referer) {\n      return convertHeaderEntry(headers_.value_->Referer());\n    } else if (value == ID) {\n      return convertHeaderEntry(headers_.value_->RequestId());\n    } else if (value == UserAgent) {\n      return convertHeaderEntry(headers_.value_->UserAgent());\n    } else if (value == TotalSize) {\n      return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize());\n    }\n  }\n  return {};\n}", "target": 1}
{"code": " create_response(const char *nurl, const char *method, unsigned int *rp_code)\n {\n       char *page, *fpath;\n        struct MHD_Response *resp = NULL;\n        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {\n                resp = create_response_api(nurl, method, rp_code);\n        } else {\n                fpath = get_path(nurl, server_data.www_dir);\n               resp = create_response_file(nurl, method, rp_code, fpath);\n                free(fpath);\n        }\n}", "target": 1}
{"code": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}", "target": 1}
{"code": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}", "target": 1}
{"code": "static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)\n{\n\tstruct jbg_dec_state decoder;\n\tint decodeStatus = 0;\n\tunsigned char* pImage = NULL;\n\t(void) size, (void) s;\n\tif (isFillOrder(tif, tif->tif_dir.td_fillorder))\n\t{\n\t\tTIFFReverseBits(tif->tif_rawdata, tif->tif_rawdatasize);\n\t}\n\tjbg_dec_init(&decoder);\n#if defined(HAVE_JBG_NEWLEN)\n\tjbg_newlen(tif->tif_rawdata, (size_t)tif->tif_rawdatasize);\n#endif \n\tdecodeStatus = jbg_dec_in(&decoder, (unsigned char*)tif->tif_rawdata,\n\t\t\t\t  (size_t)tif->tif_rawdatasize, NULL);\n\tif (JBG_EOK != decodeStatus)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"JBIG\", \"Error (%d) decoding: %s\",\n\t\t\t     decodeStatus,\n#if defined(JBG_EN)\n\t\t\t     jbg_strerror(decodeStatus, JBG_EN)\n#else\n\t\t\t     jbg_strerror(decodeStatus)\n#endif\n\t\t\t     );\n\t\tjbg_dec_free(&decoder);\n\t\treturn 0;\n\t}\n\tpImage = jbg_dec_getimage(&decoder, 0);\n\t_TIFFmemcpy(buffer, pImage, jbg_dec_getsize(&decoder));\n\tjbg_dec_free(&decoder);\n\treturn 1;\n}", "target": 1}
{"code": "int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\tat91_aes_init();\n\tif (is_signed) {\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\trc = 0;\nexit:\n\tat91_aes_cleanup();\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\treturn rc;\n}", "target": 1}
{"code": "bool __fastcall TSiteRawDialog::Execute(TSessionData * Data)\n{\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\n  std::unique_ptr<TSessionData> RawData(new TSessionData(L\"\"));\n  RawData->Assign(Data);\n  if (RawData->FSProtocol != fsSFTPonly)\n  {\n    RawData->FSProtocol = FactoryDefaults->FSProtocol;\n  }\n  RawData->HostName = FactoryDefaults->HostName;\n  RawData->PortNumber = FactoryDefaults->PortNumber;\n  RawData->UserName = FactoryDefaults->UserName;\n  RawData->Password = FactoryDefaults->Password;\n  RawData->Ftps = FactoryDefaults->Ftps;\n  std::unique_ptr<TStrings> Options(RawData->SaveToOptions(FactoryDefaults.get(), false, false));\n  SettingsMemo->Lines = Options.get();\n  bool Result = TCustomDialog::Execute();\n  if (Result)\n  {\n    std::unique_ptr<TSessionData> BackupData(new TSessionData(L\"\"));\n    BackupData->Assign(Data);\n    Data->DefaultSettings();\n    Data->FSProtocol = BackupData->FSProtocol;\n    Data->HostName = BackupData->HostName;\n    Data->PortNumber = BackupData->PortNumber;\n    Data->UserName = BackupData->UserName;\n    Data->Password = BackupData->Password;\n    Data->Ftps = BackupData->Ftps;\n    Data->ApplyRawSettings(SettingsMemo->Lines);\n  }\n  return Result;\n}", "target": 1}
{"code": "static inline void unix_insert_socket(struct hlist_head *list, struct sock *sk)\n{\n\tspin_lock(&unix_table_lock);\n\t__unix_insert_socket(list, sk);\n\tspin_unlock(&unix_table_lock);\n}", "target": 0}
{"code": "rfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"%s: client not 8 bits per pixel\\n\",\n                \"rfbSetClientColourMapBGR233\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    scme->type = rfbSetColourMapEntries;\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n    len = sz_rfbSetColourMapEntriesMsg;\n    i = 0;\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 / 7);\n                rgb[i++] = Swap16IfLE(g * 65535 / 7);\n                rgb[i++] = Swap16IfLE(b * 65535 / 3);\n            }\n        }\n    }\n    len += 256 * 3 * 2;\n    if (rfbWriteExact(cl, buf, len) < 0) {\n        rfbLogPerror(\"rfbSetClientColourMapBGR233: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "wsrep_cb_status_t wsrep_sst_donate_cb (void* app_ctx, void* recv_ctx,\n                                       const void* msg, size_t msg_len,\n                                       const wsrep_gtid_t* current_gtid,\n                                       const char* state, size_t state_len,\n                                       bool bypass)\n{\n  local_status.set(WSREP_MEMBER_DONOR);\n  const char* method = (char*)msg;\n  size_t method_len  = strlen (method);\n  const char* data   = method + method_len + 1;\n  char uuid_str[37];\n  wsrep_uuid_print (&current_gtid->uuid, uuid_str, sizeof(uuid_str));\n  wsp::env env(NULL);\n  if (env.error())\n  {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): env var ctor failed: %d\", -env.error());\n    return WSREP_CB_FAILURE;\n  }\n  int ret;\n  if ((ret= sst_append_auth_env(env, sst_auth_real)))\n  {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): appending auth env failed: %d\", ret);\n    return WSREP_CB_FAILURE;\n  }\n  if (!strcmp (WSREP_SST_MYSQLDUMP, method))\n  {\n    ret = sst_donate_mysqldump(data, &current_gtid->uuid, uuid_str,\n                               current_gtid->seqno, bypass, env());\n  }\n  else\n  {\n    ret = sst_donate_other(method, data, uuid_str,\n                           current_gtid->seqno, bypass, env());\n  }\n  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n}", "target": 1}
{"code": "static int tca_action_flush(struct rtattr *rta, struct nlmsghdr *n, u32 pid)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *b;\n\tstruct nlmsghdr *nlh;\n\tstruct tcamsg *t;\n\tstruct netlink_callback dcb;\n\tstruct rtattr *x;\n\tstruct rtattr *tb[TCA_ACT_MAX+1];\n\tstruct rtattr *kind;\n\tstruct tc_action *a = create_a(0);\n\tint err = -EINVAL;\n\tif (a == NULL) {\n\t\tprintk(\"tca_action_flush: couldnt create tc_action\\n\");\n\t\treturn err;\n\t}\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\tprintk(\"tca_action_flush: failed skb alloc\\n\");\n\t\tkfree(a);\n\t\treturn -ENOBUFS;\n\t}\n\tb = (unsigned char *)skb->tail;\n\tif (rtattr_parse_nested(tb, TCA_ACT_MAX, rta) < 0)\n\t\tgoto err_out;\n\tkind = tb[TCA_ACT_KIND-1];\n\ta->ops = tc_lookup_action(kind);\n\tif (a->ops == NULL)\n\t\tgoto err_out;\n\tnlh = NLMSG_PUT(skb, pid, n->nlmsg_seq, RTM_DELACTION, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\terr = a->ops->walk(skb, &dcb, RTM_DELACTION, a);\n\tif (err < 0)\n\t\tgoto rtattr_failure;\n\tx->rta_len = skb->tail - (u8 *) x;\n\tnlh->nlmsg_len = skb->tail - b;\n\tnlh->nlmsg_flags |= NLM_F_ROOT;\n\tmodule_put(a->ops->owner);\n\tkfree(a);\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, n->nlmsg_flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\treturn 0;\n\treturn err;\nrtattr_failure:\n\tmodule_put(a->ops->owner);\nnlmsg_failure:\nerr_out:\n\tkfree_skb(skb);\n\tkfree(a);\n\treturn err;\n}", "target": 1}
{"code": "int js_tointeger(js_State *J, int idx)\n{\n\treturn jsV_numbertointeger(jsV_tonumber(J, stackidx(J, idx)));\n}", "target": 0}
{"code": "static int manager_dispatch_notify_fd(sd_event_source *source, int fd, uint32_t revents, void *userdata) {\n        Manager *m = userdata;\n        ssize_t n;\n        assert(m);\n        assert(m->notify_fd == fd);\n        if (revents != EPOLLIN) {\n                log_warning(\"Got unexpected poll event for notify fd.\");\n                return 0;\n        }\n        for (;;) {\n                char buf[4096];\n                struct iovec iovec = {\n                        .iov_base = buf,\n                        .iov_len = sizeof(buf)-1,\n                };\n                union {\n                        struct cmsghdr cmsghdr;\n                        uint8_t buf[CMSG_SPACE(sizeof(struct ucred))];\n                } control = {};\n                struct msghdr msghdr = {\n                        .msg_iov = &iovec,\n                        .msg_iovlen = 1,\n                        .msg_control = &control,\n                        .msg_controllen = sizeof(control),\n                };\n                struct ucred *ucred;\n                Unit *u;\n                _cleanup_strv_free_ char **tags = NULL;\n                n = recvmsg(m->notify_fd, &msghdr, MSG_DONTWAIT);\n                if (n <= 0) {\n                        if (n == 0)\n                                return -EIO;\n                        if (errno == EAGAIN || errno == EINTR)\n                                break;\n                        return -errno;\n                }\n                if (msghdr.msg_controllen < CMSG_LEN(sizeof(struct ucred)) ||\n                    control.cmsghdr.cmsg_level != SOL_SOCKET ||\n                    control.cmsghdr.cmsg_type != SCM_CREDENTIALS ||\n                    control.cmsghdr.cmsg_len != CMSG_LEN(sizeof(struct ucred))) {\n                        log_warning(\"Received notify message without credentials. Ignoring.\");\n                        continue;\n                }\n                ucred = (struct ucred*) CMSG_DATA(&control.cmsghdr);\n                u = hashmap_get(m->watch_pids, LONG_TO_PTR(ucred->pid));\n                if (!u) {\n                        u = manager_get_unit_by_pid(m, ucred->pid);\n                        if (!u) {\n                                log_warning(\"Cannot find unit for notify message of PID \"PID_FMT\".\", ucred->pid);\n                                continue;\n                        }\n                }\n                assert((size_t) n < sizeof(buf));\n                buf[n] = 0;\n                tags = strv_split(buf, \"\\n\\r\");\n                if (!tags)\n                        return log_oom();\n                log_debug_unit(u->id, \"Got notification message for unit %s\", u->id);\n                if (UNIT_VTABLE(u)->notify_message)\n                        UNIT_VTABLE(u)->notify_message(u, ucred->pid, tags);\n        }\n        return 0;\n}", "target": 1}
{"code": "void smp_send_dhkey_check(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  smp_send_cmd(SMP_OPCODE_PAIR_DHKEY_CHECK, p_cb);\n}", "target": 0}
{"code": "int decomp_get_rddata(js_string *compressed, js_string *out,\n                      unsigned int compressed_offset, int type, int rdlength) {\n    char *desc;\n    int subtype, total, len;\n    desc = decomp_get_rrdesc(type);\n    if(desc == 0) { \n        if(rdlength == 0) {\n            return JS_SUCCESS;\n            }\n        if(decomp_append_bytes(compressed,out,compressed_offset,\n                               rdlength) != JS_SUCCESS) {\n            return JS_ERROR;\n            }\n        else {\n            return JS_SUCCESS;\n            }\n        }\n    else {\n        subtype = *desc;\n        total = 0;\n        while(subtype != 0) {\n            if(subtype > 0 && subtype < 64) {\n                if(decomp_append_bytes(compressed,out,\n                   compressed_offset,subtype) != JS_SUCCESS) {\n                       return JS_ERROR;\n                       }\n                total += subtype;\n                compressed_offset += subtype;\n                }\n            else if(subtype == RRSUB_DLABEL) {\n                len = decomp_append_dlabel(compressed,out,\n                        compressed_offset);\n                if(len == JS_ERROR) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else if(subtype == RRSUB_TEXT) {\n                len = *(compressed->string + compressed_offset);\n                len += 1; \n                if(len < 0 || len > 256) {\n                    return JS_ERROR;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) !=\n                   JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else if(subtype == RRSUB_VARIABLE) {\n                len = rdlength - total;\n                if(len == 0) {\n                    break;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) != JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else { \n                return JS_ERROR;\n                }\n            desc++;\n            if(subtype != RRSUB_VARIABLE)\n                subtype = *desc;\n            else\n                subtype = 0; \n            }\n        if(rdlength != total) {\n            return JS_ERROR;\n            }\n        }\n    return JS_SUCCESS;\n    }", "target": 1}
{"code": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long off;\n\tunsigned long start;\n\tu32 len;\n\tif (!info)\n\t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n\t}\n\tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}", "target": 1}
{"code": "  void *realloc(void *ptr, size_t newsz)\n  {\n    void *ret = ::realloc(ptr, newsz + extra_bytes);\n    forget_ptr(ptr);\n    mem_ptr(ret);\n    return ret;\n  }", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                           \"Control character detected in URL.\");\n             return HTTP_BAD_REQUEST;\n         }\n     }\n     return OK;\n}", "target": 1}
{"code": "mm_compare(struct mm_share *a, struct mm_share *b)\n{\n\tptrdiff_t diff = (char *)a->address - (char *)b->address;\n\tif (diff == 0)\n\t\treturn (0);\n\telse if (diff < 0)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}", "target": 1}
{"code": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\tdev = file->private_data;\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\nexit:\n\tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n}", "target": 1}
{"code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\tbool success = true;\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\tfree(buffer);\n\treturn success;\n}", "target": 1}
{"code": "static void exif_process_CME (image_info_type *image_info, char *value, size_t length)\n{\n\tif (length>3) {\n\t\tswitch(value[2]) {\n\t\t\tcase 0:\n\t\t\t\texif_iif_add_tag(image_info, SECTION_COMMENT, \"Comment\", TAG_COMPUTED_VALUE, TAG_FMT_UNDEFINED, length, value, length);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\texif_iif_add_tag(image_info, SECTION_COMMENT, \"Comment\", TAG_COMPUTED_VALUE, TAG_FMT_STRING, length, value, length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL, E_NOTICE, \"Undefined JPEG2000 comment encoding\");\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\texif_iif_add_tag(image_info, SECTION_COMMENT, \"Comment\", TAG_COMPUTED_VALUE, TAG_FMT_UNDEFINED, 0, NULL, 0);\n\t\tphp_error_docref(NULL, E_NOTICE, \"JPEG2000 comment section too small\");\n\t}\n}", "target": 0}
{"code": "uip_nd6_init()\n{\n#if UIP_ND6_SEND_NA\n  uip_icmp6_register_input_handler(&ns_input_handler);\n#endif\n#if UIP_ND6_SEND_NS\n  uip_icmp6_register_input_handler(&na_input_handler);\n#endif\n#if UIP_CONF_ROUTER && UIP_ND6_SEND_RA\n  uip_icmp6_register_input_handler(&rs_input_handler);\n#endif\n#if !UIP_CONF_ROUTER\n  uip_icmp6_register_input_handler(&ra_input_handler);\n#endif\n}", "target": 0}
{"code": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n \t\tconst void *data, size_t datalen)\n {\n \tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n \tif (*pdata == ctx->from) {\n \t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n \t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "    int MemIo::seek(int64 offset, Position pos )\n    {\n        int64 newIdx = 0;\n        switch (pos) {\n            case BasicIo::cur:\n                newIdx = p_->idx_ + offset;\n                break;\n            case BasicIo::beg:\n                newIdx = offset;\n                break;\n            case BasicIo::end:\n                newIdx = p_->size_ + offset;\n                break;\n        }\n        if (newIdx < 0)\n            return 1;\n        p_->idx_ = static_cast<long>(newIdx);   \n        p_->eof_ = false;\n        return 0;\n    }", "target": 1}
{"code": "  libraw_internal_data_t *get_internal_data_pointer()\n  {\n    return &libraw_internal_data;\n  }", "target": 0}
{"code": "WCHAR* VDir::MapPathW(const WCHAR *pInName)\n{   \n    WCHAR szBuffer[(MAX_PATH+1)*2];\n    WCHAR szlBuf[MAX_PATH+1];\n    int length = wcslen(pInName);\n    if (!length)\n\treturn (WCHAR*)pInName;\n    if (length > MAX_PATH) {\n\twcsncpy(szlBuf, pInName, MAX_PATH);\n\tif (IsPathSep(pInName[0]) && !IsPathSep(pInName[1])) {   \n\t    szlBuf[MAX_PATH-2] = '\\0';\n\t}\n\telse\n\t    szlBuf[MAX_PATH] = '\\0';\n\tpInName = szlBuf;\n    }\n    if (pInName[1] == ':') {\n\tif (IsPathSep(pInName[2])) {\n\t    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t}\n\telse {\n\t    wcscpy(szBuffer, GetDirW(DriveIndex((char)*pInName)));\n\t    wcscat(szBuffer, &pInName[2]);\n\t    if(wcslen(szBuffer) > MAX_PATH)\n\t\tszBuffer[MAX_PATH] = '\\0';\n\t    DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t}\n    }\n    else {\n\tif (IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {\n\t    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t}\n\telse {\n\t    wcscpy(szBuffer, GetDefaultDirW());\n\t    if (IsPathSep(pInName[0])) {\n\t\twcscpy(&szBuffer[2], pInName);\n\t\tDoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t    }\n\t    else {\n\t\tif (IsSpecialFileName(pInName)) {\n\t\t    return (WCHAR*)pInName;\n\t\t}\n\t\telse {\n\t\t    wcscat(szBuffer, pInName);\n\t\t    if (wcslen(szBuffer) > MAX_PATH)\n\t\t\tszBuffer[MAX_PATH] = '\\0';\n\t\t    DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);\n\t\t}\n\t    }\n\t}\n    }\n    return szLocalBufferW;\n}", "target": 1}
{"code": "add_if_prefix_matches(lookup_state_t *state,\n                      const sorted_pattern_t *prefix,\n                      const svn_stringbuf_t *segment)\n{\n  node_t *node = prefix->node;\n  if (   node->segment.len <= segment->len\n      && !memcmp(node->segment.data, segment->data, node->segment.len))\n    add_next_node(state, node);\n}", "target": 0}
{"code": "void ImplPolygon::ImplSplit( sal_uInt16 nPos, sal_uInt16 nSpace, ImplPolygon const * pInitPoly )\n{\n    if (mnPoints + nSpace > USHRT_MAX)\n        return;\n    const sal_uInt16    nNewSize = mnPoints + nSpace;\n    const std::size_t   nSpaceSize = static_cast<std::size_t>(nSpace) * sizeof(Point);\n    if( nPos >= mnPoints )\n    {\n        nPos = mnPoints;\n        ImplSetSize( nNewSize );\n        if( pInitPoly )\n        {\n            memcpy( mpPointAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n            if( pInitPoly->mpFlagAry )\n                memcpy( mpFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n        }\n    }\n    else\n    {\n        const sal_uInt16    nSecPos = nPos + nSpace;\n        const sal_uInt16    nRest = mnPoints - nPos;\n        Point* pNewAry = reinterpret_cast<Point*>(new char[ static_cast<std::size_t>(nNewSize) * sizeof(Point) ]);\n        memcpy( pNewAry, mpPointAry, nPos * sizeof( Point ) );\n        if( pInitPoly )\n            memcpy( pNewAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n        else\n            memset( pNewAry + nPos, 0, nSpaceSize );\n        memcpy( pNewAry + nSecPos, mpPointAry + nPos, nRest * sizeof( Point ) );\n        delete[] reinterpret_cast<char*>(mpPointAry);\n        if( mpFlagAry )\n        {\n            PolyFlags* pNewFlagAry = new PolyFlags[ nNewSize ];\n            memcpy( pNewFlagAry, mpFlagAry, nPos );\n            if( pInitPoly && pInitPoly->mpFlagAry )\n                memcpy( pNewFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n            else\n                memset( pNewFlagAry + nPos, 0, nSpace );\n            memcpy( pNewFlagAry + nSecPos, mpFlagAry + nPos, nRest );\n            delete[] mpFlagAry;\n            mpFlagAry = pNewFlagAry;\n        }\n        mpPointAry = pNewAry;\n        mnPoints   = nNewSize;\n    }\n}", "target": 1}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n \tconst char *msg;\n \tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n \tBUG_ON(dh == NULL);\n \tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "static void mod_wstunnel_merge_config(plugin_config * const pconf, const config_plugin_value_t *cpv) {\n    do {\n        mod_wstunnel_merge_config_cpv(pconf, cpv);\n    } while ((++cpv)->k_id != -1);\n}", "target": 0}
{"code": "static void snd_timer_user_disconnect(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\ttu->disconnected = true;\n\twake_up(&tu->qchange_sleep);\n}", "target": 0}
{"code": " ProcXSendExtensionEvent(ClientPtr client)\n {\n    int ret;\n     DeviceIntPtr dev;\n     xEvent *first;\n     XEventClass *list;\n    struct tmask tmp[EMASKSIZE];\n    REQUEST(xSendExtensionEventReq);\n    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);\n    if (stuff->length !=\n        bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +\n        (stuff->num_events * bytes_to_int32(sizeof(xEvent))))\n        return BadLength;\n    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess);\n    if (ret != Success)\n        return ret;\n    if (stuff->num_events == 0)\n        return ret;\n     first = ((xEvent *) &stuff[1]);\n    if (!((EXTENSION_EVENT_BASE <= first->u.u.type) &&\n          (first->u.u.type < lastEvent))) {\n        client->errorValue = first->u.u.type;\n        return BadValue;\n     }\n     list = (XEventClass *) (first + stuff->num_events);\n        return ret;\n    ret = (SendEvent(client, dev, stuff->destination,\n                     stuff->propagate, (xEvent *) &stuff[1],\n                     tmp[stuff->deviceid].mask, stuff->num_events));\n    return ret;\n}", "target": 1}
{"code": "static int init_strtab(ELFOBJ *bin) {\n\tr_return_val_if_fail (!bin->strtab, false);\n\tif (!bin->shdr) {\n\t\treturn false;\n\t}\n\tElf_(Half) shstrndx = bin->ehdr.e_shstrndx;\n\tif (shstrndx != SHN_UNDEF && !is_shidx_valid (bin, shstrndx)) {\n\t\treturn false;\n\t}\n\tif (bin->shdr[shstrndx].sh_size > UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!bin->shdr[shstrndx].sh_size) {\n\t\treturn false;\n\t}\n\tbin->shstrtab_section = bin->strtab_section = &bin->shdr[shstrndx];\n\tbin->shstrtab_size = bin->shstrtab_section->sh_size;\n\tif (bin->shstrtab_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset + bin->shstrtab_section->sh_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shstrtab = calloc (1, bin->shstrtab_size + 1))) {\n\t\tr_sys_perror (\"malloc\");\n\t\tbin->shstrtab = NULL;\n\t\treturn false;\n\t}\n\tint res = r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,\n\t\tbin->shstrtab_section->sh_size);\n\tif (res < 1) {\n\t\tR_LOG_ERROR (\"read (shstrtab) at 0x%\" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\tbin->shstrtab[bin->shstrtab_section->sh_size] = '\\0';\n\tsdb_num_set (bin->kv, \"elf_shstrtab.offset\", bin->shstrtab_section->sh_offset, 0);\n\tsdb_num_set (bin->kv, \"elf_shstrtab.size\", bin->shstrtab_section->sh_size, 0);\n\treturn true;\n}", "target": 1}
{"code": "static inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}", "target": 0}
{"code": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n  default:\n    break;\n  }\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}", "target": 1}
{"code": "void EC_GROUP_clear_free(EC_GROUP *group)\n\t{\n\tif (!group) return;\n\tif (group->meth->group_clear_finish != 0)\n\t\tgroup->meth->group_clear_finish(group);\n\telse if (group->meth->group_finish != 0)\n\t\tgroup->meth->group_finish(group);\n\tEC_EX_DATA_clear_free_all_data(&group->extra_data);\n\tif (group->generator != NULL)\n        EC_EX_DATA_clear_free_all_data(&group->extra_data);\n        if (group->generator != NULL)\n                EC_POINT_clear_free(group->generator);\n        BN_clear_free(&group->order);\n\tOPENSSL_cleanse(group, sizeof *group);\n\tOPENSSL_free(group);\n\t}", "target": 1}
{"code": "manuf_name_lookup(const guint8 *addr)\n{\n    guint32       manuf_key;\n    guint8       oct;\n    hashmanuf_t  *manuf_value;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL) {\n        return manuf_value;\n    }\n    if ((manuf_key & 0x00010000) != 0) {\n        manuf_key &= 0x00FEFFFF;\n        manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n        if (manuf_value != NULL) {\n            return manuf_value;\n        }\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return manuf_hash_new_entry(addr, short_name, long_name);\n    }\n    return manuf_hash_new_entry(addr, NULL, NULL);\n} ", "target": 1}
{"code": "archive_strncat_l(struct archive_string *as, const void *_p, size_t n,\n    struct archive_string_conv *sc)\n{\n\tconst void *s;\n\tsize_t length;\n\tint i, r = 0, r2;\n\tif (_p == NULL || n == 0) {\n\t\tint tn = 1;\n\t\tif (sc != NULL && (sc->flag & SCONV_TO_UTF16))\n\t\t\ttn = 2;\n\t\tif (archive_string_ensure(as, as->length + tn) == NULL)\n\t\t\treturn (-1);\n\t\tas->s[as->length] = 0;\n\t\tif (tn == 2)\n\t\t\tas->s[as->length+1] = 0;\n\t\treturn (0);\n\t}\n\tif (sc == NULL) {\n\t\tlength = mbsnbytes(_p, n);\n\t\tif (archive_string_append(as, _p, length) == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\tif (sc->flag & SCONV_FROM_UTF16)\n\t\tlength = utf16nbytes(_p, n);\n\telse\n\t\tlength = mbsnbytes(_p, n);\n\ts = _p;\n\ti = 0;\n\tif (sc->nconverter > 1) {\n\t\tsc->utftmp.length = 0;\n\t\tr2 = sc->converter[0](&(sc->utftmp), s, length, sc);\n\t\tif (r2 != 0 && errno == ENOMEM)\n\t\t\treturn (r2);\n\t\tif (r > r2)\n\t\t\tr = r2;\n\t\ts = sc->utftmp.s;\n\t\tlength = sc->utftmp.length;\n\t\t++i;\n\t}\n\tr2 = sc->converter[i](as, s, length, sc);\n\tif (r > r2)\n\t\tr = r2;\n\treturn (r);\n}", "target": 1}
{"code": "static void b43_request_firmware(struct work_struct *work)\n{\n\tstruct b43_wl *wl = container_of(work,\n\t\t\t    struct b43_wl, firmware_load);\n\tstruct b43_wldev *dev = wl->current_dev;\n\tstruct b43_request_fw_context *ctx;\n\tunsigned int i;\n\tint err;\n\tconst char *errmsg;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn;\n\tctx->dev = dev;\n\tctx->req_type = B43_FWTYPE_PROPRIETARY;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; \n\tif (ctx->fatal_failure)\n\t\tgoto out;\n\tctx->req_type = B43_FWTYPE_OPENSOURCE;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; \n\tif(ctx->fatal_failure)\n\t\tgoto out;\n\tfor (i = 0; i < B43_NR_FWTYPES; i++) {\n\t\terrmsg = ctx->errors[i];\n\t\tif (strlen(errmsg))\n\t\t\tb43err(dev->wl, errmsg);\n\t}\n\tb43_print_fw_helptext(dev->wl, 1);\n\tgoto out;\nstart_ieee80211:\n\twl->hw->queues = B43_QOS_QUEUE_NUM;\n\tif (!modparam_qos || dev->fw.opensource)\n\t\twl->hw->queues = 1;\n\terr = ieee80211_register_hw(wl->hw);\n\tif (err)\n\t\tgoto err_one_core_detach;\n\twl->hw_registred = true;\n\tb43_leds_register(wl->current_dev);\n\tgoto out;\nerr_one_core_detach:\n\tb43_one_core_detach(dev->dev);\nout:\n\tkfree(ctx);\n}", "target": 1}
{"code": "int nntp_add_group(char *line, void *data)\n {\n   struct NntpServer *nserv = data;\n   struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING];\n   char desc[HUGE_STRING] = \"\";\n   char mod;\n   anum_t first, last;\n   if (!nserv || !line)\n     return 0;\n  if (sscanf(line, \"%s \" ANUM \" \" ANUM \" %c %[^\\n]\", group, &last, &first, &mod, desc) < 4)\n     return 0;\n   nntp_data = nntp_data_find(nserv, group);\n   nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}", "target": 1}
{"code": "static int ql_alloc_large_buffers(struct ql3_adapter *qdev)\n{\n\tint i;\n\tstruct ql_rcv_buf_cb *lrg_buf_cb;\n\tstruct sk_buff *skb;\n\tdma_addr_t map;\n\tint err;\n\tfor (i = 0; i < qdev->num_large_buffers; i++) {\n\t\tskb = netdev_alloc_skb(qdev->ndev,\n\t\t\t\t       qdev->lrg_buffer_len);\n\t\tif (unlikely(!skb)) {\n\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t   \"large buff alloc failed for %d bytes at index %d\\n\",\n\t\t\t\t   qdev->lrg_buffer_len * 2, i);\n\t\t\tql_free_large_buffers(qdev);\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tlrg_buf_cb = &qdev->lrg_buf[i];\n\t\t\tmemset(lrg_buf_cb, 0, sizeof(struct ql_rcv_buf_cb));\n\t\t\tlrg_buf_cb->index = i;\n\t\t\tlrg_buf_cb->skb = skb;\n\t\t\tskb_reserve(skb, QL_HEADER_SPACE);\n\t\t\tmap = pci_map_single(qdev->pdev,\n\t\t\t\t\t     skb->data,\n\t\t\t\t\t     qdev->lrg_buffer_len -\n\t\t\t\t\t     QL_HEADER_SPACE,\n\t\t\t\t\t     PCI_DMA_FROMDEVICE);\n\t\t\terr = pci_dma_mapping_error(qdev->pdev, map);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t\t   \"PCI mapping failed with error: %d\\n\",\n\t\t\t\t\t   err);\n\t\t\t\tql_free_large_buffers(qdev);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tdma_unmap_addr_set(lrg_buf_cb, mapaddr, map);\n\t\t\tdma_unmap_len_set(lrg_buf_cb, maplen,\n\t\t\t\t\t  qdev->lrg_buffer_len -\n\t\t\t\t\t  QL_HEADER_SPACE);\n\t\t\tlrg_buf_cb->buf_phy_addr_low =\n\t\t\t    cpu_to_le32(LS_64BITS(map));\n\t\t\tlrg_buf_cb->buf_phy_addr_high =\n\t\t\t    cpu_to_le32(MS_64BITS(map));\n\t\t}\n\t}\n\treturn 0;", "target": 1}
{"code": "void RootWindowHostWin::SetCapture() {\n  if (!has_capture_) {\n    has_capture_ = true;\n    ::SetCapture(hwnd());\n  }\n}", "target": 0}
{"code": "static bool is_ready_state(int status)\n{\n\tint state = status & (STATUS_READY | STATUS_DIR | STATUS_DMA);\n\treturn state == STATUS_READY;\n}", "target": 0}
{"code": "kex_input_kexinit(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tconst u_char *ptr;\n\tu_int i;\n\tsize_t dlen;\n\tint r;\n\tdebug(\"SSH2_MSG_KEXINIT received\");\n \tif (kex == NULL)\n \t\treturn SSH_ERR_INVALID_ARGUMENT;\n \tptr = sshpkt_ptr(ssh, &dlen);\n \tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n \t\treturn r;\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++)\n\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0)\n\t\t\treturn r;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tif ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)\n\t\t\treturn r;\n\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\treturn r;\n\tif (!(kex->flags & KEX_INIT_SENT))\n\t\tif ((r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\tif ((r = kex_choose_conf(ssh)) != 0)\n\t\treturn r;\n\tif (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)\n\t\treturn (kex->kex[kex->kex_type])(ssh);\n\treturn SSH_ERR_INTERNAL_ERROR;\n}", "target": 1}
{"code": "static void listdir(unsigned int depth, int f, void * const tls_fd,\n                    const char *name)\n{\n    PureFileInfo *dir;\n    char *names;\n    PureFileInfo *s;\n    PureFileInfo *r;\n    int d;\n    if (depth >= max_ls_depth || matches >= max_ls_files) {\n        return;\n    }\n    if ((dir = sreaddir(&names)) == NULL) {\n        addreply(226, MSG_CANT_READ_FILE, name);\n        return;\n    }\n    s = dir;\n    while (s->name_offset != (size_t) -1) {\n        d = 0;\n        if (FI_NAME(s)[0] != '.') {\n            d = listfile(s, NULL);\n        } else if (opt_a) {\n            if (FI_NAME(s)[1] == 0 ||\n                (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {\n                listfile(s, NULL);\n            } else {\n                d = listfile(s, NULL);\n            }\n        }\n        if (!d) {\n            s->name_offset = (size_t) -1;\n        }\n        s++;\n    }\n    outputfiles(f, tls_fd);\n    r = dir;\n    while (opt_R && r != s) {\n        if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {\n            char *alloca_subdir;\n            const size_t sizeof_subdir = PATH_MAX + 1U;\n            if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {\n                goto toomany;\n            }\n            if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",\n                                 name, FI_NAME(r)), sizeof_subdir)) {\n                goto nolist;\n            }\n            wrstr(f, tls_fd, \"\\r\\n\\r\\n\");\n            wrstr(f, tls_fd, alloca_subdir);\n            wrstr(f, tls_fd, \":\\r\\n\\r\\n\");\n            listdir(depth + 1U, f, tls_fd, alloca_subdir);\n            nolist:\n            ALLOCA_FREE(alloca_subdir);\n            if (matches >= max_ls_files) {\n                goto toomany;\n            }\n            if (chdir(\"..\")) {    \n                if (chdir(wd) || chdir(name)) {    \n                    die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                }\n            }\n        }\n        r++;\n    }\n    toomany:\n    free(names);\n    free(dir);\n    names = NULL;\n}", "target": 1}
{"code": "void GfxDeviceCMYKColorSpace::getGray(const GfxColor *color, GfxGray *gray) const\n{\n    *gray = clip01((GfxColorComp)(gfxColorComp1 - color->c[3] - 0.3 * color->c[0] - 0.59 * color->c[1] - 0.11 * color->c[2] + 0.5));\n}", "target": 0}
{"code": "FILE *fopen_safe(const char *path, const char *mode)\n{\n\tint fd;\n\tFILE *file;\n\tint flags = O_NOFOLLOW | O_CREAT;\n\tint sav_errno;\n\tif (mode[0] == 'r')\n\t\treturn fopen(path, mode);\n\tif ((mode[0] != 'a' && mode[0] != 'w') ||\n\t    (mode[1] &&\n\t     (mode[1] != '+' || mode[2]))) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif (mode[0] == 'w')\n\t\tflags |= O_TRUNC;\n\telse\n\t\tflags |= O_APPEND;\n\tif (mode[1])\n\t\tflags |= O_RDWR;\n\telse\n\t\tflags |= O_WRONLY;\n\tif (mode[0] == 'w') {\n\t\tif (unlink(path) && errno != ENOENT) {\n\t\t\tlog_message(LOG_INFO, \"Failed to remove existing file '%s' prior to write\", path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse {\n#ifndef ENABLE_LOG_FILE_APPEND\n\t\tlog_message(LOG_INFO, \"BUG - shouldn't be opening file for append with current build options\");\n\t\terrno = EINVAL;\n\t\treturn NULL;\n#endif\n\t}\n\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\tif (fd == -1)\n\t\treturn NULL;\n\tif (fchown(fd, 0, 0)) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"Unable to change file ownership of %s- errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\tif (fchmod(fd, S_IRUSR | S_IWUSR)) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"Unable to change file permission of %s - errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\tfile = fdopen (fd, \"w\");\n\tif (!file) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"fdopen(\\\"%s\\\") failed - errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\treturn file;\n}", "target": 1}
{"code": " static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n {\n\tchar *ksep, *vsep, *val;\n \tsize_t klen, vlen;\n \tsize_t new_vlen;\n \tif (var->ptr >= var->end) {\n \t\treturn 0;\n \t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n \tif (!vsep) {\n \t\tif (!eof) {\n \t\t\treturn 0;\n \t\t} else {\n \t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n \tefree(val);\n \tvar->ptr = vsep + (vsep != var->end);\n \treturn 1;\n }", "target": 1}
{"code": "int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,\n\t\t\t     struct snd_rawmidi_params * params)\n{\n\tchar *newbuf;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\tsnd_rawmidi_drain_input(substream);\n\tif (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->avail_min < 1 || params->avail_min > params->buffer_size) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->buffer_size != runtime->buffer_size) {\n\t\tnewbuf = krealloc(runtime->buffer, params->buffer_size,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\truntime->buffer = newbuf;\n\t\truntime->buffer_size = params->buffer_size;\n\t}\n\truntime->avail_min = params->avail_min;\n\treturn 0;\n}", "target": 1}
{"code": "static int is_branch32_taken(struct bpf_reg_state *reg, u32 val, u8 opcode)\n{\n\tstruct tnum subreg = tnum_subreg(reg->var_off);\n\ts32 sval = (s32)val;\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !!tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JNE:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JSET:\n\t\tif ((~subreg.mask & subreg.value) & val)\n\t\t\treturn 1;\n\t\tif (!((subreg.mask | subreg.value) & val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\tif (reg->u32_min_value > val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value <= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGT:\n\t\tif (reg->s32_min_value > sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value <= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLT:\n\t\tif (reg->u32_max_value < val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value >= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLT:\n\t\tif (reg->s32_max_value < sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value >= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\tif (reg->u32_min_value >= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value < val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGE:\n\t\tif (reg->s32_min_value >= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value < sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLE:\n\t\tif (reg->u32_max_value <= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value > val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLE:\n\t\tif (reg->s32_max_value <= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value > sval)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n \t\t\t\t\t\t   work);\n \tint ret = io_data->req->status ? io_data->req->status :\n \t\t\t\t\t io_data->req->actual;\n \tif (io_data->read && ret > 0) {\n \t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n \tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n \t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n \tusb_ep_free_request(io_data->ep, io_data->req);\n\tio_data->kiocb->private = NULL;\n \tif (io_data->read)\n \t\tkfree(io_data->to_free);\n \tkfree(io_data->buf);\n\tkfree(io_data);\n}", "target": 1}
{"code": "file_magwarn(struct magic_set *ms, const char *f, ...)\n{\n\tva_list va;\n\tchar *expanded_format;\n\tTSRMLS_FETCH();\n\tva_start(va, f);\n\tvasprintf(&expanded_format, f, va);\n\tva_end(va);\n\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Warning: %s\", expanded_format);\n\tfree(expanded_format);\n}", "target": 0}
{"code": "static inline void GetMeanPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  double\n    sum;\n  register SkipList\n    *p;\n  size_t\n    color;\n  ssize_t\n    count;\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  do\n  {\n    color=p->nodes[color].next[0];\n    sum+=(double) p->nodes[color].count*color;\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sum);\n}", "target": 0}
{"code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }", "target": 1}
{"code": "SPICE_GNUC_VISIBLE int spice_server_set_agent_mouse(SpiceServer *reds, int enable)\n{\n    reds->config->agent_mouse = enable;\n    reds_update_mouse_mode(reds);\n    return 0;\n}", "target": 0}
{"code": "static void fuse_lib_release(fuse_req_t req, fuse_ino_t ino,\n                             struct fuse_file_info *fi)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    struct fuse_intr_data d;\n    char *path;\n    int err = 0;\n    pthread_rwlock_rdlock(&f->tree_lock);\n    path = get_path(f, ino);\n    if (f->conf.debug)\n        fprintf(stderr, \"RELEASE%s[%llu] flags: 0x%x\\n\",\n                fi->flush ? \"+FLUSH\" : \"\",\n                (unsigned long long) fi->fh, fi->flags);\n    if (fi->flush) {\n        err = fuse_flush_common(f, req, ino, path, fi);\n        if (err == -ENOSYS)\n            err = 0;\n    }\n    fuse_prepare_interrupt(f, req, &d);\n    fuse_do_release(f, ino, path, fi);\n    fuse_finish_interrupt(f, req, &d);\n    free(path);\n    pthread_rwlock_unlock(&f->tree_lock);\n    reply_err(req, err);\n}", "target": 0}
{"code": "static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_report_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "static int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)\n{\n\tu8 buf[CAC_MAX_SIZE];\n\tu8 *out_ptr;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len, next_len;\n\tsc_apdu_t apdu;\n\tint r = SC_SUCCESS;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsize = left = *out_buf ? *out_len : sizeof(buf);\n\tout_ptr = *out_buf ? *out_buf : buf;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );\n\tnext_len = MIN(left, 100);\n\tfor (; left > 0; left -= len, out_ptr += len) {\n\t\tlen = next_len;\n\t\tapdu.resp = out_ptr;\n\t\tapdu.le = len;\n\t\tapdu.resplen = left;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.resplen == 0) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tleft -= len;\n\t\t\tbreak;\n\t\t}\n\t\tnext_len = MIN(left, apdu.sw2);\n\t}\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n\t}\n\tr = size - left;\n\tif (*out_buf == NULL) {\n\t\t*out_buf = malloc(r);\n\t\tif (*out_buf == NULL) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\tSC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t\tmemcpy(*out_buf, buf, r);\n\t}\n\t*out_len = r;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}", "target": 1}
{"code": "do_macro(uschar *p)\n{\nint length;\nint nest = 0;\nargstr **pp;\nmacrodef *md = misc_malloc(sizeof(macrodef));\nmd->name = misc_readitem(p, NULL, &length, NULL, 0);\nmd->namelength = Ustrlen(md->name);\np += length;\nif (length == 0)\n  {\n  error(14);\n  return;\n  }\nmd->lines = md->args = NULL;\nmd->next = macrolist;\nmacrolist = md;\npp = &(md->args);\nwhile (*p != 0)\n  {\n  argstr *as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_readitem(p, NULL, &length, NULL, 0);\n  p += length;\n  }\npp = &(md->lines);\nfor (;;)\n  {\n  argstr *as;\n  uschar *line = read_nextline();\n  if (line == NULL) { error(13, \".endmacro\"); return; }\n  if (Ustrncmp(line, \".macro \", 7) == 0) nest++;\n  else if (Ustrncmp(line, \".endmacro\", 9) == 0)\n    {\n    if (isspace(line[9]) || line[9] == '\\n')\n    if (--nest < 0) break;\n    }\n  as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_copystring(line, Ustrlen(line));\n  }\nif (md->lines == NULL)\n  {\n  md->lines = misc_malloc(sizeof(argstr));\n  md->lines->next = NULL;\n  md->lines->string = misc_copystring(US\". Dummy line\\n\", 13);\n  }\n}", "target": 1}
{"code": "device_drive_ata_smart_initiate_selftest (Device *device,\n                                          const char *test,\n                                          gchar **options,\n                                          DBusGMethodInvocation *context)\n{\n  if (!device->priv->drive_ata_smart_is_available)\n    {\n      throw_error (context, ERROR_FAILED, \"Device does not support ATA SMART\");\n      goto out;\n    }\n  daemon_local_check_auth (device->priv->daemon,\n                           device,\n                           \"org.freedesktop.udisks.drive-ata-smart-selftest\",\n                           \"DriveAtaSmartInitiateSelftest\",\n                           TRUE,\n                           device_drive_ata_smart_initiate_selftest_authorized_cb,\n                           context,\n                           2,\n                           g_strdup (test),\n                           g_free,\n                           g_strdupv (options),\n                           g_strfreev);\n out:\n  return TRUE;\n}", "target": 0}
{"code": "ex_redraw(exarg_T *eap)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n    validate_cursor();\n    update_topline();\n    update_screen(eap->forceit ? CLEAR : VIsual_active ? INVERTED : 0);\n    if (need_maketitle)\n\tmaketitle();\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n\tresize_console_buf();\n#endif\n    RedrawingDisabled = r;\n    p_lz = p;\n    screen_stop_highlight();\n    msg_didout = FALSE;\n    msg_col = 0;\n    need_wait_return = FALSE;\n    if (State & CMDLINE)\n\tredrawcmdline();\n    out_flush();\n}", "target": 0}
{"code": "ExprCreateFloat(void)\n{\n    EXPR_CREATE(ExprFloat, expr, EXPR_VALUE, EXPR_TYPE_FLOAT);\n    return expr;\n}", "target": 0}
{"code": "static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)\n {\n     const unsigned char *p;\n     int plen;\n    if (alg == NULL)\n         return NULL;\n     if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)\n         return NULL;\n    if (alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    return d2i_X509_ALGOR(NULL, &p, plen);\n}", "target": 1}
{"code": "int nfc_deactivate_target(struct nfc_dev *dev, u32 target_idx, u8 mode)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s target_idx=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->active_target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->active_target->idx != target_idx) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->ops->check_presence)\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\tdev->ops->deactivate_target(dev, dev->active_target, mode);\n\tdev->active_target = NULL;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n \tif (len < sizeof(sctp_assoc_t))\n \t\treturn -EINVAL;\n \tif (copy_from_user(&sas, optval, len))\n \t\treturn -EFAULT;\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n \tasoc->stats.max_obs_rto = asoc->rto_min;\n\tlen = min_t(size_t, len, sizeof(sas));\n \tif (put_user(len, optlen))\n \t\treturn -EFAULT;\n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "pci_emul_mem_handler(struct vmctx *ctx, int vcpu, int dir, uint64_t addr,\n\t\t     int size, uint64_t *val, void *arg1, long arg2)\n{\n\tstruct pci_vdev *pdi = arg1;\n\tstruct pci_vdev_ops *ops = pdi->dev_ops;\n\tuint64_t offset;\n\tint bidx = (int) arg2;\n\tassert(bidx <= PCI_BARMAX);\n\tassert(pdi->bar[bidx].type == PCIBAR_MEM32 ||\n\t       pdi->bar[bidx].type == PCIBAR_MEM64);\n\tassert(addr >= pdi->bar[bidx].addr &&\n\t       addr + size <= pdi->bar[bidx].addr + pdi->bar[bidx].size);\n\toffset = addr - pdi->bar[bidx].addr;\n\tif (dir == MEM_F_WRITE) {\n\t\tif (size == 8) {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   4, *val & 0xffffffff);\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset + 4,\n\t\t\t\t\t   4, *val >> 32);\n\t\t} else {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   size, bar_value(size, *val));\n\t\t}\n\t} else {\n\t\tif (size == 8) {\n\t\t\tuint64_t val_lo, val_hi;\n\t\t\tval_lo = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset, 4);\n\t\t\tval_lo = bar_value(4, val_lo);\n\t\t\tval_hi = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset + 4, 4);\n\t\t\t*val = val_lo | (val_hi << 32);\n\t\t} else {\n\t\t\t*val = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                            offset, size);\n\t\t\t*val = bar_value(size, *val);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "POSITION::POSITION()\n{\n  table= 0;\n  records_read= cond_selectivity= read_time= 0.0;\n  prefix_record_count= 0.0;\n  key= 0;\n  use_join_buffer= 0;\n  sj_strategy= SJ_OPT_NONE;\n  n_sj_tables= 0;\n  spl_plan= 0;\n  range_rowid_filter_info= 0;\n  ref_depend_map= dups_producing_tables= 0;\n  inner_tables_handled_with_other_sjs= 0;\n  dups_weedout_picker.set_empty();\n  firstmatch_picker.set_empty();\n  loosescan_picker.set_empty();\n  sjmat_picker.set_empty();\n}", "target": 0}
{"code": "static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tptr->offset.len = n;\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tptr->data = sec->payload_data + i;\n\t\tr_list_append (ret, ptr);\n\t\tr += 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n \tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n \treturn 0;\n}", "target": 1}
{"code": "static int collect_syscall(struct task_struct *target, struct syscall_info *info)\n{\n\tstruct pt_regs *regs;\n\tif (!try_get_task_stack(target)) {\n\t\tmemset(info, 0, sizeof(*info));\n\t\tinfo->data.nr = -1;\n\t\treturn 0;\n\t}\n\tregs = task_pt_regs(target);\n\tif (unlikely(!regs)) {\n\t\tput_task_stack(target);\n\t\treturn -EAGAIN;\n\t}\n\tinfo->sp = user_stack_pointer(regs);\n\tinfo->data.instruction_pointer = instruction_pointer(regs);\n\tinfo->data.nr = syscall_get_nr(target, regs);\n\tif (info->data.nr != -1L)\n\t\tsyscall_get_arguments(target, regs,\n\t\t\t\t      (unsigned long *)&info->data.args[0]);\n\tput_task_stack(target);\n\treturn 0;\n}", "target": 1}
{"code": "void LinkResolver::resolve_interface_call(CallInfo& result, Handle recv, Klass* recv_klass,\n                                          const LinkInfo& link_info,\n                                          bool check_null_and_abstract, TRAPS) {\n  methodHandle resolved_method = linktime_resolve_interface_method(link_info, CHECK);\n  runtime_resolve_interface_method(result, resolved_method,link_info.resolved_klass(),\n                                   recv, recv_klass, check_null_and_abstract, CHECK);\n}", "target": 0}
{"code": "static struct socket *get_raw_socket(int fd)\n{\n\tstruct {\n\t\tstruct sockaddr_ll sa;\n\t\tchar  buf[MAX_ADDR_LEN];\n\t} uaddr;\n\tint r;\n\tstruct socket *sock = sockfd_lookup(fd, &r);\n\tif (!sock)\n\t\treturn ERR_PTR(-ENOTSOCK);\n\tif (sock->sk->sk_type != SOCK_RAW) {\n\t\tr = -ESOCKTNOSUPPORT;\n\t\tgoto err;\n\t}\n\tr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa, 0);\n\tif (r < 0)\n\t\tgoto err;\n\tif (uaddr.sa.sll_family != AF_PACKET) {\n\t\tr = -EPFNOSUPPORT;\n\t\tgoto err;\n\t}\n\treturn sock;\nerr:\n\tsockfd_put(sock);\n\treturn ERR_PTR(r);\n}", "target": 1}
{"code": "file_printable(char *buf, size_t bufsiz, const char *str)\n{\n\tchar *ptr, *eptr;\n\tconst unsigned char *s = (const unsigned char *)str;\n\tfor (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {\n\t\tif (isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr + 4)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((*s >> 6) & 7) + '0';\n\t\t*ptr++ = ((*s >> 3) & 7) + '0';\n\t\t*ptr++ = ((*s >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}", "target": 1}
{"code": " ptaReadStream(FILE  *fp)\n {\nchar       typestr[128];\n l_int32    i, n, ix, iy, type, version;\n l_float32  x, y;\n PTA       *pta;\n    PROCNAME(\"ptaReadStream\");\n    if (!fp)\n        return (PTA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n    if (fscanf(fp, \"\\n Pta Version %d\\n\", &version) != 1)\n         return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n     if (version != PTA_VERSION_NUMBER)\n         return (PTA *)ERROR_PTR(\"invalid pta version\", procName, NULL);\n    if (fscanf(fp, \" Number of pts = %d; format = %s\\n\", &n, typestr) != 2)\n         return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n     if (!strcmp(typestr, \"float\"))\n         type = 0;\n    else  \n        type = 1;\n    if ((pta = ptaCreate(n)) == NULL)\n        return (PTA *)ERROR_PTR(\"pta not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  \n            if (fscanf(fp, \"   (%f, %f)\\n\", &x, &y) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading floats\", procName, NULL);\n            }\n            ptaAddPt(pta, x, y);\n        } else {   \n            if (fscanf(fp, \"   (%d, %d)\\n\", &ix, &iy) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading ints\", procName, NULL);\n            }\n            ptaAddPt(pta, ix, iy);\n        }\n    }\n    return pta;\n}", "target": 1}
{"code": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       n * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int tsize = pipe->ring_size - t;\n\t\t\tif (h > 0)\n\t\t\t\tmemcpy(bufs + tsize, pipe->bufs,\n\t\t\t\t       h * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       tsize * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\thead = n;\n\ttail = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}", "target": 1}
{"code": "x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}", "target": 1}
{"code": "TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input,\n                    const TfLiteTensor* positions, TfLiteTensor* output) {\n  tflite::GatherParams op_params;\n  op_params.axis = params.axis;\n  op_params.batch_dims = params.batch_dims;\n  optimized_ops::Gather(op_params, GetTensorShape(input),\n                        GetTensorData<InputT>(input), GetTensorShape(positions),\n                        GetTensorData<PositionsT>(positions),\n                        GetTensorShape(output), GetTensorData<InputT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void do_busid_cmd(ESPState *s, uint8_t busid)\n{\n    uint32_t cmdlen;\n    int32_t datalen;\n    int lun;\n    SCSIDevice *current_lun;\n    uint8_t buf[ESP_CMDFIFO_SZ];\n    trace_esp_do_busid_cmd(busid);\n    lun = busid & 7;\n    cmdlen = fifo8_num_used(&s->cmdfifo);\n    esp_fifo_pop_buf(&s->cmdfifo, buf, cmdlen);\n    current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, lun);\n    s->current_req = scsi_req_new(current_lun, 0, lun, buf, s);\n    datalen = scsi_req_enqueue(s->current_req);\n    s->ti_size = datalen;\n    fifo8_reset(&s->cmdfifo);\n    if (datalen != 0) {\n        s->rregs[ESP_RSTAT] = STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        s->ti_cmd = 0;\n        esp_set_tc(s, 0);\n        if (datalen > 0) {\n            s->data_in_ready = false;\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n        } else {\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            esp_raise_irq(s);\n            esp_lower_drq(s);\n        }\n        scsi_req_continue(s->current_req);\n        return;\n    }\n}", "target": 1}
{"code": "static void selinux_task_to_inode(struct task_struct *p,\n\t\t\t\t  struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tu32 sid = task_sid(p);\n\tspin_lock(&isec->lock);\n\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\tisec->sid = sid;\n\tisec->initialized = LABEL_INITIALIZED;\n\tspin_unlock(&isec->lock);\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::Show() {\n  window_->Show();\n  WasShown();\n}", "target": 0}
{"code": "grub_username_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  grub_printf (\"\\b\");\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\t{\n\t  buf[cur_len++] = key;\n\t  grub_printf (\"%c\", key);\n\t}\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n    if (!ok)\n        return ((int)n);\n    if (n < 6) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    p = d = (unsigned char *)s->init_msg;\n    n2l(p, s->session->tlsext_tick_lifetime_hint);\n    n2s(p, ticklen);\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    if (s->session->tlsext_tick) {\n        OPENSSL_free(s->session->tlsext_tick);\n        s->session->tlsext_ticklen = 0;\n    }\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n# ifndef OPENSSL_NO_SHA256\n               EVP_sha256(), NULL);\n# else\n               EVP_sha1(), NULL);\n# endif\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}", "target": 1}
{"code": "static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *m, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint ret;\n\tint copylen;\n\tret = -EOPNOTSUPP;\n \tif (m->msg_flags&MSG_OOB)\n \t\tgoto read_error;\n \tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n \tif (!skb)\n \t\tgoto read_error;\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\tret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);\n\tif (ret)\n\t\tgoto out_free;\n\tret = (flags & MSG_TRUNC) ? skb->len : copylen;\nout_free:\n\tskb_free_datagram(sk, skb);\n\tcaif_check_flow_release(sk);\n\treturn ret;\nread_error:\n\treturn ret;\n}", "target": 1}
{"code": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}", "target": 1}
{"code": "    TiffComponent* TiffComponent::doAddPath(uint16_t  ,\n                                            TiffPath& ,\n                                            TiffComponent* const ,\n                                            TiffComponent::UniquePtr )\n    {\n        return this;\n    } ", "target": 0}
{"code": " static int ldb_dn_escape_internal(char *dst, const char *src, int len)\n {\n       const char *p, *s;\n        char *d;\n       size_t l;\n       p = s = src;\n        d = dst;\n       while (p - src < len) {\n               p += strcspn(p, \",=\\n\\r+<>#;\\\\\\\" \");\n               if (p - src == len) \n                       break;\n               memcpy(d, s, p - s);\n               d += (p - s); \n               switch (*p) {\n                case ' ':\n                       if (p == src || (p-src)==(len-1)) {\n                                *d++ = '\\\\';\n                               *d++ = *p++;                                     \n                        } else {\n                               *d++ = *p++;\n                        }\n                        break;\n\t\t\t\t*d++ = '\\\\';\n\t\t\t\t*d++ = *p++;\t\t\t\t\t \n\t\t\t} else {\n\t\t\t\t*d++ = *p++;\n\t\t\t}\n\t\t\tbreak;\n                case '?':\n                        *d++ = '\\\\';\n                       *d++ = *p++;\n                        break;\n               default: {\n                        unsigned char v;\n                        const char *hexbytes = \"0123456789ABCDEF\";\n                       v = *(const unsigned char *)p;\n                        *d++ = '\\\\';\n                        *d++ = hexbytes[v>>4];\n                        *d++ = hexbytes[v&0xF];\n                       p++;\n                        break;\n                }\n                }\n               s = p; \n        }", "target": 1}
{"code": "  NullVideoFrame() {}", "target": 0}
{"code": "void smp_idle_terminate(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n if (p_cb->flags & SMP_PAIR_FLAGS_WE_STARTED_DD) {\n    SMP_TRACE_DEBUG(\"Pairing terminated at IDLE state.\");\n    p_cb->status = SMP_FAIL;\n    smp_proc_pairing_cmpl(p_cb);\n }\n}", "target": 0}
{"code": "static void hardware_enable_nolock(void *junk)\n{\n\tint cpu = raw_smp_processor_id();\n\tint r;\n\tif (cpumask_test_cpu(cpu, cpus_hardware_enabled))\n\t\treturn;\n\tcpumask_set_cpu(cpu, cpus_hardware_enabled);\n\tr = kvm_arch_hardware_enable(NULL);\n\tif (r) {\n\t\tcpumask_clear_cpu(cpu, cpus_hardware_enabled);\n\t\tatomic_inc(&hardware_enable_failed);\n\t\tprintk(KERN_INFO \"kvm: enabling virtualization on \"\n\t\t\t\t \"CPU%d failed\\n\", cpu);\n\t}\n}", "target": 0}
{"code": "juniper_mlppp_print(netdissect_options *ndo,\n                    const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_MLPPP;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        if (ndo->ndo_eflag &&\n            EXTRACT_16BITS(&l2info.cookie) != PPP_OSI &&\n            EXTRACT_16BITS(&l2info.cookie) !=  (PPP_ADDRESS << 8 | PPP_CONTROL))\n            ND_PRINT((ndo, \"Bundle-ID %u: \", l2info.bundle));\n        p+=l2info.header_len;\n        switch(l2info.proto) {\n        case JUNIPER_LSQ_L3_PROTO_IPV4:\n            if (l2info.cookie[4] == (JUNIPER_LSQ_COOKIE_RE|JUNIPER_LSQ_COOKIE_DIR))\n                ppp_print(ndo, p, l2info.length);\n            else\n                ip_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_IPV6:\n            ip6_print(ndo, p,l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_MPLS:\n            mpls_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_ISO:\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n            return l2info.header_len;\n        default:\n            break;\n        }\n        switch (EXTRACT_16BITS(&l2info.cookie)) {\n        case PPP_OSI:\n            ppp_print(ndo, p - 2, l2info.length + 2);\n            break;\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n        default:\n            ppp_print(ndo, p, l2info.length);\n            break;\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "onig_set_default_case_fold_flag(OnigCaseFoldType case_fold_flag)\n{\n  OnigDefaultCaseFoldFlag = case_fold_flag;\n  return 0;\n}", "target": 0}
{"code": "void ring_buffer_record_enable(struct ring_buffer *buffer)\n{\n\tatomic_dec(&buffer->record_disabled);\n}", "target": 0}
{"code": "int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\ttmpstream = 0;\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\nerror:\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "  bool List::operator== (const Expression& rhs) const\n  {\n    if (List_Ptr_Const r = Cast<List>(&rhs)) {\n      if (length() != r->length()) return false;\n      if (separator() != r->separator()) return false;\n      for (size_t i = 0, L = length(); i < L; ++i) {\n        Expression_Obj rv = r->at(i);\n        Expression_Obj lv = this->at(i);\n        if (!lv || !rv) return false;\n        if (!(*lv == *rv)) return false;\n      }\n      return true;\n    }\n    return false;\n  }", "target": 0}
{"code": "const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,\n                                    socklen_t size) {\n  if (!src || !dst) {\n    errno = EFAULT;\n    return nullptr;\n  }\n  size_t src_size = 0;\n  if (af == AF_INET) {\n    src_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    src_size = sizeof(struct in6_addr);\n  } else {\n    errno = EAFNOSUPPORT;\n    return nullptr;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});\n  input.Push(size);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetNtopHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_ntop\", 2);\n  auto result = output.next();\n  int klinux_errno = output.next<int>();\n  if (result.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n  memcpy(dst, result.data(),\n         std::min(static_cast<size_t>(size),\n                  static_cast<size_t>(INET6_ADDRSTRLEN)));\n  return dst;\n}", "target": 1}
{"code": "#else\n    static int input  (yyscan_t yyscanner)\n#endif\n{\n\tint c;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\tif ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\tif ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t*yyg->yy_c_buf_p = '\\0';\n\t\telse\n\t\t\t{ \n\t\t\tyy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;\n\t\t\t++yyg->yy_c_buf_p;\n\t\t\tswitch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\tre_yyrestart(yyin ,yyscanner);\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( re_yywrap(yyscanner ) )\n\t\t\t\t\t\treturn EOF;\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput(yyscanner);\n#else\n\t\t\t\t\treturn input(yyscanner);\n#endif\n\t\t\t\t\t}\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tc = *(unsigned char *) yyg->yy_c_buf_p;\t\n\t*yyg->yy_c_buf_p = '\\0';\t\n\tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n\tif ( c == '\\n' )\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\treturn c;", "target": 1}
{"code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n {\n         uint8* bufp = buf;\n         int32  bytes_read = 0;\n        uint16 strip, nstrips   = TIFFNumberOfStrips(in);\n         uint32 stripsize = TIFFStripSize(in);\n         uint32 rows = 0;\n         uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += bytes_read;\n        }\n        return 1;\n} ", "target": 1}
{"code": "optimize_straight_join(JOIN *join, table_map join_tables)\n{\n  JOIN_TAB *s;\n  uint idx= join->const_tables;\n  bool disable_jbuf= join->thd->variables.join_cache_level == 0;\n  double    record_count= 1.0;\n  double    read_time=    0.0;\n  uint use_cond_selectivity= \n         join->thd->variables.optimizer_use_condition_selectivity;\n  POSITION  loose_scan_pos;\n  for (JOIN_TAB **pos= join->best_ref + idx ; (s= *pos) ; pos++)\n  {\n    best_access_path(join, s, join_tables, join->positions, idx,\n                     disable_jbuf, record_count,\n                     join->positions + idx, &loose_scan_pos);\n    record_count= COST_MULT(record_count, join->positions[idx].records_read);\n    read_time= COST_ADD(read_time,\n                        COST_ADD(join->positions[idx].read_time,\n                                 record_count / (double) TIME_FOR_COMPARE));\n    advance_sj_state(join, join_tables, idx, &record_count, &read_time,\n                     &loose_scan_pos);\n    join_tables&= ~(s->table->map);\n    double pushdown_cond_selectivity= 1.0;\n    if (use_cond_selectivity > 1)\n      pushdown_cond_selectivity= table_cond_selectivity(join, idx, s,\n                                                        join_tables);\n    join->positions[idx].cond_selectivity= pushdown_cond_selectivity;\n    ++idx;\n  }\n  if (join->sort_by_table &&\n      join->sort_by_table != join->positions[join->const_tables].table->table)\n    read_time+= record_count;  \n  memcpy((uchar*) join->best_positions, (uchar*) join->positions,\n         sizeof(POSITION)*idx);\n  join->join_record_count= record_count;\n  join->best_read= read_time - 0.001;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::CopyFromBackingStore(\n    const gfx::Rect& src_subrect,\n    const gfx::Size& accelerated_dst_size,\n    const ReadbackRequestCallback& callback,\n    const SkColorType preferred_color_type) {\n  if (view_) {\n    TRACE_EVENT0(\"browser\",\n        \"RenderWidgetHostImpl::CopyFromBackingStore::FromCompositingSurface\");\n    gfx::Rect accelerated_copy_rect = src_subrect.IsEmpty() ?\n        gfx::Rect(view_->GetViewBounds().size()) : src_subrect;\n    view_->CopyFromCompositingSurface(accelerated_copy_rect,\n                                      accelerated_dst_size, callback,\n                                      preferred_color_type);\n    return;\n  }\n  callback.Run(SkBitmap(), content::READBACK_FAILED);\n}", "target": 0}
{"code": "GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n                                   int64_t count, Error **errp)\n{\n    GuestFileRead *read_data = NULL;\n    guchar *buf;\n    HANDLE fh;\n    bool is_ok;\n    DWORD read_count;\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    if (!gfh) {\n        return NULL;\n    }\n    if (!has_count) {\n        count = QGA_READ_COUNT_DEFAULT;\n    } else if (count < 0) {\n        error_setg(errp, \"value '%\" PRId64\n                   \"' is invalid for argument count\", count);\n        return NULL;\n    }\n    fh = gfh->fh;\n    buf = g_malloc0(count+1);\n    is_ok = ReadFile(fh, buf, count, &read_count, NULL);\n    if (!is_ok) {\n        error_setg_win32(errp, GetLastError(), \"failed to read file\");\n        slog(\"guest-file-read failed, handle %\" PRId64, handle);\n    } else {\n        buf[read_count] = 0;\n        read_data = g_new0(GuestFileRead, 1);\n        read_data->count = (size_t)read_count;\n        read_data->eof = read_count == 0;\n        if (read_count != 0) {\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n        }\n    }\n    g_free(buf);\n    return read_data;\n}", "target": 1}
{"code": "d_lite_inspect_raw(VALUE self)\n{\n    get_d1(self);\n    return mk_inspect_raw(dat, rb_obj_class(self));\n}", "target": 0}
{"code": "zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) \n{\n\tspl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);\n\tif (fsobj->u.dir.entry.d_name[0] == '\\0' && fsobj->orig_path == NULL) {\n\t\tmethod = \"_bad_state_ex\";\n\t\tmethod_len = sizeof(\"_bad_state_ex\") - 1;\n\t\tkey = NULL;\n\t}\n\treturn zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);\n}", "target": 0}
{"code": "MmkvHostObject::MmkvHostObject(const std::string& instanceId, std::string path,\n                               std::string cryptKey) {\n  __android_log_print(ANDROID_LOG_INFO, \"RNMMKV\",\n                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encryption-Key: %s)\",\n                      instanceId.c_str(), path.c_str(), cryptKey.c_str());\n  std::string* pathPtr = path.size() > 0 ? &path : nullptr;\n  std::string* cryptKeyPtr = cryptKey.size() > 0 ? &cryptKey : nullptr;\n  instance = MMKV::mmkvWithID(instanceId, mmkv::DEFAULT_MMAP_SIZE, MMKV_SINGLE_PROCESS, cryptKeyPtr,\n                              pathPtr);\n  if (instance == nullptr) {\n    if (instanceId.empty()) {\n      throw std::runtime_error(\"Failed to create MMKV instance! `id` cannot be empty!\");\n    }\n    if (cryptKey.size() > 16) {\n      throw std::runtime_error(\n          \"Failed to create MMKV instance! `encryptionKey` cannot be longer than 16 bytes!\");\n    }\n    throw std::runtime_error(\"Failed to create MMKV instance!\");\n  }\n}", "target": 1}
{"code": "ProcMapSubwindows(ClientPtr client)\n{\n    WindowPtr pWin;\n    REQUEST(xResourceReq);\n    int rc;\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupWindow(&pWin, stuff->id, client, DixListAccess);\n    if (rc != Success)\n        return rc;\n    MapSubwindows(pWin, client);\n    return Success;\n}", "target": 0}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "bool HTMLTextAreaElement::tooLong(const String& value, NeedsToCheckDirtyFlag check) const\n{\n    if (check == CheckDirtyFlag && !lastChangeWasUserEdit())\n        return false;\n    int max = maxLength();\n    if (max < 0)\n        return false;\n    return computeLengthForSubmission(value) > static_cast<unsigned>(max);\n}", "target": 0}
{"code": "lookup_bytestring(netdissect_options *ndo, register const u_char *bs,\n\t\t  const unsigned int nlen)\n{\n\tstruct enamemem *tp;\n\tregister u_int i, j, k;\n\tif (nlen >= 6) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = (bs[4] << 8) | bs[5];\n\t} else if (nlen >= 4) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = 0;\n\t} else\n\t\ti = j = k = 0;\n\ttp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];\n\twhile (tp->e_nxt)\n\t\tif (tp->e_addr0 == i &&\n\t\t    tp->e_addr1 == j &&\n\t\t    tp->e_addr2 == k &&\n\t\t    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)\n\t\t\treturn tp;\n\t\telse\n\t\t\ttp = tp->e_nxt;\n\ttp->e_addr0 = i;\n\ttp->e_addr1 = j;\n\ttp->e_addr2 = k;\n\ttp->e_bs = (u_char *) calloc(1, nlen + 1);\n\tif (tp->e_bs == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\tmemcpy(tp->e_bs, bs, nlen);\n\ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));\n\tif (tp->e_nxt == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\treturn tp;\n}", "target": 1}
{"code": "void* leak_malloc(size_t bytes)\n{\n    void* base = dlmalloc(bytes + sizeof(AllocationEntry));\n    if (base != NULL) {\n        pthread_mutex_lock(&gAllocationsMutex);\n            intptr_t backtrace[BACKTRACE_SIZE];\n            size_t numEntries = get_backtrace(backtrace, BACKTRACE_SIZE);\n            AllocationEntry* header = (AllocationEntry*)base;\n            header->entry = record_backtrace(backtrace, numEntries, bytes);\n            header->guard = GUARD;\n            base = (AllocationEntry*)base + 1;\n        pthread_mutex_unlock(&gAllocationsMutex);\n    }\n    return base;\n}", "target": 1}
{"code": "void RenderView::didClearAutoFillSelection(const WebKit::WebNode& node) {\n  autofill_helper_.DidClearAutoFillSelection(node);\n}", "target": 0}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 1}
{"code": "vte_sequence_handler_fs (VteTerminal *terminal, GValueArray *params)\n{\n\tterminal->pvt->screen->status_line = FALSE;\n}", "target": 0}
{"code": "status_t MediaHTTP::connect(\n const char *uri,\n const KeyedVector<String8, String8> *headers,\n off64_t ) {\n if (mInitCheck != OK) {\n return mInitCheck;\n }\n KeyedVector<String8, String8> extHeaders;\n if (headers != NULL) {\n        extHeaders = *headers;\n }\n if (extHeaders.indexOfKey(String8(\"User-Agent\")) < 0) {\n         extHeaders.add(String8(\"User-Agent\"), String8(MakeUserAgent().c_str()));\n     }\n    bool success = mHTTPConnection->connect(uri, &extHeaders);\n     mLastHeaders = extHeaders;\n    mLastURI = uri;\n     mCachedSizeValid = false;\n     if (success) {\n        AString sanitized = uriDebugString(uri);\n         mName = String8::format(\"MediaHTTP(%s)\", sanitized.c_str());\n     }\n return success ? OK : UNKNOWN_ERROR;\n}", "target": 1}
{"code": "PHP_FUNCTION(curl_reset)\n{\n\tzval       *zid;\n\tphp_curl   *ch;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zid) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(ch, php_curl *, zid, -1, le_curl_name, le_curl);\n\tif (ch->in_callback) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Attempt to reset cURL handle from a callback\");\n\t\treturn;\n\t}\n\tcurl_easy_reset(ch->cp);\n\t_php_curl_reset_handlers(ch);\n\t_php_curl_set_default_options(ch);\n}", "target": 0}
{"code": " header_read (SF_PRIVATE *psf, void *ptr, int bytes)\n {\tint count = 0 ;\n\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\treturn psf_fread (ptr, 1, bytes, psf) ;\n\tif (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))\n\t{\tint most ;\n\t\tmost = SIGNED_SIZEOF (psf->header) - psf->headend ;\n\t\tpsf_fread (psf->header + psf->headend, 1, most, psf) ;\n\t\tmemcpy (ptr, psf->header + psf->headend, most) ;\n\t\tpsf->headend = psf->headindex += most ;\n\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;\n\t\treturn bytes ;\n\t\t} ;\n\tif (psf->headindex + bytes > psf->headend)\n\t{\tcount = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;\n\t\tif (count != bytes - (int) (psf->headend - psf->headindex))\n \t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;\n \t\t\treturn count ;\n \t\t\t} ;\n\t\tpsf->headend += count ;\n \t\t} ;\n\tmemcpy (ptr, psf->header + psf->headindex, bytes) ;\n\tpsf->headindex += bytes ;\n \treturn bytes ;\n } ", "target": 1}
{"code": "sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const\n{\n if (mHeap == 0) {\n Parcel data, reply;\n        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());\n if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {\n            sp<IBinder> heap = reply.readStrongBinder();\n ssize_t o = reply.readInt32();\n size_t s = reply.readInt32();\n             if (heap != 0) {\n                 mHeap = interface_cast<IMemoryHeap>(heap);\n                 if (mHeap != 0) {\n                    mOffset = o;\n                    mSize = s;\n                 }\n             }\n         }\n     }\n     if (offset) *offset = mOffset;\n     if (size) *size = mSize;\n    return mHeap;\n }", "target": 1}
{"code": "static int ext4_init_block_bitmap(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned int bit, bit_max;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t start, tmp;\n\tint flex_bg = 0;\n\tJ_ASSERT_BH(bh, buffer_locked(bh));\n\tif (!ext4_group_desc_csum_verify(sb, block_group, gdp)) {\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT |\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\treturn -EFSBADCRC;\n\t}\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\tbit_max = ext4_num_base_meta_clusters(sb, block_group);\n\tif ((bit_max >> 3) >= bh->b_size)\n\t\treturn -EFSCORRUPTED;\n\tfor (bit = 0; bit < bit_max; bit++)\n\t\text4_set_bit(bit, bh->b_data);\n\tstart = ext4_group_first_block_no(sb, block_group);\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tflex_bg = 1;\n\ttmp = ext4_block_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\ttmp = ext4_inode_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\ttmp = ext4_inode_table(sb, gdp);\n\tfor (; tmp < ext4_inode_table(sb, gdp) +\n\t\t     sbi->s_itb_per_group; tmp++) {\n\t\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\t}\n\text4_mark_bitmap_end(num_clusters_in_group(sb, block_group),\n\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\treturn 0;\n}", "target": 1}
{"code": "free_tabpage(tabpage_T *tp)\n{\n    int idx;\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_TEXT_PROP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n    vim_free(tp->tp_localdir);\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n    vim_free(tp);\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::AddMouseEventCallback(\n    const MouseEventCallback& callback) {\n  mouse_event_callbacks_.push_back(callback);\n}", "target": 0}
{"code": "KeyInfo *sqlite3KeyInfoFromExprList(\n  Parse *pParse,       \n  ExprList *pList,     \n  int iStart,          \n  int nExtra           \n){\n  int nExpr;\n  KeyInfo *pInfo;\n  struct ExprList_item *pItem;\n  sqlite3 *db = pParse->db;\n  int i;\n  nExpr = pList->nExpr;\n  pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);\n  if( pInfo ){\n    assert( sqlite3KeyInfoIsWriteable(pInfo) );\n    for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++){\n      pInfo->aColl[i-iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);\n      pInfo->aSortOrder[i-iStart] = pItem->sortOrder;\n    }\n  }\n  return pInfo;\n}", "target": 0}
{"code": "TIFFjpeg_create_compress(JPEGState* sp)\n{\n\tsp->cinfo.c.err = jpeg_std_error(&sp->err);\n\tsp->err.error_exit = TIFFjpeg_error_exit;\n\tsp->err.output_message = TIFFjpeg_output_message;\n\tsp->cinfo.c.client_data = NULL;\n\treturn CALLVJPEG(sp, jpeg_create_compress(&sp->cinfo.c));\n}", "target": 0}
{"code": "static int oidc_cache_crypto_decrypt(request_rec *r, const char *cache_value,\n\t\tunsigned char *key, unsigned char **plaintext) {\n\tint len = -1;\n\tchar *encoded_tag = strstr(cache_value, \".\");\n\tif (encoded_tag == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"corrupted cache value: no tag separator found in encrypted value\");\n\t\treturn FALSE;\n\t}\n\tcache_value = apr_pstrmemdup(r->pool, cache_value,\n\t\t\tstrlen(cache_value) - strlen(encoded_tag));\n\tencoded_tag++;\n\tchar *d_bytes = NULL;\n\tint d_len = oidc_base64url_decode(r->pool, &d_bytes, cache_value);\n\tchar *t_bytes = NULL;\n\tint t_len = oidc_base64url_decode(r->pool, &t_bytes, encoded_tag);\n\tif ((d_len > 0) && (t_len > 0)) {\n\t\t*plaintext = apr_pcalloc(r->pool,\n\t\t\t\t(d_len + EVP_CIPHER_block_size(OIDC_CACHE_CIPHER) - 1));\n\t\tlen = oidc_cache_crypto_decrypt_impl(r, (unsigned char *) d_bytes,\n\t\t\t\td_len, OIDC_CACHE_CRYPTO_GCM_AAD,\n\t\t\t\tsizeof(OIDC_CACHE_CRYPTO_GCM_AAD), (unsigned char *) t_bytes,\n\t\t\t\tt_len, key, OIDC_CACHE_CRYPTO_GCM_IV,\n\t\t\t\tsizeof(OIDC_CACHE_CRYPTO_GCM_IV), *plaintext);\n\t\tif (len > -1) {\n\t\t\t(*plaintext)[len] = '\\0';\n\t\t} else {\n\t\t\t*plaintext = NULL;\n\t\t}\n\t}\n\treturn len;\n}", "target": 1}
{"code": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}", "target": 1}
{"code": "void cgit_clone_info(void)\n{\n\tif (!ctx.qry.path || strcmp(ctx.qry.path, \"refs\")) {\n\t\tcgit_print_error_page(400, \"Bad request\", \"Bad request\");\n\t\treturn;\n\t}\n\tctx.page.mimetype = \"text/plain\";\n\tctx.page.filename = \"info/refs\";\n\tcgit_print_http_headers();\n\tfor_each_ref(print_ref_info, NULL);\n}", "target": 0}
{"code": "ExpressionCoerceToBool::ExpressionCoerceToBool(ExpressionContext* const expCtx,\n                                               intrusive_ptr<Expression> pExpression)\n    : Expression(expCtx, {std::move(pExpression)}), pExpression(_children[0]) {}", "target": 0}
{"code": "bool IsIDNComponentInSingleScript(const char16* str, int str_len) {\n  UScriptCode first_script = USCRIPT_INVALID_CODE;\n  bool is_first = true;\n  int i = 0;\n  while (i < str_len) {\n    unsigned code_point;\n    U16_NEXT(str, i, str_len, code_point);\n    UErrorCode err = U_ZERO_ERROR;\n    UScriptCode cur_script = uscript_getScript(code_point, &err);\n    if (err != U_ZERO_ERROR)\n      return false;  \n    cur_script = NormalizeScript(cur_script);\n    if (is_first && cur_script != USCRIPT_COMMON) {\n      first_script = cur_script;\n      is_first = false;\n    } else {\n      if (cur_script != USCRIPT_COMMON && cur_script != first_script)\n        return false;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\tif (!strlen(text)) return \"empty string\";\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  \n\treturn escaped;\n}", "target": 1}
{"code": "p2bit(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++) {\n        *out++ = (L(&palette[in[x] * 4]) >= 128000) ? 255 : 0;\n    }\n}", "target": 0}
{"code": "static void do_popen(FILE *fin, FILE *fout, int afdt_fd) {\n  char buf[BUFFER_SIZE];\n  char cwd[BUFFER_SIZE];\n  if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';\n  bool read_only = (buf[0] == 'r');\n  read_buf(fin, buf);\n  std::string old_cwd = Process::GetCurrentDirectory();\n  read_buf(fin, cwd);\n  if (old_cwd != cwd) {\n    if (chdir(cwd)) {\n      Logger::Warning(\"Light Process failed chdir to %s.\", cwd);\n    }\n  }\n  FILE *f = buf[0] ? ::popen(buf, read_only ? \"r\" : \"w\") : nullptr;\n  if (old_cwd != cwd && chdir(old_cwd.c_str())) {\n  }\n  if (f == nullptr) {\n    Logger::Error(\"Light process failed popen: %d (%s).\", errno,\n                  folly::errnoStr(errno).c_str());\n    fprintf(fout, \"error\\n\");\n    fflush(fout);\n  } else {\n    fprintf(fout, \"success\\n%\" PRId64 \"\\n\", (int64_t)f);\n    fflush(fout);\n    int fd = fileno(f);\n    send_fd(afdt_fd, fd);\n  }\n}", "target": 1}
{"code": "static uint16_t nvme_get_feature_timestamp(NvmeCtrl *n, NvmeRequest *req)\n{\n    uint64_t timestamp = nvme_get_timestamp(n);\n    return nvme_c2h(n, (uint8_t *)&timestamp, sizeof(timestamp), req);\n}", "target": 0}
{"code": "parse_GROUP(char *arg, const struct ofpact_parse_params *pp)\n{\n    return str_to_u32(arg, &ofpact_put_GROUP(pp->ofpacts)->group_id);\n}", "target": 0}
{"code": "InlineBoxPosition AdjustInlineBoxPositionForTextDirection(\n    InlineBox* inline_box,\n    int caret_offset,\n    UnicodeBidi unicode_bidi,\n    TextDirection primary_direction) {\n  if (inline_box->Direction() == primary_direction)\n    return AdjustInlineBoxPositionForPrimaryDirection(inline_box, caret_offset);\n  const unsigned char level = inline_box->BidiLevel();\n  if (caret_offset == inline_box->CaretLeftmostOffset()) {\n    InlineBox* const prev_box = inline_box->PrevLeafChildIgnoringLineBreak();\n    if (!prev_box || prev_box->BidiLevel() < level) {\n      InlineBox* const result_box =\n          InlineBoxTraversal::FindRightBoundaryOfEntireBidiRunIgnoringLineBreak(\n              *inline_box, level);\n      return InlineBoxPosition(result_box, result_box->CaretRightmostOffset());\n    }\n    if (prev_box->BidiLevel() <= level)\n      return InlineBoxPosition(inline_box, caret_offset);\n    InlineBox* const result_box =\n        InlineBoxTraversal::FindLeftBoundaryOfBidiRunIgnoringLineBreak(\n            *inline_box, level);\n    return InlineBoxPosition(result_box, result_box->CaretLeftmostOffset());\n  }\n  if (unicode_bidi == UnicodeBidi::kPlaintext) {\n    if (inline_box->BidiLevel() < level)\n      return InlineBoxPosition(inline_box, inline_box->CaretLeftmostOffset());\n    return InlineBoxPosition(inline_box, inline_box->CaretRightmostOffset());\n  }\n  InlineBox* const next_box = inline_box->NextLeafChildIgnoringLineBreak();\n  if (!next_box || next_box->BidiLevel() < level) {\n    InlineBox* const result_box =\n        InlineBoxTraversal::FindLeftBoundaryOfEntireBidiRunIgnoringLineBreak(\n            *inline_box, level);\n    return InlineBoxPosition(result_box, result_box->CaretLeftmostOffset());\n  }\n  if (next_box->BidiLevel() <= level)\n    return InlineBoxPosition(inline_box, caret_offset);\n  InlineBox* const result_box =\n      InlineBoxTraversal::FindRightBoundaryOfBidiRunIgnoringLineBreak(\n          *inline_box, level);\n  return InlineBoxPosition(result_box, result_box->CaretRightmostOffset());\n}", "target": 0}
{"code": "PHPAPI ZEND_COLD void php_error_docref1(const char *docref, const char *param1, int type, const char *format, ...)\n{\n\tva_list args;\n\tva_start(args, format);\n\tphp_verror(docref, param1, type, format, args);\n\tva_end(args);\n}", "target": 0}
{"code": "\t\tvoid CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, ThreeRegexSameFieldMultikey) {\n    addIndex(BSON(\"a\" << 1), true);\n    runQuery(fromjson(\"{$and: [{a: /0/}, {a: /1/}, {a: /2/}]}\"));\n    ASSERT_EQUALS(getNumSolutions(), 4U);\n    assertSolutionExists(\"{cscan: {filter: {$and:[{a:/0/},{a:/1/},{a:/2/}]}, dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:/0/},{a:/1/},{a:/2/}]}, node: {ixscan: \"\n        \"{pattern: {a: 1}, filter: null, \"\n        \"bounds: {a: [['', {}, true, false], [/0/, /0/, true, true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:/1/},{a:/0/},{a:/2/}]}, node: {ixscan: \"\n        \"{pattern: {a: 1}, filter: null, \"\n        \"bounds: {a: [['', {}, true, false], [/1/, /1/, true, true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:/2/},{a:/0/},{a:/1/}]}, node: {ixscan: \"\n        \"{pattern: {a: 1}, filter: null, \"\n        \"bounds: {a: [['', {}, true, false], [/2/, /2/, true, true]]}}}}}\");\n}", "target": 0}
{"code": "void PasswordAutofillAgent::WillSubmitForm(const blink::WebFormElement& form) {\n  std::unique_ptr<RendererSavePasswordProgressLogger> logger;\n  if (logging_state_active_) {\n    logger.reset(new RendererSavePasswordProgressLogger(this, routing_id()));\n    logger->LogMessage(Logger::STRING_WILL_SUBMIT_FORM_METHOD);\n    LogHTMLForm(logger.get(), Logger::STRING_HTML_FORM_FOR_SUBMIT, form);\n  }\n  std::unique_ptr<PasswordForm> submitted_form = CreatePasswordFormFromWebForm(\n      form, &nonscript_modified_values_, &form_predictions_);\n  if (submitted_form) {\n    if (logger) {\n      logger->LogPasswordForm(Logger::STRING_CREATED_PASSWORD_FORM,\n                              *submitted_form);\n    }\n    if (provisionally_saved_form_ &&\n        submitted_form->action == provisionally_saved_form_->action) {\n      if (logger)\n        logger->LogMessage(Logger::STRING_SUBMITTED_PASSWORD_REPLACED);\n      submitted_form->password_value =\n          provisionally_saved_form_->password_value;\n      submitted_form->new_password_value =\n          provisionally_saved_form_->new_password_value;\n      submitted_form->username_value =\n          provisionally_saved_form_->username_value;\n    }\n    Send(new AutofillHostMsg_PasswordFormSubmitted(routing_id(),\n                                                   *submitted_form));\n    provisionally_saved_form_.reset();\n  } else if (logger) {\n    logger->LogMessage(Logger::STRING_FORM_IS_NOT_PASSWORD);\n  }\n}", "target": 0}
{"code": "static void imx_usdhc_init(Object *obj)\n{\n    SDHCIState *s = SYSBUS_SDHCI(obj);\n    s->io_ops = &usdhc_mmio_ops;\n    s->quirks = SDHCI_QUIRK_NO_BUSY_IRQ;\n}", "target": 0}
{"code": "TfLiteStatus EvalHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n  const int resource_id = std::hash<std::string>{}(params->table_name);\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  auto* resource_handle_data =\n      GetTensorData<std::int32_t>(resource_handle_tensor);\n  resource_handle_data[0] = resource_id;\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  resource::CreateHashtableResourceIfNotAvailable(\n      &resources, resource_id, params->key_dtype, params->value_dtype);\n  return kTfLiteOk;\n}", "target": 1}
{"code": "PHP_MINFO_FUNCTION(exif)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_row(2, \"EXIF Support\", \"enabled\");\n\tphp_info_print_table_row(2, \"EXIF Version\", PHP_EXIF_VERSION);\n\tphp_info_print_table_row(2, \"Supported EXIF Version\", \"0220\");\n\tphp_info_print_table_row(2, \"Supported filetypes\", \"JPEG, TIFF\");\n\tif (zend_hash_str_exists(&module_registry, \"mbstring\", sizeof(\"mbstring\")-1)) {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"enabled\");\n\t} else {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"disabled\");\n\t}\n\tphp_info_print_table_row(2, \"Extended EXIF tag formats\", \"Canon, Casio, Fujifilm, Nikon, Olympus, Samsung, Panasonic, DJI, Sony, Pentax, Minolta, Sigma, Foveon, Kyocera, Ricoh, AGFA, Epson\");\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();\n}", "target": 0}
{"code": "u64 local_clock(void)\n{\n\treturn sched_clock();\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ContainedOrPathLevelMultikeyCannotCombineTrailingFields) {\n    MultikeyPaths multikeyPaths{{}, {0U}};\n    addIndex(BSON(\"b\" << 1 << \"a\" << 1), multikeyPaths);\n    addIndex(BSON(\"c\" << 1));\n    runQuery(\n        fromjson(\"{$and: [{a: {$gte: 0}}, {$or: [{$and: [{a: {$lte: 10}}, {b: 6}]}, {c: 7}]}]}\"));\n    assertNumSolutions(2);\n    std::vector<std::string> alternates;\n    alternates.push_back(\n        \"{fetch: {filter: {a: {$gte: 0}}, node: {or: {nodes: [\"\n        \"{ixscan: {pattern: {b: 1, a: 1}, bounds: {b: [[6, 6, true, true]], a: [[-Infinity, 10, \"\n        \"true, true]]}}},\"\n        \"{ixscan: {pattern: {c: 1}, bounds: {c: [[7, 7, true, true]]}}}\"\n        \"]}}}}\");\n    alternates.push_back(\n        \"{fetch: {filter: {a: {$gte: 0}}, node: {or: {nodes: [\"\n        \"{ixscan: {pattern: {b: 1, a: 1}, bounds: {b: [[6, 6, true, true]], a: [[0, Infinity, \"\n        \"true, true]]}}},\"\n        \"{ixscan: {pattern: {c: 1}, bounds: {c: [[7, 7, true, true]]}}}\"\n        \"]}}}}\");\n    assertHasOneSolutionOf(alternates);\n    assertSolutionExists(\"{cscan: {dir: 1}}}}\");\n}", "target": 0}
{"code": "void ewk_view_paint_context_paint_contents(Ewk_View_Paint_Context* context, const Eina_Rectangle* area)\n{\n    EINA_SAFETY_ON_NULL_RETURN(context);\n    EINA_SAFETY_ON_NULL_RETURN(area);\n    WebCore::IntRect rect(area->x, area->y, area->w, area->h);\n    if (context->view->isTransparent())\n        context->graphicContext->clearRect(rect);\n    context->view->paintContents(context->graphicContext, rect);\n}", "target": 0}
{"code": "R_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\tfree (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; \n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}", "target": 1}
{"code": "void RenderView::OnExecuteCode(const ViewMsg_ExecuteCode_Params& params) {\n  WebFrame* main_frame = webview() ? webview()->mainFrame() : NULL;\n  if (!main_frame) {\n    Send(new ViewMsg_ExecuteCodeFinished(routing_id_, params.request_id,\n                                         false));\n    return;\n  }\n  WebDataSource* ds = main_frame->dataSource();\n  NavigationState* navigation_state = NavigationState::FromDataSource(ds);\n  if (!navigation_state->user_script_idle_scheduler()->has_run()) {\n    pending_code_execution_queue_.push(\n        linked_ptr<ViewMsg_ExecuteCode_Params>(\n            new ViewMsg_ExecuteCode_Params(params)));\n    return;\n  }\n  ExecuteCodeImpl(main_frame, params);\n}", "target": 0}
{"code": "void blk_mq_add_to_requeue_list(struct request *rq, bool at_head)\n{\n\tstruct request_queue *q = rq->q;\n\tunsigned long flags;\n\tBUG_ON(rq->cmd_flags & REQ_SOFTBARRIER);\n\tspin_lock_irqsave(&q->requeue_lock, flags);\n\tif (at_head) {\n\t\trq->cmd_flags |= REQ_SOFTBARRIER;\n\t\tlist_add(&rq->queuelist, &q->requeue_list);\n\t} else {\n\t\tlist_add_tail(&rq->queuelist, &q->requeue_list);\n\t}\n\tspin_unlock_irqrestore(&q->requeue_lock, flags);\n}", "target": 0}
{"code": "option_handler (assuan_context_t ctx, const char *key, const char *value)\n{\n  ctrl_t ctrl = assuan_get_pointer (ctx);\n  if (!strcmp (key, \"event-signal\"))\n    {\n#ifdef HAVE_W32_SYSTEM\n      if (!*value)\n        return gpg_error (GPG_ERR_ASS_PARAMETER);\n      ctrl->server_local->event_signal = strtoul (value, NULL, 16);\n#else\n      int i = *value? atoi (value) : -1;\n      if (i < 0)\n        return gpg_error (GPG_ERR_ASS_PARAMETER);\n      ctrl->server_local->event_signal = i;\n#endif\n    }\n return 0;\n}", "target": 0}
{"code": "user_local_save_to_keyfile (User     *user,\n                            GKeyFile *keyfile)\n{\n        if (user->email)\n                g_key_file_set_string (keyfile, \"User\", \"Email\", user->email);\n        if (user->language)\n                g_key_file_set_string (keyfile, \"User\", \"Language\", user->language);\n        if (user->x_session)\n                g_key_file_set_string (keyfile, \"User\", \"XSession\", user->x_session);\n        if (user->location)\n                g_key_file_set_string (keyfile, \"User\", \"Location\", user->location);\n        if (user->password_hint)\n                g_key_file_set_string (keyfile, \"User\", \"PasswordHint\", user->password_hint);\n        if (user->icon_file)\n                g_key_file_set_string (keyfile, \"User\", \"Icon\", user->icon_file);\n}", "target": 0}
{"code": "void setup_page_debug(struct kmem_cache *s, struct page *page, void *addr)\n{\n\tif (!(s->flags & SLAB_POISON))\n\t\treturn;\n\tmetadata_access_enable();\n\tmemset(addr, POISON_INUSE, page_size(page));\n\tmetadata_access_disable();\n}", "target": 0}
{"code": "qedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       nfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\tva_end(va);\n}", "target": 1}
{"code": "  inline void init (hb_face_t *face,\n\t\t    hb_tag_t _hea_tag, hb_tag_t _mtx_tag,\n\t\t    unsigned int default_advance_)\n  {\n    this->default_advance = default_advance_;\n    this->num_metrics = face->get_num_glyphs ();\n    hb_blob_t *_hea_blob = OT::Sanitizer<OT::_hea>::sanitize (face->reference_table (_hea_tag));\n    const OT::_hea *_hea = OT::Sanitizer<OT::_hea>::lock_instance (_hea_blob);\n    this->num_advances = _hea->numberOfLongMetrics;\n    hb_blob_destroy (_hea_blob);\n    this->blob = OT::Sanitizer<OT::_mtx>::sanitize (face->reference_table (_mtx_tag));\n    if (unlikely (!this->num_advances ||\n\t\t  2 * (this->num_advances + this->num_metrics) < hb_blob_get_length (this->blob)))\n    {\n      this->num_metrics = this->num_advances = 0;\n      hb_blob_destroy (this->blob);\n      this->blob = hb_blob_get_empty ();\n    }\n    this->table = OT::Sanitizer<OT::_mtx>::lock_instance (this->blob);\n  }", "target": 1}
{"code": "activate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n        primary = _(\"Untrusted application launcher\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"The application launcher %s has not been marked as trusted. \"\n                               \"If you do not know the source of this file, launching it may be unsafe.\"\n                               ),\n                             display_name);\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                      \"text\", primary,\n                      \"secondary-text\", secondary,\n                      NULL);\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Launch Anyway\"), RESPONSE_RUN);\n        if (nautilus_file_can_set_permissions (file))\n        {\n            gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"Mark as _Trusted\"), RESPONSE_MARK_TRUSTED);\n        }\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n        g_signal_connect (dialog, \"response\",\n                          G_CALLBACK (untrusted_launcher_response_callback),\n                          parameters_desktop);\n        gtk_widget_show (dialog);\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"Launching trusted launcher %s\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}", "target": 1}
{"code": "void HTMLMediaElement::StartDeferredLoad() {\n  if (deferred_load_state_ == kWaitingForTrigger) {\n    ExecuteDeferredLoad();\n    return;\n  }\n  if (deferred_load_state_ == kExecuteOnStopDelayingLoadEventTask)\n    return;\n  DCHECK_EQ(deferred_load_state_, kWaitingForStopDelayingLoadEventTask);\n  deferred_load_state_ = kExecuteOnStopDelayingLoadEventTask;\n}", "target": 0}
{"code": "unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\n{\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);\n}", "target": 0}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int remaining = s->icy_metaint - s->icy_data_read;\n    if (remaining < 0)\n        return AVERROR_INVALIDDATA;\n    if (!remaining) {\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n    return FFMIN(size, remaining);\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n   libettercap_init();\n   ef_globals_alloc();\n   select_text_interface();\n   libettercap_ui_init();\n   fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\", \n                      PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);\n   EF_GBL->lineno = 1;\n   parse_options(argc, argv);\n   if (EF_GBL_OPTIONS->source_file) {\n      yyin = fopen(EF_GBL_OPTIONS->source_file, \"r\");\n      if (yyin == NULL)\n         FATAL_ERROR(\"Input file not found !\");\n   } else {\n      FATAL_ERROR(\"No source file.\");\n   }\n   setbuf(yyin, NULL);\n   setbuf(stdout, NULL);\n   setbuf(stderr, NULL);\n   load_tables();\n   load_constants();\n   fprintf(stdout, \"\\n Parsing source file \\'%s\\' \", EF_GBL_OPTIONS->source_file);\n   fflush(stdout);\n   ef_debug(1, \"\\n\");\n   if (yyparse() == 0)\n      fprintf(stdout, \" done.\\n\\n\");\n   else\n      fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");\n   if (write_output() != E_SUCCESS)\n      FATAL_ERROR(\"Cannot write output file (%s)\", EF_GBL_OPTIONS->output_file);\n   ef_globals_free();\n   return 0;\n}", "target": 1}
{"code": "CONCRETE_IO_HANDLE socketio_create(void* io_create_parameters)\n{\n    SOCKETIO_CONFIG* socket_io_config = io_create_parameters;\n    SOCKET_IO_INSTANCE* result;\n    if (socket_io_config == NULL)\n    {\n        LogError(\"Invalid argument: socket_io_config is NULL\");\n        result = NULL;\n    }\n    else\n    {\n        result = malloc(sizeof(SOCKET_IO_INSTANCE));\n        if (result != NULL)\n        {\n            (void)memset(result, 0, sizeof(SOCKET_IO_INSTANCE));\n            result->address_type = ADDRESS_TYPE_IP;\n            result->pending_io_list = singlylinkedlist_create();\n            if (result->pending_io_list == NULL)\n            {\n                LogError(\"Failure: singlylinkedlist_create unable to create pending list.\");\n                destroy_socket_io_instance(result);\n                result = NULL;\n            }\n            else\n            {\n                if (socket_io_config->hostname != NULL)\n                {\n                    result->hostname = (char*)malloc(strlen(socket_io_config->hostname) + 1);\n                    if (result->hostname != NULL)\n                    {\n                        (void)strcpy(result->hostname, socket_io_config->hostname);\n                    }\n                    result->socket = INVALID_SOCKET;\n                }\n                else\n                {\n                    result->hostname = NULL;\n                    result->socket = *((int*)socket_io_config->accepted_socket);\n                }\n                if ((result->hostname == NULL) && (result->socket == INVALID_SOCKET))\n                {\n                    LogError(\"Failure: hostname == NULL and socket is invalid.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->port = socket_io_config->port;\n                    result->on_io_open_complete = NULL;\n                    result->dns_resolver = dns_resolver_create(result->hostname, socket_io_config->port, NULL);\n                    result->target_mac_address = NULL;\n                    result->on_bytes_received = NULL;\n                    result->on_io_error = NULL;\n                    result->on_bytes_received_context = NULL;\n                    result->on_io_error_context = NULL;\n                    result->io_state = IO_STATE_CLOSED;\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Allocation Failure: SOCKET_IO_INSTANCE\");\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static const char *set_enable_sendfile(cmd_parms *cmd, void *d_,\n                                   const char *arg)\n{\n    core_dir_config *d = d_;\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->enable_sendfile = ENABLE_SENDFILE_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->enable_sendfile = ENABLE_SENDFILE_OFF;\n    }\n    else {\n        return \"parameter must be 'on' or 'off'\";\n    }\n    return NULL;\n}", "target": 0}
{"code": "bool DNP3_Base::AddToBuffer(Endpoint* endp, int target_len, const u_char** data, int* len)\n\t{\n\tif ( ! target_len )\n\t\treturn true;\n\tint to_copy = min(*len, target_len - endp->buffer_len);\n\tmemcpy(endp->buffer + endp->buffer_len, *data, to_copy);\n\t*data += to_copy;\n\t*len -= to_copy;\n\tendp->buffer_len += to_copy;\n\treturn endp->buffer_len == target_len;\n\t}", "target": 1}
{"code": "static struct list_head *rb_list_head(struct list_head *list)\n{\n\tunsigned long val = (unsigned long)list;\n\treturn (struct list_head *)(val & ~RB_FLAG_MASK);\n}", "target": 0}
{"code": "void AudioContext::initialize()\n{\n    if (isInitialized())\n        return;\n    FFTFrame::initialize();\n    m_listener = AudioListener::create();\n    if (m_destinationNode.get()) {\n        m_destinationNode->initialize();\n        if (!isOfflineContext()) {\n            startRendering();\n            ++s_hardwareContextCount;\n        }\n        m_isInitialized = true;\n    }\n}", "target": 0}
{"code": "push_n_(codegen_scope *s, int n)\n{\n  if (s->sp+n >= 0xffff) {\n    codegen_error(s, \"too complex expression\");\n  }\n  s->sp+=n;\n  nregs_update;\n}", "target": 0}
{"code": "void hugepage_put_subpool(struct hugepage_subpool *spool)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&spool->lock, flags);\n\tBUG_ON(!spool->count);\n\tspool->count--;\n\tunlock_or_release_subpool(spool, flags);\n}", "target": 0}
{"code": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}", "target": 1}
{"code": "int LibRaw_file_datastream::eof()\n{\n  LR_STREAM_CHK();\n  return f->sgetc() == EOF;\n}", "target": 0}
{"code": "static void nvme_flush_ns_cb(void *opaque, int ret)\n{\n    NvmeFlushAIOCB *iocb = opaque;\n    NvmeNamespace *ns = iocb->ns;\n    if (ret < 0) {\n        iocb->ret = ret;\n        goto out;\n    } else if (iocb->ret < 0) {\n        goto out;\n    }\n    if (ns) {\n        trace_pci_nvme_flush_ns(iocb->nsid);\n        iocb->ns = NULL;\n        iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);\n        return;\n    }\nout:\n    iocb->aiocb = NULL;\n    qemu_bh_schedule(iocb->bh);\n}", "target": 0}
{"code": "mono_loader_set_error_method_load (const char *class_name, const char *member_name)\n{\n\tMonoLoaderError *error;\n\tif (mono_loader_get_last_error ())\n\t\treturn;\n\terror = g_new0 (MonoLoaderError, 1);\n\terror->exception_type = MONO_EXCEPTION_MISSING_METHOD;\n\terror->class_name = g_strdup (class_name);\n\terror->member_name = member_name;\n\tset_loader_error (error);\n}", "target": 0}
{"code": "bool WebContentsImpl::ShouldAssignSiteForURL(const GURL& url) {\n  if (url == GURL(kAboutBlankURL))\n    return false;\n  return GetContentClient()->browser()->ShouldAssignSiteForURL(url);\n}", "target": 0}
{"code": "static bool mac_table_doesnt_fit(void *opaque, int version_id)\n{\n    return !mac_table_fits(opaque, version_id);\n}", "target": 0}
{"code": "bool Item_cache_wrapper::is_null()\n{\n  Item *cached_value;\n  DBUG_ENTER(\"Item_cache_wrapper::is_null\");\n  if (!expr_cache)\n  {\n    bool tmp= orig_item->is_null();\n    null_value= orig_item->null_value;\n    DBUG_RETURN(tmp);\n  }\n  if ((cached_value= check_cache()))\n  {\n    bool tmp= cached_value->is_null();\n    null_value= cached_value->null_value;\n    DBUG_RETURN(tmp);\n  }\n  cache();\n  DBUG_RETURN((null_value= expr_value->null_value));\n}", "target": 0}
{"code": "int LibRaw::adjust_sizes_info_only(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  raw2image_start();\n  if (O.use_fuji_rotate)\n    {\n      if (IO.fuji_width) \n        {\n          IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;\n          S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));\n          S.iheight = (ushort)( (S.iheight - IO.fuji_width) / sqrt(0.5));\n        } \n      else \n        {\n          if (S.pixel_aspect < 0.995) S.iheight = (ushort)( S.iheight / S.pixel_aspect + 0.5);\n          if (S.pixel_aspect > 1.005) S.iwidth  = (ushort) (S.iwidth  * S.pixel_aspect + 0.5);\n        }\n    }\n  SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);\n  if ( S.flip & 4)\n    {\n      unsigned short t = S.iheight;\n      S.iheight=S.iwidth;\n      S.iwidth = t;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);\n    }\n  return 0;\n}", "target": 0}
{"code": "cmsToneCurve* CMSEXPORT cmsBuildGamma(cmsContext ContextID, cmsFloat64Number Gamma)\n{\n    return cmsBuildParametricToneCurve(ContextID, 1, &Gamma);\n}", "target": 0}
{"code": "int gdImageColorClosest (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorClosestAlpha (im, r, g, b, gdAlphaOpaque);\n}", "target": 0}
{"code": "acpi_status acpi_os_delete_cache(acpi_cache_t * cache)\n{\n\tkmem_cache_destroy(cache);\n\treturn (AE_OK);\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d,\n                  typename TTypes<T, 3>::ConstTensor gradient,\n                  typename TTypes<T, 3>::ConstTensor input,\n                  const Tensor* input_min_tensor,\n                  const Tensor* input_max_tensor,\n                  typename TTypes<T, 3>::Tensor input_backprop,\n                  typename TTypes<T>::Flat input_min_backprop,\n                  typename TTypes<T>::Flat input_max_backprop) {\n    QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "static void kvm_update_dr6(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\tkvm_x86_ops->set_dr6(vcpu, vcpu->arch.dr6);\n}", "target": 0}
{"code": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n \tptr = bufstart = buf->value;\n #define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n \t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}", "target": 1}
{"code": "void dtls1_stop_timer(SSL *s)\n{\n    memset(&(s->d1->timeout), 0, sizeof(struct dtls1_timeout_st));\n    memset(&(s->d1->next_timeout), 0, sizeof(struct timeval));\n    s->d1->timeout_duration = 1;\n    BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,\n             &(s->d1->next_timeout));\n    dtls1_clear_record_buffer(s);\n}", "target": 0}
{"code": "f_kind_of_p(VALUE x, VALUE c)\n{\n    return rb_obj_is_kind_of(x, c);\n}", "target": 0}
{"code": "static inline pte_t pte_swp_mksoft_dirty(pte_t pte)\n{\n\treturn pte;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, AndWithNestedNE) {\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{a: {$gt: -1, $lt: 1, $ne: 0}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a:1}, \"\n        \"bounds: {a: [[-1,0,false,false], \"\n        \"[0,1,false,false]]}}}}}\");\n}", "target": 0}
{"code": " int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n {\n \tstruct cred *cred;\n \tif (!(unshare_flags & CLONE_NEWUSER))\n \t\treturn 0;\n \tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n }", "target": 1}
{"code": "int OmniboxViewWin::GetMaxEditWidth(int entry_width) const {\n  RECT formatting_rect;\n  GetRect(&formatting_rect);\n  RECT edit_bounds;\n  GetClientRect(&edit_bounds);\n  return entry_width - formatting_rect.left -\n      (edit_bounds.right - formatting_rect.right);\n}", "target": 0}
{"code": "nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\treturn 0;\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}", "target": 1}
{"code": "ospf_make_md5_digest (struct ospf_interface *oi, struct ospf_packet *op)\n{\n  struct ospf_header *ospfh;\n  unsigned char digest[OSPF_AUTH_MD5_SIZE];\n  MD5_CTX ctx;\n  void *ibuf;\n  u_int32_t t;\n  struct crypt_key *ck;\n  const u_int8_t *auth_key;\n  ibuf = STREAM_DATA (op->s);\n  ospfh = (struct ospf_header *) ibuf;\n  if (ntohs (ospfh->auth_type) != OSPF_AUTH_CRYPTOGRAPHIC)\n    return 0;\n  t = (time(NULL) & 0xFFFFFFFF);\n  if (t > oi->crypt_seqnum)\n    oi->crypt_seqnum = t;\n  else\n    oi->crypt_seqnum++;\n  ospfh->u.crypt.crypt_seqnum = htonl (oi->crypt_seqnum); \n  if (list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))\n    auth_key = (const u_int8_t *) \"\";\n  else\n    {\n      ck = listgetdata (listtail(OSPF_IF_PARAM (oi, auth_crypt)));\n      auth_key = ck->auth_key;\n    }\n  memset(&ctx, 0, sizeof(ctx));\n  MD5Init(&ctx);\n  MD5Update(&ctx, ibuf, ntohs (ospfh->length));\n  MD5Update(&ctx, auth_key, OSPF_AUTH_MD5_SIZE);\n  MD5Final(digest, &ctx);\n  stream_put (op->s, digest, OSPF_AUTH_MD5_SIZE);\n  op->length = ntohs (ospfh->length) + OSPF_AUTH_MD5_SIZE;\n  if (stream_get_endp(op->s) != op->length)\n    zlog_warn(\"ospf_make_md5_digest: length mismatch stream %lu ospf_packet %u\",\n\t      (u_long)stream_get_endp(op->s), op->length);\n  return OSPF_AUTH_MD5_SIZE;\n}", "target": 0}
{"code": "int bio_uncopy_user(struct bio *bio)\n{\n\tstruct bio_map_data *bmd = bio->bi_private;\n\tint ret = 0;\n\tif (!bio_flagged(bio, BIO_NULL_MAPPED)) {\n\t\tif (!current->mm)\n\t\t\tret = -EINTR;\n\t\telse if (bio_data_dir(bio) == READ)\n\t\t\tret = bio_copy_to_iter(bio, bmd->iter);\n\t\tif (bmd->is_our_pages)\n\t\t\tbio_free_pages(bio);\n\t}\n\tkfree(bmd);\n\tbio_put(bio);\n\treturn ret;\n}", "target": 0}
{"code": "static int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint offs, int count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))\n\t\treturn -EFAULT;\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\treturn store_instr(ins.channel, &ins);\n}", "target": 1}
{"code": "  ft_var_readpackedpoints( FT_Stream  stream,\n                           FT_UInt   *point_cnt )\n  {\n    FT_UShort *points;\n    FT_Int     n;\n    FT_Int     runcnt;\n    FT_Int     i;\n     FT_Int     j;\n     FT_Int     first;\n     FT_Memory  memory = stream->memory;\n    FT_Error   error = TT_Err_Ok;\n     FT_UNUSED( error );\n    *point_cnt = n = FT_GET_BYTE();\n    if ( n == 0 )\n      return ALL_POINTS;\n    if ( n & GX_PT_POINTS_ARE_WORDS )\n      n = FT_GET_BYTE() | ( ( n & GX_PT_POINT_RUN_COUNT_MASK ) << 8 );\n    if ( FT_NEW_ARRAY( points, n ) )\n      return NULL;\n    i = 0;\n    while ( i < n )\n    {\n      runcnt = FT_GET_BYTE();\n      if ( runcnt & GX_PT_POINTS_ARE_WORDS )\n      {\n         runcnt = runcnt & GX_PT_POINT_RUN_COUNT_MASK;\n         first  = points[i++] = FT_GET_USHORT();\n        if ( runcnt < 1 )\n           goto Exit;\n        for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_USHORT() );\n      }\n      else\n       {\n         first = points[i++] = FT_GET_BYTE();\n        if ( runcnt < 1 )\n           goto Exit;\n         for ( j = 0; j < runcnt; ++j )\n          points[i++] = (FT_UShort)( first += FT_GET_BYTE() );\n      }\n    }\n  Exit:\n    return points;\n  }", "target": 1}
{"code": "int dummyDCTFilter(short *coeffs, tjregion arrayRegion, tjregion planeRegion,\n\tint componentIndex, int transformIndex, tjtransform *transform)\n{\n\tint i;\n\tfor(i=0; i<arrayRegion.w*arrayRegion.h; i++) coeffs[i]=-coeffs[i];\n\treturn 0;\n}", "target": 0}
{"code": "static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,\n\t\t\t      struct sys_reg_params *p,\n\t\t\t      const struct sys_reg_desc *r)\n{\n\tu64 idx;\n\tif (!kvm_arm_pmu_v3_ready(vcpu))\n\t\treturn trap_raz_wi(vcpu, p, r);\n\tif (r->CRn == 9 && r->CRm == 13) {\n\t\tif (r->Op2 == 2) {\n\t\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = vcpu_sys_reg(vcpu, PMSELR_EL0)\n\t\t\t      & ARMV8_PMU_COUNTER_MASK;\n\t\t} else if (r->Op2 == 0) {\n\t\t\tif (pmu_access_cycle_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n \t\t\tidx = ARMV8_PMU_CYCLE_IDX;\n \t\t} else {\n\t\t\tBUG();\n \t\t}\n \t} else if (r->CRn == 14 && (r->CRm & 12) == 8) {\n \t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n \t\t\treturn false;\n \t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n \t} else {\n\t\tBUG();\n \t}\n \tif (!pmu_counter_idx_valid(vcpu, idx))\n\t\treturn false;\n\tif (p->is_write) {\n\t\tif (pmu_access_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tkvm_pmu_set_counter_value(vcpu, idx, p->regval);\n\t} else {\n\t\tp->regval = kvm_pmu_get_counter_value(vcpu, idx);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, \n         jsi_ScopeChain *scope, Jsi_Value *fargs,\n         Jsi_Value *_this,\n         Jsi_Value **vret)\n{\n    Jsi_Interp *interp = ps->interp;\n    if (interp->exited)\n        return JSI_ERROR;\n    Jsi_RC rc;\n    jsi_Frame frame = *interp->framePtr;\n    frame.parent = interp->framePtr;\n    interp->framePtr = &frame;\n    frame.parent->child = interp->framePtr = &frame;\n    frame.ps = ps;\n    frame.ingsc = scope;\n    frame.incsc = fargs;\n    frame.inthis = _this;\n    frame.opcodes = opcodes;\n    frame.fileName = ((func && func->script)?func->script:interp->curFile);\n    frame.funcName = interp->curFunction;\n    frame.dirName = interp->curDir;\n    if (frame.fileName && frame.fileName == frame.parent->fileName)\n        frame.logflag = frame.parent->logflag;\n    else\n        frame.logflag = 0;\n    frame.level = frame.parent->level+1;\n    frame.evalFuncPtr = func;\n    frame.arguments = NULL;\n    if (interp->curIp)\n        frame.parent->line = interp->curIp->Line;\n    frame.ip = interp->curIp;\n    interp->refCount++;\n    interp->level++;\n    Jsi_IncrRefCount(interp, fargs);\n    rc = jsi_evalcode_sub(ps, opcodes, scope, fargs, _this, *vret);\n    Jsi_DecrRefCount(interp, fargs);\n    if (interp->didReturn == 0 && !interp->exited) {\n        if ((interp->evalFlags&JSI_EVAL_RETURN)==0)\n            Jsi_ValueMakeUndef(interp, vret);\n    }\n    if (frame.arguments)\n        Jsi_DecrRefCount(interp, frame.arguments);\n    interp->didReturn = 0;\n    interp->refCount--;\n    interp->level--;\n    interp->framePtr = frame.parent;\n    interp->framePtr->child = NULL;\n    interp->curIp = frame.ip;\n    if (interp->exited)\n        rc = JSI_ERROR;\n    return rc;\n}", "target": 1}
{"code": "    void TiffReader::visitSizeEntry(TiffSizeEntry* object)\n    {\n        assert(object != 0);\n        readTiffEntry(object);\n        TiffFinder finder(object->dtTag(), object->dtGroup());\n        pRoot_->accept(finder);\n        TiffDataEntryBase* te = dynamic_cast<TiffDataEntryBase*>(finder.result());\n        if (te && te->pValue()) {\n            te->setStrips(object->pValue(), pData_, size_, baseOffset());\n        }\n    }", "target": 0}
{"code": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    for (const std::string& input : node.input()) {\n      if (input.empty())\n        return InvalidArgument(\"Node '\", node.name(), \"' has an empty input\");\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    }\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr type,\n                          ConvertAttribute(node.experimental_type(), builder));\n      state.addAttribute(fulltype_attr, type);\n    }\n    Operation* op = builder.create(state);\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return ::tensorflow::OkStatus();\n}", "target": 1}
{"code": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n \t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n \t\t\t.tcpv_minrtt = ca->base_rtt,\n \t\t};\n\t\tu64 t = ca->sum_rtt;\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n \t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n \t}\n }", "target": 1}
{"code": "static inline void skb_set_transport_header(struct sk_buff *skb,\n\t\t\t\t\t    const int offset)\n{\n\tskb->transport_header = skb->data + offset;\n}", "target": 0}
{"code": "static bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\t\tif (!sgt)\n\t\t\treturn false;\n\t\tsgl = sgt->sgl;\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\terr = -ENAMETOOLONG;\n \tif (outarg.namelen > FUSE_NAME_MAX)\n \t\tgoto err;\n \tname.name = buf;\n \tname.len = outarg.namelen;\n \terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}", "target": 1}
{"code": "  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }", "target": 0}
{"code": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}", "target": 1}
{"code": "static int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\tfor (i = 0; i < refs.count; ++i) {\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\t\tgit_reference_free(ref);\n\t}\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}", "target": 0}
{"code": "static void spl_ptr_heap_destroy(spl_ptr_heap *heap TSRMLS_DC) { \n\tint i;\n\tfor (i=0; i < heap->count; ++i) {\n\t\theap->dtor(heap->elements[i] TSRMLS_CC);\n\t}\n\tefree(heap->elements);\n\tefree(heap);\n}", "target": 0}
{"code": "setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}", "target": 1}
{"code": " GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n {\n     size_t size, len;\n    BOOL ret = FALSE;\n     WCHAR *data = NULL;\n     DWORD bytes, read;\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n         ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n     }\n     size = bytes / sizeof(*data);\n     if (size == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     data = malloc(bytes);\n     if (data == NULL)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n         ReturnLastError(pipe, L\"malloc\");\n        goto out;\n     }\n     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n     if (bytes != read)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n         ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n     }\n     if (data[size - 1] != 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n     sud->std_input = sud->options + len;\n    data = NULL; \n    ret = TRUE;\nout:\n     free(data);\n    return ret;\n }", "target": 1}
{"code": "device_filesystem_create_authorized_cb (Daemon *daemon,\n                                        Device *device,\n                                        DBusGMethodInvocation *context,\n                                        const gchar *action_id,\n                                        guint num_user_data,\n                                        gpointer *user_data_elements)\n{\n  const gchar *fstype = user_data_elements[0];\n  gchar **options = user_data_elements[1];\n  device_filesystem_create_internal (device, fstype, options, NULL, NULL, context);\n}", "target": 0}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n \tmsr.host_initiated = false;\n \tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(&svm->vcpu, 0);\n \t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": " set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n     double rounded;\n     if (code == gs_error_undefinedresult) {\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}", "target": 1}
{"code": "uint WavInFile::getLengthMS() const\n{\n    double numSamples;\n    double sampleRate;\n    numSamples = (double)getNumSamples();\n    sampleRate = (double)getSampleRate();\n    return (uint)(1000.0 * numSamples / sampleRate + 0.5);\n}", "target": 0}
{"code": "uint get_next_field_for_derived_key(uchar *arg)\n{\n  KEYUSE *keyuse= *(KEYUSE **) arg;\n  if (!keyuse)\n    return (uint) (-1);\n  TABLE *table= keyuse->table;\n  uint key= keyuse->key;\n  uint fldno= keyuse->keypart; \n  uint keypart= keyuse->keypart_map == (key_part_map) 1 ?\n                                         0 : (keyuse-1)->keypart+1;\n  for ( ; \n        keyuse->table == table && keyuse->key == key && keyuse->keypart == fldno;\n        keyuse++)\n    keyuse->keypart= keypart;\n  if (keyuse->key != key)\n    keyuse= 0;\n  *((KEYUSE **) arg)= keyuse;\n  return fldno;\n}", "target": 0}
{"code": "void gdImageSetThickness (gdImagePtr im, int thickness)\n{\n\tim->thick = thickness;\n}", "target": 0}
{"code": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n \tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n \t\treturn false;\n\treturn true;\n }", "target": 1}
{"code": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\texp = timespec64_to_ktime(*tsreq);\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}", "target": 1}
{"code": "static void setup_format_params(int track)\n{\n\tint n;\n\tint il;\n\tint count;\n\tint head_shift;\n\tint track_shift;\n\tstruct fparm {\n\t\tunsigned char track, head, sect, size;\n\t} *here = (struct fparm *)floppy_track_buffer;\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->track = track;\n\traw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN |\n\t\t\t  FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\traw_cmd->cmd_count = NR_F;\n\tCOMMAND = FM_MODE(_floppy, FD_FORMAT);\n\tDR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);\n\tF_SIZECODE = FD_SIZECODE(_floppy);\n\tF_SECT_PER_TRACK = _floppy->sect << 2 >> F_SIZECODE;\n\tF_GAP = _floppy->fmt_gap;\n\tF_FILL = FD_FILL_BYTE;\n \traw_cmd->kernel_data = floppy_track_buffer;\n \traw_cmd->length = 4 * F_SECT_PER_TRACK;\n \thead_shift = (F_SECT_PER_TRACK + 5) / 6;\n\ttrack_shift = 2 * head_shift + 3;\n\tn = (track_shift * format_req.track + head_shift * format_req.head)\n\t    % F_SECT_PER_TRACK;\n\til = 1;\n\tif (_floppy->fmt_gap < 0x22)\n\t\til++;\n\tfor (count = 0; count < F_SECT_PER_TRACK; ++count) {\n\t\there[count].track = format_req.track;\n\t\there[count].head = format_req.head;\n\t\there[count].sect = 0;\n\t\there[count].size = F_SIZECODE;\n\t}\n\tfor (count = 1; count <= F_SECT_PER_TRACK; ++count) {\n\t\there[n].sect = count;\n\t\tn = (n + il) % F_SECT_PER_TRACK;\n\t\tif (here[n].sect) {\t\n\t\t\t++n;\n\t\t\tif (n >= F_SECT_PER_TRACK) {\n\t\t\t\tn -= F_SECT_PER_TRACK;\n\t\t\t\twhile (here[n].sect)\n\t\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\tif (_floppy->stretch & FD_SECTBASEMASK) {\n\t\tfor (count = 0; count < F_SECT_PER_TRACK; count++)\n\t\t\there[count].sect += FD_SECTBASE(_floppy) - 1;\n\t}\n}", "target": 1}
{"code": " onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n   if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n   }\n   else {\n     cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "get_signed_descriptor_by_fp(const char *fp, int extrainfo,\n                            time_t publish_cutoff)\n{\n  if (router_digest_is_me(fp)) {\n    if (extrainfo)\n      return &(router_get_my_extrainfo()->cache_info);\n    else\n      return &(router_get_my_routerinfo()->cache_info);\n  } else {\n    const routerinfo_t *ri = router_get_by_id_digest(fp);\n    if (ri &&\n        ri->cache_info.published_on > publish_cutoff) {\n      if (extrainfo)\n        return extrainfo_get_by_descriptor_digest(\n                                     ri->cache_info.extra_info_digest);\n      else\n        return &ri->cache_info;\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "JSRetainPtr<JSStringRef> AccessibilityUIElement::attributesOfDocumentLinks()\n{\n    return JSStringCreateWithCharacters(0, 0);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ContainedOrOfAndCollapseIndenticalScans) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    runQuery(fromjson(\"{c: 1, $or: [{a:1, b:2}, {a:1, b:2}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {c: 1}, node: {ixscan: {pattern: {a: 1, b: 1}},\"\n        \"bounds: {a: [[1,1,true,true]], b: [[2,2,true,true]]},\"\n        \"filter: null}}}\");\n}", "target": 0}
{"code": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\t_gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);\n\t\t\tpk->keyid[0] = _cdk_buftou32(buf + 12);\n\t\t\tpk->keyid[1] = _cdk_buftou32(buf + 16);\n\t\t}\n\t}\n\tlowbits = pk ? pk->keyid[1] : 0;\n\tif (keyid && pk) {\n\t\tkeyid[0] = pk->keyid[0];\n\t\tkeyid[1] = pk->keyid[1];\n\t}\n\treturn lowbits;\n}", "target": 1}
{"code": "static void uivector_init(uivector* p)\n{\n  p->data = NULL;\n  p->size = p->allocsize = 0;\n}", "target": 0}
{"code": "int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)\n{\n    EVP_PKEY *pkey;\n    ASN1_IA5STRING *chal;\n    ASN1_OBJECT *spkioid;\n    int i, n;\n    char *s;\n    BIO_printf(out, \"Netscape SPKI:\\n\");\n    X509_PUBKEY_get0_param(&spkioid, NULL, NULL, NULL, spki->spkac->pubkey);\n    i = OBJ_obj2nid(spkioid);\n    BIO_printf(out, \"  Public Key Algorithm: %s\\n\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    pkey = X509_PUBKEY_get(spki->spkac->pubkey);\n    if (!pkey)\n        BIO_printf(out, \"  Unable to load public key\\n\");\n    else {\n        EVP_PKEY_print_public(out, pkey, 4, NULL);\n        EVP_PKEY_free(pkey);\n    }\n    chal = spki->spkac->challenge;\n    if (chal->length)\n        BIO_printf(out, \"  Challenge String: %s\\n\", chal->data);\n    i = OBJ_obj2nid(spki->sig_algor.algorithm);\n    BIO_printf(out, \"  Signature Algorithm: %s\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    n = spki->signature->length;\n    s = (char *)spki->signature->data;\n    for (i = 0; i < n; i++) {\n        if ((i % 18) == 0)\n            BIO_write(out, \"\\n      \", 7);\n        BIO_printf(out, \"%02x%s\", (unsigned char)s[i],\n                   ((i + 1) == n) ? \"\" : \":\");\n    }\n    BIO_write(out, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "static int su3000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0x51;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached DS3000/TS2020!\");\n\t\treturn 0;\n\t}\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "ctnetlink_parse_tuple_filter(const struct nlattr * const cda[],\n\t\t\t      struct nf_conntrack_tuple *tuple, u32 type,\n\t\t\t      u_int8_t l3num, struct nf_conntrack_zone *zone,\n\t\t\t      u_int32_t flags)\n{\n\tstruct nlattr *tb[CTA_TUPLE_MAX+1];\n\tint err;\n\tmemset(tuple, 0, sizeof(*tuple));\n\terr = nla_parse_nested_deprecated(tb, CTA_TUPLE_MAX, cda[type],\n\t\t\t\t\t  tuple_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\ttuple->src.l3num = l3num;\n\tif (flags & CTA_FILTER_FLAG(CTA_IP_DST) ||\n\t    flags & CTA_FILTER_FLAG(CTA_IP_SRC)) {\n\t\tif (!tb[CTA_TUPLE_IP])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_ip(tb[CTA_TUPLE_IP], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (flags & CTA_FILTER_FLAG(CTA_PROTO_NUM)) {\n\t\tif (!tb[CTA_TUPLE_PROTO])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_proto(tb[CTA_TUPLE_PROTO], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (flags & CTA_FILTER_FLAG(ALL_CTA_PROTO)) {\n\t\treturn -EINVAL;\n\t}\n\tif ((flags & CTA_FILTER_FLAG(CTA_TUPLE_ZONE)) && tb[CTA_TUPLE_ZONE]) {\n\t\tif (!zone)\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_zone(tb[CTA_TUPLE_ZONE],\n\t\t\t\t\t\t type, zone);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (type == CTA_TUPLE_REPLY)\n\t\ttuple->dst.dir = IP_CT_DIR_REPLY;\n\telse\n\t\ttuple->dst.dir = IP_CT_DIR_ORIGINAL;\n\treturn 0;\n}", "target": 1}
{"code": "TxnWrap::TxnWrap(MDB_env *env, MDB_txn *txn) {\n    this->env = env;\n    this->txn = txn;\n    this->flags = 0;\n}", "target": 0}
{"code": "Browser::CreateParams Browser::CreateParams::CreateForApp(\n    const std::string& app_name,\n    bool trusted_source,\n    const gfx::Rect& window_bounds,\n    Profile* profile) {\n  DCHECK(!app_name.empty());\n  CreateParams params(TYPE_POPUP, profile);\n  params.app_name = app_name;\n  params.trusted_source = trusted_source;\n  params.initial_bounds = window_bounds;\n  return params;\n}", "target": 0}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 1}
{"code": "struct dns_https_param *dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tint *priority, char *target, int target_size)\n{\n\tint qtype = 0;\n\tunsigned char *data = NULL;\n\tint rr_len = 0;\n\tdata = dns_get_rr_nested_start(rrs, domain, maxsize, &qtype, ttl, &rr_len);\n\tif (data == NULL) {\n\t\treturn NULL;\n\t}\n\tif (qtype != DNS_T_HTTPS) {\n\t\treturn NULL;\n\t}\n\tif (rr_len < 2) {\n\t\treturn NULL;\n\t}\n\t*priority = _dns_read_short(&data);\n\trr_len -= 2;\n\tif (rr_len <= 0) {\n\t\treturn NULL;\n\t}\n\tint len = strnlen((char *)data, rr_len);\n\tsafe_strncpy(target, (char *)data, target_size);\n\tdata += len + 1;\n\trr_len -= len + 1;\n\tif (rr_len <= 0) {\n\t\treturn NULL;\n\t}\n\treturn (struct dns_https_param *)data;\n}", "target": 1}
{"code": "static int probe_rio(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct rio_usb_data *rio = &rio_instance;\n\tint retval;\n\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);\n\tretval = usb_register_dev(intf, &usb_rio_class);\n\tif (retval) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trio->rio_dev = dev;\n\tif (!(rio->obuf = kmalloc(OBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the output buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\treturn -ENOMEM;\n\t}\n\tdev_dbg(&intf->dev, \"obuf address:%p\\n\", rio->obuf);\n\tif (!(rio->ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the input buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tkfree(rio->obuf);\n\t\treturn -ENOMEM;\n\t}\n\tdev_dbg(&intf->dev, \"ibuf address:%p\\n\", rio->ibuf);\n\tmutex_init(&(rio->lock));\n\tusb_set_intfdata (intf, rio);\n\trio->present = 1;\n\treturn 0;\n}", "target": 1}
{"code": "u32 gf_isom_get_media_type(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn (trak->Media && trak->Media->handler) ? trak->Media->handler->handlerType : 0;\n}", "target": 0}
{"code": "stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\t\treset_globals();\n\t\treturn e;\n\t}\n}", "target": 1}
{"code": "static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,\n                           int* const code_lengths, HuffmanCode* const table) {\n  int ok = 0;\n  int size = 0;\n  VP8LBitReader* const br = &dec->br_;\n  const int simple_code = VP8LReadBits(br, 1);\n  memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));\n  if (simple_code) {  \n    const int num_symbols = VP8LReadBits(br, 1) + 1;\n    const int first_symbol_len_code = VP8LReadBits(br, 1);\n    int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);\n    code_lengths[symbol] = 1;\n    if (num_symbols == 2) {\n      symbol = VP8LReadBits(br, 8);\n      code_lengths[symbol] = 1;\n    }\n    ok = 1;\n  } else {  \n    int i;\n    int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };\n    const int num_codes = VP8LReadBits(br, 4) + 4;\n    assert(num_codes <= NUM_CODE_LENGTH_CODES);\n    for (i = 0; i < num_codes; ++i) {\n      code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);\n    }\n    ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,\n                                code_lengths);\n  }\n  ok = ok && !br->eos_;\n  if (ok) {\n    size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,\n                                 code_lengths, alphabet_size);\n  }\n  if (!ok || size == 0) {\n    return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  }\n  return size;\n}", "target": 1}
{"code": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tstruct user_struct *user;\n\tint ret;\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\tuser = get_current_user();\n\tif (unlikely(atomic_read(&user->inotify_devs) >=\n\t\t\tinotify_max_user_instances)) {\n\t\tret = -EMFILE;\n\t\tgoto out_free_uid;\n\t}\n\tgroup = inotify_new_group(user, inotify_max_queued_events);\n\tif (IS_ERR(group)) {\n\t\tret = PTR_ERR(group);\n\t\tgoto out_free_uid;\n\t}\n\tatomic_inc(&user->inotify_devs);\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n \tif (ret >= 0)\n \t\treturn ret;\n \tatomic_dec(&user->inotify_devs);\n out_free_uid:\n \tfree_uid(user);\n\treturn ret;\n}", "target": 1}
{"code": "SPICE_GNUC_VISIBLE int spice_server_migrate_switch(SpiceServer *reds)\n{\n    spice_debug(\"trace\");\n    if (reds->clients.empty()) {\n       return 0;\n    }\n    reds->expect_migrate = FALSE;\n    if (!reds->config->mig_spice) {\n        spice_warning(\"spice_server_migrate_switch called without migrate_info set\");\n        return 0;\n    }\n    reds->main_channel->migrate_switch(reds->config->mig_spice);\n    reds_mig_release(reds->config);\n    return 0;\n}", "target": 0}
{"code": "static INLINE INT32 planar_skip_plane_rle(const BYTE* pSrcData, UINT32 SrcSize, UINT32 nWidth,\n                                          UINT32 nHeight)\n{\n\tUINT32 x, y;\n\tBYTE controlByte;\n\tconst BYTE* pRLE = pSrcData;\n\tconst BYTE* pEnd = &pSrcData[SrcSize];\n\tfor (y = 0; y < nHeight; y++)\n\t{\n\t\tfor (x = 0; x < nWidth;)\n\t\t{\n\t\t\tint cRawBytes;\n\t\t\tint nRunLength;\n\t\t\tif (pRLE >= pEnd)\n\t\t\t\treturn -1;\n\t\t\tcontrolByte = *pRLE++;\n\t\t\tnRunLength = PLANAR_CONTROL_BYTE_RUN_LENGTH(controlByte);\n\t\t\tcRawBytes = PLANAR_CONTROL_BYTE_RAW_BYTES(controlByte);\n\t\t\tif (nRunLength == 1)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 16;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\telse if (nRunLength == 2)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 32;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\tpRLE += cRawBytes;\n\t\t\tx += cRawBytes;\n\t\t\tx += nRunLength;\n\t\t\tif (x > nWidth)\n\t\t\t\treturn -1;\n\t\t\tif (pRLE > pEnd)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn (INT32)(pRLE - pSrcData);\n}", "target": 1}
{"code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\tatomic_thread_fence();\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 1}
{"code": "static void set_banner(struct openconnect_info *vpninfo)\n{\n        char *banner, *q;\n        const char *p;\n       if (!vpninfo->banner || !(banner = malloc(strlen(vpninfo->banner)))) {\n                unsetenv(\"CISCO_BANNER\");\n                return;\n        }\n\tp = vpninfo->banner;\n\tq = banner;\n\twhile (*p) {\n\t\tif (*p == '%' && isxdigit((int)(unsigned char)p[1]) &&\n\t\t    isxdigit((int)(unsigned char)p[2])) {\n\t\t\t*(q++) = unhex(p + 1);\n\t\t\tp += 3;\n\t\t} else \n\t\t\t*(q++) = *(p++);\n\t}\n\t*q = 0;\n\tsetenv(\"CISCO_BANNER\", banner, 1);\n\tfree(banner);\n}\t", "target": 1}
{"code": "ProcCirculateWindow(ClientPtr client)\n{\n    WindowPtr pWin;\n    REQUEST(xCirculateWindowReq);\n    int rc;\n    REQUEST_SIZE_MATCH(xCirculateWindowReq);\n    if ((stuff->direction != RaiseLowest) && (stuff->direction != LowerHighest)) {\n        client->errorValue = stuff->direction;\n        return BadValue;\n    }\n    rc = dixLookupWindow(&pWin, stuff->window, client, DixManageAccess);\n    if (rc != Success)\n        return rc;\n    CirculateWindow(pWin, (int) stuff->direction, client);\n    return Success;\n}", "target": 0}
{"code": "static void imap_login_preinit(void)\n{\n\tlogin_set_roots = imap_login_setting_roots;\n}", "target": 0}
{"code": "long kernel_wait4(pid_t upid, int __user *stat_addr, int options,\n\t\t  struct rusage *ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\tif (options & ~(WNOHANG|WUNTRACED|WCONTINUED|\n \t\t\t__WNOTHREAD|__WCLONE|__WALL))\n \t\treturn -EINVAL;\n \tif (upid == -1)\n \t\ttype = PIDTYPE_MAX;\n \telse if (upid < 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = get_task_pid(current, PIDTYPE_PGID);\n\t} else  {\n\t\ttype = PIDTYPE_PID;\n\t\tpid = find_get_pid(upid);\n\t}\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options | WEXITED;\n\two.wo_info\t= NULL;\n\two.wo_stat\t= 0;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\tput_pid(pid);\n\tif (ret > 0 && stat_addr && put_user(wo.wo_stat, stat_addr))\n\t\tret = -EFAULT;\n\treturn ret;\n}", "target": 1}
{"code": "void RenderView::didNotAllowScript(WebKit::WebFrame* frame) {\n  DidBlockContentType(CONTENT_SETTINGS_TYPE_JAVASCRIPT);\n}", "target": 0}
{"code": "static inline int rtnetlink_fill_iwinfo(struct sk_buff *\tskb,\n\t\t\t\t\tstruct net_device *\tdev,\n\t\t\t\t\tint\t\t\ttype,\n\t\t\t\t\tchar *\t\t\tevent,\n\t\t\t\t\tint\t\t\tevent_len)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tnlh = NLMSG_PUT(skb, 0, 0, type, sizeof(*r));\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev->flags;\n\tr->ifi_change = 0;\t\n\tRTA_PUT(skb, IFLA_WIRELESS,\n\t\tevent_len, event);\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "shell_gtk_embed_on_window_mapped (GtkWidget     *object,\n                                  ShellGtkEmbed *embed)\n{\n  ShellGtkEmbedPrivate *priv = shell_gtk_embed_get_instance_private (embed);\n  MetaDisplay *display = shell_global_get_display (shell_global_get ());\n  if (priv->window_created_handler == 0 && priv->window_actor == NULL)\n    priv->window_created_handler =\n      g_signal_connect (display,\n                        \"window-created\",\n                        G_CALLBACK (shell_gtk_embed_window_created_cb),\n                        embed);\n}", "target": 0}
{"code": "GF_Err fiin_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_PAEN:\n\t\tBOX_FIELD_LIST_ASSIGN(partition_entries)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SEGR:\n\t\tBOX_FIELD_ASSIGN(session_info, FDSessionGroupBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_GITN:\n\t\tBOX_FIELD_ASSIGN(group_id_to_name, GroupIdToNameBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "date_s__valid_nth_kday_p(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE vy, vm, vn, vk, vsg;\n    VALUE argv2[5];\n    rb_scan_args(argc, argv, \"41\", &vy, &vm, &vn, &vk, &vsg);\n    argv2[0] = vy;\n    argv2[1] = vm;\n    argv2[2] = vn;\n    argv2[3] = vk;\n    if (argc < 5)\n\targv2[4] = DBL2NUM(GREGORIAN);\n    else\n\targv2[4] = vsg;\n    return valid_nth_kday_sub(5, argv2, klass, 1);\n}", "target": 0}
{"code": "int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tstruct cp_control cpc;\n\tint err = 0;\n\tif (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\tcpc.trimmed = 0;\n\tif (end <= MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\"Found FS corruption, run fsck to fix.\");\n\t\tgoto out;\n\t}\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));\n\tfor (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {\n\t\tcpc.trim_start = start_segno;\n\t\tif (sbi->discard_blks == 0)\n\t\t\tbreak;\n\t\telse if (sbi->discard_blks < BATCHED_TRIM_BLOCKS(sbi))\n\t\t\tcpc.trim_end = end_segno;\n\t\telse\n\t\t\tcpc.trim_end = min_t(unsigned int,\n\t\t\t\trounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1, end_segno);\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\terr = write_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t\tif (err)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tmark_discard_range_all(sbi);\n\tf2fs_wait_discard_bios(sbi);\nout:\n\trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n\treturn err;\n}", "target": 1}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "GF_Err prhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->yaw);\n\tgf_bs_write_u32(bs, ptr->pitch);\n\tgf_bs_write_u32(bs, ptr->roll);\n\treturn GF_OK;\n}", "target": 0}
{"code": "pid_t LightProcess::proc_open(const char *cmd, const std::vector<int> &created,\n                              const std::vector<int> &desired,\n                              const char *cwd,\n                              const std::vector<std::string> &env) {\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  always_assert(Available());\n  always_assert(created.size() == desired.size());\n  if (fprintf(g_procs[id].m_fout, \"proc_open\\n%s\\n%s\\n\", cmd, cwd) <= 0) {\n    Logger::Error(\"Failed to send command proc_open\");\n    return -1;\n  }\n  fprintf(g_procs[id].m_fout, \"%d\\n\", (int)env.size());\n  for (unsigned int i = 0; i < env.size(); i++) {\n    fprintf(g_procs[id].m_fout, \"%s\\n\", env[i].c_str());\n  }\n  fprintf(g_procs[id].m_fout, \"%d\\n\", (int)created.size());\n  for (unsigned int i = 0; i < desired.size(); i++) {\n    fprintf(g_procs[id].m_fout, \"%d\\n\", desired[i]);\n  }\n  fflush(g_procs[id].m_fout);\n  bool error_send = false;\n  int save_errno = 0;\n  for (unsigned int i = 0; i < created.size(); i++) {\n    if (!send_fd(g_procs[id].m_afdt_fd, created[i])) {\n      error_send = true;\n      save_errno = errno;\n      break;\n    }\n  }\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  if (strncmp(buf, \"error\", 5) == 0) {\n    read_buf(g_procs[id].m_fin, buf);\n    sscanf(buf, \"%d\", &errno);\n    if (error_send) {\n      errno = save_errno;\n    }\n    return -1;\n  }\n  int64_t pid = -1;\n  sscanf(buf, \"%\" PRId64, &pid);\n  assert(pid);\n  return (pid_t)pid;\n}", "target": 1}
{"code": "static int firm_set_rts(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb rts_command;\n\trts_command.port = port->port_number + 1;\n\trts_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_RTS,\n\t\t\t(__u8 *)&rts_command, sizeof(rts_command));\n}", "target": 0}
{"code": "void LibRaw::unpacked_load_raw_reversed()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  for (row = raw_height - 1; row >= 0; row--)\n  {\n    checkCancel();\n    read_shorts(&raw_image[row * raw_width], raw_width);\n    for (col = 0; col < raw_width; col++)\n      if ((RAW(row, col) >>= load_flags) >> bits &&\n          (unsigned)(row - top_margin) < height &&\n          (unsigned)(col - left_margin) < width)\n        derror();\n  }\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_options)\n{\n\tphp_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_OPTIONS);\n}", "target": 0}
{"code": "void kvm_disable_largepages(void)\n{\n\tlargepages_enabled = false;\n}", "target": 0}
{"code": "mm_sshpam_respond(void *ctx, u_int num, char **resp)\n{\n\tBuffer m;\n\tint i, ret;\n\tdebug3(\"%s\", __func__);\n\tbuffer_init(&m);\n\tbuffer_put_int(&m, num);\n\tfor (i = 0; i < num; ++i)\n\t\tbuffer_put_cstring(&m, resp[i]);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_RESPOND, &m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_RESPOND\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_RESPOND, &m);\n\tret = buffer_get_int(&m);\n\tdebug3(\"%s: pam_respond returned %d\", __func__, ret);\n\tbuffer_free(&m);\n\treturn (ret);\n}", "target": 0}
{"code": "static void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint uninitialized_var(is_swbp);\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\tsend_sig(SIGTRAP, current, 0);\n\t\t} else {\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\tinstruction_pointer_set(regs, bp_vaddr);\n\tsmp_rmb(); \n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\tif (!get_utask())\n\t\tgoto out;\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\thandler_chain(uprobe, regs);\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\nout:\n\tput_uprobe(uprobe);\n}", "target": 0}
{"code": "void SVGDocumentExtensions::reportWarning(const String& message)\n{\n    reportMessage(m_document, WarningMessageLevel, \"Warning: \" + message);\n}", "target": 0}
{"code": "void bitmap_cache_register_callbacks(rdpUpdate* update)\n{\n\trdpCache* cache = update->context->cache;\n\tcache->bitmap->MemBlt = update->primary->MemBlt;\n\tcache->bitmap->Mem3Blt = update->primary->Mem3Blt;\n\tupdate->primary->MemBlt = update_gdi_memblt;\n\tupdate->primary->Mem3Blt = update_gdi_mem3blt;\n\tupdate->secondary->CacheBitmap = update_gdi_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_gdi_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_gdi_cache_bitmap_v3;\n\tupdate->BitmapUpdate = gdi_bitmap_update;\n}", "target": 0}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n  int i;\n  gdImagePtr im;\n  if (overflow2(sizeof (unsigned char *), sy)) {\n\tgdFree(im);\n\treturn NULL;\n  }\n  im = (gdImage *) gdMalloc (sizeof (gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n  memset (im, 0, sizeof (gdImage));\n  im->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n  im->polyInts = 0;\n  im->polyAllocated = 0;\n  im->brush = 0;\n  im->tile = 0;\n  im->style = 0;\n  for (i = 0; (i < sy); i++)\n    {\n      im->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\t\tif (!im->pixels[i]) \n\t\t\t{\n\t\t\t\tfor (--i ; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t\t}\n\t\t\t\tgdFree(im);\n\t\t\t\treturn NULL;\n\t\t\t}\n    }\n  im->sx = sx;\n  im->sy = sy;\n  im->colorsTotal = 0;\n  im->transparent = (-1);\n  im->interlace = 0;\n  im->thick = 1;\n  im->AA = 0;\n  for (i = 0; (i < gdMaxColors); i++)\n    {\n      im->open[i] = 1;\n      im->red[i] = 0;\n      im->green[i] = 0;\n      im->blue[i] = 0;\n    };\n  im->trueColor = 0;\n  im->tpixels = 0;\n  im->cx1 = 0;\n  im->cy1 = 0;\n  im->cx2 = im->sx - 1;\n  im->cy2 = im->sy - 1;\n  return im;\n}", "target": 1}
{"code": "PHP_FUNCTION(curl_version)\n{\n\tcurl_version_info_data *d;\n\tlong uversion = CURLVERSION_NOW;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &uversion) == FAILURE) {\n\t\treturn;\n\t}\n\td = curl_version_info(uversion);\n\tif (d == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tarray_init(return_value);\n\tCAAL(\"version_number\", d->version_num);\n\tCAAL(\"age\", d->age);\n\tCAAL(\"features\", d->features);\n\tCAAL(\"ssl_version_number\", d->ssl_version_num);\n\tCAAS(\"version\", d->version);\n\tCAAS(\"host\", d->host);\n\tCAAS(\"ssl_version\", d->ssl_version);\n\tCAAS(\"libz_version\", d->libz_version);\n\t{\n\t\tchar **p = (char **) d->protocols;\n\t\tzval  *protocol_list = NULL;\n\t\tMAKE_STD_ZVAL(protocol_list);\n\t\tarray_init(protocol_list);\n\t\twhile (*p != NULL) {\n\t\t\tadd_next_index_string(protocol_list, *p, 1);\n\t\t\tp++;\n\t\t}\n\t\tCAAZ(\"protocols\", protocol_list);\n\t}\n}", "target": 0}
{"code": "static void iova_entry_free(unsigned long data)\n{\n\tstruct page *freelist = (struct page *)data;\n\tdma_free_pagelist(freelist);\n}", "target": 0}
{"code": "static void do_clear(enum clear_what what, bool context)\n{\n    if (context) {\n        if (what & CLEAR_ALLDEFINE) {\n            Context *ctx;\n            list_for_each(ctx, cstk)\n                clear_smacro_table(&ctx->localmac, what);\n        }\n    } else {\n        if (what & CLEAR_ALLDEFINE)\n            clear_smacro_table(&smacros, what);\n        if (what & CLEAR_MMACRO)\n            free_mmacro_table(&mmacros);\n    }\n}", "target": 0}
{"code": "local block_state deflate_fast(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    IPos hash_head;       \n    int bflush;           \n    for (;;) {\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; \n        }\n        hash_head = NIL;\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n            s->match_length = longest_match (s, hash_head);\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->match_start, s->match_length);\n            _tr_tally_dist(s, s->strstart - s->match_start,\n                           s->match_length - MIN_MATCH, bflush);\n            s->lookahead -= s->match_length;\n#ifndef FASTEST\n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) {\n                s->match_length--; \n                do {\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                } while (--s->match_length != 0);\n                s->strstart++;\n            } else\n#endif\n            {\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window[s->strstart];\n                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n            }\n        } else {\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit (s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_request_sock *req_inet;\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\treq_inet = inet_rsk(req);\n\topt = xchg(&req_inet->opt, opt);\n\tkfree(opt);\n\treturn 0;\nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1}
{"code": "static void sco_sock_clear_timer(struct sock *sk)\n{\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tsk_stop_timer(sk, &sk->sk_timer);\n}", "target": 0}
{"code": "vreader_slot (int vrdr)\n{\n  if (vrdr == -1 || !(vrdr >= 0 && vrdr < DIM(vreader_table)))\n    return -1;\n  if (!vreader_table [vrdr].valid)\n    return -1;\n  return vreader_table[vrdr].slot;\n}", "target": 0}
{"code": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n \tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n \tunsigned int assoclen = req->assoclen;\n \tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n \tint ilen, err;\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static inline void ConvertXYZToRGB(const double X,const double Y,const double Z,\n  double *red,double *green,double *blue)\n{\n  double\n    b,\n    g,\n    r;\n  assert(red != (double *) NULL);\n  assert(green != (double *) NULL);\n  assert(blue != (double *) NULL);\n  r=3.2404542*X-1.5371385*Y-0.4985314*Z;\n  g=(-0.9692660)*X+1.8760108*Y+0.0415560*Z;\n  b=0.0556434*X-0.2040259*Y+1.0572252*Z;\n  *red=EncodePixelGamma(QuantumRange*r);\n  *green=EncodePixelGamma(QuantumRange*g);\n  *blue=EncodePixelGamma(QuantumRange*b);\n}", "target": 0}
{"code": "ospf_router_lsa_links_examin\n(\n  struct router_lsa_link * link,\n  u_int16_t linkbytes,\n  const u_int16_t num_links\n)\n{\n  unsigned counted_links = 0, thislinklen;\n  while (linkbytes)\n  {\n    thislinklen = OSPF_ROUTER_LSA_LINK_SIZE + 4 * link->m[0].tos_count;\n    if (thislinklen > linkbytes)\n    {\n      if (IS_DEBUG_OSPF_PACKET (0, RECV))\n        zlog_debug (\"%s: length error in link block #%u\", __func__, counted_links);\n      return MSG_NG;\n    }\n    link = (struct router_lsa_link *)((caddr_t) link + thislinklen);\n    linkbytes -= thislinklen;\n    counted_links++;\n  }\n  if (counted_links != num_links)\n  {\n    if (IS_DEBUG_OSPF_PACKET (0, RECV))\n      zlog_debug (\"%s: %u link blocks declared, %u present\",\n                  __func__, num_links, counted_links);\n    return MSG_NG;\n  }\n  return MSG_OK;\n}", "target": 0}
{"code": "sync_path (struct url *u)\n{\n  char *newpath, *efile, *edir;\n  xfree (u->path);\n  edir = url_escape_dir (u->dir);\n  efile = url_escape_1 (u->file, urlchr_unsafe | urlchr_reserved, 1);\n  if (!*edir)\n    newpath = xstrdup (efile);\n  else\n    {\n      int dirlen = strlen (edir);\n      int filelen = strlen (efile);\n      char *p = newpath = xmalloc (dirlen + 1 + filelen + 1);\n      memcpy (p, edir, dirlen);\n      p += dirlen;\n      *p++ = '/';\n      memcpy (p, efile, filelen);\n      p += filelen;\n      *p = '\\0';\n    }\n  u->path = newpath;\n  if (edir != u->dir)\n    xfree (edir);\n  if (efile != u->file)\n    xfree (efile);\n  xfree (u->url);\n  u->url = url_string (u, URL_AUTH_SHOW);\n}", "target": 0}
{"code": "static CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)\n{\n    zend_class_entry *ce = zend_lookup_class(class_name);\n    if (ce)\n    {\n        return ce;\n    }\n    zval user_func, args[1], retval;\n    if ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0'))\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));\n    Z_STR(user_func) = fname;\n    Z_TYPE_INFO(user_func) = IS_STRING_EX;\n    ZVAL_STR(&args[0], class_name);\n    call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL);\n    swoole_string_release(fname);\n    ce = zend_lookup_class(class_name);\n    if (!ce)\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    else\n    {\n        return ce;\n    }\n}", "target": 1}
{"code": "spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\t*minor_status = 0;\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &(*ctx)->ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\treturn (ret);\n}", "target": 1}
{"code": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\t*prev = NULL;\t\n\tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n\t\treturn -EINVAL;\n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}", "target": 1}
{"code": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\tif (flags)\n\t\t*flags++ = '\\0';\t\n\tif (nodelist) {\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\tmode_flags = 0;\n\tif (flags) {\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\tnew->w.user_nodemask = nodes;\n\terr = 0;\nout:\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}", "target": 1}
{"code": "MP4::Properties::bitrate() const\n{\n  return d->bitrate;\n}", "target": 0}
{"code": "int av_lockmgr_register(int (*cb)(void **mutex, enum AVLockOp op))\n{\n    if (lockmgr_cb) {\n        if (lockmgr_cb(&codec_mutex, AV_LOCK_DESTROY))\n            return -1;\n        if (lockmgr_cb(&avformat_mutex, AV_LOCK_DESTROY))\n            return -1;\n    }\n    lockmgr_cb = cb;\n    if (lockmgr_cb) {\n        if (lockmgr_cb(&codec_mutex, AV_LOCK_CREATE))\n            return -1;\n        if (lockmgr_cb(&avformat_mutex, AV_LOCK_CREATE))\n            return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "void rds_inc_info_copy(struct rds_incoming *inc,\n\t\t       struct rds_info_iterator *iter,\n\t\t       __be32 saddr, __be32 daddr, int flip)\n{\n\tstruct rds_info_message minfo;\n\tminfo.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo.len = be32_to_cpu(inc->i_hdr.h_len);\n\tif (flip) {\n\t\tminfo.laddr = daddr;\n\t\tminfo.faddr = saddr;\n\t\tminfo.lport = inc->i_hdr.h_dport;\n\t\tminfo.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo.laddr = saddr;\n\t\tminfo.faddr = daddr;\n\t\tminfo.lport = inc->i_hdr.h_sport;\n \t\tminfo.fport = inc->i_hdr.h_dport;\n \t}\n \trds_info_copy(iter, &minfo, sizeof(minfo));\n }", "target": 1}
{"code": "char *cgit_repourl(const char *reponame)\n{\n\tif (ctx.cfg.virtual_root)\n\t\treturn fmtalloc(\"%s%s/\", ctx.cfg.virtual_root, reponame);\n\telse\n\t\treturn fmtalloc(\"?r=%s\", reponame);\n}", "target": 0}
{"code": "mysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET field_offset)\n{\n  MYSQL_FIELD_OFFSET return_value=result->current_field;\n  result->current_field=field_offset;\n  return return_value;\n}", "target": 0}
{"code": "static int call_usermodehelper_keys(char *path, char **argv, char **envp,\n\t\t\t\t\tstruct key *session_keyring, int wait)\n{\n\treturn call_usermodehelper_fns(path, argv, envp, wait,\n\t\t\t\t       umh_keys_init, umh_keys_cleanup,\n\t\t\t\t       key_get(session_keyring));\n}", "target": 0}
{"code": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n  if (!s)\n    return -1;\n  while (*s)\n  {\n    SKIPWS(s);\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS(s);\n      ptmp = tmp;\n      while (isdigit((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = '\\0';\n      if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static void redo_format(void)\n{\n\tbuffer_track = -1;\n\tsetup_format_params(format_req.track << STRETCH(_floppy));\n\tfloppy_start();\n\tdebugt(__func__, \"queue format request\");\n}", "target": 0}
{"code": "static INLINE RECTANGLE_16* region16_rects_noconst(REGION16* region)\n{\n\tREGION16_DATA* data;\n\tdata = region->data;\n\tif (!data)\n\t\treturn NULL;\n\treturn (RECTANGLE_16*)(&data[1]);\n}", "target": 0}
{"code": "bool EditorClientBlackBerry::shouldChangeSelectedRange(Range* fromRange, Range* toRange, EAffinity affinity, bool stillSelecting)\n{\n    if (m_webPagePrivate->m_dumpRenderTree)\n        return m_webPagePrivate->m_dumpRenderTree->shouldChangeSelectedDOMRangeToDOMRangeAffinityStillSelecting(fromRange, toRange, static_cast<int>(affinity), stillSelecting);\n     Frame* frame = m_webPagePrivate->focusedOrMainFrame();\n     if (frame && frame->document()) {\n        if (Node* focusedNode = frame->document()->focusedNode()) {\n            if (focusedNode->hasTagName(HTMLNames::selectTag))\n                return false;\n            if (focusedNode->isElementNode() && DOMSupport::isPopupInputField(static_cast<Element*>(focusedNode)))\n                return false;\n        }\n         if (m_webPagePrivate->m_inputHandler->isInputMode() && fromRange && toRange && (fromRange->startContainer() == toRange->startContainer()))\n            m_webPagePrivate->m_inputHandler->notifyClientOfKeyboardVisibilityChange(true);\n    }\n    return true;\n}", "target": 0}
{"code": "ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}", "target": 1}
{"code": "static inline pmd_t pmd_mknuma(pmd_t pmd)\n{\n\treturn pmd;\n}", "target": 0}
{"code": "      unsigned int scalar4(const mp_func op,\n                           const unsigned int arg1, const unsigned int arg2, const unsigned int arg3,\n                           const unsigned int arg4) {\n        const unsigned int pos =\n          arg1>_cimg_mp_slot_c && _cimg_mp_is_comp(arg1)?arg1:\n          arg2>_cimg_mp_slot_c && _cimg_mp_is_comp(arg2)?arg2:\n          arg3>_cimg_mp_slot_c && _cimg_mp_is_comp(arg3)?arg3:\n          arg4>_cimg_mp_slot_c && _cimg_mp_is_comp(arg4)?arg4:scalar();\n        CImg<ulongT>::vector((ulongT)op,pos,arg1,arg2,arg3,arg4).move_to(code);\n        return pos;", "target": 0}
{"code": "int luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                    int narg1, int delta) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \n      return precallC(L, func, LUA_MULTRET, clCvalue(s2v(func))->f);\n    case LUA_VLCF:  \n      return precallC(L, func, LUA_MULTRET, fvalue(s2v(func)));\n    case LUA_VLCL: {  \n      Proto *p = clLvalue(s2v(func))->p;\n      int fsize = p->maxstacksize;  \n      int nfixparams = p->numparams;\n      int i;\n      ci->func -= delta;  \n      for (i = 0; i < narg1; i++)  \n        setobjs2s(L, ci->func + i, func + i);\n      checkstackGC(L, fsize);\n      func = ci->func;  \n      for (; narg1 <= nfixparams; narg1++)\n        setnilvalue(s2v(func + narg1));  \n      ci->top = func + 1 + fsize;  \n      lua_assert(ci->top <= L->stack_last);\n      ci->u.l.savedpc = p->code;  \n      ci->callstatus |= CIST_TAIL;\n      L->top = func + narg1;  \n      return -1;\n    }\n    default: {  \n      func = luaD_tryfuncTM(L, func);  \n      narg1++;\n      goto retry;  \n    }\n  }\n}", "target": 1}
{"code": "int rds_rdma_extra_size(struct rds_rdma_args *args)\n{\n\tstruct rds_iovec vec;\n\tstruct rds_iovec __user *local_vec;\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n \tlocal_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;\n \tfor (i = 0; i < args->nr_local; i++) {\n \t\tif (copy_from_user(&vec, &local_vec[i],\n\t\t\t\t   sizeof(struct rds_iovec)))\n\t\t\treturn -EFAULT;\n\t\tnr_pages = rds_pages_in_vec(&vec);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\t\ttot_pages += nr_pages;\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn tot_pages * sizeof(struct scatterlist);\n}", "target": 1}
{"code": "exif_data_save_data_entry (ExifData *data, ExifEntry *e,\n\t\t\t   unsigned char **d, unsigned int *ds,\n\t\t\t   unsigned int offset)\n{\n\tunsigned int doff, s;\n\tunsigned int ts;\n\tif (!data || !data->priv) \n\t\treturn;\n\texif_set_short (*d + 6 + offset + 0,\n\t\t\tdata->priv->order, (ExifShort) e->tag);\n\texif_set_short (*d + 6 + offset + 2,\n\t\t\tdata->priv->order, (ExifShort) e->format);\n\tif (!(data->priv->options & EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE)) {\n\t\tif ((e->tag == EXIF_TAG_MAKER_NOTE) && data->priv->md) {\n\t\t\texif_mem_free (data->priv->mem, e->data);\n\t\t\te->data = NULL;\n\t\t\te->size = 0;\n\t\t\texif_mnote_data_set_offset (data->priv->md, *ds - 6);\n\t\t\texif_mnote_data_save (data->priv->md, &e->data, &e->size);\n\t\t\te->components = e->size;\n\t\t\tif (exif_format_get_size (e->format) != 1) {\n\t\t\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\t\t}\n\t\t}\n\t}\n\texif_set_long  (*d + 6 + offset + 4,\n\t\t\tdata->priv->order, e->components);\n\ts = exif_format_get_size (e->format) * e->components;\n\tif (s > 4) {\n\t\tunsigned char *t;\n\t\tdoff = *ds - 6;\n\t\tts = *ds + s;\n\t\tif (s & 1)\n\t\t\tts++;\n\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\tif (!t) {\n\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t\t  \treturn;\n\t\t}\n\t\t*d = t;\n\t\t*ds = ts;\n\t\texif_set_long (*d + 6 + offset + 8, data->priv->order, doff);\n\t\tif (s & 1) \n\t\t\t*(*d + *ds - 1) = '\\0';\n\t} else\n\t\tdoff = offset + 8;\n\tif (e->data) {\n\t\tmemcpy (*d + 6 + doff, e->data, s);\n\t} else {\n\t\tmemset (*d + 6 + doff, 0, s);\n\t}\n\tif (s < 4) \n\t\tmemset (*d + 6 + doff + s, 0, (4 - s));\n}", "target": 1}
{"code": "MONGO_EXPORT bson_bool_t mongo_cmd_authenticate( mongo *conn, const char *db, const char *user, const char *pass ) {\n    bson from_db;\n    bson cmd;\n    const char *nonce;\n    int result;\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n    char hex_digest[33];\n    if( mongo_simple_int_command( conn, db, \"getnonce\", 1, &from_db ) == MONGO_OK ) {\n        bson_iterator it;\n        bson_find( &it, &from_db, \"nonce\" );\n        nonce = bson_iterator_string( &it );\n    }\n    else {\n        return MONGO_ERROR;\n    }\n    mongo_pass_digest( user, pass, hex_digest );\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )nonce, strlen( nonce ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )hex_digest, 32 );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n    bson_init( &cmd );\n    bson_append_int( &cmd, \"authenticate\", 1 );\n    bson_append_string( &cmd, \"user\", user );\n    bson_append_string( &cmd, \"nonce\", nonce );\n    bson_append_string( &cmd, \"key\", hex_digest );\n    bson_finish( &cmd );\n    bson_destroy( &from_db );\n    result = mongo_run_command( conn, db, &cmd, NULL );\n    bson_destroy( &cmd );\n    return result;\n}", "target": 1}
{"code": "static void virtual_xfer_breadcrumbs(struct virtual_engine *ve,\n\t\t\t\t     struct intel_engine_cs *engine)\n{\n\tstruct intel_engine_cs *old = ve->siblings[0];\n\tspin_lock(&old->breadcrumbs.irq_lock);\n\tif (!list_empty(&ve->context.signal_link)) {\n\t\tlist_move_tail(&ve->context.signal_link,\n\t\t\t       &engine->breadcrumbs.signalers);\n\t\tintel_engine_queue_breadcrumbs(engine);\n\t}\n\tspin_unlock(&old->breadcrumbs.irq_lock);\n}", "target": 0}
{"code": "nfsd4_layoutget_release(union nfsd4_op_u *u)\n{\n\tkfree(u->layoutget.lg_content);\n}", "target": 0}
{"code": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\treturn 0;\n\t}\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else if (is_pae(vcpu) && is_paging(vcpu) &&\n\t\t   !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}", "target": 0}
{"code": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\ncheck:\n\twhile ((ptr = strstr(dir, \"\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\treturn rpath;\n}", "target": 1}
{"code": "Variant array_search(const Variant& needle,\n                     const Variant& haystack,\n                     bool strict ) {\n  Variant ret = false;\n  auto ok = strict ?\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::same(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; }) :\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::equal(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; });\n  if (UNLIKELY(!ok)) {\n    raise_warning(\"array_search() expects parameter 2 to be an array \"\n                  \"or collection\");\n    return init_null();\n  }\n  return ret;\n}", "target": 0}
{"code": "static inline float *VMUL2S(float *dst, const float *v, unsigned idx,\n                            unsigned sign, const float *scale)\n{\n    union av_intfloat32 s0, s1;\n    s0.f = s1.f = *scale;\n    s0.i ^= sign >> 1 << 31;\n    s1.i ^= sign      << 31;\n    *dst++ = v[idx    & 15] * s0.f;\n    *dst++ = v[idx>>4 & 15] * s1.f;\n    return dst;\n}", "target": 0}
{"code": "static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n \tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n \t\treturn -ENOMEM;\n \tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n \tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n \tif (!newinfo)\n\t\treturn -ENOMEM;\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}", "target": 1}
{"code": "static void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}", "target": 0}
{"code": "static inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\treturn *pmdp;\n}", "target": 0}
{"code": "vte_sequence_handler_UP (VteTerminal *terminal, GValueArray *params)\n{\n\tvte_sequence_handler_multiple(terminal, params, vte_sequence_handler_up);\n}", "target": 0}
{"code": "static inline zend_long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tzend_long elements;\n\telements = parse_iv2((*p) + 2, p);\n\t(*p) += 2;\n\tif (ce->serialize == NULL) {\n\t\tobject_init_ex(rval, ce);\n\t} else {\n\t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name->val);\n\t\treturn 0;\n\t}\n\treturn elements;\n}", "target": 0}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  IndexPacket\n    *indexes;\n  PixelPacket\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  unsigned short\n    nibble;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "TEST(EqOp, MatchesReferencedArrayValue) {\n    BSONObj operand = BSON(\"a.0\" << 5);\n    EqualityMatchExpression eq(\"a.0\", operand[\"a.0\"]);\n    ASSERT(eq.matchesBSON(BSON(\"a\" << BSON_ARRAY(5)), NULL));\n    ASSERT(!eq.matchesBSON(BSON(\"a\" << BSON_ARRAY(BSON_ARRAY(5))), NULL));\n}", "target": 0}
{"code": "static void drop_user_return_notifiers(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\tif (smsr->registered)\n\t\tkvm_on_user_return(&smsr->urn);\n}", "target": 0}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "void PDFiumEngine::OnSingleClick(int page_index, int char_index) {\n  SetSelecting(true);\n  selection_.push_back(PDFiumRange(pages_[page_index], char_index, 0));\n}", "target": 0}
{"code": "date_s_xmlschema(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    if (!NIL_P(opt)) argc--;\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        if (!NIL_P(opt)) argv2[argc2++] = opt;\n\tVALUE hash = date_s__xmlschema(argc2, argv2, klass);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "status_t BnSoundTriggerHwService::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n         case LIST_MODULES: {\n             CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n             unsigned int numModulesReq = data.readInt32();\n             unsigned int numModules = numModulesReq;\n             struct sound_trigger_module_descriptor *modules =\n                     (struct sound_trigger_module_descriptor *)calloc(numModulesReq,\n                                                    sizeof(struct sound_trigger_module_descriptor));\n             status_t status = listModules(modules, &numModules);\n             reply->writeInt32(status);\n             reply->writeInt32(numModules);\n            ALOGV(\"LIST_MODULES status %d got numModules %d\", status, numModules);\n if (status == NO_ERROR) {\n if (numModulesReq > numModules) {\n                    numModulesReq = numModules;\n }\n                reply->write(modules,\n                             numModulesReq * sizeof(struct sound_trigger_module_descriptor));\n }\n            free(modules);\n return NO_ERROR;\n }\n case ATTACH: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n sound_trigger_module_handle_t handle;\n            data.read(&handle, sizeof(sound_trigger_module_handle_t));\n            sp<ISoundTriggerClient> client =\n                    interface_cast<ISoundTriggerClient>(data.readStrongBinder());\n            sp<ISoundTrigger> module;\n status_t status = attach(handle, client, module);\n            reply->writeInt32(status);\n if (module != 0) {\n                reply->writeInt32(1);\n                reply->writeStrongBinder(IInterface::asBinder(module));\n } else {\n                reply->writeInt32(0);\n }\n return NO_ERROR;\n } break;\n case SET_CAPTURE_STATE: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n            reply->writeInt32(setCaptureState((bool)data.readInt32()));\n return NO_ERROR;\n } break;\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}", "target": 1}
{"code": "void btrfs_assign_next_active_device(struct btrfs_device *device,\n\t\t\t\t     struct btrfs_device *this_dev)\n{\n\tstruct btrfs_fs_info *fs_info = device->fs_info;\n\tstruct btrfs_device *next_device;\n\tif (this_dev)\n\t\tnext_device = this_dev;\n\telse\n\t\tnext_device = btrfs_find_next_active_device(fs_info->fs_devices,\n\t\t\t\t\t\t\t\tdevice);\n\tASSERT(next_device);\n\tif (fs_info->sb->s_bdev &&\n\t\t\t(fs_info->sb->s_bdev == device->bdev))\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (fs_info->fs_devices->latest_bdev == device->bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n}", "target": 0}
{"code": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n        if (rom->romsize > rom->datasize) {\n            d += l;\n            l = rom->romsize - rom->datasize;\n            if ((d + l) > (dest + size)) {\n                l = dest - d;\n            }\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n    return (d + l) - dest;\n}", "target": 1}
{"code": "  AudioContextTest() :\n      platform_(new ScopedTestingPlatformSupport<AudioContextTestPlatform>) {}", "target": 0}
{"code": "decode_labeled_prefix6(netdissect_options *ndo,\n                       const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen, plenbytes;\n\tND_TCHECK2(pptr[0], 4);\n\tITEMCHECK(4);\n\tplen = pptr[0]; \n\tif (24 > plen)\n\t\treturn -1;\n        plen-=24; \n\tif (128 < plen)\n\t\treturn -1;\n\titemlen -= 4;\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[4], plenbytes);\n\tmemcpy(&addr, &pptr[4], plenbytes);\n\tif (plen % 8) {\n\t\taddr.s6_addr[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d, label:%u %s\",\n                 ip6addr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 4 + plenbytes;\ntrunc:\n\treturn -2;\nbadtlv:\n\treturn -3;\n}", "target": 0}
{"code": "static inline void skb_dst_set_noref_force(struct sk_buff *skb,\n\t\t\t\t\t   struct dst_entry *dst)\n{\n\t__skb_dst_set_noref(skb, dst, true);\n}", "target": 0}
{"code": "static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); \n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); \n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "unsigned FAST_FUNC udhcp_option_idx(const char *name)\n{\n\tint n = index_in_strings(dhcp_option_strings, name);\n\tif (n >= 0)\n\t\treturn n;\n\t{\n\t\tchar buf[sizeof(dhcp_option_strings)];\n\t\tchar *d = buf;\n\t\tconst char *s = dhcp_option_strings;\n\t\twhile (s < dhcp_option_strings + sizeof(dhcp_option_strings) - 2) {\n\t\t\t*d++ = (*s == '\\0' ? ' ' : *s);\n\t\t\ts++;\n\t\t}\n\t\t*d = '\\0';\n\t\tbb_error_msg_and_die(\"unknown option '%s', known options: %s\", name, buf);\n\t}\n}", "target": 0}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n \tif (skb->ip_summed != CHECKSUM_COMPLETE)\n \t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n \tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n }", "target": 1}
{"code": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\nerr:\n\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "htc_request_check_host_hdr(struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "    void ExifThumb::setJpegThumbnail(\n        const std::string& path,\n              URational    xres,\n              URational    yres,\n              uint16_t     unit\n    )\n    {\n        DataBuf thumb = readFile(path); \n        setJpegThumbnail(thumb.pData_, thumb.size_, xres, yres, unit);\n    }", "target": 0}
{"code": " static int digi_startup(struct usb_serial *serial)\n {\n \tstruct digi_serial *serial_priv;\n \tint ret;\n \tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n \tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 1}
{"code": "device_linux_md_stop_authorized_cb (Daemon *daemon,\n                                    Device *device,\n                                    DBusGMethodInvocation *context,\n                                    const gchar *action_id,\n                                    guint num_user_data,\n                                    gpointer *user_data_elements)\n{\n  int n;\n  char *argv[10];\n  GError *error;\n  n = 0;\n  argv[n++] = \"mdadm\";\n  argv[n++] = \"--stop\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = NULL;\n  error = NULL;\n  if (!job_new (context, \"LinuxMdStop\", TRUE, device, argv, NULL, linux_md_stop_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "DLLIMPORT cfg_bool_t cfg_getbool(cfg_t *cfg, const char *name)\n{\n\treturn cfg_getnbool(cfg, name, 0);\n}", "target": 0}
{"code": "AcpiPsCompleteFinalOp (\n    ACPI_WALK_STATE         *WalkState,\n     ACPI_PARSE_OBJECT       *Op,\n     ACPI_STATUS             Status)\n {\n    ACPI_STATUS             Status2;\n     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);\n    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, \"AML package complete at Op %p\\n\", Op));\n    do\n     {\n         if (Op)\n         {\n            if (WalkState->AscendingCallback != NULL)\n             {\n                 WalkState->Op = Op;\n                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);\n                WalkState->Opcode = Op->Common.AmlOpcode;\n                Status = WalkState->AscendingCallback (WalkState);\n                Status = AcpiPsNextParseState (WalkState, Op, Status);\n                if (Status == AE_CTRL_PENDING)\n                {\n                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);\n                    if (ACPI_FAILURE (Status))\n                    {\n                        return_ACPI_STATUS (Status);\n                    }\n                }\n                 if (Status == AE_CTRL_TERMINATE)\n                 {\n                    Status = AE_OK;\n                    do\n                    {\n                        if (Op)\n                        {\n                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);\n                            if (ACPI_FAILURE (Status2))\n                            {\n                                return_ACPI_STATUS (Status2);\n                            }\n                        }\n                        AcpiPsPopScope (&(WalkState->ParserState), &Op,\n                            &WalkState->ArgTypes, &WalkState->ArgCount);\n                    } while (Op);\n                    return_ACPI_STATUS (Status);\n                 }\n                 else if (ACPI_FAILURE (Status))\n                 {\n                    (void) AcpiPsCompleteThisOp (WalkState, Op);\n                    return_ACPI_STATUS (Status);\n                 }\n             }\n            Status2 = AcpiPsCompleteThisOp (WalkState, Op);\n            if (ACPI_FAILURE (Status2))\n             {\n                return_ACPI_STATUS (Status2);\n             }\n         }\n        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,\n            &WalkState->ArgCount);\n     } while (Op);\n    return_ACPI_STATUS (Status);\n }", "target": 1}
{"code": "const char* ewk_view_setting_encoding_default_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, 0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, 0);\n    return priv->settings.encodingDefault;\n}", "target": 0}
{"code": "ParseNameValue(const char * buffer, int bufsize,\n                struct NameValueParserData * data)\n {\n \tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n \tparser.xmlstart = buffer;\n \tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}", "target": 1}
{"code": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline void perf_get_data_addr(struct pt_regs *regs, u64 *addrp) { }", "target": 0}
{"code": "status_t Parcel::readUint32(uint32_t *pArg) const\n{\n return readAligned(pArg);\n}", "target": 0}
{"code": "void PDFiumEngine::InvalidateAllPages() {\n  CancelPaints();\n  StopFind();\n  LoadPageInfo(true);\n  client_->Invalidate(pp::Rect(plugin_size_));\n}", "target": 0}
{"code": "int BN_is_odd(const BIGNUM *a)\n{\n    return (a->top > 0) && (a->d[0] & 1);\n}", "target": 0}
{"code": "static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\twhile (begin && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\tif (!str[*begin]) {                \n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t} else if (isalpha ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t} else if (isdigit ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     \n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             \n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}", "target": 1}
{"code": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\tsk_setup_caps(newsk, dst);\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\treturn newsk;\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1}
{"code": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\tif (entry->fields.mask)\n\t\treturn -1;\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr &= ~(1 << irq);\n\tif (irq == RTC_GSI && line_status) {\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\tioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = ret;\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\treturn ret;\n}", "target": 1}
{"code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}", "target": 1}
{"code": "R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\tRRBNode head; \n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; \n\tRRBNode *p = NULL, *q = tree->root; \n\tint dir = 0, last = 0; \n\t_set_link (parent, q, 1);\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\ttree->root = head.link[1];\nout_exit:\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\treturn inserted;\n}", "target": 1}
{"code": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\thash_len = digest_length(d);\n\t}\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\tpasswd2_sum = passwd1_sum + hash_len;\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\tif (ret < 0)\n\t\tgoto err;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, key, keylen) == 0)\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)\n\t\t\tret = 1;\n\t}\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\treturn ret;\n}", "target": 1}
{"code": "append_wild(char *to, char *end, const char *wild)\n{\n  end-=5;\t\t\t\t\t\n  if (wild && wild[0])\n  {\n    to=strmov(to,\" like '\");\n    while (*wild && to < end)\n    {\n      if (*wild == '\\\\' || *wild == '\\'')\n\t*to++='\\\\';\n      *to++= *wild++;\n    }\n    if (*wild)\t\t\t\t\t\n      *to++='%';\t\t\t\t\n    to[0]='\\'';\n    to[1]=0;\n  }\n}", "target": 0}
{"code": "static inline s16 fixp_new16(s16 a)\n{\n\treturn ((s32)a) >> (16 - FRAC_N);\n}", "target": 0}
{"code": "int h1_parse_cont_len_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n;\n\tlong long cl;\n\tint not_first = !!(h1m->flags & H1_MF_CLEN);\n\tstruct ist word;\n\tword.ptr = value->ptr - 1; \n\te = value->ptr + value->len;\n\twhile (++word.ptr < e) {\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\tif (unlikely(n == word.ptr)) \n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl + c;\n\t\t}\n\t\tword.len = n - word.ptr;\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (h1m->flags & H1_MF_CLEN && cl != h1m->body_len)\n\t\t\tgoto fail;\n\t\th1m->flags |= H1_MF_CLEN;\n\t\th1m->curr_len = h1m->body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t}\n\treturn !not_first;\n fail:\n\treturn -1;\n}", "target": 1}
{"code": "mysql_create_db(MYSQL *mysql, const char *db)\n{\n  DBUG_ENTER(\"mysql_createdb\");\n  DBUG_PRINT(\"enter\",(\"db: %s\",db));\n  DBUG_RETURN(simple_command(mysql,COM_CREATE_DB,db, (ulong) strlen(db),0));\n}", "target": 0}
{"code": "  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = buf_.data();\n    *lenReturn = buf_.size();\n  }", "target": 0}
{"code": "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n        if (fd < 0)\n                return -EBADF;\n        if (!filename_is_valid(name))\n                return -EINVAL;\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) \n                return -EINVAL;\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}", "target": 1}
{"code": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "static int zipfileComparePath(const char *zA, const char *zB, int nB){\n  int nA = (int)strlen(zA);\n  if( zA[nA-1]=='/' ) nA--;\n  if( zB[nB-1]=='/' ) nB--;\n  if( nA==nB && memcmp(zA, zB, nA)==0 ) return 0;\n  return 1;\n}", "target": 0}
{"code": "void vrend_renderer_context_create_internal(uint32_t handle, uint32_t nlen,\n                                            const char *debug_name)\n{\n   struct vrend_decode_ctx *dctx;\n   if (handle >= VREND_MAX_CTX)\n      return;\n   dctx = malloc(sizeof(struct vrend_decode_ctx));\n   if (!dctx)\n      return;\n   dctx->grctx = vrend_create_context(handle, nlen, debug_name);\n   if (!dctx->grctx) {\n      free(dctx);\n      return;\n   }\n   dctx->ds = &dctx->ids;\n   dec_ctx[handle] = dctx;\n}", "target": 1}
{"code": "atm_if_print(netdissect_options *ndo,\n             const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tuint32_t llchdr;\n\tu_int hdrlen = 0;\n\tif (caplen < 1 || length < 1) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n        if (*p == LLC_UI) {\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"CNLPID \"));\n            isoclns_print(ndo, p + 1, length - 1, caplen - 1);\n            return hdrlen;\n        }\n\tif (caplen < 3 || length < 3) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n\tllchdr = EXTRACT_24BITS(p);\n\tif (llchdr != LLC_UI_HDR(LLCSAP_SNAP) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_ISONS) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_IP)) {\n\t\tif (caplen < 20 || length < 20) {\n\t\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\t\treturn (caplen);\n\t\t}\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%08x%08x %08x%08x \",\n\t\t\t       EXTRACT_32BITS(p),\n\t\t\t       EXTRACT_32BITS(p+4),\n\t\t\t       EXTRACT_32BITS(p+8),\n\t\t\t       EXTRACT_32BITS(p+12)));\n\t\tp += 20;\n\t\tlength -= 20;\n\t\tcaplen -= 20;\n\t\thdrlen += 20;\n\t}\n\thdrlen += atm_llc_print(ndo, p, length, caplen);\n\treturn (hdrlen);\n}", "target": 1}
{"code": "archive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\tint n, ret_val = 0;\n\tchar *p;\n\tchar *end;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile (*w != L'\\0' && len > 0) {\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tas->s[as->length] = '\\0';\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n#if HAVE_WCRTOMB\n\t\tn = wcrtomb(p, *w++, &shift_state);\n#else\n\t\tn = wctomb(p, *w++);\n#endif\n\t\tif (n == -1) {\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t*p++ = '?';\n\t\t\t\tret_val = -1;\n\t\t\t} else {\n\t\t\t\tret_val = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tp += n;\n\t\tlen--;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n \tif (current->flags & PF_RANDOMIZE)\n \t\trandom_factor = arch_mmap_rnd();\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n \tif (mmap_is_legacy()) {\n \t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}", "target": 1}
{"code": "static void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\tvmx->ple_window = __grow_ple_window(old);\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\ttrace_kvm_ple_window_grow(vcpu->vcpu_id, vmx->ple_window, old);\n}", "target": 0}
{"code": "int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b)\n{\n    int result = -1;\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n     case V_ASN1_OBJECT:\n         result = OBJ_cmp(a->value.object, b->value.object);\n         break;\n     case V_ASN1_NULL:\n         result = 0;             \n         break;\n    case V_ASN1_NEG_ENUMERATED:\n    case V_ASN1_BIT_STRING:\n    case V_ASN1_OCTET_STRING:\n    case V_ASN1_SEQUENCE:\n    case V_ASN1_SET:\n    case V_ASN1_NUMERICSTRING:\n    case V_ASN1_PRINTABLESTRING:\n    case V_ASN1_T61STRING:\n    case V_ASN1_VIDEOTEXSTRING:\n    case V_ASN1_IA5STRING:\n    case V_ASN1_UTCTIME:\n    case V_ASN1_GENERALIZEDTIME:\n    case V_ASN1_GRAPHICSTRING:\n    case V_ASN1_VISIBLESTRING:\n    case V_ASN1_GENERALSTRING:\n    case V_ASN1_UNIVERSALSTRING:\n    case V_ASN1_BMPSTRING:\n    case V_ASN1_UTF8STRING:\n    case V_ASN1_OTHER:\n    default:\n        result = ASN1_STRING_cmp((ASN1_STRING *)a->value.ptr,\n                                 (ASN1_STRING *)b->value.ptr);\n        break;\n    }\n    return result;\n}", "target": 1}
{"code": "inline int nci_request(struct nci_dev *ndev,\n\t\t       void (*req)(struct nci_dev *ndev,\n\t\t\t\t   const void *opt),\n\t\t       const void *opt, __u32 timeout)\n{\n\tint rc;\n\tif (!test_bit(NCI_UP, &ndev->flags))\n\t\treturn -ENETDOWN;\n\tmutex_lock(&ndev->req_lock);\n\trc = __nci_request(ndev, req, opt, timeout);\n\tmutex_unlock(&ndev->req_lock);\n\treturn rc;\n}", "target": 1}
{"code": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n}", "target": 1}
{"code": "    int RafImage::pixelWidth() const\n    {\n        Exiv2::ExifData::const_iterator widthIter = exifData_.findKey(Exiv2::ExifKey(\"Exif.Photo.PixelXDimension\"));\n        if (widthIter != exifData_.end() && widthIter->count() > 0) {\n            return widthIter->toLong();\n        }\n        return 0;\n    }", "target": 0}
{"code": "  bool IsBelowFrame(JavaScriptFrame* frame) {\n    return (c_entry_fp_ == 0) || (c_entry_fp_ > frame->sp());\n  }", "target": 0}
{"code": "int InlineTextBox::selectionHeight()\n{\n    return root()->selectionHeight();\n}", "target": 0}
{"code": "static void kiss_unesc(struct mkiss *ax, unsigned char s)\n{\n\tswitch (s) {\n\tcase END:\n\t\tif (test_bit(AXF_KEEPTEST, &ax->flags))\n\t\t\tclear_bit(AXF_KEEPTEST, &ax->flags);\n\t\tif (!test_and_clear_bit(AXF_ERROR, &ax->flags) && (ax->rcount > 2))\n\t\t\tax_bump(ax);\n\t\tclear_bit(AXF_ESCAPE, &ax->flags);\n\t\tax->rcount = 0;\n\t\treturn;\n\tcase ESC:\n\t\tset_bit(AXF_ESCAPE, &ax->flags);\n\t\treturn;\n\tcase ESC_ESC:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = ESC;\n\t\tbreak;\n\tcase ESC_END:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = END;\n\t\tbreak;\n\t}\n\tspin_lock_bh(&ax->buflock);\n\tif (!test_bit(AXF_ERROR, &ax->flags)) {\n\t\tif (ax->rcount < ax->buffsize) {\n\t\t\tax->rbuff[ax->rcount++] = s;\n\t\t\tspin_unlock_bh(&ax->buflock);\n\t\t\treturn;\n\t\t}\n\t\tax->dev->stats.rx_over_errors++;\n\t\tset_bit(AXF_ERROR, &ax->flags);\n\t}\n\tspin_unlock_bh(&ax->buflock);\n}", "target": 0}
{"code": "parse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t\t    \"Missing number\");\n \t\t\t\treturn ARCHIVE_WARN;\n \t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t\tif (argc > MAX_PACK_ARGS) {\n \t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t\t    \"Too many arguments\");\n \t\t\t\treturn ARCHIVE_WARN;\n \t\t\t}\n \t\t}\n \t\tif (argc < 2) {\n \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}", "target": 1}
{"code": "static int dwc3_pci_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct property_entry *p = (struct property_entry *)id->driver_data;\n\tstruct dwc3_pci\t\t*dwc;\n\tstruct resource\t\tres[2];\n\tint\t\t\tret;\n\tstruct device\t\t*dev = &pci->dev;\n\tret = pcim_enable_device(pci);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable pci device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpci_set_master(pci);\n\tdwc = devm_kzalloc(dev, sizeof(*dwc), GFP_KERNEL);\n\tif (!dwc)\n\t\treturn -ENOMEM;\n\tdwc->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!dwc->dwc3)\n\t\treturn -ENOMEM;\n\tmemset(res, 0x00, sizeof(struct resource) * ARRAY_SIZE(res));\n\tres[0].start\t= pci_resource_start(pci, 0);\n\tres[0].end\t= pci_resource_end(pci, 0);\n\tres[0].name\t= \"dwc_usb3\";\n\tres[0].flags\t= IORESOURCE_MEM;\n\tres[1].start\t= pci->irq;\n\tres[1].name\t= \"dwc_usb3\";\n\tres[1].flags\t= IORESOURCE_IRQ;\n\tret = platform_device_add_resources(dwc->dwc3, res, ARRAY_SIZE(res));\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't add resources to dwc3 device\\n\");\n\t\tgoto err;\n\t}\n\tdwc->pci = pci;\n\tdwc->dwc3->dev.parent = dev;\n\tACPI_COMPANION_SET(&dwc->dwc3->dev, ACPI_COMPANION(dev));\n\tret = platform_device_add_properties(dwc->dwc3, p);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = dwc3_pci_quirks(dwc);\n\tif (ret)\n\t\tgoto err;\n\tret = platform_device_add(dwc->dwc3);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register dwc3 device\\n\");\n\t\tgoto err;\n\t}\n\tdevice_init_wakeup(dev, true);\n\tpci_set_drvdata(pci, dwc);\n\tpm_runtime_put(dev);\n#ifdef CONFIG_PM\n\tINIT_WORK(&dwc->wakeup_work, dwc3_pci_resume_work);\n#endif\n\treturn 0;\nerr:\n\tplatform_device_put(dwc->dwc3);\n\treturn ret;\n}", "target": 1}
{"code": "static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen,\n\t\t\t\t       size_t *_dp, size_t *_len,\n\t\t\t\t       const char **_errmsg)\n{\n\tunsigned char tag, tmp;\n\tsize_t dp = *_dp, len, n;\n\tint indef_level = 1;\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n \ttag = data[dp++];\n\tif (tag == 0) {\n \t\tif (data[dp++] != 0)\n \t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n \tlen = data[dp++];\n\tif (len <= 0x7f) {\n\t\tdp += len;\n\t\tgoto next_tag;\n\t}\n \tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n \t}\n \tn = len - 0x80;\n\tif (unlikely(n > sizeof(size_t) - 1))\n \t\tgoto length_too_long;\n \tif (unlikely(n > datalen - dp))\n \t\tgoto data_overrun_error;\n\tfor (len = 0; n > 0; n--) {\n \t\tlen <<= 8;\n \t\tlen |= data[dp++];\n \t}\n \tdp += len;\n \tgoto next_tag;\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:\n\t*_errmsg = \"Invalid length EOC\";\n\tgoto error;\ndata_overrun_error:\n\t*_errmsg = \"Data overrun error\";\n\tgoto error;\nmissing_eoc:\n\t*_errmsg = \"Missing EOC in indefinite len cons\";\nerror:\n\t*_dp = dp;\n\treturn -1;\n}", "target": 1}
{"code": "bool WebGraphicsContext3DDefaultImpl::makeContextCurrent()\n{\n    return m_glContext->MakeCurrent();\n}", "target": 0}
{"code": "static void HuffmanTree_cleanup(HuffmanTree* tree)\n{\n  free(tree->tree2d);\n  free(tree->tree1d);\n  free(tree->lengths);\n}", "target": 0}
{"code": "void PasswordAutofillAgent::ProvisionallySavePassword(\n    std::unique_ptr<PasswordForm> password_form,\n    ProvisionallySaveRestriction restriction) {\n  if (!password_form || (restriction == RESTRICTION_NON_EMPTY_PASSWORD &&\n                         password_form->password_value.empty() &&\n                         password_form->new_password_value.empty())) {\n    return;\n  }\n  provisionally_saved_form_ = std::move(password_form);\n}", "target": 0}
{"code": "static inline void ok_inflater_write_byte(ok_inflater *inflater, const uint8_t b) {\n    inflater->buffer[inflater->buffer_end_pos & BUFFER_SIZE_MASK] = b;\n    inflater->buffer_end_pos++;\n}", "target": 0}
{"code": "SPL_METHOD(Array, offsetExists)\n{\n\tzval *index;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &index) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_BOOL(spl_array_has_dimension_ex(0, getThis(), index, 2 TSRMLS_CC));\n} ", "target": 0}
{"code": "HMAC_SHA256_Init(struct HMAC_SHA256_CTX * ctx, const void * _K, size_t Klen)\n{\n  unsigned char pad[64];\n  unsigned char khash[32];\n  const unsigned char * K = (unsigned char *) _K;\n  size_t i;\n  if (Klen > 64) {\n    SHA256_Init(&ctx->ictx);\n    scrypt_SHA256_Update(&ctx->ictx, K, Klen);\n    scrypt_SHA256_Final(khash, &ctx->ictx);\n    K = khash;\n    Klen = 32;\n  }\n  SHA256_Init(&ctx->ictx);\n  memset(pad, 0x36, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  scrypt_SHA256_Update(&ctx->ictx, pad, 64);\n  SHA256_Init(&ctx->octx);\n  memset(pad, 0x5c, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  scrypt_SHA256_Update(&ctx->octx, pad, 64);\n  memset(khash, 0, 32);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, ContainedOrMultikeyCannotCompoundFields) {\n    const bool multikey = true;\n    addIndex(BSON(\"a.c\" << 1 << \"a.b\" << 1), multikey);\n    addIndex(BSON(\"d\" << 1));\n    runQuery(fromjson(\"{$and: [{'a.b': 5}, {$or: [{'a.c': 6}, {d: 7}]}]}\"));\n    assertNumSolutions(2);\n    assertSolutionExists(\n        \"{fetch: {filter: {'a.b': 5}, node: {or: {nodes: [\"\n        \"{ixscan: {pattern: {'a.c': 1, 'a.b': 1}, bounds: {'a.c': [[6, 6, true, true]], 'a.b': \"\n        \"[['MinKey', 'MaxKey', true, true]]}}},\"\n        \"{ixscan: {pattern: {d: 1}, bounds: {d: [[7, 7, true, true]]}}}\"\n        \"]}}}}\");\n    assertSolutionExists(\"{cscan: {dir: 1}}}}\");\n}", "target": 0}
{"code": "static int _FVMenuClose(FontView *fv) {\n    int i;\n    SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;\n    if ( !SFCloseAllInstrs(fv->b.sf) )\nreturn( false );\n    if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {\n    } else if ( warn_script_unsaved && fv->script_unsaved && \n                AskScriptChanged()==2 ) {\n        return false;\n    } else if ( SFAnyChanged(sf) ) {\n\ti = AskChanged(fv->b.sf);\n\tif ( i==2 )\t\nreturn( false );\n\tif ( i==0 && !_FVMenuSave(fv))\t\t\nreturn(false);\n\telse\n\t    SFClearAutoSave(sf);\t\t\n    }\n    _FVCloseWindows(fv);\n    if ( sf->filename!=NULL )\n\tRecentFilesRemember(sf->filename);\n    else if ( sf->origname!=NULL )\n\tRecentFilesRemember(sf->origname);\n    GDrawDestroyWindow(fv->gw);\nreturn( true );\n}", "target": 0}
{"code": "md_uuid_free(void *x)\n{\n  md_uuid *a = x;\n  free(a->path);\n  free(a);\n}", "target": 0}
{"code": "void kvm_get_pfn(pfn_t pfn)\n{\n\tif (!kvm_is_mmio_pfn(pfn))\n\t\tget_page(pfn_to_page(pfn));\n}", "target": 0}
{"code": "Bool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return GF_FALSE;\n\treturn GF_TRUE;\n}", "target": 0}
{"code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "void dev_init_scheduler(struct net_device *dev)\n{\n\tqdisc_lock_tree(dev);\n\tdev->qdisc = &noop_qdisc;\n\tdev->qdisc_sleeping = &noop_qdisc;\n\tINIT_LIST_HEAD(&dev->qdisc_list);\n\tqdisc_unlock_tree(dev);\n\tsetup_timer(&dev->watchdog_timer, dev_watchdog, (unsigned long)dev);\n}", "target": 0}
{"code": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "void DelegatedFrameHost::OnUpdateVSyncParameters(base::TimeTicks timebase,\n                                                 base::TimeDelta interval) {\n  vsync_timebase_ = timebase;\n  vsync_interval_ = interval;\n}", "target": 0}
{"code": "static inline int check_user_page_hwpoison(unsigned long addr)\n{\n\tint rc, flags = FOLL_TOUCH | FOLL_HWPOISON | FOLL_WRITE;\n\trc = __get_user_pages(current, current->mm, addr, 1,\n\t\t\t      flags, NULL, NULL, NULL);\n\treturn rc == -EHWPOISON;\n}", "target": 0}
{"code": "void OmniboxViewWin::OnSysChar(TCHAR ch,\n                               UINT repeat_count,\n                               UINT flags) {\n  if (ch == VK_SPACE)\n    SetMsgHandled(false);\n}", "target": 0}
{"code": "static const char *set_qualify_redirect_url(cmd_parms *cmd, void *d_, int flag)\n{\n    core_dir_config *d = d_;\n    d->qualify_redirect_url = flag ? AP_CORE_CONFIG_ON : AP_CORE_CONFIG_OFF;\n    return NULL;\n}", "target": 0}
{"code": "bool L2NormalizeReduceAxis(Value sq_op, DenseElementsAttr axis) {\n  if (sq_op.getType().cast<ShapedType>().getRank() - 1 ==\n          *axis.getValues<int>().begin() ||\n      *axis.getValues<int>().begin() == -1) {\n    return true;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() != axis.getNumElements()) {\n    return false;\n  }\n  auto shape = sq_op.getType().cast<ShapedType>();\n  SmallVector<int, 4> elems{axis.getValues<int>().begin(),\n                            axis.getValues<int>().end()};\n  for (int i = 0; i < shape.getRank(); ++i) {\n    if (i != elems[i]) return false;\n  }\n  return true;\n}", "target": 1}
{"code": "R_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {\n\tif (!s) {\n\t\treturn -1;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\tif (s->bio) {\n\t\t\treturn BIO_read (s->bio, buf, len);\n\t\t}\n\t\treturn SSL_read (s->sfd, buf, len);\n\t}\n#endif\n#if __WINDOWS__\nrep:\n\t{\n\tint ret = recv (s->fd, (void *)buf, len, 0);\n\tif (ret == -1) {\n\t\tgoto rep;\n\t}\n\treturn ret;\n\t}\n#else\n\tint r = recv (s->fd, buf, len, 0);\n\tD { eprintf (\"READ \"); int i; for (i = 0; i<len; i++) { eprintf (\"%02x \", buf[i]); } eprintf (\"\\n\"); }\n\treturn r;\n#endif\n}", "target": 1}
{"code": "static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->mount,\n\t\t       ttydir);\n\tif (ret >= sizeof(path))\n\t\treturn -1;\n\tret = mkdir(path, 0755);\n\tif (ret && errno != EEXIST) {\n\t\tSYSERROR(\"failed with errno %d to create %s\", errno, path);\n\t\treturn -1;\n\t}\n\tINFO(\"created %s\", path);\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/dev/%s/console\",\n\t\t       rootfs->mount, ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tsnprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tret = unlink(path);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", path);\n\t\treturn -1;\n\t}\n\tret = creat(lxcpath, 0660);\n\tif (ret==-1 && errno != EEXIST) {\n\t\tSYSERROR(\"error %d creating %s\", errno, lxcpath);\n\t\treturn -1;\n\t}\n\tif (ret >= 0)\n\t\tclose(ret);\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n\t\treturn -1;\n\t}\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/console\", ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"lxc/console path too long\");\n\t\treturn -1;\n\t}\n\tret = symlink(lxcpath, path);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for console\");\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup on %s\", lxcpath);\n\treturn 0;\n}", "target": 1}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": "cib_connect(gboolean full)\n{\n    int rc = pcmk_ok;\n    static gboolean need_pass = TRUE;\n    CRM_CHECK(cib != NULL, return -EINVAL);\n    if (getenv(\"CIB_passwd\") != NULL) {\n        need_pass = FALSE;\n    }\n    if(watch_fencing && st == NULL) {\n        st = stonith_api_new();\n    }\n    if(watch_fencing && st->state == stonith_disconnected) {\n        crm_trace(\"Connecting to stonith\");\n        rc = st->cmds->connect(st, crm_system_name, NULL);\n        if(rc == pcmk_ok) {\n            crm_trace(\"Setting up stonith callbacks\");\n            st->cmds->register_notification(st, T_STONITH_NOTIFY_FENCE, mon_st_callback);\n        }\n    }\n    if (cib->state != cib_connected_query && cib->state != cib_connected_command) {\n        crm_trace(\"Connecting to the CIB\");\n        if (as_console && need_pass && cib->variant == cib_remote) {\n            need_pass = FALSE;\n            print_as(\"Password:\");\n        }\n        rc = cib->cmds->signon(cib, crm_system_name, cib_query);\n        if (rc != pcmk_ok) {\n            return rc;\n        }\n        current_cib = get_cib_copy(cib);\n        mon_refresh_display(NULL);\n        if (full) {\n            if (rc == pcmk_ok) {\n                rc = cib->cmds->set_connection_dnotify(cib, mon_cib_connection_destroy);\n                if (rc == -EPROTONOSUPPORT) {\n                    print_as(\"Notification setup failed, won't be able to reconnect after failure\");\n                    if (as_console) {\n                        sleep(2);\n                    }\n                    rc = pcmk_ok;\n                }\n            }\n            if (rc == pcmk_ok) {\n                cib->cmds->del_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n                rc = cib->cmds->add_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n            }\n            if (rc != pcmk_ok) {\n                print_as(\"Notification setup failed, could not monitor CIB actions\");\n                if (as_console) {\n                    sleep(2);\n                }\n                clean_up(-rc);\n            }\n        }\n    }\n    return rc;\n}", "target": 1}
{"code": "TEST(Context, EmptyHeadersAttributes) {\n  Protobuf::Arena arena;\n  HeadersWrapper<Http::RequestHeaderMap> headers(arena, nullptr);\n  auto header = headers[CelValue::CreateStringView(Referer)];\n  EXPECT_FALSE(header.has_value());\n  EXPECT_EQ(0, headers.size());\n  EXPECT_TRUE(headers.empty());\n}", "target": 0}
{"code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tret = 0;\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret <= 0 ? ret : -EIO;\n}", "target": 1}
{"code": "void PDFiumEngine::Form_Invalidate(FPDF_FORMFILLINFO* param,\n                                   FPDF_PAGE page,\n                                   double left,\n                                   double top,\n                                   double right,\n                                   double bottom) {\n  PDFiumEngine* engine = static_cast<PDFiumEngine*>(param);\n  int page_index = engine->GetVisiblePageIndex(page);\n  if (page_index == -1) {\n    return;\n  }\n  pp::Rect rect = engine->pages_[page_index]->PageToScreen(\n      engine->GetVisibleRect().point(), engine->current_zoom_, left, top, right,\n      bottom, engine->current_rotation_);\n  engine->client_->Invalidate(rect);\n}", "target": 0}
{"code": "Status CreateTempFile(Env* env, float value, uint64 size, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 1}
{"code": "void kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}", "target": 0}
{"code": "zgetdevice(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    const gx_device *dev;\n    check_type(*op, t_integer);\n    if (op->value.intval != (int)(op->value.intval))\n        return_error(gs_error_rangecheck);\t\n    dev = gs_getdevice((int)(op->value.intval));\n    if (dev == 0)\t\t\n        return_error(gs_error_rangecheck);\n    make_tav(op, t_device, avm_foreign | a_readonly, pdevice,\n             (gx_device *) dev);\n    return 0;\n}", "target": 0}
{"code": "void gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h, int pct)\n{\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\ttoy = dstY;\n\tfor (y = srcY; y < (srcY + h); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; x < (srcX + w); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel(src, x, y);\n\t\t\tif (gdImageGetTransparent(src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dst == src) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel(dst, tox, toy);\n \t\t\t\tncR = (int)(gdImageRed (src, c) * (pct / 100.0) + gdImageRed (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncG = (int)(gdImageGreen (src, c) * (pct / 100.0) + gdImageGreen (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncB = (int)(gdImageBlue (src, c) * (pct / 100.0) + gdImageBlue (dst, dc) * ((100 - pct) / 100.0));\n\t\t\t\tnc = gdImageColorResolve (dst, ncR, ncG, ncB);\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}", "target": 1}
{"code": "tegra_xusb_find_port_node(struct tegra_xusb_padctl *padctl, const char *type,\n\t\t\t  unsigned int index)\n{\n\tstruct device_node *ports, *np;\n\tchar *name;\n\tports = of_get_child_by_name(padctl->dev->of_node, \"ports\");\n\tif (!ports)\n\t\treturn NULL;\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n\treturn np;\n}", "target": 1}
{"code": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n\t\t}\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}", "target": 1}
{"code": "optional<ARN> ARN::parse(const string& s, bool wildcards) {\n  static const char str_wild[] = \"arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)\";\n  static const regex rx_wild(str_wild,\n\t\t\t\t    sizeof(str_wild) - 1,\n\t\t\t\t    ECMAScript | optimize);\n  static const char str_no_wild[]\n    = \"arn:([^:*]*):([^:*]*):([^:*]*):([^:*]*):([^:*]*)\";\n  static const regex rx_no_wild(str_no_wild,\n\t\t\t\tsizeof(str_no_wild) - 1,\n\t\t\t\tECMAScript | optimize);\n  smatch match;\n  if ((s == \"*\") && wildcards) {\n    return ARN(Partition::wildcard, Service::wildcard, \"*\", \"*\", \"*\");\n  } else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) {\n    ceph_assert(match.size() == 6);\n    ARN a;\n    {\n      auto p = to_partition(match[1], wildcards);\n      if (!p)\n\treturn none;\n      a.partition = *p;\n    }\n    {\n      auto s = to_service(match[2], wildcards);\n      if (!s) {\n\treturn none;\n      }\n      a.service = *s;\n    }\n    a.region = match[3];\n    a.account = match[4];\n    a.resource = match[5];\n    return a;\n  }\n  return none;\n}", "target": 1}
{"code": "cdf_tole8(uint64_t sv)\n{\n\treturn CDF_TOLE8(sv);\n}", "target": 0}
{"code": " bool DebugOnStart::FindArgument(wchar_t* command_line, const char* argument_c) {\n  wchar_t argument[50];\n   for (int i = 0; argument_c[i]; ++i)\n     argument[i] = argument_c[i];\n  int argument_len = lstrlen(argument);\n  int command_line_len = lstrlen(command_line);\n  while (command_line_len > argument_len) {\n    wchar_t first_char = command_line[0];\n    wchar_t last_char = command_line[argument_len+1];\n    if ((first_char == L'-' || first_char == L'/') &&\n        (last_char == L' ' || last_char == 0 || last_char == L'=')) {\n      command_line[argument_len+1] = 0;\n      if (lstrcmpi(command_line+1, argument) == 0) {\n        command_line[argument_len+1] = last_char;\n        return true;\n      }\n      command_line[argument_len+1] = last_char;\n    }\n    ++command_line;\n    --command_line_len;\n  }\n  return false;\n}", "target": 1}
{"code": "ScopedRenderBufferBinder::~ScopedRenderBufferBinder() {\n  ScopedGLErrorSuppressor suppressor(decoder_);\n  glBindRenderbufferEXT(\n      GL_RENDERBUFFER,\n      decoder_->bound_renderbuffer_ ?\n          decoder_->bound_renderbuffer_->service_id() : 0);\n}", "target": 0}
{"code": "status_t MyOpusExtractor::readNextPacket(MediaBuffer **out) {\n if (mOffset <= mFirstDataOffset && mStartGranulePosition < 0) {\n MediaBuffer *mBuf;\n uint32_t numSamples = 0;\n uint64_t curGranulePosition = 0;\n while (true) {\n status_t err = _readNextPacket(&mBuf, false);\n if (err != OK && err != ERROR_END_OF_STREAM) {\n return err;\n             }\n             if (err == ERROR_END_OF_STREAM || mCurrentPage.mPageNo > 2) {\n                 break;\n             }\n             curGranulePosition = mCurrentPage.mGranulePosition;\n            numSamples += getNumSamplesInPacket(mBuf);\n            mBuf->release();\n            mBuf = NULL;\n }\n if (curGranulePosition > numSamples) {\n            mStartGranulePosition = curGranulePosition - numSamples;\n } else {\n            mStartGranulePosition = 0;\n }\n        seekToOffset(0);\n }\n status_t err = _readNextPacket(out, false);\n if (err != OK) {\n return err;\n }\n int32_t currentPageSamples;\n if ((*out)->meta_data()->findInt32(kKeyValidSamples, &currentPageSamples)) {\n if (mOffset == mFirstDataOffset) {\n            currentPageSamples -= mStartGranulePosition;\n (*out)->meta_data()->setInt32(kKeyValidSamples, currentPageSamples);\n }\n        mCurGranulePosition = mCurrentPage.mGranulePosition - currentPageSamples;\n }\n int64_t timeUs = getTimeUsOfGranule(mCurGranulePosition);\n (*out)->meta_data()->setInt64(kKeyTime, timeUs);\n uint32_t frames = getNumSamplesInPacket(*out);\n    mCurGranulePosition += frames;\n return OK;\n}", "target": 1}
{"code": " void add_param_to_argv(char *parsestart, int line)\n {\n\tint quote_open = 0, escaped = 0, param_len = 0;\n\tchar param_buffer[1024], *curchar;\n\t\t\tparam_buffer[param_len++] = *curchar;\n\t\t\tif (param_len >= sizeof(param_buffer))\n\t\t\t\txtables_error(PARAMETER_PROBLEM,\n \t\tcase ' ':\n \t\tcase '\\t':\n \t\tcase '\\n':\n\t\t\tif (!param_len) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tbreak;\n \t\tdefault:\n\t\t\tparam_buffer[param_len++] = *curchar;\n\t\t\tif (param_len >= sizeof(param_buffer))\n\t\t\t\txtables_error(PARAMETER_PROBLEM,\n\t\t\t\t\t      \"Parameter too long!\");\n \t\t\tcontinue;\n \t\t}\n\t\tparam_buffer[param_len] = '\\0';\n\t\tif ((param_buffer[0] == '-' &&\n\t\t     param_buffer[1] != '-' &&\n\t\t     strchr(param_buffer, 't')) ||\n\t\t    (!strncmp(param_buffer, \"--t\", 3) &&\n\t\t     !strncmp(param_buffer, \"--table\", strlen(param_buffer)))) {\n \t\t\txtables_error(PARAMETER_PROBLEM,\n \t\t\t\t      \"The -t option (seen in line %u) cannot be used in %s.\\n\",\n \t\t\t\t      line, xt_params->program_name);\n \t\t}\n\t\tadd_argv(param_buffer, 0);\n\t\tparam_len = 0;\n \t}", "target": 1}
{"code": "void RenderWidgetHostImpl::SetScreenOrientationForTesting(\n    uint16_t angle,\n    ScreenOrientationValues type) {\n  screen_orientation_angle_for_testing_ = angle;\n  screen_orientation_type_for_testing_ = type;\n  WasResized();\n}", "target": 0}
{"code": "static int hclge_tm_schd_mode_vnet_base_cfg(struct hclge_vport *vport)\n{\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\tu8 i;\n\tret = hclge_tm_pri_schd_mode_cfg(hdev, vport->vport_id);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < kinfo->num_tc; i++) {\n\t\tu8 sch_mode = hdev->tm_info.tc_info[i].tc_sch_mode;\n\t\tret = hclge_tm_qs_schd_mode_cfg(hdev, vport->qs_offset + i,\n\t\t\t\t\t\tsch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static PHP_GINIT_FUNCTION(date)\n{\n\tdate_globals->default_timezone = NULL;\n\tdate_globals->timezone = NULL;\n\tdate_globals->tzcache = NULL;\n\tdate_globals->timezone_valid = 0;", "target": 0}
{"code": "void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tif (nft_set_is_anonymous(set))\n\t\tnft_clear(ctx->net, set);\n\tset->use++;\n}", "target": 0}
{"code": "static inline int is_zero_pfn(unsigned long pfn)\n{\n\textern unsigned long zero_pfn;\n\treturn pfn == zero_pfn;\n}", "target": 0}
{"code": "static authz_status oidc_handle_unauthorized_user24(request_rec *r) {\n\toidc_debug(r, \"enter\");\n\toidc_cfg *c = ap_get_module_config(r->server->module_config, &auth_openidc_module);\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\t\t\t\t  OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_debug(r, \"setting environment variable %s to \\\"%s\\\" for usage in mod_headers\", OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\tapr_table_set(r->subprocess_env, OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\treturn AUTHZ_DENIED;\n\t}\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\t\tcase OIDC_UNAUTZ_RETURN403:\n\t\tcase OIDC_UNAUTZ_RETURN401:\n\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t}\n\toidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n\tconst char *location = oidc_util_hdr_out_location_get(r);\n\tif (location != NULL) {\n\t\toidc_debug(r, \"send HTML refresh with authorization redirect: %s\", location);\n\t\tchar *html_head =\n\t\t\t\tapr_psprintf(r->pool, \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=%s\\\">\", location);\n\t\toidc_util_html_send(r, \"Stepup Authentication\", html_head, NULL, NULL,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t\tr->header_only = 1;\n\t}\n\treturn AUTHZ_DENIED;\n}", "target": 0}
{"code": "vba_read_project_strings(int fd, int big_endian)\n{\n\tunsigned char *buf = NULL;\n\tuint16_t buflen = 0;\n\tint ret = 0;\n\tfor(;;) {\n\t\toff_t offset;\n\t\tuint16_t length;\n\t\tchar *name;\n\t\tif(!read_uint16(fd, &length, big_endian))\n\t\t\tbreak;\n\t\tif (length < 6) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tbreak;\n\t\t}\n\t\tif(length > buflen) {\n\t\t\tunsigned char *newbuf = (unsigned char *)cli_realloc(buf, length);\n\t\t\tif(newbuf == NULL) {\n\t\t\t\tif(buf)\n\t\t\t\t\tfree(buf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuflen = length;\n\t\t\tbuf = newbuf;\n\t\t}\n\t\toffset = lseek(fd, 0, SEEK_CUR);\n\t\tif(cli_readn(fd, buf, length) != (int)length) {\n\t\t\tcli_dbgmsg(\"read name failed - rewinding\\n\");\n\t\t\tlseek(fd, offset, SEEK_SET);\n\t\t\tbreak;\n\t\t}\n\t\tname = get_unicode_name((const char *)buf, length, big_endian);\n\t\tcli_dbgmsg(\"length: %d, name: %s\\n\", length, (name) ? name : \"[null]\");\n\t\tif((name == NULL) || (memcmp(\"*\\\\\", name, 2) != 0) ||\n\t\t   (strchr(\"ghcd\", name[2]) == NULL)) {\n\t\t\tlseek(fd, -(length+2), SEEK_CUR);\n\t\t\tif(name)\n\t\t\t\tfree(name);\n\t\t\tbreak;\n\t\t}\n\t\tfree(name);\n\t\tif(!read_uint16(fd, &length, big_endian)) {\n\t\t\tif(buf)\n\t\t\t\tfree(buf);\n\t\t\tbreak;\n\t\t}\n\t\tret++;\n\t\tif ((length != 0) && (length != 65535)) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\t\toffset = lseek(fd, 10, SEEK_CUR);\n\t\tcli_dbgmsg(\"offset: %lu\\n\", (unsigned long)offset);\n\t\tvba56_test_middle(fd);\n\t}\n\tif(buf)\n\t\tfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "GF_EXPORT\nBool gf_isom_has_cenc_sample_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_FALSE;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\treturn GF_FALSE;", "target": 0}
{"code": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo,\n\t\t\t\t const void *text, size_t text_size,\n\t\t\t\t void *digest)\n{\n\tstruct nettle_hash_ctx ctx;\n\tint ret;\n\tret = _ctx_init(algo, &ctx);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tctx.update(&ctx, text_size, text);\n\tctx.digest(&ctx, ctx.length, digest);\n\treturn 0;\n}", "target": 1}
{"code": "COMPAT_SYSCALL_DEFINE2(truncate, const char __user *, path, compat_off_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}", "target": 0}
{"code": "static void clear_tables(JOIN *join)\n{\n  for (uint i= 0 ; i < join->table_count ; i++)\n  {\n    if (!(join->table[i]->map & join->const_table_map))\n      mark_as_null_row(join->table[i]);\t\t\n  }\n}", "target": 0}
{"code": "static int bnx2x_get_leader_lock_resource(struct bnx2x *bp)\n{\n\tif (BP_PATH(bp))\n\t\treturn HW_LOCK_RESOURCE_RECOVERY_LEADER_1;\n\telse\n\t\treturn HW_LOCK_RESOURCE_RECOVERY_LEADER_0;\n}", "target": 0}
{"code": "static ssize_t ucma_migrate_id(struct ucma_file *new_file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_migrate_id cmd;\n\tstruct rdma_ucm_migrate_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct fd f;\n\tstruct ucma_file *cur_file;\n\tint ret = 0;\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\tf = fdget(cmd.fd);\n\tif (!f.file)\n\t\treturn -ENOENT;\n\tif (f.file->f_op != &ucma_fops) {\n\t\tret = -EINVAL;\n\t\tgoto file_put;\n\t}\n\tctx = ucma_get_ctx(f.file->private_data, cmd.id);\n\tif (IS_ERR(ctx)) {\n\t\tret = PTR_ERR(ctx);\n\t\tgoto file_put;\n\t}\n\trdma_lock_handler(ctx->cm_id);\n\tcur_file = ctx->file;\n\tif (cur_file == new_file) {\n\t\tmutex_lock(&cur_file->mut);\n\t\tresp.events_reported = ctx->events_reported;\n\t\tmutex_unlock(&cur_file->mut);\n\t\tgoto response;\n\t}\n\tucma_lock_files(cur_file, new_file);\n\txa_lock(&ctx_table);\n\tlist_move_tail(&ctx->list, &new_file->ctx_list);\n\tucma_move_events(ctx, new_file);\n\tctx->file = new_file;\n\tresp.events_reported = ctx->events_reported;\n\txa_unlock(&ctx_table);\n\tucma_unlock_files(cur_file, new_file);\nresponse:\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\trdma_unlock_handler(ctx->cm_id);\n\tucma_put_ctx(ctx);\nfile_put:\n\tfdput(f);\n\treturn ret;\n}", "target": 1}
{"code": "R_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\tfree (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; \n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}", "target": 1}
{"code": "GF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}", "target": 0}
{"code": "static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n \ttu = file->private_data;\n \tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n \tspin_lock_irq(&tu->qlock);\n \twhile ((long)count - result >= unit) {\n \t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n \t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n \t\t\tspin_unlock_irq(&tu->qlock);\n \t\t\tschedule();\n \t\t\tspin_lock_irq(&tu->qlock);\n \t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n \t\ttu->qused--;\n \t\tspin_unlock_irq(&tu->qlock);\n\t\tmutex_lock(&tu->ioctl_lock);\n \t\tif (tu->tread) {\n \t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n \t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n \t\t\t\t\t sizeof(struct snd_timer_read)))\n \t\t\t\terr = -EFAULT;\n \t\t}\n\t\tmutex_unlock(&tu->ioctl_lock);\n \t\tspin_lock_irq(&tu->qlock);\n \t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n \t}\n  _error:\n \tspin_unlock_irq(&tu->qlock);\n \treturn result > 0 ? result : err;\n }", "target": 1}
{"code": " static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n {\n     long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n         long a = *(long *)(src1 + i);\n         long b = *(long *)(src2 + i);\n         *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}", "target": 1}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": " status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,\n                                              uint32_t cmdSize,\n                                              void *pCmdData,\n uint32_t *replySize,\n void *pReplyData)\n{\n Mutex::Autolock _l(mLock);\n    ALOGVV(\"command(), cmdCode: %d, mEffectInterface: %p\", cmdCode, mEffectInterface);\n if (mState == DESTROYED || mEffectInterface == NULL) {\n return NO_INIT;\n }\n if (mStatus != NO_ERROR) {\n return mStatus;\n }\n if (cmdCode == EFFECT_CMD_GET_PARAM &&\n (*replySize < sizeof(effect_param_t) ||\n ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {\n         android_errorWriteLog(0x534e4554, \"29251553\");\n         return -EINVAL;\n     }\n     status_t status = (*mEffectInterface)->command(mEffectInterface,\n                                                    cmdCode,\n                                                    cmdSize,\n                                                   pCmdData,\n                                                   replySize,\n                                                   pReplyData);\n if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {\n uint32_t size = (replySize == NULL) ? 0 : *replySize;\n for (size_t i = 1; i < mHandles.size(); i++) {\n EffectHandle *h = mHandles[i];\n if (h != NULL && !h->destroyed_l()) {\n                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);\n }\n }\n }\n return status;\n}", "target": 1}
{"code": "MenuCacheItem *menu_cache_find_item_by_id(MenuCache *cache, const char *id)\n{\n    MenuCacheItem *item = NULL;\n    MENU_CACHE_LOCK;\n    if (cache && id)\n        item = _scan_by_id(MENU_CACHE_ITEM(cache->root_dir), id);\n    if (item)\n        menu_cache_item_ref(item);\n    MENU_CACHE_UNLOCK;\n    return item;\n}", "target": 0}
{"code": "static int __init unittest_data_add(void)\n{\n\tvoid *unittest_data;\n\tstruct device_node *unittest_data_node, *np;\n\textern uint8_t __dtb_testcases_begin[];\n\textern uint8_t __dtb_testcases_end[];\n\tconst int size = __dtb_testcases_end - __dtb_testcases_begin;\n\tint rc;\n\tif (!size) {\n\t\tpr_warn(\"%s: No testcase data to attach; not running tests\\n\",\n\t\t\t__func__);\n\t\treturn -ENODATA;\n\t}\n\tunittest_data = kmemdup(__dtb_testcases_begin, size, GFP_KERNEL);\n\tif (!unittest_data)\n\t\treturn -ENOMEM;\n\tof_fdt_unflatten_tree(unittest_data, NULL, &unittest_data_node);\n\tif (!unittest_data_node) {\n\t\tpr_warn(\"%s: No tree to attach; not running tests\\n\", __func__);\n\t\treturn -ENODATA;\n\t}\n\tof_overlay_mutex_lock();\n\trc = of_resolve_phandles(unittest_data_node);\n\tif (rc) {\n\t\tpr_err(\"%s: Failed to resolve phandles (rc=%i)\\n\", __func__, rc);\n\t\tof_overlay_mutex_unlock();\n\t\treturn -EINVAL;\n\t}\n\tif (!of_root) {\n\t\tof_root = unittest_data_node;\n\t\tfor_each_of_allnodes(np)\n\t\t\t__of_attach_node_sysfs(np);\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\t\tof_chosen = of_find_node_by_path(\"/chosen\");\n\t\tof_overlay_mutex_unlock();\n\t\treturn 0;\n\t}\n\tnp = unittest_data_node->child;\n\twhile (np) {\n\t\tstruct device_node *next = np->sibling;\n\t\tnp->parent = of_root;\n\t\tattach_node_and_children(np);\n\t\tnp = next;\n\t}\n\tof_overlay_mutex_unlock();\n\treturn 0;\n}", "target": 1}
{"code": "vte_sequence_handler_scroll_up (VteTerminal *terminal, GValueArray *params)\n{\n\tlong val = 1;\n\tGValue *value;\n\tif ((params != NULL) && (params->n_values > 0)) {\n\t\tvalue = g_value_array_get_nth(params, 0);\n\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\tval = g_value_get_long(value);\n\t\t\tval = MAX(val, 1);\n\t\t}\n\t}\n\t_vte_terminal_scroll_text (terminal, -val);\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, InWithLhsFieldPathMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: {$in: ['$x', [1, 2, 3]]}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 1)));\n    ASSERT_TRUE(matches(BSON(\"x\" << 3)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 5)));\n    ASSERT_FALSE(matches(BSON(\"y\" << 2)));\n    ASSERT_FALSE(matches(BSON(\"x\" << BSON(\"y\" << 2))));\n}", "target": 0}
{"code": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}", "target": 1}
{"code": "static s32 adpt_send_nop(adpt_hba*pHba,u32 m)\n{\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 5*HZ;\n\twhile(m == EMPTY_QUEUE){\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif(m != EMPTY_QUEUE){\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_ERR \"%s: Timeout waiting for message frame!\\n\",pHba->name);\n\t\t\treturn 2;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tmsg = (u32 __iomem *)(pHba->msg_addr_virt + m);\n\twritel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);\n\twritel( I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0,&msg[1]);\n\twritel( 0,&msg[2]);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "size_t ring_buffer_page_len(void *page)\n{\n\treturn local_read(&((struct buffer_data_page *)page)->commit)\n\t\t+ BUF_PAGE_HDR_SIZE;\n}", "target": 0}
{"code": "  scoped_refptr<TransportSocketParams> GetTcpParams() {\n    if (GetParam() != HTTP)\n      return scoped_refptr<TransportSocketParams>();\n    return ignored_transport_socket_params_;\n  }", "target": 0}
{"code": "update_info_drive_ports (Device *device)\n{\n  GList *ports;\n  GList *l;\n  GPtrArray *p;\n  ports = daemon_local_find_enclosing_ports (device->priv->daemon, device->priv->native_path);\n  p = g_ptr_array_new ();\n  for (l = ports; l != NULL; l = l->next)\n    {\n      Port *port = PORT (l->data);\n      g_ptr_array_add (p, (gpointer) port_local_get_object_path (port));\n    }\n  g_ptr_array_add (p, NULL);\n  device_set_drive_ports (device, (GStrv) p->pdata);\n  g_ptr_array_unref (p);\n  g_list_free (ports);\n  return TRUE;\n}", "target": 0}
{"code": "netsnmp_mibindex_load( void )\n{\n    DIR *dir;\n    struct dirent *file;\n    FILE *fp;\n    char tmpbuf[ 300];\n    char tmpbuf2[300];\n    int  i;\n    char *cp;\n    snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes\",\n              get_persistent_directory());\n    tmpbuf[sizeof(tmpbuf)-1] = 0;\n    dir = opendir( tmpbuf );\n    if ( dir == NULL ) {\n        DEBUGMSGTL((\"mibindex\", \"load: (new)\\n\"));\n        mkdirhier( tmpbuf, NETSNMP_AGENT_DIRECTORY_MODE, 0);\n        return;\n    }\n    while ((file = readdir( dir ))) {\n        if ( !isdigit((unsigned char)(file->d_name[0])))\n            continue;\n        i = atoi( file->d_name );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n              get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        fp = fopen( tmpbuf, \"r\" );\n        if (!fp)\n            continue;\n        cp = fgets( tmpbuf2, sizeof(tmpbuf2), fp );\n        fclose( fp );\n        if ( !cp ) {\n            DEBUGMSGTL((\"mibindex\", \"Empty MIB index (%d)\\n\", i));\n            continue;\n        }\n        if ( strncmp( tmpbuf2, \"DIR \", 4 ) != 0 ) {\n            DEBUGMSGTL((\"mibindex\", \"Malformed MIB index (%d)\\n\", i));\n            continue;\n        }\n        tmpbuf2[strlen(tmpbuf2)-1] = 0;\n        DEBUGMSGTL((\"mibindex\", \"load: (%d) %s\\n\", i, tmpbuf2));\n        (void)_mibindex_add( tmpbuf2+4, i );  \n    }\n    closedir( dir );\n}", "target": 1}
{"code": "bool V8DOMWindow::indexedSecurityCheckCustom(v8::Local<v8::Object> host, uint32_t index, v8::AccessType type, v8::Local<v8::Value>)\n{\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n    v8::Handle<v8::Object> window = host->FindInstanceInPrototypeChain(V8DOMWindow::GetTemplate(isolate, worldTypeInMainThread(isolate)));\n    if (window.IsEmpty())\n        return false;\n    DOMWindow* targetWindow = V8DOMWindow::toNative(window);\n    ASSERT(targetWindow);\n    Frame* target = targetWindow->frame();\n    if (!target)\n        return false;\n    Frame* childFrame =  target->tree()->scopedChild(index);\n    if (target->loader()->stateMachine()->isDisplayingInitialEmptyDocument())\n        target->loader()->didAccessInitialDocument();\n    if (type == v8::ACCESS_HAS && childFrame)\n        return true;\n    if (type == v8::ACCESS_GET && childFrame && !host->HasRealIndexedProperty(index))\n        return true;\n    return BindingSecurity::shouldAllowAccessToFrame(target, DoNotReportSecurityError);\n}", "target": 0}
{"code": "bool ATSParser::PSISection::isCRCOkay() const {\n if (!isComplete()) {\n return false;\n }\n uint8_t* data = mBuffer->data();\n if ((data[1] & 0x80) == 0) {\n return true;\n }\n     unsigned sectionLength = U16_AT(data + 1) & 0xfff;\n     ALOGV(\"sectionLength %u, skip %u\", sectionLength, mSkipBytes);\n     sectionLength -= mSkipBytes;\n uint32_t crc = 0xffffffff;\n for(unsigned i = 0; i < sectionLength + 4 ; i++) {\n uint8_t b = data[i];\n int index = ((crc >> 24) ^ (b & 0xff)) & 0xff;\n        crc = CRC_TABLE[index] ^ (crc << 8);\n }\n    ALOGV(\"crc: %08x\\n\", crc);\n return (crc == 0);\n}", "target": 1}
{"code": "NOEXPORT void tray_update(const int num) {\n    NOTIFYICONDATA nid;\n    static ICON_TYPE previous_icon=ICON_NONE;\n    ICON_TYPE current_icon;\n    LPTSTR tip;\n    if(!global_options.option.taskbar) { \n        tray_delete(); \n        return;\n    }\n    if(!tray_menu_handle) \n        tray_menu_handle=LoadMenu(ghInst, MAKEINTRESOURCE(IDM_TRAYMENU));\n    if(!tray_menu_handle) {\n        ioerror(\"LoadMenu\");\n        return;\n    }\n    if(cmdline.service)\n        EnableMenuItem(tray_menu_handle, IDM_EDIT_CONFIG, MF_GRAYED);\n    ZeroMemory(&nid, sizeof nid);\n    nid.cbSize=sizeof nid;\n    nid.uID=1; \n    nid.uFlags=NIF_MESSAGE|NIF_TIP;\n    nid.uCallbackMessage=WM_SYSTRAY; \n    nid.hWnd=hwnd; \n    if(num<0) {\n        tip=str_tprintf(TEXT(\"Server is down\"));\n        current_icon=ICON_ERROR;\n    } else if(num>0) {\n        tip=str_tprintf(TEXT(\"%d active session(s)\"), num);\n        current_icon=ICON_ACTIVE;\n    } else {\n        tip=str_tprintf(TEXT(\"Server is idle\"));\n        current_icon=ICON_IDLE;\n    }\n    _tcsncpy(nid.szTip, tip, 63);\n    nid.szTip[63]=TEXT('\\0');\n    str_free(tip);\n    nid.hIcon=global_options.icon[current_icon];\n    if(current_icon!=previous_icon) {\n        nid.uFlags|=NIF_ICON;\n        previous_icon=current_icon;\n    }\n    if(Shell_NotifyIcon(NIM_MODIFY, &nid)) \n        return; \n    nid.uFlags|=NIF_ICON;\n    Shell_NotifyIcon(NIM_ADD, &nid);\n}", "target": 1}
{"code": "static int arc_emac_tx(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct arc_emac_priv *priv = netdev_priv(ndev);\n\tunsigned int len, *txbd_curr = &priv->txbd_curr;\n\tstruct net_device_stats *stats = &ndev->stats;\n\t__le32 *info = &priv->txbd[*txbd_curr].info;\n\tdma_addr_t addr;\n\tif (skb_padto(skb, ETH_ZLEN))\n\t\treturn NETDEV_TX_OK;\n\tlen = max_t(unsigned int, ETH_ZLEN, skb->len);\n\tif (unlikely(!arc_emac_tx_avail(priv))) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetdev_err(ndev, \"BUG! Tx Ring full when queue awake!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\taddr = dma_map_single(&ndev->dev, (void *)skb->data, len,\n\t\t\t      DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(&ndev->dev, addr))) {\n\t\tstats->tx_dropped++;\n\t\tstats->tx_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tdma_unmap_addr_set(&priv->tx_buff[*txbd_curr], addr, addr);\n\tdma_unmap_len_set(&priv->tx_buff[*txbd_curr], len, len);\n\tpriv->tx_buff[*txbd_curr].skb = skb;\n\tpriv->txbd[*txbd_curr].data = cpu_to_le32(addr);\n\twmb();\n\tskb_tx_timestamp(skb);\n\t*info = cpu_to_le32(FOR_EMAC | FIRST_OR_LAST_MASK | len);\n\t*txbd_curr = (*txbd_curr + 1) % TX_BD_NUM;\n\tsmp_mb();\n\tif (!arc_emac_tx_avail(priv)) {\n\t\tnetif_stop_queue(ndev);\n\t\tsmp_mb();\n\t\tif (arc_emac_tx_avail(priv))\n\t\t\tnetif_start_queue(ndev);\n\t}\n\tarc_reg_set(priv, R_STATUS, TXPL_MASK);\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "gdk_pixbuf__tiff_image_load (FILE *f, GError **error)\n{\n        TIFF *tiff;\n        int fd;\n        GdkPixbuf *pixbuf;\n        g_return_val_if_fail (f != NULL, NULL);\n        tiff_set_handlers ();\n        fd = fileno (f);\n        lseek (fd, 0, SEEK_SET);\n        tiff = TIFFFdOpen (fd, \"libpixbuf-tiff\", \"r\");\n        if (!tiff) {\n                g_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"Failed to open TIFF image\"));\n                return NULL;\n        }\n        pixbuf = tiff_image_parse (tiff, NULL, error);\n        TIFFClose (tiff);\n        return pixbuf;\n}", "target": 0}
{"code": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n {\n     if (dir_path) {\n         v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n    } else {\n         v9fs_path_sprintf(target, \"%s\", name);\n     }\n     return 0;\n }", "target": 1}
{"code": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}", "target": 1}
{"code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n \t\tattr->size = usize;\n \t}\n\tret = copy_to_user(uattr, attr, usize);\n \tif (ret)\n \t\treturn -EFAULT;\nout:\n\treturn ret;\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}", "target": 1}
{"code": "int sysctl_numa_balancing(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_numa_balancing);\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_numabalancing_state(state);\n\treturn err;\n}", "target": 0}
{"code": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off, gdb_num;\n\tint err;\n\t__u16 bg_flags = 0;\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n} ", "target": 0}
{"code": "    virtual AP4_Result Tell(AP4_Position& position) { position = m_Size; return AP4_SUCCESS; }", "target": 0}
{"code": "void HTMLMediaElement::ParserDidSetAttributes() {\n  HTMLElement::ParserDidSetAttributes();\n  if (FastHasAttribute(kMutedAttr))\n    muted_ = true;\n}", "target": 0}
{"code": "static int neigh_fill_info(struct sk_buff *skb, struct neighbour *n,\n\t\t\t   u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tunsigned long now = jiffies;\n\tunsigned char *b = skb->tail;\n\tstruct nda_cacheinfo ci;\n\tint locked = 0;\n\tu32 probes;\n\tstruct nlmsghdr *nlh = NLMSG_NEW(skb, pid, seq, event,\n\t\t\t\t\t sizeof(struct ndmsg), flags);\n\tstruct ndmsg *ndm = NLMSG_DATA(nlh);\n\tndm->ndm_family\t = n->ops->family;\n\tndm->ndm_flags\t = n->flags;\n\tndm->ndm_type\t = n->type;\n\tndm->ndm_ifindex = n->dev->ifindex;\n\tRTA_PUT(skb, NDA_DST, n->tbl->key_len, n->primary_key);\n\tread_lock_bh(&n->lock);\n\tlocked\t\t = 1;\n\tndm->ndm_state\t = n->nud_state;\n\tif (n->nud_state & NUD_VALID)\n\t\tRTA_PUT(skb, NDA_LLADDR, n->dev->addr_len, n->ha);\n\tci.ndm_used\t = now - n->used;\n\tci.ndm_confirmed = now - n->confirmed;\n\tci.ndm_updated\t = now - n->updated;\n\tci.ndm_refcnt\t = atomic_read(&n->refcnt) - 1;\n\tprobes = atomic_read(&n->probes);\n\tread_unlock_bh(&n->lock);\n\tlocked\t\t = 0;\n\tRTA_PUT(skb, NDA_CACHEINFO, sizeof(ci), &ci);\n\tRTA_PUT(skb, NDA_PROBES, sizeof(probes), &probes);\n\tnlh->nlmsg_len\t = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tif (locked)\n\t\tread_unlock_bh(&n->lock);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "static int mxf_read_pulldown_component(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFPulldownComponent *mxf_pulldown = arg;\n    switch(tag) {\n    case 0x0d01:\n        avio_read(pb, mxf_pulldown->input_segment_ref, 16);\n        break;\n    }\n    return 0;\n}", "target": 0}
{"code": "fz_indexed_colorspace_palette(fz_context *ctx, fz_colorspace *cs, int *high)\n{\n\tstruct indexed *idx = cs->data;\n\tif (!fz_colorspace_is_indexed(ctx, cs))\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"colorspace not indexed\");\n\t*high = idx->high;\n\treturn idx->lookup;\n}", "target": 0}
{"code": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\tstrlcpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "void php_gd_error(const char *format, ...)\n{\n\tva_list args;\n\tTSRMLS_FETCH();\n\tva_start(args, format);\n\tphp_verror(NULL, \"\", E_WARNING, format, args TSRMLS_CC);\n\tva_end(args);\n}", "target": 0}
{"code": "static inline Quantum ScaleLongLongToQuantum(const MagickSizeType value)\n{\n  return((Quantum) (value));\n}", "target": 0}
{"code": "void Opal::Call::set_no_answer_forward (unsigned delay, const std::string & uri)\n{\n  forward_uri = uri;\n  NoAnswerTimer.SetInterval (0, PMIN (delay, 60));\n}", "target": 0}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape;\n    status_ = TensorShape::BuildTensorShapeBase(ssm.shape(), &ssm_shape);\n    if (!status_.ok()) return;\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 1}
{"code": "void vnc_zlib_clear(VncState *vs)\n{\n    if (vs->zlib.stream.opaque) {\n        deflateEnd(&vs->zlib.stream);\n    }\n    buffer_free(&vs->zlib.zlib);\n}", "target": 0}
{"code": "static Jsi_RC DebugInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash) {\n        Jsi_ValueMakeArrayObject(interp, ret, NULL);\n        return JSI_OK;\n    }\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->breakpointHash, ret, 0);\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    int num;\n    char nbuf[100];\n    if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n        return Jsi_LogError(\"bad number\");\n    snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n    if (!hPtr) \n        return Jsi_LogError(\"unknown breakpoint\");\n    jsi_BreakPoint* bp = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);\n    if (!bp) return JSI_ERROR;\n    Jsi_DString dStr = {};\n    if (bp->func)\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"func\\\", func:\\\"%s\\\", hits:%d, enabled:%s, temporary:%s}\",\n         bp->id, bp->func, bp->hits, bp->enabled?\"true\":\"false\", bp->temp?\"true\":\"false\");\n    else\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"line\\\", file:\\\"%s\\\", line:%d, hits:%d, enabled:%s}\",\n            bp->id, bp->file?bp->file:\"\", bp->line, bp->hits, bp->enabled?\"true\":\"false\");\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}", "target": 1}
{"code": "list_fields(MYSQL *mysql,const char *db,const char *table,\n\t    const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  ulong UNINIT_VAR(rows);\n  if (mysql_select_db(mysql,db))\n  {\n    fprintf(stderr,\"%s: Cannot connect to db: %s: %s\\n\",my_progname,db,\n\t    mysql_error(mysql));\n    return 1;\n  }\n  if (opt_count)\n  {\n    sprintf(query,\"select count(*) from `%s`\", table);\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot get record count for db: %s, table: %s: %s\\n\",\n              my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    row= mysql_fetch_row(result);\n    rows= (ulong) strtoull(row[0], (char**) 0, 10);\n    mysql_free_result(result);\n  }\n  end=strmov(strmov(strmov(query,\"show  columns from `\"),table),\"`\");\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot list columns in db: %s, table: %s: %s\\n\",\n\t    my_progname,db,table,mysql_error(mysql));\n    return 1;\n  }\n  printf(\"Database: %s  Table: %s\", db, table);\n  if (opt_count)\n    printf(\"  Rows: %lu\", rows);\n  if (wild && wild[0])\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  if (opt_show_keys)\n  {\n    end=strmov(strmov(strmov(query,\"show keys from `\"),table),\"`\");\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot list keys in db: %s, table: %s: %s\\n\",\n\t      my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    if (mysql_num_rows(result))\n    {\n      print_res_header(result);\n      while ((row=mysql_fetch_row(result)))\n\tprint_res_row(result,row);\n      print_res_top(result);\n    }\n    else\n      puts(\"Table has no keys\");\n  }\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "handle_bap(netdissect_options *ndo _U_,\n           const u_char *p _U_, int length _U_)\n{\n}", "target": 0}
{"code": "static inline vm_fault_t hugetlb_handle_userfault(struct vm_area_struct *vma,\n\t\t\t\t\t\t  struct address_space *mapping,\n\t\t\t\t\t\t  pgoff_t idx,\n\t\t\t\t\t\t  unsigned int flags,\n\t\t\t\t\t\t  unsigned long haddr,\n\t\t\t\t\t\t  unsigned long reason)\n{\n\tvm_fault_t ret;\n\tu32 hash;\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = haddr,\n\t\t.flags = flags,\n\t};\n\thash = hugetlb_fault_mutex_hash(mapping, idx);\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\ti_mmap_unlock_read(mapping);\n\tret = handle_userfault(&vmf, reason);\n\ti_mmap_lock_read(mapping);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\treturn ret;\n}", "target": 0}
{"code": "SPL_METHOD(Array, exchangeArray)\n{\n\tzval *object = getThis(), *tmp, **array;\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tarray_init(return_value);\n\tzend_hash_copy(HASH_OF(return_value), spl_array_get_hash_table(intern, 0 TSRMLS_CC), (copy_ctor_func_t) zval_add_ref, &tmp, sizeof(zval*));\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &array) == FAILURE) {\n\t\treturn;\n\t}\n\tspl_array_set_array(object, intern, array, 0L, 1 TSRMLS_CC);\n}", "target": 0}
{"code": "join_tab_cmp_straight(const void *dummy, const void* ptr1, const void* ptr2)\n{\n  JOIN_TAB *jt1= *(JOIN_TAB**) ptr1;\n  JOIN_TAB *jt2= *(JOIN_TAB**) ptr2;\n  DBUG_ASSERT(!jt1->emb_sj_nest);\n  DBUG_ASSERT(!jt2->emb_sj_nest);\n  int cmp;\n  if ((cmp= compare_embedding_subqueries(jt1, jt2)) != 0)\n    return cmp;\n  if (jt1->dependent & jt2->table->map)\n    return 1;\n  if (jt2->dependent & jt1->table->map)\n    return -1;\n  return jt1 > jt2 ? 1 : (jt1 < jt2 ? -1 : 0);\n}", "target": 0}
{"code": "static uint8_t nvme_sq_empty(NvmeSQueue *sq)\n{\n    return sq->head == sq->tail;\n}", "target": 0}
{"code": "char *get_refs_directory(void)\n{\n\tif (!git_refs_dir)\n\t\tsetup_git_env();\n\treturn git_refs_dir;\n}", "target": 0}
{"code": "static inline void ok_png_premultiply(uint8_t *dst) {\n    const uint8_t a = dst[3];\n    if (a == 0) {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    } else if (a < 255) {\n        dst[0] = (a * dst[0] + 127) / 255;\n        dst[1] = (a * dst[1] + 127) / 255;\n        dst[2] = (a * dst[2] + 127) / 255;\n    }\n}", "target": 0}
{"code": "lsof_parse (const char *stdout,\n            GPtrArray *processes)\n{\n  int n;\n  char **tokens;\n  tokens = g_strsplit (stdout, \"\\n\", 0);\n  for (n = 0; tokens[n] != NULL; n++)\n    {\n      pid_t pid;\n      uid_t uid;\n      char *command_line;\n      GValue elem =\n        { 0 };\n      if (strlen (tokens[n]) == 0)\n        continue;\n      pid = strtol (tokens[n], NULL, 0);\n      uid = get_uid_for_pid (pid);\n      command_line = get_command_line_for_pid (pid);\n      g_value_init (&elem, LSOF_DATA_STRUCT_TYPE);\n      g_value_take_boxed (&elem, dbus_g_type_specialized_construct (LSOF_DATA_STRUCT_TYPE));\n      dbus_g_type_struct_set (&elem, 0, pid, 1, uid, 2, command_line != NULL ? command_line : \"\", G_MAXUINT);\n      g_ptr_array_add (processes, g_value_get_boxed (&elem));\n      g_free (command_line);\n    }\n  g_strfreev (tokens);\n}", "target": 0}
{"code": "static void calc_load_migrate(struct rq *rq)\n{\n\tlong delta = calc_load_fold_active(rq);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n}", "target": 0}
{"code": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out;\n}", "target": 1}
{"code": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void nfs_fattr_free_owner_name(struct nfs_fattr *fattr)\n{\n\tfattr->valid &= ~NFS_ATTR_FATTR_OWNER_NAME;\n\tkfree(fattr->owner_name->data);\n}", "target": 0}
{"code": "void ewk_view_viewport_attributes_set(Evas_Object* ewkView, const WebCore::ViewportArguments& arguments)\n{\n    EWK_VIEW_SD_GET(ewkView, smartData);\n    EWK_VIEW_PRIV_GET(smartData, priv);\n    priv->viewportArguments = arguments;\n    evas_object_smart_callback_call(ewkView, \"viewport,changed\", 0);\n}", "target": 0}
{"code": "static void opj_j2k_setup_decoding (opj_j2k_t *p_j2k)\n{\n        assert(p_j2k != 00);\n        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_decode_tiles);\n}", "target": 0}
{"code": "fz_default_color_params(fz_context *ctx)\n{\n\treturn default_color_params;\n}", "target": 0}
{"code": "user_change_icon_file_authorized_cb (Daemon                *daemon,\n                                     User                  *user,\n                                     GDBusMethodInvocation *context,\n                                     gpointer               data)\n{\n        g_autofree gchar *filename = NULL;\n        g_autoptr(GFile) file = NULL;\n        g_autoptr(GFileInfo) info = NULL;\n        guint32 mode;\n        GFileType type;\n        guint64 size;\n        filename = g_strdup (data);\n        if (filename == NULL ||\n            *filename == '\\0') {\n                g_autofree gchar *dest_path = NULL;\n                g_autoptr(GFile) dest = NULL;\n                g_autoptr(GError) error = NULL;\n                g_clear_pointer (&filename, g_free);\n                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);\n                dest = g_file_new_for_path (dest_path);\n                if (!g_file_delete (dest, NULL, &error) &&\n                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n                        throw_error (context, ERROR_FAILED, \"failed to remove user icon, %s\", error->message);\n                        return;\n                }\n                goto icon_saved;\n         }\n         file = g_file_new_for_path (filename);\n         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                return;\n        }", "target": 1}
{"code": "void js_delregistry(js_State *J, const char *name)\n{\n\tjsR_delproperty(J, J->R, name);\n}", "target": 0}
{"code": "static int update_private_key(const u8 *key, size_t keysize)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tidx = keysize * (opt_key_num-1);\n\tr = sc_update_binary(card, idx, key, keysize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to write private key: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static GF_MovieFragmentBox *gf_isom_get_moof(GF_ISOFile *file, u32 moof_index)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tmoof_index--;\n\t\t\tif (!moof_index) return (GF_MovieFragmentBox *) a;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "sigalrm_handler(int sig)\n{\nsig = sig;            \nsigalrm_seen = TRUE;\n}", "target": 0}
{"code": "static int exif_rewrite_tag_format_to_unsigned(int format)\n{\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE: return TAG_FMT_BYTE;\n\t\tcase TAG_FMT_SRATIONAL: return TAG_FMT_URATIONAL;\n\t\tcase TAG_FMT_SSHORT: return TAG_FMT_USHORT;\n\t\tcase TAG_FMT_SLONG: return TAG_FMT_ULONG;\n\t}\n\treturn format;\n}", "target": 0}
{"code": "\tSpawnPreparationInfo prepareSpawn(const Options &options) {\n\t\tTRACE_POINT();\n\t\tSpawnPreparationInfo info;\n\t\tprepareChroot(info, options);\n\t\tinfo.userSwitching = prepareUserSwitching(options);\n\t\tprepareSwitchingWorkingDirectory(info, options);\n\t\tinferApplicationInfo(info);\n\t\treturn info;\n\t}", "target": 1}
{"code": "fz_new_cmm_context(fz_context *ctx)\n{\n\tctx->cmm_instance = fz_cmm_new_instance(ctx);\n}", "target": 0}
{"code": "static int test_ifdefine_section(cmd_parms *cmd, const char *arg)\n{\n    return ap_exists_config_define(arg);\n}", "target": 0}
{"code": "Status OpLevelCostEstimator::PredictMaxPoolGrad(const OpContext& op_context,\n                                                NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;\n  } else if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy);\n  } else {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy * 2);\n  }\n  node_costs->num_compute_ops = ops;\n  const int64_t input0_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  const int64_t input2_size =\n      CalculateTensorSize(op_info.inputs(2), &found_unknown_shapes);\n  node_costs->num_input_bytes_accessed = {input0_size, 0, input2_size};\n  const int64_t output_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static int emulator_get_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 *pdata)\n{\n\treturn kvm_get_msr(emul_to_vcpu(ctxt), msr_index, pdata);\n}", "target": 0}
{"code": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}", "target": 1}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "void XMLTokenizer::endElementNs()\n{\n    if (m_parserStopped)\n        return;\n    if (m_parserPaused) {\n        m_pendingCallbacks->appendEndElementNSCallback();\n        return;\n    }\n    exitText();\n    Node* n = m_currentNode;\n    RefPtr<Node> parent = n->parentNode();\n    n->finishParsingChildren();\n    if (!n->isElementNode() || !m_view) {\n        setCurrentNode(parent.get());\n        return;\n    }\n    Element* element = static_cast<Element*>(n);\n    ScriptElement* scriptElement = toScriptElement(element);\n    if (!scriptElement) {\n        setCurrentNode(parent.get());\n        return;\n    }\n    ASSERT(!m_pendingScript);\n    m_requestingScript = true;\n    String scriptHref = scriptElement->sourceAttributeValue();\n    if (!scriptHref.isEmpty()) {\n        String scriptCharset = scriptElement->scriptCharset();\n        if ((m_pendingScript = m_doc->docLoader()->requestScript(scriptHref, scriptCharset))) {\n            m_scriptElement = element;\n            m_pendingScript->addClient(this);\n            if (m_pendingScript)\n                pauseParsing();\n        } else \n            m_scriptElement = 0;\n    } else\n        m_view->frame()->loader()->executeScript(ScriptSourceCode(scriptElement->scriptContent(), m_doc->url(), m_scriptStartLine));\n    m_requestingScript = false;\n    setCurrentNode(parent.get());\n}", "target": 0}
{"code": "static inline Status ParseAndCheckBoxSizes(const Tensor& boxes,\n                                           const Tensor& box_index,\n                                           int* num_boxes) {\n  if (boxes.NumElements() == 0 && box_index.NumElements() == 0) {\n    *num_boxes = 0;\n    return Status::OK();\n  }\n  if (boxes.dims() != 2) {\n    return errors::InvalidArgument(\"boxes must be 2-D\",\n                                   boxes.shape().DebugString());\n  }\n  *num_boxes = boxes.dim_size(0);\n  if (boxes.dim_size(1) != 4) {\n    return errors::InvalidArgument(\"boxes must have 4 columns\");\n  }\n  if (box_index.dims() != 1) {\n    return errors::InvalidArgument(\"box_index must be 1-D\",\n                                   box_index.shape().DebugString());\n  }\n  if (box_index.dim_size(0) != *num_boxes) {\n    return errors::InvalidArgument(\"box_index has incompatible shape\");\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static NTSTATUS fd_open_atomic(struct connection_struct *conn,\n\t\t\tfiles_struct *fsp,\n\t\t\tint flags,\n\t\t\tmode_t mode,\n                        bool *file_created)\n {\n        NTSTATUS status = NT_STATUS_UNSUCCESSFUL;\n        bool file_existed = VALID_STAT(fsp->fsp_name->st);\n        *file_created = false;\n\t\t * We're not creating the file, just pass through.\n\t\t */\n\t\treturn fd_open(conn, fsp, flags, mode);\n\t}", "target": 1}
{"code": "static bool vsock_in_connected_table(struct vsock_sock *vsk)\n{\n\tbool ret;\n\tspin_lock_bh(&vsock_table_lock);\n\tret = __vsock_in_connected_table(vsk);\n\tspin_unlock_bh(&vsock_table_lock);\n\treturn ret;\n}", "target": 0}
{"code": "  virtual bool offline_mode() const { return offline_mode_; }", "target": 0}
{"code": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "reg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0)\n\treturn FALSE;\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n    if (mode == 'v')\n    {\n\tcol = (colnr_T)(rex.input - rex.line);\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\tcols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static int TraceLineTo(FT_Vector *to,DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n  char\n    path[MagickPathExtent];\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"L%g,%g\",affine.tx+to->x/64.0,\n    affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}", "target": 0}
{"code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n \t\tnew->ns = ns;\n \t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n \t\tspin_lock_irq(&ucounts_lock);\n \t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n \t\t\tucounts = new;\n \t\t}\n \t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n \t\tucounts = NULL;\n \tspin_unlock_irq(&ucounts_lock);\n \treturn ucounts;\n }", "target": 1}
{"code": "int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  char **_filter, char ***_domains)\n{\n    int ret;\n    struct match_map_rule *r;\n    struct priority_list *p;\n    struct sss_cert_content *cert_content = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    size_t c;\n    if (_filter == NULL || _domains == NULL) {\n        return EINVAL;\n    }\n    ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content);\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to get certificate content [%d].\", ret);\n        return ret;\n    }\n    if (ctx->prio_list == NULL) {\n        if (ctx->default_mapping_rule == NULL) {\n            CM_DEBUG(ctx, \"No matching or mapping rules available.\");\n            return EINVAL;\n        }\n        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, &filter);\n        goto done;\n    }\n    for (p = ctx->prio_list; p != NULL; p = p->next) {\n        for (r = p->rule_list; r != NULL; r = r->next) {\n            ret = do_match(ctx, r->parsed_match_rule, cert_content);\n            if (ret == 0) {\n                ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n                                 &filter);\n                if (ret != 0) {\n                    CM_DEBUG(ctx, \"Failed to get filter\");\n                    goto done;\n                }\n                if (r->domains != NULL) {\n                    for (c = 0; r->domains[c] != NULL; c++);\n                    domains = talloc_zero_array(ctx, char *, c + 1);\n                    if (domains == NULL) {\n                        ret = ENOMEM;\n                        goto done;\n                    }\n                    for (c = 0; r->domains[c] != NULL; c++) {\n                        domains[c] = talloc_strdup(domains, r->domains[c]);\n                        if (domains[c] == NULL) {\n                            ret = ENOMEM;\n                            goto done;\n                        }\n                    }\n                }\n                ret = 0;\n                goto done;\n            }\n        }\n    }\n    ret = ENOENT;\ndone:\n    talloc_free(cert_content);\n    if (ret == 0) {\n        *_filter = filter;\n        *_domains = domains;\n    } else {\n        talloc_free(filter);\n        talloc_free(domains);\n    }\n    return ret;\n}", "target": 1}
{"code": "Opal::Call::emit_setup_in_main ()\n{\n  setup ();\n}", "target": 0}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, TwoRegexSameFieldCovering) {\n    addIndex(BSON(\"a\" << 1));\n    runQuerySortProj(\n        fromjson(\"{$and: [{a: /0/}, {a: /1/}]}\"), BSONObj(), fromjson(\"{_id: 0, a: 1}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{cscan: {dir: 1, filter: {$and:[{a:/0/},{a:/1/}]}}}}}\");\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{ixscan: {filter: {$and:[{a:/0/},{a:/1/}]}, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "SWFShape_setLineStyle_internal(SWFShape shape, unsigned short width,\n                      byte r, byte g, byte b, byte a)\n{\n\tint line;\n\tif ( shape->isEnded )\n\t\treturn;\n\tfor ( line=0; line<shape->nLines; ++line )\n\t{\n\t\tif ( SWFLineStyle_equals(shape->lines[line], width, r, g, b, a, 0) )\n\t\t\tbreak;\n\t}\n\tif ( line == shape->nLines )\n\t\tline = SWFShape_addLineStyle(shape, width, r, g, b, a);\n\telse\n\t\t++line;\n\tfinishSetLine(shape, line, width);\n}", "target": 0}
{"code": "daemon_linux_lvm2_vg_set_name_authorized_cb (Daemon *daemon,\n                                             Device *device,\n                                             DBusGMethodInvocation *context,\n                                             const gchar *action_id,\n                                             guint num_user_data,\n                                             gpointer *user_data_elements)\n{\n  const gchar *uuid = user_data_elements[0];\n  const gchar *new_name = user_data_elements[1];\n  const gchar *vg_name;\n  guint n;\n  gchar *argv[10];\n  vg_name = find_lvm2_vg_name_for_uuid (daemon, uuid);\n  if (vg_name == NULL)\n    {\n      throw_error (context, ERROR_FAILED, \"Cannot find VG with UUID `%s'\", uuid);\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"vgrename\";\n  argv[n++] = (gchar *) vg_name;\n  argv[n++] = (gchar *) new_name;\n  argv[n++] = NULL;\n  if (!job_new (context, \"LinuxLvm2VGSetName\", TRUE, NULL, argv, NULL, linux_lvm2_vg_set_name_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)\n{\n  if (thd->locked_tables_mode != LTM_LOCK_TABLES)\n    return;\n  if (mdl_ticket)\n  {\n    thd->mdl_context.release_all_locks_for_name(mdl_ticket);\n  }\n  if (thd->lock->table_count == 0)\n    unlock_locked_tables(thd);\n}", "target": 0}
{"code": "static PHP_FUNCTION(libxml_clear_errors)\n{\n\txmlResetLastError();\n\tif (LIBXML(error_list)) {\n\t\tzend_llist_clean(LIBXML(error_list));\n\t}\n}", "target": 0}
{"code": "sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option)\n{\n    ALOGV(\"getFrameAtTime: time(%lld us) option(%d)\", timeUs, option);\n Mutex::Autolock lock(mLock);\n Mutex::Autolock glock(sLock);\n    mThumbnail.clear();\n if (mRetriever == NULL) {\n        ALOGE(\"retriever is not initialized\");\n return NULL;\n }\n VideoFrame *frame = mRetriever->getFrameAtTime(timeUs, option);\n if (frame == NULL) {\n        ALOGE(\"failed to capture a video frame\");\n return NULL;\n }\n size_t size = sizeof(VideoFrame) + frame->mSize;\n    sp<MemoryHeapBase> heap = new MemoryHeapBase(size, 0, \"MetadataRetrieverClient\");\n if (heap == NULL) {\n        ALOGE(\"failed to create MemoryDealer\");\n delete frame;\n return NULL;\n }\n    mThumbnail = new MemoryBase(heap, 0, size);\n if (mThumbnail == NULL) {\n        ALOGE(\"not enough memory for VideoFrame size=%u\", size);\n delete frame;\n return NULL;\n }\n VideoFrame *frameCopy = static_cast<VideoFrame *>(mThumbnail->pointer());\n    frameCopy->mWidth = frame->mWidth;\n    frameCopy->mHeight = frame->mHeight;\n    frameCopy->mDisplayWidth = frame->mDisplayWidth;\n    frameCopy->mDisplayHeight = frame->mDisplayHeight;\n    frameCopy->mSize = frame->mSize;\n    frameCopy->mRotationAngle = frame->mRotationAngle;\n     ALOGV(\"rotation: %d\", frameCopy->mRotationAngle);\n     frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);\n     memcpy(frameCopy->mData, frame->mData, frame->mSize);\n     delete frame;  \n     return mThumbnail;\n }", "target": 1}
{"code": "SPL_METHOD(SplHeap, isEmpty)\n{\n\tspl_heap_object *intern = (spl_heap_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"\") == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_BOOL(spl_ptr_heap_count(intern->heap)==0);\n}", "target": 0}
{"code": "GF_Err proj_type_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->layout = gf_bs_read_u32(bs);\n\t\tptr->padding = gf_bs_read_u32(bs);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->bounds_top = gf_bs_read_u32(bs);\n\t\tptr->bounds_bottom = gf_bs_read_u32(bs);\n\t\tptr->bounds_left = gf_bs_read_u32(bs);\n\t\tptr->bounds_right = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->crc = gf_bs_read_u32(bs);\n\t\tptr->encoding_4cc = gf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "is_left_anchor(int anc)\n{\n  if (anc == ANCHOR_END_BUF || anc == ANCHOR_SEMI_END_BUF ||\n      anc == ANCHOR_END_LINE || anc == ANCHOR_PREC_READ ||\n      anc == ANCHOR_PREC_READ_NOT)\n    return 0;\n  return 1;\n}", "target": 0}
{"code": "bool AudioContext::isAudioThread() const\n{\n    return currentThread() == m_audioThread;\n}", "target": 0}
{"code": "void QuotaManager::DeleteOriginFromDatabase(\n    const GURL& origin, StorageType type) {\n  LazyInitialize();\n  if (db_disabled_)\n    return;\n  scoped_refptr<DeleteOriginInfo> task =\n      new DeleteOriginInfo(this, origin, type);\n  task->Start();\n}", "target": 0}
{"code": "Eina_Bool ewk_view_setting_resizable_textareas_set(Evas_Object* ewkView, Eina_Bool enable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    enable = !!enable;\n    if (priv->settings.resizableTextareas != enable) {\n        priv->pageSettings->setTextAreasAreResizable(enable);\n        priv->settings.resizableTextareas = enable;\n    }\n    return true;\n}", "target": 0}
{"code": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \tif (num_clips && clips_ptr) {\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}", "target": 1}
{"code": "void __init psi_init(void)\n{\n\tif (!psi_enable) {\n\t\tstatic_branch_enable(&psi_disabled);\n\t\treturn;\n\t}\n\tpsi_period = jiffies_to_nsecs(PSI_FREQ);\n\tgroup_init(&psi_system);\n}", "target": 0}
{"code": "static int override_release(char __user *release, int len)\n {\n \tint ret = 0;\n\tchar buf[65];\n \tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n \t\tint ndots = 0;\n \t\tunsigned v;\n \t\twhile (*rest) {\n \t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n \t\t\trest++;\n \t\t}\n \t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n \t}\n \treturn ret;\n }", "target": 1}
{"code": "int perf_event_overflow(struct perf_event *event,\n\t\t\t  struct perf_sample_data *data,\n\t\t\t  struct pt_regs *regs)\n{\n\treturn __perf_event_overflow(event, 1, data, regs);\n}", "target": 0}
{"code": "static int task_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\tif (event->attr.config != PERF_COUNT_SW_TASK_CLOCK)\n\t\treturn -ENOENT;\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\tperf_swevent_init_hrtimer(event);\n\treturn 0;\n}", "target": 0}
{"code": "R_API int r_io_bank_read_from_submap_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tr_return_val_if_fail (io, -1);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn 0;\n\t}\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_R)) {\n\t\treturn -1;\n\t}\n\tconst int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tif (map->perm & R_PERM_RELOC) {\n\t\treturn map->reloc_map->read (io, map, addr, buf, read_len);\n\t}\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_read_at (io, map->fd, paddr, buf, read_len);\n}", "target": 1}
{"code": "check_entry_for_referral(Slapi_PBlock *pb, Slapi_Entry *entry, char *matched, const char *callingfn) \n{\n\tint rc=0, i=0, numValues=0;\n\tSlapi_Attr *attr;\n\tSlapi_Value *val=NULL;\t\n\tstruct berval **refscopy=NULL;\n\tstruct berval **url=NULL;\n\tif ( slapi_entry_attr_find( entry, \"ref\", &attr ) )\n\t{\n\t\tgoto out;\n\t}\n\tslapi_attr_get_numvalues(attr, &numValues );\n\tif(numValues == 0) {\n\t\tgoto out;\n\t}\n\turl=(struct berval **) slapi_ch_malloc((numValues + 1) * sizeof(struct berval*));\n\tif (!url) {\n\t\tLDAPDebug( LDAP_DEBUG_ANY,\n\t\t\t\"check_entry_for_referral: Out of memory\\n\",\n\t\t\t0, 0, 0);\n\t\tgoto out;\n\t}\n\tfor (i = slapi_attr_first_value(attr, &val); i != -1;\n\t     i = slapi_attr_next_value(attr, i, &val)) {\n\t\turl[i]=(struct berval*)slapi_value_get_berval(val);\n\t}\n\turl[numValues]=NULL;\t\t\n\trefscopy = ref_adjust( pb, url, slapi_entry_get_sdn(entry), 0 ); \n\tslapi_send_ldap_result( pb, LDAP_REFERRAL, matched, NULL, 0, refscopy );\n\trc= 1;\n\tLDAPDebug( LDAP_DEBUG_TRACE,\n\t\t\"<= %s sent referral to (%s) for (%s)\\n\",\n\t\tcallingfn,\n\t\trefscopy ? refscopy[0]->bv_val : \"\",\n\t\tslapi_entry_get_dn(entry));\nout:\n\tif ( refscopy != NULL )\n\t{\n\t\tber_bvecfree( refscopy );\n\t}\n\tif( url != NULL) {\n\t\tslapi_ch_free( (void **)&url );\t\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static int __init memory_tier_init(void)\n{\n\tint ret, node;\n\tstruct memory_tier *memtier;\n\tret = subsys_virtual_register(&memory_tier_subsys, NULL);\n\tif (ret)\n\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);\n#ifdef CONFIG_MIGRATION\n\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),\n\t\t\t\tGFP_KERNEL);\n\tWARN_ON(!node_demotion);\n#endif\n\tmutex_lock(&memory_tier_lock);\n\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n\tif (!default_dram_type)\n\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);\n\tfor_each_node_state(node, N_MEMORY) {\n\t\tmemtier = set_node_memory_tier(node);\n\t\tif (IS_ERR(memtier))\n\t\t\tbreak;\n\t}\n\testablish_demotion_targets();\n\tmutex_unlock(&memory_tier_lock);\n\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);\n\treturn 0;\n}", "target": 1}
{"code": "void InstanceKlass::set_package(ClassLoaderData* loader_data, TRAPS) {\n  check_prohibited_package(name(), loader_data, CHECK);\n  TempNewSymbol pkg_name = package_from_name(name(), CHECK);\n  if (pkg_name != NULL && loader_data != NULL) {\n    _package_entry = loader_data->packages()->lookup_only(pkg_name);\n    if (_package_entry == NULL) {\n      ResourceMark rm;\n      if (!ModuleEntryTable::javabase_defined()) {\n        assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME \" module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n      } else {\n        assert(loader_data->unnamed_module() != NULL, \"unnamed module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name,\n                                                         loader_data->unnamed_module());\n      }\n      assert(_package_entry != NULL, \"Package entry for class %s not found, loader %s\",\n             name()->as_C_string(), loader_data->loader_name_and_id());\n    }\n    if (log_is_enabled(Debug, module)) {\n      ResourceMark rm;\n      ModuleEntry* m = _package_entry->module();\n      log_trace(module)(\"Setting package: class: %s, package: %s, loader: %s, module: %s\",\n                        external_name(),\n                        pkg_name->as_C_string(),\n                        loader_data->loader_name_and_id(),\n                        (m->is_named() ? m->name()->as_C_string() : UNNAMED_MODULE));\n    }\n  } else {\n    ResourceMark rm;\n    log_trace(module)(\"Setting package: class: %s, package: unnamed, loader: %s, module: %s\",\n                      external_name(),\n                      (loader_data != NULL) ? loader_data->loader_name_and_id() : \"NULL\",\n                      UNNAMED_MODULE);\n  }\n}", "target": 0}
{"code": "int main_configure(char *arg1, char *arg2) {\n    int cmdline_status;\n    cmdline_status=options_cmdline(arg1, arg2);\n    if(cmdline_status) \n        return cmdline_status;\n    options_apply();\n    str_canary_init(); \n    log_open(SINK_SYSLOG);\n    if(bind_ports())\n        return 1;\n#ifdef HAVE_CHROOT\n    if(change_root())\n        return 1;\n#endif \n    if(drop_privileges(1))\n        return 1;\n    if(log_open(SINK_OUTFILE))\n        return 1;\n#ifndef USE_FORK\n    num_clients=0; \n#endif\n    log_flush(LOG_MODE_CONFIGURED);\n    return 0;\n}", "target": 1}
{"code": "  virtual bool ethernet_available() const { return true; }", "target": 0}
{"code": "auth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n \tstatic int expire_checked = 0;\n #endif\n #ifndef HAVE_CYGWIN\n \tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n \t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "target": 1}
{"code": "static Jsi_RC SysGetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    extern char **environ;\n    char *cp;\n    int i;\n    if (interp->isSafe)\n        return Jsi_LogError(\"no getenv in safe mode\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v != NULL) {\n        const char *fnam = Jsi_ValueString(interp, v, NULL);\n        if (!fnam) \n            return Jsi_LogError(\"arg1: expected string 'name'\");\n        cp = getenv(fnam);\n        if (cp != NULL) {\n            Jsi_ValueMakeStringDup(interp, ret, cp);\n        }\n        return JSI_OK;\n    }\n    Jsi_Value *vres;\n    Jsi_Obj  *ores = Jsi_ObjNew(interp);\n    Jsi_Value *nnv;\n    char *val, nam[200];\n    vres = Jsi_ValueMakeObject(interp, NULL, ores);\n    for (i=0; ; i++) {\n        int n;\n        cp = environ[i];\n        if (cp == 0 || ((val = Jsi_Strchr(cp, '='))==NULL))\n            break;\n        n = val-cp+1;\n        if (n>=(int)sizeof(nam))\n            n = sizeof(nam)-1;\n        Jsi_Strncpy(nam, cp, n);\n        val = val+1;\n        nnv = Jsi_ValueMakeStringDup(interp, NULL, val);\n        Jsi_ObjInsert(interp, ores, nam, nnv, 0);\n    }\n    Jsi_ValueReplace(interp, ret, vres);\n    return JSI_OK;\n}", "target": 1}
{"code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\tmmu_notifier_release(mm);\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\tarch_exit_mmap(mm);\n\tvma = mm->mmap;\n\tif (!vma)\t\n\t\treturn;\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tunmap_vmas(&tlb, vma, 0, -1);\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}", "target": 1}
{"code": "jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\n {\n \tjas_matrix_t *matrix;\n \tassert(xstart <= xend && ystart <= yend);\n\tif (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {\n\t\treturn 0;\n\t}\n\tmatrix->xstart_ = xstart;\n\tmatrix->ystart_ = ystart;\n\tmatrix->xend_ = xend;\n\tmatrix->yend_ = yend;\n \treturn matrix;\n }", "target": 1}
{"code": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromLocalPort(port);\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}", "target": 1}
{"code": "soup_server_unpause_message (SoupServer *server,\n\t\t\t     SoupMessage *msg)\n{\n\tg_return_if_fail (SOUP_IS_SERVER (server));\n\tg_return_if_fail (SOUP_IS_MESSAGE (msg));\n\tsoup_message_io_unpause (msg);\n}", "target": 0}
{"code": "static int ssl_get_remaining_space_in_datagram( mbedtls_ssl_context const *ssl )\n{\n    size_t const bytes_written = ssl->out_left;\n    size_t const mtu           = ssl_get_maximum_datagram_size( ssl );\n    if( bytes_written > mtu )\n    {\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n    return( (int) ( mtu - bytes_written ) );\n}", "target": 0}
{"code": "dhcpv6_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint16_t type, optlen;\n     i = 0;\n     while (i < length) {\n         tlv = cp + i;\n         type = EXTRACT_16BITS(tlv);\n         optlen = EXTRACT_16BITS(tlv + 2);\n        value = tlv + 4;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n         ND_PRINT((ndo, \"%s\", tok2str(dh6opt_str, \"Unknown\", type)));\n         ND_PRINT((ndo,\" (%u)\", optlen + 4 ));\n         switch (type) {\n             case DH6OPT_DNS_SERVERS:\n            case DH6OPT_SNTP_SERVERS: {\n                if (optlen % 16 != 0) {\n                    ND_PRINT((ndo, \" %s\", istr));\n                    return -1;\n                }\n                for (t = 0; t < optlen; t += 16)\n                    ND_PRINT((ndo, \" %s\", ip6addr_string(ndo, value + t)));\n            }\n                break;\n            case DH6OPT_DOMAIN_LIST: {\n                const u_char *tp = value;\n                while (tp < value + optlen) {\n                    ND_PRINT((ndo, \" \"));\n                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                        return -1;\n                }\n            }\n                break;\n        }\n        i += 4 + optlen;\n    }\n    return 0;\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteType output_type = GetOutput(context, node, kOutputTensor)->type;\n  switch (output_type) {  \n    case kTfLiteFloat32:\n      EvalUnquantized<float>(context, node);\n      break;\n    case kTfLiteInt32:\n      EvalUnquantized<int32_t>(context, node);\n      break;\n    case kTfLiteUInt8:\n      EvalQuantizedUInt8(context, node);\n      break;\n    case kTfLiteInt8:\n      EvalUnquantized<int8_t>(context, node);\n      break;\n    case kTfLiteInt64:\n      EvalUnquantized<int64_t>(context, node);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Op Concatenation does not currently support Type '%s'.\",\n          TfLiteTypeGetName(output_type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "void FrameLoader::clientRedirectCancelledOrFinished(bool cancelWithLoadInProgress)\n{\n    m_client->dispatchDidCancelClientRedirect();\n    if (!cancelWithLoadInProgress)\n        m_quickRedirectComing = false;\n    m_sentRedirectNotification = false;\n}", "target": 0}
{"code": "concat_opt_exact_info_str(OptExactInfo* to, UChar* s, UChar* end,\n\t\t\t  int raw ARG_UNUSED, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p, end);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n  to->len = i;\n}", "target": 0}
{"code": "void RenderView::removeAutofillSuggestions(const WebString& name,\n                                           const WebString& value) {\n  autofill_helper_.RemoveAutocompleteSuggestion(name, value);\n}", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n         avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n         return AVERROR_PATCHWELCOME;\n     }\n    if (item_num > 65536) {\n         av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n         return AVERROR_INVALIDDATA;\n     }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "systemd_unit_name_escape (const gchar *in)\n{\n  GString * const str = g_string_sized_new (strlen (in));\n  for (; *in; in++)\n    {\n      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')\n        g_string_append_c (str, *in);\n      else\n        g_string_append_printf (str, \"\\\\x%02x\", *in);\n    }\n  return g_string_free (str, FALSE);\n}", "target": 0}
{"code": "onig_init_for_match_at(regex_t* reg)\n{\n  return match_at(reg, (const UChar* )NULL, (const UChar* )NULL,\n                  (const UChar* )NULL, (const UChar* )NULL, (UChar* )NULL,\n                  (MatchArg* )NULL);\n}", "target": 0}
{"code": "FontData::FontData(ByteArray* ba) {\n  Init(ba);\n}", "target": 0}
{"code": "local block_state deflate_huff(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n    for (;;) {\n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      \n            }\n        }\n        s->match_length = 0;\n        Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        value += (1 << zeroes) - 1;\n    }\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n    *write_to = value;\n    return 0;\n}", "target": 1}
{"code": "void ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn;\n\tWLog_INFO(TAG, \"AV_PAIRs =\");\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)\n\t{\n\t\tWLog_INFO(TAG, \"\\t%s AvId: %\" PRIu16 \" AvLen: %\" PRIu16 \"\",\n\t\t          AV_PAIR_STRINGS[ntlm_av_pair_get_id(pAvPair)], ntlm_av_pair_get_id(pAvPair),\n\t\t          ntlm_av_pair_get_len(pAvPair));\n\t\twinpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair),\n\t\t              ntlm_av_pair_get_len(pAvPair));\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n}", "target": 1}
{"code": "entry_guard_obeys_restriction(const entry_guard_t *guard,\n                              const entry_guard_restriction_t *rst)\n{\n  tor_assert(guard);\n   if (! rst)\n     return 1; \n   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n }", "target": 1}
{"code": "grub_password_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\tbuf[cur_len++] = key;\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "GF_Err gitn_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tptr->size += 2;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->entries[i].name) ptr->size += strlen(ptr->entries[i].name);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void encode_setattr(struct xdr_stream *xdr, const struct nfs_setattrargs *arg, const struct nfs_server *server, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SETATTR, decode_setattr_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &arg->stateid);\n\tencode_attrs(xdr, arg->iap, server);\n}", "target": 0}
{"code": "void dummy_error_processor(THD *thd, void *data)\n{}", "target": 0}
{"code": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "void CSSStyleSheet::addSubresourceStyleURLs(ListHashSet<KURL>& urls)\n{\n    Deque<CSSStyleSheet*> styleSheetQueue;\n    styleSheetQueue.append(this);\n    while (!styleSheetQueue.isEmpty()) {\n        CSSStyleSheet* styleSheet = styleSheetQueue.takeFirst();\n        for (unsigned i = 0; i < styleSheet->length(); ++i) {\n            StyleBase* styleBase = styleSheet->item(i);\n            if (!styleBase->isRule())\n                continue;\n            CSSRule* rule = static_cast<CSSRule*>(styleBase);\n            if (rule->isImportRule()) {\n                if (CSSStyleSheet* ruleStyleSheet = static_cast<CSSImportRule*>(rule)->styleSheet())\n                    styleSheetQueue.append(ruleStyleSheet);\n            }\n            rule->addSubresourceStyleURLs(urls);\n        }\n    }\n}", "target": 0}
{"code": "void ThreadWatcherList::GetStatusOfThreads(uint32* responding_thread_count,\n                                           uint32* unresponding_thread_count) {\n  DCHECK(WatchDogThread::CurrentlyOnWatchDogThread());\n  *responding_thread_count = 0;\n  *unresponding_thread_count = 0;\n  if (!g_thread_watcher_list_)\n    return;\n  for (RegistrationList::iterator it =\n           g_thread_watcher_list_->registered_.begin();\n       g_thread_watcher_list_->registered_.end() != it;\n       ++it) {\n    if (it->second->IsVeryUnresponsive())\n      ++(*unresponding_thread_count);\n    else\n      ++(*responding_thread_count);\n  }\n}", "target": 0}
{"code": "static int fbcon_set_font(struct vc_data *vc, struct console_font *font,\n\t\t\t  unsigned int flags)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tunsigned charcount = font->charcount;\n\tint w = font->width;\n\tint h = font->height;\n\tint size;\n\tint i, csum;\n\tu8 *new_data, *data = font->data;\n\tint pitch = PITCH(font->width);\n\tif (charcount != 256 && charcount != 512)\n\t\treturn -EINVAL;\n\tif (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||\n\t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))\n\t\treturn -EINVAL;\n\tif (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||\n\t    !(info->pixmap.blit_y & (1 << (font->height - 1))))\n\t\treturn -EINVAL;\n\tif (fbcon_invalid_charcount(info, charcount))\n\t\treturn -EINVAL;\n\tsize = CALC_FONTSZ(h, pitch, charcount);\n\tnew_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));\n\tnew_data += FONT_EXTRA_WORDS * sizeof(int);\n\tFNTSIZE(new_data) = size;\n\tREFCOUNT(new_data) = 0;\t\n\tfor (i=0; i< charcount; i++) {\n\t\tmemcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);\n\t}\n\tcsum = crc32(0, new_data, size);\n\tFNTSUM(new_data) = csum;\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tstruct vc_data *tmp = vc_cons[i].d;\n\t\tif (fb_display[i].userfont &&\n\t\t    fb_display[i].fontdata &&\n\t\t    FNTSUM(fb_display[i].fontdata) == csum &&\n\t\t    FNTSIZE(fb_display[i].fontdata) == size &&\n\t\t    tmp->vc_font.width == w &&\n\t\t    !memcmp(fb_display[i].fontdata, new_data, size)) {\n\t\t\tkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\n\t\t\tnew_data = (u8 *)fb_display[i].fontdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);\n}", "target": 1}
{"code": "static int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tcp2112_gpio_set(chip, offset, value);\n\treturn 0;\nfail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret < 0 ? ret : -EIO;\n}", "target": 1}
{"code": "op2name(int opcode)\n{\n  int i;\n  for (i = 0; OpInfo[i].opcode >= 0; i++) {\n    if (opcode == OpInfo[i].opcode) return OpInfo[i].name;\n  }\n  return \"\";\n}", "target": 0}
{"code": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, BasicCompound) {\n    addIndex(BSON(\"x\" << 1 << \"y\" << 1));\n    runQuery(fromjson(\"{ x : 5, y: 10}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: \"\n        \"{filter: null, pattern: {x: 1, y: 1}}}}}\");\n}", "target": 0}
{"code": "INST_HANDLER (cpse) {\t\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "    size_t Iptcdatum::size() const\n    {\n        return value_.get() == 0 ? 0 : value_->size();\n    }", "target": 0}
{"code": "unsigned long gfn_to_hva_prot(struct kvm *kvm, gfn_t gfn, bool *writable)\n{\n\tstruct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);\n\treturn gfn_to_hva_memslot_prot(slot, gfn, writable);\n}", "target": 0}
{"code": "decrypt(gcry_mpi_t output, gcry_mpi_t a, gcry_mpi_t b, ELG_secret_key *skey )\n{\n  gcry_mpi_t t1 = mpi_alloc_secure( mpi_get_nlimbs( skey->p ) );\n  gcry_mpi_powm( t1, a, skey->x, skey->p );\n  mpi_invm( t1, t1, skey->p );\n  mpi_mulm( output, b, t1, skey->p );\n#if 0\n  if( DBG_CIPHER )\n    {\n      log_mpidump(\"elg decrypted x= \", skey->x);\n      log_mpidump(\"elg decrypted p= \", skey->p);\n      log_mpidump(\"elg decrypted a= \", a);\n      log_mpidump(\"elg decrypted b= \", b);\n      log_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n  mpi_free(t1);\n}", "target": 1}
{"code": "  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n    currentBuffer.length = len;\n    wcb_->setSocket(socket_);\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n  }", "target": 1}
{"code": "GF_Err gf_filter_add_event_listener(GF_Filter *filter, GF_FSEventListener *el)\n{\n\tGF_Err e;\n\tif (!filter || !filter->session || !el || !el->on_event) return GF_BAD_PARAM;\n\twhile (filter->session->in_event_listener) gf_sleep(1);\n\tgf_mx_p(filter->session->evt_mx);\n\tif (!filter->session->event_listeners) {\n\t\tfilter->session->event_listeners = gf_list_new();\n\t}\n\te = gf_list_add(filter->session->event_listeners, el);\n\tgf_mx_v(filter->session->evt_mx);\n\treturn e;\n}", "target": 0}
{"code": "void BaseAudioContext::Trace(blink::Visitor* visitor) {\n  visitor->Trace(destination_node_);\n  visitor->Trace(listener_);\n  visitor->Trace(active_source_nodes_);\n  visitor->Trace(resume_resolvers_);\n  visitor->Trace(decode_audio_resolvers_);\n  visitor->Trace(periodic_wave_sine_);\n  visitor->Trace(periodic_wave_square_);\n  visitor->Trace(periodic_wave_sawtooth_);\n  visitor->Trace(periodic_wave_triangle_);\n  visitor->Trace(audio_worklet_);\n  EventTargetWithInlineData::Trace(visitor);\n  PausableObject::Trace(visitor);\n}", "target": 0}
{"code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "static int proc_root_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(dentry->d_inode);\n\tint result = -ENOENT;\n\tif (task) {\n\t\tresult = get_task_root(task, path);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}", "target": 0}
{"code": "static uint32_t dp8393x_wt(dp8393xState *s)\n{\n    return s->regs[SONIC_WT1] << 16 | s->regs[SONIC_WT0];\n}", "target": 0}
{"code": "pam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n  D((\"Called and Exit\"));\n  return PAM_SUCCESS;\n}", "target": 0}
{"code": "nfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\tif (sfsname) {\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}", "target": 1}
{"code": "gx_default_update_spot_equivalent_colors(gx_device *pdev, const gs_gstate * pgs)\n{\n    return 0;\n}", "target": 0}
{"code": "_dbus_win_set_errno (int err)\n{\n#ifdef DBUS_WINCE\n  SetLastError (err);\n#else\n  errno = err;\n#endif\n}", "target": 0}
{"code": "onig_is_prelude(void)\n{\n    return !rb_const_defined(rb_cThread, rb_intern_const(\"MUTEX_FOR_THREAD_EXCLUSIVE\"));\n}", "target": 0}
{"code": "void FileSystemOperation::DidFileExists(\n    const StatusCallback& callback,\n    base::PlatformFileError rv,\n    const base::PlatformFileInfo& file_info,\n    const FilePath& unused) {\n  if (rv == base::PLATFORM_FILE_OK && file_info.is_directory)\n    rv = base::PLATFORM_FILE_ERROR_NOT_A_FILE;\n  callback.Run(rv);\n}", "target": 0}
{"code": "void ChangeListLoader::LoadChangeListFromServer(int64 start_changestamp) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!change_feed_fetcher_);\n  DCHECK(cached_about_resource_);\n  bool is_delta_update = start_changestamp != 0;\n  if (is_delta_update) {\n    change_feed_fetcher_.reset(\n        new DeltaFeedFetcher(scheduler_, start_changestamp));\n  } else {\n    change_feed_fetcher_.reset(new FullFeedFetcher(scheduler_));\n  }\n  change_feed_fetcher_->Run(\n      base::Bind(&ChangeListLoader::LoadChangeListFromServerAfterLoadChangeList,\n                 weak_ptr_factory_.GetWeakPtr(),\n                 base::Passed(make_scoped_ptr(\n                     new google_apis::AboutResource(*cached_about_resource_))),\n                 is_delta_update));\n}", "target": 0}
{"code": "static int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs;\n\tstruct inode *inode = page->mapping->host;\n\ttrace_ext4_writepage(inode, page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tif (page_has_buffers(page)) {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tret = block_prepare_write(page, 0, len,\n\t\t\t\t\t  noalloc_get_block_write);\n\t\tif (!ret) {\n\t\t\tpage_bufs = page_buffers(page);\n\t\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tunlock_page(page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tblock_commit_write(page, 0, len);\n\t}\n\tif (PageChecked(page) && ext4_should_journal_data(inode)) {\n\t\tClearPageChecked(page);\n\t\treturn __ext4_journalled_writepage(page, len);\n\t}\n\tif (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))\n\t\tret = nobh_writepage(page, noalloc_get_block_write, wbc);\n\telse\n\t\tret = block_write_full_page(page, noalloc_get_block_write,\n\t\t\t\t\t    wbc);\n\treturn ret;\n}", "target": 1}
{"code": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j, bl;\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        i = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (i < 0)\n            return 0;\n        else\n            *outl = i;\n        return 1;\n    }\n    if (inl <= 0) {\n        *outl = 0;\n        return inl == 0;\n    }\n    if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\n        if (ctx->cipher->do_cipher(ctx, out, in, inl)) {\n            *outl = inl;\n            return 1;\n        } else {\n            *outl = 0;\n            return 0;\n        }\n    }\n    i = ctx->buf_len;\n     bl = ctx->cipher->block_size;\n     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n     if (i != 0) {\n        if (i + inl < bl) {\n             memcpy(&(ctx->buf[i]), in, inl);\n             ctx->buf_len += inl;\n             *outl = 0;\n            return 1;\n        } else {\n            j = bl - i;\n            memcpy(&(ctx->buf[i]), in, j);\n            if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))\n                return 0;\n            inl -= j;\n            in += j;\n            out += bl;\n            *outl = bl;\n        }\n    } else\n        *outl = 0;\n    i = inl & (bl - 1);\n    inl -= i;\n    if (inl > 0) {\n        if (!ctx->cipher->do_cipher(ctx, out, in, inl))\n            return 0;\n        *outl += inl;\n    }\n    if (i != 0)\n        memcpy(ctx->buf, &(in[inl]), i);\n    ctx->buf_len = i;\n    return 1;\n}", "target": 1}
{"code": "st_init_numtable_with_size(st_index_t size)\n{\n    return st_init_table_with_size(&type_numhash, size);\n}", "target": 0}
{"code": " unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,\n \t\t      const nodemask_t *nodemask, unsigned long totalpages)\n {\n\tint points;\n \tif (oom_unkillable_task(p, mem, nodemask))\n \t\treturn 0;\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\tif (atomic_read(&p->mm->oom_disable_count)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\tif (!totalpages)\n\t\ttotalpages = 1;\n\tpoints = get_mm_rss(p->mm) + p->mm->nr_ptes;\n\tpoints += get_mm_counter(p->mm, MM_SWAPENTS);\n\tpoints *= 1000;\n\tpoints /= totalpages;\n\ttask_unlock(p);\n\tif (has_capability_noaudit(p, CAP_SYS_ADMIN))\n\t\tpoints -= 30;\n\tpoints += p->signal->oom_score_adj;\n\tif (points <= 0)\n\t\treturn 1;\n\treturn (points < 1000) ? points : 1000;\n}", "target": 1}
{"code": "  CookieHashMethod(const std::string& key, const std::string& path,\n                   const absl::optional<std::chrono::seconds>& ttl, bool terminal,\n                   const CookieAttributeRefVector attributes)\n      : HashMethodImplBase(terminal), key_(key), path_(path), ttl_(ttl), attributes_(attributes) {}", "target": 1}
{"code": "  UpdatePersistentHostQuotaTask(\n      QuotaManager* manager,\n      const std::string& host,\n      int new_quota,\n      HostQuotaCallback* callback)\n      : DatabaseTaskBase(manager),\n        host_(host),\n        new_quota_(new_quota),\n        callback_(callback) {\n    DCHECK_GE(new_quota_, 0);\n  }", "target": 0}
{"code": "PositionTemplate<Strategy> DownstreamIgnoringEditingBoundaries(\n    PositionTemplate<Strategy> position) {\n  PositionTemplate<Strategy> last_position;\n  while (!position.IsEquivalent(last_position)) {\n    last_position = position;\n    position = MostForwardCaretPosition(position, kCanCrossEditingBoundary);\n  }\n  return position;\n}", "target": 0}
{"code": "static bool reg_type_mismatch(enum bpf_reg_type src, enum bpf_reg_type prev)\n{\n\treturn src != prev && (!reg_type_mismatch_ok(src) ||\n\t\t\t       !reg_type_mismatch_ok(prev));\n}", "target": 0}
{"code": "vcard_apdu_new(unsigned char *raw_apdu, int len, vcard_7816_status_t *status)\n{\n    VCardAPDU *new_apdu;\n    *status = VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE;\n    if (len < 4) {\n        *status = VCARD7816_STATUS_ERROR_WRONG_LENGTH;\n        return NULL;\n    }\n    new_apdu = g_new(VCardAPDU, 1);\n    new_apdu->a_data = g_memdup(raw_apdu, len);\n     new_apdu->a_len = len;\n     *status = vcard_apdu_set_class(new_apdu);\n     if (*status != VCARD7816_STATUS_SUCCESS) {\n        g_free(new_apdu);\n         return NULL;\n     }\n     *status = vcard_apdu_set_length(new_apdu);\n     if (*status != VCARD7816_STATUS_SUCCESS) {\n        g_free(new_apdu);\n         new_apdu = NULL;\n     }\n     return new_apdu;\n}", "target": 1}
{"code": " Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)\n {\n     HTMLElement::insertedInto(insertionPoint);\n    return InsertionShouldCallDidNotifySubtreeInsertions;\n}\nvoid HTMLBodyElement::didNotifySubtreeInsertionsToDocument()\n{\n    Element* ownerElement = document().ownerElement();\n    if (!isHTMLFrameElementBase(ownerElement))\n        return;\n    HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);\n    int marginWidth = ownerFrameElement.marginWidth();\n    int marginHeight = ownerFrameElement.marginHeight();\n    if (marginWidth != -1)\n        setIntegralAttribute(marginwidthAttr, marginWidth);\n    if (marginHeight != -1)\n        setIntegralAttribute(marginheightAttr, marginHeight);\n }", "target": 0}
{"code": "    void CiffComponent::doPrint(std::ostream&      os,\n                                ByteOrder          byteOrder,\n                                const std::string& prefix) const\n    {\n        os << prefix\n           << _(\"tag\") << \" = 0x\" << std::setw(4) << std::setfill('0')\n           << std::hex << std::right << tagId()\n           << \", \" << _(\"dir\") << \" = 0x\" << std::setw(4) << std::setfill('0')\n           << std::hex << std::right << dir()\n           << \", \" << _(\"type\") << \" = \" << TypeInfo::typeName(typeId())\n           << \", \" << _(\"size\") << \" = \" << std::dec << size_\n           << \", \" << _(\"offset\") << \" = \" << offset_ << \"\\n\";\n        Value::UniquePtr value;\n        if (typeId() != directory) {\n            value = Value::create(typeId());\n            value->read(pData_, size_, byteOrder);\n            if (value->size() < 100) {\n                os << prefix << *value << \"\\n\";\n            }\n        }\n    } ", "target": 0}
{"code": "static wStream* rdg_receive_packet(rdpRdg* rdg)\n{\n\twStream* s;\n\tconst size_t header = sizeof(RdgPacketHeader);\n\tsize_t packetLength;\n\tassert(header <= INT_MAX);\n\ts = Stream_New(NULL, 1024);\n\tif (!s)\n\t\treturn NULL;\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s), header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tStream_Seek(s, 4);\n\tStream_Read_UINT32(s, packetLength);\n\tif ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s) + header, (int)packetLength - (int)header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tStream_SetLength(s, packetLength);\n\treturn s;\n}", "target": 1}
{"code": "int prepareForShutdown() {\n    redisLog(REDIS_WARNING,\"User requested shutdown, saving DB...\");\n    if (server.bgsavechildpid != -1) {\n        redisLog(REDIS_WARNING,\"There is a live saving child. Killing it!\");\n        kill(server.bgsavechildpid,SIGKILL);\n        rdbRemoveTempFile(server.bgsavechildpid);\n    }\n    if (server.appendonly) {\n        aof_fsync(server.appendfd);\n        if (server.vm_enabled) unlink(server.vm_swap_file);\n    } else if (server.saveparamslen > 0) {\n        if (rdbSave(server.dbfilename) != REDIS_OK) {\n            redisLog(REDIS_WARNING,\"Error trying to save the DB, can't exit\");\n            return REDIS_ERR;\n        }\n    } else {\n        redisLog(REDIS_WARNING,\"Not saving DB.\");\n    }\n    if (server.daemonize) unlink(server.pidfile);\n    redisLog(REDIS_WARNING,\"Server exit now, bye bye...\");\n    return REDIS_OK;\n}", "target": 1}
{"code": "xmlFreeElementTable(xmlElementTablePtr table) {\n    xmlHashFree(table, (xmlHashDeallocator) xmlFreeElement);\n}", "target": 0}
{"code": "static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent outI1: calculated ke+nonce, sending I1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "void GLES2DecoderImpl::DoEnable(GLenum cap) {\n  SetCapabilityState(cap, true);\n  glEnable(cap);\n}", "target": 0}
{"code": "void QuotaManager::DumpOriginInfoTable(\n    DumpOriginInfoTableCallback* callback) {\n  make_scoped_refptr(new DumpOriginInfoTableTask(this, callback))->Start();\n}", "target": 0}
{"code": "void QuotaManager::RegisterClient(QuotaClient* client) {\n  DCHECK(io_thread_->BelongsToCurrentThread());\n  DCHECK(!database_.get());\n  clients_.push_back(client);\n}", "target": 0}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static ext4_io_end_t *ext4_init_io_end (struct inode *inode)\n{\n\text4_io_end_t *io = NULL;\n\tio = kmalloc(sizeof(*io), GFP_NOFS);\n\tif (io) {\n\t\tigrab(inode);\n\t\tio->inode = inode;\n\t\tio->flag = 0;\n\t\tio->offset = 0;\n\t\tio->size = 0;\n\t\tio->error = 0;\n\t\tINIT_WORK(&io->work, ext4_end_io_work);\n\t\tINIT_LIST_HEAD(&io->list);\n\t}\n\treturn io;\n}", "target": 1}
{"code": "clear_cached_dir(cached_dir_t *d)\n{\n  tor_free(d->dir);\n  tor_free(d->dir_z);\n  memset(d, 0, sizeof(cached_dir_t));\n}", "target": 0}
{"code": "bool acpi_osi_is_win8(void)\n{\n\treturn acpi_gbl_osi_data >= ACPI_OSI_WIN_8;\n}", "target": 0}
{"code": "build_cert_bag (unsigned char *buffer, size_t buflen, char *salt,\n                size_t *r_length)\n{\n  size_t len[9], needed;\n  unsigned char *p, *certbag;\n  size_t certbaglen;\n  needed = compute_tag_length (buflen);\n  needed += buflen;\n  needed += DIM (data_rc2iter2048);\n  needed += 2 + DIM (oid_data);\n  len[5] = needed;\n  needed += compute_tag_length ( needed);\n  needed += 3;\n  len[3] = needed;\n  needed += compute_tag_length (needed);\n  len[2] = needed;\n  needed += compute_tag_length (needed);\n  needed += 2 + DIM (oid_encryptedData);\n  len[0] = needed;\n  needed += compute_tag_length (needed);\n  p = certbag = gcry_malloc (needed);\n  if (!certbag)\n    {\n      log_error (\"error allocating buffer\\n\");\n      return NULL;\n    }\n  p = store_tag_length (p, TAG_SEQUENCE, len[0]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_encryptedData));\n  memcpy (p, oid_encryptedData, DIM (oid_encryptedData));\n  p += DIM (oid_encryptedData);\n  p = store_tag_length (p, 0xa0, len[2]);\n  p = store_tag_length (p, TAG_SEQUENCE, len[3]);\n  *p++ = TAG_INTEGER;\n  *p++ = 1;\n  *p++ = 0;\n  p = store_tag_length (p, TAG_SEQUENCE, len[5]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_data));\n  memcpy (p, oid_data, DIM (oid_data));\n  p += DIM (oid_data);\n  memcpy (p, data_rc2iter2048, DIM (data_rc2iter2048));\n  memcpy (p + DATA_RC2ITER2048_SALT_OFF, salt, 8);\n  p += DIM (data_rc2iter2048);\n  p = store_tag_length (p, 0x80, buflen);\n  memcpy (p, buffer, buflen);\n  p += buflen;\n  certbaglen = p - certbag;\n  if (needed != certbaglen)\n    log_debug (\"length mismatch: %lu, %lu\\n\",\n               (unsigned long)needed, (unsigned long)certbaglen);\n  *r_length = certbaglen;\n  return certbag;\n}", "target": 0}
{"code": "static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,\n                                      X509_ALGOR **pmaskHash)\n{\n    const unsigned char *p;\n    int plen;\n    RSA_PSS_PARAMS *pss;\n    *pmaskHash = NULL;\n    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);\n    if (!pss)\n        return NULL;\n     if (pss->maskGenAlgorithm) {\n         ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;\n         if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1\n            && param->type == V_ASN1_SEQUENCE) {\n             p = param->value.sequence->data;\n             plen = param->value.sequence->length;\n             *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);\n        }\n    }\n    return pss;\n}", "target": 1}
{"code": "repodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n  if (!*schema)\n    return 0;\t\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}", "target": 1}
{"code": "rb_reg_last_match(VALUE match)\n{\n    return rb_reg_nth_match(0, match);\n}", "target": 0}
{"code": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\tif (!rdev->ena_pin)\n\t\treturn;\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n \t\t\t\tgpiod_put(pin->gpiod);\n \t\t\t\tlist_del(&pin->list);\n \t\t\t\tkfree(pin);\n \t\t\t} else {\n \t\t\t\tpin->request_count--;\n \t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "dirserv_free_fingerprint_list(void)\n{\n  if (!fingerprint_list)\n    return;\n  strmap_free(fingerprint_list->fp_by_name, _tor_free);\n  digestmap_free(fingerprint_list->status_by_digest, _tor_free);\n  tor_free(fingerprint_list);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, IntersectDisableAndHash) {\n    bool oldEnableHashIntersection = internalQueryPlannerEnableHashIntersection.load();\n    internalQueryPlannerEnableHashIntersection.store(false);\n    params.options = QueryPlannerParams::NO_TABLE_SCAN | QueryPlannerParams::INDEX_INTERSECTION;\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    addIndex(BSON(\"c\" << 1));\n    runQuery(fromjson(\"{a: {$gt: 1}, b: 1, c: 1}\"));\n    assertNumSolutions(4U);\n    assertSolutionExists(\n        \"{fetch: {filter: {b: 1, c: 1}, node: {ixscan: \"\n        \"{pattern: {a: 1}, bounds: {a: [[1,Infinity,false,true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {a:{$gt:1},c:1}, node: {ixscan: \"\n        \"{pattern: {b: 1}, bounds: {b: [[1,1,true,true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {a:{$gt:1},b:1}, node: {ixscan: \"\n        \"{pattern: {c: 1}, bounds: {c: [[1,1,true,true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {a:{$gt:1}, b: 1, c: 1}, node: {andSorted: {nodes: [\"\n        \"{ixscan: {filter: null, pattern: {b:1}}},\"\n        \"{ixscan: {filter: null, pattern: {c:1}}}]}}}}\");\n    internalQueryPlannerEnableHashIntersection.store(oldEnableHashIntersection);\n}", "target": 0}
{"code": "_asn1_delete_list_and_nodes (void)\n{\n  list_type *listElement;\n  while (firstElement)\n    {\n      listElement = firstElement;\n      firstElement = firstElement->next;\n      _asn1_remove_node (listElement->node, 0);\n      free (listElement);\n    }\n}", "target": 0}
{"code": "bool GLSurfaceOzoneSurfaceless::IsOffscreen() {\n  return false;\n}", "target": 0}
{"code": "pci_lintr_route(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct intxinfo *ii;\n\tif (dev->lintr.pin == 0)\n\t\treturn;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tii = &bi->slotinfo[dev->slot].si_intpins[dev->lintr.pin - 1];\n\tif (ii->ii_ioapic_irq == 0)\n\t\tii->ii_ioapic_irq = ioapic_pci_alloc_irq(dev);\n\tassert(ii->ii_ioapic_irq > 0);\n\tif (ii->ii_pirq_pin == 0)\n\t\tii->ii_pirq_pin = pirq_alloc_pin(dev);\n\tassert(ii->ii_pirq_pin > 0);\n\tdev->lintr.ioapic_irq = ii->ii_ioapic_irq;\n\tdev->lintr.pirq_pin = ii->ii_pirq_pin;\n\tpci_set_cfgdata8(dev, PCIR_INTLINE, pirq_irq(ii->ii_pirq_pin));\n}", "target": 1}
{"code": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n \tif (!addr)\n \t\treturn -ENODEV;\n\tio->io_cleanup = port_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n \t\t\treturn -EIO;\n \t\t}\n \t}\n \treturn 0;\n }", "target": 1}
{"code": "restore_backup_configuration (GsdXrandrManager *manager, const char *backup_filename, const char *intended_filename, guint32 timestamp)\n{\n        int saved_errno;\n        if (rename (backup_filename, intended_filename) == 0) {\n                GError *error;\n                error = NULL;\n                if (!apply_configuration_from_filename (manager, intended_filename, FALSE, timestamp, &error)) {\n                        error_message (manager, _(\"Could not restore the display's configuration\"), error, NULL);\n                        if (error)\n                                g_error_free (error);\n                }\n                return;\n        }\n        saved_errno = errno;\n        if (saved_errno == ENOENT)\n                unlink (intended_filename);\n        else {\n                char *msg;\n                msg = g_strdup_printf (\"Could not rename %s to %s: %s\",\n                                       backup_filename, intended_filename,\n                                       g_strerror (saved_errno));\n                error_message (manager,\n                               _(\"Could not restore the display's configuration from a backup\"),\n                               NULL,\n                               msg);\n                g_free (msg);\n        }\n        unlink (backup_filename);\n}", "target": 0}
{"code": "static char* getPreferredTag(const char* gf_tag)\n{ \n\tchar* result = NULL;\n\tint grOffset = 0;\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 1}
{"code": "static uint8 TIFFClampDoubleToUInt8( double val )\n{\n    if( val < 0 )\n        return 0;\n    if( val > 255 || val != val )\n        return 255;\n    return (uint8)val;\n}", "target": 0}
{"code": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n   mrb_bool failed = TRUE;\n   mrb_get_args(mrb, \"o\", &orig);\n   fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n   if (fptr_copy != NULL) {\n     fptr_finalize(mrb, fptr_copy, FALSE);\n     mrb_free(mrb, fptr_copy);\n   }\n   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n   DATA_TYPE(copy) = &mrb_io_type;\n   DATA_PTR(copy) = fptr_copy;\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n  return copy;\n}", "target": 1}
{"code": "sg_rq_end_io_usercontext(struct work_struct *work)\n{\n\tstruct sg_request *srp = container_of(work, struct sg_request, ew.work);\n\tstruct sg_fd *sfp = srp->parentfp;\n\tsg_finish_rem_req(srp);\n\tsg_remove_request(sfp, srp);\n\tkref_put(&sfp->f_ref, sg_remove_sfp);\n}", "target": 0}
{"code": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "copy_text_attr(\n    int\t\toff,\n    char_u\t*buf,\n    int\t\tlen,\n    int\t\tattr)\n{\n    int\t\ti;\n    mch_memmove(ScreenLines + off, buf, (size_t)len);\n    if (enc_utf8)\n\tvim_memset(ScreenLinesUC + off, 0, sizeof(u8char_T) * (size_t)len);\n    for (i = 0; i < len; ++i)\n\tScreenAttrs[off + i] = attr;\n}", "target": 0}
{"code": "static int jsR_delproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto dontconf;\n\t\tif (!strcmp(name, \"global\")) goto dontconf;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto dontconf;\n\t\tif (!strcmp(name, \"multiline\")) goto dontconf;\n\t\tif (!strcmp(name, \"lastIndex\")) goto dontconf;\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.delete && obj->u.user.delete(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\tref = jsV_getownproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->atts & JS_DONTCONF)\n\t\t\tgoto dontconf;\n\t\tjsV_delproperty(J, obj, name);\n\t}\n\treturn 1;\ndontconf:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\treturn 0;\n}", "target": 0}
{"code": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\titem->data = rdata;\n#ifndef OPENSSL_NO_SCTP\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\treturn(1);\n\t}", "target": 1}
{"code": "DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathLength, UINT32 id,\n                           UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,\n                           UINT32 FileAttributes, UINT32 SharedAccess)\n{\n\tDRIVE_FILE* file;\n\tif (!base_path || (!path && (PathLength > 0)))\n\t\treturn NULL;\n\tfile = (DRIVE_FILE*)calloc(1, sizeof(DRIVE_FILE));\n\tif (!file)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn NULL;\n\t}\n\tfile->file_handle = INVALID_HANDLE_VALUE;\n\tfile->find_handle = INVALID_HANDLE_VALUE;\n\tfile->id = id;\n\tfile->basepath = base_path;\n\tfile->FileAttributes = FileAttributes;\n\tfile->DesiredAccess = DesiredAccess;\n\tfile->CreateDisposition = CreateDisposition;\n\tfile->CreateOptions = CreateOptions;\n\tfile->SharedAccess = SharedAccess;\n\tdrive_file_set_fullpath(file, drive_file_combine_fullpath(base_path, path, PathLength));\n\tif (!drive_file_init(file))\n\t{\n\t\tDWORD lastError = GetLastError();\n\t\tdrive_file_free(file);\n\t\tSetLastError(lastError);\n\t\treturn NULL;\n\t}\n\treturn file;\n}", "target": 1}
{"code": "void scheduler_tick(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr = rq->curr;\n\tsched_clock_tick();\n\traw_spin_lock(&rq->lock);\n\tupdate_rq_clock(rq);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\tupdate_cpu_load_active(rq);\n\tcalc_global_load_tick(rq);\n\traw_spin_unlock(&rq->lock);\n\tperf_event_task_tick();\n#ifdef CONFIG_SMP\n\trq->idle_balance = idle_cpu(cpu);\n\ttrigger_load_balance(rq);\n#endif\n\trq_last_tick_reset(rq);\n}", "target": 0}
{"code": "static void FNAME_DECL(uncompress_row0_seg)(int i,\n                                            PIXEL * const cur_row,\n                                            const int end,\n                                            const unsigned int waitmask,\n                                            const unsigned int bpc_mask)\n{\n    DECLARE_STATE_VARIABLES;\n    DECLARE_CHANNEL_VARIABLES;\n    int stopidx;\n    spice_assert(end - i > 0);\n    if (i == 0) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0_0);\n        if (state->waitcnt) {\n            --state->waitcnt;\n        } else {\n            state->waitcnt = (tabrand(&state->tabrand_seed) & waitmask);\n            UPDATE_MODEL(0);\n        }\n        stopidx = ++i + state->waitcnt;\n    } else {\n        stopidx = i + state->waitcnt;\n    }\n    while (stopidx < end) {\n        for (; i <= stopidx; i++) {\n            unsigned int codewordlen;\n            UNCOMPRESS_PIX_START(&cur_row[i]);\n            APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n        }\n        UPDATE_MODEL(stopidx);\n        stopidx = i + (tabrand(&state->tabrand_seed) & waitmask);\n    }\n    for (; i < end; i++) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n    }\n    state->waitcnt = stopidx - end;\n}", "target": 0}
{"code": "void freeClient(redisClient *c) {\n    listNode *ln;\n    sdsfree(c->querybuf);\n    c->querybuf = NULL;\n    if (c->flags & REDIS_BLOCKED)\n        unblockClientWaitingData(c);\n    unwatchAllKeys(c);\n    listRelease(c->watched_keys);\n    pubsubUnsubscribeAllChannels(c,0);\n    pubsubUnsubscribeAllPatterns(c,0);\n    dictRelease(c->pubsub_channels);\n    listRelease(c->pubsub_patterns);\n    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);\n    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n    listRelease(c->reply);\n    freeClientArgv(c);\n    close(c->fd);\n    ln = listSearchKey(server.clients,c);\n    redisAssert(ln != NULL);\n    listDelNode(server.clients,ln);\n    if (c->flags & REDIS_IO_WAIT) {\n        redisAssert(server.vm_enabled);\n        if (listLength(c->io_keys) == 0) {\n            ln = listSearchKey(server.io_ready_clients,c);\n            redisAssert(ln != NULL);\n            listDelNode(server.io_ready_clients,ln);\n        } else {\n            while (listLength(c->io_keys)) {\n                ln = listFirst(c->io_keys);\n                dontWaitForSwappedKey(c,ln->value);\n            }\n        }\n        server.vm_blocked_clients--;\n    }\n    listRelease(c->io_keys);\n    if (c->flags & REDIS_SLAVE) {\n        if (c->replstate == REDIS_REPL_SEND_BULK && c->repldbfd != -1)\n            close(c->repldbfd);\n        list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves;\n        ln = listSearchKey(l,c);\n        redisAssert(ln != NULL);\n        listDelNode(l,ln);\n    }\n    if (c->flags & REDIS_MASTER) {\n        server.master = NULL;\n        server.replstate = REDIS_REPL_CONNECT;\n        while (listLength(server.slaves)) {\n            ln = listFirst(server.slaves);\n            freeClient((redisClient*)ln->value);\n        }\n    }\n    zfree(c->argv);\n    freeClientMultiState(c);\n    zfree(c);\n}", "target": 1}
{"code": "ospf6_print_lshdr(netdissect_options *ndo,\n                  register const struct lsa6_hdr *lshp, const u_char *dataend)\n {\n \tif ((const u_char *)(lshp + 1) > dataend)\n \t\tgoto trunc;\n\tND_TCHECK(lshp->ls_type);\n\tND_TCHECK(lshp->ls_seq);\n \tND_PRINT((ndo, \"\\n\\t  Advertising Router %s, seq 0x%08x, age %us, length %u\",\n                ipaddr_string(ndo, &lshp->ls_router),\n               EXTRACT_32BITS(&lshp->ls_seq),\n               EXTRACT_16BITS(&lshp->ls_age),\n               EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr)));\n\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid);\n\treturn (0);\ntrunc:\n\treturn (1);\n}", "target": 1}
{"code": "    ExifData& Image::exifData()\n    {\n        return exifData_;\n    }", "target": 0}
{"code": "static void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINMEDIA;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &med->desc.media);\n    pj_scan_get_char(scanner);\n    pj_scan_get(scanner, &cs_token, &str);\n    med->desc.port = (unsigned short)pj_strtoul(&str);\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tpj_scan_get(scanner, &cs_token, &str);\n\tmed->desc.port_count = pj_strtoul(&str);\n    } else {\n\tmed->desc.port_count = 0;\n    }\n    if (pj_scan_get_char(scanner) != ' ') {\n\tPJ_THROW(SYNTAX_ERROR);\n    }\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &med->desc.transport);\n    med->desc.fmt_count = 0;\n    while (*scanner->curptr == ' ') {\n\tpj_str_t fmt;\n\tpj_scan_get_char(scanner);\n\tif ((*scanner->curptr == '\\r') || (*scanner->curptr == '\\n'))\n\t\tbreak;\n\tpj_scan_get(scanner, &cs_token, &fmt);\n\tif (med->desc.fmt_count < PJMEDIA_MAX_SDP_FMT)\n\t    med->desc.fmt[med->desc.fmt_count++] = fmt;\n\telse\n\t    PJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY, \n\t\t         \"Error adding SDP media format %.*s, \"\n\t\t\t \"format is ignored\",\n\t\t\t (int)fmt.slen, fmt.ptr));\n    }\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n    WebKitWebFrame *frame;\n    JSGlobalContextRef context;\n    JSObjectRef globalobject;\n    JSStringRef var_name;\n    JSStringRef js_script;\n    JSValueRef js_result;\n    JSStringRef js_result_string;\n    size_t js_result_size;\n    js_init();\n    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));\n    context = webkit_web_frame_get_global_context(frame);\n    globalobject = JSContextGetGlobalObject(context);\n    var_name = JSStringCreateWithUTF8CString(\"Uzbl\");\n    JSObjectSetProperty(context, globalobject, var_name,\n                        JSObjectMake(context, uzbl.js.classref, NULL),\n                        kJSClassAttributeNone, NULL);\n    js_script = JSStringCreateWithUTF8CString(script);\n    js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n    if (js_result && !JSValueIsUndefined(context, js_result)) {\n        js_result_string = JSValueToStringCopy(context, js_result, NULL);\n        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);\n        if (js_result_size) {\n            char js_result_utf8[js_result_size];\n            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);\n            g_string_assign(result, js_result_utf8);\n        }\n        JSStringRelease(js_result_string);\n    }\n    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n    JSStringRelease(var_name);\n    JSStringRelease(js_script);\n}", "target": 1}
{"code": "static void mdbEvalSetColumn(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    char nbuf[200];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    Jsi_Interp *interp = p->jdb->interp;\n    if (field->isnull)\n        return;\n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_STRING: {\n            int bytes = field->len;\n            const char *zBlob = field->buffer.vstring;\n            if( !zBlob ) {\n                const char *nv = p->jdb->optPtr->nullvalue;\n                Jsi_DSAppend(dStr, nv?nv:\"null\", NULL);\n                return;\n            }\n            Jsi_DSAppendLen(dStr, zBlob, bytes);\n            return;\n        }\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        default:\n            Jsi_LogWarn(\"unknown type: %d\", field->jsiTypeMap);\n    }\n}", "target": 1}
{"code": "static void alterCurrentValue(PlatformUIElement element, int factor)\n{\n    if (!element || !ATK_IS_VALUE(element))\n        return;\n    GValue currentValue = G_VALUE_INIT;\n    atk_value_get_current_value(ATK_VALUE(element), &currentValue);\n    GValue increment = G_VALUE_INIT;\n    atk_value_get_minimum_increment(ATK_VALUE(element), &increment);\n    GValue newValue = G_VALUE_INIT;\n    g_value_init(&newValue, G_TYPE_DOUBLE);\n    g_value_set_float(&newValue, g_value_get_float(&currentValue) + factor * g_value_get_float(&increment));\n    atk_value_set_current_value(ATK_VALUE(element), &newValue);\n    g_value_unset(&newValue);\n    g_value_unset(&increment);\n     g_value_unset(&currentValue);\n }", "target": 0}
{"code": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\ttmp = !!tmp; \n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\treturn count;\n}", "target": 1}
{"code": "void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\tstatic_key_slow_dec(&kvm_no_apic_vcpu);\n}", "target": 0}
{"code": " static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n {\n \tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n \treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n }", "target": 1}
{"code": "posix_acl_xattr_list(struct dentry *dentry)\n{\n\treturn IS_POSIXACL(d_backing_inode(dentry));\n}", "target": 0}
{"code": "static zend_object_value zend_error_exception_new(zend_class_entry *class_type TSRMLS_DC) \n{\n\treturn zend_default_exception_new_ex(class_type, 2 TSRMLS_CC);\n}", "target": 0}
{"code": "return_enc_padata(krb5_context context, krb5_data *req_pkt,\n                  krb5_kdc_req *request, krb5_keyblock *reply_key,\n                  krb5_db_entry *server, krb5_enc_kdc_rep_part *reply_encpart,\n                  krb5_boolean is_referral)\n{\n    krb5_error_code code = 0;\n    assert(reply_encpart->enc_padata == NULL);\n    if (is_referral) {\n        code = return_referral_enc_padata(context, reply_encpart, server);\n        if (code)\n            return code;\n    }\n    code = kdc_handle_protected_negotiation(context, req_pkt, request, reply_key,\n                                            &reply_encpart->enc_padata);\n    if (code)\n        goto cleanup;\ncleanup:\n    return code;\n}", "target": 1}
{"code": "void ThreadWatcherObserver::RemoveNotifications() {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  if (!g_thread_watcher_observer_)\n    return;\n  g_thread_watcher_observer_->registrar_.RemoveAll();\n  delete g_thread_watcher_observer_;\n}", "target": 0}
{"code": "static inline bool nested_cpu_has_vid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n}", "target": 0}
{"code": "bool CmdExtract::ExtractFileCopy(File &New,wchar *ArcName,const wchar *RedirName,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize,int64 UnpSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); \n  File Existing;\n  if (!Existing.Open(NameExisting))\n  {\n    bool OpenFailed=true;\n    for (size_t I=0;I<RefList.Size();I++)\n      if (wcscmp(RedirName,RefList[I].RefName)==0 && RefList[I].TmpName!=NULL)\n      {\n        bool RefMove=RefList[I].RefCount-- == 1;\n        NameExisting=RefList[I].TmpName;\n        if (RefMove) \n        {\n          New.Delete(); \n          bool MoveFailed=!RenameFile(NameExisting,NameNew);\n          if (MoveFailed)\n          {\n            if (!New.WCreate(NameNew,FMF_WRITE|FMF_SHAREREAD))\n              return false;\n            RefMove=false; \n          }\n          else\n          {\n            if (New.Open(NameNew))\n              New.Seek(0,SEEK_END);\n            free(RefList[I].TmpName);\n            RefList[I].TmpName=NULL;\n            return true;\n          }\n        }\n        if (!RefMove)\n          OpenFailed=!Existing.Open(NameExisting);\n        break;\n      }\n    if (OpenFailed)\n    {\n      ErrHandler.OpenErrorMsg(NameExisting);\n      uiMsg(UIERROR_FILECOPY,ArcName,NameExisting,NameNew);\n      uiMsg(UIERROR_FILECOPYHINT,ArcName);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_EREFERENCE;\n#endif\n      return false;\n    }\n  }\n  Array<byte> Buffer(0x100000);\n  int64 CopySize=0;\n  while (true)\n  {\n    Wait();\n    int ReadSize=Existing.Read(&Buffer[0],Buffer.Size());\n    if (ReadSize==0)\n      break;\n    uiExtractProgress(CopySize,UnpSize,0,0);\n    New.Write(&Buffer[0],ReadSize);\n    CopySize+=ReadSize;\n  }\n  return true;\n}", "target": 1}
{"code": "void __init proc_root_init(void)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\tmnt = kern_mount_data(&proc_fs_type, &init_pid_ns);\n\tif (IS_ERR(mnt)) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\tinit_pid_ns.proc_mnt = mnt;\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\tproc_net_init();\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); \n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}", "target": 1}
{"code": "void OpenURL(const char *url)\n{\n    if (strchr(url, '\\'') != NULL)\n    {\n        TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL is not valid\");\n    }\n    else\n    {\n#if defined(PLATFORM_DESKTOP)\n        char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));\n    #if defined(_WIN32)\n        sprintf(cmd, \"explorer \\\"%s\\\"\", url);\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n        sprintf(cmd, \"xdg-open '%s'\", url); \n    #endif\n    #if defined(__APPLE__)\n        sprintf(cmd, \"open '%s'\", url);\n    #endif\n        int result = system(cmd);\n        if (result == -1) TRACELOG(LOG_WARNING, \"OpenURL() child process could not be created\");\n        RL_FREE(cmd);\n#endif\n#if defined(PLATFORM_WEB)\n        emscripten_run_script(TextFormat(\"window.open('%s', '_blank')\", url));\n#endif\n#if defined(PLATFORM_ANDROID)\n        JNIEnv *env = NULL;\n        JavaVM *vm = CORE.Android.app->activity->vm;\n        (*vm)->AttachCurrentThread(vm, &env, NULL);\n        jstring urlString = (*env)->NewStringUTF(env, url);\n        jclass uriClass = (*env)->FindClass(env, \"android/net/Uri\");\n        jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, \"parse\", \"(Ljava/lang/String;)Landroid/net/Uri;\");\n        jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);\n        jclass intentClass = (*env)->FindClass(env, \"android/content/Intent\");\n        jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, \"ACTION_VIEW\", \"Ljava/lang/String;\");\n        jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);\n        jmethodID newIntent = (*env)->GetMethodID(env, intentClass, \"<init>\", \"(Ljava/lang/String;Landroid/net/Uri;)V\");\n        jobject intent = (*env)->AllocObject(env, intentClass);\n        (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);\n        jclass activityClass = (*env)->FindClass(env, \"android/app/Activity\");\n        jmethodID startActivity = (*env)->GetMethodID(env, activityClass, \"startActivity\", \"(Landroid/content/Intent;)V\");\n        (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);\n        (*vm)->DetachCurrentThread(vm);\n#endif\n    }\n}", "target": 1}
{"code": "static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {\n const char* name;\n size_t namelen;\n if (node->graft_path) {\n        name = node->graft_path;\n        namelen = node->graft_pathlen;\n } else if (node->actual_name) {\n        name = node->actual_name;\n        namelen = node->namelen;\n } else {\n        name = node->name;\n        namelen = node->namelen;\n }\n if (bufsize < namelen + 1) {\n return -1;\n }\n     ssize_t pathlen = 0;\n     if (node->parent && node->graft_path == NULL) {\n        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);\n         if (pathlen < 0) {\n             return -1;\n         }\n        buf[pathlen++] = '/';\n }\n    memcpy(buf + pathlen, name, namelen + 1); \n return pathlen + namelen;\n}", "target": 1}
{"code": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\tnp = pdev->dev.of_node;\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n \t\treturn -ENOMEM;\n \tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\tplatform_set_drvdata(pdev, priv);\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\treturn 0;\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}", "target": 1}
{"code": "static bool arg_type_is_mem_ptr(enum bpf_arg_type type)\n{\n\treturn base_type(type) == ARG_PTR_TO_MEM ||\n\t       base_type(type) == ARG_PTR_TO_UNINIT_MEM;\n}", "target": 0}
{"code": "gst_h264_slice_parse_dec_ref_pic_marking (GstH264SliceHdr * slice,\n    GstH264NalUnit * nalu, NalReader * nr)\n{\n  GstH264DecRefPicMarking *dec_ref_pic_m;\n  guint start_pos;\n  GST_DEBUG (\"parsing \\\"Decoded reference picture marking\\\"\");\n  start_pos = nal_reader_get_pos (nr);\n  dec_ref_pic_m = &slice->dec_ref_pic_marking;\n  if (nalu->idr_pic_flag) {\n    READ_UINT8 (nr, dec_ref_pic_m->no_output_of_prior_pics_flag, 1);\n    READ_UINT8 (nr, dec_ref_pic_m->long_term_reference_flag, 1);\n  } else {\n    READ_UINT8 (nr, dec_ref_pic_m->adaptive_ref_pic_marking_mode_flag, 1);\n    if (dec_ref_pic_m->adaptive_ref_pic_marking_mode_flag) {\n      guint32 mem_mgmt_ctrl_op;\n      GstH264RefPicMarking *refpicmarking;\n      dec_ref_pic_m->n_ref_pic_marking = 0;\n      while (1) {\n        refpicmarking =\n            &dec_ref_pic_m->ref_pic_marking[dec_ref_pic_m->n_ref_pic_marking];\n        READ_UE (nr, mem_mgmt_ctrl_op);\n        if (mem_mgmt_ctrl_op == 0)\n          break;\n        refpicmarking->memory_management_control_operation = mem_mgmt_ctrl_op;\n        if (mem_mgmt_ctrl_op == 1 || mem_mgmt_ctrl_op == 3)\n          READ_UE (nr, refpicmarking->difference_of_pic_nums_minus1);\n        if (mem_mgmt_ctrl_op == 2)\n          READ_UE (nr, refpicmarking->long_term_pic_num);\n        if (mem_mgmt_ctrl_op == 3 || mem_mgmt_ctrl_op == 6)\n          READ_UE (nr, refpicmarking->long_term_frame_idx);\n        if (mem_mgmt_ctrl_op == 4)\n          READ_UE (nr, refpicmarking->max_long_term_frame_idx_plus1);\n        dec_ref_pic_m->n_ref_pic_marking++;\n      }\n    }\n  }\n  dec_ref_pic_m->bit_size = nal_reader_get_pos (nr) - start_pos;\n  return TRUE;\nerror:\n  GST_WARNING (\"error parsing \\\"Decoded reference picture marking\\\"\");\n  return FALSE;\n}", "target": 1}
{"code": "util_write_callback(int flags, char *ptr, size_t size, size_t nmemb, void *stream)\n{\n    CurlObject *self;\n    PyObject *arglist;\n    PyObject *result = NULL;\n    size_t ret = 0;     \n    PyObject *cb;\n    int total_size;\n    PYCURL_DECLARE_THREAD_STATE;\n    self = (CurlObject *)stream;\n    if (!PYCURL_ACQUIRE_THREAD())\n        return ret;\n    cb = flags ? self->h_cb : self->w_cb;\n    if (cb == NULL)\n        goto silent_error;\n    if (size <= 0 || nmemb <= 0)\n        goto done;\n    total_size = (int)(size * nmemb);\n    if (total_size < 0 || (size_t)total_size / size != nmemb) {\n        PyErr_SetString(ErrorObject, \"integer overflow in write callback\");\n        goto verbose_error;\n    }\n#if PY_MAJOR_VERSION >= 3\n    arglist = Py_BuildValue(\"(y#)\", ptr, total_size);\n#else\n    arglist = Py_BuildValue(\"(s#)\", ptr, total_size);\n#endif\n    if (arglist == NULL)\n        goto verbose_error;\n    result = PyEval_CallObject(cb, arglist);\n    Py_DECREF(arglist);\n    if (result == NULL)\n        goto verbose_error;\n    if (result == Py_None) {\n        ret = total_size;           \n    }\n    else if (PyInt_Check(result) || PyLong_Check(result)) {\n        ret = (size_t) PyLong_AsLong(result);\n    }\n    else {\n        PyErr_SetString(ErrorObject, \"write callback must return int or None\");\n        goto verbose_error;\n    }\ndone:\nsilent_error:\n    Py_XDECREF(result);\n    PYCURL_RELEASE_THREAD();\n    return ret;\nverbose_error:\n    PyErr_Print();\n    goto silent_error;\n}", "target": 0}
{"code": "compat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_fw_xfer32 kfw32;\n\tstruct mpt_fw_xfer kfw;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\tif (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))\n\t\treturn -EFAULT;\n\tiocnumX = kfw32.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mptfwxfer_ioctl @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\\n\",\n\t    iocp->name));\n\tkfw.iocnum = iocnum;\n\tkfw.fwlen = kfw32.fwlen;\n\tkfw.bufp = compat_ptr(kfw32.bufp);\n\tret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\treturn ret;\n}", "target": 1}
{"code": "void AudioContext::processAutomaticPullNodes(size_t framesToProcess)\n{\n    ASSERT(isAudioThread());\n    for (unsigned i = 0; i < m_renderingAutomaticPullNodes.size(); ++i)\n        m_renderingAutomaticPullNodes[i]->processIfNecessary(framesToProcess);\n}", "target": 0}
{"code": "inline bool RARPPM_CONTEXT::decodeSymbol2(ModelPPM *Model)\n{\n  int count, HiCnt, i=NumStats-Model->NumMasked;\n  RARPPM_SEE2_CONTEXT* psee2c=makeEscFreq2(Model,i);\n  RARPPM_STATE* ps[256], ** pps=ps, * p=U.Stats-1;\n  HiCnt=0;\n  do \n  {\n    do \n    { \n      p++; \n    } while (Model->CharMask[p->Symbol] == Model->EscCount);\n    HiCnt += p->Freq;\n    if (pps>=ps+ASIZE(ps))\n      return false;\n    *pps++ = p;\n  } while ( --i );\n  Model->Coder.SubRange.scale += HiCnt;\n  count=Model->Coder.GetCurrentCount();\n  if (count>=(int)Model->Coder.SubRange.scale)\n    return(false);\n  p=*(pps=ps);\n  if (count < HiCnt) \n  {\n    HiCnt=0;\n    while ((HiCnt += p->Freq) <= count) \n    {\n      pps++;\n      if (pps>=ps+ASIZE(ps)) \n        return false;\n      p=*pps;\n    }\n    Model->Coder.SubRange.LowCount = (Model->Coder.SubRange.HighCount=HiCnt)-p->Freq;\n    psee2c->update();\n    update2(Model,p);\n  }\n  else\n  {\n    Model->Coder.SubRange.LowCount=HiCnt;\n    Model->Coder.SubRange.HighCount=Model->Coder.SubRange.scale;\n    i=NumStats-Model->NumMasked;\n    pps--;\n    do \n    { \n      pps++;\n      if (pps>=ps+ASIZE(ps)) \n        return false;\n      Model->CharMask[(*pps)->Symbol]=Model->EscCount; \n    } while ( --i );\n    psee2c->Summ += Model->Coder.SubRange.scale;\n    Model->NumMasked = NumStats;\n  }\n  return true;\n}", "target": 1}
{"code": "void read_user_name(char *name)\n{\n  char *str=getenv(\"USER\");\t\t\n  strmake(name,str ? str : \"ODBC\", USERNAME_LENGTH);\n}", "target": 0}
{"code": "void SecurityManager::resend_handshake_message_token(\n        const GUID_t& remote_participant_key) const\n{\n    auto sentry = is_security_manager_initialized();\n    if (!sentry)\n    {\n        return;\n    }\n    shared_lock<shared_mutex> _(mutex_);\n    auto dp_it = discovered_participants_.find(remote_participant_key);\n    if (dp_it != discovered_participants_.end())\n    {\n        SecurityManager::DiscoveredParticipantInfo::AuthUniquePtr remote_participant_info = dp_it->second->get_auth();\n        if (remote_participant_info)\n        {\n            if (remote_participant_info->change_sequence_number_ != SequenceNumber_t::unknown())\n            {\n                CacheChange_t* p_change = participant_stateless_message_writer_history_->remove_change_and_reuse(\n                    remote_participant_info->change_sequence_number_);\n                remote_participant_info->change_sequence_number_ = SequenceNumber_t::unknown();\n                if (p_change != nullptr)\n                {\n                    EPROSIMA_LOG_INFO(SECURITY, \"Authentication handshake resent to participant \" <<\n                            remote_participant_key);\n                    if (participant_stateless_message_writer_history_->add_change(p_change))\n                    {\n                        remote_participant_info->change_sequence_number_ = p_change->sequenceNumber;\n                    }\n                }\n            }\n            dp_it->second->set_auth(remote_participant_info);\n        }\n    }\n}", "target": 1}
{"code": "nvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tu64 connection_id)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tu64 association_id = nvmet_fc_getassociationid(connection_id);\n \tu16 qid = nvmet_fc_getqueueid(connection_id);\n \tunsigned long flags;\n \tspin_lock_irqsave(&tgtport->lock, flags);\n \tlist_for_each_entry(assoc, &tgtport->assoc_list, a_list) {\n \t\tif (association_id == assoc->association_id) {\n\t\t\tqueue = assoc->queues[qid];\n\t\t\tif (queue &&\n\t\t\t    (!atomic_read(&queue->connected) ||\n\t\t\t     !nvmet_fc_tgt_q_get(queue)))\n\t\t\t\tqueue = NULL;\n\t\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t\t\treturn queue;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\treturn NULL;\n}", "target": 1}
{"code": " void dev_load(struct net *net, const char *name)\n {\n \tstruct net_device *dev;\n \trcu_read_lock();\n \tdev = dev_get_by_name_rcu(net, name);\n \trcu_read_unlock();\n\tif (!dev && capable(CAP_NET_ADMIN))\n\t\trequest_module(\"%s\", name);\n }", "target": 1}
{"code": "void closeFile(PlatformFileHandle& handle)\n{\n    if (isHandleValid(handle)) {\n        ::CloseHandle(handle);\n        handle = invalidPlatformFileHandle;\n    }\n}", "target": 0}
{"code": "  void set_simulator_redirection(Redirection* redirection) {\n    simulator_redirection_ = redirection;\n  }", "target": 0}
{"code": "TEST_F(QueryPlannerTest, PlannerAddsFetchToIxscanForCountWhenFetchFilterNonempty) {\n    params.options = QueryPlannerParams::IS_COUNT;\n    addIndex(BSON(\"x\" << 1));\n    runQuery(BSON(\"y\" << 3 << \"x\" << 5));\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\n        \"{fetch: {filter: {y: 3}, node: {ixscan: \"\n        \"{pattern: {x: 1}, bounds: {x: [[5,5,true,true]]}}}}}\");\n}", "target": 0}
{"code": "static inline void __clear_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n\t__clear_bit(fd / BITS_PER_LONG, fdt->full_fds_bits);\n}", "target": 0}
{"code": "fbCombineAtopC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32 d = READ(dest + i);\n        CARD32 s = READ(src + i);\n        CARD32 m = READ(mask + i);\n        CARD32 ad;\n        CARD16 as = d >> 24;\n\tfbCombineMaskC (&s, &m);\n        ad = ~m;\n        FbByteAddMulC(d, ad, s, as);\n        WRITE(dest + i, d);\n    }\n}", "target": 0}
{"code": "static void run(int argc, const char *const argv[],\n        const char *name, void (*init)(const char * const argv[]))\n{\n    int rv;\n    bool user_config;\n    const char *argv_out[argc+4], *new_argv[argc+4];\n    int argc_out;\n    char conf_file[OGS_MAX_FILEPATH_LEN];\n    user_config = false;\n    for (argc_out = 0; argc_out < argc; argc_out++) {\n        if (strcmp(\"-c\", argv[argc_out]) == 0) {\n            user_config = true; \n        }\n        argv_out[argc_out] = argv[argc_out];\n    }\n    argv_out[argc_out] = NULL;\n    if (!user_config) {\n        ogs_snprintf(conf_file, sizeof conf_file, \"%s%s\",\n            MESON_BUILD_ROOT OGS_DIR_SEPARATOR_S\n            \"configs\" OGS_DIR_SEPARATOR_S, name);\n        argv_out[argc_out++] = \"-c\";\n        argv_out[argc_out++] = conf_file;\n        argv_out[argc_out] = NULL;\n    }\n    argv_out[0] = MESON_BUILD_ROOT OGS_DIR_SEPARATOR_S \n            \"src\" OGS_DIR_SEPARATOR_S \"open5gs-main\";\n    rv = abts_main(argc_out, argv_out, new_argv);\n    ogs_assert(rv == OGS_OK);\n    (*init)(new_argv);\n}", "target": 1}
{"code": "int ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n    ushf *overlay;\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n    ss = source->state;\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds->strm = dest;\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n    ds->pending_buf = (uchf *) overlay;\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n    return Z_OK;\n#endif \n}", "target": 1}
{"code": "check_CONJUNCTION(const struct ofpact_conjunction *a OVS_UNUSED,\n                  const struct ofpact_check_params *cp OVS_UNUSED)\n{\n    return 0;\n}", "target": 0}
{"code": "static void svm_hwapic_isr_update(struct kvm *kvm, int isr)\n{\n\treturn;\n}", "target": 0}
{"code": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n \tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n \tint ret;\n\tif (args->buffer_count < 1) {\n \t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n \t\treturn -EINVAL;\n \t}\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}", "target": 1}
{"code": "METHODDEF(JDIMENSION)\nget_32bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n  if (source->use_inversion_array) {\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_EXT_BGRX ||\n      cinfo->in_color_space == JCS_EXT_BGRA) {\n    MEMCOPY(outptr, inptr, source->row_width);\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;\n      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);\n      inptr++;                          \n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      \n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr[aindex] = *inptr++;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      \n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        inptr++;                        \n        outptr += ps;\n      }\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  int max_index = -1;\n  const int segment_id_size = segment_ids->dims->data[0];\n  if (segment_id_size > 0) {\n    max_index = segment_ids->data.i32[segment_id_size - 1];\n  }\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}", "target": 1}
{"code": "copy_plats_to_inter (class ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n{\n  vec<ipa_agg_value> res = vNULL;\n  if (!plats->aggs || plats->aggs_contain_variable || plats->aggs_bottom)\n    return vNULL;\n  for (struct ipcp_agg_lattice *aglat = plats->aggs; aglat; aglat = aglat->next)\n    if (aglat->is_single_const ())\n      {\n\tstruct ipa_agg_value ti;\n\tti.offset = aglat->offset - offset;\n\tti.value = aglat->values->value;\n\tres.safe_push (ti);\n      }\n  return res;\n}", "target": 0}
{"code": "strncat_from_utf8_libarchive2(struct archive_string *as,\n    const void *_p, size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tint n;\n\tchar *p;\n\tchar *end;\n\tuint32_t unicode;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\t(void)sc; \n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {\n\t\twchar_t wc;\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\twc = L'?';\n\t\t} else\n\t\t\twc = (wchar_t)unicode;\n\t\ts += n;\n\t\tlen -= n;\n#if HAVE_WCRTOMB\n\t\tn = (int)wcrtomb(p, wc, &shift_state);\n#else\n\t\tn = (int)wctomb(p, wc);\n#endif\n\t\tif (n == -1)\n\t\t\treturn (-1);\n\t\tp += n;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (0);\n}", "target": 1}
{"code": "static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                             const BYTE* exponent, int exponent_size, BYTE* output)\n{\n\tBN_CTX* ctx;\n\tint output_length = -1;\n\tBYTE* input_reverse;\n\tBYTE* modulus_reverse;\n\tBYTE* exponent_reverse;\n\tBIGNUM *mod, *exp, *x, *y;\n\tinput_reverse = (BYTE*)malloc(2 * key_length + exponent_size);\n\tif (!input_reverse)\n\t\treturn -1;\n\tmodulus_reverse = input_reverse + key_length;\n\texponent_reverse = modulus_reverse + key_length;\n\tmemcpy(modulus_reverse, modulus, key_length);\n\tcrypto_reverse(modulus_reverse, key_length);\n\tmemcpy(exponent_reverse, exponent, exponent_size);\n\tcrypto_reverse(exponent_reverse, exponent_size);\n\tmemcpy(input_reverse, input, length);\n\tcrypto_reverse(input_reverse, length);\n\tif (!(ctx = BN_CTX_new()))\n\t\tgoto fail_bn_ctx;\n\tif (!(mod = BN_new()))\n\t\tgoto fail_bn_mod;\n\tif (!(exp = BN_new()))\n\t\tgoto fail_bn_exp;\n\tif (!(x = BN_new()))\n\t\tgoto fail_bn_x;\n\tif (!(y = BN_new()))\n\t\tgoto fail_bn_y;\n\tBN_bin2bn(modulus_reverse, key_length, mod);\n\tBN_bin2bn(exponent_reverse, exponent_size, exp);\n\tBN_bin2bn(input_reverse, length, x);\n\tBN_mod_exp(y, x, exp, mod, ctx);\n\toutput_length = BN_bn2bin(y, output);\n\tcrypto_reverse(output, output_length);\n\tif (output_length < (int)key_length)\n\t\tmemset(output + output_length, 0, key_length - output_length);\n\tBN_free(y);\nfail_bn_y:\n\tBN_clear_free(x);\nfail_bn_x:\n\tBN_free(exp);\nfail_bn_exp:\n\tBN_free(mod);\nfail_bn_mod:\n\tBN_CTX_free(ctx);\nfail_bn_ctx:\n\tfree(input_reverse);\n\treturn output_length;\n}", "target": 1}
{"code": "    CiffComponent* CiffComponent::doAdd(CrwDirs& , uint16_t )\n    {\n        return 0;\n    } ", "target": 0}
{"code": "static void atusb_disconnect(struct usb_interface *interface)\n{\n\tstruct atusb *atusb = usb_get_intfdata(interface);\n\tdev_dbg(&atusb->usb_dev->dev, \"%s\\n\", __func__);\n\tatusb->shutdown = 1;\n\tcancel_delayed_work_sync(&atusb->work);\n\tusb_kill_anchored_urbs(&atusb->rx_urbs);\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\tieee802154_unregister_hw(atusb->hw);\n\tieee802154_free_hw(atusb->hw);\n\tusb_set_intfdata(interface, NULL);\n\tusb_put_dev(atusb->usb_dev);\n\tpr_debug(\"%s done\\n\", __func__);\n}", "target": 1}
{"code": "    CommentValue::CommentValue()\n        : StringValueBase(Exiv2::undefined), byteOrder_(littleEndian)\n    {\n    }", "target": 0}
{"code": "gmtime_r(const time_t *t, struct tm *tm)\n{\n    auto struct tm *tmp = gmtime(t);\n    if (tmp)\n\t*tm = *tmp;\n    return tmp;\n}", "target": 0}
{"code": "JOIN_TAB *first_linear_tab(JOIN *join,\n                           enum enum_with_bush_roots include_bush_roots,\n                           enum enum_with_const_tables const_tbls)\n{\n  JOIN_TAB *first= join->join_tab;\n  if (!first)\n    return NULL;\n  if (const_tbls == WITHOUT_CONST_TABLES)\n    first+= join->const_tables;\n  if (first >= join->join_tab + join->top_join_tab_count)\n    return NULL; \n  if (first->bush_children && include_bush_roots == WITHOUT_BUSH_ROOTS)\n  {\n    return first->bush_children->start;\n  }\n  return first;\n}", "target": 0}
{"code": "Status OpLevelCostEstimator::PredictAvgPool(const OpContext& op_context,\n                                            NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * dims.kx * dims.ky;\n  node_costs->num_compute_ops = ops;\n  int64_t input_size;\n  if (dims.ky >= dims.sy) {\n    input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  } else {  \n    const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype()));\n    input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz;\n  }\n  node_costs->num_input_bytes_accessed = {input_size};\n  const int64_t output_size =\n      CalculateOutputSize(op_info, &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\t__u8 proto;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tstruct xfrm_state *x;\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tproto = x->id.proto;\n\txfrm_state_put(x);\n\tif (IS_ERR(out_skb))\n\t\treturn  PTR_ERR(out_skb);\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GET;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n\treturn 0;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::OnSyntheticGestureCompleted(\n    SyntheticGesture::Result result) {\n  Send(new InputMsg_SyntheticGestureCompleted(GetRoutingID()));\n}", "target": 0}
{"code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tu--;\n\t\t\twhile (u >= 0) {\n\t\t\t\tgdFree(res->ContribRow[u].Weights);\n\t\t\t\tu--;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static inline void snow_set_blocks(SnowContext *s, int level, int x, int y, int l, int cb, int cr, int mx, int my, int ref, int type){\n    const int w= s->b_width << s->block_max_depth;\n    const int rem_depth= s->block_max_depth - level;\n    const int index= (x + y*w) << rem_depth;\n    const int block_w= 1<<rem_depth;\n    BlockNode block;\n    int i,j;\n    block.color[0]= l;\n    block.color[1]= cb;\n    block.color[2]= cr;\n    block.mx= mx;\n    block.my= my;\n    block.ref= ref;\n    block.type= type;\n    block.level= level;\n    for(j=0; j<block_w; j++){\n        for(i=0; i<block_w; i++){\n            s->block[index + i + j*w]= block;\n        }\n    }\n}", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n \tkey = key_ref_to_ptr(key_ref);\n \tret = key_permission(key_ref, KEY_NEED_READ);\n \tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "void key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}", "target": 0}
{"code": "void fz_init_cached_color_converter(fz_context *ctx, fz_color_converter *cc, fz_colorspace *is, fz_colorspace *ds, fz_colorspace *ss, const fz_color_params *params)\n{\n\tint n = ss->n;\n\tfz_cached_color_converter *cached = fz_malloc_struct(ctx, fz_cached_color_converter);\n\tcc->opaque = cached;\n\tcc->convert = fz_cached_color_convert;\n\tcc->ds = ds ? ds : fz_device_gray(ctx);\n\tcc->ss = ss;\n\tcc->is = is;\n\tfz_try(ctx)\n\t{\n\t\tfz_find_color_converter(ctx, &cached->base, is, cc->ds, ss, params);\n\t\tcached->hash = fz_new_hash_table(ctx, 256, n * sizeof(float), -1, fz_free);\n\t}\n\tfz_catch(ctx)\n\t{\n                fz_drop_color_converter(ctx, &cached->base);\n                fz_drop_hash_table(ctx, cached->hash);\n                fz_free(ctx, cached);\n                fz_rethrow(ctx);\n        }\n }", "target": 1}
{"code": "TEST_F(SecretManagerImplTest, DeprecatedSanMatcher) {\n  envoy::extensions::transport_sockets::tls::v3::Secret secret_config;\n  const std::string yaml =\n      R\"EOF(\n      name: \"abc.com\"\n      validation_context:\n        trusted_ca: { filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\" }\n        allow_expired_certificate: true\n        match_subject_alt_names:\n          exact: \"example.foo\"\n      )EOF\";\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml), secret_config);\n  std::unique_ptr<SecretManager> secret_manager(new SecretManagerImpl(config_tracker_));\n  secret_manager->addStaticSecret(secret_config);\n  ASSERT_EQ(secret_manager->findStaticCertificateValidationContextProvider(\"undefined\"), nullptr);\n  ASSERT_NE(secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\"), nullptr);\n  Ssl::CertificateValidationContextConfigImpl cvc_config(\n      *secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\")->secret(), *api_);\n  EXPECT_EQ(cvc_config.subjectAltNameMatchers().size(), 4);\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[0].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n            cvc_config.subjectAltNameMatchers()[0].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[1].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n            cvc_config.subjectAltNameMatchers()[1].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[2].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n            cvc_config.subjectAltNameMatchers()[2].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[3].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS,\n            cvc_config.subjectAltNameMatchers()[3].san_type());\n}", "target": 0}
{"code": "    StringValueBase::StringValueBase(TypeId typeId)\n        : Value(typeId)\n    {\n    }", "target": 0}
{"code": "void dname_pkt_copy(sldns_buffer* pkt, uint8_t* to, uint8_t* dname)\n{\n\tsize_t len = 0;\n\tuint8_t lablen;\n\tlablen = *dname++;\n\twhile(lablen) {\n\t\tif(LABEL_IS_PTR(lablen)) {\n\t\t\tdname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));\n\t\t\tlablen = *dname++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(lablen > LDNS_MAX_LABELLEN) {\n\t\t\t*to = 0; \n\t\t\treturn;\n\t\t}\n\t\tlog_assert(lablen <= LDNS_MAX_LABELLEN);\n\t\tlen += (size_t)lablen+1;\n\t\tif(len >= LDNS_MAX_DOMAINLEN) {\n\t\t\t*to = 0; \n\t\t\tlog_err(\"bad dname in dname_pkt_copy\");\n\t\t\treturn;\n\t\t}\n\t\t*to++ = lablen;\n\t\tmemmove(to, dname, lablen);\n\t\tdname += lablen;\n\t\tto += lablen;\n\t\tlablen = *dname++;\n\t}\n\t*to = 0;\n}", "target": 1}
{"code": "BZIP3_API struct bz3_state * bz3_new(s32 block_size) {\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n        return NULL;\n    }\n    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));\n    if (!bz3_state) {\n        return NULL;\n    }\n    bz3_state->cm_state = malloc(sizeof(state));\n    bz3_state->swap_buffer = malloc(bz3_bound(block_size));\n    bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32));\n    memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128));\n    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));\n    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {\n        if (bz3_state->cm_state) free(bz3_state->cm_state);\n        if (bz3_state->swap_buffer) free(bz3_state->swap_buffer);\n        if (bz3_state->sais_array) free(bz3_state->sais_array);\n        if (bz3_state->lzp_lut) free(bz3_state->lzp_lut);\n        free(bz3_state);\n        return NULL;\n    }\n    bz3_state->block_size = block_size;\n    bz3_state->last_error = BZ3_OK;\n    return bz3_state;\n}", "target": 1}
{"code": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_reportstat_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "char *BN_bn2dec(const BIGNUM *a)\n{\n    int i = 0, num, ok = 0;\n    char *buf = NULL;\n    char *p;\n    BIGNUM *t = NULL;\n    BN_ULONG *bn_data = NULL, *lp;\n    i = BN_num_bits(a) * 3;\n    num = (i / 10 + i / 1000 + 1) + 1;\n    bn_data = OPENSSL_malloc((num / BN_DEC_NUM + 1) * sizeof(BN_ULONG));\n    buf = OPENSSL_malloc(num + 3);\n    if ((buf == NULL) || (bn_data == NULL)) {\n        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((t = BN_dup(a)) == NULL)\n        goto err;\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\n    p = buf;\n    lp = bn_data;\n    if (BN_is_zero(t)) {\n        *(p++) = '0';\n        *(p++) = '\\0';\n    } else {\n        if (BN_is_negative(t))\n            *p++ = '-';\n        i = 0;\n        while (!BN_is_zero(t)) {\n            *lp = BN_div_word(t, BN_DEC_CONV);\n            lp++;\n        }\n        lp--;\n        BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT1, *lp);\n        while (*p)\n            p++;\n        while (lp != bn_data) {\n            lp--;\n            BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT2, *lp);\n            while (*p)\n                p++;\n        }\n    }\n    ok = 1;\n err:\n    OPENSSL_free(bn_data);\n    BN_free(t);\n    if (ok)\n        return buf;\n    OPENSSL_free(buf);\n    return NULL;\n}", "target": 1}
{"code": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}", "target": 1}
{"code": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; \n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n \tretval = copy_strings_kernel(1, &i_name, bprm);\n \tif (retval) return retval; \n \tbprm->argc++;\n\tbprm->interp = interp;\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}", "target": 1}
{"code": "std::string utf16ToUtf8(const StringPiece16& utf16) {\n ssize_t utf8Length = utf16_to_utf8_length(utf16.data(), utf16.length());\n if (utf8Length <= 0) {\n return {};\n     }\n     std::string utf8;\n     utf8.resize(utf8Length);\n    utf16_to_utf8(utf16.data(), utf16.length(), &*utf8.begin());\n     return utf8;\n }", "target": 1}
{"code": "static int __init atalk_init(void)\n{\n\tint rc;\n\trc = proto_register(&ddp_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\trc = sock_register(&atalk_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\tddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\n\tif (!ddp_dl)\n\t\tprintk(atalk_err_snap);\n\tdev_add_pack(&ltalk_packet_type);\n\tdev_add_pack(&ppptalk_packet_type);\n\trc = register_netdevice_notifier(&ddp_notifier);\n\tif (rc)\n\t\tgoto out_sock;\n\taarp_proto_init();\n\trc = atalk_proc_init();\n\tif (rc)\n\t\tgoto out_aarp;\n\trc = atalk_register_sysctl();\n\tif (rc)\n\t\tgoto out_proc;\nout:\n\treturn rc;\nout_proc:\n\tatalk_proc_exit();\nout_aarp:\n\taarp_cleanup_module();\n\tunregister_netdevice_notifier(&ddp_notifier);\nout_sock:\n\tdev_remove_pack(&ppptalk_packet_type);\n\tdev_remove_pack(&ltalk_packet_type);\n\tunregister_snap_client(ddp_dl);\n\tsock_unregister(PF_APPLETALK);\nout_proto:\n\tproto_unregister(&ddp_proto);\n\tgoto out;\n}", "target": 1}
{"code": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "lzss_current_offset(struct lzss *lzss)\n{\n  return lzss_offset_for_position(lzss, lzss->position);\n}", "target": 0}
{"code": "  void GetGlobalUsage(StorageType type) {\n    type_ = kStorageTypeUnknown;\n    usage_ = -1;\n    unlimited_usage_ = -1;\n    quota_manager_->GetGlobalUsage(type,\n        callback_factory_.NewCallback(\n            &QuotaManagerTest::DidGetGlobalUsage));\n  }", "target": 0}
{"code": "SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\t\t       unsigned int, flags)\n{\n\tstruct sched_attr attr;\n\tstruct task_struct *p;\n\tint retval;\n\tif (!uattr || pid < 0 || flags)\n\t\treturn -EINVAL;\n\tretval = sched_copy_attr(uattr, &attr);\n\tif (retval)\n\t\treturn retval;\n\tif ((int)attr.sched_policy < 0)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setattr(p, &attr);\n\trcu_read_unlock();\n\treturn retval;\n}", "target": 0}
{"code": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\t*rcmd = NULL;\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool RootWindow::DispatchKeyEvent(KeyEvent* event) {\n  DispatchHeldMouseMove();\n  KeyEvent translated_event(*event);\n  if (translated_event.key_code() == ui::VKEY_UNKNOWN)\n    return false;\n  client::EventClient* client = client::GetEventClient(GetRootWindow());\n  if (client && !client->CanProcessEventsWithinSubtree(focused_window_)) {\n    SetFocusedWindow(NULL, NULL);\n    return false;\n  }\n  return ProcessKeyEvent(focused_window_, &translated_event);\n}", "target": 0}
{"code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n \telse\n \t\tci->hcd = hcd;\n \treturn ret;\n }", "target": 1}
{"code": "int mesg_make_query (u_char *qname, uint16_t qtype, uint16_t qclass,\n\t\t     uint32_t id, int rd, u_char *buf, int buflen) {\n\tchar *fn = \"mesg_make_query()\";\n\tu_char *ucp;\n\tint i, written_len;\n\tMesg_Hdr *hdr;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: (qtype: %s, id: %d): start\", fn,\n\t\t\tstring_rtype (qtype), id);\n\thdr = (Mesg_Hdr *) buf;\n\thdr->id = id;\n\thdr->opcode = OP_QUERY;\n\thdr->rcode = RC_OK;\n\thdr->rd = rd;\n\thdr->qr = hdr->aa = hdr->tc = hdr->ra = hdr->zero = 0;\n\thdr->qdcnt = ntohs (1);\n\thdr->ancnt = hdr->nscnt = hdr->arcnt = ntohs (0);\n\twritten_len = sizeof (Mesg_Hdr);\n\tucp = (u_char *) (hdr + 1);\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qname offset = %zd\", fn, ucp - buf);\n\ti = dname_copy (qname, ucp, buflen - written_len);\n\tif (i < 0)\n\t\treturn -1;\n\twritten_len += i;\n\tucp += i;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qtype/qclass offset = %zd\",\n\t\t\tfn, ucp - buf);\n\twritten_len += sizeof (uint16_t) * 2;\n\tif (written_len > buflen)\n\t\treturn -1;\n\tPUTSHORT (qtype, ucp);\n\tPUTSHORT (qclass, ucp);\n\treturn written_len;\n}", "target": 1}
{"code": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n \t\t\tifr->ifr_settings.size = size; \n \t\t\treturn -ENOBUFS;\n \t\t}\n \t\tline.clock_type = get_status(port)->clocking;\n \t\tline.clock_rate = 0;\n \t\tline.loopback = 0;\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; \n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}", "target": 1}
{"code": "static void kick_siblings(struct i915_request *rq, struct intel_context *ce)\n{\n\tstruct virtual_engine *ve = container_of(ce, typeof(*ve), context);\n\tstruct i915_request *next = READ_ONCE(ve->request);\n\tif (next && next->execution_mask & ~rq->execution_mask)\n\t\ttasklet_schedule(&ve->base.execlists.tasklet);\n}", "target": 0}
{"code": "  Status FillCollectiveParams(CollectiveParams* col_params,\n                              CollectiveType collective_type,\n                              const Tensor& group_size, const Tensor& group_key,\n                              const Tensor& instance_key) {\n    if (group_size.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_size, got \",\n                              group_size.shape().DebugString());\n    }\n    if (group_key.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_key, got \",\n                              group_key.shape().DebugString());\n    }\n    if (instance_key.dims() > 0) {\n      return errors::Internal(\n          \"Unexpected dimensions on input instance_key, got \",\n          instance_key.shape().DebugString());\n    }\n    col_params->name = name_;\n    col_params->group.device_type = device_type_;\n    col_params->group.group_size = group_size.unaligned_flat<int32>()(0);\n    if (col_params->group.group_size <= 0) {\n      return errors::InvalidArgument(\n          \"group_size must be positive integer but got \",\n          col_params->group.group_size);\n    }\n    col_params->group.group_key = group_key.unaligned_flat<int32>()(0);\n    col_params->instance.type = collective_type;\n    col_params->instance.instance_key = instance_key.unaligned_flat<int32>()(0);\n    col_params->instance.data_type = data_type_;\n    col_params->instance.impl_details.communication_hint = communication_hint_;\n    col_params->instance.impl_details.timeout_seconds = timeout_seconds_;\n    return Status::OK();\n  }", "target": 1}
{"code": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        conf_req_flag = FALSE;\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}", "target": 1}
{"code": "void mpz_as_bytes(const mpz_t *z, bool big_endian, size_t len, byte *buf) {\n    byte *b = buf;\n    if (big_endian) {\n        b += len;\n    }\n    mpz_dig_t *zdig = z->dig;\n    int bits = 0;\n    mpz_dbl_dig_t d = 0;\n    mpz_dbl_dig_t carry = 1;\n    for (size_t zlen = z->len; zlen > 0; --zlen) {\n        bits += DIG_SIZE;\n        d = (d << DIG_SIZE) | *zdig++;\n        for (; bits >= 8; bits -= 8, d >>= 8) {\n            mpz_dig_t val = d;\n            if (z->neg) {\n                val = (~val & 0xff) + carry;\n                carry = val >> 8;\n            }\n            if (big_endian) {\n                *--b = val;\n                if (b == buf) {\n                    return;\n                }\n            } else {\n                *b++ = val;\n                if (b == buf + len) {\n                    return;\n                }\n            }\n        }\n    }\n    if (big_endian) {\n        len = b - buf;\n    } else {\n        len = buf + len - b;\n        buf = b;\n    }\n    memset(buf, z->neg ? 0xff : 0x00, len);\n}", "target": 1}
{"code": "xsltCompileLocationPathPattern(xsltParserContextPtr ctxt, int novar) {\n    SKIP_BLANKS;\n    if ((CUR == '/') && (NXT(1) == '/')) {\n\tNEXT;\n\tNEXT;\n\tctxt->comp->priority = 0.5;\t\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else if (CUR == '/') {\n\tNEXT;\n\tSKIP_BLANKS;\n\tPUSH(XSLT_OP_ROOT, NULL, NULL, novar);\n\tif ((CUR != 0) && (CUR != '|')) {\n\t    PUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n\t    xsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t}\n    } else if (CUR == '*') {\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else if (CUR == '@') {\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else {\n\txmlChar *name;\n\tname = xsltScanNCName(ctxt);\n\tif (name == NULL) {\n\t    xsltTransformError(NULL, NULL, NULL,\n\t\t    \"xsltCompileLocationPathPattern : Name expected\\n\");\n\t    ctxt->error = 1;\n\t    return;\n\t}\n \tSKIP_BLANKS;\n \tif ((CUR == '(') && !xmlXPathIsNodeType(name)) {\n \t    xsltCompileIdKeyPattern(ctxt, name, 1, novar, 0);\n \t    if ((CUR == '/') && (NXT(1) == '/')) {\n \t\tPUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);\n \t\tNEXT;\n\t\tNEXT;\n\t\tSKIP_BLANKS;\n\t\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t    } else if (CUR == '/') {\n\t\tPUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n\t\tNEXT;\n\t\tSKIP_BLANKS;\n\t\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t    }\n\t    return;\n\t}\n\txsltCompileRelativePathPattern(ctxt, name, novar);\n    }\nerror:\n    return;\n}", "target": 1}
{"code": "ppp_create_interface(struct net *net, int unit, int *retp)\n{\n\tstruct ppp *ppp;\n\tstruct ppp_net *pn;\n\tstruct net_device *dev = NULL;\n\tint ret = -ENOMEM;\n\tint i;\n\tdev = alloc_netdev(sizeof(struct ppp), \"\", ppp_setup);\n\tif (!dev)\n\t\tgoto out1;\n\tpn = ppp_pernet(net);\n\tppp = netdev_priv(dev);\n\tppp->dev = dev;\n\tppp->mru = PPP_MRU;\n\tinit_ppp_file(&ppp->file, INTERFACE);\n\tppp->file.hdrlen = PPP_HDRLEN - 2;\t\n\tfor (i = 0; i < NUM_NP; ++i)\n\t\tppp->npmode[i] = NPMODE_PASS;\n\tINIT_LIST_HEAD(&ppp->channels);\n\tspin_lock_init(&ppp->rlock);\n\tspin_lock_init(&ppp->wlock);\n#ifdef CONFIG_PPP_MULTILINK\n\tppp->minseq = -1;\n\tskb_queue_head_init(&ppp->mrq);\n#endif \n\tdev_net_set(dev, net);\n\tret = -EEXIST;\n\tmutex_lock(&pn->all_ppp_mutex);\n\tif (unit < 0) {\n\t\tunit = unit_get(&pn->units_idr, ppp);\n\t\tif (unit < 0) {\n\t\t\t*retp = unit;\n\t\t\tgoto out2;\n\t\t}\n\t} else {\n\t\tif (unit_find(&pn->units_idr, unit))\n\t\t\tgoto out2; \n\t\tunit = unit_set(&pn->units_idr, ppp, unit);\n\t\tif (unit < 0)\n\t\t\tgoto out2;\n\t}\n\tppp->file.index = unit;\n\tsprintf(dev->name, \"ppp%d\", unit);\n\tret = register_netdev(dev);\n\tif (ret != 0) {\n\t\tunit_put(&pn->units_idr, unit);\n\t\tprintk(KERN_ERR \"PPP: couldn't register device %s (%d)\\n\",\n\t\t       dev->name, ret);\n\t\tgoto out2;\n\t}\n\tppp->ppp_net = net;\n\tatomic_inc(&ppp_unit_count);\n\tmutex_unlock(&pn->all_ppp_mutex);\n\t*retp = 0;\n\treturn ppp;\nout2:\n\tmutex_unlock(&pn->all_ppp_mutex);\n\tfree_netdev(dev);\nout1:\n\t*retp = ret;\n\treturn NULL;\n}", "target": 0}
{"code": "FoFiTrueType::FoFiTrueType(char *fileA, int lenA, GBool freeFileDataA, int faceIndexA):\n  FoFiBase(fileA, lenA, freeFileDataA)\n{\n  tables = NULL;\n  nTables = 0;\n  cmaps = NULL;\n  nCmaps = 0;\n  nameToGID = NULL;\n  parsedOk = gFalse;\n  faceIndex = faceIndexA;\n  gsubFeatureTable = 0;\n  gsubLookupList = 0;\n  parse();\n}", "target": 0}
{"code": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\tif ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)\n\t    && !vendor_intel(ctxt))\n\t\treturn emulate_ud(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tctxt->eflags &= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n {\n \tstruct oz_port *port = hport;\n \tstruct urb *urb;\n\tint err = 0;\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n \tif (!urb)\n \t\treturn;\n \tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n \t\tif (required_size > total_size)\n \t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}", "target": 1}
{"code": "relax_ng_parse(const char *path, xml_read_cb cb, void *arg)\n{\n\txmlTextReaderPtr reader;\n\txmlRelaxNGValidCtxtPtr rngvalidctx;\n\tint read;\n\tint error;\n\treader = xmlNewTextReaderFilename(path);\n\tif (reader == NULL)\n\t\treturn pr_val_err(\"Couldn't get XML '%s' file.\", path);\n\terror = xmlTextReaderRelaxNGSetSchema(reader, schema);\n\tif (error) {\n\t\terror = pr_val_err(\"Couldn't set Relax NG schema.\");\n\t\tgoto free_reader;\n\t}\n\trngvalidctx = xmlRelaxNGNewValidCtxt(schema);\n\tif (rngvalidctx == NULL) {\n\t\terror = pr_val_err(\"xmlRelaxNGNewValidCtxt() returned NULL\");\n\t\tgoto free_reader;\n\t}\n\txmlRelaxNGSetValidErrors(rngvalidctx, relax_ng_log_err,\n\t    relax_ng_log_warn, NULL);\n\terror = xmlTextReaderRelaxNGValidateCtxt(reader, rngvalidctx, 1);\n\tif (error) {\n\t\terror = pr_val_err(\"Invalid XML document\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlTextReaderSetStructuredErrorHandler(reader, relax_ng_log_str_err,\n\t    NULL);\n\twhile ((read = xmlTextReaderRead(reader)) == 1) {\n\t\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\t\tgoto free_valid_ctx;\n\t\t}\n\t\terror = cb(reader, arg);\n\t\tif (error)\n\t\t\tgoto free_valid_ctx;\n\t}\n\tif (read < 0) {\n\t\terror = pr_val_err(\"Error parsing XML document.\");\n\t\tgoto free_valid_ctx;\n\t}\n\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\n\txmlFreeTextReader(reader);\n\treturn 0;\nfree_valid_ctx:\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\nfree_reader:\n\txmlFreeTextReader(reader);\n\treturn error;\n}", "target": 1}
{"code": "token_continue(i_ctx_t *i_ctx_p, scanner_state * pstate, bool save)\n{\n    os_ptr op = osp;\n     int code;\n     ref token;\n     pop(1);                     \n again:\n            gs_scanner_error_object(i_ctx_p, pstate, &i_ctx_p->error_object);\n            break;\n        case scan_BOS:\n            code = 0;\n        case 0:         \n            push(2);\n            ref_assign(op - 1, &token);\n            make_true(op);\n            break;\n        case scan_EOF:          \n            push(1);\n            make_false(op);\n            code = 0;\n            break;\n        case scan_Refill:       \n            code = gs_scan_handle_refill(i_ctx_p, pstate, save,\n                                      ztoken_continue);\n            switch (code) {\n                case 0: \n                    goto again;\n                case o_push_estack:\n                    return code;\n            }\n            break;              \n    }", "target": 1}
{"code": "static void fuse_lib_init(void *data, struct fuse_conn_info *conn)\n{\n    struct fuse *f = (struct fuse *) data;\n    struct fuse_context_i *c = fuse_get_context_internal();\n    memset(c, 0, sizeof(*c));\n    c->ctx.fuse = f;\n    fuse_fs_init(f->fs, conn);\n}", "target": 0}
{"code": "mrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"n*&\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n  regs = mrb->c->ci->stack+1;\n  if (n == 0) {\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            \n    goto funcall;\n  }\n  ci->mid = name;\n  ci->u.target_class = c;\n  if (n == 15) {     \n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { \n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        \n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    \n    }\n    ci->n--;\n  }\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}", "target": 1}
{"code": "u32 gf_fs_get_http_rate(GF_FilterSession *fs)\n{\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return 0;\n\t}\n\treturn gf_dm_get_global_rate(fs->download_manager);\n}", "target": 0}
{"code": "int snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\tif (!card)\n\t\treturn -EINVAL;\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn 0;\n\t}\n\tcard->shutdown = 1;\n\tspin_unlock(&card->files_lock);\n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\tsnd_device_disconnect_all(card);\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n#endif\n\treturn 0;\t\n}", "target": 1}
{"code": "decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n {\n \tuint8_t route_target[8];\n \tu_int plen;\n \tND_TCHECK(pptr[0]);\n \tplen = pptr[0];   \n \tif (0 == plen) {\n \t\tsnprintf(buf, buflen, \"default route target\");\n \t\treturn 1;\n \t}\n \tif (32 > plen)\n \t\treturn -1;\n         plen-=32; \n \tif (64 < plen)\n \t\treturn -1;\n \tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n \tif (plen % 8) {\n \t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n \t\t\t((0xff00 >> (plen % 8)) & 0xff);\n \t}\n \tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n \t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n \treturn 5 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 1}
{"code": "static void session_init_control(struct avrcp *session)\n{\n\tsession->passthrough_id = avctp_register_passthrough_handler(\n\t\t\t\t\t\t\tsession->conn,\n\t\t\t\t\t\t\thandle_passthrough,\n\t\t\t\t\t\t\tsession);\n\tsession->passthrough_handlers = passthrough_handlers;\n\tsession->control_id = avctp_register_pdu_handler(session->conn,\n\t\t\t\t\t\t\tAVC_OP_VENDORDEP,\n\t\t\t\t\t\t\thandle_vendordep_pdu,\n\t\t\t\t\t\t\tsession);\n\tsession->control_handlers = control_handlers;\n\tif (btd_device_get_service(session->dev, AVRCP_TARGET_UUID) != NULL)\n\t\tcontroller_init(session);\n\tif (btd_device_get_service(session->dev, AVRCP_REMOTE_UUID) != NULL)\n\t\ttarget_init(session);\n}", "target": 0}
{"code": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n \tstruct cred *new;\n \tint ret;\n \tif (\n #ifdef CONFIG_KEYS\n \t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\tnew->user_ns = new->user->user_ns;\n#ifdef CONFIG_KEYS\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}", "target": 1}
{"code": "d_lite_upto(VALUE self, VALUE max)\n{\n    VALUE date;\n    RETURN_ENUMERATOR(self, 1, &max);\n    date = self;\n    while (FIX2INT(d_lite_cmp(date, max)) <= 0) {\n\trb_yield(date);\n\tdate = d_lite_plus(date, INT2FIX(1));\n    }\n    return self;\n}", "target": 0}
{"code": "GF_Err iSLT_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}", "target": 0}
{"code": "set_agg_lats_contain_variable (class ipcp_param_lattices *plats)\n{\n  bool ret = !plats->aggs_contain_variable;\n  plats->aggs_contain_variable = true;\n  return ret;\n}", "target": 0}
{"code": "ns_client_shuttingdown(ns_client_t *client) {\n\treturn (client->newstate == NS_CLIENTSTATE_FREED);\n}", "target": 0}
{"code": "ReverbConvolverStage::ReverbConvolverStage(const float* impulseResponse, size_t, size_t reverbTotalLatency, size_t stageOffset, size_t stageLength,\n                                           size_t fftSize, size_t renderPhase, size_t renderSliceSize, ReverbAccumulationBuffer* accumulationBuffer, bool directMode)\n    : m_accumulationBuffer(accumulationBuffer)\n    , m_accumulationReadIndex(0)\n    , m_inputReadIndex(0)\n    , m_directMode(directMode)\n{\n    ASSERT(impulseResponse);\n    ASSERT(accumulationBuffer);\n    if (!m_directMode) {\n        m_fftKernel = adoptPtr(new FFTFrame(fftSize));\n         m_fftKernel->doPaddedFFT(impulseResponse + stageOffset, stageLength);\n         m_fftConvolver = adoptPtr(new FFTConvolver(fftSize));\n     } else {\n         m_directKernel = adoptPtr(new AudioFloatArray(fftSize / 2));\n        m_directKernel->copyToRange(impulseResponse + stageOffset, 0, fftSize / 2);\n         m_directConvolver = adoptPtr(new DirectConvolver(renderSliceSize));\n     }\n     m_temporaryBuffer.allocate(renderSliceSize);\n    size_t totalDelay = stageOffset + reverbTotalLatency;\n    size_t halfSize = fftSize / 2;\n    if (!m_directMode) {\n        ASSERT(totalDelay >= halfSize);\n        if (totalDelay >= halfSize)\n            totalDelay -= halfSize;\n    }\n    int maxPreDelayLength = std::min(halfSize, totalDelay);\n    m_preDelayLength = totalDelay > 0 ? renderPhase % maxPreDelayLength : 0;\n    if (m_preDelayLength > totalDelay)\n        m_preDelayLength = 0;\n    m_postDelayLength = totalDelay - m_preDelayLength;\n    m_preReadWriteIndex = 0;\n    m_framesProcessed = 0; \n    size_t delayBufferSize = m_preDelayLength < fftSize ? fftSize : m_preDelayLength;\n    delayBufferSize = delayBufferSize < renderSliceSize ? renderSliceSize : delayBufferSize;\n    m_preDelayBuffer.allocate(delayBufferSize);\n}", "target": 1}
{"code": "aspath_unintern (struct aspath **aspath)\n{\n  struct aspath *ret;\n  struct aspath *asp = *aspath;\n  if (asp->refcnt)\n    asp->refcnt--;\n  if (asp->refcnt == 0)\n    {\n      ret = hash_release (ashash, asp);\n      assert (ret != NULL);\n      aspath_free (asp);\n      *aspath = NULL;\n    }\n}", "target": 0}
{"code": "static void mce_report_event(struct pt_regs *regs)\n{\n\tif (regs->flags & (X86_VM_MASK|X86_EFLAGS_IF)) {\n\t\tmce_notify_irq();\n\t\tmce_schedule_work();\n\t\treturn;\n\t}\n\tirq_work_queue(&mce_irq_work);\n}", "target": 0}
{"code": "    Rational TimeValue::toRational(long n) const\n    {\n        return Rational(toLong(n), 1);\n    }", "target": 0}
{"code": "static int hash_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_ahash_setkey(private, key, keylen);\n}", "target": 0}
{"code": "tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\tstruct tc_action_ops *a_o;\n\tstruct tc_action a;\n\tint ret = 0;\n\tstruct tcamsg *t = (struct tcamsg *) NLMSG_DATA(cb->nlh);\n\tchar *kind = find_dump_kind(cb->nlh);\n\tif (kind == NULL) {\n\t\tprintk(\"tc_dump_action: action bad kind\\n\");\n\t\treturn 0;\n\t}\n\ta_o = tc_lookup_action_n(kind);\n\tif (a_o == NULL) {\n\t\tprintk(\"failed to find %s\\n\", kind);\n\t\treturn 0;\n\t}\n\tmemset(&a, 0, sizeof(struct tc_action));\n\ta.ops = a_o;\n\tif (a_o->walk == NULL) {\n\t\tprintk(\"tc_dump_action: %s !capable of dumping table\\n\", kind);\n\t\tgoto rtattr_failure;\n\t}\n\tnlh = NLMSG_PUT(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t                cb->nlh->nlmsg_type, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\tret = a_o->walk(skb, cb, RTM_GETACTION, &a);\n\tif (ret < 0)\n\t\tgoto rtattr_failure;\n\tif (ret > 0) {\n\t\tx->rta_len = skb->tail - (u8 *) x;\n\t\tret = skb->len;\n\t} else\n\t\tskb_trim(skb, (u8*)x - skb->data);\n\tnlh->nlmsg_len = skb->tail - b;\n\tif (NETLINK_CB(cb->skb).pid && ret)\n\t\tnlh->nlmsg_flags |= NLM_F_MULTI;\n\tmodule_put(a_o->owner);\n\treturn skb->len;\nrtattr_failure:\nnlmsg_failure:\n\tmodule_put(a_o->owner);\n\tskb_trim(skb, b - skb->data);\n\treturn skb->len;\n}", "target": 1}
{"code": "get_stdinput(char *(*fn_readline)(const char *), void(*fn_addhist)(const char *))\n{\nint i;\ngstring * g = NULL;\nif (!fn_readline) { printf(\"> \"); fflush(stdout); }\nfor (i = 0;; i++)\n  {\n  uschar buffer[1024];\n  uschar *p, *ss;\n  #ifdef USE_READLINE\n  char *readline_line = NULL;\n  if (fn_readline != NULL)\n    {\n    if ((readline_line = fn_readline((i > 0)? \"\":\"> \")) == NULL) break;\n    if (*readline_line != 0 && fn_addhist != NULL) fn_addhist(readline_line);\n    p = US readline_line;\n    }\n  else\n  #endif\n    {\n    if (Ufgets(buffer, sizeof(buffer), stdin) == NULL) break;\n    p = buffer;\n    }\n  ss = p + (int)Ustrlen(p);\n  while (ss > p && isspace(ss[-1])) ss--;\n  if (i > 0)\n    {\n    while (p < ss && isspace(*p)) p++;   \n    }\n  g = string_catn(g, p, ss - p);\n  #ifdef USE_READLINE\n  if (fn_readline) free(readline_line);\n  #endif\n  if (ss == p || g->s[g->ptr-1] != '\\\\')\n    break;\n  --g->ptr;\n  (void) string_from_gstring(g);\n  }\nif (!g) printf(\"\\n\");\nreturn string_from_gstring(g);\n}", "target": 0}
{"code": "_parse_pat (GstMpegtsSection * section)\n{\n  GPtrArray *pat;\n  guint16 i = 0, nb_programs;\n  GstMpegtsPatProgram *program;\n  guint8 *data, *end;\n  data = section->data + 8;\n  end = section->data + section->section_length;\n  nb_programs = (end - 4 - data) / 4;\n  pat =\n      g_ptr_array_new_full (nb_programs,\n      (GDestroyNotify) _mpegts_pat_program_free);\n  while (data < end - 4) {\n    program = g_slice_new0 (GstMpegtsPatProgram);\n    program->program_number = GST_READ_UINT16_BE (data);\n    data += 2;\n    program->network_or_program_map_PID = GST_READ_UINT16_BE (data) & 0x1FFF;\n    data += 2;\n    g_ptr_array_index (pat, i) = program;\n    i++;\n  }\n  pat->len = nb_programs;\n  if (data != end - 4) {\n    GST_ERROR (\"at the end of PAT data != end - 4\");\n    g_ptr_array_unref (pat);\n    return NULL;\n  }\n  return (gpointer) pat;\n}", "target": 1}
{"code": "void ArcMemory::Load(const byte *Data,size_t Size)\n{\n  ArcData.Alloc(Size);\n  memcpy(&ArcData[0],Data,Size);\n  Loaded=true;\n  SeekPos=0;\n}", "target": 0}
{"code": "static inline bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn false;\n}", "target": 0}
{"code": "gen_S(codegen_scope *s, uint16_t i)\n{\n  emit_S(s, s->pc, i);\n  s->pc += 2;\n}", "target": 0}
{"code": "join_read_record_no_init(JOIN_TAB *tab)\n{\n  Copy_field *save_copy, *save_copy_end;\n  save_copy=     tab->read_record.copy_field;\n  save_copy_end= tab->read_record.copy_field_end;\n  init_read_record(&tab->read_record, tab->join->thd, tab->table,\n\t\t   tab->select, tab->filesort_result, 1, 1, FALSE);\n  tab->read_record.copy_field=     save_copy;\n  tab->read_record.copy_field_end= save_copy_end;\n  tab->read_record.read_record= rr_sequential_and_unpack;\n  return (*tab->read_record.read_record)(&tab->read_record);\n}", "target": 0}
{"code": "uint32_t enc_untrusted_qe_get_quote_size(uint32_t *quote_size) {\n  uint32_t result;\n  CHECK_OCALL(ocall_enc_untrusted_qe_get_quote_size(&result, quote_size));\n  return result;\n}", "target": 0}
{"code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}", "target": 1}
{"code": "decrypt(MPI output, MPI a, MPI b, ELG_secret_key *skey )\n{\n    MPI t1 = mpi_alloc_secure( mpi_get_nlimbs( skey->p ) );\n    mpi_normalize (a);\n    mpi_normalize (b);\n    mpi_powm( t1, a, skey->x, skey->p );\n    mpi_invm( t1, t1, skey->p );\n    mpi_mulm( output, b, t1, skey->p );\n#if 0\n    if( DBG_CIPHER ) {\n\tlog_mpidump(\"elg decrypted x= \", skey->x);\n\tlog_mpidump(\"elg decrypted p= \", skey->p);\n\tlog_mpidump(\"elg decrypted a= \", a);\n\tlog_mpidump(\"elg decrypted b= \", b);\n\tlog_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n    mpi_free(t1);\n}", "target": 1}
{"code": "RenderView::GetSearchProviderInstallState(const std::string& url) {\n  GURL inquiry_url = GURL(url);\n  if (inquiry_url.is_empty())\n    return ViewHostMsg_GetSearchProviderInstallState_Params::Denied();\n  ViewHostMsg_GetSearchProviderInstallState_Params install;\n  Send(new ViewHostMsg_GetSearchProviderInstallState(routing_id_,\n                                                     inquiry_url,\n                                                     &install));\n  return install;\n}", "target": 0}
{"code": "const git_tree_entry *git_treebuilder_get(git_treebuilder *bld, const char *filename)\n{\n\treturn treebuilder_get(bld, filename);\n}", "target": 0}
{"code": "QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n    if (!cipher.ok())\n        return cipherText;\n    if (direction)\n        temp2 = byteToB64(temp2);\n    return temp2;\n}", "target": 1}
{"code": "static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tif (sk->sk_state == BT_CLOSED)\n\t\treturn 0;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\treturn err;\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\thci_sock_cmsg(sk, msg, skb);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\tcase HCI_CHANNEL_MONITOR:\n\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "rb_reg_names(VALUE re)\n{\n    VALUE ary;\n    rb_reg_check(re);\n    ary = rb_ary_new_capa(onig_number_of_names(RREGEXP_PTR(re)));\n    onig_foreach_name(RREGEXP_PTR(re), reg_names_iter, (void*)ary);\n    return ary;\n}", "target": 0}
{"code": "void mark_progress(struct st_command* command __attribute__((unused)),\n                   int line)\n{\n  static ulonglong progress_start= 0; \n  DYNAMIC_STRING ds_progress;\n  char buf[32], *end;\n  ulonglong timer= timer_now();\n  if (!progress_start)\n    progress_start= timer;\n  timer-= progress_start;\n  if (init_dynamic_string(&ds_progress, \"\", 256, 256))\n    die(\"Out of memory\");\n  end= longlong10_to_str(timer, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  end= int10_to_str(line, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  dynstr_append(&ds_progress, cur_file->file_name);\n  dynstr_append_mem(&ds_progress, \":\", 1);\n  end= int10_to_str(cur_file->lineno, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\n\", 1);\n  progress_file.write(&ds_progress);\n  dynstr_free(&ds_progress);\n}", "target": 0}
{"code": "snmpDecodePacket(SnmpRequest * rq)\n{\n    struct snmp_pdu *PDU;\n    u_char *Community;\n    u_char *buf = rq->buf;\n    int len = rq->len;\n    allow_t allow = ACCESS_DENIED;\n    if (!Config.accessList.snmp) {\n        debugs(49, DBG_IMPORTANT, \"WARNING: snmp_access not configured. agent query DENIED from : \" << rq->from);\n        return;\n    }\n    debugs(49, 5, HERE << \"Called.\");\n    PDU = snmp_pdu_create(0);\n    rq->session.Version = SNMP_VERSION_1;\n    Community = snmp_parse(&rq->session, PDU, buf, len);\n    if (Community) {\n        ACLFilledChecklist checklist(Config.accessList.snmp, NULL, NULL);\n        checklist.src_addr = rq->from;\n        checklist.snmp_community = (char *) Community;\n        allow = checklist.fastCheck();\n        if (allow == ACCESS_ALLOWED && (snmp_coexist_V2toV1(PDU))) {\n            rq->community = Community;\n            rq->PDU = PDU;\n            debugs(49, 5, \"snmpAgentParse: reqid=[\" << PDU->reqid << \"]\");\n            snmpConstructReponse(rq);\n        } else {\n            debugs(49, DBG_IMPORTANT, \"WARNING: SNMP agent query DENIED from : \" << rq->from);\n        }\n        xfree(Community);\n    } else {\n        debugs(49, DBG_IMPORTANT, \"WARNING: Failed SNMP agent query from : \" << rq->from);\n        snmp_free_pdu(PDU);\n    }\n}", "target": 1}
{"code": "void LIRGenerator::do_ArrayCopy(Intrinsic* x) {\n  assert(x->number_of_arguments() == 5, \"wrong type\");\n  CodeEmitInfo* info = state_for(x, x->state());\n  LIRItem src(x->argument_at(0), this);\n  LIRItem src_pos(x->argument_at(1), this);\n  LIRItem dst(x->argument_at(2), this);\n  LIRItem dst_pos(x->argument_at(3), this);\n  LIRItem length(x->argument_at(4), this);\n#ifndef _LP64\n  src.load_item_force     (FrameMap::rcx_oop_opr);\n  src_pos.load_item_force (FrameMap::rdx_opr);\n  dst.load_item_force     (FrameMap::rax_oop_opr);\n  dst_pos.load_item_force (FrameMap::rbx_opr);\n  length.load_item_force  (FrameMap::rdi_opr);\n  LIR_Opr tmp =           (FrameMap::rsi_opr);\n#else\n  src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));\n  src_pos.load_item_force (FrameMap::as_opr(j_rarg1));\n  dst.load_item_force     (FrameMap::as_oop_opr(j_rarg2));\n  dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));\n  length.load_item_force  (FrameMap::as_opr(j_rarg4));\n  LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);\n#endif \n  set_no_result(x);\n  int flags;\n  ciArrayKlass* expected_type;\n  arraycopy_helper(x, &flags, &expected_type);\n  __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(), length.result(), tmp, expected_type, flags, info); \n}", "target": 0}
{"code": "unsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_diff_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& key_compare_func,\n                         const Array& args ) {\n  Variant func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, true COMMA true COMMA cmp_func COMMA &func);\n}", "target": 0}
{"code": "ext4_find_extent(struct inode *inode, ext4_lblk_t block,\n\t\t struct ext4_ext_path **orig_path, int flags)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct buffer_head *bh;\n\tstruct ext4_ext_path *path = orig_path ? *orig_path : NULL;\n\tshort int depth, i, ppos = 0;\n\tint ret;\n\teh = ext_inode_hdr(inode);\n\tdepth = ext_depth(inode);\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tif (depth > path[0].p_maxdepth) {\n\t\t\tkfree(path);\n\t\t\t*orig_path = path = NULL;\n\t\t}\n\t}\n\tif (!path) {\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 2),\n\t\t\t\tGFP_NOFS);\n\t\tif (unlikely(!path))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0].p_maxdepth = depth + 1;\n\t}\n\tpath[0].p_hdr = eh;\n\tpath[0].p_bh = NULL;\n\ti = depth;\n\twhile (i) {\n\t\text_debug(\"depth %d: num %d, max %d\\n\",\n\t\t\t  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t\text4_ext_binsearch_idx(inode, path + ppos, block);\n\t\tpath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\n\t\tpath[ppos].p_depth = i;\n\t\tpath[ppos].p_ext = NULL;\n\t\tbh = read_extent_tree_block(inode, path[ppos].p_block, --i,\n\t\t\t\t\t    flags);\n\t\tif (IS_ERR(bh)) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tgoto err;\n\t\t}\n\t\teh = ext_block_hdr(bh);\n\t\tppos++;\n\t\tpath[ppos].p_bh = bh;\n\t\tpath[ppos].p_hdr = eh;\n\t}\n\tpath[ppos].p_depth = i;\n\tpath[ppos].p_ext = NULL;\n\tpath[ppos].p_idx = NULL;\n\text4_ext_binsearch(inode, path + ppos, block);\n\tif (path[ppos].p_ext)\n\t\tpath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\n\text4_ext_show_path(inode, path);\n\treturn path;\nerr:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (orig_path)\n\t\t*orig_path = NULL;\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "Item_ref::Item_ref(TABLE_LIST *view_arg, Item **item,\n                   const char *field_name_arg, bool alias_name_used_arg)\n  :Item_ident(view_arg, field_name_arg),\n   result_field(NULL), ref(item), reference_trough_name(0)\n{\n  alias_name_used= alias_name_used_arg;\n  if ((set_properties_only= (ref && *ref && (*ref)->fixed)))\n    set_properties();\n}", "target": 0}
{"code": "nsPluginInstance::setupCookies(const std::string& pageurl)\n{\n    std::string::size_type pos;\n    pos = pageurl.find(\"/\", pageurl.find(\"\n    std::string url = pageurl.substr(0, pos);\n    std::string ncookie;\n    char *cookie = 0;\n    uint32_t length = 0;\n    NPError rv = NPERR_GENERIC_ERROR;\n#if NPAPI_VERSION != 190\n    if (NPNFuncs.getvalueforurl) {\n        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),\n                                &cookie, &length);\n    } else {\n        LOG_ONCE( gnash::log_debug(\"Browser doesn't support getvalueforurl\") );\n    }\n#endif\n    if (rv == NPERR_GENERIC_ERROR) {\n        log_debug(\"Trying window.document.cookie for cookies\");\n        ncookie = getDocumentProp(\"cookie\");\n    }\n    if (cookie) {\n        ncookie.assign(cookie, length);\n        NPN_MemFree(cookie);\n    }\n    if (ncookie.empty()) {\n        gnash::log_debug(\"No stored Cookie for %s\", url);\n        return;\n    }\n    gnash::log_debug(\"The Cookie for %s is %s\", url, ncookie);\n    std::ofstream cookiefile;\n    std::stringstream ss;\n     ss << \"/tmp/gnash-cookies.\" << getpid();\n     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);\n    typedef boost::char_separator<char> char_sep;\n    typedef boost::tokenizer<char_sep> tokenizer;\n    tokenizer tok(ncookie, char_sep(\";\"));\n    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {\n        cookiefile << \"Set-Cookie: \" << *it << std::endl;\n    }\n    cookiefile.close();\n    if (setenv(\"GNASH_COOKIES_IN\", ss.str().c_str(), 1) < 0) {\n        gnash::log_error(\n            \"Couldn't set environment variable GNASH_COOKIES_IN to %s\",\n            ncookie);\n    }\n}", "target": 1}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}", "target": 1}
{"code": "void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}", "target": 1}
{"code": " int fscrypt_process_policy(struct inode *inode,\n \t\t\t\tconst struct fscrypt_policy *policy)\n {\n \tif (policy->version != 0)\n \t\treturn -EINVAL;\n\tif (!inode_has_encryption_context(inode)) {\n\t\tif (!inode->i_sb->s_cop->empty_dir)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!inode->i_sb->s_cop->empty_dir(inode))\n\t\t\treturn -ENOTEMPTY;\n\t\treturn create_encryption_context_from_policy(inode, policy);\n\t}\n\tif (is_encryption_context_consistent_with_policy(inode, policy))\n\t\treturn 0;\n\tprintk(KERN_WARNING \"%s: Policy inconsistent with encryption context\\n\",\n\t       __func__);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_set_server_protocol(server_rec* s, const char* proto)\n{\n    core_server_config *conf = ap_get_core_module_config(s->module_config);\n    conf->protocol = proto;\n}", "target": 0}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct VhostUserMsg *msg)\n{\n\tuint16_t vring_idx;\n\tswitch (msg->request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = msg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = msg->payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = msg->payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid vring index: %u\\n\", vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n {\n \tconst char *b = (const char *)sst->sst_tab;\n \tconst char *e = ((const char *)p) + tail;\n \t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)\n \t\treturn 0;\n \tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n \t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n \t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));\n \terrno = EFTYPE;\n \treturn -1;\n }", "target": 1}
{"code": "void GfxColorSpace::createMapping(std::vector<GfxSeparationColorSpace *> *separationList, int maxSepComps)\n{\n    return;\n}", "target": 0}
{"code": "qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), nfunc, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "jbig2_decode_gray_scale_image(Jbig2Ctx *ctx, Jbig2Segment *segment,\n                              const byte *data, const size_t size,\n                              bool GSMMR, uint32_t GSW, uint32_t GSH,\n                              uint32_t GSBPP, bool GSUSESKIP, Jbig2Image *GSKIP, int GSTEMPLATE, Jbig2ArithCx *GB_stats)\n {\n     uint8_t **GSVALS = NULL;\n     size_t consumed_bytes = 0;\n    int i, j, code, stride;\n    int x, y;\n     Jbig2Image **GSPLANES;\n     Jbig2GenericRegionParams rparams;\n     Jbig2WordStream *ws = NULL;\n    Jbig2ArithState *as = NULL;\n    GSPLANES = jbig2_new(ctx, Jbig2Image *, GSBPP);\n    if (GSPLANES == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %d bytes for GSPLANES\", GSBPP);\n        return NULL;\n    }\n    for (i = 0; i < GSBPP; ++i) {\n        GSPLANES[i] = jbig2_image_new(ctx, GSW, GSH);\n         if (GSPLANES[i] == NULL) {\n             jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate %dx%d image for GSPLANES\", GSW, GSH);\n            for (j = i - 1; j >= 0; --j) {\n                jbig2_image_release(ctx, GSPLANES[j]);\n            }\n             jbig2_free(ctx->allocator, GSPLANES);\n             return NULL;\n         }\n        }\n    }", "target": 1}
{"code": " static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n {\n \tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n \tdctx = (dpIOCtxPtr) ctx;\n \tdp = dctx->dp;\n \tremain = dp->logicalSize - dp->pos;\n \tif(remain >= len) {\n \t\trlen = len;\n \t} else {\n \t\tif(remain <= 0) {\n\t\t\treturn 0; \n \t\t}\n \t\trlen = remain;\n \t}\n \tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n \tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "int nfc_stop_poll(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->polling) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tdev->ops->stop_poll(dev);\n\tdev->polling = false;\n\tdev->rf_mode = NFC_RF_NONE;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "log2vis_encoded_string (PyObject * string, const char *encoding,\n\t\t\tFriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t\n\tPyObject *result = NULL;\t\n\tlogical = PyUnicode_Decode (PyString_AS_STRING (string),\n\t\t\t\t    PyString_GET_SIZE (string),\n\t\t\t\t    encoding, \"strict\");\n\tif (logical == NULL)\n\t\treturn NULL;\n\tif (strcmp (encoding, \"utf-8\") == 0)\n\t\tresult = log2vis_utf8 (string,\n\t\t\t\t       PyUnicode_GET_SIZE (logical),\n\t\t\t\t       base_direction, clean, reordernsm);\n\telse\n\t{\n\t\tPyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);\n\t\tif (visual)\n\t\t{\n\t\t\tresult = PyUnicode_Encode (PyUnicode_AS_UNICODE\n\t\t\t\t\t\t   (visual),\n\t\t\t\t\t\t   PyUnicode_GET_SIZE (visual),\n\t\t\t\t\t\t   encoding, \"strict\");\n\t\t\tPy_DECREF (visual);\n\t\t}\n\t}\n\tPy_DECREF (logical);\n\treturn result;\n}", "target": 1}
{"code": "sshsk_open(const char *path)\n{\n\tstruct sshsk_provider *ret = NULL;\n\tuint32_t version;\n\tif (path == NULL || *path == '\\0') {\n\t\terror(\"No FIDO SecurityKeyProvider specified\");\n\t\treturn NULL;\n\t}\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\terror_f(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\tif ((ret->path = strdup(path)) == NULL) {\n\t\terror_f(\"strdup failed\");\n\t\tgoto fail;\n\t}\n\tif (strcasecmp(ret->path, \"internal\") == 0) {\n\t\tret->sk_enroll = ssh_sk_enroll;\n\t\tret->sk_sign = ssh_sk_sign;\n\t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n\t\treturn ret;\n\t}\n\tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n\t    \"sk_api_version\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tversion = ret->sk_api_version();\n\tdebug_f(\"provider %s implements version 0x%08lx\", ret->path,\n\t    (u_long)version);\n\tif ((version & SSH_SK_VERSION_MAJOR_MASK) != SSH_SK_VERSION_MAJOR) {\n\t\terror(\"Provider \\\"%s\\\" implements unsupported \"\n\t\t    \"version 0x%08lx (supported: 0x%08lx)\",\n\t\t    path, (u_long)version, (u_long)SSH_SK_VERSION_MAJOR);\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_enroll = dlsym(ret->dlhandle, \"sk_enroll\")) == NULL) {\n\t\terror(\"Provider %s dlsym(sk_enroll) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_sign = dlsym(ret->dlhandle, \"sk_sign\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_sign) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_load_resident_keys = dlsym(ret->dlhandle,\n\t    \"sk_load_resident_keys\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_load_resident_keys) \"\n\t\t    \"failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\treturn ret;\nfail:\n\tsshsk_free(ret);\n\treturn NULL;\n}", "target": 1}
{"code": "static void scrub_spilled_slot(u8 *stype)\n{\n\tif (*stype != STACK_INVALID)\n\t\t*stype = STACK_MISC;\n}", "target": 0}
{"code": "GF_Err iKMS_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMAKMSBox *ptr = (GF_ISMAKMSBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n    if (ptr->URI)\n        gf_bs_write_data(bs, ptr->URI, (u32) strlen(ptr->URI));\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}", "target": 0}
{"code": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}", "target": 1}
{"code": "static int decode_sao_offset_sign(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_offset_sign\\n\");\n  int value = decode_CABAC_bypass(&tctx->cabac_decoder);\n  logtrace(LogSymbols,\"$1 sao_offset_sign=%d\\n\",value);\n  return value;\n}", "target": 0}
{"code": "static bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {\n\tbool phdr_found = false;\n\tint i;\n#if R_BIN_ELF64\n\tconst bool is_elf64 = true;\n#else\n\tconst bool is_elf64 = false;\n#endif\n\tut64 phnum = Elf_(r_bin_elf_get_phnum) (bin);\n\tfor (i = 0; i < phnum; i++) {\n\t\tut8 phdr[sizeof (Elf_(Phdr))] = {0};\n\t\tint j = 0;\n\t\tconst size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));\n\t\tint len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_ERROR (\"read (phdr)\");\n\t\t\tR_FREE (bin->phdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->phdr[i].p_type = READ32 (phdr, j);\n\t\tif (bin->phdr[i].p_type == PT_PHDR) {\n\t\t\tphdr_found = true;\n\t\t}\n\t\tif (is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_offset = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_vaddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_paddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_filesz = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_memsz = R_BIN_ELF_READWORD (phdr, j);\n\t\tif (!is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_align = R_BIN_ELF_READWORD (phdr, j);\n\t}\n\tif (linux_kernel_hack && phdr_found) {\n\t\tut64 load_addr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\tbin->ehdr.e_phoff = Elf_(r_bin_elf_v2p) (bin, load_addr + bin->ehdr.e_phoff);\n\t\treturn read_phdr (bin, false);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "clamp_indexed(const fz_colorspace *cs, const float *in, float *out)\n{\n\tstruct indexed *idx = cs->data;\n\t*out = fz_clamp(*in, 0, idx->high) / 255.0f; \n}", "target": 0}
{"code": "GF_Err fdpa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_u16(bs, ptr->info.transport_object_identifier);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "bool RenderView::isSelectTrailingWhitespaceEnabled() {\n#if defined(OS_WIN)\n  return true;\n#else\n  return false;\n#endif\n}", "target": 0}
{"code": "bool Tensor::FromProto(Allocator* a, const TensorProto& proto) {\n  CHECK_NOTNULL(a);\n  TensorBuffer* p = nullptr;\n  if (!TensorShape::IsValid(proto.tensor_shape())) return false;\n  if (proto.dtype() == DT_INVALID) return false;\n  TensorShape shape(proto.tensor_shape());\n  const int64_t N = shape.num_elements();\n  if (N > 0 && proto.dtype()) {\n    bool dtype_error = false;\n    if (!proto.tensor_content().empty()) {\n      const auto& content = proto.tensor_content();\n      CASES_WITH_DEFAULT(proto.dtype(), p = Helper<T>::Decode(a, content, N),\n                         dtype_error = true, dtype_error = true);\n    } else {\n      CASES_WITH_DEFAULT(proto.dtype(), p = FromProtoField<T>(a, proto, N),\n                         dtype_error = true, dtype_error = true);\n    }\n    if (dtype_error || p == nullptr) return false;\n  }\n  shape_ = shape;\n  set_dtype(proto.dtype());\n  UnrefIfNonNull(buf_);\n  buf_ = p;\n  if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) {\n    LogMemory::RecordTensorAllocation(\"Unknown (from Proto)\",\n                                      LogMemory::UNKNOWN_STEP_ID, *this);\n  }\n  return true;\n}", "target": 1}
{"code": "  void GetCachedOrigins(StorageType type, std::set<GURL>* origins) {\n    ASSERT_TRUE(origins != NULL);\n    origins->clear();\n    quota_manager_->GetCachedOrigins(type, origins);\n  }", "target": 0}
{"code": "    template<typename t>\n    CImg<Tfloat> get_blur_guided(const CImg<t>& guide, const float radius, const float regularization) const {\n      if (!is_sameXYZ(guide))\n        throw CImgArgumentException(_cimg_instance\n                                    \"blur_guided(): Invalid size for specified guide image (%u,%u,%u,%u,%p).\",\n                                    cimg_instance,\n                                    guide._width,guide._height,guide._depth,guide._spectrum,guide._data);\n      if (is_empty() || !radius) return *this;\n      const int _radius = radius>=0?(int)radius:(int)(-radius*cimg::max(_width,_height,_depth)/100);\n      float _regularization = regularization;\n      if (regularization<0) {\n        T edge_min, edge_max = guide.max_min(edge_min);\n        if (edge_min==edge_max) return *this;\n        _regularization = -regularization*(edge_max - edge_min)/100;\n      }\n      _regularization = std::max(_regularization,0.01f);\n      const unsigned int psize = (unsigned int)(1 + 2*_radius);\n      const CImg<uintT> N = CImg<uintT>(_width,_height,_depth,1,1)._blur_guided(psize);\n      CImg<Tfloat>\n        mean_I = CImg<Tfloat>(guide,false)._blur_guided(psize).div(N),\n        mean_p = CImg<Tfloat>(*this,false)._blur_guided(psize).div(N),\n        cov_Ip = CImg<Tfloat>(*this,false).mul(guide)._blur_guided(psize).div(N)-=mean_p.get_mul(mean_I),\n        var_I = CImg<Tfloat>(guide,false).sqr()._blur_guided(psize).div(N)-=mean_I.get_sqr(),\n        &a = cov_Ip.div(var_I+=_regularization),\n        &b = mean_p-=a.get_mul(mean_I);\n      a._blur_guided(psize).div(N);\n      b._blur_guided(psize).div(N);\n      return a.mul(guide)+=b;", "target": 0}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int mxf_read_sync(AVIOContext *pb, const uint8_t *key, unsigned size)\n{\n    int i, b;\n    for (i = 0; i < size && !avio_feof(pb); i++) {\n        b = avio_r8(pb);\n        if (b == key[0])\n            i = 0;\n        else if (b != key[i])\n            i = -1;\n    }\n    return i == size;\n}", "target": 0}
{"code": "newEntry(struct rx_call *call, char aname[], afs_int32 flag, afs_int32 oid,\n\t afs_int32 *aid, afs_int32 *cid)\n{\n    afs_int32 code;\n    struct ubik_trans *tt;\n    int admin;\n    char cname[PR_MAXNAMELEN];\n    stolower(aname);\n    code = Initdb();\n    if (code)\n\treturn code;\n    code = ubik_BeginTrans(dbase, UBIK_WRITETRANS, &tt);\n    if (code)\n\treturn code;\n    code = ubik_SetLock(tt, 1, 1, LOCKWRITE);\n    if (code)\n\tABORT_WITH(tt, code);\n    code = read_DbHeader(tt);\n    if (code)\n\tABORT_WITH(tt, code);\n     code = WhoIsThisWithName(call, tt, cid, cname);\n    if (code != 2) {           \n       if (code)\n           ABORT_WITH(tt, PRPERM);\n       admin = IsAMemberOf(tt, *cid, SYSADMINID);\n    } else {\n       admin = ((!restricted && !strcmp(aname, cname))) || IsAMemberOf(tt, *cid, SYSADMINID);\n       oid = *cid = SYSADMINID;\n     }\n     if (!CreateOK(tt, *cid, oid, flag, admin))\n        ABORT_WITH(tt, PRPERM);\n    if (code)\n\treturn code;\n    return PRSUCCESS;\n}", "target": 1}
{"code": "TEST_F(ExprMatchTest, LtWithRHSFieldPathMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: {$lt: [3, '$x']}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 10)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 3)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 1)));\n}", "target": 0}
{"code": "void handle_debug_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n        const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, DEBUG_MSG);\n    }\n}", "target": 1}
{"code": "static uint32_t get_cmd(ESPState *s, uint32_t maxlen)\n{\n    uint8_t buf[ESP_CMDFIFO_SZ];\n    uint32_t dmalen, n;\n    int target;\n    target = s->wregs[ESP_WBUSID] & BUSID_DID;\n    if (s->dma) {\n        dmalen = MIN(esp_get_tc(s), maxlen);\n        if (dmalen == 0) {\n            return 0;\n        }\n        if (s->dma_memory_read) {\n            s->dma_memory_read(s->dma_opaque, buf, dmalen);\n            fifo8_push_all(&s->cmdfifo, buf, dmalen);\n        } else {\n            if (esp_select(s) < 0) {\n                fifo8_reset(&s->cmdfifo);\n                return -1;\n            }\n            esp_raise_drq(s);\n            fifo8_reset(&s->cmdfifo);\n            return 0;\n        }\n    } else {\n        dmalen = MIN(fifo8_num_used(&s->fifo), maxlen);\n        if (dmalen == 0) {\n            return 0;\n        }\n        n = esp_fifo_pop_buf(&s->fifo, buf, dmalen);\n        if (n >= 3) {\n            buf[0] = buf[2] >> 5;\n        }\n        fifo8_push_all(&s->cmdfifo, buf, n);\n    }\n    trace_esp_get_cmd(dmalen, target);\n    if (esp_select(s) < 0) {\n        fifo8_reset(&s->cmdfifo);\n        return -1;\n    }\n    return dmalen;\n}", "target": 1}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n \t\tpktinfo->ipi_ifindex = 0;\n \t\tpktinfo->ipi_spec_dst.s_addr = 0;\n \t}\n\tskb_dst_drop(skb);\n }", "target": 1}
{"code": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}", "target": 1}
{"code": "static inline int prb_curr_blk_in_use(struct kbdq_core *pkc,\n\t\t\t\t      struct block_desc *pbd)\n{\n\treturn TP_STATUS_USER & BLOCK_STATUS(pbd);\n}", "target": 0}
{"code": "read_attribute(cdk_stream_t inp, size_t pktlen, cdk_pkt_userid_t attr,\n\t       int name_size)\n{\n\tconst byte *p;\n\tbyte *buf;\n\tsize_t len, nread;\n\tcdk_error_t rc;\n\tif (!inp || !attr || !pktlen)\n\t\treturn CDK_Inv_Value;\n\tif (DEBUG_PKT)\n\t\t_gnutls_write_log(\"read_attribute: %d octets\\n\",\n\t\t\t\t  (int) pktlen);\n\t_gnutls_str_cpy(attr->name, name_size, ATTRIBUTE);\n\tattr->len = MIN(name_size, sizeof(ATTRIBUTE) - 1);\n\tbuf = cdk_calloc(1, pktlen);\n\tif (!buf)\n\t\treturn CDK_Out_Of_Core;\n\trc = stream_read(inp, buf, pktlen, &nread);\n\tif (rc) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tp = buf;\n\tlen = *p++;\n\tpktlen--;\n\tif (len == 255) {\n\t\tlen = _cdk_buftou32(p);\n\t\tp += 4;\n\t\tpktlen -= 4;\n\t} else if (len >= 192) {\n\t\tif (pktlen < 2) {\n\t\t\tcdk_free(buf);\n\t\t\treturn CDK_Inv_Packet;\n\t\t}\n\t\tlen = ((len - 192) << 8) + *p + 192;\n\t\tp++;\n\t\tpktlen--;\n\t}\n\tif (*p != 1) {\t\t\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tp++;\n\tlen--;\n\tif (len >= pktlen) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Inv_Packet;\n\t}\n\tattr->attrib_img = cdk_calloc(1, len);\n\tif (!attr->attrib_img) {\n\t\tcdk_free(buf);\n\t\treturn CDK_Out_Of_Core;\n\t}\n\tattr->attrib_len = len;\n\tmemcpy(attr->attrib_img, p, len);\n\tcdk_free(buf);\n\treturn rc;\n}", "target": 1}
{"code": "static TEE_Result do_allocate_keypair(struct dsa_keypair *key, size_t l_bits,\n\t\t\t\t      size_t n_bits)\n{\n\tDSA_TRACE(\"DSA allocate Keypair of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(n_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "LuaSettings::LuaSettings(const std::string &filename, bool write_allowed) :\n\tm_filename(filename),\n\tm_is_own_settings(true),\n\tm_write_allowed(write_allowed)\n{\n\tm_settings = new Settings();\n\tm_settings->readConfigFile(filename.c_str());\n}", "target": 0}
{"code": "static void vmx_complete_interrupts(struct vcpu_vmx *vmx)\n{\n\t__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,\n\t\t\t\t  VM_EXIT_INSTRUCTION_LEN,\n\t\t\t\t  IDT_VECTORING_ERROR_CODE);\n}", "target": 0}
{"code": "const char *ssh_scp_request_get_filename(ssh_scp scp)\n{\n    if (scp == NULL) {\n        return NULL;\n    }\n    return scp->request_name;\n}", "target": 0}
{"code": "create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_ADD, NULL, NULL)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tattr->size = usize;\n\t}\n\tret = copy_to_user(uattr, attr, usize);\n\tif (ret)\n\t\treturn -EFAULT;\nout:\n\treturn ret;\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}", "target": 1}
{"code": "void usb_ep_combine_input_packets(USBEndpoint *ep)\n{\n    USBPacket *p, *u, *next, *prev = NULL, *first = NULL;\n    USBPort *port = ep->dev->port;\n    int totalsize;\n    assert(ep->pipeline);\n    assert(ep->pid == USB_TOKEN_IN);\n    QTAILQ_FOREACH_SAFE(p, &ep->queue, queue, next) {\n        if (ep->halted) {\n            p->status = USB_RET_REMOVE_FROM_QUEUE;\n            port->ops->complete(port, p);\n            continue;\n        }\n        if (p->state == USB_PACKET_ASYNC) {\n            prev = p;\n            continue;\n        }\n        usb_packet_check_state(p, USB_PACKET_QUEUED);\n        if (prev && prev->short_not_ok) {\n            break;\n        }\n        if (first) {\n            if (first->combined == NULL) {\n                USBCombinedPacket *combined = g_new0(USBCombinedPacket, 1);\n                combined->first = first;\n                QTAILQ_INIT(&combined->packets);\n                qemu_iovec_init(&combined->iov, 2);\n                usb_combined_packet_add(combined, first);\n            }\n            usb_combined_packet_add(first->combined, p);\n        } else {\n            first = p;\n        }\n        totalsize = (p->combined) ? p->combined->iov.size : p->iov.size;\n        if ((p->iov.size % ep->max_packet_size) != 0 || !p->short_not_ok ||\n                next == NULL ||\n                (totalsize == (16 * KiB - 36) && p->int_req)) {\n            usb_device_handle_data(ep->dev, first);\n            assert(first->status == USB_RET_ASYNC);\n            if (first->combined) {\n                QTAILQ_FOREACH(u, &first->combined->packets, combined_entry) {\n                    usb_packet_set_state(u, USB_PACKET_ASYNC);\n                }\n            } else {\n                usb_packet_set_state(first, USB_PACKET_ASYNC);\n            }\n            first = NULL;\n            prev = p;\n        }\n    }\n}", "target": 1}
{"code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}", "target": 1}
{"code": "bool zone_watermark_ok_safe(struct zone *z, unsigned int order,\n\t\t\tunsigned long mark, int classzone_idx)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\tif (z->percpu_drift_mark && free_pages < z->percpu_drift_mark)\n\t\tfree_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, 0,\n\t\t\t\t\t\t\t\tfree_pages);\n}", "target": 0}
{"code": "static int acpi_smbus_hc_add(struct acpi_device *device)\n{\n\tint status;\n\tunsigned long long val;\n\tstruct acpi_smb_hc *hc;\n\tif (!device)\n\t\treturn -EINVAL;\n\tstatus = acpi_evaluate_integer(device->handle, \"_EC\", NULL, &val);\n\tif (ACPI_FAILURE(status)) {\n\t\tprintk(KERN_ERR PREFIX \"error obtaining _EC.\\n\");\n\t\treturn -EIO;\n\t}\n\tstrcpy(acpi_device_name(device), ACPI_SMB_HC_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_SMB_HC_CLASS);\n\thc = kzalloc(sizeof(struct acpi_smb_hc), GFP_KERNEL);\n\tif (!hc)\n\t\treturn -ENOMEM;\n\tmutex_init(&hc->lock);\n\tinit_waitqueue_head(&hc->wait);\n\thc->ec = acpi_driver_data(device->parent);\n\thc->offset = (val >> 8) & 0xff;\n\thc->query_bit = val & 0xff;\n\tdevice->driver_data = hc;\n\tacpi_ec_add_query_handler(hc->ec, hc->query_bit, NULL, smbus_alarm, hc);\n\tprintk(KERN_INFO PREFIX \"SBS HC: EC = 0x%p, offset = 0x%0x, query_bit = 0x%0x\\n\",\n\t\thc->ec, hc->offset, hc->query_bit);\n\treturn 0;\n}", "target": 1}
{"code": "GF_Box *trun_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRunBox, GF_ISOM_BOX_TYPE_TRUN);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "SPL_METHOD(DirectoryIterator, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tintern->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t\tintern->file_name = NULL;\n\t}\n}", "target": 0}
{"code": "static bool manager_get_show_status(Manager *m, StatusType type) {\n        assert(m);\n        if (m->running_as != SYSTEMD_SYSTEM)\n                return false;\n        if (m->no_console_output)\n                return false;\n        if (!IN_SET(manager_state(m), MANAGER_INITIALIZING, MANAGER_STARTING, MANAGER_STOPPING))\n                return false;\n        if (type != STATUS_TYPE_EMERGENCY && manager_check_ask_password(m) > 0)\n                return false;\n        if (m->show_status > 0)\n                return true;\n        return plymouth_running();\n}", "target": 0}
{"code": "void FrameLoader::load(const ResourceRequest& request, const SubstituteData& substituteData, bool lockHistory)\n{\n    if (m_inStopAllLoaders)\n        return;\n    m_loadType = FrameLoadTypeStandard;\n    RefPtr<DocumentLoader> loader = m_client->createDocumentLoader(request, substituteData);\n    if (lockHistory && m_documentLoader)\n        loader->setClientRedirectSourceForHistory(m_documentLoader->didCreateGlobalHistoryEntry() ? m_documentLoader->urlForHistory() : m_documentLoader->clientRedirectSourceForHistory());\n    load(loader.get());\n}", "target": 0}
{"code": "static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)\n{\n  unsigned result = 0;\n  size_t i;\n  for(i = nbits - 1; i < nbits; i--)\n  {\n    result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;\n  }\n  return result;\n}", "target": 0}
{"code": "void dname_pkt_copy(sldns_buffer* pkt, uint8_t* to, uint8_t* dname)\n{\n\tsize_t len = 0;\n\tuint8_t lablen;\n\tlablen = *dname++;\n\twhile(lablen) {\n\t\tif(LABEL_IS_PTR(lablen)) {\n\t\t\tdname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));\n\t\t\tlablen = *dname++;\n\t\t\tcontinue;\n\t\t}\n\t\tlog_assert(lablen <= LDNS_MAX_LABELLEN);\n\t\tlen += (size_t)lablen+1;\n\t\tif(len >= LDNS_MAX_DOMAINLEN) {\n\t\t\t*to = 0; \n\t\t\tlog_err(\"bad dname in dname_pkt_copy\");\n\t\t\treturn;\n\t\t}\n\t\t*to++ = lablen;\n\t\tmemmove(to, dname, lablen);\n\t\tdname += lablen;\n\t\tto += lablen;\n\t\tlablen = *dname++;\n\t}\n\t*to = 0;\n}", "target": 1}
{"code": "void RenderView::OnPepperPluginDestroy(\n    WebPluginDelegatePepper* pepper_plugin) {\n  std::set<WebPluginDelegatePepper*>::iterator found_pepper =\n      current_oldstyle_pepper_plugins_.find(pepper_plugin);\n  if (found_pepper == current_oldstyle_pepper_plugins_.end()) {\n    NOTREACHED();\n    return;\n  }\n  current_oldstyle_pepper_plugins_.erase(found_pepper);\n  for (std::deque< linked_ptr<PendingFileChooser> >::iterator i =\n           file_chooser_completions_.begin();\n       i != file_chooser_completions_.end(); ) {\n    if ((*i)->completion == pepper_plugin) {\n      if (i == file_chooser_completions_.begin())\n        (*i)->completion = NULL;\n      else\n        i = file_chooser_completions_.erase(i);\n    } else {\n      ++i;\n    }\n  }\n}", "target": 0}
{"code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tmsg->msg_namelen = 0;\n\t\t\treturn 0;\n\t\t}\n\t\treturn err;\n\t}\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0) {\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\t\tif (bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\telse\n\t\t\tmsg->msg_namelen = 0;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": " static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n \t\t\tunsigned int dataoff, unsigned int *timeouts)\n {\n\treturn true;\n }", "target": 1}
{"code": "void ewk_view_mixed_content_run_set(Evas_Object* ewkView, bool hasRun)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);\n    priv->flags.hasRunMixedContent = hasRun;\n    if (hasRun)\n        evas_object_smart_callback_call(ewkView, \"mixedcontent,run\", 0);\n}", "target": 0}
{"code": "void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) \n{\n  if(recurs > 1000) \n    throw MOADNSException(\"Loop\");\n  for(;;) {\n    unsigned char labellen=content.at(frompos++);\n    if(!labellen) {\n      if(ret.empty())\n              ret.append(1,'.');\n      break;\n    }\n    else if((labellen & 0xc0) == 0xc0) {\n      uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);\n      if(offset >= frompos-2)\n        throw MOADNSException(\"forward reference during label decompression\");\n      return getLabelFromContent(content, offset, ret, ++recurs);\n    }\n    else if(labellen > 63) \n      throw MOADNSException(\"Overly long label during label decompression (\"+lexical_cast<string>((unsigned int)labellen)+\")\");\n    else {\n      for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {\n        if(content.at(frompos)=='.' || content.at(frompos)=='\\\\') {\n          ret.append(1, '\\\\');\n          ret.append(1, content[frompos]);\n        }\n        else if(content.at(frompos)==' ') {\n          ret+=\"\\\\032\";\n        }\n        else \n          ret.append(1, content[frompos]);\n      }\n      ret.append(1,'.');\n    }\n  }\n}", "target": 1}
{"code": "stmt_read_row_from_cursor(MYSQL_STMT *stmt, unsigned char **row)\n{\n  if (stmt->data_cursor)\n    return stmt_read_row_buffered(stmt, row);\n  if (stmt->server_status & SERVER_STATUS_LAST_ROW_SENT)\n    stmt->server_status &= ~SERVER_STATUS_LAST_ROW_SENT;\n  else\n  {\n    MYSQL *mysql= stmt->mysql;\n    NET *net= &mysql->net;\n    MYSQL_DATA *result= &stmt->result;\n    uchar buff[4  +\n               4 ];\n    free_root(&result->alloc, MYF(MY_KEEP_PREALLOC));\n    result->data= NULL;\n    result->rows= 0;\n    int4store(buff, stmt->stmt_id);\n    int4store(buff + 4, stmt->prefetch_rows); \n    if ((*mysql->methods->advanced_command)(mysql, COM_STMT_FETCH,\n                                            buff, sizeof(buff), (uchar*) 0, 0,\n                                            1, stmt))\n    {\n      if (stmt->mysql)\n        set_stmt_errmsg(stmt, net);\n      return 1;\n    }\n    if ((*mysql->methods->read_rows_from_cursor)(stmt))\n      return 1;\n    stmt->server_status= mysql->server_status;\n    stmt->data_cursor= result->data;\n    return stmt_read_row_buffered(stmt, row);\n  }\n  *row= 0;\n  return MYSQL_NO_DATA;\n}", "target": 0}
{"code": "_asn1_extract_der_octet (asn1_node node, const unsigned char *der,\n\t\t\t int der_len, unsigned flags)\n{\n  int len2, len3;\n  int counter, counter_end;\n  int result;\n  len2 = asn1_get_length_der (der, der_len, &len3);\n  if (len2 < -1)\n    return ASN1_DER_ERROR;\n  counter = len3 + 1;\n  if (len2 == -1)\n    counter_end = der_len - 2;\n  else\n    counter_end = der_len;\n  while (counter < counter_end)\n    {\n      len2 = asn1_get_length_der (der + counter, der_len, &len3);\n      if (IS_ERR(len2, flags))\n\t{\n\t  warn();\n\t  return ASN1_DER_ERROR;\n\t}\n      if (len2 >= 0)\n\t{\n\t  DECR_LEN(der_len, len2+len3);\n\t  _asn1_append_value (node, der + counter + len3, len2);\n\t}\n      else\n\t{\t\t\t\n\t  DECR_LEN(der_len, len3);\n\t  result =\n\t    _asn1_extract_der_octet (node, der + counter + len3,\n\t\t\t\t     der_len, flags);\n\t  if (result != ASN1_SUCCESS)\n\t    return result;\n\t  len2 = 0;\n\t}\n      DECR_LEN(der_len, 1);\n      counter += len2 + len3 + 1;\n    }\n  return ASN1_SUCCESS;\ncleanup:\n  return result;\n}", "target": 1}
{"code": "otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)\n{\n    otError error = OT_ERROR_NO_BUFS;\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n    VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);\n    RemoveJoiner(aEui64, 0); \n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (joiner->mValid)\n        {\n            continue;\n        }\n        if (aEui64 != NULL)\n        {\n            joiner->mEui64 = *aEui64;\n            joiner->mAny   = false;\n        }\n        else\n        {\n            joiner->mAny = true;\n        }\n        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));\n        joiner->mValid          = true;\n        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);\n        UpdateJoinerExpirationTimer();\n        SendCommissionerSet();\n        otLogInfoMeshCoP(\"Added Joiner (%s, %s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\", aPskd);\n        ExitNow(error = OT_ERROR_NONE);\n    }\nexit:\n    return error;\n}", "target": 1}
{"code": "static void part_write_body(const struct message_part *part,\n\t\t\t    string_t *str, bool extended)\n{\n\tconst struct message_part_data *data = part->data;\n\tbool text;\n\ti_assert(part->data != NULL);\n\tif ((part->flags & MESSAGE_PART_FLAG_MESSAGE_RFC822) != 0) {\n\t\tstr_append(str, \"\\\"message\\\" \\\"rfc822\\\"\");\n\t\ttext = FALSE;\n\t} else {\n\t\tif (data->content_type == NULL) {\n\t\t\ttext = TRUE;\n\t\t\tstr_append(str, \"\\\"text\\\" \\\"plain\\\"\");\n\t\t} else {\n\t\t\ttext = (strcasecmp(data->content_type, \"text\") == 0);\n\t\t\timap_append_string(str, data->content_type);\n\t\t\tstr_append_c(str, ' ');\n\t\t\timap_append_string(str, data->content_subtype);\n\t\t}\n\t}\n\tstr_append_c(str, ' ');\n\tparams_write(data->content_type_params,\n\t\tdata->content_type_params_count, str, text);\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_id);\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_description);\n\tstr_append_c(str, ' ');\n\tif (data->content_transfer_encoding != NULL)\n\t\timap_append_string(str, data->content_transfer_encoding);\n\telse\n\t\tstr_append(str, \"\\\"7bit\\\"\");\n\tstr_printfa(str, \" %\"PRIuUOFF_T, part->body_size.virtual_size);\n\tif (text) {\n\t\tstr_printfa(str, \" %u\", part->body_size.lines);\n\t} else if ((part->flags & MESSAGE_PART_FLAG_MESSAGE_RFC822) != 0) {\n\t\tconst struct message_part_data *child_data;\n\t\ti_assert(part->children != NULL);\n\t\ti_assert(part->children->next == NULL);\n\t\tchild_data = part->children->data;\n\t\tstr_append(str, \" (\");\n\t\timap_envelope_write(child_data->envelope, str);\n\t\tstr_append(str, \") \");\n\t\tpart_write_bodystructure_siblings(part->children, str, extended);\n\t\tstr_printfa(str, \" %u\", part->body_size.lines);\n\t}\n\tif (!extended)\n\t\treturn;\n\tstr_append_c(str, ' ');\n\timap_append_nstring_nolf(str, data->content_md5);\n\tpart_write_bodystructure_common(data, str);\n}", "target": 1}
{"code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\tif (!update || !s)\n\t\treturn NULL;\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       \n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\tStream_Seek_UINT8(s);                      \n\tStream_Seek_UINT8(s);                      \n\tStream_Read_UINT8(s, bitmapData->codecID); \n\tStream_Read_UINT16(s, bitmapData->width);  \n\tStream_Read_UINT16(s, bitmapData->height); \n\tStream_Read_UINT32(s, new_len);            \n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\tif (!new_data)\n\t\tgoto fail;\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}", "target": 1}
{"code": "  void AddBatchOffsets(Tensor* indices, const Tensor& params) {\n    int64_t batch_size = 1;  \n    for (int idx = 0; idx < batch_dims_; ++idx) {\n      batch_size *= params.dim_size(idx);\n    }\n    auto indices_flat = indices->flat<Index>();\n    int64_t const index_inner_size = indices->NumElements() / batch_size;\n    int64_t const batch_offset = params.dim_size(batch_dims_);\n    for (int64_t batch_idx = 0, dest_idx = 0; batch_idx < batch_size;\n         ++batch_idx) {\n      for (int64_t idx = 0; idx < index_inner_size; ++idx) {\n        indices_flat(dest_idx++) += batch_offset * batch_idx;\n      }\n    }\n  }", "target": 1}
{"code": "FontData::FontData(FontData* data, int32_t offset) {\n  Init(data->array_);\n  Bound(data->bound_offset_ + offset,\n        (data->bound_length_ == GROWABLE_SIZE)\n        ? GROWABLE_SIZE : data->bound_length_ - offset);\n}", "target": 0}
{"code": "fbFetchPixel_a4r4g4b4 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32  pixel = READ((CARD16 *) bits + offset);\n    CARD32  a,r,g,b;\n    a = ((pixel & 0xf000) | ((pixel & 0xf000) >> 4)) << 16;\n    r = ((pixel & 0x0f00) | ((pixel & 0x0f00) >> 4)) << 12;\n    g = ((pixel & 0x00f0) | ((pixel & 0x00f0) >> 4)) << 8;\n    b = ((pixel & 0x000f) | ((pixel & 0x000f) << 4));\n    return (a | r | g | b);\n}", "target": 0}
{"code": "bool Virtual_tmp_table::sp_set_all_fields_from_item(THD *thd, Item *value)\n{\n  DBUG_ASSERT(value->is_fixed());\n  DBUG_ASSERT(value->cols() == s->fields);\n  for (uint i= 0; i < value->cols(); i++)\n  {\n    if (field[i]->sp_prepare_and_store_item(thd, value->addr(i)))\n      return true;\n  }\n  return false;\n}", "target": 0}
{"code": "storageConnectGetCapabilities(virConnectPtr conn)\n{\n    if (virConnectGetCapabilitiesEnsureACL(conn) < 0)\n        return NULL;\n    return virCapabilitiesFormatXML(driver->caps);\n}", "target": 0}
{"code": "static void alloc_stmt_fields(MYSQL_STMT *stmt)\n{\n  MYSQL_FIELD *fields, *field, *end;\n  MEM_ROOT *fields_mem_root= &stmt->extension->fields_mem_root;\n  MYSQL *mysql= stmt->mysql;\n  DBUG_ASSERT(stmt->field_count);\n  free_root(fields_mem_root, MYF(0));\n  if (!(stmt->fields= (MYSQL_FIELD *) alloc_root(fields_mem_root,\n\t\t\t\t\t\t sizeof(MYSQL_FIELD) *\n\t\t\t\t\t\t stmt->field_count)) ||\n      !(stmt->bind= (MYSQL_BIND *) alloc_root(fields_mem_root,\n\t\t\t\t\t      sizeof(MYSQL_BIND) *\n\t\t\t\t\t      stmt->field_count)))\n  {\n    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);\n    return;\n  }\n  for (fields= mysql->fields, end= fields+stmt->field_count,\n\t field= stmt->fields;\n       field && fields < end; fields++, field++)\n  {\n    *field= *fields; \n    field->catalog=   strmake_root(fields_mem_root,\n                                   fields->catalog,\n                                   fields->catalog_length);\n    field->db=        strmake_root(fields_mem_root,\n                                   fields->db,\n                                   fields->db_length);\n    field->table=     strmake_root(fields_mem_root,\n                                   fields->table,\n                                   fields->table_length);\n    field->org_table= strmake_root(fields_mem_root,\n                                   fields->org_table,\n                                   fields->org_table_length);\n    field->name=      strmake_root(fields_mem_root,\n                                   fields->name,\n                                   fields->name_length);\n    field->org_name=  strmake_root(fields_mem_root,\n                                   fields->org_name,\n                                   fields->org_name_length);\n    if (fields->def)\n    {\n      field->def= strmake_root(fields_mem_root,\n                               fields->def,\n                               fields->def_length);\n      field->def_length= fields->def_length;\n    }\n    else\n    {\n      field->def= NULL;\n      field->def_length= 0;\n    }\n    field->extension= 0; \n    field->max_length= 0; \n  }\n}", "target": 0}
{"code": "void ompl::geometric::VFRRT::setup()\n{\n    RRT::setup();\n    vfdim_ = si_->getStateSpace()->getValueLocations().size();\n}", "target": 0}
{"code": "static ssize_t usbip_sockfd_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct stub_device *sdev = dev_get_drvdata(dev);\n\tint sockfd = 0;\n\tstruct socket *socket;\n\tint rv;\n\tif (!sdev) {\n\t\tdev_err(dev, \"sdev is null\\n\");\n\t\treturn -ENODEV;\n\t}\n\trv = sscanf(buf, \"%d\", &sockfd);\n\tif (rv != 1)\n\t\treturn -EINVAL;\n\tif (sockfd != -1) {\n\t\tint err;\n\t\tdev_info(dev, \"stub up\\n\");\n\t\tspin_lock_irq(&sdev->ud.lock);\n\t\tif (sdev->ud.status != SDEV_ST_AVAILABLE) {\n\t\t\tdev_err(dev, \"not ready\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tsocket = sockfd_lookup(sockfd, &err);\n\t\tif (!socket) {\n\t\t\tdev_err(dev, \"failed to lookup sock\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (socket->type != SOCK_STREAM) {\n\t\t\tdev_err(dev, \"Expecting SOCK_STREAM - found %d\",\n\t\t\t\tsocket->type);\n\t\t\tgoto sock_err;\n\t\t}\n\t\tsdev->ud.tcp_socket = socket;\n\t\tsdev->ud.sockfd = sockfd;\n\t\tspin_unlock_irq(&sdev->ud.lock);\n\t\tsdev->ud.tcp_rx = kthread_get_run(stub_rx_loop, &sdev->ud,\n\t\t\t\t\t\t  \"stub_rx\");\n\t\tsdev->ud.tcp_tx = kthread_get_run(stub_tx_loop, &sdev->ud,\n\t\t\t\t\t\t  \"stub_tx\");\n\t\tspin_lock_irq(&sdev->ud.lock);\n\t\tsdev->ud.status = SDEV_ST_USED;\n\t\tspin_unlock_irq(&sdev->ud.lock);\n\t} else {\n\t\tdev_info(dev, \"stub down\\n\");\n\t\tspin_lock_irq(&sdev->ud.lock);\n\t\tif (sdev->ud.status != SDEV_ST_USED)\n\t\t\tgoto err;\n\t\tspin_unlock_irq(&sdev->ud.lock);\n\t\tusbip_event_add(&sdev->ud, SDEV_EVENT_DOWN);\n\t}\n\treturn count;\nsock_err:\n\tsockfd_put(socket);\nerr:\n\tspin_unlock_irq(&sdev->ud.lock);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* c) override {\n    PartialTensorShape element_shape;\n    OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(0), &element_shape));\n    int32 num_elements = c->input(1).scalar<int32>()();\n    TensorList output;\n    output.element_shape = element_shape;\n    output.element_dtype = element_dtype_;\n    output.tensors().resize(num_elements, Tensor(DT_INVALID));\n    Tensor* result;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr));\n    result->scalar<Variant>()() = std::move(output);\n  }", "target": 1}
{"code": "max3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum,\n\t\t    int force_toggles)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint old_epnum, same_ep, rcvtog, sndtog;\n\tstruct usb_device *old_dev;\n\tu8 hctl;\n\told_dev = max3421_hcd->loaded_dev;\n\told_epnum = max3421_hcd->loaded_epnum;\n\tsame_ep = (dev == old_dev && epnum == old_epnum);\n\tif (same_ep && !force_toggles)\n\t\treturn;\n\tif (old_dev && !same_ep) {\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\trcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tsndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tusb_settoggle(old_dev, old_epnum, 0, rcvtog);\n\t\tusb_settoggle(old_dev, old_epnum, 1, sndtog);\n\t}\n\trcvtog = usb_gettoggle(dev, epnum, 0);\n\tsndtog = usb_gettoggle(dev, epnum, 1);\n\thctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\n\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\tmax3421_hcd->loaded_epnum = epnum;\n\tspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\n\tmax3421_hcd->loaded_dev = dev;\n\tspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\n}", "target": 1}
{"code": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString += \"<var name='\";\n      m_packetString += varName.data();\n      m_packetString += \"'>\";\n    }\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n      } else {\n        m_packetString += \"<array length='\";\n        m_packetString += std::to_string(length);\n        m_packetString += \"'>\";\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString += \"</struct>\";\n      }\n      else {\n        m_packetString += \"</array>\";\n      }\n    }\n    else {\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n        m_packetString += \"</struct>\";\n      }\n    }\n    if (hasVarTag) {\n      m_packetString += \"</var>\";\n    }\n    return true;\n  }\n  std::string varType = getDataTypeString(varVariant.getType()).data();\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    std::string varValue = varVariant.toString().data();\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    }\n    m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);\n    return true;\n  }\n  return false;\n}", "target": 1}
{"code": "void RGWSetBucketWebsite_ObjStore_S3::send_response()\n{\n  if (op_ret < 0)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n}", "target": 0}
{"code": "void Hybrid_type_traits_decimal::set_zero(Hybrid_type *val) const\n{\n  my_decimal_set_zero(&val->dec_buf[0]);\n  val->used_dec_buf_no= 0;\n}", "target": 0}
{"code": "pci_emul_mem_handler(struct vmctx *ctx, int vcpu, int dir, uint64_t addr,\n\t\t     int size, uint64_t *val, void *arg1, long arg2)\n{\n\tstruct pci_vdev *pdi = arg1;\n\tstruct pci_vdev_ops *ops = pdi->dev_ops;\n\tuint64_t offset;\n\tint bidx = (int) arg2;\n\tassert(bidx <= PCI_BARMAX);\n\tassert(pdi->bar[bidx].type == PCIBAR_MEM32 ||\n\t       pdi->bar[bidx].type == PCIBAR_MEM64);\n\tassert(addr >= pdi->bar[bidx].addr &&\n\t       addr + size <= pdi->bar[bidx].addr + pdi->bar[bidx].size);\n\toffset = addr - pdi->bar[bidx].addr;\n\tif (dir == MEM_F_WRITE) {\n\t\tif (size == 8) {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   4, *val & 0xffffffff);\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset + 4,\n\t\t\t\t\t   4, *val >> 32);\n\t\t} else {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   size, bar_value(size, *val));\n\t\t}\n\t} else {\n\t\tif (size == 8) {\n\t\t\tuint64_t val_lo, val_hi;\n\t\t\tval_lo = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset, 4);\n\t\t\tval_lo = bar_value(4, val_lo);\n\t\t\tval_hi = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset + 4, 4);\n\t\t\t*val = val_lo | (val_hi << 32);\n\t\t} else {\n\t\t\t*val = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                            offset, size);\n\t\t\t*val = bar_value(size, *val);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static CuckooFilter *cfCreate(RedisModuleKey *key, size_t capacity, size_t bucketSize,\n                              size_t maxIterations, size_t expansion) {\n    if (capacity < bucketSize * 2)\n        return NULL;\n    CuckooFilter *cf = RedisModule_Calloc(1, sizeof(*cf));\n    if (CuckooFilter_Init(cf, capacity, bucketSize, maxIterations, expansion) != 0) {\n        RedisModule_Free(cf); \n        cf = NULL;            \n    }\n    RedisModule_ModuleTypeSetValue(key, CFType, cf);\n    return cf;\n}", "target": 1}
{"code": " static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n\t       sizeof(ualg->cru_driver_name));\n\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n\t       CRYPTO_MAX_ALG_NAME);\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static void rx_queue_get_ownership(struct kobject *kobj,\n\t\t\t\t   kuid_t *uid, kgid_t *gid)\n{\n\tconst struct net *net = rx_queue_namespace(kobj);\n\tnet_ns_get_ownership(net, uid, gid);", "target": 0}
{"code": "folly::Optional<TLSMessage> PlaintextReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    folly::io::Cursor cursor(buf.front());\n    if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {\n      return folly::none;\n    }\n    TLSMessage msg;\n    msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n    if (skipEncryptedRecords_) {\n      if (msg.type == ContentType::application_data) {\n        cursor.skip(sizeof(ProtocolVersion));\n        auto length = cursor.readBE<uint16_t>();\n        if (buf.chainLength() < (cursor - buf.front()) + length) {\n          return folly::none;\n        }\n        length +=\n            sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n        buf.trimStart(length);\n        continue;\n      } else if (msg.type != ContentType::change_cipher_spec) {\n        skipEncryptedRecords_ = false;\n      }\n    }\n    switch (msg.type) {\n      case ContentType::handshake:\n      case ContentType::alert:\n        break;\n      case ContentType::change_cipher_spec:\n        break;\n      default:\n        throw std::runtime_error(folly::to<std::string>(\n            \"received plaintext content type \",\n            static_cast<ContentTypeType>(msg.type),\n            \", header: \",\n            folly::hexlify(buf.splitAtMost(10)->coalesce())));\n    }\n    receivedRecordVersion_ =\n        static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());\n    auto length = cursor.readBE<uint16_t>();\n    if (length > kMaxPlaintextRecordSize) {\n      throw std::runtime_error(\"received too long plaintext record\");\n    }\n    if (length == 0) {\n      throw std::runtime_error(\"received empty plaintext record\");\n    }\n    if (buf.chainLength() < (cursor - buf.front()) + length) {\n      return folly::none;\n    }\n    cursor.clone(msg.fragment, length);\n    buf.trimStart(cursor - buf.front());\n    if (msg.type == ContentType::change_cipher_spec) {\n      msg.fragment->coalesce();\n      if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n    return std::move(msg);\n  }\n}", "target": 1}
{"code": " accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n        listener = data->listener;\n        server = data->server;\n         g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n        ice_conn = IceAcceptConnection (listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                 return TRUE;\n         }\n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        g_object_unref (client);\n         return TRUE;\n }", "target": 1}
{"code": "u32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\treturn 0;\n}", "target": 0}
{"code": "static int __init nonx32_setup(char *str)\n{\n\tif (!strcmp(str, \"on\"))\n\t\tforce_personality32 &= ~READ_IMPLIES_EXEC;\n\telse if (!strcmp(str, \"off\"))\n\t\tforce_personality32 |= READ_IMPLIES_EXEC;\n\treturn 1;\n}", "target": 0}
{"code": "  void Add(RenderWidgetHost* host) {\n    hosts_.push_back(RenderWidgetHostID(host->GetProcess()->GetID(),\n                                        host->GetRoutingID()));\n  }", "target": 0}
{"code": "static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n{\n    HLSContext *c = s->priv_data;\n    AVDictionary *tmp = NULL;\n    const char *proto_name = NULL;\n    int ret;\n    av_dict_copy(&tmp, opts, 0);\n    av_dict_copy(&tmp, opts2, 0);\n    if (av_strstart(url, \"crypto\", NULL)) {\n        if (url[6] == '+' || url[6] == ':')\n            proto_name = avio_find_protocol_name(url + 7);\n    }\n    if (!proto_name)\n        proto_name = avio_find_protocol_name(url);\n    if (!proto_name)\n        return AVERROR_INVALIDDATA;\n    if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))\n        return AVERROR_INVALIDDATA;\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n        ;\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n        ;\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n        return AVERROR_INVALIDDATA;\n    ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n    if (ret >= 0) {\n        char *new_cookies = NULL;\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n        if (new_cookies) {\n            av_free(c->cookies);\n            c->cookies = new_cookies;\n        }\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    }\n    av_dict_free(&tmp);\n    if (is_http)\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n    return ret;\n}", "target": 1}
{"code": "static const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)\n{\n    int offset = 0;\n    const uint8_t *ptr = NULL;\n    if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 || \n            asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))\n        goto end_get_sig;\n    if (asn1_sig[offset++] != ASN1_OCTET_STRING)\n        goto end_get_sig;\n    *len = get_asn1_length(asn1_sig, &offset);\n    ptr = &asn1_sig[offset];          \nend_get_sig:\n    return ptr;\n}", "target": 1}
{"code": "empty_param_read(iparam_list * plist, const ref * pkey, iparam_loc * ploc)\n{\n    return 1;\n}", "target": 0}
{"code": "int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n    return 0;\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n    return -1;\n}", "target": 1}
{"code": "bool PrintMsg_Print_Params_IsEqual(\n    const PrintMsg_PrintPages_Params& oldParams,\n    const PrintMsg_PrintPages_Params& newParams) {\n  return PageLayoutIsEqual(oldParams, newParams) &&\n         oldParams.params.max_shrink == newParams.params.max_shrink &&\n         oldParams.params.min_shrink == newParams.params.min_shrink &&\n         oldParams.params.selection_only == newParams.params.selection_only &&\n         oldParams.params.supports_alpha_blend ==\n             newParams.params.supports_alpha_blend &&\n         oldParams.pages.size() == newParams.pages.size() &&\n         oldParams.params.display_header_footer ==\n             newParams.params.display_header_footer &&\n         oldParams.params.date == newParams.params.date &&\n         oldParams.params.title == newParams.params.title &&\n         oldParams.params.url == newParams.params.url &&\n         std::equal(oldParams.pages.begin(), oldParams.pages.end(),\n             newParams.pages.begin());\n}", "target": 0}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\terror = git_stream_connect(t->io);\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_call_handlers(ndp, msg);;\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}", "target": 1}
{"code": "comics_document_class_init (ComicsDocumentClass *klass)\n{\n\tGObjectClass    *gobject_class = G_OBJECT_CLASS (klass);\n\tEvDocumentClass *ev_document_class = EV_DOCUMENT_CLASS (klass);\n\tgobject_class->finalize = comics_document_finalize;\n\tev_document_class->load = comics_document_load;\n\tev_document_class->save = comics_document_save;\n\tev_document_class->get_n_pages = comics_document_get_n_pages;\n\tev_document_class->get_page_size = comics_document_get_page_size;\n\tev_document_class->render = comics_document_render;\n}", "target": 0}
{"code": "\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}", "target": 1}
{"code": "int HttpFileImpl::save(const std::string &path) const\n{\n    assert(!path.empty());\n    if (fileName_.empty())\n        return -1;\n    filesystem::path fsPath(utils::toNativePath(path));\n    if (!fsPath.is_absolute() &&\n        (!fsPath.has_parent_path() ||\n         (fsPath.begin()->string() != \".\" && fsPath.begin()->string() != \"..\")))\n    {\n        filesystem::path fsUploadPath(utils::toNativePath(\n            HttpAppFrameworkImpl::instance().getUploadPath()));\n        fsPath = fsUploadPath / fsPath;\n    }\n    filesystem::path fsFileName(utils::toNativePath(fileName_));\n    if (!filesystem::exists(fsPath))\n    {\n        LOG_TRACE << \"create path:\" << fsPath;\n        drogon::error_code err;\n        filesystem::create_directories(fsPath, err);\n        if (err)\n        {\n            LOG_SYSERR;\n            return -1;\n        }\n    }\n    return saveTo(fsPath / fsFileName);\n}", "target": 1}
{"code": "static void kvm_io_bus_destroy(struct kvm_io_bus *bus)\n{\n\tint i;\n\tfor (i = 0; i < bus->dev_count; i++) {\n\t\tstruct kvm_io_device *pos = bus->devs[i];\n\t\tkvm_iodevice_destructor(pos);\n\t}\n\tkfree(bus);\n}", "target": 0}
{"code": "ZEND_API void ZEND_FASTCALL convert_scalar_to_number(zval *op) \n{\n\t_convert_scalar_to_number(op, 1, 0);\n}", "target": 0}
{"code": "ProcPutImage(ClientPtr client)\n{\n    GC *pGC;\n    DrawablePtr pDraw;\n    long length;                \n    long lengthProto;           \n    char *tmpImage;\n    REQUEST(xPutImageReq);\n    REQUEST_AT_LEAST_SIZE(xPutImageReq);\n    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);\n    if (stuff->format == XYBitmap) {\n        if ((stuff->depth != 1) ||\n            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))\n            return BadMatch;\n        length = BitmapBytePad(stuff->width + stuff->leftPad);\n    }\n    else if (stuff->format == XYPixmap) {\n        if ((pDraw->depth != stuff->depth) ||\n            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))\n            return BadMatch;\n        length = BitmapBytePad(stuff->width + stuff->leftPad);\n        length *= stuff->depth;\n    }\n    else if (stuff->format == ZPixmap) {\n        if ((pDraw->depth != stuff->depth) || (stuff->leftPad != 0))\n            return BadMatch;\n        length = PixmapBytePad(stuff->width, stuff->depth);\n    }\n    else {\n        client->errorValue = stuff->format;\n        return BadValue;\n    }\n     tmpImage = (char *) &stuff[1];\n     lengthProto = length;\n    if (lengthProto >= (INT32_MAX / stuff->height))\n         return BadLength;\n     if ((bytes_to_int32(lengthProto * stuff->height) +\n         bytes_to_int32(sizeof(xPutImageReq))) != client->req_len)\n        return BadLength;\n    ReformatImage(tmpImage, lengthProto * stuff->height,\n                  stuff->format == ZPixmap ? BitsPerPixel(stuff->depth) : 1,\n                  ClientOrder(client));\n    (*pGC->ops->PutImage) (pDraw, pGC, stuff->depth, stuff->dstX, stuff->dstY,\n                           stuff->width, stuff->height,\n                           stuff->leftPad, stuff->format, tmpImage);\n    return Success;\n}", "target": 1}
{"code": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tpipe_buf_get(ipipe, ibuf);\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\treturn ret;\n}", "target": 1}
{"code": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n \trefcount_set(&net->count, 1);\n \trefcount_set(&net->passive, 1);\n \tnet->dev_base_seq = 1;\n \tnet->user_ns = user_ns;\n \tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\nout_undo:\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\trcu_barrier();\n\tgoto out;\n}", "target": 1}
{"code": "int tm_adopt(\n  char  *id,\n  int    adoptCmd,\n  pid_t  pid)\n  {\n  int rc = TM_SUCCESS;\n  int status, ret;\n  pid_t sid;\n  char *env;\n  struct tcp_chan *chan = NULL;\n  sid = getsid(pid);\n  if (init_done) return TM_BADINIT;\n  init_done = 1;\n  if ((tm_jobid = getenv(\"PBS_JOBID\")) == NULL)\n    tm_jobid = (char *)\"ADOPT JOB\";\n  tm_jobid_len = strlen(tm_jobid);\n  if ((tm_jobcookie = getenv(\"PBS_JOBCOOKIE\")) == NULL)\n    tm_jobcookie = (char *)\"ADOPT COOKIE\";\n  tm_jobcookie_len = strlen(tm_jobcookie);\n  tm_jobndid = 0;\n  tm_jobtid = 0;\n  if ((env = getenv(\"PBS_MOMPORT\")) == NULL || (tm_momport = atoi(env)) == 0)\n    tm_momport = PBS_MANAGER_SERVICE_PORT;\n  if (adoptCmd != TM_ADOPT_ALTID && adoptCmd != TM_ADOPT_JOBID)\n    return TM_EUNKNOWNCMD;\n  if (startcom(adoptCmd, TM_NULL_EVENT, &chan) != DIS_SUCCESS)\n    return TM_ESYSTEM;\n  if (diswsi(chan, sid) != DIS_SUCCESS)\n    {\n    rc = TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  if (diswsi(chan, pid) != DIS_SUCCESS)\n    {\n    rc =  TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  if (diswcs(chan, id, strlen(id)) != DIS_SUCCESS)\n    {\n    rc =  TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  DIS_tcp_wflush(chan);\n  status = disrsi(chan, &ret);\n  if (ret != DIS_SUCCESS)\n    {\n    rc = TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  tm_finalize();\n  if (local_conn > -1)\n    {\n    close(local_conn);\n    local_conn = -1;\n    }\n  DIS_tcp_cleanup(chan);\n  return (status == TM_OKAY ?\n          TM_SUCCESS :\n          TM_ENOTFOUND);\ntm_adopt_cleanup:\n  if (chan != NULL)\n    DIS_tcp_cleanup(chan);\n  return rc;\n  }", "target": 1}
{"code": "spa_base64_to_bits (char *out, int outlength, const char *in)\n{\n  int len = 0;\n  register uschar digit1, digit2, digit3, digit4;\n  if (in[0] == '+' && in[1] == ' ')\n    in += 2;\n  if (*in == '\\r')\n    return (0);\n  do\n    {\n      if (len >= outlength)                   \n        return (-1);                          \n      digit1 = in[0];\n      if (DECODE64 (digit1) == BAD)\n       return (-1);\n      digit2 = in[1];\n      if (DECODE64 (digit2) == BAD)\n       return (-1);\n      digit3 = in[2];\n      if (digit3 != '=' && DECODE64 (digit3) == BAD)\n       return (-1);\n      digit4 = in[3];\n      if (digit4 != '=' && DECODE64 (digit4) == BAD)\n       return (-1);\n      in += 4;\n      *out++ = (DECODE64 (digit1) << 2) | (DECODE64 (digit2) >> 4);\n      ++len;\n      if (digit3 != '=')\n       {\n         if (len >= outlength)                   \n           return (-1);                          \n         *out++ =\n           ((DECODE64 (digit2) << 4) & 0xf0) | (DECODE64 (digit3) >> 2);\n         ++len;\n         if (digit4 != '=')\n           {\n             if (len >= outlength)                   \n               return (-1);                          \n             *out++ = ((DECODE64 (digit3) << 6) & 0xc0) | DECODE64 (digit4);\n             ++len;\n           }\n       }\n    }\n  while (*in && *in != '\\r' && digit4 != '=');\n  return (len);\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_result_error)\n{\n\tzval *result;\n\tPGresult *pgsql_result;\n\tpgsql_result_handle *pg_result;\n\tchar *err = NULL;\n\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS(), \"r\",\n\t\t\t\t\t\t\t\t &result) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, result, -1, \"PostgreSQL result\", le_result);\n\tpgsql_result = pg_result->result;\n\tif (!pgsql_result) {\n\t\tRETURN_FALSE;\n\t}\n\terr = (char *)PQresultErrorMessage(pgsql_result);\n\tRETURN_STRING(err);\n}", "target": 0}
{"code": "static int adpt_queue_lck(struct scsi_cmnd *cmd)\n{\n\tadpt_hba* pHba = NULL;\n\tstruct adpt_device* pDev = NULL;\t\n\tif ((cmd->cmnd[0] == REQUEST_SENSE) && (cmd->sense_buffer[0] != 0)) {\n\t\tcmd->result = (DID_OK << 16);\n\t\tscsi_done(cmd);\n\t\treturn 0;\n\t}\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tif (!pHba) {\n\t\treturn FAILED;\n\t}\n\trmb();\n\tif ((pHba->state) & DPTI_STATE_RESET)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\tif((pDev = (struct adpt_device*) (cmd->device->hostdata)) == NULL) {\n\t\tif ((pDev = adpt_find_device(pHba, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun)) == NULL) {\n\t\t\tcmd->result = (DID_NO_CONNECT << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tcmd->device->hostdata = pDev;\n\t}\n\tpDev->pScsi_dev = cmd->device;\n\tif (pDev->state & DPTI_DEV_RESET ) {\n\t\treturn FAILED;\n\t}\n\treturn adpt_scsi_to_i2o(pHba, cmd, pDev);\n}", "target": 1}
{"code": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n \tkgid_t group = new->egid;\n \tint ret;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\tatomic_set(&ns->count, 1);\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\tset_cred_user_ns(new, ns);\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}", "target": 1}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; \n    struct dp_packet *pkt;\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "target": 1}
{"code": "static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)\n{\n    void **p = ptr;\n    if (min_size < *size)\n        return 0;\n    min_size = FFMAX(17 * min_size / 16 + 32, min_size);\n    av_free(*p);\n    *p = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);\n    if (!*p)\n        min_size = 0;\n    *size = min_size;\n    return 1;\n}", "target": 0}
{"code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}", "target": 1}
{"code": "compare_vote_rs_(const void **_a, const void **_b)\n{\n  const vote_routerstatus_t *a = *_a, *b = *_b;\n  return compare_vote_rs(a,b);\n}", "target": 0}
{"code": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\nerr:\n\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "static int http_read_header(URLContext *h, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    char line[MAX_URL_SIZE];\n    int err = 0;\n    s->chunksize = -1;\n    for (;;) {\n        if ((err = http_get_line(s, line, sizeof(line))) < 0)\n            return err;\n        av_log(h, AV_LOG_TRACE, \"header='%s'\\n\", line);\n        err = process_line(h, line, s->line_count, new_location);\n        if (err < 0)\n            return err;\n        if (err == 0)\n            break;\n        s->line_count++;\n    }\n    if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)\n        h->is_streamed = 1; \n    cookie_string(s->cookie_dict, &s->cookies);\n    av_dict_free(&s->cookie_dict);\n    return err;\n}", "target": 1}
{"code": "userauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n \tsize_t len;\n \tu_char *doid = NULL;\n\tif (!authctxt->valid || authctxt->user == NULL)\n\t\treturn (0);\n \tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n \t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\tdo {\n\t\tmechs--;\n\t\tfree(doid);\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n \t\treturn (0);\n \t}\n \tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n \t\tif (ctxt != NULL)\n \t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\tauthctxt->methoddata = (void *)ctxt;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfree(doid);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\treturn (0);\n}", "target": 1}
{"code": "static BOOL drive_file_remove_dir(const WCHAR* path)\n{\n\tWIN32_FIND_DATAW findFileData;\n\tBOOL ret = TRUE;\n\tHANDLE dir;\n\tWCHAR* fullpath;\n\tWCHAR* path_slash;\n\tsize_t base_path_length;\n\tif (!path)\n\t\treturn FALSE;\n\tbase_path_length = _wcslen(path) * 2;\n\tpath_slash = (WCHAR*)calloc(1, base_path_length + sizeof(WCHAR) * 3);\n\tif (!path_slash)\n\t{\n\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\treturn FALSE;\n\t}\n\tCopyMemory(path_slash, path, base_path_length);\n\tpath_slash[base_path_length / 2] = L'/';\n\tpath_slash[base_path_length / 2 + 1] = L'*';\n\tDEBUG_WSTR(\"Search in %s\", path_slash);\n\tdir = FindFirstFileW(path_slash, &findFileData);\n\tpath_slash[base_path_length / 2 + 1] = 0;\n\tif (dir == INVALID_HANDLE_VALUE)\n\t{\n\t\tfree(path_slash);\n\t\treturn FALSE;\n\t}\n\tdo\n\t{\n\t\tsize_t len = _wcslen(findFileData.cFileName);\n\t\tif ((len == 1 && findFileData.cFileName[0] == L'.') ||\n\t\t    (len == 2 && findFileData.cFileName[0] == L'.' && findFileData.cFileName[1] == L'.'))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfullpath = drive_file_combine_fullpath(path_slash, findFileData.cFileName, len * 2);\n\t\tDEBUG_WSTR(\"Delete %s\", fullpath);\n\t\tif (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n\t\t{\n\t\t\tret = drive_file_remove_dir(fullpath);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = DeleteFileW(fullpath);\n\t\t}\n\t\tfree(fullpath);\n\t\tif (!ret)\n\t\t\tbreak;\n\t} while (ret && FindNextFileW(dir, &findFileData) != 0);\n\tFindClose(dir);\n\tif (ret)\n\t{\n\t\tif (!RemoveDirectoryW(path))\n\t\t{\n\t\t\tret = FALSE;\n\t\t}\n\t}\n\tfree(path_slash);\n\treturn ret;\n}", "target": 1}
{"code": "static int msr_open(struct inode *inode, struct file *file)\n{\n \tunsigned int cpu;\n \tstruct cpuinfo_x86 *c;\n \tcpu = iminor(file->f_path.dentry->d_inode);\n \tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n \t\treturn -ENXIO;\t\n\tc = &cpu_data(cpu);\n\tif (!cpu_has(c, X86_FEATURE_MSR))\n\t\treturn -EIO;\t\n\treturn 0;\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tunregister_netdev(sp->dev);\n}", "target": 1}
{"code": "static int bson_validate_string( bson *b, const unsigned char *string,\n                                 const int length, const char check_utf8, const char check_dot,\n                                 const char check_dollar ) {\n    int position = 0;\n    int sequence_length = 1;\n    if( check_dollar && string[0] == '$' ) {\n        if( !bson_string_is_db_ref( string, length ) )\n            b->err |= BSON_FIELD_INIT_DOLLAR;\n    }\n    while ( position < length ) {\n        if ( check_dot && *( string + position ) == '.' ) {\n            b->err |= BSON_FIELD_HAS_DOT;\n        }\n        if ( check_utf8 ) {\n            sequence_length = trailingBytesForUTF8[*( string + position )] + 1;\n            if ( ( position + sequence_length ) > length ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n            if ( !isLegalUTF8( string + position, sequence_length ) ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n        }\n        position += sequence_length;\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "void CarbonProtocolReader::skip(const FieldType ft) {\n  switch (ft) {\n    case FieldType::True:\n    case FieldType::False: {\n      break;\n    }\n    case FieldType::Int8: {\n      readRaw<int8_t>();\n      break;\n    }\n    case FieldType::Int16: {\n      readRaw<int16_t>();\n      break;\n    }\n    case FieldType::Int32: {\n      readRaw<int32_t>();\n      break;\n    }\n    case FieldType::Int64: {\n      readRaw<int64_t>();\n      break;\n    }\n    case FieldType::Double: {\n      readRaw<double>();\n      break;\n    }\n    case FieldType::Float: {\n      readRaw<float>();\n      break;\n    }\n    case FieldType::Binary: {\n      readRaw<std::string>();\n      break;\n    }\n    case FieldType::List: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Struct: {\n      readStructBegin();\n      while (true) {\n        const auto fieldType = readFieldHeader().first;\n        if (fieldType == FieldType::Stop) {\n          break;\n        }\n        skip(fieldType);\n      }\n      readStructEnd();\n      break;\n    }\n    case FieldType::Set: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Map: {\n      skipKVContainer();\n      break;\n    }\n    default: { break; }\n  }\n}", "target": 1}
{"code": "TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* hash;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &hash));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input));\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &weight));\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;\n    case kTfLiteLshProjectionDense:\n      outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);\n      break;\n    default:\n      return kTfLiteError;\n  }\n  return context->ResizeTensor(context, output, outputSize);\n}", "target": 1}
{"code": "static void n_tty_close(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\tvfree(ldata);\n\ttty->disc_data = NULL;\n}", "target": 0}
{"code": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n \tstruct iov_iter i;\n \tint ret;\n \tif (map_data)\n \t\tcopy = true;\n \telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\n unmap_rq:\n \t__blk_rq_unmap_user(bio);\n \trq->bio = NULL;\n \treturn -EINVAL;\n }", "target": 1}
{"code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\tif (!update || !s)\n\t\treturn NULL;\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       \n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\tStream_Seek_UINT8(s);                      \n\tStream_Seek_UINT8(s);                      \n\tStream_Read_UINT8(s, bitmapData->codecID); \n\tStream_Read_UINT16(s, bitmapData->width);  \n\tStream_Read_UINT16(s, bitmapData->height); \n\tStream_Read_UINT32(s, new_len);            \n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\tif (!new_data)\n\t\tgoto fail;\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}", "target": 1}
{"code": "int htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -ETIMEDOUT;\n\t}\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 1}
{"code": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  \n                goto exit;\n            case 1:  \n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n    ret = PyObject_Hash(tmp);\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == 1) {\n        ret = -1;\n        goto exit;\n    }\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}", "target": 1}
{"code": "void QuotaManager::GetGlobalUsage(\n    StorageType type,\n    GlobalUsageCallback* callback) {\n  LazyInitialize();\n  GetUsageTracker(type)->GetGlobalUsage(callback);\n}", "target": 0}
{"code": "static UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, Stream_Pointer(irp->input), Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "DEFINE_TRACE(ContainerNode)\n{\n    visitor->trace(m_firstChild);\n    visitor->trace(m_lastChild);\n    Node::trace(visitor);\n}", "target": 0}
{"code": "bitset_invert_to(BitSetRef from, BitSetRef to)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { to[i] = ~(from[i]); }\n}", "target": 0}
{"code": "static void patch_fn(struct cgit_context *ctx)\n{\n\tcgit_print_patch(ctx->qry.sha1);\n}", "target": 0}
{"code": "static void f_parser (lua_State *L, void *ud) {\n  int i;\n  Proto *tf;\n  Closure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = luaZ_lookahead(p->z);\n  luaC_checkGC(L);\n  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,\n                                                             &p->buff, p->name);\n  cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));\n  cl->l.p = tf;\n  for (i = 0; i < tf->nups; i++)  \n    cl->l.upvals[i] = luaF_newupval(L);\n  setclvalue(L, L->top, cl);\n  incr_top(L);\n}", "target": 1}
{"code": "SPL_METHOD(SplMinHeap, compare)\n{\n\tzval *a, *b;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zz\", &a, &b) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(spl_ptr_heap_zval_min_cmp(a, b, NULL TSRMLS_CC));\n} ", "target": 0}
{"code": "static int cac_is_cert(cac_private_data_t * priv, const sc_path_t *in_path)\n{\n\tcac_object_t test_obj;\n\ttest_obj.path = *in_path;\n\ttest_obj.path.index = 0;\n\ttest_obj.path.count = 0;\n\treturn (list_contains(&priv->pki_list, &test_obj) != 0);\n}", "target": 0}
{"code": "static int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = -ENOIOCTLCMD;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\tcase SIOCSARP:\t\t\n\tcase SIOCDARP:\t\t\n\t\trtnl_lock();\n\t\trc = atif_ioctl(cmd, argp);\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}", "target": 1}
{"code": "  int size() const override { return value_ == nullptr ? 0 : value_->size(); }", "target": 0}
{"code": "    void Modify::delMetadatum(Exiv2::Image* pImage, const ModifyCmd& modifyCmd)\n    {\n        if (Params::instance().verbose_) {\n            std::cout << _(\"Del\") << \" \" << modifyCmd.key_ << std::endl;\n        }\n        Exiv2::ExifData& exifData = pImage->exifData();\n        Exiv2::IptcData& iptcData = pImage->iptcData();\n        Exiv2::XmpData& xmpData = pImage->xmpData();\n        if (modifyCmd.metadataId_ == exif) {\n            Exiv2::ExifData::iterator pos;\n            Exiv2::ExifKey exifKey = Exiv2::ExifKey(modifyCmd.key_);\n            while ((pos = exifData.findKey(exifKey)) != exifData.end()) {\n                exifData.erase(pos);\n            }\n        }\n        if (modifyCmd.metadataId_ == iptc) {\n            Exiv2::IptcData::iterator pos;\n            Exiv2::IptcKey iptcKey = Exiv2::IptcKey(modifyCmd.key_);\n            while ((pos = iptcData.findKey(iptcKey)) != iptcData.end()) {\n                iptcData.erase(pos);\n            }\n        }\n        if (modifyCmd.metadataId_ == xmp) {\n            Exiv2::XmpData::iterator pos;\n            Exiv2::XmpKey xmpKey = Exiv2::XmpKey(modifyCmd.key_);\n            if ((pos = xmpData.findKey(xmpKey)) != xmpData.end()) {\n                xmpData.eraseFamily(pos);\n            }\n        }\n    }", "target": 0}
{"code": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\tif (!(dev->flags & IFF_UP))\n\t\treturn NET_RX_DROP;\n\tif (skb->len > (dev->mtu + dev->hard_header_len))\n\t\treturn NET_RX_DROP;\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}", "target": 1}
{"code": "accountingReportStats(XML_Parser originParser, const char *epilog) {\n  const XML_Parser rootParser = getRootParserOf(originParser, NULL);\n  assert(! rootParser->m_parentParser);\n  if (rootParser->m_accounting.debugLevel < 1) {\n    return;\n  }\n  const float amplificationFactor\n      = accountingGetCurrentAmplification(rootParser);\n  fprintf(stderr,\n          \"expat: Accounting(%p): Direct \" EXPAT_FMT_ULL(\n              \"10\") \", indirect \" EXPAT_FMT_ULL(\"10\") \", amplification %8.2f%s\",\n          (void *)rootParser, rootParser->m_accounting.countBytesDirect,\n          rootParser->m_accounting.countBytesIndirect,\n          (double)amplificationFactor, epilog);\n}", "target": 0}
{"code": "void __netdev_watchdog_up(struct net_device *dev)\n{\n\tif (dev->tx_timeout) {\n\t\tif (dev->watchdog_timeo <= 0)\n\t\t\tdev->watchdog_timeo = 5*HZ;\n\t\tif (!mod_timer(&dev->watchdog_timer,\n\t\t\t       round_jiffies(jiffies + dev->watchdog_timeo)))\n\t\t\tdev_hold(dev);\n\t}\n}", "target": 0}
{"code": "void rfc_send_rls(tRFC_MCB* p_mcb, uint8_t dlci, bool is_command,\n uint8_t status) {\n uint8_t* p_data;\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(RFCOMM_CMD_BUF_SIZE);\n  p_buf->offset = L2CAP_MIN_OFFSET + RFCOMM_CTRL_FRAME_LEN;\n  p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n *p_data++ = RFCOMM_EA | RFCOMM_I_CR(is_command) | RFCOMM_MX_RLS;\n *p_data++ = RFCOMM_EA | (RFCOMM_MX_RLS_LEN << 1);\n *p_data++ = RFCOMM_EA | RFCOMM_CR_MASK | (dlci << RFCOMM_SHIFT_DLCI);\n *p_data++ = RFCOMM_RLS_ERROR | status;\n  p_buf->len = RFCOMM_MX_RLS_LEN + 2;\n  rfc_send_buf_uih(p_mcb, RFCOMM_MX_DLCI, p_buf);\n}", "target": 0}
{"code": "static bool intel_iommu_capable(enum iommu_cap cap)\n{\n\tif (cap == IOMMU_CAP_CACHE_COHERENCY)\n\t\treturn domain_update_iommu_snooping(NULL) == 1;\n\tif (cap == IOMMU_CAP_INTR_REMAP)\n\t\treturn irq_remapping_enabled == 1;\n\treturn false;\n}", "target": 0}
{"code": "gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t\tgdImagePaletteCopy(dst, src);\n\t}\n\tdst->transparent = src->transparent;\n\tif (src->sx < (crop->x + crop->width -1)) {\n\t\tcrop->width = src->sx - crop->x + 1;\n\t}\n\tif (src->sy < (crop->y + crop->height -1)) {\n\t\tcrop->height = src->sy - crop->y + 1;\n\t}\n#if 0\nprintf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n#endif\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tint y = crop->y;\n\t\tif (src->trueColor) {\n\t\t\tunsigned int dst_y = 0;\n\t\t\twhile (y < (crop->y + (crop->height - 1))) {\n\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tint x;\n\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dst;\n\t}\n}", "target": 1}
{"code": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tPK11_FreeSlot(hash_slot);\n\treturn 0;\n}", "target": 1}
{"code": "luks_lock_wait_for_cleartext_device_removed_cb (Daemon *daemon,\n                                                const char *object_path,\n                                                gpointer user_data)\n{\n  Device *device;\n  LockEncryptionData *data = user_data;\n  device = daemon_local_find_by_object_path (daemon, object_path);\n  if (device == data->cleartext_device)\n    {\n      job_local_end (data->luks_device);\n      update_info (data->luks_device);\n      drain_pending_changes (data->luks_device, FALSE);\n      dbus_g_method_return (data->context);\n      g_signal_handler_disconnect (daemon, data->device_removed_signal_handler_id);\n      g_source_remove (data->device_removed_timeout_id);\n      lock_encryption_data_unref (data);\n    }\n}", "target": 0}
{"code": "static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n \t\treturn -EMSGSIZE;\n \talgo = nla_data(nla);\n\tstrcpy(algo->alg_name, auth->alg_name);\n \tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n \talgo->alg_key_len = auth->alg_key_len;\n\treturn 0;\n}", "target": 1}
{"code": "static int exif_read_from_impl(image_info_type *ImageInfo, php_stream *stream, int read_thumbnail, int read_all)\n{\n\tint ret;\n\tzend_stat_t st;\n\tmemset(ImageInfo, 0, sizeof(*ImageInfo));\n\tImageInfo->motorola_intel\t= -1; \n\tImageInfo->infile\t\t\t= stream;\n\tImageInfo->FileName\t\t\t= NULL;\n\tif (php_stream_is(ImageInfo->infile, PHP_STREAM_IS_STDIO)) {\n\t\tif (VCWD_STAT(stream->orig_path, &st) >= 0) {\n\t\t\tzend_string *base;\n\t\t\tif ((st.st_mode & S_IFMT) != S_IFREG) {\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Not a file\");\n\t\t\t\tphp_stream_close(ImageInfo->infile);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tbase = php_basename(stream->orig_path, strlen(stream->orig_path), NULL, 0);\n\t\t\tImageInfo->FileName = estrndup(ZSTR_VAL(base), ZSTR_LEN(base));\n\t\t\tzend_string_release(base);\n\t\t\tImageInfo->FileDateTime = st.st_mtime;\n\t\t\tImageInfo->FileSize = st.st_size;\n\t\t}\n\t} else {\n\t\tif (!ImageInfo->FileSize) {\n\t\t\tphp_stream_seek(ImageInfo->infile, 0, SEEK_END);\n\t\t\tImageInfo->FileSize = php_stream_tell(ImageInfo->infile);\n\t\t\tphp_stream_seek(ImageInfo->infile, 0, SEEK_SET);\n\t\t}\n\t}\n\tImageInfo->read_thumbnail\t\t= read_thumbnail;\n\tImageInfo->read_all\t\t\t\t= read_all;\n\tImageInfo->Thumbnail.filetype\t= IMAGE_FILETYPE_UNKNOWN;\n\tImageInfo->encode_unicode\t\t= estrdup(EXIF_G(encode_unicode));\n\tImageInfo->decode_unicode_be\t= estrdup(EXIF_G(decode_unicode_be));\n\tImageInfo->decode_unicode_le\t= estrdup(EXIF_G(decode_unicode_le));\n\tImageInfo->encode_jis\t\t\t= estrdup(EXIF_G(encode_jis));\n\tImageInfo->decode_jis_be\t \t= estrdup(EXIF_G(decode_jis_be));\n\tImageInfo->decode_jis_le\t\t= estrdup(EXIF_G(decode_jis_le));\n\tImageInfo->ifd_nesting_level = 0;\n\tret = exif_scan_FILE_header(ImageInfo);\n\treturn ret;\n}", "target": 1}
{"code": "archive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\tzip = (struct zip *)(a->format->data);\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n\t\tinflateEnd(&zip->stream);\n#endif\n#if HAVA_LZMA_H && HAVE_LIBLZMA\n    if (zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t}\n#endif\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\tfree(zip->uncompressed_buffer);\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}", "target": 1}
{"code": "LogData::LogData()\n    : routing_id(0),\n      type(0),\n      sent(0),\n      receive(0),\n      dispatch(0) {\n}", "target": 0}
{"code": "void InstanceKlass::release_C_heap_structures_internal() {\n  Klass::release_C_heap_structures();\n  if (_oop_map_cache != NULL) {\n    delete _oop_map_cache;\n    _oop_map_cache = NULL;\n  }\n  JNIid::deallocate(jni_ids());\n  set_jni_ids(NULL);\n  jmethodID* jmeths = methods_jmethod_ids_acquire();\n  if (jmeths != (jmethodID*)NULL) {\n    release_set_methods_jmethod_ids(NULL);\n    FreeHeap(jmeths);\n  }\n  assert(_dep_context == NULL,\n         \"dependencies should already be cleaned\");\n#if INCLUDE_JVMTI\n  if (breakpoints() != 0x0) {\n    methods_do(clear_all_breakpoints);\n    assert(breakpoints() == 0x0, \"should have cleared breakpoints\");\n  }\n  if (_cached_class_file != NULL) {\n    os::free(_cached_class_file);\n    _cached_class_file = NULL;\n  }\n#endif\n  FREE_C_HEAP_ARRAY(char, _source_debug_extension);\n}", "target": 0}
{"code": "static void cma_leave_mc_groups(struct rdma_id_private *id_priv)\n{\n\tstruct cma_multicast *mc;\n\twhile (!list_empty(&id_priv->mc_list)) {\n\t\tmc = list_first_entry(&id_priv->mc_list, struct cma_multicast,\n\t\t\t\t      list);\n\t\tlist_del(&mc->list);\n\t\tdestroy_mc(id_priv, mc);\n\t}\n}", "target": 0}
{"code": "void *TrustedPrimitives::UntrustedLocalMemcpy(void *dest, const void *src,\n                                              size_t size) noexcept {\n  return memcpy(dest, src, size);\n}", "target": 0}
{"code": "  bool CanUploadFile(const FilePath& file) {\n    return uploadable_files_.find(file) != uploadable_files_.end();\n  }", "target": 0}
{"code": "static void decode_data(struct sixpack *sp, unsigned char inbyte)\n{\n\tunsigned char *buf;\n\tif (sp->rx_count != 3) {\n\t\tsp->raw_buf[sp->rx_count++] = inbyte;\n\t\treturn;\n\t}\n\tbuf = sp->raw_buf;\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\tbuf[0] | ((buf[1] << 2) & 0xc0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[1] & 0x0f) | ((buf[2] << 2) & 0xf0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[2] & 0x03) | (inbyte << 2);\n\tsp->rx_count = 0;\n}", "target": 1}
{"code": "bool AccessibilityUIElement::addNotificationListener(JSValueRef functionCallback)\n{\n    return true;\n}", "target": 0}
{"code": "static int em_wrmsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 msr_data;\n\tmsr_data = (u32)ctxt->regs[VCPU_REGS_RAX]\n\t\t| ((u64)ctxt->regs[VCPU_REGS_RDX] << 32);\n\tif (ctxt->ops->set_msr(ctxt, ctxt->regs[VCPU_REGS_RCX], msr_data))\n\t\treturn emulate_gp(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static inline u32 netlink_group_mask(u32 group)\n{\n\treturn group ? 1 << (group - 1) : 0;\n}", "target": 0}
{"code": "pidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}", "target": 1}
{"code": "__visible void kvm_lock_spinning(struct arch_spinlock *lock, __ticket_t want)\n{\n\tstruct kvm_lock_waiting *w;\n\tint cpu;\n\tu64 start;\n\tunsigned long flags;\n\tif (in_nmi())\n\t\treturn;\n\tw = this_cpu_ptr(&klock_waiting);\n\tcpu = smp_processor_id();\n\tstart = spin_time_start();\n\tlocal_irq_save(flags);\n\tw->lock = NULL;\n\tsmp_wmb();\n\tw->want = want;\n\tsmp_wmb();\n\tw->lock = lock;\n\tadd_stats(TAKEN_SLOW, 1);\n\tcpumask_set_cpu(cpu, &waiting_cpus);\n\tbarrier();\n\t__ticket_enter_slowpath(lock);\n\tif (ACCESS_ONCE(lock->tickets.head) == want) {\n\t\tadd_stats(TAKEN_SLOW_PICKUP, 1);\n\t\tgoto out;\n\t}\n\tif (arch_irqs_disabled_flags(flags))\n\t\thalt();\n\telse\n\t\tsafe_halt();\nout:\n\tcpumask_clear_cpu(cpu, &waiting_cpus);\n\tw->lock = NULL;\n\tlocal_irq_restore(flags);\n\tspin_time_accum_blocked(start);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const auto& input = context->input(0);\n    auto flat_in = input.flat<tstring>();\n    int fixed_length;\n    const auto& length_input = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(length_input.shape()),\n                errors::InvalidArgument(\"k must be scalar, got shape \",\n                                        length_input.shape().DebugString()));\n    fixed_length = length_input.scalar<int32>()();\n    OP_REQUIRES(\n        context, fixed_length % sizeof(T) == 0,\n        errors::InvalidArgument(\n            \"fixed_length (\", fixed_length,\n            \") must be a multiple of the size of out_type (\", sizeof(T), \")\"));\n    OP_REQUIRES(context, fixed_length > 0,\n                errors::InvalidArgument(\"fixed_length (\", fixed_length,\n                                        \") must be greater than zero.\"));\n    int width = fixed_length / sizeof(T);\n    TensorShape out_shape = input.shape();\n    out_shape.AddDim(width);\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"output\", out_shape, &output_tensor));\n    if (flat_in.size() == 0) {  \n      return;\n    }\n    auto out = output_tensor->flat_inner_dims<T>();\n    T* out_data = out.data();\n    memset(out_data, 0, fixed_length * flat_in.size());\n    if (!convert_data_endianness_ || sizeof(T) == 1) {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const T* in_data = reinterpret_cast<const T*>(flat_in(i).data());\n        if (flat_in(i).size() > fixed_length) {\n          memcpy(out_data, in_data, fixed_length);\n        } else {\n          memcpy(out_data, in_data, flat_in(i).size());\n        }\n        out_data += fixed_length;\n      }\n    } else {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const char* in_data_bytes =\n            reinterpret_cast<const char*>(flat_in(i).data());\n        char* out_data_bytes = reinterpret_cast<char*>(out_data);\n        const char* p_in = in_data_bytes;\n        char* p_out = out_data_bytes;\n        for (; p_in < in_data_bytes + fixed_length;\n             p_in += sizeof(T), p_out += sizeof(T)) {\n          std::reverse_copy(p_in, p_in + sizeof(T), p_out);\n        }\n        out_data += fixed_length;\n      }\n    }\n  }", "target": 1}
{"code": "errorProcessor(XML_Parser parser, const char *s, const char *end,\n               const char **nextPtr) {\n  UNUSED_P(s);\n  UNUSED_P(end);\n  UNUSED_P(nextPtr);\n  return parser->m_errorCode;\n}", "target": 0}
{"code": "PluginInfoMessageFilter::~PluginInfoMessageFilter() {}", "target": 0}
{"code": "void show_opcodes(u8 *rip, const char *loglvl)\n{\n#define PROLOGUE_SIZE 42\n#define EPILOGUE_SIZE 21\n#define OPCODE_BUFSIZE (PROLOGUE_SIZE + 1 + EPILOGUE_SIZE)\n\tu8 opcodes[OPCODE_BUFSIZE];\n\tif (probe_kernel_read(opcodes, rip - PROLOGUE_SIZE, OPCODE_BUFSIZE)) {\n\t\tprintk(\"%sCode: Bad RIP value.\\n\", loglvl);\n\t} else {\n\t\tprintk(\"%sCode: %\" __stringify(PROLOGUE_SIZE) \"ph <%02x> %\"\n\t\t       __stringify(EPILOGUE_SIZE) \"ph\\n\", loglvl, opcodes,\n\t\t       opcodes[PROLOGUE_SIZE], opcodes + PROLOGUE_SIZE + 1);\n\t}\n}", "target": 1}
{"code": "rt6_print(netdissect_options *ndo, register const u_char *bp, const u_char *bp2 _U_)\n{\n\tregister const struct ip6_rthdr *dp;\n\tregister const struct ip6_rthdr0 *dp0;\n\tregister const u_char *ep;\n\tint i, len;\n\tregister const struct in6_addr *addr;\n\tdp = (const struct ip6_rthdr *)bp;\n\tlen = dp->ip6r_len;\n\tep = ndo->ndo_snapend;\n\tND_TCHECK(dp->ip6r_segleft);\n\tND_PRINT((ndo, \"srcrt (len=%d\", dp->ip6r_len));\t\n\tND_PRINT((ndo, \", type=%d\", dp->ip6r_type));\n\tND_PRINT((ndo, \", segleft=%d\", dp->ip6r_segleft));\n\tswitch (dp->ip6r_type) {\n\tcase IPV6_RTHDR_TYPE_0:\n\tcase IPV6_RTHDR_TYPE_2:\t\t\t\n\t\tdp0 = (const struct ip6_rthdr0 *)dp;\n\t\tND_TCHECK(dp0->ip6r0_reserved);\n\t\tif (dp0->ip6r0_reserved || ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \", rsv=0x%0x\",\n\t\t\t    EXTRACT_32BITS(&dp0->ip6r0_reserved)));\n\t\t}\n\t\tif (len % 2 == 1)\n\t\t\tgoto trunc;\n\t\tlen >>= 1;\n\t\taddr = &dp0->ip6r0_addr[0];\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif ((const u_char *)(addr + 1) > ep)\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \", [%d]%s\", i, ip6addr_string(ndo, addr)));\n\t\t\taddr++;\n\t\t}\n\t\tND_PRINT((ndo, \") \"));\n\t\treturn((dp0->ip6r0_len + 1) << 3);\n\t\tbreak;\n\tdefault:\n\t\tgoto trunc;\n\t\tbreak;\n\t}\n trunc:\n\tND_PRINT((ndo, \"[|srcrt]\"));\n\treturn -1;\n}", "target": 1}
{"code": "static int digi_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint i;\n\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n\t\tif (!serial->port[i]->read_urb) {\n\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!serial->port[i]->write_urb) {\n\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 0}
{"code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n     if (!s->initialized) {\n         ff_vp8_decode_init(avctx);\n         s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n     }\n     s->lossless = 0;\n     if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n    update_canvas_size(avctx, avctx->width, avctx->height);\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}", "target": 1}
{"code": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct sock *sk;\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x\",\n\t\t\tscid, flags, result);\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\tif (!sk)\n\t\treturn 0;\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tbreak;\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {\n\t\t\tchar req[128];\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\t\tgoto done;\n\t\t}\n\tdefault:\n\t\tsk->sk_state = BT_DISCONN;\n\t\tsk->sk_err = ECONNRESET;\n\t\tl2cap_sock_set_timer(sk, HZ * 5);\n\t\t{\n\t\t\tstruct l2cap_disconn_req req;\n\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (flags & 0x01)\n\t\tgoto done;\n\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t}\ndone:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}", "target": 1}
{"code": "void ewk_view_zoom_weak_smooth_scale_set(Evas_Object* ewkView, Eina_Bool smoothScale)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);\n    smoothScale = !!smoothScale;\n    if (smartData->zoom_weak_smooth_scale == smoothScale)\n        return;\n    smartData->zoom_weak_smooth_scale = smoothScale;\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api->zoom_weak_smooth_scale_set);\n    smartData->api->zoom_weak_smooth_scale_set(smartData, smoothScale);\n}", "target": 0}
{"code": "int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn -EINVAL;\n\tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n\t\treturn -ENOMEM;\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\tfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\n\t\t     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_bh(&fq->q.lock);\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tret = -EINPROGRESS;\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len &&\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\nout_unlock:\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q, &nf_frags);\n\treturn ret;\n}", "target": 1}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &nd->path);\nout:\n\treturn ERR_PTR(error);\n}", "target": 0}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "static void vnc_client_cache_addr(VncState *client)\n{\n    Error *err = NULL;\n    client->info = g_malloc0(sizeof(*client->info));\n    vnc_init_basic_info_from_remote_addr(client->sioc,\n                                         qapi_VncClientInfo_base(client->info),\n                                         &err);\n    client->info->websocket = client->websocket;\n    if (err) {\n        qapi_free_VncClientInfo(client->info);\n        client->info = NULL;\n        error_free(err);\n    }\n}", "target": 0}
{"code": "static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, struct nameidata *nd)\n{\n\tstruct dentry * result;\n\tstruct inode *dir = parent->d_inode;\n\tmutex_lock(&dir->i_mutex);\n\tresult = d_lookup(parent, name);\n\tif (!result) {\n\t\tstruct dentry * dentry = d_alloc(parent, name);\n\t\tresult = ERR_PTR(-ENOMEM);\n\t\tif (dentry) {\n\t\t\tresult = dir->i_op->lookup(dir, dentry, nd);\n\t\t\tif (result)\n\t\t\t\tdput(dentry);\n\t\t\telse\n\t\t\t\tresult = dentry;\n\t\t}\n\t\tmutex_unlock(&dir->i_mutex);\n\t\treturn result;\n\t}\n\tmutex_unlock(&dir->i_mutex);\n\tif (result->d_op && result->d_op->d_revalidate) {\n\t\tresult = do_revalidate(result, nd);\n\t\tif (!result)\n\t\t\tresult = ERR_PTR(-ENOENT);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static void pptp_timeout(struct triton_timer_t *t)\n{\n\tstruct pptp_conn_t *conn = container_of(t, typeof(*conn), timeout_timer);\n\tdisconnect(conn);\n}", "target": 0}
{"code": "    HttpIo::HttpImpl::HttpImpl(const std::string& url, size_t blockSize)\n        : Impl(url, blockSize)\n        , hostInfo_(Exiv2::Uri::Parse(url))\n    {\n        Exiv2::Uri::Decode(hostInfo_);\n    }", "target": 0}
{"code": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\tDBG(\"\");\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\tset_discovery_discoverable(adapter, l ? true : false);\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\ttrigger_start_discovery(adapter, 0);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "rb_reg_fixed_encoding_p(VALUE re)\n{\n    if (FL_TEST(re, KCODE_FIXED))\n        return Qtrue;\n    else\n        return Qfalse;\n}", "target": 0}
{"code": "mysql_set_local_infile_handler(MYSQL *mysql,\n                               int (*local_infile_init)(void **, const char *,\n                               void *),\n                               int (*local_infile_read)(void *, char *, uint),\n                               void (*local_infile_end)(void *),\n                               int (*local_infile_error)(void *, char *, uint),\n                               void *userdata)\n{\n  mysql->options.local_infile_init=  local_infile_init;\n  mysql->options.local_infile_read=  local_infile_read;\n  mysql->options.local_infile_end=   local_infile_end;\n  mysql->options.local_infile_error= local_infile_error;\n  mysql->options.local_infile_userdata = userdata;\n}", "target": 0}
{"code": "DECLARESepPutFunc(putRGBseparate8bittile)\n{\n    (void) img; (void) x; (void) y; (void) a;\n    while (h-- > 0) {\n\tUNROLL8(w, NOP, *cp++ = PACK(*r++, *g++, *b++));\n\tSKEW(r, g, b, fromskew);\n\tcp += toskew;\n    }\n}", "target": 0}
{"code": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}", "target": 1}
{"code": "vte_sequence_handler_reset_mode (VteTerminal *terminal, GValueArray *params)\n{\n\tguint i;\n\tlong setting;\n\tGValue *value;\n\tif ((params == NULL) || (params->n_values == 0)) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < params->n_values; i++) {\n\t\tvalue = g_value_array_get_nth(params, i);\n\t\tif (!G_VALUE_HOLDS_LONG(value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tsetting = g_value_get_long(value);\n\t\tvte_sequence_handler_set_mode_internal(terminal, setting, FALSE);\n\t}\n}", "target": 0}
{"code": "void WebContentsImpl::FocusThroughTabTraversal(bool reverse) {\n  if (ShowingInterstitialPage()) {\n    render_manager_.interstitial_page()->FocusThroughTabTraversal(reverse);\n    return;\n  }\n  GetRenderViewHostImpl()->SetInitialFocus(reverse);\n}", "target": 0}
{"code": "void HTMLInputElement::setRangeText(const String& replacement, unsigned start, unsigned end, const String& selectionMode, ExceptionState& exceptionState)\n{\n    if (!m_inputType->supportsSelectionAPI()) {\n        exceptionState.throwDOMException(InvalidStateError, \"The input element's type ('\" + m_inputType->formControlType() + \"') does not support selection.\");\n        return;\n    }\n    HTMLTextFormControlElement::setRangeText(replacement, start, end, selectionMode, exceptionState);\n}", "target": 0}
{"code": "void SandboxedExtensionUnpacker::OnUnpackExtensionSucceeded(\n    const DictionaryValue& manifest) {\n  if (thread_identifier_ != BrowserThread::ID_COUNT)\n    DCHECK(BrowserThread::CurrentlyOn(thread_identifier_));\n  got_response_ = true;\n  scoped_ptr<DictionaryValue> final_manifest(RewriteManifestFile(manifest));\n  if (!final_manifest.get())\n    return;\n  std::string error;\n  if (!extension_l10n_util::LocalizeExtension(extension_root_,\n                                              final_manifest.get(),\n                                              &error)) {\n    ReportFailure(error);\n    return;\n  }\n  extension_ = Extension::Create(\n      extension_root_, Extension::INTERNAL, *final_manifest, true, &error);\n  if (!extension_.get()) {\n    ReportFailure(std::string(\"Manifest is invalid: \") + error);\n    return;\n  }\n  if (!RewriteImageFiles())\n    return;\n  if (!RewriteCatalogFiles())\n    return;\n  ReportSuccess();\n}", "target": 0}
{"code": "ikev1_sub_print(netdissect_options *ndo,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1}
{"code": "bgp_capability_mp (struct peer *peer, struct capability *cap)\n{\n  if (ntohs (cap->mpc.afi) == AFI_IP)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST) \n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == BGP_SAFI_VPNV4)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n\t    peer->afc_nego[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#ifdef HAVE_IPV6\n  else if (ntohs (cap->mpc.afi) == AFI_IP6)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#endif \n  else\n    {\n      return -1;\n    }\n  return 0;\n}", "target": 1}
{"code": "void RenderFrameHostImpl::SwapOut() {\n  if (render_view_host_->IsRenderViewLive()) {\n    Send(new FrameMsg_SwapOut(routing_id_));\n  } else {\n    OnSwappedOut(true);\n  }\n}", "target": 0}
{"code": "HRESULT Http::HrReadHeaders()\n{\n\tHRESULT hr;\n\tstd::string strBuffer;\n\tULONG n = 0;\n\tstd::map<std::string, std::string>::iterator iHeader = mapHeaders.end();\n\tec_log_debug(\"Receiving headers:\");\n\tdo\n\t{\n\t\thr = m_lpChannel->HrReadLine(strBuffer);\n\t\tif (hr != hrSuccess)\n\t\t\treturn hr;\n\t\tif (strBuffer.empty())\n\t\t\tbreak;\n\t\tif (n == 0) {\n\t\t\tm_strAction = strBuffer;\n\t\t} else {\n\t\t\tauto pos = strBuffer.find(':');\n\t\t\tsize_t start = 0;\n\t\t\tif (strBuffer[0] == ' ' || strBuffer[0] == '\\t') {\n\t\t\t\tif (iHeader == mapHeaders.end())\n\t\t\t\t\tcontinue;\n\t\t\t\twhile (strBuffer[start] == ' ' || strBuffer[start] == '\\t')\n\t\t\t\t\t++start;\n\t\t\t\tiHeader->second += strBuffer.substr(start);\n\t\t\t} else {\n\t\t\t\tauto r = mapHeaders.emplace(strBuffer.substr(0, pos), strBuffer.substr(pos + 2));\n\t\t\t\tiHeader = r.first;\n\t\t\t}\n\t\t}\n\t\tif (strBuffer.find(\"Authorization\") != std::string::npos)\n\t\t\tec_log_debug(\"< Authorization: <value hidden>\");\n\t\telse\n\t\t\tec_log_debug(\"< \"+strBuffer);\n\t\t++n;\n\t} while(hr == hrSuccess);\n\thr = HrParseHeaders();\n\tif (hr != hrSuccess)\n\t\thr_ldebug(hr, \"parsing headers failed\");\n\treturn hr;\n}", "target": 1}
{"code": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\tif (size_left == 0)\n\t\treturn 0;\n\tbuf = (char *) match32;\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\t\tsize_left -= match32->match_size;\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\treturn growth;\n}", "target": 1}
{"code": "AP_CORE_DECLARE(void) ap_random_parent_after_fork(void)\n{\n    apr_uint16_t data;\n    apr_random_insecure_bytes(rng, &data, sizeof(data));\n}", "target": 0}
{"code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParamRef(flags);\n\t}", "target": 1}
{"code": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\treturn usb_serial_generic_open(tty, port);\n}", "target": 1}
{"code": "GfxColorSpace *GfxLabColorSpace::copy() const\n{\n    GfxLabColorSpace *cs;\n    cs = new GfxLabColorSpace();\n    cs->whiteX = whiteX;\n    cs->whiteY = whiteY;\n    cs->whiteZ = whiteZ;\n    cs->blackX = blackX;\n    cs->blackY = blackY;\n    cs->blackZ = blackZ;\n    cs->aMin = aMin;\n    cs->aMax = aMax;\n    cs->bMin = bMin;\n    cs->bMax = bMax;\n    cs->kr = kr;\n    cs->kg = kg;\n    cs->kb = kb;\n#ifdef USE_CMS\n    cs->transform = transform;\n#endif\n    return cs;\n}", "target": 0}
{"code": "static int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}", "target": 1}
{"code": "assegment_free (struct assegment *seg)\n{\n  if (!seg)\n    return;\n  if (seg->as)\n    assegment_data_free (seg->as);\n  memset (seg, 0xfe, sizeof(struct assegment));\n  XFREE (MTYPE_AS_SEG, seg);\n  return;\n}", "target": 0}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "FLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, uint32_t samples, FLAC__bool is_last_block)\n{\n\tconst FLAC__byte *buffer;\n\tsize_t bytes;\n\tFLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));\n\tif(!FLAC__bitwriter_get_buffer(encoder->private_->frame, &buffer, &bytes)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\tif(encoder->protected_->verify) {\n\t\tencoder->private_->verify.output.data = buffer;\n\t\tencoder->private_->verify.output.bytes = bytes;\n\t\tif(encoder->private_->verify.state_hint == ENCODER_IN_MAGIC) {\n\t\t\tencoder->private_->verify.needs_magic_hack = true;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__stream_decoder_process_single(encoder->private_->verify.decoder)) {\n\t\t\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\t\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\t\t\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA)\n\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif(write_frame_(encoder, buffer, bytes, samples, is_last_block) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\treturn false;\n\t}\n\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\tFLAC__bitwriter_clear(encoder->private_->frame);\n\tif(samples > 0) {\n\t\tencoder->private_->streaminfo.data.stream_info.min_framesize = flac_min(bytes, encoder->private_->streaminfo.data.stream_info.min_framesize);\n\t\tencoder->private_->streaminfo.data.stream_info.max_framesize = flac_max(bytes, encoder->private_->streaminfo.data.stream_info.max_framesize);\n\t}\n\treturn true;\n}", "target": 1}
{"code": " get_next_file(FILE *VFile, char *ptr)\n {\n \tchar *ret;\n \tret = fgets(ptr, PATH_MAX, VFile);\n \tif (!ret)\n \t\treturn NULL;\n\tif (ptr[strlen(ptr) - 1] == '\\n')\n\t\tptr[strlen(ptr) - 1] = '\\0';\n \treturn ret;\n }", "target": 1}
{"code": "    std::string RafImage::mimeType() const\n    {\n        return \"image/x-fuji-raf\";\n    }", "target": 0}
{"code": "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", "target": 1}
{"code": "static int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tstruct ati_remote2 *ar2;\n\tint r;\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn -ENODEV;\n\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n \tar2->udev = udev;\n \tar2->intf[0] = interface;\n \tar2->ep[0] = &alt->endpoint[0].desc;\n \tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n \tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n \tif (r)\n \t\tgoto fail1;\n \talt = ar2->intf[1]->cur_altsetting;\n \tar2->ep[1] = &alt->endpoint[0].desc;\n \tr = ati_remote2_urb_init(ar2);\n \tif (r)\n\t\tgoto fail2;\n \tar2->channel_mask = channel_mask;\n \tar2->mode_mask = mode_mask;\n \tr = ati_remote2_setup(ar2, ar2->channel_mask);\n \tif (r)\n\t\tgoto fail2;\n \tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n \tstrlcat(ar2->phys, \"/input0\", sizeof(ar2->phys));\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n \tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n \tif (r)\n\t\tgoto fail2;\n \tr = ati_remote2_input_init(ar2);\n \tif (r)\n\t\tgoto fail3;\n \tusb_set_intfdata(interface, ar2);\n \tinterface->needs_remote_wakeup = 1;\n \treturn 0;\n fail3:\n \tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail2:\n \tati_remote2_urb_cleanup(ar2);\n \tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n  fail1:\n \tkfree(ar2);\n\treturn r;\n}", "target": 1}
{"code": "linkaddr_string(netdissect_options *ndo, const u_char *ep,\n\t\tconst unsigned int type, const unsigned int len)\n{\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tif (len == 0)\n\t\treturn (\"<empty>\");\n\tif (type == LINKADDR_ETHER && len == ETHER_ADDR_LEN)\n\t\treturn (etheraddr_string(ndo, ep));\n\tif (type == LINKADDR_FRELAY)\n\t\treturn (q922_string(ndo, ep, len));\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\ttp->e_name = cp = (char *)malloc(len*3);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"linkaddr_string: malloc\");\n\t*cp++ = hex[*ep >> 4];\n\t*cp++ = hex[*ep++ & 0xf];\n\tfor (i = len-1; i > 0 ; --i) {\n\t\t*cp++ = ':';\n\t\t*cp++ = hex[*ep >> 4];\n\t\t*cp++ = hex[*ep++ & 0xf];\n\t}\n\t*cp = '\\0';\n\treturn (tp->e_name);\n}", "target": 1}
{"code": "ext4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tif (!header->h_hash)\n\t\treturn NULL;  \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n\t\t\t\t\t (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT4_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT4_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext4_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tkey = keyring_search_aux(keyring, &ctx);\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 1}
{"code": "inline void GatherNd(const RuntimeShape& params_shape,\n                     const ParamsT* params_data,\n                     const RuntimeShape& indices_shape,\n                     const IndicesT* indices_data,\n                     const RuntimeShape& output_shape, ParamsT* output_data) {\n  ruy::profiler::ScopeLabel label(\"GatherNd\");\n  const GatherNdHelperResult res = GatherNdHelper(params_shape, indices_shape);\n  for (int i = 0; i < res.n_slices; ++i) {\n    int from_pos = 0;\n    for (int j = 0; j < res.indices_nd; ++j) {\n      from_pos += indices_data[i * res.indices_nd + j] * res.dims_to_count[j];\n    }\n    std::memcpy(output_data + i * res.slice_size, params_data + from_pos,\n                sizeof(ParamsT) * res.slice_size);\n  }\n}", "target": 1}
{"code": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n \t\treturn PTR_ERR(stub_clk_chan.mbox);\n \tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n \tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n \tif (!freq_reg)\n \t\treturn -ENOMEM;\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}", "target": 1}
{"code": "static inline struct shmid_kernel *shm_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock(&shm_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn (void *)ipcp;\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}", "target": 0}
{"code": "static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,\n\t\tconst char *page, size_t len)\n{\n\tstruct gadget_info *gi = to_gadget_info(item);\n\tchar *name;\n\tint ret;\n\tname = kstrdup(page, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tif (name[len - 1] == '\\n')\n\t\tname[len - 1] = '\\0';\n\tmutex_lock(&gi->lock);\n\tif (!strlen(name)) {\n\t\tret = unregister_gadget(gi);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tkfree(name);\n\t} else {\n\t\tif (gi->composite.gadget_driver.udc_name) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\t\tgi->composite.gadget_driver.udc_name = name;\n\t\tret = usb_gadget_probe_driver(&gi->composite.gadget_driver);\n\t\tif (ret) {\n\t\t\tgi->composite.gadget_driver.udc_name = NULL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tmutex_unlock(&gi->lock);\n\treturn len;\nerr:\n\tkfree(name);\n\tmutex_unlock(&gi->lock);\n\treturn ret;\n}", "target": 1}
{"code": "check_SAMPLE(const struct ofpact_sample *a OVS_UNUSED,\n             const struct ofpact_check_params *cp OVS_UNUSED)\n{\n    return 0;\n}", "target": 0}
{"code": "static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\t\tfree(k);\n\t\tfree(d);\n\t\treturn; \n\t}\n\tk->addr = *addr;\n\tk->addrlen = addrlen;\n\tlock_rw_init(&k->entry.lock);\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}", "target": 1}
{"code": "FunctionTemplateFactory V8ClassIndex::GetFactory(V8WrapperType type)\n{\n    switch (type) {\n#define MAKE_CASE(type, name)\\\n    case V8ClassIndex::type: return V8##name::GetTemplate;\n    WRAPPER_TYPES(MAKE_CASE)\n#undef MAKE_CASE\n    default: return NULL;\n    }\n}", "target": 0}
{"code": "u32 gf_isom_get_avg_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\tif ( trak->Media->information->sampleTable->SampleSize->sampleSize)\n\t\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n\tif (!trak->Media->information->sampleTable->SampleSize->total_samples) return 0;\n\treturn (u32) (trak->Media->information->sampleTable->SampleSize->total_size / trak->Media->information->sampleTable->SampleSize->total_samples);\n}", "target": 0}
{"code": "  Definition_Obj Parser::parse_definition(Definition::Type which_type)\n  {\n    std::string which_str(lexed);\n    if (!lex< identifier >()) error(\"invalid name in \" + which_str + \" definition\");\n    std::string name(Util::normalize_underscores(lexed));\n    if (which_type == Definition::FUNCTION && (name == \"and\" || name == \"or\" || name == \"not\"))\n    { error(\"Invalid function name \\\"\" + name + \"\\\".\"); }\n    ParserState source_position_of_def = pstate;\n    Parameters_Obj params = parse_parameters();\n    if (which_type == Definition::MIXIN) stack.push_back(Scope::Mixin);\n    else stack.push_back(Scope::Function);\n    Block_Obj body = parse_block();\n    stack.pop_back();\n    return SASS_MEMORY_NEW(Definition, source_position_of_def, name, params, body, which_type);\n  }", "target": 0}
{"code": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}", "target": 1}
{"code": "int dyn_string_cmp(DYNAMIC_STRING* ds, const char *fname)\n{\n  int error;\n  File fd;\n  char temp_file_path[FN_REFLEN];\n  DBUG_ENTER(\"dyn_string_cmp\");\n  DBUG_PRINT(\"enter\", (\"fname: %s\", fname));\n  if ((fd= create_temp_file(temp_file_path, TMPDIR,\n                            \"tmp\", O_CREAT | O_SHARE | O_RDWR,\n                            MYF(MY_WME))) < 0)\n    die(\"Failed to create temporary file for ds\");\n  if (my_write(fd, (uchar *) ds->str, ds->length,\n               MYF(MY_FNABP | MY_WME)) ||\n      my_seek(fd, 0, SEEK_SET, MYF(0)) == MY_FILEPOS_ERROR)\n  {\n    my_close(fd, MYF(0));\n    my_delete(temp_file_path, MYF(MY_WME));\n    die(\"Failed to write file '%s'\", temp_file_path);\n  }\n  error= compare_files2(fd, fname);\n  my_close(fd, MYF(0));\n  my_delete(temp_file_path, MYF(MY_WME));\n  DBUG_RETURN(error);\n}", "target": 0}
{"code": "png_crc_error(png_structp png_ptr)\n{\n   png_byte crc_bytes[4];\n   png_uint_32 crc;\n   int need_crc = 1;\n   if (png_ptr->chunk_name[0] & 0x20)                     \n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n         need_crc = 0;\n   }\n   else                                                    \n   {\n      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)\n         need_crc = 0;\n   }\n   png_read_data(png_ptr, crc_bytes, 4);\n   if (need_crc)\n   {\n      crc = png_get_uint_32(crc_bytes);\n      return ((int)(crc != png_ptr->crc));\n   }\n   else\n      return (0);\n}", "target": 0}
{"code": " */\nint re_yyget_column  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    return yycolumn;", "target": 1}
{"code": "find_by_thp(struct tang_keys_info* tki, const char* target)\n{\n    if (!tki) {\n        return NULL;\n    }\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    json_array_extend(keys, tki->m_rotated_keys);\n    size_t idx;\n    json_t* jwk;\n    const char** hashes = supported_hashes();\n    json_array_foreach(keys, idx, jwk) {\n        for (int i = 0; hashes[i]; i++) {\n            __attribute__ ((__cleanup__(cleanup_str))) char* thumbprint = jwk_thumbprint(jwk, hashes[i]);\n            if (!thumbprint || strcmp(thumbprint, target) != 0) {\n                continue;\n            }\n            if (jwk_valid_for_deriving_keys(jwk)) {\n                return json_incref(jwk);\n            } else if (jwk_valid_for_signing(jwk)) {\n                json_auto_t* sign = json_deep_copy(tki->m_sign);\n                if (json_array_append(sign, jwk) == -1) {\n                    return NULL;\n                }\n                json_auto_t* jws = jwk_sign(tki->m_payload, sign);\n                if (!jws) {\n                    return NULL;\n                }\n                return json_incref(jws);\n            }\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n \tstruct inode *inode = page->mapping->host;\n \tstruct buffer_head *bh = NULL;\n \tunsigned char *symlink;\n\tint err = -EIO;\n \tunsigned char *p = kmap(page);\n \tstruct udf_inode_info *iinfo;\n \tuint32_t pos;\n \tiinfo = UDF_I(inode);\n \tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n \t} else {\n \t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh)\n\t\t\tgoto out;\n \t\tsymlink = bh->b_data;\n \t}\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n \tunlock_page(page);\n \treturn 0;\nout:\n \tup_read(&iinfo->i_data_sem);\n \tSetPageError(page);\n \tkunmap(page);\n \tunlock_page(page);\n \treturn err;\n}", "target": 1}
{"code": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n  SeenContainers seen;\n  return recursiveAddVarImpl(varName, varVariant, hasVarTag, seen);\n}", "target": 0}
{"code": "fetch_alt_indirect_string (dwarf_vma offset)\n{\n  separate_info * i;\n  if (! do_follow_links)\n    return \"\";\n  if (first_separate_info == NULL)\n    return _(\"<no links available>\");\n  for (i = first_separate_info; i != NULL; i = i->next)\n    {\n      struct dwarf_section * section;\n      const char *           ret;\n      if (! load_debug_section (separate_debug_str, i->handle))\n\tcontinue;\n      section = &debug_displays [separate_debug_str].section;\n      if (section->start == NULL)\n\tcontinue;\n      if (offset >= section->size)\n\tcontinue;\n      ret = (const char *) (section->start + offset);\n      if (strnlen ((const char *) ret, section->size - offset)\n\t  == section->size - offset)\n\treturn _(\"<no NUL byte at end of alt .debug_str section>\");\n      return ret;\n    }\n  warn (_(\"DW_FORM_GNU_strp_alt offset (%s) too big or no string sections available\\n\"),\n\tdwarf_vmatoa (\"x\", offset));\n  return _(\"<offset is too big>\");\n}", "target": 0}
{"code": "static int sg_proc_seq_show_int(struct seq_file *s, void *v)\n{\n\tseq_printf(s, \"%d\\n\", *((int *)s->private));\n\treturn 0;\n}", "target": 0}
{"code": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\tif (nsops < 1)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}", "target": 1}
{"code": "static uint64_t pit_ioport_read(void *opaque, hwaddr addr,\n                                unsigned size)\n{\n    PITCommonState *pit = opaque;\n    int ret, count;\n    PITChannelState *s;\n    addr &= 3;\n    s = &pit->channels[addr];\n    if (s->status_latched) {\n        s->status_latched = 0;\n        ret = s->status;\n    } else if (s->count_latched) {\n        switch(s->count_latched) {\n        default:\n        case RW_STATE_LSB:\n            ret = s->latched_count & 0xff;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_MSB:\n            ret = s->latched_count >> 8;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_WORD0:\n            ret = s->latched_count & 0xff;\n            s->count_latched = RW_STATE_MSB;\n            break;\n        }\n    } else {\n        switch(s->read_state) {\n        default:\n        case RW_STATE_LSB:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            break;\n        case RW_STATE_MSB:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            break;\n        case RW_STATE_WORD0:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            s->read_state = RW_STATE_WORD1;\n            break;\n        case RW_STATE_WORD1:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            s->read_state = RW_STATE_WORD0;\n            break;\n        }\n    }\n    return ret;\n}", "target": 1}
{"code": "DSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                    const std::string& params,\n                                    const std::string& provider) const\n   {\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }", "target": 1}
{"code": "TEST_F(QueryPlannerTest, OrCollapsesToSingleScan) {\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{$or: [{a:{$gt:2}}, {a:{$gt:0}}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a:1}, \"\n        \"bounds: {a: [[0,Infinity,false,true]]}}}}}\");\n}", "target": 0}
{"code": "  Status DoCompute(OpKernelContext* ctx) {\n    tensorflow::ResourceTagger tag(kTFDataResourceTag,\n                                   ctx->op_kernel().type_string());\n    tstring filename;\n    TF_RETURN_IF_ERROR(\n        ParseScalarArgument<tstring>(ctx, \"filename\", &filename));\n    tstring compression_type;\n    TF_RETURN_IF_ERROR(ParseScalarArgument<tstring>(ctx, \"compression_type\",\n                                                    &compression_type));\n    std::unique_ptr<WritableFile> file;\n    TF_RETURN_IF_ERROR(ctx->env()->NewWritableFile(filename, &file));\n    auto writer = absl::make_unique<io::RecordWriter>(\n        file.get(),\n        io::RecordWriterOptions::CreateRecordWriterOptions(compression_type));\n    DatasetBase* dataset;\n    TF_RETURN_IF_ERROR(GetDatasetFromVariantTensor(ctx->input(0), &dataset));\n    IteratorContext::Params params(ctx);\n    FunctionHandleCache function_handle_cache(params.flr);\n    params.function_handle_cache = &function_handle_cache;\n    ResourceMgr resource_mgr;\n    params.resource_mgr = &resource_mgr;\n    CancellationManager cancellation_manager(ctx->cancellation_manager());\n    params.cancellation_manager = &cancellation_manager;\n    IteratorContext iter_ctx(std::move(params));\n    DatasetBase* finalized_dataset;\n    TF_RETURN_IF_ERROR(FinalizeDataset(ctx, dataset, &finalized_dataset));\n    std::unique_ptr<IteratorBase> iterator;\n    TF_RETURN_IF_ERROR(finalized_dataset->MakeIterator(\n        &iter_ctx, nullptr, \"ToTFRecordOpIterator\", &iterator));\n    std::vector<Tensor> components;\n    components.reserve(finalized_dataset->output_dtypes().size());\n    bool end_of_sequence;\n    do {\n      TF_RETURN_IF_ERROR(\n          iterator->GetNext(&iter_ctx, &components, &end_of_sequence));\n      if (!end_of_sequence) {\n        TF_RETURN_IF_ERROR(\n            writer->WriteRecord(components[0].scalar<tstring>()()));\n      }\n      components.clear();\n    } while (!end_of_sequence);\n    return Status::OK();\n  }", "target": 1}
{"code": "static void bnx2x_recovery_failed(struct bnx2x *bp)\n{\n\tnetdev_err(bp->dev, \"Recovery has failed. Power cycle is needed.\\n\");\n\tnetif_device_detach(bp->dev);\n\tbnx2x_set_reset_in_progress(bp);\n\tbnx2x_set_power_state(bp, PCI_D3hot);\n\tbp->recovery_state = BNX2X_RECOVERY_FAILED;\n\tsmp_mb();\n}", "target": 0}
{"code": "match_aref(int argc, VALUE *argv, VALUE match)\n{\n    VALUE idx, length;\n    match_check(match);\n    rb_scan_args(argc, argv, \"11\", &idx, &length);\n    if (NIL_P(length)) {\n\tif (FIXNUM_P(idx)) {\n\t    return rb_reg_nth_match(FIX2INT(idx), match);\n\t}\n\telse {\n\t    int num = namev_to_backref_number(RMATCH_REGS(match), RMATCH(match)->regexp, idx);\n\t    if (num >= 0) {\n\t\treturn rb_reg_nth_match(num, match);\n\t    }\n\t    else {\n\t\treturn match_ary_aref(match, idx, Qnil);\n\t    }\n\t}\n    }\n    else {\n\tlong beg = NUM2LONG(idx);\n\tlong len = NUM2LONG(length);\n\tlong num_regs = RMATCH_REGS(match)->num_regs;\n\tif (len < 0) {\n\t    return Qnil;\n\t}\n\tif (beg < 0) {\n\t    beg += num_regs;\n\t    if (beg < 0) return Qnil;\n\t}\n\telse if (beg > num_regs) {\n\t    return Qnil;\n\t}\n\telse if (beg+len > num_regs) {\n\t    len = num_regs - beg;\n\t}\n\treturn match_ary_subseq(match, beg, len, Qnil);\n    }\n}", "target": 0}
{"code": "size_t IndexedDBDatabase::GetUsableMessageSizeInBytes() const {\n  return blink::mojom::kIDBMaxMessageSize -\n         blink::mojom::kIDBMaxMessageOverhead;\n}", "target": 0}
{"code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n \tset_bit(MMF_UNSTABLE, &mm->flags);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n \tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n \t\tif (!can_madv_dontneed_vma(vma))\n \t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n \t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n \t\t\t\t\t NULL);\n \t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n \tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n \t\t\ttask_pid_nr(tsk), tsk->comm,\n \t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 1}
{"code": "Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n{\n  Error eofError(heif_error_Invalid_input,\n                 heif_suberror_Invalid_grid_data,\n                 \"Overlay image data incomplete\");\n  if (data.size() < 2 + 4 * 2) {\n    return eofError;\n  }\n  m_version = data[0];\n  m_flags = data[1];\n  if (m_version != 0) {\n    std::stringstream sstr;\n    sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n    return Error(heif_error_Unsupported_feature,\n                 heif_suberror_Unsupported_data_version,\n                 sstr.str());\n  }\n  int field_len = ((m_flags & 1) ? 4 : 2);\n  int ptr = 2;\n  if (ptr + 4 * 2 + 2 * field_len + num_images * 2 * field_len > data.size()) {\n    return eofError;\n  }\n  for (int i = 0; i < 4; i++) {\n    uint16_t color = static_cast<uint16_t>(readvec(data, ptr, 2));\n    m_background_color[i] = color;\n  }\n  m_width = readvec(data, ptr, field_len);\n  m_height = readvec(data, ptr, field_len);\n  m_offsets.resize(num_images);\n  for (size_t i = 0; i < num_images; i++) {\n    m_offsets[i].x = readvec_signed(data, ptr, field_len);\n    m_offsets[i].y = readvec_signed(data, ptr, field_len);\n  }\n  return Error::Ok;\n}", "target": 1}
{"code": "delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext)\n{\n    std::string real_rule;\n    if(startsWith(rule, \"[]\") && add_direct)\n    {\n        filtered_nodelist.emplace_back(rule.substr(2));\n    }\n#ifndef NO_JS_RUNTIME\n    else if(startsWith(rule, \"script:\"))\n    {\n        script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){\n            std::string script = fileGet(rule.substr(7), true);\n            try\n            {\n                ctx.eval(script);\n                auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(\"filter\");\n                std::string result_list = filter(nodelist);\n                filtered_nodelist = split(regTrim(result_list), \"\\n\");\n            }\n            catch (qjs::exception)\n            {\n                script_print_stack(ctx);\n            }\n        }, global.scriptCleanContext);\n    }\n#endif \n    else\n    {\n        for(Proxy &x : nodelist)\n        {\n            if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end())\n                filtered_nodelist.emplace_back(x.Remark);\n        }\n    }\n}", "target": 1}
{"code": "PBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,\n    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)\n{\n  struct HMAC_SHA256_CTX PShctx, hctx;\n  size_t i;\n  uint8_t ivec[4];\n  uint32_t *ivec_p;\n  uint8_t U[32];\n  uint8_t T[32];\n  uint64_t j;\n  int k;\n  size_t clen;\n  HMAC_SHA256_Init(&PShctx, passwd, passwdlen);\n  HMAC_SHA256_Update(&PShctx, salt, saltlen);\n  ivec_p = (uint32_t *) ivec;\n  for (i = 0; i * 32 < dkLen; i++) {\n    *ivec_p = folly::Endian::big32((uint32_t)(i + 1));\n    memcpy(&hctx, &PShctx, sizeof(struct HMAC_SHA256_CTX));\n    HMAC_SHA256_Update(&hctx, ivec, 4);\n    HMAC_SHA256_Final(U, &hctx);\n    memcpy(T, U, 32);\n    for (j = 2; j <= c; j++) {\n      HMAC_SHA256_Init(&hctx, passwd, passwdlen);\n      HMAC_SHA256_Update(&hctx, U, 32);\n      HMAC_SHA256_Final(U, &hctx);\n      for (k = 0; k < 32; k++)\n        T[k] ^= U[k];\n    }\n    clen = dkLen - i * 32;\n    if (clen > 32)\n      clen = 32;\n    memcpy(&buf[i * 32], T, clen);\n  }\n  memset(&PShctx, 0, sizeof(struct HMAC_SHA256_CTX));\n}", "target": 1}
{"code": "MagickExport MagickBooleanType GetImageEntropy(const Image *image,\n  double *entropy,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  *entropy=channel_statistics[CompositePixelChannel].entropy;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}", "target": 0}
{"code": "void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}", "target": 1}
{"code": "is_valid_mbc_string(const UChar* s, const UChar* end)\n{\n  return onigenc_length_check_is_valid_mbc_string(ONIG_ENCODING_UTF16_BE, s, end);\n}", "target": 0}
{"code": "static bool setup_natural_join_row_types(THD *thd,\n                                         List<TABLE_LIST> *from_clause,\n                                         Name_resolution_context *context)\n{\n  DBUG_ENTER(\"setup_natural_join_row_types\");\n  thd->where= \"from clause\";\n  if (from_clause->elements == 0)\n    DBUG_RETURN(false); \n  if (!context->select_lex->first_natural_join_processing)\n  {\n    context->first_name_resolution_table= context->natural_join_first_table;\n    DBUG_PRINT(\"info\", (\"using cached setup_natural_join_row_types\"));\n    DBUG_RETURN(false);\n  }\n  List_iterator_fast<TABLE_LIST> table_ref_it(*from_clause);\n  TABLE_LIST *table_ref; \n  TABLE_LIST *left_neighbor;\n  TABLE_LIST *right_neighbor= NULL;\n  for (left_neighbor= table_ref_it++; left_neighbor ; )\n  {\n    table_ref= left_neighbor;\n    do\n    {\n      left_neighbor= table_ref_it++;\n    }\n    while (left_neighbor && left_neighbor->sj_subq_pred);\n    if (store_top_level_join_columns(thd, table_ref,\n                                     left_neighbor, right_neighbor))\n      DBUG_RETURN(true);\n    if (left_neighbor)\n    {\n      TABLE_LIST *first_leaf_on_the_right;\n      first_leaf_on_the_right= table_ref->first_leaf_for_name_resolution();\n      left_neighbor->next_name_resolution_table= first_leaf_on_the_right;\n    }\n    right_neighbor= table_ref;\n  }\n  DBUG_ASSERT(right_neighbor);\n  context->first_name_resolution_table=\n    right_neighbor->first_leaf_for_name_resolution();\n  context->natural_join_first_table= context->first_name_resolution_table;\n  context->select_lex->first_natural_join_processing= false;\n  DBUG_RETURN (false);\n}", "target": 0}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 19;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }", "target": 1}
{"code": "const char *cgit_rooturl(void)\n{\n\tif (ctx.cfg.virtual_root)\n\t\treturn ctx.cfg.virtual_root;\n\telse\n\t\treturn ctx.cfg.script_name;\n}", "target": 0}
{"code": "static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n                          Error **errp)\n{\n    BDRVParallelsState *s = bs->opaque;\n    int i;\n    struct parallels_header ph;\n    int ret;\n    bs->read_only = 1; \n    ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));\n    if (ret < 0) {\n        goto fail;\n    }\n    if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n        (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n        error_setg(errp, \"Image not in Parallels format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n    bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n    s->tracks = le32_to_cpu(ph.tracks);\n    s->catalog_size = le32_to_cpu(ph.catalog_entries);\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n    ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    }\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\n}", "target": 1}
{"code": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}", "target": 1}
{"code": "int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  \n  struct mg_str *cl;\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  \n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n  return req_len;\n}", "target": 1}
{"code": "PHP_FUNCTION(acos)\n{\n\tdouble num;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"d\", &num) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_DOUBLE(acos(num));\n}", "target": 0}
{"code": "static const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[100];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, 100, \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, 100, \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, 100, \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, 100, \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, 100, \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, 100, \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, 100, \"UNDEFINED\");\n    }\n    return buf;\n}", "target": 1}
{"code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\tdevinfo.version_code = COMEDI_VERSION_CODE;\n\tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n\tif (read_subdev)\n\t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "bool CSecurityTLS::processMsg(CConnection* cc)\n{\n  rdr::InStream* is = cc->getInStream();\n  rdr::OutStream* os = cc->getOutStream();\n  client = cc;\n  initGlobal();\n  if (!session) {\n    if (!is->checkNoWait(1))\n      return false;\n    if (is->readU8() == 0) {\n      rdr::U32 result = is->readU32();\n      CharArray reason;\n      if (result == secResultFailed || result == secResultTooMany)\n        reason.buf = is->readString();\n      else\n        reason.buf = strDup(\"Authentication failure (protocol error)\");\n      throw AuthFailureException(reason.buf);\n    }\n    if (gnutls_init(&session, GNUTLS_CLIENT) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n    setParam();\n  }\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n    if (!gnutls_error_is_fatal(err))\n      return false;\n    vlog.error(\"TLS Handshake failed: %s\\n\", gnutls_strerror (err));\n    shutdown(false);\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n  checkSession();\n  cc->setStreams(fis = tlsis, fos = tlsos);\n  return true;\n}", "target": 1}
{"code": "static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,\n\t\tstruct compat_video_spu_palette __user *up)\n{\n\tstruct video_spu_palette __user *up_native;\n\tcompat_uptr_t palp;\n\tint length, err;\n \terr  = get_user(palp, &up->palette);\n \terr |= get_user(length, &up->length);\n \tup_native = compat_alloc_user_space(sizeof(struct video_spu_palette));\n \terr  = put_user(compat_ptr(palp), &up_native->palette);\n\terr |= put_user(length, &up_native->length);\n\tif (err)\n\t\treturn -EFAULT;\n\terr = sys_ioctl(fd, cmd, (unsigned long) up_native);\n\treturn err;\n}", "target": 1}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "TypedValue HHVM_FUNCTION(array_pad,\n                         const Variant& input,\n                         int pad_size,\n                         const Variant& pad_value) {\n  getCheckedArray(input);\n  if (pad_size > 0) {\n    return tvReturn(ArrayUtil::Pad(arr_input, pad_value, pad_size, true));\n  }\n  return tvReturn(ArrayUtil::Pad(arr_input, pad_value, -pad_size, false));\n}", "target": 0}
{"code": "void GfxGouraudTriangleShading::getParameterizedColor(double t, GfxColor *color) const\n{\n    double out[gfxColorMaxComps];\n    for (unsigned int j = 0; j < funcs.size(); ++j) {\n        funcs[j]->transform(&t, &out[j]);\n    }\n    for (int j = 0; j < gfxColorMaxComps; ++j) {\n        color->c[j] = dblToCol(out[j]);\n    }\n}", "target": 0}
{"code": "void ogs_nas_5gs_mobile_identity_guti_to_nas_guti(\n        ogs_nas_5gs_mobile_identity_guti_t *mobile_identity_guti,\n        ogs_nas_5gs_guti_t *nas_guti)\n{\n    ogs_assert(mobile_identity_guti);\n    ogs_assert(nas_guti);\n    memset(nas_guti, 0, sizeof(*nas_guti));\n    memcpy(&nas_guti->nas_plmn_id,\n            &mobile_identity_guti->nas_plmn_id, OGS_PLMN_ID_LEN);\n    memcpy(&nas_guti->amf_id,\n            &mobile_identity_guti->amf_id, sizeof(ogs_amf_id_t));\n    nas_guti->m_tmsi = be32toh(mobile_identity_guti->m_tmsi);\n}", "target": 0}
{"code": "void SpeechSynthesis::voicesDidChange()\n{\n    m_voiceList.clear();\n    if (!executionContext()->activeDOMObjectsAreStopped())\n        dispatchEvent(Event::create(EventTypeNames::voiceschanged));\n}", "target": 0}
{"code": "DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n   BigInt i(msg, msg_len, q.bits());\n   while(i >= q)\n      i -= q;\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n   BigInt s = inverse_mod(k, q);\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n   s = m_mod_q.multiply(s, mul_add(m_x, r, i));\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r/s during DSA signature\");\n   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());\n   }", "target": 1}
{"code": "static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint err = -EAGAIN;\n\tint used;\n\tlong copied = 0;\n\tlock_sock(sk);\n\twhile (iov_iter_count(&msg->msg_iter)) {\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\t\tused = ctx->used;\n\t\tif (!used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\t\tused = min_t(unsigned long, used, iov_iter_count(&msg->msg_iter));\n\t\tused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t\tif (ctx->more || used < ctx->used)\n\t\t\tused -= used % bs;\n\t\terr = -EINVAL;\n\t\tif (!used)\n\t\t\tgoto free;\n\t\tablkcipher_request_set_crypt(&ctx->req, sg,\n\t\t\t\t\t     ctx->rsgl.sg, used,\n\t\t\t\t\t     ctx->iv);\n\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_ablkcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_ablkcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\nfree:\n\t\taf_alg_free_sg(&ctx->rsgl);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\tcopied += used;\n\t\tskcipher_pull_sgl(sk, used);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\terr = 0;\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\treturn copied ?: err;\n}", "target": 1}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = self_in;\n    long long val = self->val;\n    if (big_endian) {\n        byte *b = buf + len;\n        while (b > buf) {\n            *--b = val;\n            val >>= 8;\n        }\n    } else {\n        for (; len > 0; --len) {\n            *buf++ = val;\n            val >>= 8;\n        }\n    }\n}", "target": 1}
{"code": "static char *decode_text_string(const char *str, size_t str_len)\n{\n    int   idx, is_hex, is_utf16be, ascii_idx;\n    char *ascii, hex_buf[5] = {0};\n    is_hex = is_utf16be = idx = ascii_idx = 0;\n    if (str[0] == '(')\n    {\n        ascii = malloc(strlen(str) + 1);\n        strncpy(ascii, str, strlen(str) + 1);\n        return ascii;\n    }\n    else if (str[0] == '<')\n    {\n        is_hex = 1;\n        ++idx;\n    }\n    if (is_hex && (str_len > 5) && \n        (str[idx] == 'F') && (str[idx+1] == 'E') &&\n        (str[idx+2] == 'F') && (str[idx+3] == 'F'))\n    {\n        is_utf16be = 1;\n        idx += 4;\n    }\n    else\n      return NULL;\n    ascii = malloc(str_len);\n    for ( ; idx<str_len; ++idx)\n    {\n        hex_buf[0] = str[idx++];\n        hex_buf[1] = str[idx++];\n        hex_buf[2] = str[idx++];\n        hex_buf[3] = str[idx];\n        ascii[ascii_idx++] = strtol(hex_buf, NULL, 16);\n    }\n    return ascii;\n}", "target": 1}
{"code": "static unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tstruct sock *sk = tun->sk;\n\tunsigned int mask = 0;\n\tif (!tun)\n\t\treturn POLLERR;\n\tDBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n\tpoll_wait(file, &tun->socket.wait, wait);\n\tif (!skb_queue_empty(&tun->readq))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = POLLERR;\n\ttun_put(tun);\n\treturn mask;\n}", "target": 1}
{"code": "    TaskFactory& TaskFactory::instance()\n    {\n        static TaskFactory ins;\n        return ins;\n    }", "target": 0}
{"code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 1}
{"code": "wsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_DCS;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\n\t\tedp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tswitch (instate->inchar) {\n\t\tcase '$':\n\t\t\tnewstate = VT100_EMUL_STATE_DCS_DOLLAR;\n\t\t\tbreak;\n\t\tcase '{': \t\n\t\tcase '!': \n\t\tcase '|': \n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS %x (%d, %d) unknown\\n\", instate->inchar,\n\t\t\t    ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "void ImageLoader::UpdateImageState(ImageResourceContent* new_image_content) {\n  image_content_ = new_image_content;\n  if (!new_image_content) {\n    image_resource_for_image_document_ = nullptr;\n    image_complete_ = true;\n  } else {\n    image_complete_ = false;\n  }\n  delay_until_image_notify_finished_ = nullptr;\n}", "target": 0}
{"code": "static int parse_line(char *str)\n{\n\tuint8_t array[256];\n\tuint16_t value, pskey, length = 0;\n\tchar *off, *end;\n\tpskey = strtol(str + 1, NULL, 16);\n\toff = strstr(str, \"=\");\n\tif (!off)\n\t\treturn -EIO;\n\toff++;\n\twhile (1) {\n\t\tvalue = strtol(off, &end, 16);\n\t\tif (value == 0 && off == end)\n\t\t\tbreak;\n\t\tarray[length++] = value & 0xff;\n\t\tarray[length++] = value >> 8;\n\t\tif (*end == '\\0')\n\t\t\tbreak;\n\t\toff = end + 1;\n\t}\n\treturn psr_put(pskey, array, length);\n}", "target": 1}
{"code": "ModuleState::ModuleState() :\n\tm_isDirty(true)\n{\n}", "target": 0}
{"code": "static inline int bitDiff(int value1, int value2)\n{\n  int decBits = 0;\n  if (value2 < value1)\n    while (decBits <= 14 && (value2 << ++decBits) < value1)\n      ;\n  return decBits;\n}", "target": 0}
{"code": "FileSpec::FileSpec(const Object *fileSpecA)\n{\n  ok = true;\n  fileName = nullptr;\n  platformFileName = nullptr;\n  embFile = nullptr;\n  desc = nullptr;\n  fileSpec = fileSpecA->copy();\n  Object obj1 = getFileSpecName(fileSpecA);\n  if (!obj1.isString()) {\n    ok = false;\n    error(errSyntaxError, -1, \"Invalid FileSpec\");\n    return;\n  }\n  fileName = obj1.getString()->copy();\n  if (fileSpec.isDict()) {\n    obj1 = fileSpec.dictLookup(\"EF\");\n    if (obj1.isDict()) {\n      fileStream = obj1.dictLookupNF(\"F\");\n      if (!fileStream.isRef()) {\n        ok = false;\n        fileStream.setToNull();\n        error(errSyntaxError, -1, \"Invalid FileSpec: Embedded file stream is not an indirect reference\");\n        return;\n      }\n    }\n  }\n  obj1 = fileSpec.dictLookup(\"Desc\");\n  if (obj1.isString())\n    desc = obj1.getString()->copy();\n}", "target": 1}
{"code": "static int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n    stellaris_enet_reset(s);\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n                    stellaris_enet_save, stellaris_enet_load, s);\n    return 0;\n}", "target": 1}
{"code": "xmlFreeRefList(xmlListPtr list_ref) {\n    if (list_ref == NULL) return;\n    xmlListDelete(list_ref);\n}", "target": 0}
{"code": "intrusive_ptr<Expression> Expression::parseObject(ExpressionContext* const expCtx,\n                                                  BSONObj obj,\n                                                  const VariablesParseState& vps) {\n    if (obj.isEmpty()) {\n        return ExpressionObject::create(expCtx, {});\n    }\n    if (obj.firstElementFieldName()[0] == '$') {\n        return parseExpression(expCtx, obj, vps);\n    }\n    return ExpressionObject::parse(expCtx, obj, vps);\n}", "target": 0}
{"code": "const char* get_backup_uuid(MYSQL *connection)\n{\n\tif (!backup_uuid) {\n\t\tbackup_uuid = read_mysql_one_value(connection, \"SELECT UUID()\");\n\t}\n\treturn backup_uuid;\n}", "target": 0}
{"code": "zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC)\n{\n\tzend_lex_state original_lex_state;\n\tzend_op_array *op_array = (zend_op_array *) emalloc(sizeof(zend_op_array));\n\tzend_op_array *original_active_op_array = CG(active_op_array);\n\tzend_op_array *retval;\n\tzval tmp;\n\tint compiler_result;\n\tzend_bool original_in_compilation = CG(in_compilation);\n\tif (source_string->value.str.len==0) {\n\t\tefree(op_array);\n\t\treturn NULL;\n\t}\n\tCG(in_compilation) = 1;\n\ttmp = *source_string;\n\tzval_copy_ctor(&tmp);\n\tconvert_to_string(&tmp);\n\tsource_string = &tmp;\n\tzend_save_lexical_state(&original_lex_state TSRMLS_CC);\n\tif (zend_prepare_string_for_scanning(source_string, filename TSRMLS_CC)==FAILURE) {\n\t\tefree(op_array);\n\t\tretval = NULL;\n\t} else {\n\t\tzend_bool orig_interactive = CG(interactive);\n\t\tCG(interactive) = 0;\n\t\tinit_op_array(op_array, ZEND_EVAL_CODE, INITIAL_OP_ARRAY_SIZE TSRMLS_CC);\n\t\tCG(interactive) = orig_interactive;\n\t\tCG(active_op_array) = op_array;\n\t\tzend_stack_push(&CG(context_stack), (void *) &CG(context), sizeof(CG(context)));\n\t\tzend_init_compiler_context(TSRMLS_C);\n\t\tBEGIN(ST_IN_SCRIPTING);\n\t\tcompiler_result = zendparse(TSRMLS_C);\n\t\tif (SCNG(script_filtered)) {\n\t\t\tefree(SCNG(script_filtered));\n\t\t\tSCNG(script_filtered) = NULL;\n\t\t}\n\t\tif (compiler_result==1) {\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tCG(unclean_shutdown)=1;\n\t\t\tdestroy_op_array(op_array TSRMLS_CC);\n\t\t\tefree(op_array);\n\t\t\tretval = NULL;\n\t\t} else {\n\t\t\tzend_do_return(NULL, 0 TSRMLS_CC);\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tpass_two(op_array TSRMLS_CC);\n\t\t\tzend_release_labels(0 TSRMLS_CC);\n\t\t\tretval = op_array;\n\t\t}\n\t}\n\tzend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n\tzval_dtor(&tmp);\n\tCG(in_compilation) = original_in_compilation;\n\treturn retval;\n}", "target": 1}
{"code": "static void bnx2x_set_reset_done(struct bnx2x *bp)\n{\n\tu32 val;\n\tu32 bit = BP_PATH(bp) ?\n\t\tBNX2X_PATH1_RST_IN_PROG_BIT : BNX2X_PATH0_RST_IN_PROG_BIT;\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\tval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\tval &= ~bit;\n\tREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n}", "target": 0}
{"code": "static struct sk_buff *noop_dequeue(struct Qdisc * qdisc)\n{\n\treturn NULL;\n}", "target": 0}
{"code": "static void __init set_osi_linux(unsigned int enable)\n{\n\tif (osi_linux.enable != enable)\n\t\tosi_linux.enable = enable;\n\tif (osi_linux.enable)\n\t\tacpi_osi_setup(\"Linux\");\n\telse\n\t\tacpi_osi_setup(\"!Linux\");\n\treturn;\n}", "target": 0}
{"code": "Status QuantizeV2Shape(InferenceContext* c) {\n  int axis = -1;\n  Status s = c->GetAttr(\"axis\", &axis);\n  if (!s.ok() && s.code() != error::NOT_FOUND) {\n    return s;\n  }\n  const int minmax_rank = (axis == -1) ? 0 : 1;\n  TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));\n  ShapeHandle minmax;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), minmax_rank, &minmax));\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), minmax_rank, &minmax));\n  if (axis != -1) {\n    ShapeHandle input;\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(c->input(0), axis + 1, &input));\n    DimensionHandle depth;\n    TF_RETURN_IF_ERROR(\n        c->Merge(c->Dim(minmax, 0), c->Dim(input, axis), &depth));\n  }\n  c->set_output(1, minmax);\n  c->set_output(2, minmax);\n  return Status::OK();\n}", "target": 1}
{"code": "fbStore_a1b1g1r1 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  pixel;\n        Splita(READ(values + i));\n        pixel = (((a >> 4) & 0x8) |\n                 ((b >> 5) & 0x4) |\n                 ((g >> 6) & 0x2) |\n                 ((r >> 7)      ));\n        Store4(bits, i + x, pixel);\n    }\n}", "target": 0}
{"code": "ImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)\n{\n    UINT8 n;\n    UINT8* ptr;\n    if (strcmp(im->mode, \"1\") == 0 && state->xsize > state->bytes * 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    ptr = buf;\n    for (;;) {\n\tif (bytes < 1)\n\t    return ptr - buf;\n\tif ((*ptr & 0xC0) == 0xC0) {\n\t    if (bytes < 2)\n\t\treturn ptr - buf;\n\t    n = ptr[0] & 0x3F;\n\t    while (n > 0) {\n\t\tif (state->x >= state->bytes) {\n\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t    break;\n\t\t}\n\t\tstate->buffer[state->x++] = ptr[1];\n\t\tn--;\n\t    }\n\t    ptr += 2; bytes -= 2;\n\t} else {\n\t    state->buffer[state->x++] = ptr[0];\n\t    ptr++; bytes--;\n\t}\n\tif (state->x >= state->bytes) {\n        if (state->bytes % state->xsize && state->bytes > state->xsize) {\n            int bands = state->bytes / state->xsize;\n            int stride = state->bytes / bands;\n            int i;\n            for (i=1; i< bands; i++) {  \n                memmove(&state->buffer[i*state->xsize],\n                        &state->buffer[i*stride],\n                        state->xsize);\n            }\n        }\n\t    state->shuffle((UINT8*) im->image[state->y + state->yoff] +\n\t\t\t   state->xoff * im->pixelsize, state->buffer,\n\t\t\t   state->xsize);\n\t    state->x = 0;\n\t    if (++state->y >= state->ysize) {\n\t\treturn -1;\n\t    }\n\t}\n    }\n}", "target": 1}
{"code": "struct file *get_empty_filp(void)\n{\n\tconst struct cred *cred = current_cred();\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\tpercpu_counter_inc(&nr_files);\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free(f);\n\t\treturn ERR_PTR(error);\n\t}\n\tINIT_LIST_HEAD(&f->f_u.fu_list);\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\teventpoll_init_file(f);\n\treturn f;\nover:\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}", "target": 1}
{"code": "lsb_32 (guchar *src)\n{\n\treturn src[0] | (src[1] << 8) | (src[2] << 16) | (src[3] << 24);\n}", "target": 0}
{"code": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n \tkenter(\"%p{%u}\", user, uid);\n\tif (user->uid_keyring) {\n \t\tkleave(\" = 0 [exist]\");\n \t\treturn 0;\n \t}\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\tif (!user->uid_keyring) {\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "static void tipc_node_link_failover(struct tipc_node *n, struct tipc_link *l,\n\t\t\t\t    struct tipc_link *tnl,\n\t\t\t\t    struct sk_buff_head *xmitq)\n{\n\tif (!tipc_link_is_up(tnl))\n\t\treturn;\n\tif (l && !tipc_link_is_reset(l))\n\t\treturn;\n\ttipc_link_fsm_evt(tnl, LINK_SYNCH_END_EVT);\n\ttipc_node_fsm_evt(n, NODE_SYNCH_END_EVT);\n\tn->sync_point = tipc_link_rcv_nxt(tnl) + (U16_MAX / 2 - 1);\n\ttipc_link_failover_prepare(l, tnl, xmitq);\n\tif (l)\n\t\ttipc_link_fsm_evt(l, LINK_FAILOVER_BEGIN_EVT);\n\ttipc_node_fsm_evt(n, NODE_FAILOVER_BEGIN_EVT);\n}", "target": 0}
{"code": "  bool operator!=(const HeaderMap& rhs) const override { return HeaderMapImpl::operator!=(rhs); }", "target": 0}
{"code": "sshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}", "target": 1}
{"code": "compat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2_f(\"original KEX proposal: %s\", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\t}\n\tdebug2_f(\"compat KEX proposal: %s\", p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}", "target": 1}
{"code": "static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, *version_tlv, version, version_length;\n\tu8 *lto_tlv, lto_length;\n\tu8 *wks_tlv, wks_length;\n\tu8 *miux_tlv, miux_length;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tgb_len += version_length;\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tgb_len += lto_length;\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tgb_len += wks_length;\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tgb_len += miux_length;\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tgb_cur = local->gb;\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\tlocal->gb_len = gb_len;\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\treturn ret;\n}", "target": 1}
{"code": "  template<typename T>\n  inline CImg<_cimg_Tfloat> tanh(const CImg<T>& instance) {\n    return instance.get_tanh();", "target": 0}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "nfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n \tif (sfsname) {\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n \t\tspacep = strchr(temp, ' ');\n \t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}", "target": 1}
{"code": "static void opj_j2k_setup_decoding_tile (opj_j2k_t *p_j2k)\n{\n        assert(p_j2k != 00);\n        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_decode_one_tile);\n}", "target": 0}
{"code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n \tunsigned int cscov;\n \tconst char *msg;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n \tif (dh == NULL) {\n \t\tmsg = \"nf_ct_dccp: short packet \";\n \t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\treturn NF_ACCEPT;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}", "target": 1}
{"code": "int ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n \tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n \t(*lower_file) = dentry_open(&req.path, flags, cred);\n \tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n \tif ((flags & O_ACCMODE) == O_RDONLY) {\n \t\trc = PTR_ERR((*lower_file));\n \t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n \tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n \twake_up(&ecryptfs_kthread_ctl.wait);\n \twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n \t\trc = PTR_ERR(*lower_file);\n out:\n \treturn rc;\n }", "target": 1}
{"code": "static av_always_inline float flt16_even(float pf)\n{\n    union av_intfloat32 tmp;\n    tmp.f = pf;\n    tmp.i = (tmp.i + 0x00007FFFU + (tmp.i & 0x00010000U >> 16)) & 0xFFFF0000U;\n    return tmp.f;\n}", "target": 0}
{"code": "static locale_t AcquireCLocale(void)\n{\n#if defined(MAGICKCORE_HAVE_NEWLOCALE)\n  if (c_locale == (locale_t) NULL)\n    c_locale=newlocale(LC_ALL_MASK,\"C\",(locale_t) 0);\n#elif defined(MAGICKCORE_WINDOWS_SUPPORT) && !defined(__MINGW32__)\n  if (c_locale == (locale_t) NULL)\n    c_locale=_create_locale(LC_ALL,\"C\");\n#endif\n  return(c_locale);\n}", "target": 0}
{"code": "current_attribute (GMarkupParseContext *context)\n{\n  g_assert (context->cur_attr >= 0);\n  return context->attr_names[context->cur_attr]->str;\n}", "target": 0}
{"code": "static inline void skb_get_timestampns(const struct sk_buff *skb,\n\t\t\t\t       struct timespec *stamp)\n{\n\t*stamp = ktime_to_timespec(skb->tstamp);\n}", "target": 0}
{"code": "static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                return status;\n            }\n            else\n            {\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                return func(stream, iter->pos, pItem);\n            }\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}", "target": 1}
{"code": "static inline unsigned long node_nr_slabs(struct kmem_cache_node *n)\n\t\t\t\t\t\t\t{ return 0; }", "target": 0}
{"code": "  virtual INT64 size() { return streamsize; }", "target": 0}
{"code": "bool WebGraphicsContext3DDefaultImpl::supportsCopyTextureToParentTextureCHROMIUM()\n{\n    return false;\n}", "target": 0}
{"code": "find_reserved_job_in_conn(conn c, job j)\n{\n    return (j && j->reserver == c && j->state == JOB_STATE_RESERVED) ? j : NULL;\n}", "target": 0}
{"code": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\treturn data;\n}", "target": 1}
{"code": "    void Xmpdatum::setValue(const Value* pValue)\n    {\n        p_->value_.reset();\n        if (pValue) p_->value_ = pValue->clone();\n    }", "target": 0}
{"code": "void Item_param::set_int(longlong i, uint32 max_length_arg)\n{\n  DBUG_ENTER(\"Item_param::set_int\");\n  value.integer= (longlong) i;\n  state= INT_VALUE;\n  max_length= max_length_arg;\n  decimals= 0;\n  maybe_null= 0;\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "static char *r_socket_http_answer (RSocket *s, int *code, int *rlen) {\n\tr_return_val_if_fail (s, NULL);\n\tconst char *p;\n\tint ret, len = 0, bufsz = 32768, delta = 0;\n\tchar *dn, *buf = calloc (1, bufsz + 32); \n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tchar *res = NULL;\n\tint olen = __socket_slurp (s, (ut8*)buf, bufsz);\n\tif ((dn = (char*)r_str_casestr (buf, \"\\n\\n\"))) {\n\t\tdelta += 2;\n\t} else if ((dn = (char*)r_str_casestr (buf, \"\\r\\n\\r\\n\"))) {\n\t\tdelta += 4;\n\t} else {\n\t\tgoto fail;\n\t}\n\tolen -= delta;\n\t*dn = 0; \n\tp = r_str_casestr (buf, \"Content-Length: \");\n\tif (p) {\n\t\tlen = atoi (p + 16);\n\t} else {\n\t\tlen = olen - (dn - buf);\n\t}\n\tif (len > 0) {\n\t\tif (len > olen) {\n\t\t\tres = malloc (len + 2);\n\t\t\tmemcpy (res, dn + delta, olen);\n\t\t\tdo {\n\t\t\t\tret = r_socket_read_block (s, (ut8*) res + olen, len - olen);\n\t\t\t\tif (ret < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tolen += ret;\n\t\t\t} while (olen < len);\n\t\t\tres[len] = 0;\n\t\t} else {\n\t\t\tres = malloc (len + 1);\n\t\t\tif (res) {\n\t\t\t\tmemcpy (res, dn + delta, len);\n\t\t\t\tres[len] = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tres = NULL;\n\t}\nfail:\n\tfree (buf);\n\tr_socket_close (s);\n\tif (rlen) {\n\t\t*rlen = len;\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static void bluetooth_client_finalize(GObject *object)\n{\n\tBluetoothClient *client = BLUETOOTH_CLIENT (object);\n\tBluetoothClientPrivate *priv = BLUETOOTH_CLIENT_GET_PRIVATE (client);\n\tif (priv->cancellable != NULL) {\n\t\tg_cancellable_cancel (priv->cancellable);\n\t\tg_clear_object (&priv->cancellable);\n\t}\n\tg_clear_object (&priv->manager);\n\tg_object_unref (priv->store);\n\tg_clear_pointer (&priv->default_adapter, gtk_tree_row_reference_free);\n\tG_OBJECT_CLASS(bluetooth_client_parent_class)->finalize (object);\n}", "target": 0}
{"code": "njs_typed_array_get_u32(const void *a)\n{\n    return *(const uint32_t *) a;\n}", "target": 0}
{"code": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}", "target": 1}
{"code": "static void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; \n\tvmcs_write32(sf->ar_bytes, ar);\n}", "target": 0}
{"code": "RenderThreadImpl::RenderThreadImpl(const std::string& channel_name)\n    : ChildThread(Options(channel_name, ShouldUseMojoChannel())) {\n  Init();\n}", "target": 0}
{"code": "asmlinkage long sys_oabi_semop(int semid, struct oabi_sembuf __user *tsops,\n\t\t\t       unsigned nsops)\n{\n\treturn sys_oabi_semtimedop(semid, tsops, nsops, NULL);\n}", "target": 0}
{"code": "struct error_obj run_pam_auth(const char *username, char *password) {\n    struct pam_response *reply = malloc(sizeof(struct pam_response));\n    if (reply == NULL) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"malloc\";\n        ret_val.error_msg = \"Out of memory\";\n        return ret_val;\n    }\n    reply->resp = password;\n    reply->resp_retcode = 0;\n    const struct pam_conv local_conv = { conv_func, reply };\n    pam_handle_t *local_auth = NULL;\n    int status = pam_start(\"maddy\", username, &local_conv, &local_auth);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_start\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n    status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_authenticate\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n    status = pam_end(local_auth, status);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_end\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n    struct error_obj ret_val;\n    ret_val.status = 0;\n    ret_val.func_name = NULL;\n    ret_val.error_msg = NULL;\n    return ret_val;\n}", "target": 1}
{"code": "std::shared_ptr<SQLiteDBInstance> getTestDBC() {\n  auto dbc = SQLiteDBManager::getUnique();\n  char* err = nullptr;\n  std::vector<std::string> queries = {\n      \"CREATE TABLE test_table (username varchar(30) primary key, age int)\",\n      \"INSERT INTO test_table VALUES (\\\"mike\\\", 23)\",\n      \"INSERT INTO test_table VALUES (\\\"matt\\\", 24)\"};\n  for (auto q : queries) {\n    sqlite3_exec(dbc->db(), q.c_str(), nullptr, nullptr, &err);\n    if (err != nullptr) {\n      throw std::domain_error(std::string(\"Cannot create testing DBC's db: \") +\n                              err);\n    }\n  }\n  return dbc;\n}", "target": 1}
{"code": "static int hiddev_open(struct inode *inode, struct file *file)\n{\n\tstruct hiddev_list *list;\n\tstruct usb_interface *intf;\n\tstruct hid_device *hid;\n\tstruct hiddev *hiddev;\n\tint res;\n\tintf = usbhid_find_interface(iminor(inode));\n\tif (!intf)\n\t\treturn -ENODEV;\n\thid = usb_get_intfdata(intf);\n\thiddev = hid->hiddev;\n\tif (!(list = vzalloc(sizeof(struct hiddev_list))))\n\t\treturn -ENOMEM;\n\tmutex_init(&list->thread_lock);\n\tlist->hiddev = hiddev;\n\tfile->private_data = list;\n\tif (list->hiddev->exist) {\n\t\tif (!list->hiddev->open++) {\n\t\t\tres = hid_hw_open(hiddev->hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail;\n\t\t}\n\t} else {\n\t\tres = -ENODEV;\n\t\tgoto bail;\n\t}\n\tspin_lock_irq(&list->hiddev->list_lock);\n\tlist_add_tail(&list->node, &hiddev->list);\n\tspin_unlock_irq(&list->hiddev->list_lock);\n\tmutex_lock(&hiddev->existancelock);\n\tif (!list->hiddev->open++)\n\t\tif (list->hiddev->exist) {\n\t\t\tstruct hid_device *hid = hiddev->hid;\n\t\t\tres = hid_hw_power(hid, PM_HINT_FULLON);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_unlock;\n\t\t\tres = hid_hw_open(hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_normal_power;\n\t\t}\n\tmutex_unlock(&hiddev->existancelock);\n\treturn 0;\nbail_normal_power:\n\thid_hw_power(hid, PM_HINT_NORMAL);\nbail_unlock:\n\tmutex_unlock(&hiddev->existancelock);\nbail:\n\tfile->private_data = NULL;\n\tvfree(list);\n\treturn res;\n}", "target": 1}
{"code": "static inline s16 fixp_mult(s16 a, s16 b)\n{\n\ta = ((s32)a * 0x100) / 0x7fff;\n\treturn ((s32)(a * b)) >> FRAC_N;\n}", "target": 0}
{"code": "static inline bool early_page_uninitialised(unsigned long pfn)\n{\n\treturn false;\n}", "target": 0}
{"code": "datetime_s_jisx0301(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    if (!NIL_P(opt)) argc--;\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01T00:00:00+00:00\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        argv2[1] = opt;\n        if (!NIL_P(opt)) argc2++;\n\tVALUE hash = date_s__jisx0301(argc2, argv2, klass);\n\treturn dt_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "int InlineFlowBox::getFlowSpacingLogicalWidth()\n{\n    int totWidth = marginBorderPaddingLogicalLeft() + marginBorderPaddingLogicalRight();\n    for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {\n        if (curr->isInlineFlowBox())\n            totWidth += static_cast<InlineFlowBox*>(curr)->getFlowSpacingLogicalWidth();\n    }\n    return totWidth;\n}", "target": 0}
{"code": "void WebContentsImpl::SetIsCrashed(base::TerminationStatus status,\n                                   int error_code) {\n  if (status == crashed_status_)\n    return;\n  crashed_status_ = status;\n  crashed_error_code_ = error_code;\n  NotifyNavigationStateChanged(INVALIDATE_TYPE_TAB);\n}", "target": 0}
{"code": "static char *oidc_cache_get_hashed_key(request_rec *r, const char *passphrase,\n\t\tconst char *key) {\n\tchar *input = apr_psprintf(r->pool, \"%s:%s\", passphrase, key);\n\tchar *output = NULL;\n\tif (oidc_util_hash_string_and_base64url_encode(r, OIDC_JOSE_ALG_SHA256,\n\t\t\tinput, &output) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\treturn NULL;\n\t}\n\treturn output;\n}", "target": 1}
{"code": "        EDP* getEDP() { return &edp_; }", "target": 1}
{"code": "static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"blkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_blkcipher.geniv ?: \"<default>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "SPL_METHOD(Array, setFlags)\n{\n\tzval *object = getThis();\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tlong ar_flags = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &ar_flags) == FAILURE) {\n\t\treturn;\n\t}\n\tintern->ar_flags = (intern->ar_flags & SPL_ARRAY_INT_MASK) | (ar_flags & ~SPL_ARRAY_INT_MASK);\n}", "target": 0}
{"code": "std::map<string, AttrValue> GetSetAttrs(const FunctionDef& fdef) {\n  std::map<string, AttrValue> set_attrs;\n  for (const auto& pair : fdef.attr()) {\n    if (pair.second.value_case() != AttrValue::VALUE_NOT_SET) {\n      set_attrs[pair.first] = pair.second;\n    }\n  }\n  return set_attrs;\n}", "target": 0}
{"code": "static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct kernel_lb_addr location = UDF_I(inode)->i_location;\n\tstruct fid *fid = (struct fid *)fh;\n\tint type = FILEID_UDF_WITHOUT_PARENT;\n\tif (parent && (len < 5)) {\n\t\t*lenp = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*lenp = 3;\n\t\treturn 255;\n\t}\n \t*lenp = 3;\n \tfid->udf.block = location.logicalBlockNum;\n \tfid->udf.partref = location.partitionReferenceNum;\n \tfid->udf.generation = inode->i_generation;\n \tif (parent) {\n\t\tlocation = UDF_I(parent)->i_location;\n\t\tfid->udf.parent_block = location.logicalBlockNum;\n\t\tfid->udf.parent_partref = location.partitionReferenceNum;\n\t\tfid->udf.parent_generation = inode->i_generation;\n\t\t*lenp = 5;\n\t\ttype = FILEID_UDF_WITH_PARENT;\n\t}\n\treturn type;\n}", "target": 1}
{"code": "  TestHeaderMapImplBase(const HeaderMap& rhs) {\n    HeaderMapImpl::copyFrom(*header_map_, rhs);\n    header_map_->verifyByteSizeInternalForTest();\n  }", "target": 0}
{"code": "void PDFiumEngine::Form_OnChange(FPDF_FORMFILLINFO* param) {\n}", "target": 0}
{"code": "bool IsConvolutionOpSupported(const TfLiteRegistration* registration,\n                              const TfLiteNode* node, TfLiteContext* context) {\n  if (node->builtin_data == nullptr) return false;\n  TfLiteFusedActivation activation;\n  if (registration->builtin_code == kTfLiteBuiltinConv2d) {\n    const auto* conv_params =\n        reinterpret_cast<const TfLiteConvParams*>(node->builtin_data);\n    activation = conv_params->activation;\n  } else if (registration->builtin_code == kTfLiteBuiltinDepthwiseConv2d) {\n    const auto* depthwise_conv_params =\n        reinterpret_cast<const TfLiteDepthwiseConvParams*>(node->builtin_data);\n    activation = depthwise_conv_params->activation;\n  } else if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    activation = kTfLiteActNone;\n  } else {\n    TF_LITE_KERNEL_LOG(\n        context,\n        \"Invalid op: op must be Conv2D, DepthwiseConv2D or TransposeConv.\");\n    return false;\n  }\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n  const int kOutputShapeTensor = 0;  \n  const int kWeightTensor = 1;\n  const int kBiasTensor = 2;  \n  const TfLiteTensor* weights = GetInput(context, node, kWeightTensor);\n  const int max_kernel_size = 16384;\n  if (!IsConstantTensor(weights)) {\n    return false;\n  }\n  if (weights->dims->data[1] > max_kernel_size ||\n      weights->dims->data[2] > max_kernel_size) {\n    return false;\n  }\n  if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    if (!IsConstantTensor(GetInput(context, node, kOutputShapeTensor))) {\n      return false;\n    }\n  } else {\n    if (node->inputs->size >= kBiasTensor &&\n        !IsConstantTensor(GetInput(context, node, kBiasTensor))) {\n      return false;\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n  idata->state = IMAP_CONNECTED;\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n  return 0;\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}", "target": 1}
{"code": "escape_attach (int argc, char **argv, compose_env_t *env)\n{\n  const char *encoding = default_encoding;\n  const char *content_type = default_content_type;\n  switch (argc)\n    {\n    case 4:\n      encoding = argv[3];\n    case 3:\n      content_type = argv[2];\n    case 2:\n      return attlist_attach_file (&env->attlist,\n\t\t\t\t  -1, argv[1], argv[1], argv[1],\n\t\t\t\t  content_type, encoding);\n    default:\n      return escape_check_args (argc, argv, 2, 4);\n    }\n  return 1;\n}", "target": 0}
{"code": "htmlParseComment(htmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    int len;\n    int size = HTML_PARSER_BUFFER_SIZE;\n    int q, ql;\n    int r, rl;\n    int cur, l;\n    xmlParserInputState state;\n    if ((RAW != '<') || (NXT(1) != '!') ||\n        (NXT(2) != '-') || (NXT(3) != '-')) return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    SHRINK;\n    SKIP(4);\n    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n    if (buf == NULL) {\n        htmlErrMemory(ctxt, \"buffer allocation failed\\n\");\n\tctxt->instate = state;\n\treturn;\n    }\n    q = CUR_CHAR(ql);\n    NEXTL(ql);\n    r = CUR_CHAR(rl);\n    NEXTL(rl);\n    cur = CUR_CHAR(l);\n    len = 0;\n    while (IS_CHAR(cur) &&\n           ((cur != '>') ||\n\t    (r != '-') || (q != '-'))) {\n\tif (len + 5 >= size) {\n\t    xmlChar *tmp;\n\t    size *= 2;\n\t    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n\t    if (tmp == NULL) {\n\t        xmlFree(buf);\n\t        htmlErrMemory(ctxt, \"growing buffer failed\\n\");\n\t\tctxt->instate = state;\n\t\treturn;\n\t    }\n\t    buf = tmp;\n\t}\n\tCOPY_BUF(ql,buf,len,q);\n\tq = r;\n\tql = rl;\n\tr = cur;\n\trl = l;\n\tNEXTL(l);\n\tcur = CUR_CHAR(l);\n\tif (cur == 0) {\n\t    SHRINK;\n\t    GROW;\n\t    cur = CUR_CHAR(l);\n\t}\n    }\n    buf[len] = 0;\n    if (!IS_CHAR(cur)) {\n\thtmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t             \"Comment not terminated \\n<!--%.50s\\n\", buf, NULL);\n\txmlFree(buf);\n    } else {\n        NEXT;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->comment(ctxt->userData, buf);\n\txmlFree(buf);\n    }\n    ctxt->instate = state;\n}", "target": 1}
{"code": "void * pvPortMalloc( size_t xWantedSize )\n{\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\n    static BaseType_t xHeapHasBeenInitialised = pdFALSE;\n    void * pvReturn = NULL;\n    vTaskSuspendAll();\n    {\n        if( xHeapHasBeenInitialised == pdFALSE )\n        {\n            prvHeapInit();\n            xHeapHasBeenInitialised = pdTRUE;\n        }\n        if( xWantedSize > 0 )\n        {\n            xWantedSize += heapSTRUCT_SIZE;\n            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )\n            {\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n            }\n        }\n        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )\n        {\n            pxPreviousBlock = &xStart;\n            pxBlock = xStart.pxNextFreeBlock;\n            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n            {\n                pxPreviousBlock = pxBlock;\n                pxBlock = pxBlock->pxNextFreeBlock;\n            }\n            if( pxBlock != &xEnd )\n            {\n                pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\n                pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n                if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n                {\n                    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n                    pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n                    pxBlock->xBlockSize = xWantedSize;\n                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\n                }\n                xFreeBytesRemaining -= pxBlock->xBlockSize;\n            }\n        }\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n    return pvReturn;\n}", "target": 1}
{"code": "vrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}", "target": 1}
{"code": "MagickPrivate size_t GetOptimalKernelWidth2D(const double radius,\n  const double sigma)\n{\n  double\n    alpha,\n    beta,\n    gamma,\n    normalize,\n    value;\n  size_t\n    width;\n  ssize_t\n    j,\n    u,\n    v;\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (radius > MagickEpsilon)\n    return((size_t) (2.0*ceil(radius)+1.0));\n  gamma=fabs(sigma);\n  if (gamma <= MagickEpsilon)\n    return(3UL);\n  alpha=PerceptibleReciprocal(2.0*gamma*gamma);\n  beta=(double) PerceptibleReciprocal((double) Magick2PI*gamma*gamma);\n  for (width=5; ; )\n  {\n    normalize=0.0;\n    j=(ssize_t) (width-1)/2;\n    for (v=(-j); v <= j; v++)\n      for (u=(-j); u <= j; u++)\n        normalize+=exp(-((double) (u*u+v*v))*alpha)*beta;\n    value=exp(-((double) (j*j))*alpha)*beta/normalize;\n    if ((value < QuantumScale) || (value < MagickEpsilon))\n      break;\n    width+=2;\n  }\n  return((size_t) (width-2));\n}", "target": 0}
{"code": "LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem& value) {\n  LIR_Opr result = new_register(type);\n  value.load_item();\n  __ move(value.result(), result);\n  assert(type == T_INT LP64_ONLY( || type == T_LONG ), \"unexpected type\");\n  __ xadd(addr, result, result, LIR_OprFact::illegalOpr);\n  return result;\n}", "target": 0}
{"code": "BufCompressedFill (BufFilePtr f)\n{\n    CompressedFile  *file;\n    register char_type *stackp, *de_stack;\n    register char_type finchar;\n    register code_int code, oldcode, incode;\n    BufChar\t    *buf, *bufend;\n    file = (CompressedFile *) f->private;\n    buf = f->buffer;\n    bufend = buf + BUFFILESIZE;\n    stackp = file->stackp;\n    de_stack = file->de_stack;\n    finchar = file->finchar;\n    oldcode = file->oldcode;\n    while (buf < bufend) {\n\twhile (stackp > de_stack && buf < bufend)\n\t    *buf++ = *--stackp;\n\tif (buf == bufend)\n\t    break;\n\tif (oldcode == -1)\n\t    break;\n\tcode = getcode (file);\n\tif (code == -1)\n\t    break;\n    \tif ( (code == CLEAR) && file->block_compress ) {\n\t    for ( code = 255; code >= 0; code-- )\n\t    \tfile->tab_prefix[code] = 0;\n\t    file->clear_flg = 1;\n\t    file->free_ent = FIRST - 1;\n\t    if ( (code = getcode (file)) == -1 )\t\n\t    \tbreak;\n    \t}\n    \tincode = code;\n    \tif ( code >= file->free_ent ) {\n\t    *stackp++ = finchar;\n\t    code = oldcode;\n    \t}\n     \twhile ( code >= 256 )\n     \t{\n \t    *stackp++ = file->tab_suffix[code];\n \t    code = file->tab_prefix[code];\n     \t}\n    \tif ( (code=file->free_ent) < file->maxmaxcode ) {\n\t    file->tab_prefix[code] = (unsigned short)oldcode;\n\t    file->tab_suffix[code] = finchar;\n\t    file->free_ent = code+1;\n    \t} \n\toldcode = incode;\n    }\n    file->oldcode = oldcode;\n    file->stackp = stackp;\n    file->finchar = finchar;\n    if (buf == f->buffer) {\n\tf->left = 0;\n\treturn BUFFILEEOF;\n    }\n    f->bufp = f->buffer + 1;\n    f->left = (buf - f->buffer) - 1;\n    return f->buffer[0];\n}", "target": 1}
{"code": "static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n \t\treturn ret;\n \t}\n \tread_lock(&tasklist_lock);\n \tif (pid != -1) {\n \t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}", "target": 1}
{"code": "static bool anal_fcn_data (RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "  explicit StartupWatchDogThread(const base::TimeDelta& duration)\n      : base::Watchdog(duration, \"Startup watchdog thread\", true) {\n  }", "target": 0}
{"code": "void GLES2DecoderTestBase::DoCreateShader(\n    GLenum shader_type, GLuint client_id, GLuint service_id) {\n  EXPECT_CALL(*gl_, CreateShader(shader_type))\n      .Times(1)\n      .WillOnce(Return(service_id))\n      .RetiresOnSaturation();\n  CreateShader cmd;\n  cmd.Init(shader_type, client_id);\n  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));\n}", "target": 0}
{"code": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tint groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex < 2) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\treturn 1;\nfailed:\n\treturn 0;\n}", "target": 1}
{"code": "  int get_request_payment_payer(bool *requester_pays) {\n    XMLObj *config = find_first(\"RequestPaymentConfiguration\");\n    if (!config)\n      return -EINVAL;\n    *requester_pays = false;\n    XMLObj *field = config->find_first(\"Payer\");\n    if (!field)\n      return 0;\n    string& s = field->get_data();\n    if (stringcasecmp(s, \"Requester\") == 0) {\n      *requester_pays = true;\n    } else if (stringcasecmp(s, \"BucketOwner\") != 0) {\n      return -EINVAL;\n    }\n    return 0;\n  }", "target": 0}
{"code": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static void send(node_t *node, node_t *child, byte *fout) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout);\n\t}\n\tif (child) {\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static string _get_persist_file()\n{\n    return Options.filename + \".persist\";\n}", "target": 0}
{"code": "    **/\n    CImgList<Tfloat> get_FFT(const char axis, const bool is_invert=false) const {\n      CImgList<Tfloat> res(*this,CImg<Tfloat>());\n      CImg<Tfloat>::FFT(res[0],res[1],axis,is_invert);\n      return res;", "target": 0}
{"code": "void SSH2_update_kex_myproposal(PTInstVar pvar)\n{\n\tstatic char buf[512]; \n\tint index;\n\tint i;\n\tif (pvar->socket != INVALID_SOCKET) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c\");\n\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c\") == 0) {\n\t\t\t\tmyproposal[PROPOSAL_KEX_ALGS][pos] = '\\0';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tbuf[0] = '\\0';\n\tfor (i = 0 ; pvar->settings.KexOrder[i] != 0 ; i++) {\n\t\tindex = pvar->settings.KexOrder[i] - '0';\n\t\tif (index == KEX_DH_NONE) \n\t\t\tbreak;\n\t\tstrncat_s(buf, sizeof(buf), get_kex_algorithm_name(index), _TRUNCATE);\n\t\tstrncat_s(buf, sizeof(buf), \",\", _TRUNCATE);\n\t}\n\tstrncat_s(buf, sizeof(buf), \"ext-info-c\", _TRUNCATE);\n\tmyproposal[PROPOSAL_KEX_ALGS] = buf; \n}", "target": 1}
{"code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\tR_FREE (prelink_range);\n\t*bin_obj = obj;\n\tr_list_push (pending_bin_files, bf);\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\treturn true;\nbeach:\n\tr_buf_free (fbuf);\n\tobj->cache_buf = NULL;\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}", "target": 1}
{"code": "static inline void CoefficientsToAffineArgs(double *coeff)\n{\n  double tmp[4];  \n  tmp[0]=coeff[3]; tmp[1]=coeff[1]; tmp[2]=coeff[4]; tmp[3]=coeff[2];\n  coeff[1]=tmp[0]; coeff[2]=tmp[1]; coeff[3]=tmp[2]; coeff[4]=tmp[3];\n}", "target": 0}
{"code": "    std::string Exifdatum::tagLabel() const\n    {\n        return key_.get() == 0 ? \"\" : key_->tagLabel();\n    }", "target": 0}
{"code": "char *VDir::MapPathA(const char *pInName)\n{   \n    char szBuffer[(MAX_PATH+1)*2];\n    char szlBuf[MAX_PATH+1];\n    int length = strlen(pInName);\n    if (!length)\n\treturn (char*)pInName;\n    if (length > MAX_PATH) {\n\tstrncpy(szlBuf, pInName, MAX_PATH);\n\tif (IsPathSep(pInName[0]) && !IsPathSep(pInName[1])) {   \n\t    szlBuf[MAX_PATH-2] = '\\0';\n\t}\n\telse\n\t    szlBuf[MAX_PATH] = '\\0';\n\tpInName = szlBuf;\n    }\n    if (pInName[1] == ':') {\n\tif (IsPathSep(pInName[2])) {\n\t    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n\telse {\n\t    strcpy(szBuffer, GetDirA(DriveIndex(*pInName)));\n\t    strcat(szBuffer, &pInName[2]);\n\t    if(strlen(szBuffer) > MAX_PATH)\n\t\tszBuffer[MAX_PATH] = '\\0';\n\t    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n    }\n    else {\n\tif (IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {\n\t    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n\telse {\n\t    strcpy(szBuffer, GetDefaultDirA());\n\t    if (IsPathSep(pInName[0])) {\n\t\tstrcpy(&szBuffer[2], pInName);\n\t\tDoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n\t    }\n\t    else {\n\t\tif (IsSpecialFileName(pInName)) {\n\t\t    return (char*)pInName;\n\t\t}\n\t\telse {\n\t\t    strcat(szBuffer, pInName);\n\t\t    if (strlen(szBuffer) > MAX_PATH)\n\t\t\tszBuffer[MAX_PATH] = '\\0';\n\t\t    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n\t\t}\n\t    }\n\t}\n    }\n    return szLocalBufferA;\n}", "target": 1}
{"code": "void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n \t\treturn;\n \ttimer = &pit->pit_state.timer;\n \tif (hrtimer_cancel(timer))\n \t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n }", "target": 1}
{"code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\tsalsa20_ivsetup(ctx, walk.iv);\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "void LibRaw::layer_thumb(){}", "target": 0}
{"code": "TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input,\n                    const TfLiteTensor* positions, TfLiteTensor* output) {\n  tflite::GatherParams op_params;\n  op_params.axis = params.axis;\n  op_params.batch_dims = params.batch_dims;\n  optimized_ops::Gather(op_params, GetTensorShape(input),\n                        GetTensorData<InputT>(input), GetTensorShape(positions),\n                        GetTensorData<PositionsT>(positions),\n                        GetTensorShape(output), GetTensorData<InputT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "jmethodID InstanceKlass::get_jmethod_id_fetch_or_update(\n            size_t idnum, jmethodID new_id,\n            jmethodID* new_jmeths, jmethodID* to_dealloc_id_p,\n            jmethodID** to_dealloc_jmeths_p) {\n  assert(new_id != NULL, \"sanity check\");\n  assert(to_dealloc_id_p != NULL, \"sanity check\");\n  assert(to_dealloc_jmeths_p != NULL, \"sanity check\");\n  assert(Threads::number_of_threads() == 0 ||\n         SafepointSynchronize::is_at_safepoint() ||\n         JmethodIdCreation_lock->owned_by_self(), \"sanity check\");\n  jmethodID* jmeths = methods_jmethod_ids_acquire();\n  jmethodID  id     = NULL;\n  size_t     length = 0;\n  if (jmeths == NULL ||                         \n      (length = (size_t)jmeths[0]) <= idnum) {  \n    if (jmeths != NULL) {\n      for (size_t index = 0; index < length; index++) {\n        new_jmeths[index+1] = jmeths[index+1];\n      }\n      *to_dealloc_jmeths_p = jmeths;  \n    }\n    release_set_methods_jmethod_ids(jmeths = new_jmeths);\n  } else {\n    id = jmeths[idnum+1];\n    *to_dealloc_jmeths_p = new_jmeths;  \n  }\n  if (id == NULL) {\n    id = new_id;\n    OrderAccess::release_store(&jmeths[idnum+1], id);\n  } else {\n    *to_dealloc_id_p = new_id; \n  }\n  return id;\n}", "target": 0}
{"code": "const std::string& GetExtensionIdForMutedTab(content::WebContents* contents) {\n  DCHECK_EQ(GetTabAudioMutedReason(contents) != TabMutedReason::EXTENSION,\n            LastMuteMetadata::FromWebContents(contents)->extension_id.empty());\n  return LastMuteMetadata::FromWebContents(contents)->extension_id;\n}", "target": 0}
{"code": "bool ServerSecurityFeature::foxxAllowInstallFromRemote() const {\n  return _foxxAllowInstallFromRemote;\n}", "target": 0}
{"code": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "bool AES_GCM_EncryptContext::Encrypt(\n\tconst void *pPlaintextData, size_t cbPlaintextData,\n\tconst void *pIV,\n\tvoid *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;\n    crypto_aead_aes256gcm_encrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,\n\t\tstatic_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,\n\t\tstatic_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pIV ),\n\t\tstatic_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;\n    return true;\n}", "target": 1}
{"code": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!ax)\n\t\treturn;\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\tnetif_stop_queue(ax->dev);\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\tax->tty = NULL;\n\tunregister_netdev(ax->dev);\n\tfree_netdev(ax->dev);\n}", "target": 1}
{"code": "_asn1_cpy_name (asn1_node dst, asn1_node src)\n{\n  if (dst == NULL)\n    return dst;\n  if (src == NULL)\n    {\n      dst->name[0] = 0;\n      dst->name_hash = hash_pjw_bare (dst->name, 0);\n      return dst;\n    }\n  _asn1_str_cpy (dst->name, sizeof (dst->name), src->name);\n  dst->name_hash = src->name_hash;\n  return dst;\n}", "target": 0}
{"code": "kvm_pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,\n\t\t      bool *writable)\n{\n\treturn __gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn, false, NULL,\n\t\t\t\t    write_fault, writable);\n}", "target": 0}
{"code": "HIDDEN void *zstd_init()\n{\n    ZSTD_CCtx *cctx = ZSTD_createCCtx();\n    if (cctx) {\n        ZSTD_CCtx_setParameter(cctx, ZSTD_c_compressionLevel,\n                               ZSTD_CLEVEL_DEFAULT);\n        ZSTD_CCtx_setParameter(cctx, ZSTD_c_checksumFlag, 1);\n    }\n    return cctx;\n}", "target": 0}
{"code": "GURL URLFixerUpper::FixupRelativeFile(const FilePath& base_dir,\n                                      const FilePath& text) {\n  FilePath old_cur_directory;\n  if (!base_dir.empty()) {\n    file_util::GetCurrentDirectory(&old_cur_directory);\n    file_util::SetCurrentDirectory(base_dir);\n  }\n  FilePath::StringType trimmed;\n   PrepareStringForFileOps(text, &trimmed);\n   bool is_file = true;\n   FilePath full_path;\n  if (!ValidPathForFile(trimmed, &full_path)) {\n#if defined(OS_WIN)\n    std::wstring unescaped = UTF8ToWide(UnescapeURLComponent(\n        WideToUTF8(trimmed),\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS));\n#elif defined(OS_POSIX)\n    std::string unescaped = UnescapeURLComponent(\n        trimmed,\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);\n#endif\n    if (!ValidPathForFile(unescaped, &full_path))\n      is_file = false;\n  }\n  if (!base_dir.empty())\n    file_util::SetCurrentDirectory(old_cur_directory);\n  if (is_file) {\n    GURL file_url = net::FilePathToFileURL(full_path);\n    if (file_url.is_valid())\n      return GURL(UTF16ToUTF8(net::FormatUrl(file_url, std::string(),\n          net::kFormatUrlOmitUsernamePassword, UnescapeRule::NORMAL, NULL,\n          NULL, NULL)));\n  }\n#if defined(OS_WIN)\n  std::string text_utf8 = WideToUTF8(text.value());\n#elif defined(OS_POSIX)\n  std::string text_utf8 = text.value();\n#endif\n  return FixupURL(text_utf8, std::string());\n}", "target": 1}
{"code": "static int avrcp_init(void)\n{\n\tbtd_profile_register(&avrcp_controller_profile);\n\tbtd_profile_register(&avrcp_target_profile);\n\tpopulate_default_features();\n\treturn 0;\n}", "target": 0}
{"code": "void PDFiumEngine::Form_DoGoToAction(FPDF_FORMFILLINFO* param,\n                                     int page_index,\n                                     int zoom_mode,\n                                     float* position_array,\n                                     int size_of_array) {\n  PDFiumEngine* engine = static_cast<PDFiumEngine*>(param);\n  engine->ScrollToPage(page_index);\n}", "target": 0}
{"code": "static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int i, v, offset, count, segments;\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 2;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count*2 + width)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < count; i++) {\n                frame[0] = frame[1] =\n                frame[width] = frame[width + 1] = frame[-offset];\n                frame += 2;\n            }\n        } else if (bitbuf & (mask << 1)) {\n            v = bytestream2_get_le16(gb)*2;\n            if (frame - frame_end < v)\n                return AVERROR_INVALIDDATA;\n            frame += v;\n        } else {\n            if (frame_end - frame < width + 3)\n                return AVERROR_INVALIDDATA;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n        }\n        mask <<= 2;\n    }\n    return 0;\n}", "target": 1}
{"code": "  QuotaManager* quota_manager() const { return quota_manager_.get(); }", "target": 0}
{"code": "PassRefPtr<SerializedScriptValue> SerializedScriptValue::nullValue()\n{\n    SerializedScriptValueWriter writer;\n    writer.writeNull();\n    String wireData = writer.takeWireString();\n    return adoptRef(new SerializedScriptValue(wireData));\n}", "target": 0}
{"code": "static void date_period_it_invalidate_current(zend_object_iterator *iter TSRMLS_DC)\n{\n\tdate_period_it *iterator = (date_period_it *)iter;\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}", "target": 0}
{"code": "ciKlass* ciEnv::get_klass_by_index(const constantPoolHandle& cpool,\n                                   int index,\n                                   bool& is_accessible,\n                                   ciInstanceKlass* accessor) {\n  GUARDED_VM_ENTRY(return get_klass_by_index_impl(cpool, index, is_accessible, accessor);)\n}", "target": 0}
{"code": "pfkey_proto2satype(uint16_t proto)\n{\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\t\treturn SADB_SATYPE_AH;\n\tcase IPPROTO_ESP:\n\t\treturn SADB_SATYPE_ESP;\n\tcase IPPROTO_COMP:\n\t\treturn SADB_X_SATYPE_IPCOMP;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "TIFFjpeg_start_compress(JPEGState* sp, boolean write_all_tables)\n{\n\treturn CALLVJPEG(sp,\n\t    jpeg_start_compress(&sp->cinfo.c, write_all_tables));\n}", "target": 0}
{"code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n\t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\tskcipher->setkey = alg->setkey;\n\tskcipher->encrypt = alg->encrypt;\n\tskcipher->decrypt = alg->decrypt;\n\tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\treturn 0;\n}", "target": 1}
{"code": "static MagickBooleanType WriteAnimatedWEBPImage(const ImageInfo *image_info,\n  Image *image,WebPConfig *configure,WebPMemoryWriter *writer_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *first_image;\n  PictureMemory\n    *current,\n    *head;\n  size_t\n    effective_delta = 0,\n    frame_timestamp = 0;\n  WebPAnimEncoder\n    *enc;\n  WebPAnimEncoderOptions\n    enc_options;\n  WebPData\n    webp_data;\n  WebPPicture\n    picture;\n  WebPAnimEncoderOptionsInit(&enc_options);\n  if (image_info->verbose)\n    enc_options.verbose = 1;\n  image=CoalesceImages(image, exception);\n  first_image=image;\n  enc=WebPAnimEncoderNew((int) image->page.width,(int) image->page.height,\n    &enc_options);\n  head=(PictureMemory *) calloc(sizeof(*head),1);\n  current=head;\n  while (image != NULL)\n  {\n    if (WebPPictureInit(&picture) == 0)\n      ThrowWriterException(ResourceLimitError,\"UnableToEncodeImageFile\");\n    WriteSingleWEBPImage(image_info, image, &picture, current, exception);\n    effective_delta = image->delay*1000/image->ticks_per_second;\n    if (effective_delta < 10)\n      effective_delta = 100; \n    frame_timestamp+=effective_delta;\n    WebPAnimEncoderAdd(enc,&picture,(int) frame_timestamp,configure);\n    image = GetNextImageInList(image);\n    current->next=(PictureMemory *) calloc(sizeof(*head), 1);\n    current = current->next;\n  }\n  webp_data.bytes=writer_info->mem;\n  webp_data.size=writer_info->size;\n  WebPAnimEncoderAssemble(enc, &webp_data);\n  WebPMemoryWriterClear(writer_info);\n  writer_info->size=webp_data.size;\n  writer_info->mem=(unsigned char *) webp_data.bytes;\n  WebPAnimEncoderDelete(enc);\n  DestroyImageList(first_image);\n  FreePictureMemoryList(head);\n  return(MagickTrue);\n}", "target": 1}
{"code": "static u_int mp_dss_len(const  struct mp_dss *m, int csum)\n{\n        u_int len;\n        len = 4;\n        if (m->flags & MP_DSS_A) {\n                len += (m->flags & MP_DSS_a) ? 8 : 4;\n        }\n        if (m->flags & MP_DSS_M) {\n                len += (m->flags & MP_DSS_m) ? 14 : 10;\n                if (csum)\n                        len += 2;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "bool AccessibilityUIElement::isSelected() const\n{\n    return checkElementState(m_element, ATK_STATE_SELECTED);\n}", "target": 0}
{"code": "void Shell::OnAppTerminating() {\n  FOR_EACH_OBSERVER(ShellObserver, observers_, OnAppTerminating());\n}", "target": 0}
{"code": "load_debug_section_with_follow (enum dwarf_section_display_enum sec_enum,\n\t\t\t\tvoid * handle)\n{\n  if (load_debug_section (sec_enum, handle))\n    {\n      if (debug_displays[sec_enum].section.filename == NULL)\n\t{\n\t  separate_info * i;\n\t  for (i = first_separate_info; i != NULL; i = i->next)\n\t    if (i->handle == handle)\n\t      {\n\t\tdebug_displays[sec_enum].section.filename = i->filename;\n\t\tbreak;\n\t      }\n\t}\n      return true;\n    }\n  if (do_follow_links)\n    {\n      separate_info * i;\n      for (i = first_separate_info; i != NULL; i = i->next)\n\t{\n\t  if (load_debug_section (sec_enum, i->handle))\n\t    {\n\t      debug_displays[sec_enum].section.filename = i->filename;\n\t      return true;\n\t    }\n\t}\n    }\n  return false;\n}", "target": 0}
{"code": "void CredentialManagerImpl::OnProvisionalSaveComplete() {\n  DCHECK(form_manager_);\n  DCHECK(client_->IsSavingAndFillingEnabledForCurrentPage());\n  const autofill::PasswordForm& form = form_manager_->pending_credentials();\n  if (form_manager_->IsPendingCredentialsPublicSuffixMatch()) {\n    form_manager_->Save();\n    return;\n  }\n  if (!form.federation_origin.unique()) {\n    for (auto* match : form_manager_->form_fetcher()->GetFederatedMatches()) {\n      if (match->username_value == form.username_value &&\n          match->federation_origin.IsSameOriginWith(form.federation_origin)) {\n        form_manager_->Update(*match);\n        return;\n      }\n    }\n  } else if (!form_manager_->IsNewLogin()) {\n    form_manager_->Update(*form_manager_->preferred_match());\n     return;\n   }\n  client_->PromptUserToSaveOrUpdatePassword(std::move(form_manager_), false);\n}", "target": 1}
{"code": "int bnx2x_set_int_mode(struct bnx2x *bp)\n{\n\tint rc = 0;\n\tif (IS_VF(bp) && int_mode != BNX2X_INT_MODE_MSIX) {\n\t\tBNX2X_ERR(\"VF not loaded since interrupt mode not msix\\n\");\n\t\treturn -EINVAL;\n\t}\n\tswitch (int_mode) {\n\tcase BNX2X_INT_MODE_MSIX:\n\t\trc = bnx2x_enable_msix(bp);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t\tif (rc && IS_VF(bp))\n\t\t\treturn rc;\n\t\tBNX2X_DEV_INFO(\"Failed to enable multiple MSI-X (%d), set number of queues to %d\\n\",\n\t\t\t       bp->num_queues,\n\t\t\t       1 + bp->num_cnic_queues);\n\tcase BNX2X_INT_MODE_MSI:\n\t\tbnx2x_enable_msi(bp);\n\tcase BNX2X_INT_MODE_INTX:\n\t\tbp->num_ethernet_queues = 1;\n\t\tbp->num_queues = bp->num_ethernet_queues + bp->num_cnic_queues;\n\t\tBNX2X_DEV_INFO(\"set number of queues to 1\\n\");\n\t\tbreak;\n\tdefault:\n\t\tBNX2X_DEV_INFO(\"unknown value in int_mode module parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void OneHotComputeImpl(const OneHotContext& op_context) {\n  int prefix_dim_size = 1;\n  for (int i = 0; i < op_context.axis; ++i) {\n    prefix_dim_size *= op_context.indices->dims->data[i];\n  }\n  const int suffix_dim_size = NumElements(op_context.indices) / prefix_dim_size;\n  const int depth = *op_context.depth->data.i32;\n  const T on_value = *GetTensorData<T>(op_context.on_value);\n  const T off_value = *GetTensorData<T>(op_context.off_value);\n  T* output = GetTensorData<T>(op_context.output);\n  const TI* indices = GetTensorData<TI>(op_context.indices);\n  for (int i = 0; i < prefix_dim_size; ++i) {\n    for (int j = 0; j < depth; ++j) {\n      for (int k = 0; k < suffix_dim_size; ++k, ++output) {\n        *output = static_cast<int>(indices[i * suffix_dim_size + k]) == j\n                      ? on_value\n                      : off_value;\n      }\n    }\n  }\n}", "target": 1}
{"code": "void GLES2DecoderTestBase::DoVertexAttribPointer(\n    GLuint index, GLint size, GLenum type, GLsizei stride, GLuint offset) {\n  EXPECT_CALL(*gl_,\n              VertexAttribPointer(index, size, type, GL_FALSE, stride,\n                                  BufferOffset(offset)))\n      .Times(1)\n      .RetiresOnSaturation();\n  VertexAttribPointer cmd;\n  cmd.Init(index, size, GL_FLOAT, GL_FALSE, stride, offset);\n  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));\n}", "target": 0}
{"code": "    **/\n    T& atN(const int pos, const int x, const int y, const int z, const int c, const T& out_value) {\n      return (pos<0 || pos>=(int)_width)?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);", "target": 0}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "static int get_filter(struct sss_certmap_ctx *ctx,\n                      struct ldap_mapping_rule *parsed_mapping_rule,\n                      struct sss_cert_content *cert_content,\n                      char **filter)\n{\n    struct ldap_mapping_rule_comp *comp;\n    char *result = NULL;\n    char *expanded = NULL;\n    int ret;\n    result = talloc_strdup(ctx, \"\");\n    if (result == NULL) {\n        return ENOMEM;\n    }\n    for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) {\n        if (comp->type == comp_string) {\n            result = talloc_strdup_append(result, comp->val);\n        } else if (comp->type == comp_template) {\n            ret = expand_template(ctx, comp->parsed_template, cert_content,\n                                  &expanded);\n            if (ret != 0) {\n                CM_DEBUG(ctx, \"Failed to expanded template.\");\n                goto done;\n            }\n            result = talloc_strdup_append(result, expanded);\n            talloc_free(expanded);\n            expanded = NULL;\n            if (result == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else {\n            ret = EINVAL;\n            CM_DEBUG(ctx, \"Unsupported component type.\");\n            goto done;\n        }\n    }\n    ret = 0;\ndone:\n    talloc_free(expanded);\n    if (ret == 0) {\n        *filter = result;\n    } else {\n        talloc_free(result);\n    }\n    return ret;\n}", "target": 1}
{"code": "void CoreUserInputHandler::putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher)\n{\n    static const char *cmd = \"PRIVMSG\";\n    static const char *splitter = \" .,-!?\";\n    int maxSplitPos = message.count();\n    int splitPos = maxSplitPos;\n    forever {\n        QByteArray crypted = message.left(splitPos);\n        bool isEncrypted = false;\n#ifdef HAVE_QCA2\n        if (cipher && !cipher->key().isEmpty() && !message.isEmpty()) {\n            isEncrypted = cipher->encrypt(crypted);\n        }\n#endif\n        int overrun = lastParamOverrun(cmd, QList<QByteArray>() << target << crypted);\n        if (overrun) {\n            if (!isEncrypted)\n                maxSplitPos = message.count() - overrun;\n            splitPos = -1;\n            for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n                splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \n            }\n            if (splitPos <= 0 || splitPos > maxSplitPos)\n                splitPos = maxSplitPos;\n            maxSplitPos = splitPos - 1;\n            if (maxSplitPos <= 0) { \n                qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(message.data());\n                return;\n            }\n            continue; \n        }\n        putCmd(cmd, QList<QByteArray>() << target << crypted);\n        if (splitPos < message.count())\n            putPrivmsg(target, message.mid(splitPos), cipher);\n        return;\n    }\n}", "target": 1}
{"code": "void OmniboxViewWin::TrackMousePosition(MouseButton button,\n                                        const CPoint& point) {\n  if (gaining_focus_.get()) {\n    tracking_click_[button] = true;\n    click_point_[button] = point;\n  }\n}", "target": 0}
{"code": "static int truncate_error_page(struct page *p, unsigned long pfn,\n\t\t\t\tstruct address_space *mapping)\n{\n\tint ret = MF_FAILED;\n\tif (mapping->a_ops->error_remove_page) {\n\t\tint err = mapping->a_ops->error_remove_page(mapping, p);\n\t\tif (err != 0) {\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to punch page: %d\\n\",\n\t\t\t\tpfn, err);\n\t\t} else if (page_has_private(p) &&\n\t\t\t   !try_to_release_page(p, GFP_NOIO)) {\n\t\t\tpr_info(\"Memory failure: %#lx: failed to release buffers\\n\",\n\t\t\t\tpfn);\n\t\t} else {\n\t\t\tret = MF_RECOVERED;\n\t\t}\n\t} else {\n\t\tif (invalidate_inode_page(p))\n\t\t\tret = MF_RECOVERED;\n\t\telse\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to invalidate\\n\",\n\t\t\t\tpfn);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static UINT serial_process_irp_write(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\tDWORD nbWritten = 0;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length); \n\tStream_Read_UINT64(irp->input, Offset); \n\tStream_Seek(irp->input, 20);            \n\tWLog_Print(serial->log, WLOG_DEBUG, \"writing %\" PRIu32 \" bytes to %s\", Length,\n\t           serial->device.name);\n\tif (CommWriteFile(serial->hComm, Stream_Pointer(irp->input), Length, &nbWritten, NULL))\n\t{\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"write failure to %s, nbWritten=%\" PRIu32 \", last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, nbWritten, GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" bytes written to %s\", nbWritten,\n\t           serial->device.name);\n\tStream_Write_UINT32(irp->output, nbWritten); \n\tStream_Write_UINT8(irp->output, 0);          \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "has_undead_caller_from_outside_scc_p (struct cgraph_node *node,\n\t\t\t\t      void *data ATTRIBUTE_UNUSED)\n{\n  struct cgraph_edge *cs;\n  for (cs = node->callers; cs; cs = cs->next_caller)\n    if (cs->caller->thunk.thunk_p\n\t&& cs->caller->call_for_symbol_thunks_and_aliases\n\t  (has_undead_caller_from_outside_scc_p, NULL, true))\n      return true;\n    else if (!ipa_edge_within_scc (cs)\n\t     && !IPA_NODE_REF (cs->caller)->node_dead)\n      return true;\n  return false;\n}", "target": 0}
{"code": "  int libraw_versionNumber() { return LibRaw::versionNumber(); }", "target": 0}
{"code": "static int fsck_tag(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object *tagged = tag->tagged;\n\tif (!tagged)\n\t\treturn report(options, &tag->object, FSCK_MSG_BAD_TAG_OBJECT, \"could not load tagged object\");\n\treturn fsck_tag_buffer(tag, data, size, options);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& gradient = ctx->input(0);\n    const Tensor& input = ctx->input(1);\n    Tensor* input_backprop = nullptr;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, input.shape(), &input_backprop));\n    OP_REQUIRES(\n        ctx, input.IsSameSize(gradient),\n        errors::InvalidArgument(\"gradient and input must be the same size\"));\n    const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n    const Tensor& input_min_tensor = ctx->input(2);\n    const Tensor& input_max_tensor = ctx->input(3);\n    if (axis_ != -1) {\n      OP_REQUIRES(\n          ctx, input_min_tensor.dim_size(0) == depth,\n          errors::InvalidArgument(\"min has incorrect size, expected \", depth,\n                                  \" was \", input_min_tensor.dim_size(0)));\n      OP_REQUIRES(\n          ctx, input_max_tensor.dim_size(0) == depth,\n          errors::InvalidArgument(\"max has incorrect size, expected \", depth,\n                                  \" was \", input_max_tensor.dim_size(0)));\n    }\n    TensorShape min_max_shape(input_min_tensor.shape());\n    Tensor* input_min_backprop;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, min_max_shape, &input_min_backprop));\n    Tensor* input_max_backprop;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(2, min_max_shape, &input_max_backprop));\n    if (axis_ == -1) {\n      functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(), gradient.template flat<T>(),\n        input.template flat<T>(), input_min_tensor.scalar<T>(),\n        input_max_tensor.scalar<T>(), input_backprop->template flat<T>(),\n        input_min_backprop->template scalar<T>(),\n        input_max_backprop->template scalar<T>());\n    } else {\n      functor::QuantizeAndDequantizePerChannelGradientFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(),\n        gradient.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        input.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        &input_min_tensor, &input_max_tensor,\n        input_backprop->template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        input_min_backprop->template flat<T>(),\n        input_max_backprop->template flat<T>());\n    }\n  }", "target": 1}
{"code": "    long LangAltValue::count() const\n    {\n        return static_cast<long>(value_.size());\n    }", "target": 0}
{"code": "static inline void skb_set_network_header(struct sk_buff *skb, const int offset)\n{\n\tskb->network_header = skb->data + offset;\n}", "target": 0}
{"code": "make_unix_date2(const u_char *date_ptr)\n{\n    uint32_t x, x2;\n    x = EXTRACT_LE_32BITS(date_ptr);\n    x2 = ((x & 0xFFFF) << 16) | ((x & 0xFFFF0000) >> 16);\n    return int_unix_date(x2);\n}", "target": 0}
{"code": "bool TradQT_Manager::ParseCachedBoxes ( const MOOV_Manager & moovMgr )\n{\n\tMOOV_Manager::BoxInfo udtaInfo;\n\tMOOV_Manager::BoxRef  udtaRef = moovMgr.GetBox ( \"moov/udta\", &udtaInfo );\n\tif ( udtaRef == 0 ) return false;\n\tfor ( XMP_Uns32 i = 0; i < udtaInfo.childCount; ++i ) {\n\t\tMOOV_Manager::BoxInfo currInfo;\n\t\tMOOV_Manager::BoxRef  currRef = moovMgr.GetNthChild ( udtaRef, i, &currInfo );\n\t\tif ( currRef == 0 ) break;\t\n\t\tif ( (currInfo.boxType >> 24) != 0xA9 ) continue;\n\t\tif ( currInfo.contentSize < 2+2+1 ) continue;\t\n\t\tInfoMapPos newInfo = this->parsedBoxes.insert ( this->parsedBoxes.end(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInfoMap::value_type ( currInfo.boxType, ParsedBoxInfo ( currInfo.boxType ) ) );\n\t\tstd::vector<ValueInfo> * newValues = &newInfo->second.values;\n\t\tXMP_Uns8 * boxPtr = (XMP_Uns8*) currInfo.content;\n\t\tXMP_Uns8 * boxEnd = boxPtr + currInfo.contentSize;\n\t\tXMP_Uns16 miniLen, macLang;\n\t\tfor ( ; boxPtr < boxEnd-4; boxPtr += miniLen ) {\n \t\t\tminiLen = 4 + GetUns16BE ( boxPtr );\t\n \t\t\tmacLang  = GetUns16BE ( boxPtr+2);\n\t\t\tif ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) ) continue;\t\n \t\t\tXMP_StringPtr valuePtr = (char*)(boxPtr+4);\n \t\t\tsize_t valueLen = miniLen - 4;\n\t\t\tnewValues->push_back ( ValueInfo() );\n\t\t\tValueInfo * newValue = &newValues->back();\n\t\t\tnewValue->macLang = macLang;\n\t\t\tif ( IsMacLangKnown ( macLang ) ) newValue->xmpLang = GetXMPLang ( macLang );\n\t\t\tnewValue->macValue.assign ( valuePtr, valueLen );\n\t\t}\n\t}\n\treturn (! this->parsedBoxes.empty());\n}\t", "target": 1}
{"code": "int GetDPI(const PrintMsg_Print_Params* print_params) {\n#if defined(OS_MACOSX)\n  return kPointsPerInch;\n#else\n  return static_cast<int>(print_params->dpi);\n#endif  \n}", "target": 0}
{"code": "void smp_send_init(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  smp_send_cmd(SMP_OPCODE_INIT, p_cb);\n}", "target": 0}
{"code": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n     for (i = 0; i < probe_packet->buf_size; i++) {\n         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if ((temp_buffer & 0xffffff00) != 0x100)\n             continue;\n         if (temp_buffer == VOP_START_CODE)\n             VOP++;\n         else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n             VISO++;\n        else if (temp_buffer < 0x120)\n             VO++;\n        else if (temp_buffer < 0x130)\n             VOL++;\n         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}", "target": 1}
{"code": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\tswitch (cmd) {\n \tcase FBIOGET_VBLANK: {\n \t\tstruct fb_vblank vblank;\n \t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n \t\t\tFB_VBLANK_HAVE_VSYNC;\n \t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "base_indexed(const fz_colorspace *cs)\n{\n\tstruct indexed *idx = cs->data;\n\treturn idx->base;\n}", "target": 0}
{"code": "static int handle_invvpid(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}", "target": 0}
{"code": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "is_subkey(KEY_PART_INFO *key_part, KEY_PART_INFO *ref_key_part,\n\t  KEY_PART_INFO *ref_key_part_end)\n{\n  for (; ref_key_part < ref_key_part_end; key_part++, ref_key_part++)\n    if (!key_part->field->eq(ref_key_part->field))\n      return 0;\n  return 1;\n}", "target": 0}
{"code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\tif (id < 0)\n\t\treturn NULL;\n\trcu_read_lock();\n \tspin_lock_bh(&net->nsid_lock);\n \tpeer = idr_find(&net->netns_ids, id);\n \tif (peer)\n\t\tget_net(peer);\n \tspin_unlock_bh(&net->nsid_lock);\n \trcu_read_unlock();\n\treturn peer;\n}", "target": 1}
{"code": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"compression\");\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "    size_t Exifdatum::size() const\n    {\n        return value_.get() == 0 ? 0 : value_->size();\n    }", "target": 0}
{"code": "void ap_lua_rstack_dump(lua_State *L, request_rec *r, const char *msg)\n{\n    int i;\n    int top = lua_gettop(L);\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01484) \"Lua Stack Dump: [%s]\", msg);\n    for (i = 1; i <= top; i++) {\n        int t = lua_type(L, i);\n        switch (t) {\n        case LUA_TSTRING:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  '%s'\", i, lua_tostring(L, i));\n                break;\n            }\n        case LUA_TUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  userdata\",\n                              i);\n                break;\n            }\n        case LUA_TLIGHTUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  lightuserdata\", i);\n                break;\n            }\n        case LUA_TNIL:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  NIL\", i);\n                break;\n            }\n        case LUA_TNONE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  None\", i);\n                break;\n            }\n        case LUA_TBOOLEAN:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %s\", i, lua_toboolean(L,\n                                                          i) ? \"true\" :\n                              \"false\");\n                break;\n            }\n        case LUA_TNUMBER:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %g\", i, lua_tonumber(L, i));\n                break;\n            }\n        case LUA_TTABLE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <table>\", i);\n                break;\n            }\n        case LUA_TFUNCTION:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <function>\", i);\n                break;\n            }\n        default:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  unknown: -[%s]-\", i, lua_typename(L, i));\n                break;\n            }\n        }\n    }\n}", "target": 0}
{"code": "static void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    ses->time.stop = pj_strtoul(&str);\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "Curves16Data* CurvesAlloc(cmsContext ContextID, int nCurves, int nElements, cmsToneCurve** G)\n{\n    int i, j;\n    Curves16Data* c16;\n    c16 = _cmsMallocZero(ContextID, sizeof(Curves16Data));\n    if (c16 == NULL) return NULL;\n    c16 ->nCurves = nCurves;\n    c16 ->nElements = nElements;\n    c16 ->Curves = _cmsCalloc(ContextID, nCurves, sizeof(cmsUInt16Number*));\n    if (c16 ->Curves == NULL) return NULL;\n    for (i=0; i < nCurves; i++) {\n         c16->Curves[i] = _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));\n         if (nElements == 256) {\n             for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], FROM_8_TO_16(j));\n            }\n        }\n        else {\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], (cmsUInt16Number) j);\n            }\n        }\n    }\n    return c16;\n}", "target": 1}
{"code": "long ParseElementHeader(IMkvReader* pReader, long long& pos,\n long long stop, long long& id,\n long long& size) {\n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n long len;\n  id = ReadID(pReader, pos, len);\n if (id < 0)\n return E_FILE_FORMAT_INVALID;\n  pos += len; \n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n  size = ReadUInt(pReader, pos, len);\n if (size < 0 || len < 1 || len > 8) {\n return E_FILE_FORMAT_INVALID;\n }\n const unsigned long long rollover_check =\n static_cast<unsigned long long>(pos) + len;\n if (rollover_check > LONG_LONG_MAX)\n return E_FILE_FORMAT_INVALID;\n  pos += len; \n  if (stop >= 0 && pos >= stop)\n     return E_FILE_FORMAT_INVALID;\n   return 0;  \n}", "target": 1}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 size = 0;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\tsize = rz_buf_read(buffer, s1, n1);\n\tif (size != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else\n\t\tn2 = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\tsize = rz_buf_read(buffer, s2, n2);\n\tif (size != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int qh_help(int sd, char *buf, unsigned int len)\n{\n\tstruct query_handler *qh = NULL;\n\tif (!*buf || !strcmp(buf, \"help\")) {\n\t\tnsock_printf_nul(sd,\n\t\t\t\"  help <name>   show help for handler <name>\\n\"\n\t\t\t\"  help list     list registered handlers\\n\");\n\t\treturn 0;\n\t}\n\tif (!strcmp(buf, \"list\")) {\n\t\tfor (qh = qhandlers; qh != NULL; qh = qh->next_qh) {\n\t\t\tnsock_printf(sd, \"%-10s %s\\n\", qh->name, qh->description ? qh->description : \"(No description available)\");\n\t\t}\n\t\tnsock_printf(sd, \"%c\", 0);\n\t\treturn 0;\n\t}\n\tqh = qh_find_handler(buf);\n\tif (qh == NULL) {\n\t\tnsock_printf_nul(sd, \"No handler named '%s' is registered\\n\", buf);\n\t} else if (qh->handler(sd, \"help\", 4) > 200) {\n\t\tnsock_printf_nul(sd, \"The handler %s doesn't have any help yet.\", buf);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\tif (dp->synths[dev].is_midi) {\n\t\tstruct midi_info minf;\n\t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "ikev2_sa_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext1,\n\t\tu_int osa_length, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth)\n{\n\tconst struct isakmp_gen *ext;\n\tstruct isakmp_gen e;\n\tu_int sa_length;\n\tconst u_char *cp;\n\tint i;\n\tint pcount;\n\tu_char np;\n\tu_int item_len;\n\tND_TCHECK(*ext1);\n\tUNALIGNED_MEMCPY(&e, ext1, sizeof(e));\n\tikev2_pay_print(ndo, \"sa\", e.critical);\n\tosa_length= ntohs(e.len);\n\tsa_length = osa_length - 4;\n\tND_PRINT((ndo,\" len=%d\", sa_length));\n\tcp = (const u_char *)(ext1 + 1);\n\tpcount = 0;\n\tfor (np = ISAKMP_NPTYPE_P; np != 0; np = e.np) {\n\t\tpcount++;\n\t\text = (const struct isakmp_gen *)cp;\n\t\tif (sa_length < sizeof(*ext))\n\t\t\tgoto toolong;\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\titem_len = ntohs(e.len);\n\t\tif (item_len <= 4)\n\t\t\tgoto trunc;\n\t\tif (sa_length < item_len)\n\t\t\tgoto toolong;\n\t\tND_TCHECK2(*cp, item_len);\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tif (np == ISAKMP_NPTYPE_P) {\n\t\t\tcp = ikev2_p_print(ndo, np, pcount, ext, item_len,\n\t\t\t\t\t   ep, depth);\n\t\t\tif (cp == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s\", NPSTR(np)));\n\t\t\tcp += item_len;\n\t\t}\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tsa_length -= item_len;\n\t}\n\treturn cp;\ntoolong:\n\tcp += sa_length;\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "FunctionDef FunctionDefHelper::Create(\n    const string& function_name, gtl::ArraySlice<string> in_def,\n    gtl::ArraySlice<string> out_def, gtl::ArraySlice<string> attr_def,\n    gtl::ArraySlice<Node> node_def,\n    gtl::ArraySlice<std::pair<string, string>> ret_def) {\n  return Create(function_name, in_def, out_def, attr_def, node_def, ret_def,\n                {});\n}", "target": 0}
{"code": "static inline long put_compat_itimerval(struct compat_itimerval __user *o,\n\t\tstruct itimerval *i)\n{\n\treturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\n\t\t(__put_user(i->it_interval.tv_sec, &o->it_interval.tv_sec) |\n\t\t __put_user(i->it_interval.tv_usec, &o->it_interval.tv_usec) |\n\t\t __put_user(i->it_value.tv_sec, &o->it_value.tv_sec) |\n\t\t __put_user(i->it_value.tv_usec, &o->it_value.tv_usec)));\n}", "target": 0}
{"code": "unsigned int _gnutls_x509_verify_certificate(\n    const gnutls_x509_crt_t *certificate_list, int clist_size,\n    const gnutls_x509_crt_t *trusted_cas, int tcas_size,\n    const gnutls_x509_crl_t *CRLs, int crls_size,\n    unsigned int flags)\n{\n    int i = 0, ret;\n    unsigned int status = 0, output;\n    ret =\n\t_gnutls_verify_certificate2(certificate_list[clist_size-1], \n\t    trusted_cas, tcas_size, flags, &output);\n    if (ret == 0) {\n\tgnutls_assert();\n\tstatus |= output;\n\tstatus |= GNUTLS_CERT_INVALID;\n\treturn status;\n    }\n#ifdef ENABLE_PKI\n    for (i = 0; i < clist_size; i++) {\n\tret = gnutls_x509_crt_check_revocation(certificate_list[i],\n\t\t\t\t\t       CRLs, crls_size);\n\tif (ret == 1) {\t\t\n\t    status |= GNUTLS_CERT_REVOKED;\n\t    status |= GNUTLS_CERT_INVALID;\n\t    return status;\n\t}\n    }\n#endif\n    for (i = clist_size-1; i > 0; i--) {\n\tif (i - 1 < 0)\n\t    break;\n        flags ^= GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT;\n\tif ((ret =\n\t     _gnutls_verify_certificate2(certificate_list[i-1],\n                  &certificate_list[i], 1, flags, NULL)) == 0) {\n\t    status |= GNUTLS_CERT_INVALID;\n\t    return status;\n\t}\n    }\n    return 0;\n}", "target": 0}
{"code": "static __inline __int64_t php_date_llabs( __int64_t i ) { return i >= 0 ? i : -i; }", "target": 0}
{"code": "static int get_dev_to_use(struct spk_synth *synth, dev_t *dev_no)\n{\n\tif (strcmp(synth->dev_name, SYNTH_DEFAULT_DEV) ||\n\t    synth->ser == SYNTH_DEFAULT_SER)\n\t\treturn tty_dev_name_to_number(synth->dev_name, dev_no);\n\treturn ser_to_dev(synth->ser, dev_no);\n}", "target": 0}
{"code": "unsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\tif (len < 5)\n\t\treturn len;\t\n\tb->opcode = 0xe9;\t\n\tb->delta = delta;\n\treturn 5;\n}", "target": 1}
{"code": "static uint8_t avrcp_handle_set_absolute_volume(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tuint16_t len = ntohs(pdu->params_len);\n\tint8_t volume;\n\tif (len != 1)\n\t\tgoto err;\n\tvolume = pdu->params[0] & 0x7F;\n\tmedia_transport_update_device_volume(session->dev, volume);\n\treturn AVC_CTYPE_ACCEPTED;\nerr:\n\tpdu->params_len = htons(1);\n\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\treturn AVC_CTYPE_REJECTED;\n}", "target": 0}
{"code": "mptctl_eventquery (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventquery\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventquery() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventquery called.\\n\",\n\t    ioc->name));\n\tkarg.eventEntries = MPTCTL_EVENT_LOG_SIZE;\n\tkarg.eventTypes = ioc->eventTypes;\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "*/\nPHP_FUNCTION(timezone_abbreviations_list)\n{\n\tconst timelib_tz_lookup_table *table, *entry;\n\tzval                          *element, **abbr_array_pp, *abbr_array;\n\ttable = timelib_timezone_abbreviations_list();\n\tarray_init(return_value);\n\tentry = table;\n\tdo {\n\t\tMAKE_STD_ZVAL(element);\n\t\tarray_init(element);\n\t\tadd_assoc_bool(element, \"dst\", entry->type);\n\t\tadd_assoc_long(element, \"offset\", entry->gmtoffset);\n\t\tif (entry->full_tz_name) {\n\t\t\tadd_assoc_string(element, \"timezone_id\", entry->full_tz_name, 1);\n\t\t} else {\n\t\t\tadd_assoc_null(element, \"timezone_id\");\n\t\t}\n\t\tif (zend_hash_find(HASH_OF(return_value), entry->name, strlen(entry->name) + 1, (void **) &abbr_array_pp) == FAILURE) {\n\t\t\tMAKE_STD_ZVAL(abbr_array);\n\t\t\tarray_init(abbr_array);\n\t\t\tadd_assoc_zval(return_value, entry->name, abbr_array);\n\t\t} else {\n\t\t\tabbr_array = *abbr_array_pp;\n\t\t}\n\t\tadd_next_index_zval(abbr_array, element);\n\t\tentry++;\n\t} while (entry->name);", "target": 0}
{"code": "void nego_process_negotiation_response(rdpNego* nego, wStream* s)\n{\n\tUINT16 length;\n\tWLog_DBG(TAG, \"RDP_NEG_RSP\");\n\tif (Stream_GetRemainingLength(s) < 7)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid RDP_NEG_RSP\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\tStream_Read_UINT8(s, nego->flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->SelectedProtocol);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "Server::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n    Must(io.conn->fd == clientConnection->fd);\n    if (io.flag && pipeline.front())\n        pipeline.front()->initiateClose(\"write failure\");\n    afterClientWrite(io.size); \n    writeSomeData(); \n}", "target": 1}
{"code": "static void kvm_guest_cpu_offline(void *dummy)\n{\n\tkvm_disable_steal_time();\n\tif (kvm_para_has_feature(KVM_FEATURE_PV_EOI))\n\t\twrmsrl(MSR_KVM_PV_EOI_EN, 0);\n\tkvm_pv_disable_apf();\n\tapf_task_wake_all();\n}", "target": 0}
{"code": "int JOIN::init_join_caches()\n{\n  JOIN_TAB *tab;\n  for (tab= first_linear_tab(this, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab;\n       tab= next_linear_tab(this, tab, WITH_BUSH_ROOTS))\n  {\n    TABLE *table= tab->table;\n    if (table->file->keyread_enabled())\n    {\n      if (!(table->file->index_flags(table->file->keyread, 0, 1) & HA_CLUSTERED_INDEX))\n        table->mark_index_columns(table->file->keyread, table->read_set);\n    }\n    else if ((tab->read_first_record == join_read_first ||\n              tab->read_first_record == join_read_last) &&\n             !tab->filesort && table->covering_keys.is_set(tab->index) &&\n             !table->no_keyread)\n    {\n      table->prepare_for_keyread(tab->index, table->read_set);\n    }\n    if (tab->cache && tab->cache->init(select_options & SELECT_DESCRIBE))\n      revise_cache_usage(tab);\n    else\n      tab->remove_redundant_bnl_scan_conds();\n  }\n  return 0;\n}", "target": 0}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": "    TiffCopier::TiffCopier(      TiffComponent*  pRoot,\n                                 uint32_t        root,\n                           const TiffHeaderBase* pHeader,\n                           const PrimaryGroups*  pPrimaryGroups)\n        : pRoot_(pRoot),\n          root_(root),\n          pHeader_(pHeader),\n          pPrimaryGroups_(pPrimaryGroups)\n    {\n        assert(pRoot_ != 0);\n        assert(pHeader_ != 0);\n        assert(pPrimaryGroups_ != 0);\n    }", "target": 0}
{"code": "static int adpt_bios_param(struct scsi_device *sdev, struct block_device *dev,\n\t\tsector_t capacity, int geom[])\n{\n\tint heads=-1;\n\tint sectors=-1;\n\tint cylinders=-1;\n\tif (capacity < 0x2000 ) {\t\n\t\theads = 18;\n\t\tsectors = 2;\n\t} \n\telse if (capacity < 0x20000) {\n\t\theads = 64;\n\t\tsectors = 32;\n\t}\n\telse if (capacity < 0x40000) {\n\t\theads = 65;\n\t\tsectors = 63;\n\t}\n\telse if (capacity < 0x80000) {\n\t\theads = 128;\n\t\tsectors = 63;\n\t}\n\telse {\n\t\theads = 255;\n\t\tsectors = 63;\n\t}\n\tcylinders = sector_div(capacity, heads * sectors);\n\tif(sdev->type == 5) {  \n\t\theads = 252;\n\t\tsectors = 63;\n\t\tcylinders = 1111;\n\t}\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\tPDEBUG(\"adpt_bios_param: exit\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static int dev_get_valid_name(struct net *net,\n\t\t\t      struct net_device *dev,\n\t\t\t      const char *name)\n {\n \tBUG_ON(!net);\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n \treturn 0;\n }", "target": 1}
{"code": "format_versions_list(config_line_t *ln)\n{\n  smartlist_t *versions;\n  char *result;\n  versions = smartlist_new();\n  for ( ; ln; ln = ln->next) {\n    smartlist_split_string(versions, ln->value, \",\",\n                           SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);\n  }\n  sort_version_list(versions, 1);\n  result = smartlist_join_strings(versions,\",\",0,NULL);\n  SMARTLIST_FOREACH(versions,char *,s,tor_free(s));\n  smartlist_free(versions);\n  return result;\n}", "target": 0}
{"code": "FileSystemOperation* FileSystemOperation::AsFileSystemOperation() {\n  return this;\n}", "target": 0}
{"code": "u32 gf_fs_get_max_resolution_chain_length(GF_FilterSession *session)\n{\n\tif (!session) return 0;\n\treturn session->max_resolve_chain_len;\n}", "target": 0}
{"code": "TEST(FloatPoolingOpTest, AveragePool) {\n  FloatPoolingOpModel m(BuiltinOperator_AVERAGE_POOL_2D,\n                        {TensorType_FLOAT32, {1, 2, 4, 1}},\n                        2, 2,\n                        {TensorType_FLOAT32, {}});\n  m.SetInput({\n      0, 6, 2, 4,   \n      3, 2, 10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({2.75, 5.75}));\n}", "target": 0}
{"code": "vips_malloc( VipsObject *object, size_t size )\n{\n\tvoid *buf;\n\tbuf = g_malloc( size );\n        if( object ) {\n\t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\treturn( buf );\n}", "target": 1}
{"code": "static void axfm(RCore *core) {\n\tRVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX);\n\tif (refs && !RVecAnalRef_empty (refs)) {\n\t\tRVecAnalRef_sort (refs, compare_ref);\n\t\tut64 last_addr = UT64_MAX;\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\tconst bool is_first = ref->addr != last_addr;\n\t\t\tconst char *name;\n\t\t\tif (is_first) {\n\t\t\t\tname = axtm_name (core, ref->addr);\n\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\": %s\\n\", ref->addr, name? name: \"?\");\n\t\t\t}\n\t\t\tname = axtm_name (core, ref->at);\n\t\t\tr_cons_printf (\"  0x%\"PFMT64x\": %s\\n\", ref->at, name? name: \"?\");\n\t\t\tlast_addr = ref->addr;\n\t\t}\n\t}\n\tRVecAnalRef_free (refs);\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  int output_height = input_height / block_size;\n  int output_width = input_width / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height * block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width * block_size);\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = input->dims->data[3] * block_size * block_size;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 1}
{"code": "_dbus_daemon_unpublish_session_bus_address (void)\n{\n}", "target": 0}
{"code": "static void _d_rehash(struct dentry * entry)\n{\n\t__d_rehash(entry, d_hash(entry->d_parent, entry->d_name.hash));\n}", "target": 0}
{"code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\t*r = -1;\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 1}
{"code": "gopherSendComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag, int xerrno, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *) data;\n    StoreEntry *entry = gopherState->entry;\n    debugs(10, 5, conn << \" size: \" << size << \" errflag: \" << errflag);\n    if (size > 0) {\n        fd_bytes(conn->fd, size, FD_WRITE);\n        statCounter.server.all.kbytes_out += size;\n        statCounter.server.other.kbytes_out += size;\n    }\n    if (!entry->isAccepting()) {\n        debugs(10, 3, \"terminating due to bad \" << *entry);\n        gopherState->serverConn->close();\n        return;\n    }\n    if (errflag) {\n        const auto err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request, gopherState->fwd->al);\n        err->xerrno = xerrno;\n        err->port = gopherState->fwd->request->url.port();\n        err->url = xstrdup(entry->url());\n        gopherState->fwd->fail(err);\n        gopherState->serverConn->close();\n        return;\n    }\n    entry->buffer();\n    gopherMimeCreate(gopherState);\n    switch (gopherState->type_id) {\n    case GOPHER_DIRECTORY:\n        gopherState->conversion = GopherStateData::HTML_DIR;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_INDEX:\n        gopherState->conversion = GopherStateData::HTML_INDEX_RESULT;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_CSO:\n        gopherState->conversion = GopherStateData::HTML_CSO_RESULT;\n        gopherState->cso_recno = 0;\n        gopherState->HTML_header_added = 0;\n        break;\n    default:\n        gopherState->conversion = GopherStateData::NORMAL;\n        entry->flush();\n    }\n    GopherStateData::DelayAwareRead(gopherState);\n}", "target": 1}
{"code": "directory_fetches_dir_info_early(or_options_t *options)\n{\n  return directory_fetches_from_authorities(options);\n}", "target": 0}
{"code": "static inline bool cpu_has_vmx_apic_register_virt(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT;\n}", "target": 0}
{"code": "static inline void nf_reset(struct sk_buff *skb)\n{\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\n\tnf_conntrack_put(skb->nfct);\n\tskb->nfct = NULL;\n#endif\n#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED\n\tnf_conntrack_put_reasm(skb->nfct_reasm);\n\tskb->nfct_reasm = NULL;\n#endif\n#ifdef CONFIG_BRIDGE_NETFILTER\n\tnf_bridge_put(skb->nf_bridge);\n\tskb->nf_bridge = NULL;\n#endif\n}", "target": 0}
{"code": "  virtual void OnConnectionTypeChanged(\n      net::NetworkChangeNotifier::ConnectionType type) {\n    process_host_->Send(new PpapiMsg_SetNetworkState(\n        type != net::NetworkChangeNotifier::CONNECTION_NONE));\n  }", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n can_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n \t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n \t}\n error2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL |\n\t\t\t\t\t    __GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n\tnetlink_skb_set_owner_r(skb, sk);\n\tlen = cb->dump(skb, cb);\n\tif (len > 0) {\n\t\tmutex_unlock(nlk->cb_mutex);\n\t\tif (sk_filter(sk, skb))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\t__netlink_sendskb(sk, skb);\n\t\treturn 0;\n\t}\n\tnlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);\n\tif (!nlh)\n\t\tgoto errout_skb;\n\tnl_dump_check_consistent(cb, nlh);\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\tif (cb->done)\n\t\tcb->done(cb);\n\tnlk->cb_running = false;\n\tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(cb->module);\n\tconsume_skb(cb->skb);\n\treturn 0;\nerrout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 1}
{"code": "static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\t\tif (tu->timeri)\t\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\ttu->tread = xarg ? 1 : 0;\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}", "target": 0}
{"code": "ZEND_API int zend_declare_property_null(zend_class_entry *ce, const char *name, int name_length, int access_type TSRMLS_DC) \n{\n\tzval *property;\n\tif (ce->type & ZEND_INTERNAL_CLASS) {\n\t\tALLOC_PERMANENT_ZVAL(property);\n\t} else {\n\t\tALLOC_ZVAL(property);\n\t}\n\tINIT_ZVAL(*property);\n\treturn zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);\n}", "target": 0}
{"code": "void RenderView::OnCopy() {\n  if (!webview())\n    return;\n  webview()->focusedFrame()->executeCommand(WebString::fromUTF8(\"Copy\"));\n  UserMetricsRecordAction(\"Copy\");\n}", "target": 0}
{"code": "static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\treturn LOC_NOT_FOUND;\n}", "target": 1}
{"code": "static UINT printer_process_irp_write(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\trdpPrintJob* printjob = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse\n\t{\n\t\terror = printjob->Write(printjob, Stream_Pointer(irp->input), Length);\n\t}\n\tif (error)\n\t{\n\t\tWLog_ERR(TAG, \"printjob->Write failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "process_secondary_order(STREAM s)\n{\n\tuint16 length;\n \tuint16 flags;\n \tuint8 type;\n \tuint8 *next_order;\n \tin_uint16_le(s, length);\n \tin_uint16_le(s, flags);\t\n \tin_uint8(s, type);\n \tnext_order = s->p + (sint16) length + 7;\n \tswitch (type)\n\t{\n\t\tcase RDP_ORDER_RAW_BMPCACHE:\n\t\t\tprocess_raw_bmpcache(s);\n\t\t\tbreak;\n\t\tcase RDP_ORDER_COLCACHE:\n\t\t\tprocess_colcache(s);\n\t\t\tbreak;\n\t\tcase RDP_ORDER_BMPCACHE:\n\t\t\tprocess_bmpcache(s);\n\t\t\tbreak;\n\t\tcase RDP_ORDER_FONTCACHE:\n\t\t\tprocess_fontcache(s);\n\t\t\tbreak;\n\t\tcase RDP_ORDER_RAW_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, False);\t\n\t\t\tbreak;\n\t\tcase RDP_ORDER_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, True);\t\n\t\t\tbreak;\n\t\tcase RDP_ORDER_BRUSHCACHE:\n\t\t\tprocess_brushcache(s, flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_secondary_order(), unhandled secondary order %d\", type);\n\t}\n\ts->p = next_order;\n}", "target": 1}
{"code": "void GfxSeparationColorSpace::getDeviceN(const GfxColor *color, GfxColor *deviceN) const\n{\n    clearGfxColor(deviceN);\n    if (mapping == nullptr || mapping[0] == -1) {\n        GfxCMYK cmyk;\n        getCMYK(color, &cmyk);\n        deviceN->c[0] = cmyk.c;\n        deviceN->c[1] = cmyk.m;\n        deviceN->c[2] = cmyk.y;\n        deviceN->c[3] = cmyk.k;\n    } else {\n        deviceN->c[mapping[0]] = color->c[0];\n    }\n}", "target": 0}
{"code": "CLua::~CLua()\n{\n    const vector<lua_shutdown_listener*> slisteners = shutdown_listeners;\n    for (lua_shutdown_listener *listener : slisteners)\n        listener->shutdown(*this);\n    shutting_down = true;\n    if (_state)\n        lua_close(_state);\n}", "target": 0}
{"code": "BOOL lmtp_transport_entry(transport_instance *tblock, address_item *addr) {return FALSE;}", "target": 0}
{"code": "static void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\tsvm->vmcb->control.lbr_ctl = 1;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}", "target": 0}
{"code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; \n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }", "target": 1}
{"code": "  virtual void EnableOfflineMode(bool enable) {}", "target": 0}
{"code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\tinfo->addr = port->addr;\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\treturn 0;\n}", "target": 1}
{"code": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n\t\tmosquitto__free(packet);\n\t\tif(mosq->is_dropping == false){\n\t\t\tmosq->is_dropping = true;\n\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\tmosq->id);\n\t\t}\n\t\tG_MSGS_DROPPED_INC();\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}", "target": 0}
{"code": "int dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target)\n{\n\tsvcparam_buffer = dns_add_rr_nested_start(svcparam_buffer, packet, type, DNS_T_HTTPS, domain, ttl);\n\tif (svcparam_buffer == NULL) {\n\t\treturn -1;\n\t}\n\tint target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n\tif (_dns_left_len(&svcparam_buffer->context) < 2 + target_len) {\n\t\treturn -1;\n\t}\n\t_dns_write_short(&svcparam_buffer->context.ptr, priority);\n\tsafe_strncpy((char *)svcparam_buffer->context.ptr, target, target_len);\n\tsvcparam_buffer->context.ptr += target_len;\n\treturn 0;\n}", "target": 1}
{"code": "bool RenderView::runFileChooser(\n    const WebKit::WebFileChooserParams& params,\n    WebFileChooserCompletion* chooser_completion) {\n  ViewHostMsg_RunFileChooser_Params ipc_params;\n  ipc_params.mode = params.multiSelect ?\n      ViewHostMsg_RunFileChooser_Params::OpenMultiple :\n      ViewHostMsg_RunFileChooser_Params::Open;\n  ipc_params.title = params.title;\n  ipc_params.default_file_name =\n      webkit_glue::WebStringToFilePath(params.initialValue);\n  return ScheduleFileChooser(ipc_params, chooser_completion);\n}", "target": 0}
{"code": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\tmutex_lock(&client->lock);\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    if (mirror_pad_) {\n      const TfLiteMirrorPaddingParams* tf_options;\n      RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n      if (tf_options->mode !=\n          TfLiteMirrorPaddingMode::kTfLiteMirrorPaddingReflect) {\n        return absl::InvalidArgumentError(\n            \"Only Reflective padding is supported for Mirror Pad operation.\");\n      }\n    }\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 2));\n    RETURN_IF_ERROR(CheckInputsOutputs(context, tflite_node,\n                                       1, 1));\n    RETURN_IF_ERROR(CheckTensorIsAvailable(context, tflite_node, 1));\n    auto pad_tensor = tflite::GetInput(context, tflite_node, 1);\n    if (pad_tensor->dims->size != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor dimension: expected 2 dim, got \",\n          pad_tensor->dims->size, \" dim\"));\n    }\n    bool supported =\n        pad_tensor->dims->data[0] == 3 || pad_tensor->dims->data[0] == 4;\n    if (!supported || pad_tensor->dims->data[1] != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor shape: expected 4x2 or 3x2, got \",\n          pad_tensor->dims->data[0], \"x\", pad_tensor->dims->data[1]));\n    }\n    return absl::OkStatus();\n  }", "target": 1}
{"code": "RenderThreadImpl::SharedMainThreadContextProvider() {\n  DCHECK(IsMainThread());\n  if (!shared_main_thread_contexts_.get() ||\n      shared_main_thread_contexts_->DestroyedOnMainThread()) {\n    shared_main_thread_contexts_ = NULL;\n#if defined(OS_ANDROID)\n    if (SynchronousCompositorFactory* factory =\n            SynchronousCompositorFactory::GetInstance()) {\n      shared_main_thread_contexts_ = factory->CreateOffscreenContextProvider(\n          GetOffscreenAttribs(), \"Offscreen-MainThread\");\n    }\n#endif\n    if (!shared_main_thread_contexts_.get()) {\n      shared_main_thread_contexts_ = ContextProviderCommandBuffer::Create(\n          CreateOffscreenContext3d(), \"Offscreen-MainThread\");\n    }\n    if (shared_main_thread_contexts_.get() &&\n        !shared_main_thread_contexts_->BindToCurrentThread())\n      shared_main_thread_contexts_ = NULL;\n  }\n  return shared_main_thread_contexts_;\n}", "target": 0}
{"code": "static int zpff_init(struct hid_device *hid)\n{\n\tstruct zpff_device *zpff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint i, error;\n\tfor (i = 0; i < 4; i++) {\n\t\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, i, 1);\n\t\tif (!report)\n\t\t\treturn -ENODEV;\n\t}\n\tzpff = kzalloc(sizeof(struct zpff_device), GFP_KERNEL);\n\tif (!zpff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, zpff, zpff_play);\n\tif (error) {\n\t\tkfree(zpff);\n\t\treturn error;\n\t}\n\tzpff->report = report;\n\tzpff->report->field[0]->value[0] = 0x00;\n\tzpff->report->field[1]->value[0] = 0x02;\n\tzpff->report->field[2]->value[0] = 0x00;\n\tzpff->report->field[3]->value[0] = 0x00;\n\thid_hw_request(hid, zpff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"force feedback for Zeroplus based devices by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static zend_long ZEND_FASTCALL _zval_get_long_func_noisy(zval *op) \n{\n\treturn _zval_get_long_func_ex(op, 0);\n}", "target": 0}
{"code": "INST_HANDLER (sbrx) {\t\n \tint b = buf[0] & 0x7;\n \tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\n\t\t\t: \"!,!,\");\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "int snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_ioctls);\n}", "target": 0}
{"code": "int pico_tcp_initconn(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *syn;\n    struct pico_tcp_hdr *hdr;\n    uint16_t mtu, opt_len = tcp_options_size(ts, PICO_TCP_SYN);\n    syn = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!syn)\n        return -1;\n    hdr = (struct pico_tcp_hdr *) syn->transport_hdr;\n    if (!ts->snd_nxt)\n        ts->snd_nxt = long_be(pico_paws());\n    ts->snd_last = ts->snd_nxt;\n    ts->cwnd = PICO_TCP_IW;\n    mtu = (uint16_t)pico_socket_get_mss(s);\n    ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n    syn->sock = s;\n    hdr->seq = long_be(ts->snd_nxt);\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN;\n    tcp_set_space(ts);\n    hdr->rwnd = short_be(ts->wnd);\n    tcp_add_options(ts, syn, PICO_TCP_SYN, opt_len);\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(syn));\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(ts->sock.local_port), short_be(ts->sock.remote_port), syn->buffer_len);\n    ts->retrans_tmr = pico_timer_add(s->stack, PICO_TCP_SYN_TO << ts->backoff, initconn_retry, ts);\n    if (!ts->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(syn);\n        return -1;\n    }\n    pico_enqueue(&s->stack->q_tcp.out, syn);\n    return 0;\n}", "target": 1}
{"code": "nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct dentry *parent;\n\tstruct iattr attr;\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tstruct dentry *res;\n\tif (nd->flags & LOOKUP_CREATE) {\n\t\tattr.ia_mode = nd->intent.open.create_mode;\n\t\tattr.ia_valid = ATTR_MODE;\n\t\tif (!IS_POSIXACL(dir))\n\t\t\tattr.ia_mode &= ~current->fs->umask;\n\t} else {\n\t\tattr.ia_valid = 0;\n\t\tBUG_ON(nd->intent.open.flags & O_CREAT);\n\t}\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn (struct dentry *)cred;\n\tparent = dentry->d_parent;\n\tnfs_block_sillyrename(parent);\n\tstate = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tif (PTR_ERR(state) == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t}\n\t\tnfs_unblock_sillyrename(parent);\n\t\treturn (struct dentry *)state;\n\t}\n\tres = d_add_unique(dentry, igrab(state->inode));\n\tif (res != NULL)\n\t\tpath.dentry = res;\n\tnfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));\n\tnfs_unblock_sillyrename(parent);\n\tnfs4_intent_set_file(nd, &path, state);\n\treturn res;\n}", "target": 1}
{"code": "ShelfDelegate* Shell::GetShelfDelegate() {\n  if (!shelf_delegate_) {\n    shelf_model_.reset(new ShelfModel);\n    shelf_item_delegate_manager_.reset(\n        new ShelfItemDelegateManager(shelf_model_.get()));\n    shelf_delegate_.reset(delegate_->CreateShelfDelegate(shelf_model_.get()));\n    scoped_ptr<ShelfItemDelegate> controller(new AppListShelfItemDelegate);\n    int app_list_index = shelf_model_->GetItemIndexForType(TYPE_APP_LIST);\n    DCHECK_GE(app_list_index, 0);\n    ShelfID app_list_id = shelf_model_->items()[app_list_index].id;\n    DCHECK(app_list_id);\n    shelf_item_delegate_manager_->SetShelfItemDelegate(app_list_id,\n                                                       std::move(controller));\n    shelf_window_watcher_.reset(new ShelfWindowWatcher(\n        shelf_model_.get(), shelf_item_delegate_manager_.get()));\n  }\n  return shelf_delegate_.get();\n}", "target": 0}
{"code": "static int process_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\t struct timespec *tp)\n{\n\treturn posix_cpu_clock_get(PROCESS_CLOCK, tp);\n}", "target": 0}
{"code": "Status KernelAndDeviceOp::Run(\n    ScopedStepContainer* step_container, const EagerKernelArgs& inputs,\n    std::vector<EagerKernelRet>* outputs,\n    CancellationManager* cancellation_manager,\n    const absl::optional<EagerRemoteFunctionParams>& remote_func_params) {\n  OpKernelContext::Params params;\n  params.device = device_;\n  params.frame_iter = FrameAndIter(0, 0);\n  params.inputs = inputs.GetTensorValues();\n  params.op_kernel = kernel_.get();\n  params.resource_manager = device_->resource_manager();\n  params.input_alloc_attrs = &input_alloc_attrs_;\n  params.output_attr_array = output_alloc_attrs_.data();\n  params.function_library = flr_;\n  params.slice_reader_cache = &slice_reader_cache_;\n  params.rendezvous = rendezvous_;\n  OpExecutionState* op_execution_state = nullptr;\n  CancellationManager default_cancellation_manager;\n  if (cancellation_manager) {\n    params.cancellation_manager = cancellation_manager;\n  } else if (kernel_->is_deferred()) {\n    op_execution_state = new OpExecutionState;\n    params.cancellation_manager = &op_execution_state->cancellation_manager;\n    params.inc_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Ref();\n    };\n    params.dec_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Unref();\n    };\n  } else {\n    params.cancellation_manager = &default_cancellation_manager;\n  }\n  params.log_memory = log_memory_;\n  params.runner = get_runner();\n  params.step_container =\n      step_container == nullptr ? &step_container_ : step_container;\n  auto step_container_cleanup = gtl::MakeCleanup([step_container, this] {\n    if (step_container == nullptr) {\n      this->step_container_.CleanUp();\n    }\n  });\n  params.collective_executor =\n      collective_executor_ ? collective_executor_->get() : nullptr;\n  OpKernelContext context(&params);\n  {\n    port::ScopedFlushDenormal flush;\n    port::ScopedSetRound round(FE_TONEAREST);\n    profiler::AnnotatedTraceMe activity(\n        [&] { return kernel_->TraceString(context, false); },\n        profiler::TraceMeLevel::kInfo);\n    device_->Compute(kernel_.get(), &context);\n  }\n  if (op_execution_state != nullptr) {\n    op_execution_state->Unref();\n  }\n  if (!context.status().ok()) return context.status();\n  if (outputs != nullptr) {\n    outputs->clear();\n    for (int i = 0; i < context.num_outputs(); ++i) {\n      outputs->push_back(Tensor(*context.mutable_output(i)));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "Bool gf_prompt_has_input()\n{\n\treturn kbhit();\n}", "target": 0}
{"code": "char *uwsgi_expand_path(char *dir, int dir_len, char *ptr) {\n\tchar src[PATH_MAX + 1];\n\tmemcpy(src, dir, dir_len);\n\tsrc[dir_len] = 0;\n\tchar *dst = ptr;\n\tif (!dst)\n\t\tdst = uwsgi_malloc(PATH_MAX + 1);\n\tif (!realpath(src, dst)) {\n\t\tuwsgi_error_realpath(src);\n\t\tif (!ptr)\n\t\t\tfree(dst);\n\t\treturn NULL;\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "blkid_partlist blkid_probe_get_partlist(blkid_probe pr)\n{\n\treturn (blkid_partlist) pr->chains[BLKID_CHAIN_PARTS].data;\n}", "target": 0}
{"code": "static int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = ops;\n\tsock_init_data(sock, sk);\n\tsk->sk_family = PF_IEEE802154;\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}", "target": 1}
{"code": "void CLua::_getregistry(lua_State *ls, const char *name)\n{\n    lua_pushstring(ls, name);\n    lua_gettable(ls, LUA_REGISTRYINDEX);\n}", "target": 0}
{"code": "static const char *req_unparsed_uri_field(request_rec *r)\n{\n    return r->unparsed_uri;\n}", "target": 0}
{"code": "static inline bool mmget_still_valid(struct mm_struct *mm)\n{\n\treturn likely(!mm->core_state);\n}", "target": 0}
{"code": "struct usbredirparser *usbredirparser_create(void)\n{\n    return calloc(1, sizeof(struct usbredirparser_priv));\n}", "target": 0}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (WriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (WriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": "static void vmx_disable_intercept_for_msr(u32 msr, bool longmode_only)\n{\n\tif (!longmode_only)\n\t\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy,\n\t\t\t\t\t\tmsr, MSR_TYPE_R | MSR_TYPE_W);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode,\n\t\t\t\t\t\tmsr, MSR_TYPE_R | MSR_TYPE_W);\n}", "target": 0}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\tassert(game_config::path.empty() == false);\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tif (ends_with(filename, \".pbl\")) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\treturn result;\n}", "target": 1}
{"code": "date_s__iso8601(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, opt;\n    rb_scan_args(argc, argv, \"1:\", &str, &opt);\n    check_limit(str, opt);\n    return date__iso8601(str);\n}", "target": 0}
{"code": "void client_reset(t_client *client)\n{\n\tchar *hash;\n\tchar *msg;\n\tchar *cidinfo;\n\tdebug(LOG_DEBUG, \"Resetting client [%s]\", client->mac);\n\tclient->counters.incoming = 0;\n\tclient->counters.outgoing = 0;\n\tclient->counters.last_updated = time(NULL);\n\tclient->session_start = 0;\n\tclient->session_end = 0;\n\thash = safe_calloc(STATUS_BUF);\n\tclient->token = safe_calloc(STATUS_BUF);\n\tsafe_snprintf(client->token, STATUS_BUF, \"%04hx%04hx\", rand16(), rand16());\n\thash_str(hash, STATUS_BUF, client->token);\n\tclient->hid = safe_strdup(hash);\n\tfree(hash);\n\tclient->custom = safe_calloc(MID_BUF);\n\tclient->client_type = safe_calloc(STATUS_BUF);\n\tif (client->cid) {\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t\tclient->cid = safe_calloc(SMALL_BUF);\n\t}\n}", "target": 1}
{"code": "static std::string ToHtmlTableHeader(Network* network) {\n  std::string str;\n  if (network->type() == TYPE_WIFI || network->type() == TYPE_CELLULAR) {\n    str += WrapWithTH(\"Name\") + WrapWithTH(\"Auto-Connect\") +\n        WrapWithTH(\"Strength\");\n    if (network->type() == TYPE_WIFI)\n      str += WrapWithTH(\"Encryption\") + WrapWithTH(\"Passphrase\") +\n          WrapWithTH(\"Identity\") + WrapWithTH(\"Certificate\");\n  }\n  str += WrapWithTH(\"State\") + WrapWithTH(\"Error\") + WrapWithTH(\"IP Address\");\n  return str;\n}", "target": 0}
{"code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  \n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  \n  va_end(argp);\n  if (isLua(ci))  \n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}", "target": 1}
{"code": "onigenc_get_right_adjust_char_head(OnigEncoding enc, const UChar* start, const UChar* s, const UChar* end)\n{\n  UChar* p = ONIGENC_LEFT_ADJUST_CHAR_HEAD(enc, start, s, end);\n  if (p < s) {\n    p += enclen(enc, p, end);\n  }\n  return p;\n}", "target": 0}
{"code": "int32_t cli_bcapi_extract_new(struct cli_bc_ctx *ctx, int32_t id)\n{\n    cli_ctx *cctx;\n    int res = -1;\n    cli_event_count(EV, BCEV_EXTRACTED);\n    cli_dbgmsg(\"previous tempfile had %u bytes\\n\", ctx->written);\n    if (!ctx->written)\n\treturn 0;\n    if (ctx->ctx && cli_updatelimits(ctx->ctx, ctx->written))\n\treturn -1;\n    ctx->written = 0;\n    lseek(ctx->outfd, 0, SEEK_SET);\n    cli_dbgmsg(\"bytecode: scanning extracted file %s\\n\", ctx->tempfile);\n    cctx = (cli_ctx*)ctx->ctx;\n    if (cctx) {\n\tcli_file_t current = cctx->container_type;\n\tif (ctx->containertype != CL_TYPE_ANY)\n\t    cctx->container_type = ctx->containertype;\n\tres = cli_magic_scandesc(ctx->outfd, cctx);\n\tcctx->container_type = current;\n\tif (res == CL_VIRUS) {\n\t    if (cctx->virname)\n\t\tctx->virname = *cctx->virname;\n\t    ctx->found = 1;\n\t}\n    }\n    if ((cctx && cctx->engine->keeptmp) ||\n\t(ftruncate(ctx->outfd, 0) == -1)) {\n\tclose(ctx->outfd);\n\tif (!(cctx && cctx->engine->keeptmp) && ctx->tempfile)\n\t    cli_unlink(ctx->tempfile);\n\tfree(ctx->tempfile);\n\tctx->tempfile = NULL;\n\tctx->outfd = 0;\n    }\n    cli_dbgmsg(\"bytecode: extracting new file with id %u\\n\", id);\n    return res;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_set_error_verbosity)\n{\n\tzval *pgsql_link = NULL;\n\tzend_long verbosity;\n\tint id = -1, argc = ZEND_NUM_ARGS();\n\tPGconn *pgsql;\n\tif (argc == 1) {\n\t\tif (zend_parse_parameters(argc, \"l\", &verbosity) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tid = FETCH_DEFAULT_LINK();\n\t\tCHECK_DEFAULT_LINK(id);\n\t} else {\n\t\tif (zend_parse_parameters(argc, \"rl\", &pgsql_link, &verbosity) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (pgsql_link == NULL && id == -1) {\n\t\tRETURN_FALSE;\n\t}\t\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tif (verbosity & (PQERRORS_TERSE|PQERRORS_DEFAULT|PQERRORS_VERBOSE)) {\n\t\tRETURN_LONG(PQsetErrorVerbosity(pgsql, verbosity));\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, GteWithLHSFieldPathMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: {$gte: ['$x', 3]}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 3)));\n    ASSERT_TRUE(matches(BSON(\"x\" << 10)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 1)));\n}", "target": 0}
{"code": " int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n {\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n \t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n \t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n \t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}", "target": 1}
{"code": "next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}", "target": 1}
{"code": "int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\tpvclock_update_vm_gtod_copy(kvm);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);\n\treturn 0;\n}", "target": 0}
{"code": "  bool IsInitialized() { return state_ == INITIALIZED; }", "target": 0}
{"code": "void __export pptp_get_stat(unsigned int **starting, unsigned int **active)\n{\n\t*starting = &stat_starting;\n\t*active = &stat_active;\n}", "target": 0}
{"code": "void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  \n  int nextra = actual - nfixparams;  \n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  setobjs2s(L, L->top++, ci->func);\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  \n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);\n}", "target": 1}
{"code": "const char* NavigatorServiceWorker::supplementName()\n{\n     return \"NavigatorServiceWorker\";\n }", "target": 0}
{"code": "validate_commit_metadata (GVariant   *commit_data,\n                          const char *ref,\n                          const char *required_metadata,\n                          gsize       required_metadata_size,\n                          GError   **error)\n{\n  g_autoptr(GVariant) commit_metadata = NULL;\n  g_autoptr(GVariant) xa_metadata_v = NULL;\n  const char *xa_metadata = NULL;\n  gsize xa_metadata_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  if (commit_metadata != NULL)\n    {\n      xa_metadata_v = g_variant_lookup_value (commit_metadata,\n                                              \"xa.metadata\",\n                                              G_VARIANT_TYPE_STRING);\n      if (xa_metadata_v)\n        xa_metadata = g_variant_get_string (xa_metadata_v, &xa_metadata_size);\n    }\n  if (xa_metadata == NULL ||\n      xa_metadata_size != required_metadata_size ||\n      memcmp (xa_metadata, required_metadata, xa_metadata_size) != 0)\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                   _(\"Commit metadata for %s not matching expected metadata\"), ref);\n      return FALSE;\n    }\n  return TRUE;\n}", "target": 0}
{"code": "void ewk_view_menubar_visible_set(Evas_Object* ewkView, bool visible)\n{\n    DBG(\"ewkView=%p (visible=%d)\", ewkView, !!visible);\n    evas_object_smart_callback_call(ewkView, \"menubar,visible,set\", &visible);\n}", "target": 0}
{"code": "static uint16 TIFFClampDoubleToUInt16( double val )\n{\n    if( val < 0 )\n        return 0;\n    if( val > 65535 || val != val )\n        return 65535;\n    return (uint16)val;\n}", "target": 0}
{"code": "static RzList *classes_from_symbols(RzBinFile *bf) {\n\tRzBinSymbol *sym;\n\tRzListIter *iter;\n\trz_list_foreach (bf->o->symbols, iter, sym) {\n\t\tif (sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *dn = sym->dname;\n\t\t\tchar *fn = swiftField(dn, cn);\n\t\t\tif (fn) {\n\t\t\t\tRzBinField *f = rz_bin_field_new(sym->paddr, sym->vaddr, sym->size, fn, NULL, NULL, false);\n\t\t\t\trz_list_append(c->fields, f);\n\t\t\t\tfree(fn);\n\t\t\t} else {\n\t\t\t\tchar *mn = strstr(dn, \"..\");\n\t\t\t\tif (!mn) {\n\t\t\t\t\tmn = strstr(dn, cn);\n\t\t\t\t\tif (mn && mn[strlen(cn)] == '.') {\n\t\t\t\t\t\trz_list_append(c->methods, sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn bf->o->classes;\n}", "target": 1}
{"code": "void RemoteFsDevice::setup()\n{\n    details.load(details.name);\n    configured=details.configured;\n    if (isConnected()) {\n        readOpts(settingsFileName(), opts, true);\n    }\n    load();\n}", "target": 0}
{"code": "static inline void nvme_set_timestamp(NvmeCtrl *n, uint64_t ts)\n{\n    trace_pci_nvme_setfeat_timestamp(ts);\n    n->host_timestamp = le64_to_cpu(ts);\n    n->timestamp_set_qemu_clock_ms = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);\n}", "target": 0}
{"code": "void shm_exit_ns(struct ipc_namespace *ns)\n{\n\tfree_ipcs(ns, &shm_ids(ns), do_shm_rmid);\n\tidr_destroy(&ns->ids[IPC_SHM_IDS].ipcs_idr);\n}", "target": 0}
{"code": "int\nPerl_re_printf(pTHX_ const char *fmt, ...)\n{\n    va_list ap;\n    int result;\n    PerlIO *f= Perl_debug_log;\n    PERL_ARGS_ASSERT_RE_PRINTF;\n    va_start(ap, fmt);\n    result = PerlIO_vprintf(f, fmt, ap);\n    va_end(ap);\n    return result;", "target": 0}
{"code": "kvp_respond_to_host(char *key, char *value, int error)\n{\n\tstruct hv_kvp_msg  *kvp_msg;\n\tstruct hv_kvp_msg_enumerate  *kvp_data;\n\tchar\t*key_name;\n\tstruct icmsg_hdr *icmsghdrp;\n\tint\tkeylen, valuelen;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\tif (!kvp_transaction.active) {\n\t\tpr_warn(\"KVP: Transaction not active\\n\");\n\t\treturn;\n\t}\n\tbuf_len = kvp_transaction.recv_len;\n\tchannel = kvp_transaction.recv_channel;\n\treq_id = kvp_transaction.recv_req_id;\n\tkvp_transaction.active = false;\n\tif (channel->onchannel_callback == NULL)\n\t\treturn;\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\tkvp_msg = (struct hv_kvp_msg *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr) +\n\t\t\tsizeof(struct icmsg_hdr)];\n\tkvp_data = &kvp_msg->kvp_data;\n\tkey_name = key;\n\tif (error) {\n\t\ticmsghdrp->status = HV_E_FAIL;\n\t\tgoto response_done;\n\t}\n\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name),\n\t\t\t\t(wchar_t *)kvp_data->data.key);\n\tkvp_data->data.key_size = 2*(keylen + 1); \n\tvaluelen = utf8s_to_utf16s(value, strlen(value),\n\t\t\t\t(wchar_t *)kvp_data->data.value);\n\tkvp_data->data.value_size = 2*(valuelen + 1); \n\tkvp_data->data.value_type = REG_SZ; \n\ticmsghdrp->status = HV_S_OK;\nresponse_done:\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n}", "target": 1}
{"code": "ldbm_txn_ruv_modify_context( Slapi_PBlock *pb, modify_context *mc )\n{\n    char *uniqueid = NULL;\n    backend *be;\n    Slapi_Mods *smods = NULL;\n    struct backentry *bentry;\n    entry_address bentry_addr;\n    IFP fn = NULL;\n    int rc = 0;\n    back_txn txn = {NULL};\n    slapi_pblock_get(pb, SLAPI_TXN_RUV_MODS_FN, (void *)&fn);\n    slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);\n    if (NULL == fn) {\n        return (0);\n    }\n    rc = (*fn)(pb, &uniqueid, &smods);\n    if (1 != rc || NULL == smods || NULL == uniqueid) {\n        return (rc);\n    }\n    slapi_pblock_get( pb, SLAPI_BACKEND, &be);\n    bentry_addr.sdn = NULL;\n    bentry_addr.udn = NULL;\n    bentry_addr.uniqueid = uniqueid;\n    bentry = find_entry2modify_only( pb, be, &bentry_addr, &txn );\n    if (NULL == bentry) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to retrieve and lock RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        goto done;\n    }\n    modify_init( mc, bentry );\n    if (modify_apply_mods_ignore_error( mc, smods, LDAP_TYPE_OR_VALUE_EXISTS )) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to apply updates to RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        modify_term( mc, be );\n    }\ndone:\n    slapi_ch_free_string( &uniqueid );\n    return (rc);\n}", "target": 1}
{"code": "xsltNewKeyDef(const xmlChar *name, const xmlChar *nameURI) {\n    xsltKeyDefPtr cur;\n    cur = (xsltKeyDefPtr) xmlMalloc(sizeof(xsltKeyDef));\n    if (cur == NULL) {\n\txsltTransformError(NULL, NULL, NULL,\n\t\t\"xsltNewKeyDef : malloc failed\\n\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xsltKeyDef));\n    if (name != NULL)\n\tcur->name = xmlStrdup(name);\n    if (nameURI != NULL)\n\tcur->nameURI = xmlStrdup(nameURI);\n    cur->nsList = NULL;\n    return(cur);\n}", "target": 0}
{"code": "  explicit ReverseSequenceOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n  }", "target": 1}
{"code": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n \tstatic const struct dentry_operations ops = {\n \t\t.d_dname\t= simple_dname,\n \t};\n\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);\n }", "target": 1}
{"code": "GLES2DecoderImpl::GLES2DecoderImpl(ContextGroup* group)\n    : GLES2Decoder(group),\n      error_bits_(0),\n      util_(0),  \n      pack_alignment_(4),\n      unpack_alignment_(4),\n      attrib_0_buffer_id_(0),\n      attrib_0_size_(0),\n      active_texture_unit_(0),\n      black_2d_texture_id_(0),\n      black_cube_texture_id_(0),\n      clear_red_(0),\n      clear_green_(0),\n      clear_blue_(0),\n      clear_alpha_(0),\n      mask_red_(true),\n      mask_green_(true),\n      mask_blue_(true),\n      mask_alpha_(true),\n      clear_stencil_(0),\n      mask_stencil_front_(-1),\n      mask_stencil_back_(-1),\n      clear_depth_(1.0f),\n      mask_depth_(true),\n      enable_scissor_test_(false),\n      anti_aliased_(false),\n      use_shader_translator_(true),\n      vertex_compiler_(NULL),\n      fragment_compiler_(NULL),\n      validators_(group->validators()),\n      depth24_stencil8_oes_supported_(false) {\n  attrib_0_value_.v[0] = 0.0f;\n  attrib_0_value_.v[1] = 0.0f;\n  attrib_0_value_.v[2] = 0.0f;\n  attrib_0_value_.v[3] = 1.0f;\n  if (gfx::GetGLImplementation() == gfx::kGLImplementationEGLGLES2 ||\n      gfx::GetGLImplementation() == gfx::kGLImplementationMockGL) {\n    use_shader_translator_ = false;\n  }\n}", "target": 0}
{"code": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\tblk_queue_make_request(q, blk_queue_bio);\n\tq->sg_reserved_size = INT_MAX;\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n \treturn -ENOMEM;\n }", "target": 1}
{"code": "int vcc_getsockopt(struct socket *sock, int level, int optname,\n\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct atm_vcc *vcc;\n\tint len;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (__SO_LEVEL_MATCH(optname, level) && len != __SO_SIZE(optname))\n\t\treturn -EINVAL;\n\tvcc = ATM_SD(sock);\n\tswitch (optname) {\n\tcase SO_ATMQOS:\n\t\tif (!test_bit(ATM_VF_HASQOS, &vcc->flags))\n\t\t\treturn -EINVAL;\n\t\treturn copy_to_user(optval, &vcc->qos, sizeof(vcc->qos))\n\t\t\t? -EFAULT : 0;\n\tcase SO_SETCLP:\n\t\treturn put_user(vcc->atm_options & ATM_ATMOPT_CLP ? 1 : 0,\n\t\t\t\t(unsigned long __user *)optval) ? -EFAULT : 0;\n\tcase SO_ATMPVC:\n\t{\n\t\tstruct sockaddr_atmpvc pvc;\n \t\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n \t\t\treturn -ENOTCONN;\n \t\tpvc.sap_family = AF_ATMPVC;\n \t\tpvc.sap_addr.itf = vcc->dev->number;\n \t\tpvc.sap_addr.vpi = vcc->vpi;\n\t\tpvc.sap_addr.vci = vcc->vci;\n\t\treturn copy_to_user(optval, &pvc, sizeof(pvc)) ? -EFAULT : 0;\n\t}\n\tdefault:\n\t\tif (level == SOL_SOCKET)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tif (!vcc->dev || !vcc->dev->ops->getsockopt)\n\t\treturn -EINVAL;\n\treturn vcc->dev->ops->getsockopt(vcc, level, optname, optval, len);\n}", "target": 1}
{"code": "static int vmx_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn 0;\n\tif (!cpu_has_virtual_nmis() && to_vmx(vcpu)->soft_vnmi_blocked)\n\t\treturn 0;\n\treturn\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t  (GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI\n\t\t   | GUEST_INTR_STATE_NMI));\n}", "target": 0}
{"code": "static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            return;\n        }\n        Jsi_DSAppendLen(dStr, zBlob, bytes);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_DSAppend(dStr, str?str:\"\", NULL);\n}", "target": 1}
{"code": "static int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n \t\treturn -EOPNOTSUPP;\n \taddr &= KVM_PIT_CHANNEL_MASK;\n \ts = &pit_state->channels[addr];\n \tmutex_lock(&pit_state->lock);\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}", "target": 1}
{"code": "int ssl_init(void) { \n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS |\n        OPENSSL_INIT_LOAD_CRYPTO_STRINGS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#else\n    OPENSSL_config(NULL);\n    SSL_load_error_strings();\n    SSL_library_init();\n#endif\n    index_ssl_cli=SSL_get_ex_new_index(0,\n        \"CLI pointer\", NULL, NULL, NULL);\n    index_ssl_ctx_opt=SSL_CTX_get_ex_new_index(0,\n        \"SERVICE_OPTIONS pointer\", NULL, NULL, NULL);\n    index_session_authenticated=SSL_SESSION_get_ex_new_index(0,\n        \"session authenticated\", NULL, NULL, NULL);\n    index_session_connect_address=SSL_SESSION_get_ex_new_index(0,\n        \"session connect address\", NULL, cb_dup_addr, cb_free_addr);\n    if(index_ssl_cli<0 || index_ssl_ctx_opt<0 ||\n            index_session_authenticated<0 ||\n            index_session_connect_address<0) {\n        s_log(LOG_ERR, \"Application specific data initialization failed\");\n        return 1;\n    }\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_load_builtin_engines();\n#endif\n#ifndef OPENSSL_NO_DH\n    dh_params=get_dh2048();\n    if(!dh_params) {\n        s_log(LOG_ERR, \"Failed to get default DH parameters\");\n        return 1;\n    }\n#endif \n    return 0;\n}", "target": 1}
{"code": " int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n {\n \tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n \tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n\t\t\t\t\t hashbin_lock_depth++);\n\t}\n \tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\t\twhile (queue ) {\n\t\t\tif (free_func)\n\t\t\t\t(*free_func)(queue);\n\t\t\tqueue = dequeue_first(\n\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n \t\t}\n \t}\n\thashbin->hb_current = NULL;\n \thashbin->magic = ~HB_MAGIC;\n\tif ( hashbin->hb_type & HB_LOCK) {\n \t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n#ifdef CONFIG_LOCKDEP\n\t\thashbin_lock_depth--;\n#endif\n\t}\n\tkfree(hashbin);\n\treturn 0;\n}", "target": 1}
{"code": "static inline pte_t pte_mknonnuma(pte_t pte)\n{\n\treturn pte;\n}", "target": 0}
{"code": "static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) {\n\tRAnalRef *xref;\n\tRListIter *xrefIter;\n\tif (!curAddress || curAddress == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (curAddress && !vtable_is_value_in_text_section (context, curAddress, NULL)) {\n\t\treturn false;\n\t}\n\tRList *xrefs = r_anal_xrefs_get (context->anal, curAddress);\n\tif (r_list_empty (xrefs)) {\n\t\tr_list_free (xrefs);\n\t\treturn false;\n\t}\n\tr_list_foreach (xrefs, xrefIter, xref) {\n\t\tif (vtable_addr_in_text_section (context, xref->addr)) {\n\t\t\tut8 buf[VTABLE_BUFF_SIZE];\n\t\t\tcontext->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof(buf));\n\t\t\tRAnalOp analop = {0};\n\t\t\tr_anal_op (context->anal, &analop, xref->addr, buf, sizeof(buf), R_ANAL_OP_MASK_BASIC);\n\t\t\tif (analop.type == R_ANAL_OP_TYPE_MOV\n\t\t\t\t|| analop.type == R_ANAL_OP_TYPE_LEA) {\n\t\t\t\tr_list_free (xrefs);\n\t\t\t\tr_anal_op_fini (&analop);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_anal_op_fini (&analop);\n\t\t}\n\t}\n\tr_list_free (xrefs);\n\treturn false;\n}", "target": 1}
{"code": "bool HHVM_FUNCTION(imagesettile, const Resource& image, const Resource& tile) {\n  gdImagePtr im = get_valid_image_resource(image);\n  if (!im) return false;\n  gdImagePtr til = get_valid_image_resource(tile);\n  if (!til) return false;\n  gdImageSetTile(im, til);\n  return true;\n}", "target": 0}
{"code": "_PUBLIC_ codepoint_t next_codepoint_handle_ext(\n\t\t\tstruct smb_iconv_handle *ic,\n\t\t\tconst char *str, size_t len,\n\t\t\tcharset_t src_charset,\n\t\t\tsize_t *bytes_consumed)\n{\n\tuint8_t buf[4];\n\tsmb_iconv_t descriptor;\n\tsize_t ilen_orig;\n\tsize_t ilen;\n        size_t olen;\n        char *outbuf;\n       if ((str[0] & 0x80) == 0) {\n                *bytes_consumed = 1;\n                return (codepoint_t)str[0];\n        }\n\t * This is OK as we only support codepoints up to 1M (U+100000)\n\t */\n\tilen_orig = MIN(len, 5);\n\tilen = ilen_orig;\n\tdescriptor = get_conv_handle(ic, src_charset, CH_UTF16);\n\tif (descriptor == (smb_iconv_t)-1) {\n\t\t*bytes_consumed = 1;\n\t\treturn INVALID_CODEPOINT;\n\t}\n\tolen = 2;\n\toutbuf = (char *)buf;\n\tsmb_iconv(descriptor, &str, &ilen, &outbuf, &olen);\n\tif (olen == 2) {\n\t\tolen = 4;\n\t\toutbuf = (char *)buf;\n\t\tsmb_iconv(descriptor,  &str, &ilen, &outbuf, &olen);\n\t\tif (olen == 4) {\n\t\t\t*bytes_consumed = 1;\n\t\t\treturn INVALID_CODEPOINT;\n\t\t}\n\t\tolen = 4 - olen;\n\t} else {\n\t\tolen = 2 - olen;\n\t}\n\t*bytes_consumed = ilen_orig - ilen;\n\tif (olen == 2) {\n\t\treturn (codepoint_t)SVAL(buf, 0);\n\t}\n\tif (olen == 4) {\n\t\treturn (codepoint_t)0x10000 +\n\t\t\t(buf[2] | ((buf[3] & 0x3)<<8) |\n\t\t\t (buf[0]<<10) | ((buf[1] & 0x3)<<18));\n\t}\n\treturn INVALID_CODEPOINT;\n}", "target": 1}
{"code": "NavigatorServiceWorker* NavigatorServiceWorker::toNavigatorServiceWorker(Navigator& navigator)\n{\n    return static_cast<NavigatorServiceWorker*>(HeapSupplement<Navigator>::from(navigator, supplementName()));\n}", "target": 0}
{"code": "yy_symbol_print (FILE *yyo,\n                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, parm);\n  YYFPRINTF (yyo, \")\");\n}", "target": 1}
{"code": "void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\tkvm_put_guest_xcr0(vcpu);\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\tfpu_restore_checking(&vcpu->arch.guest_fpu);\n\ttrace_kvm_fpu(1);\n}", "target": 0}
{"code": "ScriptProcessorNode* BaseAudioContext::createScriptProcessor(\n    uint32_t buffer_size,\n    uint32_t number_of_input_channels,\n    ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  return ScriptProcessorNode::Create(*this, buffer_size,\n                                     number_of_input_channels, exception_state);\n}", "target": 0}
{"code": "PHP_FUNCTION(xsl_xsltprocessor_set_security_prefs)\n{\n\tzval *id;\n\txsl_object *intern;\n\tlong securityPrefs, oldSecurityPrefs;\n\tDOM_GET_THIS(id);\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &securityPrefs) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n\toldSecurityPrefs = intern->securityPrefs;\n\tintern->securityPrefs = securityPrefs;\n\tintern->securityPrefsSet = 1;\n\tRETURN_LONG(oldSecurityPrefs);\n}", "target": 0}
{"code": "void IndexedDBDatabase::RenameIndex(IndexedDBTransaction* transaction,\n                                    int64_t object_store_id,\n                                    int64_t index_id,\n                                    const base::string16& new_name) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::RenameIndex\", \"txn.id\", transaction->id());\n  DCHECK_EQ(transaction->mode(),\n            blink::mojom::IDBTransactionMode::VersionChange);\n  if (!ValidateObjectStoreIdAndIndexId(object_store_id, index_id))\n    return;\n  IndexedDBIndexMetadata& index_metadata =\n      metadata_.object_stores[object_store_id].indexes[index_id];\n  base::string16 old_name;\n  Status s = metadata_coding_->RenameIndex(\n      transaction->BackingStoreTransaction()->transaction(),\n      transaction->database()->id(), object_store_id, new_name, &old_name,\n      &index_metadata);\n  if (!s.ok()) {\n    ReportErrorWithDetails(s, \"Internal error renaming index.\");\n    return;\n  }\n  DCHECK_EQ(index_metadata.name, new_name);\n  transaction->ScheduleAbortTask(\n      base::BindOnce(&IndexedDBDatabase::RenameIndexAbortOperation, this,\n                     object_store_id, index_id, std::move(old_name)));\n}", "target": 0}
{"code": "    int CommentValue::read(const byte* buf, size_t len, ByteOrder byteOrder)\n    {\n        byteOrder_ = byteOrder;\n        return StringValueBase::read(buf, len, byteOrder);\n    }", "target": 0}
{"code": "xfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\tuint32_t\t\tlen,\n\tuint32_t\t\tflags)\n{\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= XFS_I(inode),\n\t\t.attr_filter\t= xfs_attr_filter(flags),\n\t\t.attr_flags\t= xfs_attr_flags(flags),\n\t\t.name\t\t= name,\n\t\t.namelen\t= strlen(name),\n\t};\n\tint\t\t\terror;\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (ubuf) {\n\t\tif (len > XFS_XATTR_SIZE_MAX)\n\t\t\treturn -EINVAL;\n\t\targs.value = memdup_user(ubuf, len);\n\t\tif (IS_ERR(args.value))\n\t\t\treturn PTR_ERR(args.value);\n\t\targs.valuelen = len;\n\t}\n\terror = xfs_attr_set(&args);\n\tif (!error && (flags & XFS_IOC_ATTR_ROOT))\n\t\txfs_forget_acl(inode, name);\n\tkfree(args.value);\n\treturn error;\n}", "target": 0}
{"code": "join_read_last(JOIN_TAB *tab)\n{\n  TABLE *table=tab->table;\n  int error= 0;\n  DBUG_ENTER(\"join_read_last\");\n  DBUG_ASSERT(table->no_keyread ||\n              !table->covering_keys.is_set(tab->index) ||\n              table->file->keyread == tab->index);\n  tab->table->status=0;\n  tab->read_record.read_record_func= join_read_prev;\n  tab->read_record.table=table;\n  if (!table->file->inited)\n    error= table->file->ha_index_init(tab->index, 1);\n  if (likely(!error))\n    error= table->file->prepare_index_scan();\n  if (unlikely(error) ||\n      unlikely(error= tab->table->file->ha_index_last(tab->table->record[0])))\n    DBUG_RETURN(report_error(table, error));\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": " ppp_hdlc(netdissect_options *ndo,\n          const u_char *p, int length)\n {\n\tu_char *b, *s, *t, c;\n \tint i, proto;\n \tconst void *se;\n         if (length <= 0)\n                 return;\n\tb = (uint8_t *)malloc(length);\n \tif (b == NULL)\n \t\treturn;\n\tfor (s = (u_char *)p, t = b, i = length; i > 0; i--) {\n \t\tc = *s++;\n \t\tif (c == 0x7d) {\n\t\t\tif (i > 1) {\n\t\t\t\ti--;\n\t\t\t\tc = *s++ ^ 0x20;\n\t\t\t} else\n\t\t\t\tcontinue;\n \t\t}\n \t\t*t++ = c;\n \t}\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n        if (length < 1)\n                goto trunc;\n        proto = *b; \n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: \n\t\tbreak;\n        }\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); \n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); \n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: \n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}", "target": 1}
{"code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  int64_t nnz = a_indices->dim_size(0);\n  int64_t ndims = a_indices->dim_size(1);\n  if (a_values->dim_size(0) != nnz) {\n    return errors::InvalidArgument(\"Dimensions \", nnz, \" and \",\n                                   a_values->dim_size(0),\n                                   \" are not compatible\");\n  }\n  if (a_shape->dim_size(0) != ndims) {\n    return errors::InvalidArgument(\"Dimensions \", ndims, \" and \",\n                                   a_shape->dim_size(0), \" are not compatible\");\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  const auto a_indices_mat = a_indices->flat_inner_dims<Index>();\n  for (int64_t zidx = 0; zidx < nnz; ++zidx) {\n    for (int64_t didx = 0; didx < ndims; ++didx) {\n      const Index idx = a_indices_mat(zidx, didx);\n      if (idx < 0 || idx >= a_shape_flat(didx)) {\n        return errors::InvalidArgument(\n            \"Sparse tensor has an invalid index on dimension \", didx,\n            \": \"\n            \"a_indices(\",\n            zidx, \",\", didx, \") = \", idx,\n            \", dense tensor shape: \", a_shape_flat);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "int get_compat_itimerspec(struct itimerspec *dst,\n\t\t\t  const struct compat_itimerspec __user *src)\n{\n\tif (__compat_get_timespec(&dst->it_interval, &src->it_interval) ||\n\t    __compat_get_timespec(&dst->it_value, &src->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "void blk_mq_kick_requeue_list(struct request_queue *q)\n{\n\tkblockd_schedule_work(&q->requeue_work);\n}", "target": 0}
{"code": "rt6_print(netdissect_options *ndo, register const u_char *bp, const u_char *bp2 _U_)\n{\n\tregister const struct ip6_rthdr *dp;\n\tregister const struct ip6_rthdr0 *dp0;\n\tregister const u_char *ep;\n\tint i, len;\n \tregister const struct in6_addr *addr;\n \tdp = (const struct ip6_rthdr *)bp;\n\tlen = dp->ip6r_len;\n \tep = ndo->ndo_snapend;\n \tND_TCHECK(dp->ip6r_segleft);\n \tND_PRINT((ndo, \"srcrt (len=%d\", dp->ip6r_len));\t\n \tND_PRINT((ndo, \", type=%d\", dp->ip6r_type));\n \tND_PRINT((ndo, \", segleft=%d\", dp->ip6r_segleft));\n\tswitch (dp->ip6r_type) {\n\tcase IPV6_RTHDR_TYPE_0:\n\tcase IPV6_RTHDR_TYPE_2:\t\t\t\n\t\tdp0 = (const struct ip6_rthdr0 *)dp;\n\t\tND_TCHECK(dp0->ip6r0_reserved);\n\t\tif (dp0->ip6r0_reserved || ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \", rsv=0x%0x\",\n\t\t\t    EXTRACT_32BITS(&dp0->ip6r0_reserved)));\n\t\t}\n\t\tif (len % 2 == 1)\n\t\t\tgoto trunc;\n\t\tlen >>= 1;\n\t\taddr = &dp0->ip6r0_addr[0];\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif ((const u_char *)(addr + 1) > ep)\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \", [%d]%s\", i, ip6addr_string(ndo, addr)));\n\t\t\taddr++;\n\t\t}\n\t\tND_PRINT((ndo, \") \"));\n\t\treturn((dp0->ip6r0_len + 1) << 3);\n\t\tbreak;\n\tdefault:\n\t\tgoto trunc;\n\t\tbreak;\n\t}\n trunc:\n\tND_PRINT((ndo, \"[|srcrt]\"));\n\treturn -1;\n}", "target": 1}
{"code": "d_lite_sunday_p(VALUE self)\n{\n    get_d1(self);\n    return f_boolcast(m_wday(dat) == 0);\n}", "target": 0}
{"code": "storageConnectStoragePoolEventDeregisterAny(virConnectPtr conn,\n                                            int callbackID)\n{\n    if (virConnectStoragePoolEventDeregisterAnyEnsureACL(conn) < 0)\n        return -1;\n    if (virObjectEventStateDeregisterID(conn,\n                                        driver->storageEventState,\n                                        callbackID, true) < 0)\n        return -1;\n    return 0;\n}", "target": 0}
{"code": "struct bio *bio_map_kern(struct request_queue *q, void *data, unsigned int len,\n\t\t\t gfp_t gfp_mask)\n{\n\tunsigned long kaddr = (unsigned long)data;\n\tunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = kaddr >> PAGE_SHIFT;\n\tconst int nr_pages = end - start;\n\tint offset, i;\n\tstruct bio *bio;\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\toffset = offset_in_page(kaddr);\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunsigned int bytes = PAGE_SIZE - offset;\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\t\tif (bio_add_pc_page(q, bio, virt_to_page(data), bytes,\n\t\t\t\t    offset) < bytes) {\n\t\t\tbio_put(bio);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdata += bytes;\n\t\tlen -= bytes;\n\t\toffset = 0;\n\t}\n\tbio->bi_end_io = bio_map_kern_endio;\n\treturn bio;\n}", "target": 0}
{"code": "sg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\tsrp->data.cmd_opcode = cmnd[0];\t\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n \t\treturn k;\t\n \t}\n \tif (atomic_read(&sdp->detaching)) {\n\t\tif (srp->bio)\n \t\t\tblk_end_request_all(srp->rq, -EIO);\n \t\tsg_finish_rem_req(srp);\n \t\treturn -ENODEV;\n \t}\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); \n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}", "target": 1}
{"code": " */\nstatic struct sk_buff *napi_frags_skb(struct napi_struct *napi)\n{\n\tstruct sk_buff *skb = napi->skb;\n\tconst struct ethhdr *eth;\n\tunsigned int hlen = sizeof(*eth);\n\tnapi->skb = NULL;\n\tskb_reset_mac_header(skb);\n\tskb_gro_reset_offset(skb);\n\teth = skb_gro_header_fast(skb, 0);\n\tif (unlikely(skb_gro_header_hard(skb, hlen))) {\n\t\teth = skb_gro_header_slow(skb, hlen, 0);\n\t\tif (unlikely(!eth)) {\n\t\t\tnet_warn_ratelimited(\"%s: dropping impossible skb from %s\\n\",\n\t\t\t\t\t     __func__, napi->dev->name);\n\t\t\tnapi_reuse_skb(napi, skb);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tgro_pull_from_frag0(skb, hlen);\n\t\tNAPI_GRO_CB(skb)->frag0 += hlen;\n\t\tNAPI_GRO_CB(skb)->frag0_len -= hlen;\n\t}\n\t__skb_pull(skb, hlen);\n\tskb->protocol = eth->h_proto;\n\treturn skb;", "target": 1}
{"code": "static void encode_share_access(struct xdr_stream *xdr, int open_flags)\n {\n \t__be32 *p;\n \tRESERVE_SPACE(8);\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n \t\tcase FMODE_READ:\n \t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n \t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n \t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n \t\t\tbreak;\n \t\tdefault:\n\t\t\tBUG();\n \t}\n \tWRITE32(0);\t\t\n }", "target": 1}
{"code": "set_string (char **strp, const char *value)\n{\n\tif (*strp)\n\t\tfree (*strp);\n\t*strp = value ? strdup (value) : NULL;\n}", "target": 0}
{"code": "void WebContents::RemoveCreatedCallback(const CreatedCallback& callback) {\n  for (size_t i = 0; i < g_created_callbacks.Get().size(); ++i) {\n    if (g_created_callbacks.Get().at(i).Equals(callback)) {\n      g_created_callbacks.Get().erase(g_created_callbacks.Get().begin() + i);\n      return;\n    }\n  }\n}", "target": 0}
{"code": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n \tstruct netlink_callback *cb;\n \tstruct sk_buff *skb = NULL;\n \tstruct nlmsghdr *nlh;\n \tint len, err = -ENOBUFS;\n \tint alloc_min_size;\n \tint alloc_size;\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL |\n\t\t\t\t\t    __GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n\tnetlink_skb_set_owner_r(skb, sk);\n\tlen = cb->dump(skb, cb);\n\tif (len > 0) {\n\t\tmutex_unlock(nlk->cb_mutex);\n\t\tif (sk_filter(sk, skb))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\t__netlink_sendskb(sk, skb);\n\t\treturn 0;\n\t}\n\tnlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);\n\tif (!nlh)\n\t\tgoto errout_skb;\n\tnl_dump_check_consistent(cb, nlh);\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\tif (cb->done)\n \t\tcb->done(cb);\n \tnlk->cb_running = false;\n \tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(cb->module);\n\tconsume_skb(cb->skb);\n \treturn 0;\n errout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 1}
{"code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n\tint i, count = 0;\n\tmemset(outbuf, 0, outlen);\n\tin++;\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\twhile (octets_left) {\n\t\tint bits_to_go;\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}", "target": 1}
{"code": "t1mac_output_ascii(char *s, int len)\n{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}", "target": 1}
{"code": "static int hexagon_v6_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tHexInsn hi = {0};;\n\tut32 data = 0;\n\tdata = r_read_le32 (buf);\n\tint size = hexagon_disasm_instruction (data, &hi, (ut32) addr);\n\top->size = size;\n\tif (size <= 0) {\n\t\treturn size;\n\t}\n\top->addr = addr;\n\treturn hexagon_anal_instruction (&hi, op);\n}", "target": 1}
{"code": "static int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(fud->fc);\n\tint rc;\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n \t\tunregister_chrdev_region(cc->cdev->dev, 1);\n \t\tcdev_del(cc->cdev);\n \t}\n \trc = fuse_dev_release(inode, file);\t\n\treturn rc;\n}", "target": 1}
{"code": "bool Virtual_tmp_table::add(List<Spvar_definition> &field_list)\n{\n  Spvar_definition *cdef;            \n  List_iterator_fast<Spvar_definition> it(field_list);\n  DBUG_ENTER(\"Virtual_tmp_table::add\");\n  while ((cdef= it++))\n  {\n    Field *tmp;\n    Record_addr addr(f_maybe_null(cdef->pack_flag));\n    if (!(tmp= cdef->make_field(s, in_use->mem_root, &addr, &cdef->field_name)))\n      DBUG_RETURN(true);\n    add(tmp);\n  }\n  DBUG_RETURN(false);\n}", "target": 0}
{"code": "void ImageLoader::DecodeRequest::Resolve() {\n  resolver_->Resolve();\n  loader_ = nullptr;\n}", "target": 0}
{"code": "err_t verify_signed_hash(const struct RSA_public_key *k\n                         , u_char *s, unsigned int s_max_octets\n                         , u_char **psig\n                         , size_t hash_len\n                         , const u_char *sig_val, size_t sig_len)\n{\n    unsigned int padlen;\n    {\n\tchunk_t temp_s;\n\tMP_INT c;\n\tn_to_mpz(&c, sig_val, sig_len);\n\toswcrypto.mod_exp(&c, &c, &k->e, &k->n);\n\ttemp_s = mpz_to_n(&c, sig_len);\t\n        if(s_max_octets < sig_len) {\n            return \"2\"\"exponentiation failed; too many octets\";\n        }\n\tmemcpy(s, temp_s.ptr, sig_len);\n\tpfree(temp_s.ptr);\n\tmpz_clear(&c);\n    }\n    padlen = sig_len - 3 - hash_len;\n    DBG(DBG_CRYPT,\n\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n    s += padlen + 3;\n    (*psig) = s;\n    return NULL;\n}", "target": 1}
{"code": "rpl_dio_printopt(netdissect_options *ndo,\n                 const struct rpl_dio_genoption *opt,\n                 u_int length)\n{\n        if(length < RPL_DIO_GENOPTION_LEN) return;\n        length -= RPL_DIO_GENOPTION_LEN;\n        ND_TCHECK(opt->rpl_dio_len);\n        while((opt->rpl_dio_type == RPL_OPT_PAD0 &&\n               (const u_char *)opt < ndo->ndo_snapend) ||\n              ND_TTEST2(*opt,(opt->rpl_dio_len+2))) {\n                unsigned int optlen = opt->rpl_dio_len+2;\n                if(opt->rpl_dio_type == RPL_OPT_PAD0) {\n                        optlen = 1;\n                        ND_PRINT((ndo, \" opt:pad0\"));\n                } else {\n                        ND_PRINT((ndo, \" opt:%s len:%u \",\n                                  tok2str(rpl_subopt_values, \"subopt:%u\", opt->rpl_dio_type),\n                                  optlen));\n                        if(ndo->ndo_vflag > 2) {\n                                unsigned int paylen = opt->rpl_dio_len;\n                                if(paylen > length) paylen = length;\n                                hex_print(ndo,\n                                          \" \",\n                                          ((const uint8_t *)opt) + RPL_DIO_GENOPTION_LEN,  \n                                          paylen);\n                        }\n                }\n                opt = (const struct rpl_dio_genoption *)(((const char *)opt) + optlen);\n                length -= optlen;\n        }\n        return;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& values_tensor = ctx->input(0);\n    const Tensor& value_range_tensor = ctx->input(1);\n    const Tensor& nbins_tensor = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(value_range_tensor.shape()),\n                errors::InvalidArgument(\"value_range should be a vector.\"));\n    OP_REQUIRES(ctx, (value_range_tensor.shape().num_elements() == 2),\n                errors::InvalidArgument(\n                    \"value_range should be a vector of 2 elements.\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(nbins_tensor.shape()),\n                errors::InvalidArgument(\"nbins should be a scalar.\"));\n    const auto values = values_tensor.flat<T>();\n    const auto value_range = value_range_tensor.flat<T>();\n    const auto nbins = nbins_tensor.scalar<int32>()();\n    OP_REQUIRES(\n        ctx, (value_range(0) < value_range(1)),\n        errors::InvalidArgument(\"value_range should satisfy value_range[0] < \"\n                                \"value_range[1], but got '[\",\n                                value_range(0), \", \", value_range(1), \"]'\"));\n    OP_REQUIRES(\n        ctx, (nbins > 0),\n        errors::InvalidArgument(\"nbins should be a positive number, but got '\",\n                                nbins, \"'\"));\n    Tensor* out_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({nbins}), &out_tensor));\n    auto out = out_tensor->flat<Tout>();\n    OP_REQUIRES_OK(\n        ctx, functor::HistogramFixedWidthFunctor<Device, T, Tout>::Compute(\n                 ctx, values, value_range, nbins, out));\n  }", "target": 1}
{"code": "void PrepareFrameAndViewForPrint::UpdatePrintParams(\n    const PrintMsg_Print_Params& print_params) {\n  DCHECK(!finished_);\n  gfx::Size canvas_size;\n  CalculatePrintCanvasSize(print_params, &canvas_size);\n  if (canvas_size == print_canvas_size_)\n    return;\n  frame_->printEnd();\n  dpi_ = static_cast<int>(print_params.dpi);\n  StartPrinting(canvas_size);\n}", "target": 0}
{"code": "static int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {\n\t\tif (!IS_ATOMIC_WRITTEN_PAGE(page)) {\n\t\t\tf2fs_register_inmem_page(inode, page);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tf2fs_update_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "luks_unlock_start_waiting_for_cleartext_device (UnlockEncryptionData *data)\n{\n  Device *cleartext_device;\n  cleartext_device = find_cleartext_device (data->device);\n  if (cleartext_device != NULL)\n    {\n      update_info (data->device);\n      drain_pending_changes (data->device, FALSE);\n      if (data->hook_func != NULL)\n        {\n          data->hook_func (data->context, cleartext_device, data->hook_user_data);\n        }\n      else\n        {\n          dbus_g_method_return (data->context, cleartext_device->priv->object_path);\n        }\n      unlock_encryption_data_unref (data);\n    }\n  else\n    {\n      data->device_added_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                     \"device-added\",\n                                                                     (GCallback) luks_unlock_device_added_cb,\n                                                                     data);\n      data->device_changed_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                       \"device-changed\",\n                                                                       (GCallback) luks_unlock_device_added_cb,\n                                                                       data);\n      data->device_added_timeout_id = g_timeout_add (15 * 1000, luks_unlock_device_not_seen_cb, data);\n    }\n}", "target": 0}
{"code": "void WriteMenu(IPC::Message* m, const PP_Flash_Menu* menu) {\n  m->WriteUInt32(menu->count);\n  for (uint32_t i = 0; i < menu->count; ++i)\n    WriteMenuItem(m, menu->items + i);\n}", "target": 0}
{"code": "JANET_CORE_FN(cfun_array_ensure,\n              \"(array/ensure arr capacity growth)\",\n              \"Ensures that the memory backing the array is large enough for `capacity` \"\n              \"items at the given rate of growth. `capacity` and `growth` must be integers. \"\n              \"If the backing capacity is already enough, then this function does nothing. \"\n              \"Otherwise, the backing memory will be reallocated so that there is enough space.\") {\n    janet_fixarity(argc, 3);\n    JanetArray *array = janet_getarray(argv, 0);\n    int32_t newcount = janet_getinteger(argv, 1);\n    int32_t growth = janet_getinteger(argv, 2);\n    if (newcount < 1) janet_panic(\"expected positive integer\");\n    janet_array_ensure(array, newcount, growth);\n    return argv[0];\n}", "target": 0}
{"code": "static void load_xref_from_plaintext(FILE *fp, xref_t *xref)\n{\n    int  i, buf_idx, obj_id, added_entries;\n    char c, buf[32] = {0};\n    long start, pos;\n    start = ftell(fp);\n    pos = xref->end;\n    fseek(fp, pos, SEEK_SET);\n    while (ftell(fp) != 0)\n      if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))\n        break;\n      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;\n    for (i=0; i<xref->n_entries; i++)\n    {\n        c = fgetc(fp);\n        while (c == '\\n' || c == '\\r')\n          c = fgetc(fp);\n        buf_idx = 0;\n        while (c != '\\n' && c != '\\r' && !feof(fp) &&\n               !ferror(fp) && buf_idx < sizeof(buf))\n        {\n            buf[buf_idx++] = c;\n            c = fgetc(fp);\n        }\n        if (buf_idx >= sizeof(buf))\n        {\n            ERR(\"Failed to locate newline character. \"\n                \"This might be a corrupt PDF.\\n\");\n            exit(EXIT_FAILURE);\n        }\n        buf[buf_idx] = '\\0';\n        if (strchr(buf, 't'))\n          break;\n        if (strlen(buf) > 17)\n        {\n            xref->entries[i].obj_id = obj_id++;\n            xref->entries[i].offset = atol(strtok(buf, \" \"));\n            xref->entries[i].gen_num = atoi(strtok(NULL, \" \"));\n            xref->entries[i].f_or_n = buf[17];\n            ++added_entries;\n        }\n        else\n        {\n            obj_id = atoi(buf);\n            --i;\n        }\n    }\n    xref->n_entries = added_entries;\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "WaveShaperNode* AudioContext::createWaveShaper()\n{\n    ASSERT(isMainThread());\n    return WaveShaperNode::create(this);\n}", "target": 0}
{"code": "GF_Err CoLL_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox*)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, p->maxCLL);\n\tgf_bs_write_u16(bs, p->maxFALL);\n\treturn GF_OK;\n}", "target": 0}
{"code": "void HTMLTextAreaElement::childrenChanged(bool changedByParser, Node* beforeChange, Node* afterChange, int childCountDelta)\n{\n    HTMLElement::childrenChanged(changedByParser, beforeChange, afterChange, childCountDelta);\n    setLastChangeWasNotUserEdit();\n    if (m_isDirty)\n        setInnerTextValue(value());\n    else\n        setNonDirtyValue(defaultValue());\n}", "target": 0}
{"code": "static int8_t parse_ext_option(uint16_t *dst, uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t *message_left)\n{\n    uint16_t option_number = *dst;\n    if (option_number == 13) {\n        uint8_t option_ext;\n        int8_t read_result = sn_coap_parser_read_packet_u8(&option_ext,\n                                                            *packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len);\n        if (read_result != 0) {\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n        else {\n                option_number += option_ext;\n                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                               packet_data_start_ptr,\n                                                               packet_len,\n                                                               1);\n        }\n    } else if (option_number == 14) {\n            int8_t read_result = sn_coap_parser_read_packet_u16(&option_number,\n                                                                *packet_data_pptr,\n                                                                packet_data_start_ptr,\n                                                                packet_len);\n            if (read_result != 0) {\n                tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n                return -1;\n            }\n            else {\n            option_number += 269;\n            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                           packet_data_start_ptr,\n                                                           packet_len,\n                                                           2);\n            }\n    }\n    else if (option_number == 15) {\n        tr_error(\"sn_coap_parser_options_parse - invalid option number(15)!\");\n        return -1;\n    }\n    *dst = option_number;\n    return 0;\n}", "target": 1}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n \t\treturn -ENOSYS;\n \tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n \t\t\treturn -EINVAL;\n \t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "void PrintHeaderFooterText(\n    string16 text,\n    WebKit::WebCanvas* canvas,\n    HeaderFooterPaint paint,\n    float webkit_scale_factor,\n    const PageSizeMargins& page_layout,\n    printing::HorizontalHeaderFooterPosition horizontal_position,\n    printing::VerticalHeaderFooterPosition vertical_position,\n    double offset_to_baseline) {\n#if defined(USE_SKIA)\n  size_t text_byte_length = text.length() * sizeof(char16);\n  double text_width_in_points = SkScalarToDouble(paint.measureText(\n      text.c_str(), text_byte_length));\n  SkPoint point = GetHeaderFooterPosition(webkit_scale_factor, page_layout,\n                                          horizontal_position,\n                                          vertical_position, offset_to_baseline,\n                                          text_width_in_points);\n  paint.setTextSize(SkDoubleToScalar(\n      paint.getTextSize() / webkit_scale_factor));\n  canvas->drawText(text.c_str(), text_byte_length, point.x(), point.y(),\n                   paint);\n#elif defined(OS_MACOSX)\n  ScopedCFTypeRef<CFStringRef> cf_text(base::SysUTF16ToCFStringRef(text));\n  ScopedCFTypeRef<CFAttributedStringRef> cf_attr_text(\n      CFAttributedStringCreate(NULL, cf_text, paint));\n  ScopedCFTypeRef<CTLineRef> line(CTLineCreateWithAttributedString(\n      cf_attr_text));\n  double text_width_in_points =\n      CTLineGetTypographicBounds(line, NULL, NULL, NULL) * webkit_scale_factor;\n  SkPoint point = GetHeaderFooterPosition(webkit_scale_factor,\n                                          page_layout, horizontal_position,\n                                          vertical_position, offset_to_baseline,\n                                          text_width_in_points);\n  CGContextSetTextPosition(canvas, SkScalarToDouble(point.x()),\n                           SkScalarToDouble(point.y()));\n  CTLineDraw(line, canvas);\n#endif\n}", "target": 0}
{"code": "png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n   png_uint_32 max_palette_length;\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n   max_palette_length = (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?\n      (1 << png_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;\n   if (num_palette < 0 || num_palette > max_palette_length)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n   if ((num_palette > 0 && palette == NULL) ||\n      (num_palette == 0\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\n#        endif\n      ))\n   {\n      png_error(png_ptr, \"Invalid palette\");\n   }\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n   if (num_palette > 0)\n      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n   info_ptr->free_me |= PNG_FREE_PLTE;\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "target": 1}
{"code": "static void __skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype)\n{\n\tstruct sock_exterr_skb *serr;\n\tint err;\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\tserr->ee.ee_info = tstype;\n\tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n\t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\terr = sock_queue_err_skb(sk, skb);\n\tif (err)\n\t\tkfree_skb(skb);", "target": 1}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n {\n     int i, j, v;\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n     next_start_code_studio(gb);\n }", "target": 1}
{"code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n \tstruct sock *sk2;\n \tstruct alg_sock *ask2;\n \tstruct hash_ctx *ctx2;\n \tint err;\n\terr = crypto_ahash_export(req, state);\n \tif (err)\n \t\treturn err;\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n \tsk2 = newsock->sk;\n \task2 = alg_sk(sk2);\n \tctx2 = ask2->private;\n\tctx2->more = 1;\n \terr = crypto_ahash_import(&ctx2->req, state);\n \tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "add_compile_string(UChar* s, int mb_len, OnigDistance byte_len,\n                   regex_t* reg, int ignore_case)\n{\n  int op = select_str_opcode(mb_len, byte_len, ignore_case);\n  add_opcode(reg, op);\n  if (op == OP_EXACTMBN)\n    add_length(reg, mb_len);\n  if (IS_NEED_STR_LEN_OP_EXACT(op)) {\n    if (op == OP_EXACTN_IC)\n      add_length(reg, byte_len);\n    else\n      add_length(reg, byte_len / mb_len);\n  }\n  add_bytes(reg, s, byte_len);\n  return 0;\n}", "target": 0}
{"code": "ldap_start_tls_s ( LDAP *ld,\n\tLDAPControl **serverctrls,\n\tLDAPControl **clientctrls )\n{\n#ifndef HAVE_TLS\n\treturn LDAP_NOT_SUPPORTED;\n#else\n\tint rc;\n\tchar *rspoid = NULL;\n\tstruct berval *rspdata = NULL;\n\tif ( ldap_tls_inplace( ld ) ) {\n\t\treturn LDAP_LOCAL_ERROR;\n\t}\n\trc = ldap_extended_operation_s( ld, LDAP_EXOP_START_TLS,\n\t\tNULL, serverctrls, clientctrls, &rspoid, &rspdata );\n\tif ( rspoid != NULL ) {\n\t\tLDAP_FREE(rspoid);\n\t}\n\tif ( rspdata != NULL ) {\n\t\tber_bvfree( rspdata );\n\t}\n\tif ( rc == LDAP_SUCCESS ) {\n\t\trc = ldap_int_tls_start( ld, ld->ld_defconn, NULL );\n\t}\n\treturn rc;\n#endif\n}", "target": 0}
{"code": "void *load_device_tree(const char *filename_path, int *sizep)\n{\n    int dt_size;\n    int dt_file_load_size;\n    int ret;\n    void *fdt = NULL;\n    *sizep = 0;\n    dt_size = get_image_size(filename_path);\n    if (dt_size < 0) {\n        error_report(\"Unable to get size of device tree file '%s'\",\n                     filename_path);\n        goto fail;\n    }\n    dt_size += 10000;\n    dt_size *= 2;\n     fdt = g_malloc0(dt_size);\n    dt_file_load_size = load_image(filename_path, fdt);\n     if (dt_file_load_size < 0) {\n         error_report(\"Unable to open device tree file '%s'\",\n                      filename_path);\n        goto fail;\n    }\n    ret = fdt_open_into(fdt, fdt, dt_size);\n    if (ret) {\n        error_report(\"Unable to copy device tree in memory\");\n        goto fail;\n    }\n    if (fdt_check_header(fdt)) {\n        error_report(\"Device tree file loaded into memory is invalid: %s\",\n                     filename_path);\n        goto fail;\n    }\n    *sizep = dt_size;\n    return fdt;\nfail:\n    g_free(fdt);\n    return NULL;\n}", "target": 1}
{"code": "static inline void native_tss_invalidate_io_bitmap(void)\n{\n\tthis_cpu_write(cpu_tss_rw.x86_tss.io_bitmap_base,\n\t\t       IO_BITMAP_OFFSET_INVALID);\n}", "target": 0}
{"code": "SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(\n    const base::CommandLine& command_line,\n    Profile* profile) {\n  DCHECK(profile);\n  PrefService* prefs = profile->GetPrefs();\n  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);\n#if defined(OS_CHROMEOS)\n  const bool is_first_run =\n      user_manager::UserManager::Get()->IsCurrentUserNew();\n  const bool did_restart = false;\n  StartupBrowserCreator::WasRestarted();\n#else\n  const bool is_first_run = first_run::IsChromeFirstRun();\n  const bool did_restart = StartupBrowserCreator::WasRestarted();\n#endif\n  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))\n    pref.type = SessionStartupPref::DEFAULT;\n  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&\n      !profile->IsNewProfile()) {\n    pref.type = SessionStartupPref::LAST;\n  }\n  if (!profile->IsGuestSession()) {\n    ProfileAttributesEntry* entry = nullptr;\n    bool has_entry =\n        g_browser_process->profile_manager()\n            ->GetProfileAttributesStorage()\n            .GetProfileAttributesWithPath(profile->GetPath(), &entry);\n    if (has_entry && entry->IsSigninRequired())\n       pref.type = SessionStartupPref::LAST;\n   }\n  if (pref.type == SessionStartupPref::LAST &&\n      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {\n    pref.type = SessionStartupPref::DEFAULT;\n  }\n  return pref;\n}", "target": 1}
{"code": "static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n}", "target": 1}
{"code": "ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)\n{\n    int x;\n    int chunk;\n    UINT8* out;\n    UINT8* ptr;\n    ptr = buf;\n    chunk = 3 * state->xsize;\n    for (;;) {\n\tif (bytes < chunk)\n\t    return ptr - buf;\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\tif (++state->y >= state->ysize)\n\t    return -1; \n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x+state->xsize];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\tif (++state->y >= state->ysize)\n\t    return -1;\n\tptr += chunk;\n\tbytes -= chunk;\n    }\n}", "target": 1}
{"code": "daemon_linux_lvm2_lv_remove (Daemon *daemon,\n                             const gchar *group_uuid,\n                             const gchar *uuid,\n                             gchar **options,\n                             DBusGMethodInvocation *context)\n{\n  daemon_local_check_auth (daemon,\n                           NULL,\n                           \"org.freedesktop.udisks.linux-lvm2\",\n                           \"LinuxLvm2LVRemove\",\n                           TRUE,\n                           daemon_linux_lvm2_lv_remove_authorized_cb,\n                           context,\n                           3,\n                           g_strdup (group_uuid),\n                           g_free,\n                           g_strdup (uuid),\n                           g_free,\n                           g_strdupv (options),\n                           g_strfreev);\n  return TRUE;\n}", "target": 0}
{"code": "static void mkiss_put(struct mkiss *ax)\n{\n\tif (refcount_dec_and_test(&ax->refcnt))\n\t\tcomplete(&ax->dead);\n}", "target": 0}
{"code": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}", "target": 1}
{"code": "SAPI_API int sapi_get_target_gid(gid_t *obj TSRMLS_DC)\n{\n\tif (sapi_module.get_target_gid) {\n\t\treturn sapi_module.get_target_gid(obj TSRMLS_CC);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}", "target": 0}
{"code": "daemon_linux_lvm2_vg_remove_pv (Daemon *daemon,\n                                const gchar *vg_uuid,\n                                const gchar *pv_uuid,\n                                gchar **options,\n                                DBusGMethodInvocation *context)\n{\n  daemon_local_check_auth (daemon,\n                           NULL,\n                           \"org.freedesktop.udisks.linux-lvm2\",\n                           \"LinuxLvm2VGRemovePV\",\n                           TRUE,\n                           daemon_linux_lvm2_vg_remove_pv_authorized_cb,\n                           context,\n                           3,\n                           g_strdup (vg_uuid),\n                           g_free,\n                           g_strdup (pv_uuid),\n                           g_free,\n                           g_strdupv (options),\n                           g_strfreev);\n  return TRUE;\n}", "target": 0}
{"code": "ebt_basic_match(const struct ebt_entry *e, const struct sk_buff *skb,\n                const struct net_device *in, const struct net_device *out)\n{\n\tconst struct ethhdr *h = eth_hdr(skb);\n\tconst struct net_bridge_port *p;\n\t__be16 ethproto;\n\tint verdict, i;\n\tif (vlan_tx_tag_present(skb))\n\t\tethproto = htons(ETH_P_8021Q);\n\telse\n\t\tethproto = h->h_proto;\n\tif (e->bitmask & EBT_802_3) {\n\t\tif (FWINV2(ntohs(ethproto) >= 1536, EBT_IPROTO))\n\t\t\treturn 1;\n\t} else if (!(e->bitmask & EBT_NOPROTO) &&\n\t   FWINV2(e->ethproto != ethproto, EBT_IPROTO))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->in, in), EBT_IIN))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->out, out), EBT_IOUT))\n\t\treturn 1;\n\tif (in && (p = br_port_get_rcu(in)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_in, p->br->dev), EBT_ILOGICALIN))\n\t\treturn 1;\n\tif (out && (p = br_port_get_rcu(out)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_out, p->br->dev), EBT_ILOGICALOUT))\n\t\treturn 1;\n\tif (e->bitmask & EBT_SOURCEMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_source[i] ^ e->sourcemac[i]) &\n\t\t\t   e->sourcemsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_ISOURCE) )\n\t\t\treturn 1;\n\t}\n\tif (e->bitmask & EBT_DESTMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_dest[i] ^ e->destmac[i]) &\n\t\t\t   e->destmsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_IDEST) )\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "bool __init __weak hugetlb_node_alloc_supported(void)\n{\n\treturn true;\n}", "target": 0}
{"code": "sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int matched = 0;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\tstrlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n    epass = (char *) crypt(pass, pw_epasswd);\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)\n\t    matched = !strncmp(pw_epasswd, epass, DESLEN);\n\telse\n\t    matched = !strcmp(pw_epasswd, epass);\n    }\n    explicit_bzero(des_pass, sizeof(des_pass));\n    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);\n}", "target": 1}
{"code": "ospf_fifo_new ()\n{\n  struct ospf_fifo *new;\n  new = XCALLOC (MTYPE_OSPF_FIFO, sizeof (struct ospf_fifo));\n  return new;\n}", "target": 0}
{"code": "l2tp_result_code_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr))); ptr++;\t\n\tif (length > 2) {\t\t\t\t\n\t        ND_PRINT((ndo, \"/%u\", EXTRACT_16BITS(ptr))); ptr++;\n\t}\n\tif (length > 4) {\t\t\t\t\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length - 4);\n\t}\n}", "target": 1}
{"code": "\tvoid initialize(const string &path, bool owner) {\n\t\tTRACE_POINT();\n\t\tthis->path  = path;\n\t\tthis->owner = owner;\n\t\tif (owner) {\n\t\t\tswitch (getFileTypeNoFollowSymlinks(path)) {\n\t\t\tcase FT_NONEXISTANT:\n\t\t\t\tcreateDirectory(path);\n\t\t\t\tbreak;\n\t\t\tcase FT_DIRECTORY:\n\t\t\t\tverifyDirectoryPermissions(path);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow RuntimeException(\"'\" + path + \"' already exists, and is not a directory\");\n\t\t\t}\n\t\t} else if (getFileType(path) != FT_DIRECTORY) {\n\t\t\tthrow RuntimeException(\"Server instance directory '\" + path +\n\t\t\t\t\"' does not exist\");\n\t\t}\n\t}", "target": 1}
{"code": "pci_get_vdev_info(int slot)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct pci_vdev *dev = NULL;\n\tbi = pci_businfo[0];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[slot];\n\tif (si != NULL)\n\t\tdev = si->si_funcs[0].fi_devi;\n\telse\n\t\tfprintf(stderr, \"slot=%d is empty!\\n\", slot);\n\treturn dev;\n}", "target": 1}
{"code": "static void *CFRdbLoad(RedisModuleIO *io, int encver) {\n    if (encver > CF_MIN_EXPANSION_VERSION) {\n        return NULL;\n    }\n    CuckooFilter *cf = RedisModule_Calloc(1, sizeof(*cf));\n    cf->numFilters = RedisModule_LoadUnsigned(io);\n    cf->numBuckets = RedisModule_LoadUnsigned(io);\n    cf->numItems = RedisModule_LoadUnsigned(io);\n    if (encver < CF_MIN_EXPANSION_VERSION) { \n        cf->numDeletes = 0;                  \n        cf->bucketSize = CF_DEFAULT_BUCKETSIZE;\n        cf->maxIterations = CF_MAX_ITERATIONS;\n        cf->expansion = CF_DEFAULT_EXPANSION;\n    } else {\n        cf->numDeletes = RedisModule_LoadUnsigned(io);\n        cf->bucketSize = RedisModule_LoadUnsigned(io);\n        cf->maxIterations = RedisModule_LoadUnsigned(io);\n        cf->expansion = RedisModule_LoadUnsigned(io);\n    }\n    cf->filters = RedisModule_Calloc(cf->numFilters, sizeof(*cf->filters));\n    for (size_t ii = 0, exp = 1; ii < cf->numFilters; ++ii, exp *= cf->expansion) {\n        cf->filters[ii].bucketSize = cf->bucketSize;\n        if (encver < CF_MIN_EXPANSION_VERSION) {\n            cf->filters[ii].numBuckets = cf->numBuckets;\n        } else {\n            cf->filters[ii].numBuckets = RedisModule_LoadUnsigned(io);\n        }\n        size_t lenDummy = 0;\n        cf->filters[ii].data = (MyCuckooBucket *)RedisModule_LoadStringBuffer(io, &lenDummy);\n        assert(cf->filters[ii].data != NULL && lenDummy == cf->filters[ii].bucketSize *\n                                                               cf->filters[ii].numBuckets *\n                                                               sizeof(*cf->filters[ii].data));\n    }\n    return cf;\n}", "target": 1}
{"code": "PpapiPluginProcessHost* PpapiPluginProcessHost::CreateBrokerHost(\n    const content::PepperPluginInfo& info) {\n  PpapiPluginProcessHost* plugin_host =\n      new PpapiPluginProcessHost();\n  if (plugin_host->Init(info))\n    return plugin_host;\n  NOTREACHED();  \n  return NULL;\n}", "target": 0}
{"code": " _archive_write_data(struct archive *_a, const void *buff, size_t s)\n {\n \tstruct archive_write *a = (struct archive_write *)_a;\n \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n \t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n \tarchive_clear_error(&a->archive);\n \treturn ((a->format_write_data)(a, buff, s));\n }", "target": 1}
{"code": "static int mxf_read_tagged_value(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFTaggedValue *tagged_value = arg;\n    switch (tag){\n    case 0x5001:\n        return mxf_read_utf16be_string(pb, size, &tagged_value->name);\n    case 0x5003:\n        return mxf_read_indirect_value(tagged_value, pb, size);\n    }\n    return 0;\n}", "target": 0}
{"code": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n \tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n \t\tif (ack->subh.addip_hdr->serial == serial) {\n \t\t\tsctp_chunk_hold(ack);\n \t\t\treturn ack;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint           i, j, ret;\n\tunsigned char count;\n\tif (flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\tif ( (scd->curbit + code_size) >= scd->lastbit) {\n\t\tif (scd->done) {\n\t\t\tif (scd->curbit >= scd->lastbit) {\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tscd->buf[0] = scd->buf[scd->last_byte-2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte-1];\n               if ((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0)\n\t\t\tscd->done = TRUE;\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2+count)*8 ;\n\t}\n\tret = 0;\n\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j)\n\t\tret |= ((scd->buf[ i / 8 ] & (1 << (i % 8))) != 0) << j;\n\tscd->curbit += code_size;\n\treturn ret;\n}", "target": 1}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "static void dup_xol_work(struct callback_head *work)\n{\n\tif (current->flags & PF_EXITING)\n\t\treturn;\n\tif (!__create_xol_area(current->utask->dup_xol_addr) &&\n\t\t\t!fatal_signal_pending(current))\n\t\tuprobe_warn(current, \"dup xol area\");\n}", "target": 0}
{"code": "static struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\tfor (;;) {\n\t\tif (can_open_cached(state, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, open_mode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, open_mode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(stateid.data, delegation->stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\t\tif (update_open_stateid(state, NULL, &stateid, open_mode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}", "target": 1}
{"code": "    uint32_t TiffDirectory::doSizeData() const\n    {\n        assert(false);\n        return 0;\n    } ", "target": 0}
{"code": "RecordCloseDown(ExtensionEntry * extEntry)\n{\n    DeleteCallback(&ClientStateCallback, RecordAClientStateChange, NULL);\n}                               ", "target": 0}
{"code": " static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n {\n \tmemcpy(&p->id, &x->id, sizeof(p->id));\n \tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n \tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}", "target": 1}
{"code": "static void update_attr(struct vc_data *vc)\n{\n\tvc->vc_attr = build_attr(vc, vc->vc_color, vc->vc_intensity,\n\t              vc->vc_blink, vc->vc_underline,\n\t              vc->vc_reverse ^ vc->vc_decscnm, vc->vc_italic);\n\tvc->vc_video_erase_char = (build_attr(vc, vc->vc_color, 1, vc->vc_blink, 0, vc->vc_decscnm, 0) << 8) | ' ';\n}", "target": 0}
{"code": "theme_adium_update_enable_webkit_developer_tools (EmpathyThemeAdium *theme)\n{\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (theme);\n\tWebKitWebView  *web_view = WEBKIT_WEB_VIEW (theme);\n\tgboolean        enable_webkit_developer_tools;\n\tenable_webkit_developer_tools = g_settings_get_boolean (\n\t\t\tpriv->gsettings_chat,\n\t\t\tEMPATHY_PREFS_CHAT_WEBKIT_DEVELOPER_TOOLS);\n\tg_object_set (G_OBJECT (webkit_web_view_get_settings (web_view)),\n\t\t      \"enable-developer-extras\",\n\t\t      enable_webkit_developer_tools,\n\t\t      NULL);\n}", "target": 0}
{"code": "onig_set_callout_data(regex_t* reg, OnigMatchParam* mp,\n                      int callout_num, int slot,\n                      OnigType type, OnigValue* val)\n{\n  CalloutData* d;\n  if (callout_num <= 0) return ONIGERR_INVALID_ARGUMENT;\n  d = CALLOUT_DATA_AT_NUM(mp, callout_num);\n  d->slot[slot].type = type;\n  d->slot[slot].val  = *val;\n  d->last_match_at_call_counter = mp->match_at_call_counter;\n  return ONIG_NORMAL;\n}", "target": 0}
{"code": "void QuotaManager::EvictOriginData(\n    const GURL& origin,\n    StorageType type,\n    EvictOriginDataCallback* callback) {\n  DCHECK(io_thread_->BelongsToCurrentThread());\n  DCHECK_EQ(type, kStorageTypeTemporary);\n  eviction_context_.evicted_origin = origin;\n  eviction_context_.evicted_type = type;\n  eviction_context_.evict_origin_data_callback.reset(callback);\n  DeleteOriginData(origin, type, callback_factory_.NewCallback(\n      &QuotaManager::DidOriginDataEvicted));\n}", "target": 0}
{"code": "vm_fault_t gru_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct gru_thread_state *gts;\n\tunsigned long paddr, vaddr;\n\tunsigned long expires;\n\tvaddr = vmf->address;\n\tgru_dbg(grudev, \"vma %p, vaddr 0x%lx (0x%lx)\\n\",\n\t\tvma, vaddr, GSEG_BASE(vaddr));\n\tSTAT(nopfn);\n\tgts = gru_find_thread_state(vma, TSID(vaddr, vma));\n\tif (!gts)\n\t\treturn VM_FAULT_SIGBUS;\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\tgru_check_context_placement(gts);\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();\n\t\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(GRU_ASSIGN_DELAY);  \n\t\t\texpires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;\n\t\t\tif (time_before(expires, jiffies))\n\t\t\t\tgru_steal_context(gts);\n\t\t\tgoto again;\n\t\t}\n\t\tgru_load_context(gts);\n\t\tpaddr = gseg_physical_address(gts->ts_gru, gts->ts_ctxnum);\n\t\tremap_pfn_range(vma, vaddr & ~(GRU_GSEG_PAGESIZE - 1),\n\t\t\t\tpaddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE,\n\t\t\t\tvma->vm_page_prot);\n\t}\n\tpreempt_enable();\n\tmutex_unlock(&gts->ts_ctxlock);\n\treturn VM_FAULT_NOPAGE;\n}", "target": 1}
{"code": "format_SET_L4_SRC_PORT(const struct ofpact_l4_port *a,\n                       const struct ofpact_format_params *fp)\n{\n    ds_put_format(fp->s, \"%smod_tp_src:%s%d\",\n                  colors.param, colors.end, a->port);\n}", "target": 0}
{"code": "read_channel_data (PSDchannel     *channel,\n                   const guint16   bps,\n                   const guint16   compression,\n                   const guint16  *rle_pack_len,\n                   FILE           *f,\n                   GError        **error)\n{\n  gchar    *raw_data;\n  gchar    *src;\n  gchar    *dst;\n  guint32   readline_len;\n  gint      i;\n  if (bps == 1)\n    readline_len = ((channel->columns + 7) >> 3);\n  else\n    readline_len = (channel->columns * bps >> 3);\n  IFDBG(3) g_debug (\"raw data size %d x %d = %d\", readline_len,\n                    channel->rows, readline_len * channel->rows);\n  raw_data = g_malloc (readline_len * channel->rows);\n  switch (compression)\n    {\n      case PSD_COMP_RAW:\n        if (fread (raw_data, readline_len, channel->rows, f) < 1)\n          {\n            psd_set_error (feof (f), errno, error);\n            return -1;\n          }\n        break;\n      case PSD_COMP_RLE:\n        for (i = 0; i < channel->rows; ++i)\n          {\n            src = g_malloc (rle_pack_len[i]);\n            dst = g_malloc (readline_len);\n            if (fread (src, rle_pack_len[i], 1, f) < 1)\n              {\n                psd_set_error (feof (f), errno, error);\n                return -1;\n              }\n            decode_packbits (src, dst, rle_pack_len[i], readline_len);\n            g_free (src);\n            memcpy (raw_data + i * readline_len, dst, readline_len);\n            g_free (dst);\n          }\n        break;\n    }\n  switch (bps)\n    {\n      case 16:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_16_bit (raw_data, channel->data, (channel->rows * channel->columns) << 1);\n        break;\n      case 8:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        memcpy (channel->data, raw_data, (channel->rows * channel->columns));\n        break;\n      case 1:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_1_bit (raw_data, channel->data, channel->rows, channel->columns);\n        break;\n    }\n  g_free (raw_data);\n  return 1;\n}", "target": 1}
{"code": "Eina_Bool ewk_view_setting_caret_browsing_set(Evas_Object* ewkView, Eina_Bool enable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    enable = !!enable;\n    if (priv->settings.caretBrowsing != enable) {\n        priv->pageSettings->setCaretBrowsingEnabled(enable);\n        priv->settings.caretBrowsing = enable;\n    }\n    return true;\n}", "target": 0}
{"code": "static int get_rx_bufs(struct vhost_virtqueue *vq,\n\t\t       struct vring_used_elem *heads,\n\t\t       int datalen,\n\t\t       unsigned *iovcount,\n\t\t       struct vhost_log *log,\n\t\t       unsigned *log_num,\n\t\t       unsigned int quota)\n{\n\tunsigned int out, in;\n\tint seg = 0;\n\tint headcount = 0;\n\tunsigned d;\n\tint r, nlogs = 0;\n\twhile (datalen > 0 && headcount < quota) {\n\t\tif (unlikely(seg >= UIO_MAXIOV)) {\n\t\t\tr = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\td = vhost_get_vq_desc(vq->dev, vq, vq->iov + seg,\n\t\t\t\t      ARRAY_SIZE(vq->iov) - seg, &out,\n\t\t\t\t      &in, log, log_num);\n\t\tif (d == vq->num) {\n\t\t\tr = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(out || in <= 0)) {\n\t\t\tvq_err(vq, \"unexpected descriptor format for RX: \"\n\t\t\t\t\"out %d, in %d\\n\", out, in);\n\t\t\tr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(log)) {\n\t\t\tnlogs += *log_num;\n\t\t\tlog += *log_num;\n\t\t}\n\t\theads[headcount].id = d;\n\t\theads[headcount].len = iov_length(vq->iov + seg, in);\n\t\tdatalen -= heads[headcount].len;\n\t\t++headcount;\n\t\tseg += in;\n\t}\n\theads[headcount - 1].len += datalen;\n \t*iovcount = seg;\n \tif (unlikely(log))\n \t\t*log_num = nlogs;\n \treturn headcount;\n err:\n \tvhost_discard_vq_desc(vq, headcount);\n\treturn r;\n}", "target": 1}
{"code": "PrintBackend *cpdbCreateBackendFromFile(GDBusConnection *connection,\n                                        const char *backend_file_name)\n{\n    FILE *file = NULL;\n    PrintBackend *proxy;\n    GError *error = NULL;\n    char *path, *backend_name;\n    const char *info_dir_name;\n    char obj_path[CPDB_BSIZE];\n    backend_name = cpdbGetStringCopy(backend_file_name);\n    if ((info_dir_name = getenv(\"CPDB_BACKEND_INFO_DIR\")) == NULL)\n      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    proxy = print_backend_proxy_new_sync(connection,\n                                         0,\n                                         backend_name,\n                                         obj_path,\n                                         NULL,\n                                         &error);\n    if (error)\n    {\n        logerror(\"Error creating backend proxy for %s : %s\\n\",\n                    backend_name, error->message);\n        return NULL;\n    }\n    return proxy;\n}", "target": 1}
{"code": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\ttrap = lock_rename(new_dir, old_dir);\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}", "target": 1}
{"code": "cmyk2g(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tfloat c = sv[0] * 0.3f;\n\tfloat m = sv[1] * 0.59f;\n\tfloat y = sv[2] * 0.11f;\n\tdv[0] = 1 - fz_min(c + m + y + sv[3], 1);\n}", "target": 0}
{"code": "static int handle_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data;\n\tif (vmx_get_msr(vcpu, ecx, &data)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_read(ecx, data);\n\tvcpu->arch.regs[VCPU_REGS_RAX] = data & -1u;\n\tvcpu->arch.regs[VCPU_REGS_RDX] = (data >> 32) & -1u;\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "static void encode_close(struct xdr_stream *xdr, const struct nfs_closeargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_CLOSE, decode_close_maxsz, hdr);\n\tencode_nfs4_seqid(xdr, arg->seqid);\n\tencode_nfs4_stateid(xdr, arg->stateid);\n}", "target": 0}
{"code": "bool ParseVP9SuperFrameIndex(const std::uint8_t* frame,\n                             std::size_t frame_length, Ranges* frame_ranges) {\n  if (frame == nullptr || frame_length == 0 || frame_ranges == nullptr)\n    return false;\n  bool parse_ok = false;\n  const std::uint8_t marker = frame[frame_length - 1];\n  const std::uint32_t kHasSuperFrameIndexMask = 0xe0;\n  const std::uint32_t kSuperFrameMarker = 0xc0;\n  const std::uint32_t kLengthFieldSizeMask = 0x3;\n  if ((marker & kHasSuperFrameIndexMask) == kSuperFrameMarker) {\n    const std::uint32_t kFrameCountMask = 0x7;\n    const int num_frames = (marker & kFrameCountMask) + 1;\n    const int length_field_size = ((marker >> 3) & kLengthFieldSizeMask) + 1;\n    const std::size_t index_length = 2 + length_field_size * num_frames;\n    if (frame_length < index_length) {\n      std::fprintf(stderr, \"VP9Parse: Invalid superframe index size.\\n\");\n      return false;\n    }\n    const std::size_t length = frame_length - index_length;\n    if (length >= index_length &&\n        frame[frame_length - index_length] == marker) {\n      const std::uint8_t* byte = frame + length + 1;\n      std::size_t frame_offset = 0;\n      for (int i = 0; i < num_frames; ++i) {\n        std::uint32_t child_frame_length = 0;\n        for (int j = 0; j < length_field_size; ++j) {\n          child_frame_length |= (*byte++) << (j * 8);\n        }\n        frame_ranges->push_back(Range(frame_offset, child_frame_length));\n        frame_offset += child_frame_length;\n      }\n      if (static_cast<int>(frame_ranges->size()) != num_frames) {\n        std::fprintf(stderr, \"VP9Parse: superframe index parse failed.\\n\");\n        return false;\n      }\n      parse_ok = true;\n    } else {\n      std::fprintf(stderr, \"VP9Parse: Invalid superframe index.\\n\");\n    }\n  }\n  return parse_ok;\n}", "target": 1}
{"code": "TEST_F(ExprMatchTest, LteWithRHSFieldPathMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: {$lte: [3, '$x']}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 3)));\n    ASSERT_TRUE(matches(BSON(\"x\" << 10)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 1)));\n}", "target": 0}
{"code": "void FileSystemOperation::DidWrite(\n    base::PlatformFileError rv,\n    int64 bytes,\n    bool complete) {\n  if (write_callback_.is_null()) {\n    delete this;\n    return;\n  }\n  write_callback_.Run(rv, bytes, complete);\n  if (complete || rv != base::PLATFORM_FILE_OK)\n    delete this;\n}", "target": 0}
{"code": "isakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}", "target": 1}
{"code": "static int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto exit;\n\t\t}\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "soup_client_context_new (SoupServer *server, SoupSocket *sock)\n{\n\tSoupClientContext *client = g_slice_new0 (SoupClientContext);\n\tclient->server = server;\n\tclient->sock = sock;\n\tclient->ref_count = 1;\n\treturn client;\n}", "target": 0}
{"code": "static void fuse_intr_sighandler(int sig)\n{\n    (void) sig;\n}", "target": 0}
{"code": "bool HTMLMediaElement::HasNativeControls() {\n  return ShouldShowControls(RecordMetricsBehavior::kDoRecord);\n}", "target": 0}
{"code": "static void domain_exit(struct dmar_domain *domain)\n{\n\tstruct page *freelist = NULL;\n\tif (!domain)\n\t\treturn;\n\trcu_read_lock();\n\tdomain_remove_dev_info(domain);\n\trcu_read_unlock();\n\tput_iova_domain(&domain->iovad);\n\tfreelist = domain_unmap(domain, 0, DOMAIN_MAX_PFN(domain->gaw));\n\tdma_free_pagelist(freelist);\n\tfree_domain_mem(domain);\n}", "target": 0}
{"code": "set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_mod_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_mod_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::OnGpuSwapBuffersCompletedInternal(\n    const ui::LatencyInfo& latency_info) {\n  ui::LatencyInfo::LatencyComponent window_snapshot_component;\n  if (latency_info.FindLatency(ui::BROWSER_SNAPSHOT_FRAME_NUMBER_COMPONENT,\n                               GetLatencyComponentId(),\n                               &window_snapshot_component)) {\n    int sequence_number =\n        static_cast<int>(window_snapshot_component.sequence_number);\n#if defined(OS_MACOSX) || defined(OS_WIN)\n    base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(\n        FROM_HERE,\n        base::Bind(&RenderWidgetHostImpl::WindowSnapshotReachedScreen,\n                   weak_factory_.GetWeakPtr(), sequence_number),\n        base::TimeDelta::FromSecondsD(1. / 6));\n#else\n    WindowSnapshotReachedScreen(sequence_number);\n#endif\n  }\n  latency_tracker_.OnGpuSwapBuffersCompleted(latency_info);\n}", "target": 0}
{"code": "void rds_inc_init(struct rds_incoming *inc, struct rds_connection *conn,\n\t\t  __be32 saddr)\n{\n\tatomic_set(&inc->i_refcount, 1);\n\tINIT_LIST_HEAD(&inc->i_item);\n\tinc->i_conn = conn;\n\tinc->i_saddr = saddr;\n\tinc->i_rdma_cookie = 0;\n\tinc->i_rx_tstamp.tv_sec = 0;\n\tinc->i_rx_tstamp.tv_usec = 0;\n}", "target": 0}
{"code": " void acpi_ns_terminate(void)\n {\n \tacpi_status status;\n \tACPI_FUNCTION_TRACE(ns_terminate);\n#ifdef ACPI_EXEC_APP\n\t{\n\t\tunion acpi_operand_object *prev;\n\t\tunion acpi_operand_object *next;\n\t\tnext = acpi_gbl_module_code_list;\n\t\twhile (next) {\n\t\t\tprev = next;\n\t\t\tnext = next->method.mutex;\n\t\t\tprev->method.mutex = NULL;\t\n\t\t\tacpi_ut_remove_reference(prev);\n\t\t}\n \t}\n#endif\n\tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\tacpi_ns_delete_node(acpi_gbl_root_node);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));\n\treturn_VOID;\n}", "target": 1}
{"code": "void gnutls_x509_key_purpose_deinit(gnutls_x509_key_purposes_t p)\n{\n\tkey_purposes_deinit(p);\n\tgnutls_free(p);\n}", "target": 0}
{"code": "\tTEST_METHOD(8) {\n\t\tServerInstanceDir dir(parentDir + \"/passenger-test.1234\");\n\t\tServerInstanceDir::GenerationPtr generation0 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tServerInstanceDir::GenerationPtr generation1 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tServerInstanceDir::GenerationPtr generation2 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tServerInstanceDir::GenerationPtr generation3 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tgeneration2.reset();\n\t\tensure_equals(dir.getNewestGeneration()->getNumber(), 3u);\n\t\tgeneration3.reset();\n\t\tensure_equals(dir.getNewestGeneration()->getNumber(), 1u);\n\t}", "target": 0}
{"code": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\tif (!fstype)\n\t\treturn -EINVAL;\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}", "target": 1}
{"code": "cluster_hash_key_make (void *p)\n{\n  const struct cluster_list *cluster = p;\n  return jhash(cluster->list, cluster->length, 0);\n}", "target": 0}
{"code": "static int nfc_genl_dump_ses_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "EmbeddedWorkerContextClient::EmbeddedWorkerContextClient(\n    int embedded_worker_id,\n    int64 service_worker_version_id,\n    const GURL& script_url)\n    : embedded_worker_id_(embedded_worker_id),\n      service_worker_version_id_(service_worker_version_id),\n      script_url_(script_url),\n      sender_(ChildThread::current()->thread_safe_sender()),\n      main_thread_proxy_(base::MessageLoopProxy::current()),\n      weak_factory_(this) {\n  g_worker_client_tls.Pointer()->Set(this);\n}", "target": 0}
{"code": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n {\n     char obj_txt[128];\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n     return 1;\n }", "target": 1}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = disconnect_mount(p, how);\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 1}
{"code": "bool Parcel::allowFds() const\n{\n return mAllowFds;\n}", "target": 0}
{"code": "static void xgmac_enet_send(XgmacState *s)\n{\n    struct desc bd;\n    int frame_size;\n    int len;\n    uint8_t frame[8192];\n    uint8_t *ptr;\n    ptr = frame;\n    frame_size = 0;\n    while (1) {\n        xgmac_read_desc(s, &bd, 0);\n        if ((bd.ctl_stat & 0x80000000) == 0) {\n            break;\n        }\n        len = (bd.buffer1_size & 0xfff) + (bd.buffer2_size & 0xfff);\n        if ((bd.buffer1_size & 0xfff) > 2048) {\n            DEBUGF_BRK(\"qemu:%s:ERROR...ERROR...ERROR... -- \"\n                        \"xgmac buffer 1 len on send > 2048 (0x%x)\\n\",\n                         __func__, bd.buffer1_size & 0xfff);\n        }\n        if ((bd.buffer2_size & 0xfff) != 0) {\n            DEBUGF_BRK(\"qemu:%s:ERROR...ERROR...ERROR... -- \"\n                        \"xgmac buffer 2 len on send != 0 (0x%x)\\n\",\n                        __func__, bd.buffer2_size & 0xfff);\n        }\n        if (len >= sizeof(frame)) {\n            DEBUGF_BRK(\"qemu:%s: buffer overflow %d read into %zu \"\n                        \"buffer\\n\" , __func__, len, sizeof(frame));\n            DEBUGF_BRK(\"qemu:%s: buffer1.size=%d; buffer2.size=%d\\n\",\n                        __func__, bd.buffer1_size, bd.buffer2_size);\n        }\n        cpu_physical_memory_read(bd.buffer1_addr, ptr, len);\n        ptr += len;\n        frame_size += len;\n        if (bd.ctl_stat & 0x20000000) {\n            qemu_send_packet(qemu_get_queue(s->nic), frame, len);\n            ptr = frame;\n            frame_size = 0;\n            s->regs[DMA_STATUS] |= DMA_STATUS_TI | DMA_STATUS_NIS;\n        }\n        bd.ctl_stat &= ~0x80000000;\n        xgmac_write_desc(s, &bd, 0);\n    }\n}", "target": 1}
{"code": "static void init_defrootdomain(void)\n{\n\tinit_rootdomain(&def_root_domain);\n\tatomic_set(&def_root_domain.refcount, 1);\n}", "target": 0}
{"code": "QPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    while (xref_offset)\n    {\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n\tthis->m->file->seek(xref_offset, SEEK_SET);\n\tthis->m->file->read(buf, sizeof(buf) - 1);\n        if ((strncmp(buf, \"xref\", 4) == 0) &&\n            QUtil::is_space(buf[4]))\n\t{\n            QTC::TC(\"qpdf\", \"QPDF xref space\",\n                    ((buf[4] == '\\n') ? 0 :\n                     (buf[4] == '\\r') ? 1 :\n                     (buf[4] == ' ') ? 2 : 9999));\n            int skip = 4;\n            while (QUtil::is_space(buf[skip]))\n            {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n\t}\n\telse\n\t{\n\t    xref_offset = read_xrefStream(xref_offset);\n\t}\n    }\n    if (! this->m->trailer.isInitialized())\n    {\n        throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n                      \"unable to find trailer while reading xref\");\n    }\n    int size = this->m->trailer.getKey(\"/Size\").getIntValue();\n    int max_obj = 0;\n    if (! this->m->xref_table.empty())\n    {\n\tmax_obj = (*(this->m->xref_table.rbegin())).first.getObj();\n    }\n    if (! this->m->deleted_objects.empty())\n    {\n\tmax_obj = std::max(max_obj, *(this->m->deleted_objects.rbegin()));\n    }\n    if (size != max_obj + 1)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n\t\t     std::string(\"reported number of objects (\") +\n\t\t     QUtil::int_to_string(size) +\n\t\t     \") inconsistent with actual number of objects (\" +\n\t\t     QUtil::int_to_string(max_obj + 1) + \")\"));\n    }\n    this->m->deleted_objects.clear();\n}", "target": 1}
{"code": "PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)\n{\n\tvar_entries *orig_var_entries = (*var_hash)->last;\n\tzend_long orig_used_slots = orig_var_entries ? orig_var_entries->used_slots : 0;\n\tint result;\n\tresult = php_var_unserialize_internal(UNSERIALIZE_PASSTHRU);\n\tif (!result) {\n\t\tvar_entries *e = orig_var_entries;\n\t\tzend_long s = orig_used_slots;\n\t\twhile (e) {\n\t\t\tfor (; s < e->used_slots; s++) {\n\t\t\t\te->data[s] = NULL;\n\t\t\t}\n\t\t\te = e->next;\n\t\t\ts = 0;\n\t\t}\n\t}\n\treturn result;\n}", "target": 0}
{"code": "static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tif (!ax25_sk(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_namelen != 0) {\n\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\t\tax25_digi digi;\n \t\tax25_address src;\n \t\tconst unsigned char *mac = skb_mac_header(skb);\n \t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n \t\t\t\t&digi, NULL, NULL);\n \t\tsax->sax25_family = AF_AX25;\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\tskb_free_datagram(sk, skb);\n\terr = copied;\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "my_pipe_sig_handler(int sig __attribute__((unused)))\n{\n  DBUG_PRINT(\"info\",(\"Hit by signal %d\",sig));\n#ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY\n  (void) signal(SIGPIPE, my_pipe_sig_handler);\n#endif\n}", "target": 0}
{"code": "void LinkInfo::print() {\n  ResourceMark rm;\n  tty->print_cr(\"Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s check_loader_constraints=%s\",\n                _resolved_klass->name()->as_C_string(),\n                _name->as_C_string(),\n                _signature->as_C_string(),\n                _current_klass == NULL ? \"(none)\" : _current_klass->name()->as_C_string(),\n                _check_access ? \"true\" : \"false\",\n                _check_loader_constraints ? \"true\" : \"false\");\n}", "target": 0}
{"code": "DLLIMPORT int cfg_setnbool(cfg_t *cfg, const char *name, cfg_bool_t value, unsigned int index)\n{\n\treturn cfg_opt_setnbool(cfg_getopt(cfg, name), value, index);\n}", "target": 0}
{"code": "ppm_load_read_header(FILE       *fp,\n                     pnm_struct *img)\n{\n    gchar *ptr;\n    gchar  header[MAX_CHARS_IN_ROW];\n    gint   maxval;\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    if (header[0] != ASCII_P ||\n        (header[1] != PIXMAP_ASCII &&\n         header[1] != PIXMAP_RAW))\n      {\n        g_warning (\"Image is not a portable pixmap\");\n        return FALSE;\n      }\n    img->type = header[1];\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    while(header[0] == '#')\n      {\n        fgets (header,MAX_CHARS_IN_ROW,fp);\n      }\n    img->width  = strtol (header,&ptr,0);\n    img->height = atoi (ptr);\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    maxval = strtol (header,&ptr,0);\n    if ((maxval != 255) && (maxval != 65535))\n      {\n        g_warning (\"Image is not an 8-bit or 16-bit portable pixmap\");\n        return FALSE;\n      }\n  switch (maxval)\n    {\n    case 255:\n      img->bpc = sizeof (guchar);\n      break;\n    case 65535:\n      img->bpc = sizeof (gushort);\n      break;\n    default:\n      g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n    }\n    if (!img->width || !img->height ||\n        G_MAXSIZE / img->width / img->height / CHANNEL_COUNT < img->bpc)\n      {\n        g_warning (\"Illegal width/height: %ld/%ld\", img->width, img->height);\n        return FALSE;\n      }\n    img->numsamples = img->width * img->height * CHANNEL_COUNT;\n    return TRUE;\n}", "target": 1}
{"code": "static zend_bool php_auto_globals_create_request(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *form_variables;\n\tunsigned char _gpc_flags[3] = {0, 0, 0};\n\tchar *p;\n\tALLOC_ZVAL(form_variables);\n\tarray_init(form_variables);\n\tINIT_PZVAL(form_variables);\n\tif (PG(request_order) != NULL) {\n\t\tp = PG(request_order);\n\t} else {\n\t\tp = PG(variables_order);\n\t}\n\tfor (; p && *p; p++) {\n\t\tswitch (*p) {\n\t\t\tcase 'g':\n\t\t\tcase 'G':\n\t\t\t\tif (!_gpc_flags[0]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_GET]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[0] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\tcase 'P':\n\t\t\t\tif (!_gpc_flags[1]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_POST]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[1] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\tif (!_gpc_flags[2]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_COOKIE]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[2] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &form_variables, sizeof(zval *), NULL);\n\treturn 0;\n}", "target": 0}
{"code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}", "target": 1}
{"code": "static uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}", "target": 1}
{"code": "bool lua_datum::is_number() const\n{\n    LUA_CHECK_TYPE(lua_isnumber);\n}", "target": 0}
{"code": "void vsock_add_pending(struct sock *listener, struct sock *pending)\n{\n\tstruct vsock_sock *vlistener;\n\tstruct vsock_sock *vpending;\n\tvlistener = vsock_sk(listener);\n\tvpending = vsock_sk(pending);\n\tsock_hold(pending);\n\tsock_hold(listener);\n\tlist_add_tail(&vpending->pending_links, &vlistener->pending_links);\n}", "target": 0}
{"code": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n \tlong err;\n \tint i;\n\tif (nsops < 1)\n \t\treturn -EINVAL;\n \tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n \tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}", "target": 1}
{"code": "methodHandle LinkResolver::lookup_instance_method_in_klasses(Klass* klass,\n                                                             Symbol* name,\n                                                             Symbol* signature,\n                                                             Klass::PrivateLookupMode private_mode, TRAPS) {\n  Method* result = klass->uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);\n  while (result != NULL && result->is_static() && result->method_holder()->super() != NULL) {\n    Klass* super_klass = result->method_holder()->super();\n    result = super_klass->uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);\n  }\n  if (klass->is_array_klass()) {\n    return methodHandle(THREAD, result);\n  }\n  if (result == NULL) {\n    Array<Method*>* default_methods = InstanceKlass::cast(klass)->default_methods();\n    if (default_methods != NULL) {\n      result = InstanceKlass::find_method(default_methods, name, signature);\n      assert(result == NULL || !result->is_static(), \"static defaults not allowed\");\n    }\n  }\n  return methodHandle(THREAD, result);\n}", "target": 0}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    CString sModPath, sTmp;\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}", "target": 0}
{"code": "char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n    int l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\nencrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n\t\t\treturn estrndup(value, value_len);\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n\t\t}\n\t}\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\tvalue_len = php_url_decode(buf2, value_len);\n\td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n\td_url = php_url_encode(d, strlen(d), &l);\n\tefree(d);\n    if (buf != buffer) {\n\t\tefree(buf);\n\t}\n    if (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn d_url;\n}", "target": 1}
{"code": "dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n\t\t\t  proto_tree *tree, guint8 *drep _U_, char **data,\n\t\t\t  int hf_name)\n{\n\tgint len, remaining;\n\tchar *text;\n\tif (offset % 2)\n\t\toffset += 2 - (offset % 2);\n\tremaining = tvb_captured_length_remaining(tvb, offset);\n\tif (remaining <= 0) {\n\t\tif (data)\n\t\t\t*data = g_strdup(\"\");\n\t\treturn offset;\n\t}\n\ttext = tvb_get_string_enc(NULL, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\tlen = (int)strlen(text);\n\tproto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text);\n\tif (data)\n\t\t*data = text;\n\telse\n\t\tg_free(text);\n\treturn offset + (len + 1) * 2;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType DrawPatternPath(Image *image,\n  const DrawInfo *draw_info,const char *name,Image **pattern,\n  ExceptionInfo *exception)\n{\n  char\n    property[MagickPathExtent];\n  const char\n    *geometry,\n    *path,\n    *type;\n  DrawInfo\n    *clone_info;\n  ImageInfo\n    *image_info;\n  MagickBooleanType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  assert(name != (const char *) NULL);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s\",name);\n  path=GetImageArtifact(image,property);\n  if (path == (const char *) NULL)\n    return(MagickFalse);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-geometry\",name);\n  geometry=GetImageArtifact(image,property);\n  if (geometry == (const char *) NULL)\n    return(MagickFalse);\n  if ((*pattern) != (Image *) NULL)\n    *pattern=DestroyImage(*pattern);\n  image_info=AcquireImageInfo();\n  image_info->size=AcquireString(geometry);\n  *pattern=AcquireImage(image_info,exception);\n  image_info=DestroyImageInfo(image_info);\n  (void) QueryColorCompliance(\"#00000000\",AllCompliance,\n    &(*pattern)->background_color,exception);\n  (void) SetImageBackgroundColor(*pattern,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"begin pattern-path %s %s\",name,geometry);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=DestroyImage(clone_info->stroke_pattern);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-type\",name);\n  type=GetImageArtifact(image,property);\n  if (type != (const char *) NULL)\n    clone_info->gradient.type=(GradientType) ParseCommandOption(\n      MagickGradientOptions,MagickFalse,type);\n  (void) CloneString(&clone_info->primitive,path);\n  status=RenderMVGContent(*pattern,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end pattern-path\");\n  return(status);\n}", "target": 0}
{"code": "static ssize_t stream_writev_cb(RedStream *s, const struct iovec *iov, int iovcnt)\n{\n    ssize_t ret = 0;\n    do {\n        int tosend;\n        ssize_t n, expected = 0;\n        int i;\n#ifdef IOV_MAX\n        tosend = MIN(iovcnt, IOV_MAX);\n#else\n        tosend = iovcnt;\n#endif\n        for (i = 0; i < tosend; i++) {\n            expected += iov[i].iov_len;\n        }\n        n = socket_writev(s->socket, iov, tosend);\n        if (n <= expected) {\n            if (n > 0)\n                ret += n;\n            return ret == 0 ? n : ret;\n        }\n        ret += n;\n        iov += tosend;\n        iovcnt -= tosend;\n    } while(iovcnt > 0);\n    return ret;\n}", "target": 0}
{"code": "GF_Err prft_box_size(GF_Box *s)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox*)s;\n\tptr->size += 4+8+ (ptr->version ? 8 : 4);\n\treturn GF_OK;\n}", "target": 0}
{"code": "   Format a local time/date according to locale settings */\nPHP_FUNCTION(strftime)\n{\n\tphp_strftime(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);", "target": 0}
{"code": "mail_parser_run (EMailParser *parser,\n                 EMailPartList *part_list,\n                 GCancellable *cancellable)\n{\n\tEMailExtensionRegistry *reg;\n\tCamelMimeMessage *message;\n\tEMailPart *mail_part;\n\tGQueue *parsers;\n\tGQueue mail_part_queue = G_QUEUE_INIT;\n\tGList *iter;\n\tGString *part_id;\n\tif (cancellable)\n\t\tg_object_ref (cancellable);\n\telse\n\t\tcancellable = g_cancellable_new ();\n\tg_mutex_lock (&parser->priv->mutex);\n\tg_hash_table_insert (parser->priv->ongoing_part_lists, cancellable, part_list);\n\tg_mutex_unlock (&parser->priv->mutex);\n\tmessage = e_mail_part_list_get_message (part_list);\n\treg = e_mail_parser_get_extension_registry (parser);\n\tparsers = e_mail_extension_registry_get_for_mime_type (\n\t\treg, \"application/vnd.evolution.message\");\n\tif (parsers == NULL)\n\t\tparsers = e_mail_extension_registry_get_for_mime_type (\n\t\t\treg, \"message\n\tg_return_if_fail (parsers != NULL);\n\tpart_id = g_string_new (\".message\");\n\tmail_part = e_mail_part_new (CAMEL_MIME_PART (message), \".message\");\n\te_mail_part_list_add_part (part_list, mail_part);\n\tg_object_unref (mail_part);\n\tfor (iter = parsers->head; iter; iter = iter->next) {\n\t\tEMailParserExtension *extension;\n\t\tgboolean message_handled;\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\t\textension = iter->data;\n\t\tif (!extension)\n\t\t\tcontinue;\n\t\tmessage_handled = e_mail_parser_extension_parse (\n\t\t\textension, parser,\n\t\t\tCAMEL_MIME_PART (message),\n\t\t\tpart_id, cancellable, &mail_part_queue);\n\t\tif (message_handled)\n\t\t\tbreak;\n\t}\n\twhile (!g_queue_is_empty (&mail_part_queue)) {\n\t\tmail_part = g_queue_pop_head (&mail_part_queue);\n\t\te_mail_part_list_add_part (part_list, mail_part);\n\t\tg_object_unref (mail_part);\n\t}\n\tg_mutex_lock (&parser->priv->mutex);\n\tg_hash_table_remove (parser->priv->ongoing_part_lists, cancellable);\n\tg_mutex_unlock (&parser->priv->mutex);\n\tg_clear_object (&cancellable);\n\tg_string_free (part_id, TRUE);\n}", "target": 1}
{"code": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n    authResult = rfbClientSwap32IfLE(authResult);\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "target": 1}
{"code": "void RenderView::didClearWindowObject(WebFrame* frame) {\n  if (BindingsPolicy::is_dom_automation_enabled(enabled_bindings_))\n    BindDOMAutomationController(frame);\n  if (BindingsPolicy::is_dom_ui_enabled(enabled_bindings_)) {\n    dom_ui_bindings_.set_message_sender(this);\n    dom_ui_bindings_.set_routing_id(routing_id_);\n    dom_ui_bindings_.BindToJavascript(frame, L\"chrome\");\n  }\n  if (BindingsPolicy::is_external_host_enabled(enabled_bindings_)) {\n    external_host_bindings_.set_message_sender(this);\n    external_host_bindings_.set_routing_id(routing_id_);\n    external_host_bindings_.BindToJavascript(frame, L\"externalHost\");\n  }\n}", "target": 0}
{"code": "extract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n    gboolean result = FALSE;\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n            goto out;\n        }\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}", "target": 1}
{"code": "static void __exit vmx_exit(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\tkvm_exit();\n}", "target": 0}
{"code": "static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n \t\ttu->tstamp = *tstamp;\n \tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n \t\treturn;\n \tr1.event = event;\n \tr1.tstamp = *tstamp;\n \tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}", "target": 1}
{"code": "onig_region_new(void)\n{\n  OnigRegion* r;\n  r = (OnigRegion* )xmalloc(sizeof(OnigRegion));\n  CHECK_NULL_RETURN(r);\n  onig_region_init(r);\n  return r;\n}", "target": 0}
{"code": "jsi_wsGetHeaders(jsi_wsPss *pss, struct lws *wsi, Jsi_DString* dStr, int lens[], int hmax)\n{\n    int n = 0, i = 0, nlen;\n    char buf[1000];\n    const char *cp;\n    while ((cp = (char*)lws_token_to_string((enum lws_token_indexes)n))) {\n        int len = lws_hdr_copy(wsi, buf, sizeof(buf), ( enum lws_token_indexes)n);\n        n++;\n        if (i>=(n*2+2)) break;\n        if (len<=0) continue;\n        buf[sizeof(buf)-1] = 0;\n        if (!buf[0]) continue;\n        nlen = Jsi_Strlen(cp);\n        if (nlen>0 && cp[nlen-1]==' ') nlen--;\n        if (nlen>0 && cp[nlen-1]==':') nlen--;\n        Jsi_DSAppendLen(dStr, cp, nlen);\n        Jsi_DSAppend(dStr, \"=\", buf, \"\\n\", NULL);\n        if (lens) {\n            lens[i++] = nlen;\n            lens[i++] = Jsi_Strlen(buf);\n        }\n    }\n    return i;\n}", "target": 1}
{"code": "static int netbk_count_requests(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_tx_request *first,\n\t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n\tdo {\n\t\tif (frags >= work_to_do) {\n\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n\t\t       sizeof(*txp));\n\t\tif (txp->size > first->size) {\n\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tfirst->size -= txp->size;\n\t\tfrags++;\n\t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n\t\t\t\t txp->offset, txp->size);\n\t\t\treturn -frags;\n\t\t}\n\t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}", "target": 1}
{"code": "parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}", "target": 1}
{"code": "uint32_t ldl_le_phys(AddressSpace *as, hwaddr addr)\n{\n    return address_space_ldl_le(as, addr, MEMTXATTRS_UNSPECIFIED, NULL);\n}", "target": 0}
{"code": "static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "void nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settings &ext)\n{\n    std::string &remark = node.Remark, original_remark = node.Remark, returned_remark, real_rule;\n    for(const RegexMatchConfig &x : rename_array)\n    {\n        if(!x.Script.empty())\n        {\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto rename = (std::function<std::string(const Proxy&)>) ctx.eval(\"rename\");\n                    returned_remark = rename(node);\n                    if(!returned_remark.empty())\n                        remark = returned_remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            continue;\n        }\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size())\n            remark = regReplace(remark, real_rule, x.Replace);\n    }\n    if(remark.empty())\n        remark = original_remark;\n    return;\n}", "target": 1}
{"code": "static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)\n{\n    ASSERT(!(n < 4));\n    auto predecessor = n.minus({ 1 });\n    auto d = predecessor;\n    size_t r = 0;\n    {\n        auto div_result = d.divided_by(2);\n        while (div_result.remainder == 0) {\n            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        return n == 2;\n    }\n    for (auto a : tests) {\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {\n                skip_this_witness = true;\n                break;\n            }\n        }\n        if (skip_this_witness)\n            continue;\n        return false; \n    }\n    return true; \n}", "target": 1}
{"code": "storageRegisterFull(bool allbackends)\n{\n    if (virRegisterConnectDriver(&storageConnectDriver, false) < 0)\n        return -1;\n    if (virStorageBackendDriversRegister(allbackends) < 0)\n        return -1;\n    if (virSetSharedStorageDriver(&storageDriver) < 0)\n        return -1;\n    if (virRegisterStateDriver(&stateDriver) < 0)\n        return -1;\n    return 0;\n}", "target": 0}
{"code": "unsigned long kvm_vcpu_gfn_to_hva_prot(struct kvm_vcpu *vcpu, gfn_t gfn, bool *writable)\n{\n\tstruct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\treturn gfn_to_hva_memslot_prot(slot, gfn, writable);\n}", "target": 0}
{"code": "static void increment_offset(int64_t delta)\n{\n    if (unlikely(delta == 0))\n        return;\n    location.offset += delta;\n    set_curr_offs(location.offset);\n}", "target": 0}
{"code": "status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,\n uint32_t cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData)\n{\n Mutex::Autolock _l(mLock);\n    ALOGVV(\"command(), cmdCode: %d, mEffectInterface: %p\", cmdCode, mEffectInterface);\n if (mState == DESTROYED || mEffectInterface == NULL) {\n return NO_INIT;\n }\n     if (mStatus != NO_ERROR) {\n         return mStatus;\n     }\n     status_t status = (*mEffectInterface)->command(mEffectInterface,\n                                                    cmdCode,\n                                                    cmdSize,\n                                                   pCmdData,\n                                                   replySize,\n                                                   pReplyData);\n if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {\n uint32_t size = (replySize == NULL) ? 0 : *replySize;\n for (size_t i = 1; i < mHandles.size(); i++) {\n EffectHandle *h = mHandles[i];\n if (h != NULL && !h->destroyed_l()) {\n                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);\n }\n }\n }\n return status;\n}", "target": 1}
{"code": "int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr)\n{\n\tstruct usb_descriptor_header *header;\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\t\tif (header->bLength < 2) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\t\tif (header->bDescriptorType == type) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "ServiceWorkerScriptContext::ServiceWorkerScriptContext(\n    EmbeddedWorkerContextClient* embedded_context,\n    blink::WebServiceWorkerContextProxy* proxy)\n    : embedded_context_(embedded_context),\n      proxy_(proxy),\n      current_request_id_(kInvalidRequestId) {\n}", "target": 0}
{"code": "int Item_datetime::save_in_field(Field *field, bool no_conversions)\n{\n  field->set_notnull();\n  return field->store_time_dec(&ltime, decimals);\n}", "target": 0}
{"code": "fz_cmm_transform_color(fz_context *ctx, fz_icclink *link, unsigned short *dst, const unsigned short *src)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tctx->colorspace->cmm->transform_color(ctx->cmm_instance, link, dst, src);\n}", "target": 0}
{"code": "int snd_timer_global_new(char *id, int device, struct snd_timer **rtimer)\n{\n\tstruct snd_timer_id tid;\n\ttid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = -1;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\treturn snd_timer_new(NULL, id, &tid, rtimer);\n}", "target": 0}
{"code": "njs_json_parse_iterator(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *object)\n{\n    njs_int_t             ret;\n    njs_value_t           *key, wrapper;\n    njs_object_t          *obj;\n    njs_json_state_t      *state;\n    njs_object_prop_t     *prop;\n    njs_property_query_t  pq;\n    obj = njs_json_wrap_value(vm, &wrapper, object);\n    if (njs_slow_path(obj == NULL)) {\n        return NJS_ERROR;\n    }\n    state = njs_json_push_parse_state(vm, parse, &wrapper);\n    if (njs_slow_path(state == NULL)) {\n        return NJS_ERROR;\n    }\n    for ( ;; ) {\n        if (state->index < state->keys->length) {\n            njs_property_query_init(&pq, NJS_PROPERTY_QUERY_SET, 0);\n            key = &state->keys->start[state->index];\n            ret = njs_property_query(vm, &pq, &state->value, key);\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DECLINED) {\n                    state->index++;\n                    continue;\n                }\n                return NJS_ERROR;\n            }\n            prop = pq.lhq.value;\n            if (prop->type == NJS_WHITEOUT) {\n                state->index++;\n                continue;\n            }\n            state->prop = prop;\n            if (prop->type == NJS_PROPERTY && njs_is_object(&prop->value)) {\n                state = njs_json_push_parse_state(vm, parse, &prop->value);\n                if (state == NULL) {\n                    return NJS_ERROR;\n                }\n                continue;\n            }\n            if (prop->type == NJS_PROPERTY_REF\n                && njs_is_object(prop->value.data.u.value))\n            {\n                state = njs_json_push_parse_state(vm, parse,\n                                                  prop->value.data.u.value);\n                if (state == NULL) {\n                    return NJS_ERROR;\n                }\n                continue;\n            }\n        } else {\n            state = njs_json_pop_parse_state(vm, parse);\n            if (state == NULL) {\n                vm->retval = parse->retval;\n                return NJS_OK;\n            }\n        }\n        ret = njs_json_parse_iterator_call(vm, parse, state);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n}", "target": 1}
{"code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n  return 0;\nfail:\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}", "target": 1}
{"code": "static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\topendata->o_arg.open_flags = openflags;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, openflags);\n\t*res = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "init_ctx_nego(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t      OM_uint32 acc_negState, gss_OID supportedMech,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\tif (supportedMech == GSS_C_NO_OID) {\n\t\t*minor_status = ERR_SPNEGO_NO_MECH_FROM_ACCEPTOR;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (acc_negState == ACCEPT_DEFECTIVE_TOKEN) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (!(is_kerb_mech(supportedMech) &&\n\t      is_kerb_mech(sc->internal_mech)) &&\n\t    !g_OID_equal(supportedMech, sc->internal_mech)) {\n\t\tret = init_ctx_reselect(minor_status, sc,\n\t\t\t\t\tacc_negState, supportedMech,\n\t\t\t\t\tresponseToken, mechListMIC,\n\t\t\t\t\tnegState, tokflag);\n\t} else if (*responseToken == GSS_C_NO_BUFFER) {\n\t\tif (sc->mech_complete) {\n\t\t\t*negState = ACCEPT_COMPLETE;\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\tret = GSS_S_COMPLETE;\n\t\t} else {\n\t\t\t*minor_status = ERR_SPNEGO_NO_TOKEN_FROM_ACCEPTOR;\n\t\t\tmap_errcode(minor_status);\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t} else if ((*responseToken)->length == 0 && sc->mech_complete) {\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t} else if (sc->mech_complete) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\tsc->nego_done = 1;\n\treturn ret;\n}", "target": 0}
{"code": "static int b_unpack (lua_State *L) {\n  Header h;\n   const char *fmt = luaL_checkstring(L, 1);\n   size_t ld;\n   const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n   int n = 0;  \n   defaultoptions(&h);\n   while (*fmt) {\n     int opt = *fmt++;\n     size_t size = optsize(L, opt, &fmt);\n     pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n     luaL_checkstack(L, 2, \"too many results\");\n     switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  \n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, \"format 'c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size <= ld && pos <= ld - size,\n                           2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  \n  return n + 1;\n}", "target": 1}
{"code": "struct sk_buff *cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy,\n\t\t\t\t\t\t  int approxlen, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);\n\treturn __cfg80211_testmode_alloc_skb(rdev, approxlen, 0, 0, gfp);\n}", "target": 0}
{"code": "int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\tif (rt)\n\t\treturn 0;\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\t\tsk->sk_route_caps = 0;\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "MenuCacheDir* menu_cache_dup_root_dir( MenuCache* cache )\n{\n    MenuCacheDir* dir;\n    MENU_CACHE_LOCK;\n    dir = cache->root_dir;\n    if(G_LIKELY(dir))\n        menu_cache_item_ref(MENU_CACHE_ITEM(dir));\n    MENU_CACHE_UNLOCK;\n    return dir;\n}", "target": 0}
{"code": "static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,\n\t\t\t unsigned long fh, u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(tp->q)->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tNLA_PUT_STRING(skb, TCA_KIND, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n \tchar *rundir;\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;\n \trundir = get_rundir();\n \tif (!rundir)\n \t\treturn NULL;\n\tlen += strlen(rundir);\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n \t\treturn NULL;\n \t}\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\tfree(rundir);\n \t\treturn NULL;\n \t}\n \tret = mkdir_p(dest, 0755);\n \tif (ret < 0) {\n\t\tint l2 = 22 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = mkdir_p(dest, 0755);\n\t\tif (ret < 0) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);\n \tfree(rundir);\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\treturn NULL;\n\t}\n\treturn dest;\n}", "target": 1}
{"code": "static inline Quantum ScaleLongToQuantum(const unsigned int value)\n{\n  return((Quantum) value);\n}", "target": 0}
{"code": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\tstate->dev = dev;\n\tsd = &state->sd;\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int dsOpen(void) {\n    struct stat sb;\n    int retval;\n    char *path = server.diskstore_path;\n    if ((retval = stat(path,&sb) == -1) && errno != ENOENT) {\n        redisLog(REDIS_WARNING, \"Error opening disk store at %s: %s\",\n                path, strerror(errno));\n        return REDIS_ERR;\n    }\n    if (retval == 0 && S_ISDIR(sb.st_mode)) return REDIS_OK;\n    if (retval == 0 && !S_ISDIR(sb.st_mode)) {\n        redisLog(REDIS_WARNING,\"Disk store at %s is not a directory\", path);\n        return REDIS_ERR;\n    }\n    if (mkdir(path) == -1) {\n        redisLog(REDIS_WARNING,\"Disk store init failed creating dir %s: %s\",\n            path, strerror(errno));\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}", "target": 1}
{"code": "void ImageLoader::ImageNotifyFinished(ImageResourceContent* resource) {\n  RESOURCE_LOADING_DVLOG(1)\n      << \"ImageLoader::imageNotifyFinished \" << this\n      << \"; has pending load event=\" << pending_load_event_.IsActive();\n  DCHECK(failed_load_url_.IsEmpty());\n  DCHECK_EQ(resource, image_content_.Get());\n  if (loading_image_document_)\n    CHECK(image_complete_);\n  else\n    CHECK(!image_complete_);\n  image_complete_ = true;\n  delay_until_image_notify_finished_ = nullptr;\n  if (image_content_)\n    image_content_->UpdateImageAnimationPolicy();\n  UpdateLayoutObject();\n  if (image_content_ && image_content_->HasImage()) {\n    Image& image = *image_content_->GetImage();\n    if (IsHTMLImageElement(element_)) {\n      Image::RecordCheckerableImageUMA(image, Image::ImageType::kImg);\n    } else if (IsSVGImageElement(element_)) {\n      Image::RecordCheckerableImageUMA(image, Image::ImageType::kSvg);\n    }\n    if (image.IsSVGImage()) {\n      SVGImage& svg_image = ToSVGImage(image);\n      svg_image.CheckLoaded();\n      svg_image.UpdateUseCounters(GetElement()->GetDocument());\n    }\n  }\n  DispatchDecodeRequestsIfComplete();\n  if (loading_image_document_) {\n    CHECK(!pending_load_event_.IsActive());\n    return;\n  }\n  if (resource->ErrorOccurred()) {\n    pending_load_event_.Cancel();\n    Optional<ResourceError> error = resource->GetResourceError();\n    if (error && error->IsAccessCheck())\n      CrossSiteOrCSPViolationOccurred(AtomicString(error->FailingURL()));\n    if (!suppress_error_events_)\n      DispatchErrorEvent();\n    return;\n  }\n  CHECK(!pending_load_event_.IsActive());\n  pending_load_event_ = PostCancellableTask(\n      *GetElement()->GetDocument().GetTaskRunner(TaskType::kDOMManipulation),\n      FROM_HERE,\n      WTF::Bind(&ImageLoader::DispatchPendingLoadEvent, WrapPersistent(this),\n                WTF::Passed(IncrementLoadEventDelayCount::Create(\n                    GetElement()->GetDocument()))));\n}", "target": 0}
{"code": "static inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)\n{\n\treturn whichfork != XFS_COW_FORK &&\n\t\tXFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}", "target": 0}
{"code": "static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\\n\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6)\n             parse_profile_level_id(s, h264_data, value);\n     } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n         int ret;\n        if (value[strlen(value) - 1] == ',') {\n             av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n             return 0;\n         }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int __init blk_mq_init(void)\n{\n\tblk_mq_cpu_init();\n\thotcpu_notifier(blk_mq_queue_reinit_notify, 0);\n\treturn 0;\n}", "target": 0}
{"code": "    size_t PentaxDngMnHeader::write(IoWrapper& ioWrapper,\n                                   ByteOrder ) const\n    {\n        ioWrapper.write(signature_, sizeOfSignature());\n        return sizeOfSignature();\n    } ", "target": 0}
{"code": "void AddVersionKeyWorkItems(HKEY root,\n                            BrowserDistribution* dist,\n                            const Version& new_version,\n                            WorkItemList* list) {\n  std::wstring version_key(dist->GetVersionKey());\n  list->AddCreateRegKeyWorkItem(root, version_key);\n  std::wstring product_name(dist->GetAppShortCutName());\n  list->AddSetRegValueWorkItem(root, version_key, google_update::kRegNameField,\n                               product_name, true);  \n  list->AddSetRegValueWorkItem(root, version_key,\n                               google_update::kRegOopcrashesField,\n                               static_cast<DWORD>(1),\n                               false);  \n  list->AddSetRegValueWorkItem(root, version_key,\n                               google_update::kRegVersionField,\n                               UTF8ToWide(new_version.GetString()),\n                               true);  \n}", "target": 0}
{"code": "aura::Window::Windows Shell::GetAllRootWindows() {\n  CHECK(HasInstance());\n  return Shell::GetInstance()->window_tree_host_manager()->GetAllRootWindows();\n}", "target": 0}
{"code": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\tif (flags)\n\t\t*flags++ = '\\0';\t\n\tif (nodelist) {\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\tmode_flags = 0;\n\tif (flags) {\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\tnew->w.user_nodemask = nodes;\n\terr = 0;\nout:\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}", "target": 1}
{"code": "    static std::string indent(int depth)\n    {\n        std::string result;\n        while ( depth -- ) result += \"  \";\n        return result;\n    }", "target": 0}
{"code": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tint l2 = 22 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = mkdir_p(dest, 0755);\n\t\tif (ret < 0) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}", "target": 1}
{"code": "static __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\tunsigned int i;\n \tif (!(quirks & CP_RDESC_SWAPPED_MIN_MAX))\n \t\treturn rdesc;\n \tfor (i = 0; i < *rsize - 4; i++)\n \t\tif (rdesc[i] == 0x29 && rdesc[i + 2] == 0x19) {\n \t\t\trdesc[i] = 0x19;\n\t\t\trdesc[i + 2] = 0x29;\n\t\t\tswap(rdesc[i + 3], rdesc[i + 1]);\n\t\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static int ext4_split_extent(handle_t *handle,\n\t\t\t      struct inode *inode,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      int split_flag,\n\t\t\t      int flags)\n{\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\tint uninitialized;\n\tint split_flag1, flags1;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tuninitialized = ext4_ext_is_uninitialized(ex);\n\tif (map->m_lblk + map->m_len < ee_block + ee_len) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1 |\n\t\t\t\t       EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk + map->m_len, split_flag1, flags1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\text4_ext_drop_refs(path);\n\tpath = ext4_ext_find_extent(inode, map->m_lblk, path);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (map->m_lblk >= ee_block) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1;\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk, split_flag1, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\text4_ext_show_leaf(inode, path);\nout:\n\treturn err ? err : map->m_len;\n}", "target": 1}
{"code": "static long vhost_net_reset_owner(struct vhost_net *n)\n{\n\tstruct socket *tx_sock = NULL;\n\tstruct socket *rx_sock = NULL;\n\tlong err;\n\tmutex_lock(&n->dev.mutex);\n\terr = vhost_dev_check_owner(&n->dev);\n\tif (err)\n\t\tgoto done;\n\tvhost_net_stop(n, &tx_sock, &rx_sock);\n\tvhost_net_flush(n);\n\terr = vhost_dev_reset_owner(&n->dev);\ndone:\n\tmutex_unlock(&n->dev.mutex);\n\tif (tx_sock)\n\t\tfput(tx_sock->file);\n\tif (rx_sock)\n\t\tfput(rx_sock->file);\n\treturn err;\n}", "target": 0}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n\t\t}\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n\t}\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}", "target": 1}
{"code": "static void free_partitions(struct parsed_partitions *state)\n{\n\tvfree(state->parts);\n\tkfree(state);\n}", "target": 0}
{"code": "void LightProcess::runShadow(int fdin, int fdout) {\n  FILE *fin = fdopen(fdin, \"r\");\n  FILE *fout = fdopen(fdout, \"w\");\n  char buf[BUFFER_SIZE];\n  pollfd pfd[1];\n  pfd[0].fd = fdin;\n  pfd[0].events = POLLIN;\n  while (true) {\n    int ret = poll(pfd, 1, -1);\n    if (ret < 0 && errno == EINTR) {\n      continue;\n    }\n    if (pfd[0].revents & POLLIN) {\n      if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';\n      if (strncmp(buf, \"exit\", 4) == 0) {\n        Logger::Info(\"LightProcess exiting upon request\");\n        break;\n      } else if (strncmp(buf, \"popen\", 5) == 0) {\n        do_popen(fin, fout, m_afdt_fd);\n      } else if (strncmp(buf, \"pclose\", 6) == 0) {\n        do_pclose(fin, fout);\n      } else if (strncmp(buf, \"proc_open\", 9) == 0) {\n        do_proc_open(fin, fout, m_afdt_fd);\n      } else if (strncmp(buf, \"waitpid\", 7) == 0) {\n        do_waitpid(fin, fout);\n      } else if (strncmp(buf, \"change_user\", 11) == 0) {\n        do_change_user(fin, fout);\n      } else if (buf[0]) {\n        Logger::Info(\"LightProcess got invalid command: %.20s\", buf);\n      }\n    } else if (pfd[0].revents & POLLHUP) {\n      Logger::Error(\"Lost parent, LightProcess exiting\");\n      break;\n    }\n  }\n  fclose(fin);\n  fclose(fout);\n  ::close(m_afdt_fd);\n  remove(m_afdtFilename.c_str());\n  _Exit(0);\n}", "target": 1}
{"code": "    void kick()\n    {\n        if (!m_completion)\n            return;\n        Vector<WebTextCheckingResult> results;\n        const int misspellingStartOffset = 1;\n        const int misspellingLength = 8;\n        results.append(WebTextCheckingResult(WebTextCheckingTypeSpelling, misspellingStartOffset, misspellingLength));\n        m_completion->didFinishCheckingText(results);\n        m_completion = 0;\n    }", "target": 0}
{"code": "void nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "void STDCALL mysql_get_character_set_info(MYSQL *mysql, MY_CHARSET_INFO *csinfo)\n{\n  csinfo->number   = mysql->charset->number;\n  csinfo->state    = mysql->charset->state;\n  csinfo->csname   = mysql->charset->csname;\n  csinfo->name     = mysql->charset->name;\n  csinfo->comment  = mysql->charset->comment;\n  csinfo->mbminlen = mysql->charset->mbminlen;\n  csinfo->mbmaxlen = mysql->charset->mbmaxlen;\n  if (mysql->options.charset_dir)\n    csinfo->dir = mysql->options.charset_dir;\n  else\n    csinfo->dir = charsets_dir;\n}", "target": 0}
{"code": "ldns_fget_keyword_data(FILE *f, const char *keyword, const char *k_del, char *data,\n               const char *d_del, size_t data_limit)\n{\n       return ldns_fget_keyword_data_l(f, keyword, k_del, data, d_del,\n\t\t       data_limit, NULL);\n}", "target": 0}
{"code": "static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\t\tcb->args[0] = 1;\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "GF_Box *dvcC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVCC;\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static void build_dirs(char *src, char *dst, size_t src_prefix_len, size_t dst_prefix_len) {\n\tchar *p = src + src_prefix_len + 1;\n\tchar *q = dst + dst_prefix_len + 1;\n\tchar *r = dst + dst_prefix_len;\n\tstruct stat s;\n\tbool last = false;\n\t*r = '\\0';\n\tfor (; !last; p++, q++) {\n\t\tif (*p == '\\0') {\n\t\t\tlast = true;\n\t\t}\n\t\tif (*p == '\\0' || (*p == '/' && *(p - 1) != '/')) {\n\t\t\t*p = '\\0';\n\t\t\tif (stat(src, &s) == 0 && S_ISDIR(s.st_mode)) {\n\t\t\t\t*q = '\\0';\n\t\t\t\t*r = '/';\n\t\t\t\tr = q;\n\t\t\t\tmkdir_attr(dst, s.st_mode, 0, 0);\n\t\t\t}\n\t\t\tif (!last) {\n\t\t\t\t*p = '/';\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "TEST_F(ExprMatchTest, OrMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: {$or: [{$lte: ['$x', 3]}, {$gte: ['$y', 4]}]}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 3)));\n    ASSERT_TRUE(matches(BSON(\"y\" << 5)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 10)));\n}", "target": 0}
{"code": "void LibRaw::get_mem_image_format(int *width, int *height, int *colors,\n                                  int *bps) const\n{\n  if (S.flip & 4)\n  {\n    *width = S.height;\n    *height = S.width;\n  }\n  else\n  {\n    *width = S.width;\n    *height = S.height;\n  }\n  *colors = P1.colors;\n  *bps = O.output_bps;\n}", "target": 0}
{"code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n                 if (cid <= 0)\n                     continue;\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                 }\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}", "target": 1}
{"code": "cdf_timespec_to_timestamp(cdf_timestamp_t *t, const struct timeval *ts)\n{\n#ifndef __lint__\n\t(void)&t;\n\t(void)&ts;\n#endif\n#ifdef notyet\n\tstruct tm tm;\n\tif (gmtime_r(&ts->ts_sec, &tm) == NULL) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t*t = (ts->ts_usec / CDF_TIME_PREC) * CDF_TIME_PREC;\n\t*t = tm.tm_sec;\n\t*t += tm.tm_min * 60;\n\t*t += tm.tm_hour * 60 * 60;\n\t*t += tm.tm_mday * 60 * 60 * 24;\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "static RList *patch_relocs(RBin *b) {\n\tr_return_val_if_fail (b && b->iob.io && b->iob.io->desc, NULL);\n\tRBinObject *bo = r_bin_cur_object (b);\n\tRIO *io = b->iob.io;\n\tif (!bo || !bo->bin_obj) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_coff_obj *bin = (struct r_bin_coff_obj*)bo->bin_obj;\n\tif (bin->hdr.f_flags & COFF_FLAGS_TI_F_EXEC) {\n\t\treturn NULL;\n\t}\n\tif (!(io->cached & R_PERM_W)) {\n\t\teprintf (\n\t\t\t\"Warning: please run r2 with -e io.cache=true to patch \"\n\t\t\t\"relocations\\n\");\n\t\treturn NULL;\n\t}\n\tsize_t nimports = 0;\n\tint i;\n\tfor (i = 0; i < bin->hdr.f_nsyms; i++) {\n\t\tif (is_imported_symbol (&bin->symbols[i])) {\n\t\t\tnimports++;\n\t\t}\n\t\ti += bin->symbols[i].n_numaux;\n\t}\n\tut64 m_vaddr = UT64_MAX;\n\tif (nimports) {\n\t\tut64 offset = 0;\n\t\tRIOBank *bank = b->iob.bank_get (io, io->bank);\n\t\tRListIter *iter;\n\t\tRIOMapRef *mapref;\n\t\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\t\tRIOMap *map = b->iob.map_get (io, mapref->id);\n\t\t\tif (r_io_map_end (map) > offset) {\n\t\t\t\toffset = r_io_map_end (map);\n\t\t\t}\n\t\t}\n\t\tm_vaddr = R_ROUND (offset, 16);\n\t\tut64 size = nimports * BYTES_PER_IMP_RELOC;\n\t\tchar *muri = r_str_newf (\"malloc:\n\t\tRIODesc *desc = b->iob.open_at (io, muri, R_PERM_R, 0664, m_vaddr);\n\t\tfree (muri);\n\t\tif (!desc) {\n\t\t\treturn NULL;\n\t\t}\n\t\tRIOMap *map = b->iob.map_get_at (io, m_vaddr);\n\t\tif (!map) {\n\t\t\treturn NULL;\n\t\t}\n\t\tmap->name = strdup (\".imports.r2\");\n\t}\n\treturn _relocs_list (b, bin, true, m_vaddr);\n}", "target": 1}
{"code": "void ring_buffer_record_disable_cpu(struct ring_buffer *buffer, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn;\n\tcpu_buffer = buffer->buffers[cpu];\n\tatomic_inc(&cpu_buffer->record_disabled);\n}", "target": 0}
{"code": "static int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_debug(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\t*skip_dentries = i;\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn -EINVAL;\n}", "target": 1}
{"code": " static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n {\n\tstruct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};\n \tif (copy_to_user(arg, &ci, sizeof(ci)))\n \t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}", "target": 1}
{"code": "destroy_one_secret (gpointer data)\n{\n \tchar *secret = (char *) data;\ng_message (\"%s: destroying %s\", __func__, secret);\n \tmemset (secret, 0, strlen (secret));\n \tg_free (secret);\n }", "target": 1}
{"code": "static PixelChannels **DestroyPixelThreadSet(const Image *images,\n  PixelChannels **pixels)\n{\n  ssize_t\n    i;\n  size_t\n    rows;\n  assert(pixels != (PixelChannels **) NULL);\n  rows=MagickMax(GetImageListLength(images),(size_t)\n    GetMagickResourceLimit(ThreadResource));\n  for (i=0; i < (ssize_t) rows; i++)\n    if (pixels[i] != (PixelChannels *) NULL)\n      pixels[i]=(PixelChannels *) RelinquishMagickMemory(pixels[i]);\n  pixels=(PixelChannels **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}", "target": 0}
{"code": "static int rndis_query_response(USBNetState *s,\n                rndis_query_msg_type *buf, unsigned int length)\n{\n    rndis_query_cmplt_type *resp;\n    uint8_t infobuf[sizeof(oid_supported_list)];\n    uint32_t bufoffs, buflen;\n    int infobuflen;\n    unsigned int resplen;\n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (bufoffs + buflen > length)\n         return USB_RET_STALL;\n     infobuflen = ndis_query(s, le32_to_cpu(buf->OID),\n                             bufoffs + (uint8_t *) buf, buflen, infobuf,\n    resplen = sizeof(rndis_query_cmplt_type) +\n            ((infobuflen < 0) ? 0 : infobuflen);\n    resp = rndis_queue_response(s, resplen);\n    if (!resp)\n        return USB_RET_STALL;\n    resp->MessageType = cpu_to_le32(RNDIS_QUERY_CMPLT);\n    resp->RequestID = buf->RequestID; \n    resp->MessageLength = cpu_to_le32(resplen);\n    if (infobuflen < 0) {\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        resp->InformationBufferLength = cpu_to_le32(0);\n        resp->InformationBufferOffset = cpu_to_le32(0);\n        return 0;\n    }\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n    resp->InformationBufferOffset =\n            cpu_to_le32(infobuflen ? sizeof(rndis_query_cmplt_type) - 8 : 0);\n    resp->InformationBufferLength = cpu_to_le32(infobuflen);\n    memcpy(resp + 1, infobuf, infobuflen);\n    return 0;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem ) {\n    bson_iterator next = *elem;\n    int size;\n    bson_iterator_next( &next );\n    size = next.cur - elem->cur;\n    if ( name_or_null == NULL ) {\n        if( bson_ensure_space( b, size ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append( b, elem->cur, size );\n    }\n    else {\n        int data_size = size - 2 - strlen( bson_iterator_key( elem ) );\n        bson_append_estart( b, elem->cur[0], name_or_null, data_size );\n        bson_append( b, bson_iterator_value( elem ), data_size );\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "    bool LoaderNative::readDimensions()\n    {\n        if (!valid()) return false;\n        if (width_ != 0 || height_ != 0) return true;\n        const DataBuf data = getData();\n        if (data.size_ == 0) return false;\n        try {\n            Image::UniquePtr image = ImageFactory::open(data.pData_, data.size_);\n            if (image.get() == 0) return false;\n            image->readMetadata();\n            width_ = image->pixelWidth();\n            height_ = image->pixelHeight();\n        } catch (const AnyError& ) {\n#ifndef SUPPRESS_WARNINGS\n            EXV_WARNING << \"Invalid native preview image.\\n\";\n#endif\n            return false;\n        }\n        return true;\n    }", "target": 0}
{"code": "  void Parser::parse_block_comments()\n  {\n    Block_Obj block = block_stack.back();\n    while (lex< block_comment >()) {\n      bool is_important = lexed.begin[2] == '!';\n      String_Obj contents = parse_interpolated_chunk(lexed, true, false);\n      block->append(SASS_MEMORY_NEW(Comment, pstate, contents, is_important));\n    }\n  }", "target": 0}
{"code": "static bool torture_winbind_struct_endpwent(struct torture_context *torture)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\ttorture_comment(torture, \"Running WINBINDD_ENDPWENT (struct based)\\n\");\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_ENDPWENT, &req, &rep);\n\treturn true;\n}", "target": 0}
{"code": "static int vrend_decode_create_ve(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   struct pipe_vertex_element *ve = NULL;\n   int num_elements;\n   int i;\n   int ret;\n   if (length < 1)\n      return EINVAL;\n   if ((length - 1) % 4)\n      return EINVAL;\n   num_elements = (length - 1) / 4;\n   if (num_elements) {\n      ve = calloc(num_elements, sizeof(struct pipe_vertex_element));\n      if (!ve)\n         return ENOMEM;\n      for (i = 0; i < num_elements; i++) {\n          ve[i].src_offset = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_OFFSET(i));\n          ve[i].instance_divisor = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_INSTANCE_DIVISOR(i));\n          ve[i].vertex_buffer_index = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_VERTEX_BUFFER_INDEX(i));\n          ve[i].src_format = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_FORMAT(i));\n       }\n    }\n   return ret;\n}", "target": 1}
{"code": "static int sr9700_get_eeprom_len(struct net_device *netdev)\n{\n\treturn SR_EEPROM_LEN;\n}", "target": 0}
{"code": "static void reset_fdc_info(int mode)\n{\n\tint drive;\n\tFDCS->spec1 = FDCS->spec2 = -1;\n\tFDCS->need_configure = 1;\n\tFDCS->perp_mode = 1;\n\tFDCS->rawcmd = 0;\n\tfor (drive = 0; drive < N_DRIVE; drive++)\n\t\tif (FDC(drive) == fdc && (mode || UDRS->track != NEED_1_RECAL))\n\t\t\tUDRS->track = NEED_2_RECAL;\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get_until_ch( pj_scanner *scanner, \n\t\t\t\t   int until_char, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    while (PJ_SCAN_CHECK_EOF(s) && *s != until_char) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}", "target": 1}
{"code": "bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {\n  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n    if (fs.offset() == offset) {\n      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n      if (fd->is_static() == is_static) return true;\n    }\n  }\n  return false;\n}", "target": 0}
{"code": "static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)\n{\n  const char *it = s;\n  const char *end = s + len;\n  if (enc == ENCQUOTEDPRINTABLE)\n  {\n    struct Buffer buf = { 0 };\n    for (; it < end; ++it)\n    {\n      if (*it == '_')\n      {\n        mutt_buffer_addch(&buf, ' ');\n      }\n      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&\n               (!(it[2] & ~127) && hexval(it[2]) != -1))\n      {\n        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));\n        it += 2;\n      }\n      else\n      {\n        mutt_buffer_addch(&buf, *it);\n      }\n    }\n    mutt_buffer_addch(&buf, '\\0');\n    return buf.data;\n  }\n  else if (enc == ENCBASE64)\n  {\n    char *out = mutt_mem_malloc(3 * len / 4 + 1);\n    int dlen = mutt_b64_decode(out, it);\n    if (dlen == -1)\n    {\n      FREE(&out);\n      return NULL;\n    }\n    out[dlen] = '\\0';\n    return out;\n  }\n  assert(0); \n  return NULL;\n}", "target": 1}
{"code": "static void curlfile_ctor(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tchar *fname = NULL, *mime = NULL, *postname = NULL;\n\tint fname_len, mime_len, postname_len;\n\tzval *cf = return_value;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ss\", &fname, &fname_len, &mime, &mime_len, &postname, &postname_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (fname) {\n\t\tzend_update_property_string(curl_CURLFile_class, cf, \"name\", sizeof(\"name\")-1, fname TSRMLS_CC);\n\t}\n\tif (mime) {\n\t\tzend_update_property_string(curl_CURLFile_class, cf, \"mime\", sizeof(\"mime\")-1, mime TSRMLS_CC);\n\t}\n\tif (postname) {\n\t\tzend_update_property_string(curl_CURLFile_class, cf, \"postname\", sizeof(\"postname\")-1, postname TSRMLS_CC);\n\t}\n}", "target": 0}
{"code": "static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\talgo = nla_data(nla);\n\tstrcpy(algo->alg_name, auth->alg_name);\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\treturn 0;\n}", "target": 1}
{"code": "void usbredirparser_caps_set_cap(uint32_t *caps, int cap)\n{\n    caps[cap / 32] |= 1 << (cap % 32);\n}", "target": 0}
{"code": "table_map Item_direct_view_ref::used_tables() const\n{\n  DBUG_ASSERT(fixed);\n  if (get_depended_from())\n    return OUTER_REF_TABLE_BIT;\n  if (view->is_merged_derived() || view->merged || !view->table)\n  {\n    table_map used= (*ref)->used_tables();\n    return (used ?\n            used :\n            ((null_ref_table != NO_NULL_TABLE) ?\n             null_ref_table->map :\n             (table_map)0 ));\n  }\n  return view->table->map;\n}", "target": 0}
{"code": "struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *sock)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tconn->sd = accept(sock->sd, NULL, NULL);\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 1}
{"code": "static bool red_stream_write_u32_le(RedStream *s, uint32_t n)\n{\n    n = GUINT32_TO_LE(n);\n    return red_stream_write_all(s, &n, sizeof(uint32_t));\n}", "target": 0}
{"code": "kick_jobs(tube t, unsigned int n)\n{\n    if (buried_job_p(t)) return kick_buried_jobs(t, n);\n    return kick_delayed_jobs(t, n);\n}", "target": 0}
{"code": "unsigned short bebytes2ushort(const u8 *buf)\n{\n\tif (buf == NULL)\n\t\treturn 0U;\n\treturn (unsigned short) (buf[0] << 8 | buf[1]);\n}", "target": 0}
{"code": "static int hci_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct hci_ufilter uf;\n\tstruct sock *sk = sock->sk;\n\tint len, opt, err = 0;\n\tBT_DBG(\"sk %p, opt %d\", sk, optname);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tif (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tswitch (optname) {\n\tcase HCI_DATA_DIR:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_DIR)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase HCI_TIME_STAMP:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_TSTAMP)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase HCI_FILTER:\n \t\t{\n \t\t\tstruct hci_filter *f = &hci_pi(sk)->filter;\n \t\t\tuf.type_mask = f->type_mask;\n \t\t\tuf.opcode    = f->opcode;\n \t\t\tuf.event_mask[0] = *((u32 *) f->event_mask + 0);\n\t\t\tuf.event_mask[1] = *((u32 *) f->event_mask + 1);\n\t\t}\n\t\tlen = min_t(unsigned int, len, sizeof(uf));\n\t\tif (copy_to_user(optval, &uf, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "  Status BuildFeatureReaders(const OpInputList& ragged_values_list,\n                             const OpInputList& ragged_splits_list,\n                             const OpInputList& sparse_indices_list,\n                             const OpInputList& sparse_values_list,\n                             const OpInputList& dense_list, int64 batch_size,\n                             FeatureReaders* features) {\n    features->reserve(input_order_.size());\n    int next_ragged = 0;\n    int next_sparse = 0;\n    int next_dense = 0;\n    for (char c : input_order_) {\n      if (c == 'R') {\n        TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(\n            ragged_values_list[next_ragged], ragged_splits_list[next_ragged],\n            features));\n        next_ragged++;\n      } else if (c == 'S') {\n        TF_RETURN_IF_ERROR(BuildSparseFeatureReader(\n            sparse_indices_list[next_sparse], sparse_values_list[next_sparse],\n            batch_size, features));\n        next_sparse++;\n      } else if (c == 'D') {\n        TF_RETURN_IF_ERROR(\n            BuildDenseFeatureReader(dense_list[next_dense++], features));\n      } else {\n        return errors::InvalidArgument(\"Unexpected input_order value.\");\n      }\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static void gen8_logical_ring_enable_irq(struct intel_engine_cs *engine)\n{\n\tENGINE_WRITE(engine, RING_IMR,\n\t\t     ~(engine->irq_enable_mask | engine->irq_keep_mask));\n\tENGINE_POSTING_READ(engine, RING_IMR);\n}", "target": 0}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, (xmlHashDeallocator) xmlFreeID);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "TfLiteRegistration AddOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.custom_name = \"my_add\";\n  reg.builtin_code = tflite::BuiltinOperator_CUSTOM;\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* input1 = GetInput(context, node, 0);\n    const TfLiteTensor* input2 = GetInput(context, node, 1);\n    TfLiteTensor* output = GetOutput(context, node, 0);\n    TF_LITE_ENSURE_EQ(context, input1->dims->size, input2->dims->size);\n    for (int i = 0; i < input1->dims->size; ++i) {\n      TF_LITE_ENSURE_EQ(context, input1->dims->data[i], input2->dims->data[i]);\n    }\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(\n        context, output, TfLiteIntArrayCopy(input1->dims)));\n    return kTfLiteOk;\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    TF_LITE_ENSURE(context, a0);\n    TF_LITE_ENSURE(context, a0->data.f);\n    const TfLiteTensor* a1 = GetInput(context, node, 1);\n    TF_LITE_ENSURE(context, a1);\n    TF_LITE_ENSURE(context, a1->data.f);\n    TfLiteTensor* out = GetOutput(context, node, 0);\n    TF_LITE_ENSURE(context, out);\n    TF_LITE_ENSURE(context, out->data.f);\n    int num = a0->dims->data[0];\n    for (int i = 0; i < num; i++) {\n      out->data.f[i] = a0->data.f[i] + a1->data.f[i];\n    }\n    return kTfLiteOk;\n  };\n  return reg;\n}", "target": 1}
{"code": "long do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i;\n\tstruct hlist_head batch_hash[AIO_BATCH_HASH_SIZE] = { { 0, }, };\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: io_submit: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, batch_hash, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\taio_batch_free(batch_hash);\n\tput_ioctx(ctx);\n\treturn i ? i : ret;\n}", "target": 1}
{"code": "getSystemTempDir() {\n\tconst char *temp_dir = getenv(\"PASSENGER_TEMP_DIR\");\n\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\ttemp_dir = getenv(\"PASSENGER_TMPDIR\");\n\t\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\t\ttemp_dir = \"/tmp\";\n\t\t}\n\t}\n\treturn temp_dir;\n}", "target": 0}
{"code": "name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n\tfor (;;) {\n\t\tu8 label_len;\n\t\tif (j >= length) return -1;\n\t\tGET8(label_len);\n\t\tif (!label_len) break;\n\t\tif (label_len & 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end < 0) name_end = j;\n\t\t\tj = (((int)label_len & 0x3f) << 8) + ptr_low;\n\t\t\tif (j < 0 || j >= length) return -1;\n\t\t\tif (++ptr_count > length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len > 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 >= end) return -1;\n\t\t\t*cp++ = '.';\n\t\t}\n\t\tif (cp + label_len >= end) return -1;\n\t\tmemcpy(cp, packet + j, label_len);\n\t\tcp += label_len;\n\t\tj += label_len;\n\t}\n\tif (cp >= end) return -1;\n\t*cp = '\\0';\n\tif (name_end < 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}", "target": 1}
{"code": "policies_exit_policy_append_reject_star(smartlist_t **dest)\n{\n  append_exit_policy_string(dest, \"reject *:*\");\n}", "target": 0}
{"code": "static ssize_t __disk_events_show(unsigned int events, char *buf)\n{\n\tconst char *delim = \"\";\n\tssize_t pos = 0;\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\n\t\tif (events & (1 << i)) {\n\t\t\tpos += sprintf(buf + pos, \"%s%s\",\n\t\t\t\t       delim, disk_events_strs[i]);\n\t\t\tdelim = \" \";\n\t\t}\n\tif (pos)\n\t\tpos += sprintf(buf + pos, \"\\n\");\n\treturn pos;\n}", "target": 0}
{"code": "MagickPrivate void LocaleComponentTerminus(void)\n{\n  if (locale_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&locale_semaphore);\n  LockSemaphoreInfo(locale_semaphore);\n  if (locale_cache != (SplayTreeInfo *) NULL)\n    locale_cache=DestroySplayTree(locale_cache);\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  DestroyCLocale();\n#endif\n  UnlockSemaphoreInfo(locale_semaphore);\n  RelinquishSemaphoreInfo(&locale_semaphore);\n}", "target": 0}
{"code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\tmutex_lock(&dev->lock);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tret = 0;\n exit:\n \tmutex_unlock(&dev->lock);\n\treturn ret <= 0 ? ret : -EIO;\n }", "target": 1}
{"code": "size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n    struct filter_op *array = NULL;\n    struct unfold_elm *ue;\n   BUG_IF(tree_root == NULL);\n    fprintf(stdout, \" Unfolding the meta-tree \");\n    fflush(stdout);\n   unfold_blk(&tree_root);\n   fprintf(stdout, \" done.\\n\\n\");\n   labels_to_offsets();\n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   *fop = array;\n   return (i);\n}", "target": 1}
{"code": "static inline struct kvm_mmu_page *page_header(hpa_t shadow_page)\n{\n\tstruct page *page = pfn_to_page(shadow_page >> PAGE_SHIFT);\n\treturn (struct kvm_mmu_page *)page_private(page);\n}", "target": 0}
{"code": "transientObjectPutErrorMessage(Runtime *runtime, Handle<> base, SymbolID id) {\n  StringView propName =\n      runtime->getIdentifierTable().getStringView(runtime, id);\n  Handle<StringPrimitive> baseType =\n      runtime->makeHandle(vmcast<StringPrimitive>(typeOf(runtime, base)));\n  StringView baseTypeAsString =\n      StringPrimitive::createStringView(runtime, baseType);\n  MutableHandle<StringPrimitive> valueAsString{runtime};\n  if (base->isSymbol()) {\n    auto str = symbolDescriptiveString(runtime, Handle<SymbolID>::vmcast(base));\n    if (str != ExecutionStatus::EXCEPTION) {\n      valueAsString = *str;\n    } else {\n      runtime->clearThrownValue();\n      valueAsString = StringPrimitive::createNoThrow(\n          runtime, \"<<Exception occurred getting the value>>\");\n    }\n  } else {\n    auto str = toString_RJS(runtime, base);\n    assert(\n        str != ExecutionStatus::EXCEPTION &&\n        \"Primitives should be convertible to string without exceptions\");\n    valueAsString = std::move(*str);\n  }\n  StringView valueAsStringPrintable =\n      StringPrimitive::createStringView(runtime, valueAsString);\n  SmallU16String<32> tmp;\n  return runtime->raiseTypeError(\n      TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp) + \"'\");\n}", "target": 1}
{"code": "const void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn NULL;\n#else\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\treturn trak->tfrf;\n#endif\n}", "target": 0}
{"code": "TEST(QuantizedPoolingOpTest, AveragePoolActivationRelu) {\n  QuantizedPoolingOpModel m(\n      BuiltinOperator_AVERAGE_POOL_2D,\n      {TensorType_UINT8, {1, 2, 4, 1}, -15.9375, 15.9375},\n      2, 2,\n      {TensorType_UINT8, {}, -15.9375, 15.9375}, Padding_VALID, 2, 2,\n      ActivationFunctionType_RELU);\n  m.SetInput({\n      0, -6, 2, 4,   \n      3, 2, -10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({0.0, 0.75})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({128, 134}));\n}", "target": 0}
{"code": "static void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 usage;\n\tint i, j, size;\n\tmutex_lock(&memcg->thresholds_lock);\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n \tBUG_ON(!thresholds);\n \tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\tnew = thresholds->spare;\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\tnew->size = size;\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold < usage) {\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\nswap_buffers:\n\tthresholds->spare = thresholds->primary;\n\trcu_assign_pointer(thresholds->primary, new);\n \tsynchronize_rcu();\n \tmutex_unlock(&memcg->thresholds_lock);\n }", "target": 1}
{"code": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup\");\n\treturn 0;\n}", "target": 1}
{"code": "static ZIPARCHIVE_METHOD(addFromString)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tchar *buffer, *name;\n\tint buffer_len, name_len;\n\tze_zip_object *ze_obj;\n\tstruct zip_source *zs;\n\tint pos = 0;\n\tint cur_idx;\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, this);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\",\n\t\t\t&name, &name_len, &buffer, &buffer_len) == FAILURE) {\n\t\treturn;\n\t}\n\tze_obj = (ze_zip_object*) zend_object_store_get_object(this TSRMLS_CC);\n\tif (ze_obj->buffers_cnt) {\n\t\tze_obj->buffers = (char **)erealloc(ze_obj->buffers, sizeof(char *) * (ze_obj->buffers_cnt+1));\n\t\tpos = ze_obj->buffers_cnt++;\n\t} else {\n\t\tze_obj->buffers = (char **)emalloc(sizeof(char *));\n\t\tze_obj->buffers_cnt++;\n\t\tpos = 0;\n\t}\n\tze_obj->buffers[pos] = (char *)emalloc(buffer_len + 1);\n\tmemcpy(ze_obj->buffers[pos], buffer, buffer_len + 1);\n\tzs = zip_source_buffer(intern, ze_obj->buffers[pos], buffer_len, 0);\n\tif (zs == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tcur_idx = zip_name_locate(intern, (const char *)name, 0);\n\tif (cur_idx >= 0) {\n\t\tif (zip_delete(intern, cur_idx) == -1) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (zip_add(intern, name, zs) != -1) {\n\t\tRETURN_TRUE;\n\t}\nfail:\n\tzip_source_free(zs);\n\tRETURN_FALSE;\n}", "target": 0}
{"code": "set_error_literal (GMarkupParseContext  *context,\n                   GError              **error,\n                   GMarkupError          code,\n                   const gchar          *message)\n{\n  GError *tmp_error;\n  tmp_error = g_error_new_literal (G_MARKUP_ERROR, code, message);\n  g_prefix_error (&tmp_error,\n                  _(\"Error on line %d char %d: \"),\n                  context->line_number,\n                  context->char_number);\n  mark_error (context, tmp_error);\n  g_propagate_error (error, tmp_error);\n}", "target": 0}
{"code": "enum io_wq_cancel io_wq_cancel_cb(struct io_wq *wq, work_cancel_fn *cancel,\n\t\t\t\t  void *data, bool cancel_all)\n{\n\tstruct io_cb_cancel_data match = {\n\t\t.fn\t\t= cancel,\n\t\t.data\t\t= data,\n\t\t.cancel_all\t= cancel_all,\n\t};\n\tint node;\n\tfor_each_node(node) {\n\t\tstruct io_wqe *wqe = wq->wqes[node];\n\t\tio_wqe_cancel_pending_work(wqe, &match);\n\t\tif (match.nr_pending && !match.cancel_all)\n\t\t\treturn IO_WQ_CANCEL_OK;\n\t}\n\tfor_each_node(node) {\n\t\tstruct io_wqe *wqe = wq->wqes[node];\n\t\tio_wqe_cancel_running_work(wqe, &match);\n\t\tif (match.nr_running && !match.cancel_all)\n\t\t\treturn IO_WQ_CANCEL_RUNNING;\n\t}\n\tif (match.nr_running)\n\t\treturn IO_WQ_CANCEL_RUNNING;\n\tif (match.nr_pending)\n\t\treturn IO_WQ_CANCEL_OK;\n\treturn IO_WQ_CANCEL_NOTFOUND;\n}", "target": 0}
{"code": "pam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = CS string_copy_malloc(arg); \n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n    case PAM_TEXT_INFO:    \n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n    default:  \n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n*resp = reply;\nreturn PAM_SUCCESS;\n}", "target": 1}
{"code": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}", "target": 1}
{"code": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n{\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "push_partial_as_tag (GMarkupParseContext *context)\n{\n  GString *str = context->partial_chunk;\n  context->tag_stack = g_slist_concat (get_list_node (context, str->str), context->tag_stack);\n  context->tag_stack_gstr = g_slist_concat (get_list_node (context, str), context->tag_stack_gstr);\n  context->partial_chunk = NULL;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& weights = context->input(1);\n    bool use_weights = weights.NumElements() > 0;\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsVector(data.shape()) ||\n                    TensorShapeUtils::IsMatrix(data.shape()),\n                errors::InvalidArgument(\n                    \"Input must be a 1 or 2-dimensional tensor. Got: \",\n                    data.shape().DebugString()));\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == data.shape(),\n          errors::InvalidArgument(\n              \"Weights and data must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; data shape: \", data.shape().DebugString()));\n    }\n    bool is_1d = TensorShapeUtils::IsVector(data.shape());\n    int negative_valued_axis = -1;\n    int num_batch_dimensions = (data.shape().dims() + negative_valued_axis);\n    int num_batch_elements = 1;\n    for (int i = 0; i < num_batch_dimensions; ++i) {\n      num_batch_elements *= data.shape().dim_size(i);\n    }\n    int num_value_elements = data.shape().num_elements() / num_batch_elements;\n    auto per_batch_counts = BatchedMap<W>(num_batch_elements);\n    T max_value = 0;\n    const auto data_values = data.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int i = 0;\n    for (int b = 0; b < num_batch_elements; ++b) {\n      for (int v = 0; v < num_value_elements; ++v) {\n        const auto& value = data_values(i);\n        if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n          if (binary_output_) {\n            per_batch_counts[b][value] = 1;\n          } else if (use_weights) {\n            per_batch_counts[b][value] += weight_values(i);\n          } else {\n            per_batch_counts[b][value]++;\n          }\n          if (value > max_value) {\n            max_value = value;\n          }\n        }\n        ++i;\n      }\n    }\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }", "target": 1}
{"code": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\tdown_write(&key->sem);\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}", "target": 1}
{"code": "SPL_METHOD(SplHeap, key)\n{\n\tspl_heap_object *intern = (spl_heap_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\t\t\n\tRETURN_LONG(intern->heap->count - 1);\n}", "target": 0}
{"code": "void PpapiPluginProcessHost::OnProcessLaunched() {\n   host_impl_->set_plugin_process_handle(process_->GetHandle());\n }", "target": 0}
{"code": "static void js_initvar(js_State *J, const char *name, int idx)\n{\n\tjsR_defproperty(J, J->E->variables, name, JS_DONTENUM | JS_DONTCONF, stackidx(J, idx), NULL, NULL);\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::CopyFromCompositingSurfaceFinishedForVideo(\n    base::WeakPtr<RenderWidgetHostViewAura> rwhva,\n    const base::Callback<void(bool)>& callback,\n    scoped_refptr<OwnedMailbox> subscriber_texture,\n    scoped_ptr<cc::SingleReleaseCallback> release_callback,\n    bool result) {\n  callback.Run(result);\n  GLHelper* gl_helper = ImageTransportFactory::GetInstance()->GetGLHelper();\n  uint32 sync_point = gl_helper ? gl_helper->InsertSyncPoint() : 0;\n  if (release_callback) {\n    DCHECK(!subscriber_texture);\n    release_callback->Run(sync_point, false);\n  }\n  ReturnSubscriberTexture(rwhva, subscriber_texture, sync_point);\n}", "target": 0}
{"code": "OMX_ERRORTYPE SimpleSoftOMXComponent::getParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n Mutex::Autolock autoLock(mLock);\n return internalGetParameter(index, params);\n}", "target": 0}
{"code": "rx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, int dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\tif (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))\n\t\treturn;\n\trxent = &rx_cache[rx_cache_next];\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\trxent->callnum = EXTRACT_32BITS(&rxh->callNumber);\n \tUNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));\n \tUNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));\n \trxent->dport = dport;\n\trxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);\n \trxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n }", "target": 1}
{"code": "void RenderThreadImpl::OnMemoryPressure(\n    base::MemoryPressureListener::MemoryPressureLevel memory_pressure_level) {\n  base::allocator::ReleaseFreeMemory();\n  if (webkit_platform_support_ && blink::mainThreadIsolate()) {\n    blink::mainThreadIsolate()->LowMemoryNotification();\n  }\n  if (memory_pressure_level ==\n      base::MemoryPressureListener::MEMORY_PRESSURE_CRITICAL) {\n    if (webkit_platform_support_) {\n      blink::WebImageCache::clear();\n    }\n    size_t font_cache_limit = SkGraphics::SetFontCacheLimit(0);\n    SkGraphics::SetFontCacheLimit(font_cache_limit);\n  }\n}", "target": 0}
{"code": "const char *ApplyChannelMatrix::name() const { return \"channelMatrix\"; }", "target": 0}
{"code": "get_parent_resource(const dav_resource *resource,\n                    dav_resource **parent_resource)\n{\n  dav_resource *parent;\n  dav_resource_private *parentinfo;\n  svn_stringbuf_t *path = resource->info->uri_path;\n  *parent_resource = NULL;\n  if (path->len == 1 && *path->data == '/')\n    return NULL;\n  switch (resource->type)\n    {\n    case DAV_RESOURCE_TYPE_REGULAR:\n      parent = apr_pcalloc(resource->pool, sizeof(*parent));\n      parentinfo  = apr_pcalloc(resource->pool, sizeof(*parentinfo));\n      parent->type = DAV_RESOURCE_TYPE_REGULAR;\n      parent->exists = 1;\n      parent->collection = 1;\n      parent->versioned = 1;\n      parent->hooks = resource->hooks;\n      parent->pool = resource->pool;\n      parent->uri = get_parent_path(svn_urlpath__canonicalize(resource->uri,\n                                                              resource->pool),\n                                    TRUE, resource->pool);\n      parent->info = parentinfo;\n      parentinfo->uri_path =\n        svn_stringbuf_create(get_parent_path(resource->info->uri_path->data,\n                                             TRUE, resource->pool),\n                             resource->pool);\n      parentinfo->repos = resource->info->repos;\n      parentinfo->root = resource->info->root;\n      parentinfo->r = resource->info->r;\n      parentinfo->svn_client_options = resource->info->svn_client_options;\n      parentinfo->repos_path = get_parent_path(resource->info->repos_path,\n                                               FALSE, resource->pool);\n      *parent_resource = parent;\n      break;\n    case DAV_RESOURCE_TYPE_WORKING:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_WRK_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_ACTIVITY:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_ACT_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_PRIVATE:\n      if ((resource->info->restype == DAV_SVN_RESTYPE_TXN_COLLECTION)\n          || (resource->info->restype == DAV_SVN_RESTYPE_REV_COLLECTION))\n        *parent_resource =\n          create_private_resource(resource, resource->info->restype);\n      break;\n    default:\n      break;\n    }\n  if (! *parent_resource)\n    return dav_svn__new_error(resource->pool, HTTP_INTERNAL_SERVER_ERROR, 0,\n                              apr_psprintf(resource->pool,\n                                           \"get_parent_resource was called for \"\n                                           \"%s (type %d)\",\n                                           resource->uri, resource->type));\n  return NULL;\n}", "target": 1}
{"code": "void LanLinkProvider::dataReceived()\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!socket->canReadLine())\n        return;\n#else\n    socket->startTransaction();\n#endif\n    const QByteArray data = socket->readLine();\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider received reply:\" << data;\n    NetworkPacket* np = new NetworkPacket(QLatin1String(\"\"));\n    bool success = NetworkPacket::unserialize(data, np);\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!success) {\n        delete np;\n        return;\n    }\n#else\n    if (!success) {\n        delete np;\n        socket->rollbackTransaction();\n        return;\n    }\n    socket->commitTransaction();\n#endif\n    if (np->type() != PACKET_TYPE_IDENTITY) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Expected identity, received \" << np->type();\n        delete np;\n        return;\n    }\n    m_receivedIdentityPackets[socket].np = np;\n    const QString& deviceId = np->get<QString>(QStringLiteral(\"deviceId\"));\n    disconnect(socket, &QIODevice::readyRead, this, &LanLinkProvider::dataReceived);\n    if (np->get<int>(QStringLiteral(\"protocolVersion\")) >= MIN_VERSION_WITH_SSL_SUPPORT) {\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        configureSslSocket(socket, deviceId, isDeviceTrusted);\n        qCDebug(KDECONNECT_CORE) << \"Starting client ssl (but I'm the server TCP socket)\";\n        connect(socket, &QSslSocket::encrypted, this, &LanLinkProvider::encrypted);\n        if (isDeviceTrusted) {\n            connect(socket, QOverload<const QList<QSslError> &>::of(&QSslSocket::sslErrors), this, &LanLinkProvider::sslErrors);\n        }\n        socket->startClientEncryption();\n    } else {\n        qWarning() << np->get<QString>(QStringLiteral(\"deviceName\")) << \"uses an old protocol version, this won't work\";\n        delete m_receivedIdentityPackets.take(socket).np;\n    }\n}", "target": 1}
{"code": "static const char *screen_units_str(void)\n{\n\tconst char *units_str[] = {N_(\"mil\"), N_(\"mm\"), N_(\"in\")};\n\treturn _(units_str[screen.unit]);\n}", "target": 0}
{"code": "static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n \tBT_DBG(\"sock %p, sk %p\", sock, sk);\n \tsa->rc_family  = AF_BLUETOOTH;\n \tsa->rc_channel = rfcomm_pi(sk)->channel;\n \tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->src);\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}", "target": 1}
{"code": "RegexMatchExpression::RegexMatchExpression(StringData path, StringData regex, StringData options)\n    : LeafMatchExpression(REGEX, path),\n      _regex(regex.toString()),\n      _flags(options.toString()),\n      _re(new pcrecpp::RE(_regex.c_str(), flags2options(_flags.c_str()))) {\n    _init();\n}", "target": 0}
{"code": "static inline void var_push(php_unserialize_data_t *var_hashx, zval *rval)\n{\n\tvar_entries *var_hash = (*var_hashx)->last;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_push(%ld): %d\\n\", var_hash?var_hash->used_slots:-1L, Z_TYPE_P(rval));\n#endif\n\tif (!var_hash || var_hash->used_slots == VAR_ENTRIES_MAX) {\n\t\tvar_hash = emalloc(sizeof(var_entries));\n\t\tvar_hash->used_slots = 0;\n\t\tvar_hash->next = 0;\n\t\tif (!(*var_hashx)->first) {\n\t\t\t(*var_hashx)->first = var_hash;\n\t\t} else {\n\t\t\t((var_entries *) (*var_hashx)->last)->next = var_hash;\n\t\t}\n\t\t(*var_hashx)->last = var_hash;\n\t}\n\tvar_hash->data[var_hash->used_slots++] = rval;\n}", "target": 0}
{"code": "bool cond_is_datetime_is_null(Item *cond)\n{\n  if (cond->type() == Item::FUNC_ITEM &&\n      ((Item_func*) cond)->functype() == Item_func::ISNULL_FUNC)\n  {\n    return ((Item_func_isnull*) cond)->arg_is_datetime_notnull_field();\n  }\n  return false;\n}", "target": 0}
{"code": "static int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint vector = exit_qualification & 0xff;\n\tkvm_apic_set_eoi_accelerated(vcpu, vector);\n\treturn 1;\n}", "target": 0}
{"code": "scrypt_SHA256_Update(struct SHA256_CTX * ctx, const void *in, size_t len)\n{\n  uint32_t bitlen[2];\n  uint32_t r;\n  const unsigned char *src = (unsigned char *) in;\n  r = (ctx->count[1] >> 3) & 0x3f;\n  bitlen[1] = ((uint32_t)len) << 3;\n  bitlen[0] = (uint32_t)(len >> 29);\n  if ((ctx->count[1] += bitlen[1]) < bitlen[1])\n    ctx->count[0]++;\n  ctx->count[0] += bitlen[0];\n  if (len < 64 - r) {\n    memcpy(&ctx->buf[r], src, len);\n    return;\n  }\n  memcpy(&ctx->buf[r], src, 64 - r);\n  SHA256_Transform(ctx->state, ctx->buf);\n  src += 64 - r;\n  len -= 64 - r;\n  while (len >= 64) {\n    SHA256_Transform(ctx->state, src);\n    src += 64;\n    len -= 64;\n  }\n  memcpy(ctx->buf, src, len);\n}", "target": 1}
{"code": "struct gendisk *alloc_disk(int minors)\n{\n\treturn alloc_disk_node(minors, NUMA_NO_NODE);\n}", "target": 0}
{"code": "void LinkResolver::resolve_invoke(CallInfo& result, Handle& recv,\n                             const methodHandle& attached_method,\n                             Bytecodes::Code byte, TRAPS) {\n  Klass* defc = attached_method->method_holder();\n  Symbol* name = attached_method->name();\n  Symbol* type = attached_method->signature();\n  LinkInfo link_info(defc, name, type);\n  switch(byte) {\n    case Bytecodes::_invokevirtual:\n      resolve_virtual_call(result, recv, recv->klass(), link_info,\n                           true, CHECK);\n      break;\n    case Bytecodes::_invokeinterface:\n      resolve_interface_call(result, recv, recv->klass(), link_info,\n                             true, CHECK);\n      break;\n    case Bytecodes::_invokestatic:\n      resolve_static_call(result, link_info, false, CHECK);\n      break;\n    case Bytecodes::_invokespecial:\n      resolve_special_call(result, recv, link_info, CHECK);\n      break;\n    default:\n      fatal(\"bad call: %s\", Bytecodes::name(byte));\n      break;\n  }\n}", "target": 0}
{"code": "static void carray(JF, js_Ast *list)\n{\n\tint i = 0;\n\twhile (list) {\n\t\tif (list->a->type != EXP_UNDEF) {\n\t\t\temitnumber(J, F, i++);\n\t\t\tcexp(J, F, list->a);\n\t\t\temit(J, F, OP_INITPROP);\n\t\t} else {\n\t\t\t++i;\n\t\t}\n\t\tlist = list->b;\n\t}\n}", "target": 0}
{"code": "nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\treturn 0;\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}", "target": 1}
{"code": "arista_print_date_hms_time(netdissect_options *ndo, uint32_t seconds,\n\t\tuint32_t nanoseconds)\n{\n\ttime_t ts;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tts = seconds + (nanoseconds / 1000000000);\n\tnanoseconds %= 1000000000;\n\tif (NULL == (tm = gmtime(&ts)))\n\t\tND_PRINT(\"gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\"strftime() error\");\n\telse\n\t\tND_PRINT(\"%s.%09u\", buf, nanoseconds);\n}", "target": 1}
{"code": "const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk)\n{\n  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;\n  return &chunk[total_chunk_length];\n}", "target": 0}
{"code": "ssize_t NuPlayer::NuPlayerStreamListener::read(\n void *data, size_t size, sp<AMessage> *extra) {\n    CHECK_GT(size, 0u);\n    extra->clear();\n Mutex::Autolock autoLock(mLock);\n if (mEOS) {\n return 0;\n }\n if (mQueue.empty()) {\n        mSendDataNotification = true;\n return -EWOULDBLOCK;\n }\n QueueEntry *entry = &*mQueue.begin();\n if (entry->mIsCommand) {\n switch (entry->mCommand) {\n case EOS:\n {\n                mQueue.erase(mQueue.begin());\n                entry = NULL;\n                mEOS = true;\n return 0;\n }\n case DISCONTINUITY:\n {\n *extra = entry->mExtra;\n                mQueue.erase(mQueue.begin());\n                entry = NULL;\n return INFO_DISCONTINUITY;\n }\n default:\n                TRESPASS();\n break;\n }\n }\n size_t copy = entry->mSize;\n if (copy > size) {\n         copy = size;\n     }\n     memcpy(data,\n           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()\n             + entry->mOffset,\n            copy);\n    entry->mOffset += copy;\n    entry->mSize -= copy;\n if (entry->mSize == 0) {\n        mSource->onBufferAvailable(entry->mIndex);\n        mQueue.erase(mQueue.begin());\n        entry = NULL;\n }\n return copy;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& rhs = context->input(1);\n    context->forward_ref_input_to_ref_output(0, 0);\n    AllocatorAttributes attr;\n    if (!relax_constraints_) {\n      attr.set_gpu_compatible(true);\n      attr.set_nic_compatible(true);\n    }\n    {\n      mutex_lock l(*context->input_ref_mutex(0));\n      const Tensor& old_lhs = context->mutable_input(0,  true);\n      const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape());\n      if (validate_shape_) {\n        OP_REQUIRES(context, same_shape,\n                    errors::InvalidArgument(\n                        \"Assign requires shapes of both tensors to match. \"\n                        \"lhs shape= \",\n                        old_lhs.shape().DebugString(),\n                        \" rhs shape= \", rhs.shape().DebugString()));\n      }\n      if (old_lhs.IsInitialized() &&\n          old_lhs.shape().num_elements() == rhs.shape().num_elements()) {\n        Tensor reshaped_old_lhs;\n        if (same_shape) {\n          reshaped_old_lhs = old_lhs;\n        } else {\n          CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape()));\n          context->replace_ref_input(0, reshaped_old_lhs,\n                                      true);\n        }\n        if (use_exclusive_lock_) {\n          Copy(context, &reshaped_old_lhs, rhs);\n          return;\n        }\n      } else {\n        std::unique_ptr<Tensor> input_alias = context->forward_input(\n            1, OpKernelContext::Params::kNoReservation ,\n            rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr);\n        if (input_alias != nullptr) {\n          context->replace_ref_input(0, *input_alias,  true);\n          return;\n        }\n        Tensor copy_tensor;\n        OP_REQUIRES_OK(context,\n                       context->allocate_temp(old_lhs.dtype(), rhs.shape(),\n                                              &copy_tensor, attr));\n        context->clear_recorded_memory();\n        context->replace_ref_input(0, copy_tensor,  true);\n        if (use_exclusive_lock_) {\n          Copy(context, &copy_tensor, rhs);\n          return;\n        }\n      }\n    }\n    Tensor old_unlocked_lhs = context->mutable_input(0,  false);\n    Copy(context, &old_unlocked_lhs, rhs);\n  }", "target": 1}
{"code": "static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\treturn 0;\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}", "target": 1}
{"code": "PHP_FUNCTION(grapheme_strlen)\n{\n\tunsigned char* string;\n\tint string_len;\n\tUChar* ustring = NULL;\n\tint ustring_len = 0;\n\tint ret_len;\n\tUErrorCode status;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", (char **)&string, &string_len) == FAILURE) {\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \"grapheme_strlen: unable to parse input param\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tret_len = grapheme_ascii_check(string, string_len);\n\tif ( ret_len >= 0 )\n\t\tRETURN_LONG(ret_len);\n\tstatus = U_ZERO_ERROR;\n\tintl_convert_utf8_to_utf16(&ustring, &ustring_len, (char*) string, string_len, &status );\n\tif ( U_FAILURE( status ) ) {\n\t\tintl_error_set_code( NULL, status TSRMLS_CC );\n\t\tintl_error_set_custom_msg( NULL, \"Error converting input string to UTF-16\", 0 TSRMLS_CC );\n\t\tif (ustring) {\n\t\t\tefree( ustring );\n\t\t}\n\t\tRETURN_NULL();\n\t}\n\tret_len = grapheme_split_string(ustring, ustring_len, NULL, 0 TSRMLS_CC );\n\tif (ustring) {\n\t\tefree( ustring );\n\t}\n\tif (ret_len >= 0) {\n\t\tRETVAL_LONG(ret_len);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n}", "target": 0}
{"code": "UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\tStream_Read_UINT16(s, rect16->left);   \n\tStream_Read_UINT16(s, rect16->top);    \n\tStream_Read_UINT16(s, rect16->right);  \n\tStream_Read_UINT16(s, rect16->bottom); \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int fix_len, cmpl = inl;\n    unsigned int b;\n    if (ctx->encrypt) {\n        EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_INVALID_OPERATION);\n        return 0;\n    }\n    b = ctx->cipher->block_size;\n    if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))\n        cmpl = (cmpl + 7) / 8;\n    if (inl < 0\n            || (inl == 0\n                && EVP_CIPHER_mode(ctx->cipher) != EVP_CIPH_CCM_MODE)) {\n        *outl = 0;\n        return inl == 0;\n    }\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        if (b == 1 && is_partially_overlapping(out, in, cmpl)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        fix_len = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (fix_len < 0) {\n            *outl = 0;\n            return 0;\n        } else\n            *outl = fix_len;\n        return 1;\n    }\n    if (ctx->flags & EVP_CIPH_NO_PADDING)\n        return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl);\n    OPENSSL_assert(b <= sizeof(ctx->final));\n    if (ctx->final_used) {\n        if (((PTRDIFF_T)out == (PTRDIFF_T)in)\n            || is_partially_overlapping(out, in, b)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        memcpy(out, ctx->final, b);\n        out += b;\n        fix_len = 1;\n    } else\n        fix_len = 0;\n    if (!evp_EncryptDecryptUpdate(ctx, out, outl, in, inl))\n        return 0;\n    if (b > 1 && !ctx->buf_len) {\n        *outl -= b;\n        ctx->final_used = 1;\n        memcpy(ctx->final, &out[*outl], b);\n    } else\n        ctx->final_used = 0;\n    if (fix_len)\n        *outl += b;\n    return 1;\n}", "target": 1}
{"code": "static int gaff_init(struct hid_device *hid)\n{\n\tstruct gaff_device *gaff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct list_head *report_ptr = report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport_ptr = report_ptr->next;\n\treport = list_entry(report_ptr, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 6) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\tgaff = kzalloc(sizeof(struct gaff_device), GFP_KERNEL);\n\tif (!gaff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, gaff, hid_gaff_play);\n\tif (error) {\n\t\tkfree(gaff);\n\t\treturn error;\n\t}\n\tgaff->report = report;\n\tgaff->report->field[0]->value[0] = 0x51;\n\tgaff->report->field[0]->value[1] = 0x00;\n\tgaff->report->field[0]->value[2] = 0x00;\n\tgaff->report->field[0]->value[3] = 0x00;\n\thid_hw_request(hid, gaff->report, HID_REQ_SET_REPORT);\n\tgaff->report->field[0]->value[0] = 0xfa;\n\tgaff->report->field[0]->value[1] = 0xfe;\n\thid_hw_request(hid, gaff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force Feedback for GreenAsia 0x12 devices by Lukasz Lubojanski <lukasz@lubojanski.info>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,\n                                const unsigned char* in, size_t i, const LodePNGColorMode* mode)\n{\n  if(mode->colortype == LCT_GREY)\n  {\n    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];\n    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\n    else *a = 65535;\n  }\n  else if(mode->colortype == LCT_RGB)\n  {\n    *r = 256 * in[i * 6 + 0] + in[i * 6 + 1];\n    *g = 256 * in[i * 6 + 2] + in[i * 6 + 3];\n    *b = 256 * in[i * 6 + 4] + in[i * 6 + 5];\n    if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n       && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n       && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\n    else *a = 65535;\n  }\n  else if(mode->colortype == LCT_GREY_ALPHA)\n  {\n    *r = *g = *b = 256 * in[i * 4 + 0] + in[i * 4 + 1];\n    *a = 256 * in[i * 4 + 2] + in[i * 4 + 3];\n  }\n  else if(mode->colortype == LCT_RGBA)\n  {\n    *r = 256 * in[i * 8 + 0] + in[i * 8 + 1];\n    *g = 256 * in[i * 8 + 2] + in[i * 8 + 3];\n    *b = 256 * in[i * 8 + 4] + in[i * 8 + 5];\n    *a = 256 * in[i * 8 + 6] + in[i * 8 + 7];\n  }\n}", "target": 0}
{"code": "is_code_ctype(OnigCodePoint code, unsigned int ctype, OnigEncoding enc ARG_UNUSED)\n{\n  if (code < 128)\n    return ONIGENC_IS_ASCII_CODE_CTYPE(code, ctype);\n  else\n    return (code_to_mbclen(code, enc) > 1 ? TRUE : FALSE);\n}", "target": 0}
{"code": "static void set_seg_override(struct x86_emulate_ctxt *ctxt, int seg)\n{\n\tctxt->has_seg_override = true;\n\tctxt->seg_override = seg;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const float in_min = context->input(2).flat<float>()(0);\n    const float in_max = context->input(3).flat<float>()(0);\n    ImageResizerState st(align_corners_, false);\n    st.ValidateAndCreateOutput(context);\n    if (!context->status().ok()) return;\n    if (st.output->NumElements() == 0) return;\n    typename TTypes<T, 4>::ConstTensor image_data(\n        context->input(0).tensor<T, 4>());\n    typename TTypes<T, 4>::Tensor output_data(st.output->tensor<T, 4>());\n    ResizeBilinear<T>(image_data, st.height_scale, st.width_scale, in_min,\n                      in_max, half_pixel_centers_, &output_data);\n    Tensor* out_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &out_min));\n    out_min->flat<float>()(0) = in_min;\n    Tensor* out_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &out_max));\n    out_max->flat<float>()(0) = in_max;\n  }", "target": 1}
{"code": "__xml_acl_post_process(xmlNode * xml)\n{\n    xmlNode *cIter = __xml_first_child(xml);\n    xml_private_t *p = xml->_private;\n     if(is_set(p->flags, xpf_created)) {\n         xmlAttr *xIter = NULL;\n         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {\n             const char *prop_name = (const char *)xIter->name;\n            if (strcmp(prop_name, XML_ATTR_ID) == 0) {\n                 continue;\n            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {\n                crm_trace(\"Creation of %s=%s is allowed\", crm_element_name(xml), ID(xml));\n                 break;\n             } else {\n                char *path = xml_get_path(xml);\n                 crm_trace(\"Cannot add new node %s at %s\", crm_element_name(xml), path);\n                 if(xml != xmlDocGetRootElement(xml->doc)) {\n                    xmlUnlinkNode(xml);\n                    xmlFreeNode(xml);\n                }\n                free(path);\n                 return;\n             }\n         }\n     }\n     while (cIter != NULL) {\n        xmlNode *child = cIter;\n        cIter = __xml_next(cIter); \n        __xml_acl_post_process(child);\n    }\n}", "target": 1}
{"code": "lldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n    tlen = len;\n    tptr = pptr;\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n     if (tlen) {\n         oid_len = *tptr;\n        if (tlen < oid_len) {\n             return 0;\n         }\n         if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n    return 1;\n}", "target": 1}
{"code": "inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                       const RuntimeShape& shape2, int index2) {\n  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n  return shape1.Dims(index1);\n}", "target": 1}
{"code": "GfxPath::GfxPath()\n{\n    justMoved = false;\n    size = 16;\n    n = 0;\n    firstX = firstY = 0;\n    subpaths = (GfxSubpath **)gmallocn(size, sizeof(GfxSubpath *));\n}", "target": 0}
{"code": "  Supports_Block_Obj Parser::parse_supports_directive()\n  {\n    Supports_Condition_Obj cond = parse_supports_condition(true);\n    Supports_Block_Obj query = SASS_MEMORY_NEW(Supports_Block, pstate, cond);\n    query->block(parse_block());\n    return query;\n  }", "target": 0}
{"code": "int tipc_nl_publ_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tu32 tsk_portid = cb->args[0];\n\tu32 last_publ = cb->args[1];\n\tu32 done = cb->args[2];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_sock *tsk;\n\tif (!tsk_portid) {\n\t\tstruct nlattr **attrs;\n\t\tstruct nlattr *sock[TIPC_NLA_SOCK_MAX + 1];\n\t\terr = tipc_nlmsg_parse(cb->nlh, &attrs);\n \t\tif (err)\n \t\t\treturn err;\n \t\terr = nla_parse_nested(sock, TIPC_NLA_SOCK_MAX,\n \t\t\t\t       attrs[TIPC_NLA_SOCK],\n \t\t\t\t       tipc_nl_sock_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!sock[TIPC_NLA_SOCK_REF])\n\t\t\treturn -EINVAL;\n\t\ttsk_portid = nla_get_u32(sock[TIPC_NLA_SOCK_REF]);\n\t}\n\tif (done)\n\t\treturn 0;\n\ttsk = tipc_sk_lookup(net, tsk_portid);\n\tif (!tsk)\n\t\treturn -EINVAL;\n\tlock_sock(&tsk->sk);\n\terr = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);\n\tif (!err)\n\t\tdone = 1;\n\trelease_sock(&tsk->sk);\n\tsock_put(&tsk->sk);\n\tcb->args[0] = tsk_portid;\n\tcb->args[1] = last_publ;\n\tcb->args[2] = done;\n\treturn skb->len;\n}", "target": 1}
{"code": "int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}", "target": 0}
{"code": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  \n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}", "target": 1}
{"code": "regional_alloc(struct regional *r, size_t size)\n{\n\tsize_t a = ALIGN_UP(size, ALIGNMENT);\n\tvoid *s;\n\tif(a > REGIONAL_LARGE_OBJECT_SIZE) {\n\t\ts = malloc(ALIGNMENT + size);\n\t\tif(!s) return NULL;\n\t\tr->total_large += ALIGNMENT+size;\n\t\t*(char**)s = r->large_list;\n\t\tr->large_list = (char*)s;\n\t\treturn (char*)s+ALIGNMENT;\n\t}\n\tif(a > r->available) {\n\t\ts = malloc(REGIONAL_CHUNK_SIZE);\n\t\tif(!s) return NULL;\n\t\t*(char**)s = r->next;\n\t\tr->next = (char*)s;\n\t\tr->data = (char*)s + ALIGNMENT;\n\t\tr->available = REGIONAL_CHUNK_SIZE - ALIGNMENT;\n\t}\n\tr->available -= a;\n\ts = r->data;\n\tr->data += a;\n\treturn s;\n}", "target": 1}
{"code": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n    bs->read_only = 1;\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->n_blocks = be32_to_cpu(s->n_blocks);\n    offsets_size = s->n_blocks * sizeof(uint64_t);\n    s->offsets = g_malloc(offsets_size);\n    ret = bdrv_pread(bs->file, 128 + 4 + 4, s->offsets, offsets_size);\n    if (ret < 0) {\n        goto fail;\n    }\n    for(i=0;i<s->n_blocks;i++) {\n        s->offsets[i] = be64_to_cpu(s->offsets[i]);\n        if (i > 0) {\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n            if (size > max_compressed_block_size) {\n                max_compressed_block_size = size;\n            }\n        }\n    }\n    s->compressed_block = g_malloc(max_compressed_block_size + 1);\n    s->uncompressed_block = g_malloc(s->block_size);\n    if (inflateInit(&s->zstream) != Z_OK) {\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->current_block = s->n_blocks;\n    s->sectors_per_block = s->block_size/512;\n    bs->total_sectors = s->n_blocks * s->sectors_per_block;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->offsets);\n    g_free(s->compressed_block);\n    g_free(s->uncompressed_block);\n    return ret;\n}", "target": 1}
{"code": "    static CImg<T> get_load_ascii(const char *const filename) {\n      return CImg<T>().load_ascii(filename);", "target": 0}
{"code": "static bool shouldOpenInNewWindow(Frame* targetFrame, const FrameLoadRequest& request, const NavigationAction& action)\n{\n    if (!targetFrame && !request.frameName().isEmpty())\n        return true;\n    if (!request.formState())\n        return false;\n    NavigationPolicy navigationPolicy = NavigationPolicyCurrentTab;\n    if (!action.specifiesNavigationPolicy(&navigationPolicy))\n        return false;\n    return navigationPolicy != NavigationPolicyCurrentTab;\n}", "target": 0}
{"code": "   Copy specified message to a mailbox */\nPHP_FUNCTION(imap_mail_copy)\n{\n\tzval *streamind;\n\tzend_long options = 0;\n\tzend_string *seq, *folder;\n\tint argc = ZEND_NUM_ARGS();\n\tpils *imap_le_struct;\n\tif (zend_parse_parameters(argc, \"rSS|l\", &streamind, &seq, &folder, &options) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? options : NIL)) == T) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) final {\n    const Tensor& superdiag = context->input(0);\n    const Tensor& maindiag = context->input(1);\n    const Tensor& subdiag = context->input(2);\n    const Tensor& rhs = context->input(3);\n    const int ndims = rhs.dims();\n    int64 batch_size = 1;\n    for (int i = 0; i < ndims - 2; i++) {\n      batch_size *= rhs.dim_size(i);\n    }\n    const int m = rhs.dim_size(ndims - 2);\n    const int n = rhs.dim_size(ndims - 1);\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, rhs.shape(), &output));\n    const Eigen::GpuDevice& device = context->eigen_device<Eigen::GpuDevice>();\n    GpuLaunchConfig cfg = GetGpuLaunchConfig(1, device);\n    TF_CHECK_OK(GpuLaunchKernel(\n        TridiagonalMatMulKernel<Scalar>, cfg.block_count, cfg.thread_per_block,\n        0, device.stream(), batch_size, m, n, superdiag.flat<Scalar>().data(),\n        maindiag.flat<Scalar>().data(), subdiag.flat<Scalar>().data(),\n        rhs.flat<Scalar>().data(), output->flat<Scalar>().data()));\n  }", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "dirserv_set_router_is_running(routerinfo_t *router, time_t now)\n{\n  int answer;\n  if (router_is_me(router)) {\n    answer = ! we_are_hibernating();\n  } else if (router->is_hibernating &&\n             (router->cache_info.published_on +\n              HIBERNATION_PUBLICATION_SKEW) > router->last_reachable) {\n    answer = 0;\n  } else if (get_options()->AssumeReachable) {\n    answer = 1;\n  } else {\n    answer = (now < router->last_reachable + REACHABLE_TIMEOUT);\n  }\n  if (!answer && running_long_enough_to_decide_unreachable()) {\n    time_t when = now;\n    if (router->last_reachable &&\n        router->last_reachable + REACHABILITY_TEST_CYCLE_PERIOD < now)\n      when = router->last_reachable + REACHABILITY_TEST_CYCLE_PERIOD;\n    rep_hist_note_router_unreachable(router->cache_info.identity_digest, when);\n  }\n  router->is_running = answer;\n}", "target": 0}
{"code": "int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\n\t\t\t     struct hw_atl_utils_fw_rpc **rpc)\n{\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\n\tint err = 0;\n\tdo {\n\t\tsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\n\t\tself->rpc_tid = sw.tid;\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get,\n\t\t\t\t\t\tself, fw.val,\n\t\t\t\t\t\tsw.tid == fw.tid,\n\t\t\t\t\t\t1000U, 100000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t\terr = aq_hw_err_from_flags(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t\tif (fw.len == 0xFFFFU) {\n\t\t\terr = hw_atl_utils_fw_rpc_call(self, sw.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\n\tif (rpc) {\n\t\tif (fw.len) {\n\t\t\terr =\n\t\t\thw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t\t      self->rpc_addr,\n\t\t\t\t\t\t      (u32 *)(void *)\n\t\t\t\t\t\t      &self->rpc,\n\t\t\t\t\t\t      (fw.len + sizeof(u32) -\n\t\t\t\t\t\t       sizeof(u8)) /\n\t\t\t\t\t\t      sizeof(u32));\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t\t*rpc = &self->rpc;\n\t}\nerr_exit:\n\treturn err;\n}", "target": 1}
{"code": "static PHP_INI_MH(OnUpdateInternalEncoding)\n{\n\tif (new_value) {\n\t\tOnUpdateString(entry, new_value, mh_arg1, mh_arg2, mh_arg3, stage);\n\t}\n\treturn SUCCESS;\n}", "target": 0}
{"code": "static void *conncache_add_bundle(struct conncache *connc,\n                                  char *key,\n                                  struct connectbundle *bundle)\n{\n  return Curl_hash_add(&connc->hash, key, strlen(key), bundle);\n}", "target": 0}
{"code": "  StatusOr<std::vector<int64_t>> GetStride(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return stride_;\n    }\n    const TensorShape stride_shape = ctx->InputShape(2);\n    if (!TensorShapeUtils::IsVector(stride_shape)) {\n      return errors::InvalidArgument(\"stride must be a vector, not shape \",\n                                     stride_shape.DebugString());\n    }\n    if (stride_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> stride;\n    auto status = ctx->ConstantInputAsIntVector(2, &stride);\n    if (!status.ok()) {\n      return status;\n    }\n    return stride;\n  }", "target": 1}
{"code": "int AccessibilityUIElement::hierarchicalLevel() const\n{\n    return 0;\n}", "target": 0}
{"code": " static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n \t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n \t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n \t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static int umocktypes_copy_FLOW_HANDLE(FLOW_HANDLE* destination, const FLOW_HANDLE* source)\n{\n    int result = 0;\n    *(destination) = *(source);\n    return result;\n}", "target": 0}
{"code": "check_pages_isolated_cb(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\tvoid *data)\n{\n\tint ret;\n\tlong offlined = *(long *)data;\n\tret = test_pages_isolated(start_pfn, start_pfn + nr_pages);\n\tofflined = nr_pages;\n\tif (!ret)\n\t\t*(long *)data += offlined;\n\treturn ret;\n}", "target": 0}
{"code": "int main(int argc, char **argv)\n{\n  test_cmp_parameters inParam;\n  FILE *fbase=NULL, *ftest=NULL;\n  int same = 0;\n  char lbase[256];\n  char strbase[256];\n  char ltest[256];\n  char strtest[256];\n  if( parse_cmdline_cmp(argc, argv, &inParam) == 1 )\n    {\n    compare_dump_files_help_display();\n    goto cleanup;\n    }\n  printf(\"******Parameters********* \\n\");\n  printf(\" base_filename = %s\\n\"\n    \" test_filename = %s\\n\",\n    inParam.base_filename, inParam.test_filename);\n  printf(\"************************* \\n\");\n  printf(\"Try to open: %s for reading ... \", inParam.base_filename);\n  if((fbase = fopen(inParam.base_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n  printf(\"Try to open: %s for reading ... \", inParam.test_filename);\n  if((ftest = fopen(inParam.test_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n  while (fgets(lbase, sizeof(lbase), fbase) && fgets(ltest,sizeof(ltest),ftest))\n    {\n    int nbase = sscanf(lbase, \"%255[^\\r\\n]\", strbase);\n    int ntest = sscanf(ltest, \"%255[^\\r\\n]\", strtest);\n    assert( nbase != 255 && ntest != 255 );\n    if( nbase != 1 || ntest != 1 )\n      {\n      fprintf(stderr, \"could not parse line from files\\n\" );\n      goto cleanup;\n      }\n    if( strcmp( strbase, strtest ) != 0 )\n      {\n      fprintf(stderr,\"<%s> vs. <%s>\\n\", strbase, strtest);\n      goto cleanup;\n      }\n    }\n  same = 1;\n  printf(\"\\n***** TEST SUCCEED: Files are the same. *****\\n\");\ncleanup:\n  if(fbase) fclose(fbase);\n  if(ftest) fclose(ftest);\n  free(inParam.base_filename);\n  free(inParam.test_filename);\n  return same ? EXIT_SUCCESS : EXIT_FAILURE;\n}", "target": 1}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, LINENO(ch), ch->n_col_offset,\n                          ch->n_end_lineno, ch->n_end_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 2; \n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "recv_and_process_client_pkt(void )\n{\n\tssize_t          size;\n\tlen_and_sockaddr *to;\n\tstruct sockaddr  *from;\n\tmsg_t            msg;\n\tuint8_t          query_status;\n\tl_fixedpt_t      query_xmttime;\n\tto = get_sock_lsa(G_listen_fd);\n\tfrom = xzalloc(to->len);\n\tsize = recv_from_to(G_listen_fd, &msg, sizeof(msg), MSG_DONTWAIT, from, &to->u.sa, to->len);\n\tif (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE) {\n\t\tchar *addr;\n\t\tif (size < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tgoto bail;\n\t\t\tbb_perror_msg_and_die(\"recv\");\n\t\t}\n\t\taddr = xmalloc_sockaddr2dotted_noport(from);\n\t\tbb_error_msg(\"malformed packet received from %s: size %u\", addr, (int)size);\n\t\tfree(addr);\n \t\tgoto bail;\n \t}\n \tquery_status = msg.m_status;\n \tquery_xmttime = msg.m_xmttime;\n\tmsg.m_ppoll = G.poll_exp;\n\tmsg.m_precision_exp = G_precision_exp;\n\tmsg.m_rectime = d_to_lfp(G.cur_time);\n\tmsg.m_xmttime = d_to_lfp(gettime1900d()); \n\tif (G.peer_cnt == 0) {\n\t\tG.reftime = G.cur_time;\n\t}\n\tmsg.m_reftime = d_to_lfp(G.reftime);\n\tmsg.m_orgtime = query_xmttime;\n\tmsg.m_rootdelay = d_to_sfp(G.rootdelay);\n\tmsg.m_rootdisp = d_to_sfp(G.rootdisp);\n\tmsg.m_refid = G.refid; \n\tdo_sendto(G_listen_fd,\n\t\t &to->u.sa,  from,  to->len,\n\t\t&msg, size);\n bail:\n\tfree(to);\n\tfree(from);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    ReshapeOp::Compute(ctx);\n    const float input_min_float = ctx->input(2).flat<float>()(0);\n    const float input_max_float = ctx->input(3).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n    output_max->flat<float>()(0) = input_max_float;\n  }", "target": 1}
{"code": "static inline void find_entity_for_char_basic(\n\tunsigned int k,\n\tconst entity_stage3_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len)\n{\n\tif (k >= 64U) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\t*entity     = table[k].data.ent.entity;\n\t*entity_len = table[k].data.ent.entity_len;\n}", "target": 0}
{"code": "static int _process_request_metaflags(mcp_parser_t *pr, int token) {\n    if (pr->ntokens <= token) {\n        pr->t.meta.flags = 0; \n        return 0;\n    }\n    const char *cur = pr->request + pr->tokens[token];\n    const char *end = pr->request + pr->reqlen - 2;\n    int state = 0;\n    while (cur != end) {\n        switch (state) {\n            case 0:\n                if (*cur == ' ') {\n                    cur++;\n                } else {\n                    if (*cur < 65 || *cur > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", __func__, *cur - 65);\n                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);\n                    state = 1;\n                }\n                break;\n            case 1:\n                if (*cur != ' ') {\n                    cur++;\n                } else {\n                    state = 0;\n                }\n                break;\n        }\n    }\n    if (pr->t.meta.flags & ((uint64_t)1 << 48)) {\n        pr->noreply = true;\n    }\n    return 0;\n}", "target": 1}
{"code": "void setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n    if (offset < 0) {\n        addReplyError(c,\"offset is out of range\");\n        return;\n    }\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n        if (checkType(c,o,OBJ_STRING))\n            return;\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \"setrange\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}", "target": 1}
{"code": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\tif (code_new == clear_code) {\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\t} else if (code_new == ctx->eoi_code) {\n\t\treturn LZW_EOI_CODE;\n\t} else if (code_new > current_entry) {\n\t\treturn LZW_BAD_CODE;\n\t} else if (code_new < current_entry) {\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}", "target": 1}
{"code": "    FujiMnHeader::FujiMnHeader() : start_(0)\n    {\n        read(signature_, sizeOfSignature(), byteOrder_);\n    }", "target": 0}
{"code": "void tipc_node_stop(struct net *net)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tstruct tipc_node *node, *t_node;\n\tspin_lock_bh(&tn->node_list_lock);\n\tlist_for_each_entry_safe(node, t_node, &tn->node_list, list)\n\t\ttipc_node_delete(node);\n\tspin_unlock_bh(&tn->node_list_lock);\n}", "target": 0}
{"code": "static void _out_result(conn_t out, nad_t nad) {\n    int attr;\n    jid_t from, to;\n    char *rkey;\n    int rkeylen;\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db result packet\");\n        nad_free(nad);\n        return;\n    }\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db result packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n    rkeylen = strlen(rkey);\n    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0) {\n        log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", out->s->compressed ? \", ZLIB compression enabled\" : \"\");\n        xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    \n        log_debug(ZONE, \"%s valid, flushing queue\", rkey);\n        out_flush_route_queue(out->s2s, rkey, rkeylen);\n        free(rkey);\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now invalid\", out->fd->fd, out->ip, out->port, rkey);\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] closing connection\", out->fd->fd, out->ip, out->port);\n    sx_error(out->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n    sx_close(out->s);\n    out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n    free(rkey);\n    jid_free(from);\n    jid_free(to);\n    nad_free(nad);\n}", "target": 1}
{"code": "GF_Box *mvcg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MultiviewGroupBox, GF_ISOM_BOX_TYPE_MVCG);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    next_start_code_studio(gb);\n}", "target": 1}
{"code": "static int transfer_size(int ssize, int max_sector, int max_size)\n{\n\tSUPBOUND(max_sector, fsector_t + max_size);\n\tmax_sector -= (max_sector % _floppy->sect) % ssize;\n\tcurrent_count_sectors = max_sector - fsector_t;\n\treturn max_sector;\n}", "target": 0}
{"code": "void FAST_FUNC udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt)\n{\n\tunsigned len;\n\tuint8_t *optionptr = packet->options;\n\tunsigned end = udhcp_end_option(optionptr);\n\tlen = OPT_DATA + addopt[OPT_LEN];\n\tif (end + len + 1 >= DHCP_OPTIONS_BUFSIZE) {\n\t\tbb_error_msg(\"option 0x%02x did not fit into the packet\",\n\t\t\t\taddopt[OPT_CODE]);\n\t\treturn;\n\t}\n\tlog_option(\"Adding option\", addopt);\n\tmemcpy(optionptr + end, addopt, len);\n\toptionptr[end + len] = DHCP_END;\n}", "target": 0}
{"code": "bool InstanceKlass::supers_have_passed_fingerprint_checks() {\n  if (java_super() != NULL && !java_super()->has_passed_fingerprint_check()) {\n    ResourceMark rm;\n    log_trace(class, fingerprint)(\"%s : super %s not fingerprinted\", external_name(), java_super()->external_name());\n    return false;\n  }\n  Array<Klass*>* local_interfaces = this->local_interfaces();\n  if (local_interfaces != NULL) {\n    int length = local_interfaces->length();\n    for (int i = 0; i < length; i++) {\n      InstanceKlass* intf = InstanceKlass::cast(local_interfaces->at(i));\n      if (!intf->has_passed_fingerprint_check()) {\n        ResourceMark rm;\n        log_trace(class, fingerprint)(\"%s : interface %s not fingerprinted\", external_name(), intf->external_name());\n        return false;\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "bool Browser::PreHandleGestureEvent(content::WebContents* source,\n                                    const blink::WebGestureEvent& event) {\n  if (app_name() == DevToolsWindow::kDevToolsApp)\n    return event.type == blink::WebGestureEvent::GesturePinchBegin ||\n           event.type == blink::WebGestureEvent::GesturePinchUpdate ||\n           event.type == blink::WebGestureEvent::GesturePinchEnd;\n  return false;\n}", "target": 0}
{"code": "static void cfg_free_opt_array(cfg_opt_t *opts)\n{\n\tint i;\n\tfor (i = 0; opts[i].name; ++i) {\n\t\tfree((void *)opts[i].name);\n\t\tif (opts[i].comment)\n\t\t\tfree(opts[i].comment);\n\t\tif (opts[i].def.parsed)\n\t\t\tfree(opts[i].def.parsed);\n\t\tif (opts[i].def.string)\n\t\t\tfree((void *)opts[i].def.string);\n\t\tif (opts[i].subopts)\n\t\t\tcfg_free_opt_array(opts[i].subopts);\n\t}\n\tfree(opts);\n}", "target": 0}
{"code": "dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n\t{\n\thm_fragment *frag = NULL;\n\tpitem *item = NULL;\n\tint i = -1, is_complete;\n\tunsigned char seq64be[8];\n\tunsigned long frag_len = msg_hdr->frag_len, max_len;\n\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)\n\t\tgoto err;\n\tif (DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH < s->max_cert_list)\n\t\tmax_len = s->max_cert_list;\n\telse\n\t\tmax_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n\tif ((msg_hdr->frag_off+frag_len) > max_len)\n\t\tgoto err;\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char) (msg_hdr->seq>>8);\n\tseq64be[7] = (unsigned char) msg_hdr->seq;\n\titem = pqueue_find(s->d1->buffered_messages, seq64be);\n\tif (item == NULL)\n\t\t{\n\t\tfrag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);\n\t\tif ( frag == NULL)\n\t\t\tgoto err;\n\t\tmemcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\n\t\tfrag->msg_header.frag_len = frag->msg_header.msg_len;\n                frag->msg_header.frag_off = 0;\n                }\n        else\n                frag = (hm_fragment*) item->data;", "target": 1}
{"code": "HTTP_HANDLE HTTPAPI_CreateConnection(const char* hostName)\n{\n    HTTP_HANDLE_DATA* result;\n    if (g_HTTPAPIState != HTTPAPI_INITIALIZED)\n    {\n        LogError(\"g_HTTPAPIState not HTTPAPI_INITIALIZED\");\n        result = NULL;\n    }\n    else\n    {\n        result = (HTTP_HANDLE_DATA*)malloc(sizeof(HTTP_HANDLE_DATA));\n        if (result == NULL)\n        {\n            LogError(\"malloc returned NULL.\");\n        }\n        else\n        {\n            memset(result, 0, sizeof(*result));\n            wchar_t* hostNameTemp;\n            size_t hostNameTemp_size = MultiByteToWideChar(CP_ACP, 0, hostName, -1, NULL, 0);\n            if (hostNameTemp_size == 0)\n            {\n                LogError(\"MultiByteToWideChar failed\");\n                free(result);\n                result = NULL;\n            }\n            else\n            {\n                hostNameTemp = (wchar_t*)malloc(sizeof(wchar_t) * hostNameTemp_size);\n                if (hostNameTemp == NULL)\n                {\n                    LogError(\"malloc failed\");\n                    free(result);\n                    result = NULL;\n                }\n                else\n                {\n                    if (MultiByteToWideChar(CP_ACP, 0, hostName, -1, hostNameTemp, (int)hostNameTemp_size) == 0)\n                    {\n                        LogError(\"MultiByteToWideChar failed\");\n                        free(result);\n                        result = NULL;\n                    }\n                    else\n                    {\n                        result->ConnectionHandle = WinHttpConnect(\n                            g_SessionHandle,\n                            hostNameTemp,\n                            INTERNET_DEFAULT_HTTPS_PORT,\n                            0);\n                        if (result->ConnectionHandle == NULL)\n                        {\n                            LogErrorWinHTTPWithGetLastErrorAsString(\"WinHttpConnect returned NULL.\");\n                            free(result);\n                            result = NULL;\n                        }\n                        else\n                        {\n                            result->timeout = 60000;\n                        }\n                    }\n                    free(hostNameTemp);\n                }\n            }\n        }\n    }\n    return (HTTP_HANDLE)result;\n}", "target": 1}
{"code": "static optional<Principal> parse_principal(CephContext* cct, TokenID t,\n\t\t\t\t    string&& s) {\n  if ((t == TokenID::AWS) && (s == \"*\")) {\n    return Principal::wildcard();\n  } else if (t == TokenID::CanonicalUser) {\n  } else if (t == TokenID::AWS) {\n    auto a = ARN::parse(s);\n    if (!a) {\n      if (std::none_of(s.begin(), s.end(),\n\t\t       [](const char& c) {\n\t\t\t return (c == ':') || (c == '/');\n\t\t       })) {\n\treturn Principal::tenant(std::move(s));\n      }\n    }\n    if (a->resource == \"root\") {\n      return Principal::tenant(std::move(a->account));\n    }\n    static const char rx_str[] = \"([^/]*)/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      ceph_assert(match.size() == 3);\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }\n      if (match[1] == \"role\") {\n\treturn Principal::role(std::move(a->account),\n\t\t\t       match[2]);\n      }\n    }\n  }\n  ldout(cct, 0) << \"Supplied principal is discarded: \" << s << dendl;\n  return boost::none;\n}", "target": 1}
{"code": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\tfsnotify_clear_marks_by_group(group);\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\n\treturn 0;\n}", "target": 1}
{"code": "static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,\n unsigned long arg)\n{\n unsigned long tmp;\n struct vm_area_struct * vma, *prev;\n int unmapped_error = 0;\n int error = -EINVAL;\n\tvma = find_vma_prev(current->mm, start, &prev);\n if (vma && start > vma->vm_start)\n\t\tprev = vma;\n for (;;) {\n\t\terror = -ENOMEM;\n if (!vma)\n return error;\n if (start < vma->vm_start) {\n\t\t\tunmapped_error = -ENOMEM;\n\t\t\tstart = vma->vm_start;\n if (start >= end)\n return error;\n }\n\t\ttmp = vma->vm_end;\n if (end < tmp)\n \t\t\ttmp = end;\n\t\terror = prctl_update_vma_anon_name(vma, &prev, start, end,\n \t\t\t\t(const char __user *)arg);\n \t\tif (error)\n \t\t\treturn error;\n\t\tstart = tmp;\n if (prev && start < prev->vm_end)\n\t\t\tstart = prev->vm_end;\n\t\terror = unmapped_error;\n if (start >= end)\n return error;\n if (prev)\n\t\t\tvma = prev->vm_next;\n else \n\t\t\tvma = find_vma(current->mm, start);\n }\n}", "target": 1}
{"code": "static int drff_init(struct hid_device *hid)\n{\n\tstruct drff_device *drff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_first_entry(&hid->inputs,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdrff = kzalloc(sizeof(struct drff_device), GFP_KERNEL);\n\tif (!drff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, drff, drff_play);\n\tif (error) {\n\t\tkfree(drff);\n\t\treturn error;\n\t}\n\tdrff->report = report;\n\tdrff->report->field[0]->value[0] = 0xf3;\n\tdrff->report->field[0]->value[1] = 0x00;\n\tdrff->report->field[0]->value[2] = 0x00;\n\tdrff->report->field[0]->value[3] = 0x00;\n\tdrff->report->field[0]->value[4] = 0x00;\n\tdrff->report->field[0]->value[5] = 0x00;\n\tdrff->report->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, drff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force Feedback for DragonRise Inc. \"\n\t\t \"game controllers by Richard Walmsley <richwalm@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "gplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUF_SIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n    PROCNAME(\"gplotAddPlot\");\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if ((n = numaGetCount(nay)) == 0)\n        return ERROR_INT(\"no points to plot\", procName, 1);\n    if (nax && (n != numaGetCount(nax)))\n        return ERROR_INT(\"nax and nay sizes differ\", procName, 1);\n    if (n == 1 && plotstyle == GPLOT_LINES) {\n        L_INFO(\"only 1 pt; changing style to points\\n\", procName);\n        plotstyle = GPLOT_POINTS;\n    }\n    numaGetParameters(nay, &startx, &delx);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n    gplot->nplots++;\n    snprintf(buf, L_BUF_SIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUF_SIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n    return 0;\n}", "target": 1}
{"code": "smb3_is_transform_hdr(void *buf)\n{\n\tstruct smb2_transform_hdr *trhdr = buf;\n\treturn trhdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM;\n}", "target": 0}
{"code": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n    unsigned num_sg = *p_num_sg;\n    assert(num_sg <= max_num_sg);\n    while (sz) {\n        hwaddr len = sz;\n        if (num_sg == max_num_sg) {\n            error_report(\"virtio: too many write descriptors in indirect table\");\n            exit(1);\n        }\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}", "target": 1}
{"code": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\tsnd_timer_stop(timeri);\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n \t\t    timer->hw.close)\n \t\t\ttimer->hw.close(timer);\n \t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n \t\t\t\t\t open_list) {\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n \t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n \t\t\tslave->master = NULL;\n \t\t\tslave->timer = NULL;\n\t\t\tspin_unlock_irq(&slave_active_lock);\n \t\t}\n \t\tmutex_unlock(&register_mutex);\n \t}\n  out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}", "target": 1}
{"code": "longlong Item_ref_null_helper::val_int()\n{\n  DBUG_ASSERT(fixed == 1);\n  longlong tmp= (*ref)->val_int_result();\n  owner->was_null|= null_value= (*ref)->null_value;\n  return tmp;\n}", "target": 0}
{"code": "find_next_quote(\n    char_u\t*line,\n    int\t\tcol,\n    int\t\tquotechar,\n    char_u\t*escape)\t\n{\n    int\t\tc;\n    for (;;)\n    {\n\tc = line[col];\n\tif (c == NUL)\n\t    return -1;\n\telse if (escape != NULL && vim_strchr(escape, c))\n\t    ++col;\n\telse if (c == quotechar)\n\t    break;\n\tif (has_mbyte)\n\t    col += (*mb_ptr2len)(line + col);\n\telse\n\t    ++col;\n    }\n    return col;\n}", "target": 1}
{"code": "String *Item_cache_int::val_str(String *str)\n{\n  DBUG_ASSERT(fixed == 1);\n  if (!has_value())\n    return NULL;\n  str->set_int(value, unsigned_flag, default_charset());\n  return str;\n}", "target": 0}
{"code": "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::GetSnapshotFromBrowser(\n    const GetSnapshotFromBrowserCallback& callback,\n    bool from_surface) {\n  int id = next_browser_snapshot_id_++;\n  if (from_surface) {\n    pending_surface_browser_snapshots_.insert(std::make_pair(id, callback));\n    ui::LatencyInfo latency_info;\n    latency_info.AddLatencyNumber(ui::BROWSER_SNAPSHOT_FRAME_NUMBER_COMPONENT,\n                                  0, id);\n    Send(new ViewMsg_ForceRedraw(GetRoutingID(), latency_info));\n    return;\n  }\n#if defined(OS_MACOSX)\n  if (pending_browser_snapshots_.empty())\n    GetWakeLock()->RequestWakeLock();\n#endif\n  pending_browser_snapshots_.insert(std::make_pair(id, callback));\n  ui::LatencyInfo latency_info;\n  latency_info.AddLatencyNumber(ui::BROWSER_SNAPSHOT_FRAME_NUMBER_COMPONENT, 0,\n                                id);\n  Send(new ViewMsg_ForceRedraw(GetRoutingID(), latency_info));\n}", "target": 0}
{"code": "check_SET_L4_SRC_PORT(struct ofpact_l4_port *a, struct ofpact_check_params *cp)\n{\n    return check_set_l4_port(a, cp);\n}", "target": 0}
{"code": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tint size = NLMSG_LENGTH(len);\n\tnlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = pid;\n\tnlh->nlmsg_seq = seq;\n\treturn nlh;\n}", "target": 1}
{"code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\tif (WARN_ON(!info))\n\t\treturn;\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\tif (!list_empty(&info->eoi_list))\n\t\tlateeoi_list_del(info);\n\tlist_del(&info->list);\n\tset_info_for_irq(irq, NULL);\n\tWARN_ON(info->refcnt > 0);\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\tkfree(info);\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\tirq_free_desc(irq);\n}", "target": 0}
{"code": "static void virtio_net_drop_tx_queue_data(VirtIODevice *vdev, VirtQueue *vq)\n{\n    unsigned int dropped = virtqueue_drop_all(vq);\n    if (dropped) {\n        virtio_notify(vdev, vq);\n    }\n}", "target": 0}
{"code": "static void __exit pptp_exit_module(void)\n{\n\tunregister_pppox_proto(PX_PROTO_PPTP);\n\tproto_unregister(&pptp_sk_proto);\n\tgre_del_protocol(&gre_pptp_protocol, GREPROTO_PPTP);\n\tvfree(callid_sock);\n}", "target": 0}
{"code": "int fuse_fs_symlink(struct fuse_fs *fs, const char *linkname, const char *path)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.symlink)\n        return fs->op.symlink(linkname, path);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "SWFInput_file_getChar(SWFInput input)\n{\n\tint c = fgetc((FILE *)input->data);\n\tif ( c == EOF )\n\t\tinput->length = input->offset;\n\telse\n\t\t++input->offset;\n\treturn c;\n}", "target": 0}
{"code": "expand_case_fold_make_rem_string(Node** rnode, UChar *s, UChar *end,\n\t\t\t\t regex_t* reg)\n{\n  int r;\n  Node *node;\n  node = onig_node_new_str(s, end);\n  if (IS_NULL(node)) return ONIGERR_MEMORY;\n  r = update_string_node_case_fold(reg, node);\n  if (r != 0) {\n    onig_node_free(node);\n    return r;\n  }\n  NSTRING_SET_AMBIG(node);\n  NSTRING_SET_DONT_GET_OPT_INFO(node);\n  *rnode = node;\n  return 0;\n}", "target": 0}
{"code": "NOEXPORT char *base64(int encode, const char *in, int len) {\n    BIO *bio, *b64;\n    char *out;\n    int n;\n    b64=BIO_new(BIO_f_base64());\n    if(!b64)\n        return NULL;\n    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n    bio=BIO_new(BIO_s_mem());\n    if(!bio) {\n        str_free(b64);\n        return NULL;\n    }\n    if(encode)\n        bio=BIO_push(b64, bio);\n    BIO_write(bio, in, len);\n    (void)BIO_flush(bio); \n    if(encode) {\n        bio=BIO_pop(bio);\n        BIO_free(b64);\n    } else {\n        bio=BIO_push(b64, bio);\n    }\n    n=BIO_pending(bio);\n    out=str_alloc(n<32?32:(size_t)n+1);\n    n=BIO_read(bio, out, n);\n    if(n<0) {\n        BIO_free_all(bio);\n        str_free(out);\n        return NULL;\n    }\n    BIO_free_all(bio);\n    return out;\n}", "target": 1}
{"code": "process_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin;\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tcount = pkcs11_add_provider(provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(provider);\n\t\t\tid->comment = xstrdup(provider); \n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}", "target": 1}
{"code": "int wmi_set_ie(struct wil6210_priv *wil, u8 type, u16 ie_len, const void *ie)\n{\n\tstatic const char *const names[] = {\n\t\t[WMI_FRAME_BEACON]\t= \"BEACON\",\n\t\t[WMI_FRAME_PROBE_REQ]\t= \"PROBE_REQ\",\n\t\t[WMI_FRAME_PROBE_RESP]\t= \"WMI_FRAME_PROBE_RESP\",\n\t\t[WMI_FRAME_ASSOC_REQ]\t= \"WMI_FRAME_ASSOC_REQ\",\n\t\t[WMI_FRAME_ASSOC_RESP]\t= \"WMI_FRAME_ASSOC_RESP\",\n\t};\n\tint rc;\n\tu16 len = sizeof(struct wmi_set_appie_cmd) + ie_len;\n\tstruct wmi_set_appie_cmd *cmd = kzalloc(len, GFP_KERNEL);\n\tif (!cmd) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (!ie)\n\t\tie_len = 0;\n\tcmd->mgmt_frm_type = type;\n\tcmd->ie_len = cpu_to_le16(ie_len);\n\tmemcpy(cmd->ie_info, ie, ie_len);\n\trc = wmi_send(wil, WMI_SET_APPIE_CMDID, cmd, len);\n\tkfree(cmd);\nout:\n\tif (rc) {\n\t\tconst char *name = type < ARRAY_SIZE(names) ?\n\t\t\t\t   names[type] : \"??\";\n\t\twil_err(wil, \"set_ie(%d %s) failed : %d\\n\", type, name, rc);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "      explicit JpegOutput( String const& filename ) {\n         if( FileHasExtension( filename )) {\n            outfile_ = std::fopen(filename.c_str(), \"wb\");\n         } else {\n            outfile_ = std::fopen( FileAddExtension( filename, \"jpg\" ).c_str(), \"wb\" );\n         }\n         if( outfile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open file for writing\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            DIP_THROW_RUNTIME( \"Error writing JPEG file.\" );\n         }\n         jpeg_create_compress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_dest( &cinfo_, outfile_ );\n      }", "target": 1}
{"code": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n \tstruct xt_table_info *info = NULL;\n \tsize_t sz = sizeof(*info) + size;\n \tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n \t\treturn NULL;\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}", "target": 1}
{"code": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "target": 1}
{"code": "_archive_write_disk_close(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *next, *p;\n\tint fd, ret;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_disk_close\");\n\tret = _archive_write_disk_finish_entry(&a->archive);\n\tp = sort_dir_list(a->fixup_list);\n\twhile (p != NULL) {\n\t\tfd = -1;\n\t\ta->pst = NULL; \n\t\tif (p->fixup &\n\t\t    (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {\n\t\t\tfd = open(p->name,\n\t\t\t    O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);\n\t\t}\n\t\tif (p->fixup & TODO_TIMES) {\n\t\t\tset_times(a, fd, p->mode, p->name,\n\t\t\t    p->atime, p->atime_nanos,\n\t\t\t    p->birthtime, p->birthtime_nanos,\n\t\t\t    p->mtime, p->mtime_nanos,\n\t\t\t    p->ctime, p->ctime_nanos);\n\t\t}\n\t\tif (p->fixup & TODO_MODE_BASE) {\n#ifdef HAVE_FCHMOD\n\t\t\tif (fd >= 0)\n\t\t\t\tfchmod(fd, p->mode);\n\t\t\telse\n#endif\n\t\t\tchmod(p->name, p->mode);\n\t\t}\n\t\tif (p->fixup & TODO_ACLS)\n\t\t\tarchive_write_disk_set_acls(&a->archive, fd,\n\t\t\t    p->name, &p->acl, p->mode);\n\t\tif (p->fixup & TODO_FFLAGS)\n\t\t\tset_fflags_platform(a, fd, p->name,\n\t\t\t    p->mode, p->fflags_set, 0);\n\t\tif (p->fixup & TODO_MAC_METADATA)\n\t\t\tset_mac_metadata(a, p->name, p->mac_metadata,\n\t\t\t\t\t p->mac_metadata_size);\n\t\tnext = p->next;\n\t\tarchive_acl_clear(&p->acl);\n\t\tfree(p->mac_metadata);\n\t\tfree(p->name);\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\tfree(p);\n\t\tp = next;\n\t}\n\ta->fixup_list = NULL;\n\treturn (ret);\n}", "target": 1}
{"code": "cp1251_apply_all_case_fold(OnigCaseFoldType flag,\n\t\t\t       OnigApplyAllCaseFoldFunc f, void* arg, OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_apply_all_case_fold_with_map(\n             sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,\n             flag, f, arg);\n}", "target": 0}
{"code": "libxlDomainCreateChannelPTY(virDomainDef *def, libxl_ctx *ctx)\n{\n    libxl_device_channel *x_channels;\n    virDomainChrDef *chr;\n    size_t i;\n    int nchannels;\n    x_channels = libxl_device_channel_list(ctx, def->id, &nchannels);\n    if (!x_channels)\n        return;\n    for (i = 0; i < def->nchannels; i++) {\n        libxl_channelinfo channelinfo;\n        int ret;\n        chr = def->channels[i];\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_PTY)\n            continue;\n        ret = libxl_device_channel_getinfo(ctx, def->id, &x_channels[i],\n                                           &channelinfo);\n        if (!ret && channelinfo.u.pty.path &&\n            *channelinfo.u.pty.path != '\\0') {\n                VIR_FREE(chr->source->data.file.path);\n                chr->source->data.file.path = g_strdup(channelinfo.u.pty.path);\n            }\n    }\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n}", "target": 0}
{"code": "Item *Item_cache_wrapper::check_cache()\n{\n  DBUG_ENTER(\"Item_cache_wrapper::check_cache\");\n  if (expr_cache)\n  {\n    Expression_cache_tmptable::result res;\n    Item *cached_value;\n    init_on_demand();\n    res= expr_cache->check_value(&cached_value);\n    if (res == Expression_cache_tmptable::HIT)\n      DBUG_RETURN(cached_value);\n  }\n  DBUG_RETURN(NULL);\n}", "target": 0}
{"code": "static struct ast_sip_endpoint *transport_identify(pjsip_rx_data *rdata)\n{\n\tchar buffer[PJ_INET6_ADDRSTRLEN];\n\tpj_status_t status;\n\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n\tunion pj_sockaddr sock = rdata->tp_info.transport->local_addr;\n\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n\tif (sock.addr.sa_family == PJ_AF_INET6) {\n\t\tstatus = pj_inet_ntop(PJ_AF_INET6, &(sock.ipv6.sin6_addr), buffer, PJ_INET6_ADDRSTRLEN);\n\t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"::\")) {\n\t\t\tast_log(LOG_WARNING, \"Matching against '::' may be unpredictable.\\n\");\n\t\t}\n\t} else {\n\t\tstatus = pj_inet_ntop(PJ_AF_INET, &(sock.ipv4.sin_addr), buffer, PJ_INET_ADDRSTRLEN);\n\t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"0.0.0.0\")) {\n\t\t\tast_log(LOG_WARNING, \"Matching against '0.0.0.0' may be unpredictable.\\n\");\n\t\t}\n\t}\n\tif (status == PJ_SUCCESS) {\n\t\tast_sockaddr_parse(&addr_with_tp.addr, buffer, PARSE_PORT_FORBID);\n\t\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->tp_info.transport->local_name.port);\n\t\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n\t} else {\n\t\treturn NULL;\n\t}\n}", "target": 1}
{"code": "process_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int nentries = 0;\n\tdebug2_f(\"entering\");\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}", "target": 1}
{"code": "static int input_default_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tunsigned int index;\n\tint error;\n\tint i;\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\tif (dev->keycodesize < sizeof(ke->keycode) &&\n\t\t\t(ke->keycode >> (dev->keycodesize * 8)))\n\t\treturn -EINVAL;\n\tswitch (dev->keycodesize) {\n\t\tcase 1: {\n\t\t\tu8 *k = (u8 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tu16 *k = (u16 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tu32 *k = (u32 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\t__clear_bit(*old_keycode, dev->keybit);\n\t__set_bit(ke->keycode, dev->keybit);\n\tfor (i = 0; i < dev->keycodemax; i++) {\n\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\tbreak; \n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "    CImg<T>& LabtoXYZ(const bool use_D65=true) {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"LabtoXYZ(): Instance is not a Lab image.\",\n                                    cimg_instance);\n      const CImg<Tfloat> white = CImg<Tfloat>(1,1,1,3,255).RGBtoXYZ(use_D65);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=128))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          L = (Tfloat)p1[N],\n          a = (Tfloat)p2[N],\n          b = (Tfloat)p3[N],\n          cY = (L + 16)/116,\n          cZ = cY - b/200,\n          cX = a/500 + cY,\n          X = (Tfloat)(24389*cX>216?cX*cX*cX:(116*cX - 16)*27/24389),\n          Y = (Tfloat)(27*L>216?cY*cY*cY:27*L/24389),\n          Z = (Tfloat)(24389*cZ>216?cZ*cZ*cZ:(116*cZ - 16)*27/24389);\n        p1[N] = (T)(X*white[0]);\n        p2[N] = (T)(Y*white[1]);\n        p3[N] = (T)(Z*white[2]);\n      }\n      return *this;", "target": 0}
{"code": "DECLAREContigPutFunc(putRGBcontig8bitCMYKtile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint16 r, g, b, k;\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    while (h-- > 0) {\n\tUNROLL8(w, NOP,\n\t    k = 255 - pp[3];\n\t    r = (k*(255-pp[0]))/255;\n\t    g = (k*(255-pp[1]))/255;\n\t    b = (k*(255-pp[2]))/255;\n\t    *cp++ = PACK(r, g, b);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 0}
{"code": "static MagickBooleanType ConcatenateImages(int argc,char **argv,\n     ExceptionInfo *exception )\n{\n  FILE\n    *input,\n    *output;\n  int\n    c;\n  register ssize_t\n    i;\n  if (ExpandFilenames(&argc,&argv) == MagickFalse)\n    ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n         GetExceptionMessage(errno));\n  output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL) {\n    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n    return(MagickFalse);\n  }\n  for (i=2; i < (ssize_t) (argc-1); i++) {\n#if 0\n    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n#endif\n    input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL) {\n        ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n        continue;\n      }\n    for (c=fgetc(input); c != EOF; c=fgetc(input))\n      (void) fputc((char) c,output);\n    (void) fclose(input);\n    (void) remove_utf8(argv[i]);\n  }\n  (void) fclose(output);\n  return(MagickTrue);\n}", "target": 1}
{"code": "void fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\tff->reserved_req->force = 1;\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}", "target": 0}
{"code": "    Olympus2MnHeader::~Olympus2MnHeader()\n    {\n    }", "target": 0}
{"code": "static int hiddev_open(struct inode *inode, struct file *file)\n{\n\tstruct hiddev_list *list;\n\tstruct usb_interface *intf;\n\tstruct hid_device *hid;\n\tstruct hiddev *hiddev;\n\tint res;\n\tintf = usbhid_find_interface(iminor(inode));\n\tif (!intf)\n\t\treturn -ENODEV;\n\thid = usb_get_intfdata(intf);\n\thiddev = hid->hiddev;\n\tif (!(list = vzalloc(sizeof(struct hiddev_list))))\n\t\treturn -ENOMEM;\n\tmutex_init(&list->thread_lock);\n\tlist->hiddev = hiddev;\n\tfile->private_data = list;\n\tif (list->hiddev->exist) {\n\t\tif (!list->hiddev->open++) {\n\t\t\tres = hid_hw_open(hiddev->hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail;\n\t\t}\n\t} else {\n\t\tres = -ENODEV;\n\t\tgoto bail;\n\t}\n\tspin_lock_irq(&list->hiddev->list_lock);\n\tlist_add_tail(&list->node, &hiddev->list);\n\tspin_unlock_irq(&list->hiddev->list_lock);\n\tmutex_lock(&hiddev->existancelock);\n\tif (!list->hiddev->exist) {\n\t\tres = -ENODEV;\n\t\tgoto bail_unlock;\n\t}\n\tif (!list->hiddev->open++)\n\t\tif (list->hiddev->exist) {\n\t\t\tstruct hid_device *hid = hiddev->hid;\n\t\t\tres = hid_hw_power(hid, PM_HINT_FULLON);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_unlock;\n\t\t\tres = hid_hw_open(hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_normal_power;\n\t\t}\n\tmutex_unlock(&hiddev->existancelock);\n\treturn 0;\nbail_normal_power:\n\thid_hw_power(hid, PM_HINT_NORMAL);\nbail_unlock:\n\tmutex_unlock(&hiddev->existancelock);\nbail:\n\tfile->private_data = NULL;\n\tvfree(list);\n\treturn res;\n}", "target": 1}
{"code": "zzip_disk_entry_fopen (ZZIP_DISK* disk, ZZIP_DISK_ENTRY* entry)\n{\n    ZZIP_DISK_FILE* file = malloc(sizeof(ZZIP_DISK_FILE));\n    if (! file) return file;\n    file->buffer = disk->buffer;\n    file->endbuf = disk->endbuf;\n    file->header = zzip_disk_entry_to_file_header (disk, entry);\n    if (! file->header) { free (file); return 0; }\n    file->avail = zzip_file_header_usize (file->header);\n    if (! file->avail || zzip_file_header_data_stored (file->header))\n    { file->stored = zzip_file_header_to_data (file->header); return file; }\n    file->stored = 0;\n    file->zlib.opaque = 0;\n    file->zlib.zalloc = Z_NULL;\n    file->zlib.zfree = Z_NULL;\n    file->zlib.avail_in = zzip_file_header_csize (file->header);\n    file->zlib.next_in = zzip_file_header_to_data (file->header);\n    if (! zzip_file_header_data_deflated (file->header) ||\n\tinflateInit2 (& file->zlib, -MAX_WBITS) != Z_OK)\n    { free (file); return 0; }\n    return file;\n}", "target": 1}
{"code": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tmark_files_ro(sb);\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}", "target": 1}
{"code": "RenderProcessHost* RenderFrameHostImpl::GetProcess() {\n  return render_view_host_->GetProcess();\n}", "target": 0}
{"code": " static MagickBooleanType ConcatenateImages(int argc,char **argv,\n     ExceptionInfo *exception )\n {\n   FILE\n     *input,\n     *output;\n   int\n     c;\n  register ssize_t\n    i;\n   if (ExpandFilenames(&argc,&argv) == MagickFalse)\n     ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n         GetExceptionMessage(errno));\n   output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL) {\n    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n    return(MagickFalse);\n  }\n  for (i=2; i < (ssize_t) (argc-1); i++) {\n#if 0\n    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n#endif\n     input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL) {\n         ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n         continue;\n       }\n     for (c=fgetc(input); c != EOF; c=fgetc(input))\n      (void) fputc((char) c,output);\n     (void) fclose(input);\n     (void) remove_utf8(argv[i]);\n   }\n   (void) fclose(output);\n  return(MagickTrue);\n }", "target": 1}
{"code": "void PrepareFrameAndViewForPrint::StartPrinting() {\n  ResizeForPrinting();\n  blink::WebView* web_view = frame_.view();\n  web_view->settings()->setShouldPrintBackgrounds(should_print_backgrounds_);\n  expected_pages_count_ =\n      frame()->printBegin(web_print_params_, node_to_print_);\n  is_printing_started_ = true;\n}", "target": 0}
{"code": "NOEXPORT int parse_socket_error(CLI *c, const char *text) {\n    switch(get_last_socket_error()) {\n    case 0: \n#ifndef USE_WIN32\n    case EPIPE: \n#endif\n    case S_ECONNABORTED:\n        s_log(LOG_INFO, \"%s: Socket is closed\", text);\n        return 0;\n    case S_EINTR:\n        s_log(LOG_DEBUG, \"%s: Interrupted by a signal: retrying\", text);\n        return 1;\n    case S_EWOULDBLOCK:\n        s_log(LOG_NOTICE, \"%s: Would block: retrying\", text);\n        s_poll_sleep(1, 0); \n        return 1;\n#if S_EAGAIN!=S_EWOULDBLOCK\n    case S_EAGAIN:\n        s_log(LOG_DEBUG,\n            \"%s: Temporary lack of resources: retrying\", text);\n        return 1;\n#endif\n#ifdef USE_WIN32\n    case S_ECONNRESET:\n        if(c->opt->exec_name) {\n            s_log(LOG_INFO, \"%s: Socket is closed (exec)\", text);\n            return 0;\n        }\n#endif\n    default:\n        sockerror(text);\n        throw_exception(c, 1);\n        return -1; \n    }\n}", "target": 1}
{"code": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){\n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 0}
{"code": " static void tokenadd(struct jv_parser* p, char c) {\n   assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n     p->tokenlen = p->tokenlen*2 + 256;\n     p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n   }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}", "target": 1}
{"code": "isdn_minor2drv(int minor)\n{\n\treturn (dev->drvmap[minor]);\n}", "target": 0}
{"code": "    ExifData::iterator ExifData::erase(ExifData::iterator pos)\n    {\n        return exifMetadata_.erase(pos);\n    }", "target": 0}
{"code": "SAPI_API int sapi_get_fd(int *fd TSRMLS_DC)\n{\n\tif (sapi_module.get_fd) {\n\t\treturn sapi_module.get_fd(fd TSRMLS_CC);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}", "target": 0}
{"code": "purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    funcname = \"kadm5_purgekeys\";\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp)\n         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                                arg->princ, NULL))) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_purgekeys((void *)handle, arg->princ,\n                                   arg->keepkvno);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "onig_node_str_clear(Node* node)\n{\n  if (STR_(node)->capa != 0 &&\n      IS_NOT_NULL(STR_(node)->s) && STR_(node)->s != STR_(node)->buf) {\n    xfree(STR_(node)->s);\n  }\n  STR_(node)->capa = 0;\n  STR_(node)->flag = 0;\n  STR_(node)->s    = STR_(node)->buf;\n  STR_(node)->end  = STR_(node)->buf;\n}", "target": 0}
{"code": "fbStore_b2g3r3 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    CARD8   *pixel = ((CARD8 *) bits) + x;\n    for (i = 0; i < width; ++i) {\n        Split(READ(values + i));\n        WRITE(pixel++, ((b     ) & 0xe0) |\n\t      ((g >> 3) & 0x1c) |\n\t      ((r >> 6)       ));\n    }\n}", "target": 0}
{"code": " static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n {\n \tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n \tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n \tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n \treturn 0;\n }", "target": 1}
{"code": "name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n \tfor (;;) {\n \t\tu8 label_len;\n\t\tif (j >= length) return -1;\n \t\tGET8(label_len);\n \t\tif (!label_len) break;\n \t\tif (label_len & 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end < 0) name_end = j;\n\t\t\tj = (((int)label_len & 0x3f) << 8) + ptr_low;\n\t\t\tif (j < 0 || j >= length) return -1;\n\t\t\tif (++ptr_count > length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len > 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 >= end) return -1;\n \t\t\t*cp++ = '.';\n \t\t}\n \t\tif (cp + label_len >= end) return -1;\n \t\tmemcpy(cp, packet + j, label_len);\n \t\tcp += label_len;\n \t\tj += label_len;\n\t}\n\tif (cp >= end) return -1;\n\t*cp = '\\0';\n\tif (name_end < 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}", "target": 1}
{"code": "int ldb_msg_add_string(struct ldb_message *msg,\n\t\t       const char *attr_name, const char *str)\n{\n\treturn ldb_msg_add_string_flags(msg, attr_name, str, 0);\n}", "target": 0}
{"code": "update_sum_func(Item_sum **func_ptr)\n{\n  Item_sum *func;\n  for (; (func= (Item_sum*) *func_ptr) ; func_ptr++)\n    if (func->aggregator_add())\n      return 1;\n  return 0;\n}", "target": 0}
{"code": "b64decode(const uschar *code, uschar **ptr)\n{\nint x, y;\nuschar *result = store_get(3*(Ustrlen(code)/4) + 1);\n*ptr = result;\nwhile ((x = *code++) != 0)\n  {\n  if (isspace(x)) continue;\n  if (x > 127 || (x = dec64table[x]) == 255) return -1;\n  while (isspace(y = *code++)) ;\n  if (y == 0 || (y = dec64table[y]) == 255)\n    return -1;\n  *result++ = (x << 2) | (y >> 4);\n  while (isspace(x = *code++)) ;\n  if (x == '=')\t\t\n    {\n    while (isspace(x = *code++)) ;\n    if (x != '=') return -1;\n    while (isspace(y = *code++)) ;\n    if (y != 0) return -1;\n    break;\n    }\n  else\n    {\n    if (x > 127 || (x = dec64table[x]) == 255) return -1;\n    *result++ = (y << 4) | (x >> 2);\n    while (isspace(y = *code++)) ;\n    if (y == '=')\n      {\n      while (isspace(y = *code++)) ;\n      if (y != 0) return -1;\n      break;\n      }\n    else\n      {\n      if (y > 127 || (y = dec64table[y]) == 255) return -1;\n      *result++ = (x << 6) | y;\n      }\n    }\n  }\n*result = 0;\nreturn result - *ptr;\n}", "target": 1}
{"code": "sync_create_state_control(Slapi_Entry *e, LDAPControl **ctrlp, int type, Sync_Cookie *cookie)\n{\n    int rc;\n    BerElement *ber;\n    struct berval *bvp;\n    char *uuid;\n    Slapi_Attr *attr;\n    Slapi_Value *val;\n    if (type == LDAP_SYNC_NONE || ctrlp == NULL || (ber = der_alloc()) == NULL) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n    *ctrlp = NULL;\n    slapi_entry_attr_find(e, SLAPI_ATTR_UNIQUEID, &attr);\n    slapi_attr_first_value(attr, &val);\n    uuid = sync_nsuniqueid2uuid(slapi_value_get_string(val));\n    if ((rc = ber_printf(ber, \"{eo\", type, uuid, 16)) != -1) {\n        if (cookie) {\n            char *cookiestr = sync_cookie2str(cookie);\n            rc = ber_printf(ber, \"s}\", cookiestr);\n            slapi_ch_free((void **)&cookiestr);\n        } else {\n            rc = ber_printf(ber, \"}\");\n        }\n    }\n    if (rc != -1) {\n        rc = ber_flatten(ber, &bvp);\n    }\n    ber_free(ber, 1);\n    slapi_ch_free((void **)&uuid);\n    if (rc == -1) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n    *ctrlp = (LDAPControl *)slapi_ch_malloc(sizeof(LDAPControl));\n    (*ctrlp)->ldctl_iscritical = 0;\n    (*ctrlp)->ldctl_oid = slapi_ch_strdup(LDAP_CONTROL_SYNC_STATE);\n    (*ctrlp)->ldctl_value = *bvp; \n    bvp->bv_val = NULL;\n    ber_bvfree(bvp);\n    return (LDAP_SUCCESS);\n}", "target": 1}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n     len = (*p)[0] << 8 | (*p)[1];\n     *p += 2;\n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 1}
{"code": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) \n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\tumount2(path, MNT_DETACH); \n\t\tgoto domount;\n\t}\n\treturn 0;\ndomount:\n\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}", "target": 1}
{"code": "int wake_up_state(struct task_struct *p, unsigned int state)\n{\n\treturn try_to_wake_up(p, state, 0);\n}", "target": 0}
{"code": "inline int32_t byteswap(int32_t value) { return _af_byteswap_int32(value); }", "target": 0}
{"code": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 16: \n#line 94 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1023 \"hex_grammar.c\" \n        break;\n    case 17: \n#line 95 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1029 \"hex_grammar.c\" \n        break;\n    case 18: \n#line 96 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1035 \"hex_grammar.c\" \n        break;\n    case 19: \n#line 97 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1041 \"hex_grammar.c\" \n        break;\n    case 21: \n#line 100 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1047 \"hex_grammar.c\" \n        break;\n    case 22: \n#line 99 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1053 \"hex_grammar.c\" \n        break;\n    case 23: \n#line 98 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1059 \"hex_grammar.c\" \n        break;\n      default:\n        break;\n    }", "target": 1}
{"code": " cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n     cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n {\n\tsize_t i, maxcount;\n \tconst cdf_summary_info_header_t *si =\n \t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n \tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, (const void *)\n\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n \tssi->si_os = CDF_TOLE2(si->si_os);\n \tssi->si_class = si->si_class;\n \tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE2(si->si_count);\n \t*count = 0;\n \tmaxcount = 0;\n \t*info = NULL;\n\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n\t\tif (i >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Unpack summary info loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn -1;\n\t\t}\n\t\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),\n\t\t    info, count, &maxcount) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t}\n \treturn 0;\n }", "target": 1}
{"code": "void gdImageColorDeallocate (gdImagePtr im, int color)\n{\n\tif (im->trueColor) {\n\t\treturn;\n\t}\n\tim->open[color] = 1;\n}", "target": 0}
{"code": "void OmniboxViewWin::SetUserText(const string16& text,\n                                 const string16& display_text,\n                                 bool update_popup) {\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  model_->SetUserText(text);\n  saved_selection_for_focus_change_.cpMin = -1;\n  SetWindowTextAndCaretPos(display_text, display_text.length());\n  if (update_popup)\n    UpdatePopup();\n  TextChanged();\n}", "target": 0}
{"code": "printing::MarginType GetMarginsForPdf(WebFrame* frame, const WebNode& node) {\n  if (frame->isPrintScalingDisabledForPlugin(node))\n    return printing::NO_MARGINS;\n  else\n    return printing::PRINTABLE_AREA_MARGINS;\n}", "target": 0}
{"code": "call_backend(char *uri,                 \n\t     int  argc,                 \n\t     char **argv,\t\t\n\t     char *filename)            \n{\n  const char\t*cups_serverbin;\t\n  char\t\tscheme[1024],           \n                *ptr,\t\t\t\n\t\tcmdline[65536];\t\t\n  int           retval;\n  strncpy(scheme, uri, sizeof(scheme) - 1);\n  if (strlen(uri) > 1023)\n    scheme[1023] = '\\0';\n  if ((ptr = strchr(scheme, ':')) != NULL)\n    *ptr = '\\0';\n  if ((cups_serverbin = getenv(\"CUPS_SERVERBIN\")) == NULL)\n    cups_serverbin = CUPS_SERVERBIN;\n  if (!strncasecmp(uri, \"file:\", 5) || uri[0] == '/')\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Direct output into a file not supported.\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n  else\n    snprintf(cmdline, sizeof(cmdline),\n\t     \"%s/backend/%s '%s' '%s' '%s' '%s' '%s' %s\",\n\t     cups_serverbin, scheme, argv[1], argv[2], argv[3],\n\t     (argc == 6 ? \"1\" : argv[4]),\n\t     argv[5], filename);\n  setenv(\"DEVICE_URI\", uri, 1);\n  fprintf(stderr,\n\t  \"DEBUG: beh: Executing backend command line \\\"%s\\\"...\\n\",\n\t  cmdline);\n  fprintf(stderr,\n\t  \"DEBUG: beh: Using device URI: %s\\n\",\n\t  uri);\n  retval = system(cmdline) >> 8;\n  if (retval == -1)\n    fprintf(stderr, \"ERROR: Unable to execute backend command line: %s\\n\",\n\t    strerror(errno));\n  return (retval);\n}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    CHECK_GE(dtypes.size(), size_t{1});\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static int bufp_alloc(USBRedirDevice *dev, uint8_t *data, uint16_t len,\n    uint8_t status, uint8_t ep, void *free_on_destroy)\n{\n    struct buf_packet *bufp;\n    if (!dev->endpoint[EP2I(ep)].bufpq_dropping_packets &&\n        dev->endpoint[EP2I(ep)].bufpq_size >\n            2 * dev->endpoint[EP2I(ep)].bufpq_target_size) {\n        DPRINTF(\"bufpq overflow, dropping packets ep %02X\\n\", ep);\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 1;\n    }\n    if (dev->endpoint[EP2I(ep)].bufpq_dropping_packets) {\n        if (dev->endpoint[EP2I(ep)].bufpq_size >\n                dev->endpoint[EP2I(ep)].bufpq_target_size) {\n            free(data);\n            return -1;\n        }\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;\n    }\n    bufp = g_new(struct buf_packet, 1);\n    bufp->data   = data;\n    bufp->len    = len;\n    bufp->offset = 0;\n    bufp->status = status;\n    bufp->free_on_destroy = free_on_destroy;\n    QTAILQ_INSERT_TAIL(&dev->endpoint[EP2I(ep)].bufpq, bufp, next);\n    dev->endpoint[EP2I(ep)].bufpq_size++;\n    return 0;\n}", "target": 1}
{"code": "static int dump_suid_policy()\n{\n    int c;\n    int suid_dump_policy = 0;\n    const char *filename = \"/proc/sys/fs/suid_dumpable\";\n    FILE *f  = fopen(filename, \"r\");\n    if (!f)\n    {\n        log(\"Can't open %s\", filename);\n        return suid_dump_policy;\n    }\n    c = fgetc(f);\n    fclose(f);\n    if (c != EOF)\n        suid_dump_policy = c - '0';\n    return suid_dump_policy;\n}", "target": 0}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "void main_cleanup() {\n#ifdef USE_OS_THREADS\n    CLI *c;\n    unsigned i, threads;\n    THREAD_ID *thread_list;\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_THREAD_LIST]);\n    threads=0;\n    for(c=thread_head; c; c=c->thread_next) \n        threads++;\n    thread_list=str_alloc((threads+1)*sizeof(THREAD_ID));\n    i=0;\n    for(c=thread_head; c; c=c->thread_next) { \n        thread_list[i++]=c->thread_id;\n        s_log(LOG_DEBUG, \"Terminating a thread for [%s]\", c->opt->servname);\n    }\n    if(cron_thread_id) { \n        thread_list[threads++]=cron_thread_id;\n        s_log(LOG_DEBUG, \"Terminating the cron thread\");\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_THREAD_LIST]);\n    if(threads) {\n        s_log(LOG_NOTICE, \"Terminating %u service thread(s)\", threads);\n        writesocket(terminate_pipe[1], \"\", 1);\n        for(i=0; i<threads; ++i) { \n#ifdef USE_PTHREAD\n            if(pthread_join(thread_list[i], NULL))\n                s_log(LOG_ERR, \"pthread_join() failed\");\n#endif\n#ifdef USE_WIN32\n            if(WaitForSingleObject(thread_list[i], INFINITE)==WAIT_FAILED)\n                ioerror(\"WaitForSingleObject\");\n            if(!CloseHandle(thread_list[i]))\n                ioerror(\"CloseHandle\");\n#endif\n        }\n        s_log(LOG_NOTICE, \"Service threads terminated\");\n    }\n    str_free(thread_list);\n#endif \n    unbind_ports();\n    s_poll_free(fds);\n    fds=NULL;\n#if 0\n    str_stats(); \n#endif\n    log_flush(LOG_MODE_ERROR);\n    log_close(SINK_SYSLOG|SINK_OUTFILE);\n}", "target": 1}
{"code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& indices = ctx->input(0);\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& dense_shape = ctx->input(2);\n    const Tensor& size_t = ctx->input(3);\n    const auto weights = ctx->input(4).flat<T>();\n    const int64_t weights_size = weights.size();\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    bool is_1d = dense_shape.NumElements() == 1;\n    Tensor* out_t;\n    functor::SetZeroFunctor<Device, T> fill;\n    if (is_1d) {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({size}), &out_t));\n      auto out = out_t->flat<T>();\n      fill(ctx->eigen_device<Device>(), out);\n      if (binary_output_) {\n        OP_REQUIRES_OK(ctx,\n                       functor::BincountFunctor<Device, Tidx, T, true>::Compute(\n                           ctx, values, weights, out, size));\n      } else {\n        OP_REQUIRES_OK(\n            ctx, functor::BincountFunctor<Device, Tidx, T, false>::Compute(\n                     ctx, values, weights, out, size));\n      }\n    } else {\n      const auto shape = dense_shape.flat<int64_t>();\n      const int64_t num_rows = shape(0);\n      OP_REQUIRES_OK(\n          ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n      const auto out = out_t->matrix<T>();\n      fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n      const auto indices_mat = indices.matrix<int64_t>();\n      for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {\n        const int64_t batch = indices_mat(i, 0);\n        const Tidx bin = values(i);\n        if (bin < size) {\n          if (binary_output_) {\n            out(batch, bin) = T(1);\n          } else {\n            if (weights_size) {\n              out(batch, bin) += weights(i);\n            } else {\n              out(batch, bin) += T(1);\n            }\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\n\t\t\tstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\n{\n\tstruct activation_params_nfca_poll_iso_dep *nfca_poll;\n\tstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\tnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\n\t\tnfca_poll->rats_res_len = *data++;\n\t\tpr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);\n\t\tif (nfca_poll->rats_res_len > 0) {\n\t\t\tmemcpy(nfca_poll->rats_res,\n\t\t\t       data, nfca_poll->rats_res_len);\n\t\t}\n\t\tbreak;\n\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\tnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\n\t\tnfcb_poll->attrib_res_len = *data++;\n\t\tpr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);\n\t\tif (nfcb_poll->attrib_res_len > 0) {\n\t\t\tmemcpy(nfcb_poll->attrib_res,\n\t\t\t       data, nfcb_poll->attrib_res_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\treturn NCI_STATUS_OK;\n}", "target": 1}
{"code": "void CE_WideToChar(unsigned short *w_str, char *str)\n{\n\tWideCharToMultiByte(CP_ACP, 0, w_str, -1, str, GF_MAX_PATH, NULL, NULL);\n}", "target": 0}
{"code": "static unsigned char *oidc_cache_hash_passphrase(request_rec *r,\n\t\tconst char *passphrase) {\n\tunsigned char *key = NULL;\n\tunsigned int key_len = 0;\n\toidc_jose_error_t err;\n\tif (oidc_jose_hash_bytes(r->pool, OIDC_JOSE_ALG_SHA256,\n\t\t\t(const unsigned char *) passphrase, strlen(passphrase), &key,\n\t\t\t&key_len, &err) == FALSE) {\n\t\toidc_error(r, \"oidc_jose_hash_bytes returned an error: %s\", err.text);\n\t\treturn NULL;\n\t}\n\treturn key;\n}", "target": 1}
{"code": "static int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n  if (!s)\n    return -1;\n  while (*s)\n  {\n    SKIPWS (s);\n    if (ascii_strncasecmp (\"FLAGS\", s, 5) == 0)\n    {\n      if ((s = msg_parse_flags (h, s)) == NULL)\n        return -1;\n    }\n    else if (ascii_strncasecmp (\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS (s);\n      if (mutt_atoui (s, &h->data->uid) < 0)\n        return -1;\n      s = imap_next_word (s);\n    }\n    else if (ascii_strncasecmp (\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS (s);\n      if (*s != '\\\"')\n      {\n        dprint (1, (debugfile, \"msg_parse_fetch(): bogus INTERNALDATE entry: %s\\n\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    }\n    else if (ascii_strncasecmp (\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      while (isdigit ((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"BODY\", s, 4) ||\n      !ascii_strncasecmp (\"RFC822.HEADER\", s, 13))\n    {\n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      imap_error (\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "struct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {\n\tstruct addr_t *entry;\n\tint i;\n\tif (!bin->entry && !bin->sects) {\n\t\treturn NULL;\n\t}\n\tif (!(entry = calloc (1, sizeof (struct addr_t)))) {\n\t\treturn NULL;\n\t}\n\tif (bin->entry) {\n\t\tentry->addr = entry_to_vaddr (bin);\n\t\tentry->offset = addr_to_offset (bin, entry->addr);\n\t\tentry->haddr = sdb_num_get (bin->kv, \"mach0.entry.offset\", 0);\n\t}\n\tif (!bin->entry || entry->offset == 0) {\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\tif (!strncmp (bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set (bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { \n\t\t\t\t\tentry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\treturn entry;\n}", "target": 1}
{"code": "void GLES2DecoderImpl::DoTexParameterf(\n    GLenum target, GLenum pname, GLfloat param) {\n  TextureManager::TextureInfo* info = GetTextureInfoForTarget(target);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glTexParameterf: unknown texture\");\n  } else {\n    texture_manager()->SetParameter(info, pname, static_cast<GLint>(param));\n    glTexParameterf(target, pname, param);\n  }\n}", "target": 0}
{"code": "WebPlugin* RenderView::createPlugin(WebFrame* frame,\n                                    const WebPluginParams& params) {\n  bool found = false;\n  WebPluginInfo info;\n  GURL url(params.url);\n  std::string actual_mime_type;\n  Send(new ViewHostMsg_GetPluginInfo(url,\n                                     frame->top()->url(),\n                                     params.mimeType.utf8(),\n                                     &found,\n                                     &info,\n                                     &actual_mime_type));\n  if (!found)\n    return NULL;\n  scoped_ptr<PluginGroup> group(PluginGroup::FindHardcodedPluginGroup(info));\n  group->AddPlugin(info, 0);\n  if (!info.enabled) {\n    if (CommandLine::ForCurrentProcess()->HasSwitch(\n            switches::kDisableOutdatedPlugins) &&\n        group->IsVulnerable()) {\n      Send(new ViewHostMsg_DisabledOutdatedPlugin(routing_id_,\n                                                  group->GetGroupName(),\n                                                  GURL(group->GetUpdateURL())));\n      return CreatePluginPlaceholder(frame, params, group.get());\n    }\n    return NULL;\n  }\n  if (info.path.value() != kDefaultPluginLibraryName) {\n    if (!AllowContentType(CONTENT_SETTINGS_TYPE_PLUGINS)) {\n      DCHECK(CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableClickToPlay));\n      didNotAllowPlugins(frame);\n      return CreatePluginPlaceholder(frame, params, NULL);\n    }\n    scoped_refptr<pepper::PluginModule> pepper_module =\n        PepperPluginRegistry::GetInstance()->GetModule(info.path);\n    if (pepper_module)\n      return CreatePepperPlugin(frame, params, info.path, pepper_module.get());\n    if (CommandLine::ForCurrentProcess()->HasSwitch(\n            switches::kBlockNonSandboxedPlugins)) {\n      Send(new ViewHostMsg_NonSandboxedPluginBlocked(routing_id_,\n                                                     group->GetGroupName()));\n      return CreatePluginPlaceholder(frame, params, NULL);\n    }\n  }\n  return CreateNPAPIPlugin(frame, params, info.path, actual_mime_type);\n}", "target": 0}
{"code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n \tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n \t\t\t\t\t  fm10k_driver_name);\n \tfm10k_dbg_init();\n\treturn fm10k_register_pci_driver();\n}", "target": 1}
{"code": "void fuse_fs_destroy(struct fuse_fs *fs)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.destroy)\n        fs->op.destroy(fs->user_data);\n#ifdef __SOLARIS__\n    if (fs->m)\n        fuse_put_module(fs->m);\n#endif \n    free(fs);\n}", "target": 0}
{"code": "TEST(MatchHeadersTest, HeaderContainsInverseMatch) {\n  TestRequestHeaderMapImpl matching_headers{{\"match-header\", \"123onevalue456\"}};\n  TestRequestHeaderMapImpl unmatching_headers{{\"match-header\", \"123anothervalue456\"}};\n  const std::string yaml = R\"EOF(\nname: match-header\ncontains_match: onevalue\ninvert_match: true\n  )EOF\";\n  std::vector<HeaderUtility::HeaderDataPtr> header_data;\n  header_data.push_back(\n      std::make_unique<HeaderUtility::HeaderData>(parseHeaderMatcherFromYaml(yaml)));\n  EXPECT_TRUE(HeaderUtility::matchHeaders(unmatching_headers, header_data));\n  EXPECT_FALSE(HeaderUtility::matchHeaders(matching_headers, header_data));\n}", "target": 0}
{"code": "_tiffSizeProc(thandle_t fd)\n{\n\t_TIFF_stat_s sb;\n\treturn (toff_t) (_TIFF_fstat_f((int) fd, &sb) < 0 ? 0 : sb.st_size);\n}", "target": 0}
{"code": "static int __init redirect_tg_init(void)\n{\n\treturn xt_register_targets(redirect_tg_reg,\n\t\t\t\t   ARRAY_SIZE(redirect_tg_reg));\n}", "target": 0}
{"code": "static pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {\n\tpyc_object *tmp = NULL;\n\tpyc_object *ret = NULL;\n\tut32 i = 0;\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = r_list_newf ((RListFree)free_object);\n\tif (!ret->data) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = get_object (buffer);\n\t\tif (!tmp) {\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!r_list_append (ret->data, tmp)) {\n\t\t\tfree_object (tmp);\n\t\t\tr_list_free (ret->data);\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n {\n \tstruct common_audit_data sa;\n \tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n \tsize_t arg_size;\n \tint error;\n \tif (size == 0)\n \t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n \tif (current != task)\n \t\treturn -EACCES;\n\targs = value;\n \targs = strim(args);\n \tcommand = strsep(&args, \" \");\n \tif (!args)\n\t\treturn -EINVAL;\n \targs = skip_spaces(args);\n \tif (!*args)\n\t\treturn -EINVAL;\n \targ_size = size - (args - (char *) value);\n \tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n \t\t\tgoto fail;\n \t} else\n\t\treturn -EINVAL;\n \tif (!error)\n \t\terror = size;\n \treturn error;\n fail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n \taad.profile = aa_current_profile();\n \taad.op = OP_SETPROCATTR;\n \taad.info = name;\n\taad.error = -EINVAL;\n \taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n }", "target": 1}
{"code": "static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n\t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n\t\tmemcpy(command_info->result_buffer, &data[1],\n\t\t\t\t\t\turb->actual_length - 1);\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}", "target": 1}
{"code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    krb5_clear_error_message(context);\n    if (pol_dn == NULL)\n        return EINVAL;\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n     LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n     ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n     }\n cleanup:\n     ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}", "target": 1}
{"code": "static void write_version(\n    FILE       *fp,\n    const char *fname,\n    const char *dirname,\n    xref_t     *xref)\n{\n    long  start;\n    char *c, *new_fname, data;\n    FILE *new_fp;\n    start = ftell(fp);\n    if ((c = strstr(fname, \".pdf\")))\n      *c = '\\0';\n    new_fname = malloc(strlen(fname) + strlen(dirname) + 16);\n    snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,\n             \"%s/%s-version-%d.pdf\", dirname, fname, xref->version);\n    if (!(new_fp = fopen(new_fname, \"w\")))\n    {\n        ERR(\"Could not create file '%s'\\n\", new_fname);\n        fseek(fp, start, SEEK_SET);\n        free(new_fname);\n        return;\n    }\n    fseek(fp, 0, SEEK_SET);\n    while (fread(&data, 1, 1, fp))\n      fwrite(&data, 1, 1, new_fp);\n    fprintf(new_fp, \"\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF\", xref->start);\n    fclose(new_fp);\n    free(new_fname);\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "void ChildThread::OnChannelError() {\n  set_on_channel_error_called(true);\n  base::MessageLoop::current()->Quit();\n}", "target": 0}
{"code": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n    }\n    if (data_end - data < 3)\n        return -1;\n    data++;\n    for (;;) {\n        int size = bytestream_get_be16(&data);\n        if (!size)\n            break;\n        if (size < 0 || size >= data_end - data)\n            return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n            return -1;\n        data += len;\n    }\n    return -1;\n}", "target": 1}
{"code": "void GfxPath::lineTo(double x, double y)\n{\n    if (justMoved || (n > 0 && subpaths[n - 1]->isClosed())) {\n        if (n >= size) {\n            size *= 2;\n            subpaths = (GfxSubpath **)greallocn(subpaths, size, sizeof(GfxSubpath *));\n        }\n        if (justMoved) {\n            subpaths[n] = new GfxSubpath(firstX, firstY);\n        } else {\n            subpaths[n] = new GfxSubpath(subpaths[n - 1]->getLastX(), subpaths[n - 1]->getLastY());\n        }\n        ++n;\n        justMoved = false;\n    }\n    subpaths[n - 1]->lineTo(x, y);\n}", "target": 0}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "dict_param_write(iparam_list * plist, const ref * pkey, const ref * pvalue)\n{\n    int code =\n        dict_put(&((dict_param_list *) plist)->dict, pkey, pvalue, NULL);\n    return min(code, 0);\n}", "target": 0}
{"code": "njs_string_prototype_char_at(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    size_t             length;\n    int64_t            start;\n    njs_int_t          ret;\n    njs_slice_prop_t   slice;\n    njs_string_prop_t  string;\n    ret = njs_string_object_validate(vm, njs_argument(args, 0));\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    slice.string_length = njs_string_prop(&string, njs_argument(args, 0));\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    length = 1;\n    if (start < 0 || start >= (int64_t) slice.string_length) {\n        start = 0;\n        length = 0;\n    }\n    slice.start = start;\n    slice.length = length;\n    return njs_string_slice(vm, &vm->retval, &string, &slice);\n}", "target": 0}
{"code": "name_to_backref_error(VALUE name)\n{\n    rb_raise(rb_eIndexError, \"undefined group name reference: % \"PRIsVALUE,\n\t     name);\n}", "target": 0}
{"code": "static void restart_dhcp(GDHCPClient *dhcp_client, int retry_times)\n{\n\tdebug(dhcp_client, \"restart DHCP (retries %d)\", retry_times);\n\tremove_timeouts(dhcp_client);\n\tdhcp_client->retry_times = retry_times;\n\tdhcp_client->requested_ip = 0;\n\tdhcp_client->state = INIT_SELECTING;\n\tswitch_listening_mode(dhcp_client, L2);\n\tg_dhcp_client_start(dhcp_client, dhcp_client->last_address);\n}", "target": 0}
{"code": "static inline void skb_set_transport_header(struct sk_buff *skb,\n\t\t\t\t\t    const int offset)\n{\n\tskb_reset_transport_header(skb);\n\tskb->transport_header += offset;\n}", "target": 0}
{"code": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": "static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 max = field->logical_maximum;\n\t__s32 *value;\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\tfor (n = 0; n < count; n++) {\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n \t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n \t\t    value[n] >= min && value[n] <= max &&\n \t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n \t\t\tgoto exit;\n \t}\n\tfor (n = 0; n < count; n++) {\n\t\tif (HID_MAIN_ITEM_VARIABLE & field->flags) {\n\t\t\thid_process_event(hid, field, &field->usage[n], value[n], interrupt);\n\t\t\tcontinue;\n \t\t}\n \t\tif (field->value[n] >= min && field->value[n] <= max\n \t\t\t&& field->usage[field->value[n] - min].hid\n \t\t\t&& search(value, field->value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n \t\tif (value[n] >= min && value[n] <= max\n \t\t\t&& field->usage[value[n] - min].hid\n \t\t\t&& search(field->value, value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n\t}\n\tmemcpy(field->value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}", "target": 1}
{"code": "bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)\n{\n  if (wcschr(Src,(wchar)MappedStringMark)==NULL)\n    return false;\n  Success=true;\n  uint SrcPos=0,DestPos=0;\n  while (Src[SrcPos]!=0 && DestPos<DestSize-MB_CUR_MAX)\n  {\n    if (uint(Src[SrcPos])==MappedStringMark)\n    {\n      SrcPos++;\n      continue;\n    }\n    if (uint(Src[SrcPos])>=MapAreaStart+0x80 && uint(Src[SrcPos])<MapAreaStart+0x100)\n      Dest[DestPos++]=char(uint(Src[SrcPos++])-MapAreaStart);\n    else\n    {\n      mbstate_t ps;\n      memset(&ps,0,sizeof(ps));\n      if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==-1)\n      {\n        Dest[DestPos]='_';\n        Success=false;\n      }\n      SrcPos++;\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Dest+DestPos,MB_CUR_MAX,&ps);\n      DestPos+=Max(Length,1);\n    }\n  }\n  Dest[Min(DestPos,DestSize-1)]=0;\n  return true;\n}", "target": 1}
{"code": "void Splash::pipeRunAAMono8(SplashPipe *pipe) {\n  Guchar aSrc, aDest, alpha2, aResult;\n  SplashColor cDest;\n  Guchar cResult0;\n  cDest[0] = *pipe->destColorPtr;\n  aDest = *pipe->destAlphaPtr;\n  aSrc = div255(pipe->aInput * pipe->shape);\n  aResult = aSrc + aDest - div255(aSrc * aDest);\n  alpha2 = aResult;\n  if (alpha2 == 0) {\n    cResult0 = 0;\n  } else {\n    cResult0 = state->grayTransfer[(Guchar)(((alpha2 - aSrc) * cDest[0] +\n\t\t\t\t\t     aSrc * pipe->cSrc[0]) / alpha2)];\n  }\n  *pipe->destColorPtr++ = cResult0;\n  *pipe->destAlphaPtr++ = aResult;\n  ++pipe->x;\n}", "target": 0}
{"code": "void HTMLFormControlElement::willCallDefaultEventHandler(const Event& event)\n{\n    if (!event.isKeyboardEvent() || event.type() != EventTypeNames::keydown)\n        return;\n    if (!m_wasFocusedByMouse)\n        return;\n    m_wasFocusedByMouse = false;\n    if (renderer())\n        renderer()->repaint();\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CantExplodeWithEmptyBounds2) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1 << \"c\" << 1));\n    runQuerySortProj(fromjson(\"{a: {$gt: 3, $lt: 0}}\"), BSON(\"b\" << 1), BSONObj());\n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {b:1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {dir: 1}}}}}}\");\n    assertSolutionExists(\n        \"{sort: {pattern: {b:1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{fetch: {node: {ixscan: {pattern: {a:1,b:1,c:1}}}}}}}}}\");\n}", "target": 0}
{"code": "static void nested_release_page(struct page *page)\n{\n\tkvm_release_page_dirty(page);\n}", "target": 0}
{"code": "Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {\n  if (find_local_field(name, sig, fd)) {\n    if (fd->is_static() == is_static) return const_cast<InstanceKlass*>(this);\n  }\n  if (is_static) {\n    Klass* intf = find_interface_field(name, sig, fd);\n    if (intf != NULL) return intf;\n  }\n  { Klass* supr = super();\n    if (supr != NULL) return InstanceKlass::cast(supr)->find_field(name, sig, is_static, fd);\n  }\n  return NULL;\n}", "target": 0}
{"code": "windows_icon_typefind (GstTypeFind * find, gpointer user_data)\n{\n  const guint8 *data;\n  gint64 datalen;\n  guint16 type, nimages;\n  gint32 size, offset;\n  datalen = gst_type_find_get_length (find);\n  if ((data = gst_type_find_peek (find, 0, 6)) == NULL)\n    return;\n  if (GST_READ_UINT16_LE (data) != 0)\n    return;\n  type = GST_READ_UINT16_LE (data + 2);\n  if (type != 1 && type != 2)\n    return;\n  nimages = GST_READ_UINT16_LE (data + 4);\n  if (nimages == 0)             \n    return;\n  if (data[6 + 3] != 0)\n    return;\n  if (type == 1) {\n    guint16 planes = GST_READ_UINT16_LE (data + 6 + 4);\n    if (planes > 1)\n      return;\n  }\n  size = GST_READ_UINT32_LE (data + 6 + 8);\n  offset = GST_READ_UINT32_LE (data + 6 + 12);\n  if (offset < 0 || size <= 0 || size >= datalen || offset >= datalen\n      || size + offset > datalen)\n    return;\n  gst_type_find_suggest_simple (find, GST_TYPE_FIND_NEARLY_CERTAIN,\n      \"image/x-icon\", NULL);\n}", "target": 1}
{"code": "OverscrollControllerAndroid::~OverscrollControllerAndroid() {\n}", "target": 0}
{"code": "static int register_queue_kobjects(struct net_device *dev)\n{\n\tint error = 0, txq = 0, rxq = 0, real_rx = 0, real_tx = 0;\n#ifdef CONFIG_SYSFS\n\tdev->queues_kset = kset_create_and_add(\"queues\",\n\t\t\t\t\t       NULL, &dev->dev.kobj);\n\tif (!dev->queues_kset)\n\t\treturn -ENOMEM;\n\treal_rx = dev->real_num_rx_queues;\n#endif\n\treal_tx = dev->real_num_tx_queues;\n\terror = net_rx_queue_update_kobjects(dev, 0, real_rx);\n\tif (error)\n\t\tgoto error;\n\trxq = real_rx;\n\terror = netdev_queue_update_kobjects(dev, 0, real_tx);\n\tif (error)\n\t\tgoto error;\n\ttxq = real_tx;\n\treturn 0;\nerror:\n\tnetdev_queue_update_kobjects(dev, txq, 0);\n\tnet_rx_queue_update_kobjects(dev, rxq, 0);\n\treturn error;", "target": 1}
{"code": "vips_utf8_strcasestr( const char *haystack_start, const char *needle_start, \n\tint len_bytes )\n{\n        int needle_len = g_utf8_strlen( needle_start, -1 );\n        int needle_len_bytes = strlen( needle_start );\n\tconst char *haystack;\n\tfor( haystack = haystack_start; \n\t\thaystack - haystack_start <= len_bytes - needle_len_bytes; \n\t\thaystack = g_utf8_find_next_char( haystack, NULL ) ) {\n                const char *needle_char;\n                const char *haystack_char;\n\t\tint i;\n                haystack_char = haystack;\n                needle_char = needle_start;\n                for( i = 0; i < needle_len; i++ ) {\n                        gunichar a = \n\t\t\t\tg_utf8_get_char_validated( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes - haystack );\n                        gunichar b = \n\t\t\t\tg_utf8_get_char_validated( needle_char, -1 );\n                        if( a == (gunichar) -1 ||\n\t\t\t\ta == (gunichar) -2 ||\n\t\t\t\tb == (gunichar) -1 ||\n\t\t\t\tb == (gunichar) -2 )\n                                return( NULL );\n                        if( a == (gunichar) 0 )\n                                return( NULL );\n                        if( g_unichar_tolower( a ) != g_unichar_tolower( b ) )\n                                break;\n                        haystack_char = \n\t\t\t\tg_utf8_find_next_char( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes );\n                        needle_char = \n\t\t\t\tg_utf8_find_next_char( needle_char, NULL );\n                }\n                if( i == needle_len )\n                        return( haystack );\n        }\n        return( NULL );\n}", "target": 1}
{"code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint           i, j, ret;\n\tunsigned char count;\n\tif (flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\tif ( (scd->curbit + code_size) >= scd->lastbit) {\n\t\tif (scd->done) {\n\t\t\tif (scd->curbit >= scd->lastbit) {\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tscd->buf[0] = scd->buf[scd->last_byte-2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte-1];\n               if ((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0)\n\t\t\tscd->done = TRUE;\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2+count)*8 ;\n\t}\n\tif ((scd->curbit + code_size - 1) >= (CSD_BUF_SIZE * 8)) {\n\t\tret = -1;\n\t} else {\n\t\tret = 0;\n\t\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n\t\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t\t}\n\t}\n\tscd->curbit += code_size;\n\treturn ret;\n}", "target": 1}
{"code": " int prepare_binprm(struct linux_binprm *bprm)\n {\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n \tint retval;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n \tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}", "target": 1}
{"code": "PHP_FUNCTION(snmp_set_valueretrieval)\n{\n\tzend_long method;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &method) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (method >= 0 && method <= (SNMP_VALUE_LIBRARY|SNMP_VALUE_PLAIN|SNMP_VALUE_OBJECT)) {\n\t\t\tSNMP_G(valueretrieval) = method;\n\t\t\tRETURN_TRUE;\n\t} else {\n\t\tphp_error_docref(NULL, E_WARNING, \"Unknown SNMP value retrieval method '%pd'\", method);\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0}
{"code": "void encode(ArgumentEncoder* encoder, CFArrayRef array)\n{\n    CFIndex size = CFArrayGetCount(array);\n    Vector<CFTypeRef, 32> values(size);\n    CFArrayGetValues(array, CFRangeMake(0, size), values.data());\n    encoder->encodeUInt64(size);\n    for (CFIndex i = 0; i < size; ++i) {\n        ASSERT(values[i]);\n        encode(encoder, values[i]);\n    }\n}", "target": 0}
{"code": "reset_in_progress(const struct intel_engine_execlists *execlists)\n{\n\treturn unlikely(!__tasklet_is_enabled(&execlists->tasklet));\n}", "target": 0}
{"code": "onig_node_str_cat(Node* node, const UChar* s, const UChar* end)\n{\n  ptrdiff_t addlen = end - s;\n  if (addlen > 0) {\n    ptrdiff_t len  = NSTR(node)->end - NSTR(node)->s;\n    if (NSTR(node)->capa > 0 || (len + addlen > NODE_STR_BUF_SIZE - 1)) {\n      UChar* p;\n      ptrdiff_t capa = len + addlen + NODE_STR_MARGIN;\n      if (capa <= NSTR(node)->capa) {\n\tonig_strcpy(NSTR(node)->s + len, s, end);\n      }\n      else {\n\tif (NSTR(node)->s == NSTR(node)->buf)\n\t  p = strcat_capa_from_static(NSTR(node)->s, NSTR(node)->end,\n\t\t\t\t      s, end, capa);\n\telse\n\t  p = strcat_capa(NSTR(node)->s, NSTR(node)->end, s, end, capa);\n\tCHECK_NULL_RETURN_MEMERR(p);\n\tNSTR(node)->s    = p;\n\tNSTR(node)->capa = (int )capa;\n      }\n    }\n    else {\n      onig_strcpy(NSTR(node)->s + len, s, end);\n    }\n    NSTR(node)->end = NSTR(node)->s + len + addlen;\n  }\n  return 0;\n}", "target": 0}
{"code": "mm_answer_pam_start(int socket, Buffer *m)\n{\n\tchar *user;\n\tuser = buffer_get_string(m, NULL);\n\tstart_pam(user);\n\txfree(user);\n\treturn (0);\n}", "target": 0}
{"code": "con_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) return -ENOMEM;\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); \n\t}\n\tp2[unicode & 0x3f] = fontpos;\n\tp->sum += (fontpos << 20) + unicode;\n\treturn 0;\n}", "target": 1}
{"code": "PHP_FUNCTION(urldecode)\n{\n\tchar *in_str, *out_str;\n\tint in_str_len, out_str_len;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &in_str,\n\t\t\t\t\t\t\t  &in_str_len) == FAILURE) {\n\t\treturn;\n\t}\n\tout_str = estrndup(in_str, in_str_len);\n\tout_str_len = php_url_decode(out_str, in_str_len);\n    RETURN_STRINGL(out_str, out_str_len, 0);\n}", "target": 0}
{"code": "static const char *req_handler_field(request_rec *r)\n{\n    return r->handler;\n}", "target": 0}
{"code": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n       {\n         offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n         w = DIV2(w);\n         h = DIV2(h);\n       }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "parse_field(netdissect_options *ndo, const char **pptr, int *len)\n{\n    const char *s;\n    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    s = *pptr;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n\t(*pptr)++;\n\t(*len)--;\n    }\n    (*pptr)++;\n    (*len)--;\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    return s;\n}", "target": 1}
{"code": "void RenderView::printPage(WebFrame* frame) {\n  DCHECK(frame);\n  Print(frame, true);\n}", "target": 0}
{"code": "ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\terror = 0;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}", "target": 1}
{"code": "static inline item* limited_get(char *key, size_t nkey, conn *c) {\n    item *it = item_get(key, nkey, c, DO_UPDATE);\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        item_remove(it);\n        it = NULL;\n    }\n    return it;\n}", "target": 0}
{"code": "ModuleExport void UnregisterJP2Image(void)\n{\n  (void) UnregisterMagickInfo(\"JPC\");\n  (void) UnregisterMagickInfo(\"JPT\");\n  (void) UnregisterMagickInfo(\"JPM\");\n  (void) UnregisterMagickInfo(\"JP2\");\n  (void) UnregisterMagickInfo(\"J2K\");\n}", "target": 0}
{"code": "GF_Err mvcg_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tptr->size += 7;\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tptr->size += 1 + 6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tptr->size += 1 + 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)\n{\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct *odn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\tfl_owner_t id = current->files;\n\tint error = 0;\n\tif ((arg & ~DN_MULTISHOT) == 0) {\n\t\tdnotify_flush(filp, id);\n\t\treturn 0;\n\t}\n\tif (!dir_notify_enable)\n\t\treturn -EINVAL;\n\tinode = filp->f_path.dentry->d_inode;\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn -ENOTDIR;\n\tdn = kmem_cache_alloc(dn_cache, GFP_KERNEL);\n\tif (dn == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&inode->i_lock);\n\tprev = &inode->i_dnotify;\n\twhile ((odn = *prev) != NULL) {\n\t\tif ((odn->dn_owner == id) && (odn->dn_filp == filp)) {\n\t\t\todn->dn_fd = fd;\n\t\t\todn->dn_mask |= arg;\n\t\t\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tprev = &odn->dn_next;\n\t}\n\terror = __f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\n\tif (error)\n\t\tgoto out_free;\n\tdn->dn_mask = arg;\n\tdn->dn_fd = fd;\n\tdn->dn_filp = filp;\n\tdn->dn_owner = id;\n\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\tdn->dn_next = inode->i_dnotify;\n\tinode->i_dnotify = dn;\n\tspin_unlock(&inode->i_lock);\n\tif (filp->f_op && filp->f_op->dir_notify)\n\t\treturn filp->f_op->dir_notify(filp, arg);\n\treturn 0;\nout_free:\n\tspin_unlock(&inode->i_lock);\n\tkmem_cache_free(dn_cache, dn);\n\treturn error;\n}", "target": 1}
{"code": "set_cs_start(char *line)\n{\n  char *p, *q, *r;\n  if ((p = strstr(line, \"string currentfile\"))) {\n    if (!strstr(line, \"readstring\"))\n      return;\n    *p = '\\0';\t\t\t\t\t  \n    q = strrchr(line, '/');\n    if (q) {\n      r = cs_start;\n      ++q;\n      while (!isspace(*q) && *q != '{')\n\t*r++ = *q++;\n      *r = '\\0';\n    }\n    *p = 's';\t\t\t\t\t  \n  }\n}", "target": 1}
{"code": "completion_glob_pattern (string)\n     char *string;\n{\n  register int c;\n  char *send;\n  int open;\n  DECLARE_MBSTATE;\n  open = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string++ == 0)\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return (0);\n}", "target": 1}
{"code": "void RootWindow::OnCompositingStarted(ui::Compositor*) {\n}", "target": 0}
{"code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n \tif (preloaded)\n \t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n \t\treturn PTR_ERR(blkg);\n\t}\n \tq->root_blkg = blkg;\n \tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "Item *Item_null::safe_charset_converter(CHARSET_INFO *tocs)\n{\n  collation.set(tocs);\n  return this;\n}", "target": 0}
{"code": "static inline v8::Local<v8::Context> contextForWorld(ScriptController* scriptController, DOMWrapperWorld* world)\n{\n    return scriptController->windowShell(world)->context();\n}", "target": 0}
{"code": "ChooserContextBase::GetGrantedObjects(const GURL& requesting_origin,\n                                      const GURL& embedding_origin) {\n  DCHECK_EQ(requesting_origin, requesting_origin.GetOrigin());\n  DCHECK_EQ(embedding_origin, embedding_origin.GetOrigin());\n  if (!CanRequestObjectPermission(requesting_origin, embedding_origin))\n     return {};\n   std::vector<std::unique_ptr<Object>> results;\n  auto* info = new content_settings::SettingInfo();\n   std::unique_ptr<base::DictionaryValue> setting =\n      GetWebsiteSetting(requesting_origin, embedding_origin, info);\n   std::unique_ptr<base::Value> objects;\n   if (!setting->Remove(kObjectListKey, &objects))\n     return results;\n  std::unique_ptr<base::ListValue> object_list =\n      base::ListValue::From(std::move(objects));\n  if (!object_list)\n    return results;\n  for (auto& object : *object_list) {\n     base::DictionaryValue* object_dict;\n     if (object.GetAsDictionary(&object_dict) && IsValidObject(*object_dict)) {\n       results.push_back(std::make_unique<Object>(\n          requesting_origin, embedding_origin, object_dict, info->source,\n           host_content_settings_map_->is_incognito()));\n     }\n   }\n  return results;\n}", "target": 1}
{"code": "InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser& parser, TRAPS) {\n  const int size = InstanceKlass::size(parser.vtable_size(),\n                                       parser.itable_size(),\n                                       nonstatic_oop_map_size(parser.total_oop_map_count()),\n                                       parser.is_interface());\n  const Symbol* const class_name = parser.class_name();\n  assert(class_name != NULL, \"invariant\");\n  ClassLoaderData* loader_data = parser.loader_data();\n  assert(loader_data != NULL, \"invariant\");\n  InstanceKlass* ik;\n  if (REF_NONE == parser.reference_type()) {\n    if (class_name == vmSymbols::java_lang_Class()) {\n      ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);\n    }\n    else if (is_class_loader(class_name, parser)) {\n      ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);\n    } else {\n      ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_kind_other);\n    }\n  } else {\n    ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);\n  }\n  if (HAS_PENDING_EXCEPTION) {\n    return NULL;\n  }\n  return ik;\n}", "target": 0}
{"code": "static int rndis_set_response(USBNetState *s,\n                rndis_set_msg_type *buf, unsigned int length)\n{\n    rndis_set_cmplt_type *resp =\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n    uint32_t bufoffs, buflen;\n    int ret;\n    if (!resp)\n        return USB_RET_STALL;\n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (bufoffs + buflen > length)\n         return USB_RET_STALL;\n     ret = ndis_set(s, le32_to_cpu(buf->OID),\n                     bufoffs + (uint8_t *) buf, buflen);\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n    if (ret < 0) {\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        return 0;\n    }\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n    return 0;\n}", "target": 1}
{"code": "void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n    LanDeviceLink* deviceLink;\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}", "target": 1}
{"code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    fclose(fp);\n    fp=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        fclose(fp);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}", "target": 1}
{"code": "cmsToneCurve* CMSEXPORT cmsDupToneCurve(const cmsToneCurve* In)\n{\n    if (In == NULL) return NULL;\n    return  AllocateToneCurveStruct(In ->InterpParams ->ContextID, In ->nEntries, In ->nSegments, In ->Segments, In ->Table16);\n}", "target": 0}
{"code": "void WasmBinaryBuilder::verifyInt64(int64_t x) {\n  int64_t y = getInt64();\n  if (x != y) {\n    throwError(\"surprising value\");\n  }\n}", "target": 0}
{"code": "void HeaderString::setReference(absl::string_view ref_value) {\n  buffer_ = ref_value;\n  ASSERT(valid());\n}", "target": 0}
{"code": "postmatch_getter(void)\n{\n    return rb_reg_match_post(rb_backref_get());\n}", "target": 0}
{"code": "static int adpt_close(struct inode *inode, struct file *file)\n{\n\tint minor;\n\tadpt_hba* pHba;\n\tminor = iminor(inode);\n\tif (minor >= hba_count) {\n\t\treturn -ENXIO;\n\t}\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->unit == minor) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tmutex_unlock(&adpt_configuration_lock);\n\tif (pHba == NULL) {\n\t\treturn -ENXIO;\n\t}\n\tpHba->in_use = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static ImageLoader::BypassMainWorldBehavior shouldBypassMainWorldCSP(\n    ImageLoader* loader) {\n  DCHECK(loader);\n  DCHECK(loader->element());\n  if (loader->element()->document().frame() &&\n      loader->element()\n          ->document()\n          .frame()\n          ->script()\n          .shouldBypassMainWorldCSP())\n    return ImageLoader::BypassMainWorldCSP;\n  return ImageLoader::DoNotBypassMainWorldCSP;\n}", "target": 0}
{"code": "static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        if (size <= head_size + 4)\n            return AVERROR_INVALIDDATA;\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n    return 0;\n}", "target": 1}
{"code": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n \t\t\tbreak;\n \t\tcase 2:\n \t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n \t\t\tcurrent_bit_offset = 0;\n \t\t\tbreak;\n \t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}", "target": 1}
{"code": "const SSL_CIPHER *dtls1_get_cipher(unsigned int u)\n{\n    const SSL_CIPHER *ciph = ssl3_get_cipher(u);\n    if (ciph != NULL) {\n        if (ciph->algorithm_enc == SSL_RC4)\n            return NULL;\n    }\n    return ciph;\n}", "target": 0}
{"code": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "static int cmd_noop(struct imap_client *client,\n\t\t    const struct imap_arg *args ATTR_UNUSED)\n{\n\tclient_send_reply(&client->common, IMAP_CMD_REPLY_OK,\n\t\t\t  \"NOOP completed.\");\n\treturn 1;\n}", "target": 0}
{"code": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, PAGE_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = join_session_keyring(name);\n error:\n\treturn ret;\n} ", "target": 1}
{"code": "int dccp_disconnect(struct sock *sk, int flags)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint err = 0;\n\tconst int old_state = sk->sk_state;\n\tif (old_state != DCCP_CLOSED)\n\t\tdccp_set_state(sk, DCCP_CLOSED);\n\tif (old_state == DCCP_LISTEN) {\n\t\tinet_csk_listen_stop(sk);\n\t} else if (dccp_need_reset(old_state)) {\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\n\t\tsk->sk_err = ECONNRESET;\n\t} else if (old_state == DCCP_REQUESTING)\n\t\tsk->sk_err = ECONNRESET;\n\tdccp_clear_xmit_timers(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tif (sk->sk_send_head != NULL) {\n\t\t__kfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\tinet->inet_dport = 0;\n\tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\n\t\tinet_reset_saddr(sk);\n\tsk->sk_shutdown = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\ticsk->icsk_backoff = 0;\n\tinet_csk_delack_init(sk);\n\t__sk_dst_reset(sk);\n\tWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);\n\tsk->sk_error_report(sk);\n\treturn err;\n}", "target": 1}
{"code": "my_decimal *Item_string::val_decimal(my_decimal *decimal_value)\n{\n  return val_decimal_from_string(decimal_value);\n}", "target": 0}
{"code": "TEST(QuantizedUInt8PoolingOpTest, MaxPoolActivationRelu1) {\n  QuantizedPoolingOpModel m(\n      BuiltinOperator_MAX_POOL_2D,\n      {TensorType_UINT8, {1, 2, 4, 1}, -15.9375, 15.9375},\n      2, 2,\n      {TensorType_UINT8, {}, -15.9375, 15.9375}, Padding_VALID, 2, 2,\n      ActivationFunctionType_RELU_N1_TO_1);\n  m.SetInput({\n      -1.7, -6, 2, 4,  \n      -3, -2, -10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({-1.0, 1.0})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({120, 136}));\n  m.SetInput({\n      0, -6, -0.2, -0.4,    \n      -3, -2, 0.75, -0.99,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({0.0, 0.75})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({128, 134}));\n}", "target": 0}
{"code": "skip_string(char_u *p)\n{\n    int\t    i;\n    for ( ; ; ++p)\n    {\n\tif (p[0] == '\\'')\t\t    \n\t{\n\t    if (p[1] == NUL)\t\t    \n\t\tbreak;\n\t    i = 2;\n\t    if (p[1] == '\\\\' && p[2] != NUL)    \n\t    {\n\t\t++i;\n\t\twhile (vim_isdigit(p[i - 1]))   \n\t\t    ++i;\n\t    }\n\t    if (p[i] == '\\'')\t\t    \n\t    {\n\t\tp += i;\n\t\tcontinue;\n\t    }\n\t}\n\telse if (p[0] == '\"')\t\t    \n\t{\n\t    for (++p; p[0]; ++p)\n\t    {\n\t\tif (p[0] == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t\telse if (p[0] == '\"')\t    \n\t\t    break;\n\t    }\n\t    if (p[0] == '\"')\n\t\tcontinue; \n\t}\n\telse if (p[0] == 'R' && p[1] == '\"')\n\t{\n\t    char_u *delim = p + 2;\n\t    char_u *paren = vim_strchr(delim, '(');\n\t    if (paren != NULL)\n\t    {\n\t\tsize_t delim_len = paren - delim;\n\t\tfor (p += 3; *p; ++p)\n\t\t    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0\n\t\t\t    && p[delim_len + 1] == '\"')\n\t\t    {\n\t\t\tp += delim_len + 1;\n\t\t\tbreak;\n\t\t    }\n\t\tif (p[0] == '\"')\n\t\t    continue; \n\t    }\n\t}\n\tbreak;\t\t\t\t    \n    }\n    if (!*p)\n\t--p;\t\t\t\t    \n    return p;\n}", "target": 1}
{"code": "static void move_msr_up(struct vcpu_vmx *vmx, int from, int to)\n{\n\tstruct shared_msr_entry tmp;\n\ttmp = vmx->guest_msrs[to];\n\tvmx->guest_msrs[to] = vmx->guest_msrs[from];\n\tvmx->guest_msrs[from] = tmp;\n}", "target": 0}
{"code": "extract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n    gboolean result = FALSE;\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n\t\t\tgoto out;\n        }\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}", "target": 1}
{"code": "inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                       const RuntimeShape& shape2, int index2) {\n  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n  return shape1.Dims(index1);\n}", "target": 1}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                  XML_ACCOUNT_DIRECT);\n}", "target": 0}
{"code": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "linux_md_remove_component_device_not_seen_cb (gpointer user_data)\n{\n  RemoveComponentData *data = user_data;\n  throw_error (data->context,\n               ERROR_FAILED,\n               \"Error removing component: timeout (10s) waiting for slave to stop being busy\");\n  g_signal_handler_disconnect (data->slave->priv->daemon, data->device_changed_signal_handler_id);\n  remove_component_data_unref (data);\n  return FALSE;\n}", "target": 0}
{"code": "static void logi_dj_recv_queue_notification(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t   struct dj_report *dj_report)\n{\n\tkfifo_in(&djrcv_dev->notif_fifo, dj_report, sizeof(struct dj_report));\n\tif (schedule_work(&djrcv_dev->work) == 0) {\n\t\tdbg_hid(\"%s: did not schedule the work item, was already \"\n\t\t\t\"queued\\n\", __func__);\n\t}\n}", "target": 0}
{"code": "x11_open_helper(Buffer *b)\n{\n\tu_char *ucp;\n\tu_int proto_len, data_len;\n \tu_char *ucp;\n \tu_int proto_len, data_len;\n \tif (buffer_len(b) < 12)\n \t\treturn 0;\n\t\tdebug2(\"Initial X11 packet contains bad byte order byte: 0x%x\",\n\t\t    ucp[0]);\n\t\treturn -1;\n\t}", "target": 1}
{"code": "void kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}", "target": 0}
{"code": "onig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n  r = names_clear(reg);\n  if (r != 0) return r;\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) xfree(t);\n  reg->name_table = NULL;\n  return 0;\n}", "target": 0}
{"code": "callbacks_show_selection_on_invisible (GtkMenuItem *menuitem, gpointer user_data)\n{\n\tmainProject->show_invisible_selection = GTK_CHECK_MENU_ITEM(menuitem)->active;\n\trender_refresh_rendered_image_on_screen();\n}", "target": 0}
{"code": "    void RafImage::setIptcData(const IptcData& )\n    {\n        throw(Error(kerInvalidSettingForImage, \"IPTC metadata\", \"RAF\"));\n    }", "target": 0}
{"code": "void context__cleanup(struct mosquitto *context, bool force_free)\n{\n\tstruct mosquitto__packet *packet;\n\tif(!context) return;\n\tif(force_free){\n\t\tcontext->clean_start = true;\n\t}\n#ifdef WITH_BRIDGE\n\tif(context->bridge){\n\t\tbridge__cleanup(context);\n\t}\n#endif\n\talias__free_all(context);\n\tmosquitto__free(context->auth_method);\n\tcontext->auth_method = NULL;\n\tmosquitto__free(context->username);\n\tcontext->username = NULL;\n\tmosquitto__free(context->password);\n\tcontext->password = NULL;\n\tnet__socket_close(context);\n\tif(force_free){\n\t\tsub__clean_session(context);\n\t}\n\tdb__messages_delete(context, force_free);\n\tmosquitto__free(context->address);\n\tcontext->address = NULL;\n\tcontext__send_will(context);\n\tif(context->id){\n\t\tcontext__remove_from_by_id(context);\n\t\tmosquitto__free(context->id);\n\t\tcontext->id = NULL;\n\t}\n\tpacket__cleanup(&(context->in_packet));\n\tif(context->current_out_packet){\n\t\tpacket__cleanup(context->current_out_packet);\n\t\tmosquitto__free(context->current_out_packet);\n\t\tcontext->current_out_packet = NULL;\n\t}\n\twhile(context->out_packet){\n\t\tpacket__cleanup(context->out_packet);\n\t\tpacket = context->out_packet;\n\t\tcontext->out_packet = context->out_packet->next;\n\t\tmosquitto__free(packet);\n\t}\n\tcontext->out_packet_count = 0;\n#if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)\n\tif(context->adns){\n\t\tgai_cancel(context->adns);\n\t\tmosquitto__free((struct addrinfo *)context->adns->ar_request);\n\t\tmosquitto__free(context->adns);\n\t}\n#endif\n\tif(force_free){\n\t\tmosquitto__free(context);\n\t}\n}", "target": 1}
{"code": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\treturn ptr;\n}", "target": 1}
{"code": "bool ReadListValue(const Message* m, PickleIterator* iter,\n                   ListValue* value, int recursion) {\n  int size;\n  if (!ReadParam(m, iter, &size))\n    return false;\n  for (int i = 0; i < size; ++i) {\n    Value* subval;\n    if (!ReadValue(m, iter, &subval, recursion + 1))\n      return false;\n    value->Set(i, subval);\n  }\n  return true;\n}", "target": 0}
{"code": "static void test_prepare_insert_update()\n{\n  MYSQL_STMT *stmt;\n  int        rc;\n  int        i;\n  const char *testcase[]= {\n    \"CREATE TABLE t1 (a INT, b INT, c INT, UNIQUE (A), UNIQUE(B))\",\n    \"INSERT t1 VALUES (1,2,10), (3,4,20)\",\n    \"INSERT t1 VALUES (5,6,30), (7,4,40), (8,9,60) ON DUPLICATE KEY UPDATE c=c+100\",\n    \"SELECT * FROM t1\",\n    \"INSERT t1 SET a=5 ON DUPLICATE KEY UPDATE b=0\",\n    \"SELECT * FROM t1\",\n    \"INSERT t1 VALUES (2,1,11), (7,4,40) ON DUPLICATE KEY UPDATE c=c+VALUES(a)\",\n    NULL};\n  const char **cur_query;\n  myheader(\"test_prepare_insert_update\");\n  for (cur_query= testcase; *cur_query; cur_query++)\n  {\n    char query[MAX_TEST_QUERY_LENGTH];\n    printf(\"\\nRunning query: %s\", *cur_query);\n    strmov(query, *cur_query);\n    stmt= mysql_simple_prepare(mysql, query);\n    check_stmt(stmt);\n    verify_param_count(stmt, 0);\n    rc= mysql_stmt_execute(stmt);\n    check_execute(stmt, rc);\n    if (!cur_query[1])\n    {\n      for (i=0; i < 3;i++)\n      {\n        printf(\"\\nExecuting last statement again\");\n        rc= mysql_stmt_execute(stmt);\n        check_execute(stmt, rc);\n        rc= mysql_stmt_execute(stmt);\n        check_execute(stmt, rc);\n      }\n    }\n    mysql_stmt_close(stmt);\n  }\n  rc= mysql_commit(mysql);\n  myquery(rc);\n}", "target": 0}
{"code": "static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpf_init_units();\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "ddxGiveUp(enum ExitCode error)\n{\n    int i;\n    xf86VGAarbiterFini();\n#ifdef XF86PM\n    if (xf86OSPMClose)\n        xf86OSPMClose();\n    xf86OSPMClose = NULL;\n#endif\n    for (i = 0; i < xf86NumScreens; i++) {\n        xf86Screens[i]->vtSema = FALSE;\n    }\n#ifdef XFreeXDGA\n    DGAShutdown();\n#endif\n    if (xorgHWOpenConsole)\n        xf86CloseConsole();\n    systemd_logind_fini();\n    dbus_core_fini();\n    xf86CloseLog(error);\n    if (xf86Info.caughtSignal)\n        OsAbort();\n}", "target": 0}
{"code": "static const char *set_signature_flag(cmd_parms *cmd, void *d_,\n                                      const char *arg)\n{\n    core_dir_config *d = d_;\n    if (ap_cstr_casecmp(arg, \"On\") == 0) {\n        d->server_signature = srv_sig_on;\n    }\n    else if (ap_cstr_casecmp(arg, \"Off\") == 0) {\n        d->server_signature = srv_sig_off;\n    }\n    else if (ap_cstr_casecmp(arg, \"EMail\") == 0) {\n        d->server_signature = srv_sig_withmail;\n    }\n    else {\n        return \"ServerSignature: use one of: off | on | email\";\n    }\n    return NULL;\n}", "target": 0}
{"code": "static inline void __skb_queue_head_init(struct sk_buff_head *list)\n{\n\tlist->prev = list->next = (struct sk_buff *)list;\n\tlist->qlen = 0;\n}", "target": 0}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "    void Image::setIptcData(const IptcData& iptcData)\n    {\n        iptcData_ = iptcData;\n    }", "target": 0}
{"code": "dirvote_clear_pending_consensuses(void)\n{\n  int i;\n  for (i = 0; i < N_CONSENSUS_FLAVORS; ++i) {\n    pending_consensus_t *pc = &pending_consensuses[i];\n    tor_free(pc->body);\n    networkstatus_vote_free(pc->consensus);\n    pc->consensus = NULL;\n  }\n}", "target": 0}
{"code": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n {\n \tstruct sk_buff *skb;\n \tint err;\n \tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n \t\tskb = sock_alloc_send_skb(sk,\n \t\t\thh_len + fragheaderlen + transhdrlen + 20,\n \t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n \t\tskb->transport_header = skb->network_header + fragheaderlen;\n \t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n \t\tskb->csum = 0;\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n \t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n \t}\n \treturn skb_append_datato_frags(sk, skb, getfrag, from,\n \t\t\t\t       (length - transhdrlen));\n }", "target": 1}
{"code": "    TiffComponent* TiffComponent::addChild(TiffComponent::UniquePtr tiffComponent)\n    {\n        return doAddChild(std::move(tiffComponent));\n    } ", "target": 0}
{"code": "horizontalDifference16(unsigned short *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From14)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef   CLAMP\n#define  CLAMP(v) From14[(v) >> 2]\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n\t    ip += n - 1;\t\n\t    wp += n - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "target": 1}
{"code": "static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n {\n   MagickBooleanType\n     status;\n  int\n    bit;\n  register const PixelPacket\n    *p;\n  register ssize_t\n    x;\n  ssize_t\n    y;\n  unsigned char\n    byte;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n   assert(image->signature == MagickSignature);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     return(status);\n   (void) TransformImageColorspace(image,sRGBColorspace);\n  if((image->columns > 255L) || (image->rows > 255L))\n    ThrowWriterException(ImageError,\"Dimensions must be less than 255x255\");\n  (void) WriteBlobByte(image,image->columns & 0xff);\n  (void) WriteBlobByte(image,image->rows & 0xff);\n  (void) SetImageType(image,BilevelType);\n  x=0;\n   y=0;\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n     if (p == (const PixelPacket *) NULL)\n       break;\n     bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      byte>>=1;\n      if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n        byte|=0x80;\n      bit++;\n      if (bit == 8)\n        {\n       \t  (void) WriteBlobByte(image,byte);\n          bit=0;\n          byte=0;\n        }\n      p++;\n    }\n    if (bit != 0)\n      (void) WriteBlobByte(image,byte);\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "target": 1}
{"code": "guardfraction_line_apply(const char *guard_id,\n                      uint32_t guardfraction_percentage,\n                      smartlist_t *vote_routerstatuses)\n{\n  vote_routerstatus_t *vrs = NULL;\n  tor_assert(vote_routerstatuses);\n  vrs = smartlist_bsearch(vote_routerstatuses, guard_id,\n                         compare_digest_to_vote_routerstatus_entry);\n  if (!vrs) {\n    return 0;\n  }\n  vrs->status.has_guardfraction = 1;\n  vrs->status.guardfraction_percentage = guardfraction_percentage;\n  return 1;\n}", "target": 0}
{"code": "fbCombineOutU (CARD32 *dest, const CARD32 *src, int width)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32 s = READ(src + i);\n        CARD32 a = Alpha(~READ(dest + i));\n        FbByteMul(s, a);\n        WRITE(dest + i, s);\n    }\n}", "target": 0}
{"code": "void HTMLMediaElement::MediaSourceOpened(WebMediaSource* web_media_source) {\n  SetShouldDelayLoadEvent(false);\n  media_source_->SetWebMediaSourceAndOpen(base::WrapUnique(web_media_source));\n}", "target": 0}
{"code": "bool ShouldTabShowFavicon(int capacity,\n                          bool is_pinned_tab,\n                          bool is_active_tab,\n                          bool has_favicon,\n                          TabAlertState alert_state) {\n  if (!has_favicon)\n    return false;\n  int required_capacity = 1;\n  if (ShouldTabShowCloseButton(capacity, is_pinned_tab, is_active_tab))\n    ++required_capacity;\n  if (ShouldTabShowAlertIndicator(capacity, is_pinned_tab, is_active_tab,\n                                  has_favicon, alert_state)) {\n    ++required_capacity;\n  }\n  return capacity >= required_capacity;\n}", "target": 0}
{"code": "void WebContentsImpl::SetFocusToLocationBar(bool select_all) {\n  if (delegate_)\n    delegate_->SetFocusToLocationBar(select_all);\n}", "target": 0}
{"code": "check_acl(pam_handle_t *pamh,\n\t  const char *sense, const char *this_user, const char *other_user,\n\t  int noent_code, int debug)\n{\n\tchar path[PATH_MAX];\n\tstruct passwd *pwd;\n {\n        char path[PATH_MAX];\n        struct passwd *pwd;\n       FILE *fp;\n       int i, save_errno;\n        uid_t fsuid;\n        pwd = pam_modutil_getpwnam(pamh, this_user);\n        if (pwd == NULL) {\n\t}\n\ti = snprintf(path, sizeof(path), \"%s/.xauth/%s\", pwd->pw_dir, sense);\n\tif ((i >= (int)sizeof(path)) || (i < 0)) {\n\t\tpam_syslog(pamh, LOG_ERR,\n\t\t\t   \"name of user's home directory is too long\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\tfsuid = setfsuid(pwd->pw_uid);\n\tfp = fopen(path, \"r\");\n                return PAM_SESSION_ERR;\n        }\n        fsuid = setfsuid(pwd->pw_uid);\n       fp = fopen(path, \"r\");\n        save_errno = errno;\n        setfsuid(fsuid);\n       if (fp != NULL) {\n                char buf[LINE_MAX], *tmp;\n                while (fgets(buf, sizeof(buf), fp) != NULL) {\n\t\t\t\t   other_user, path);\n\t\t}\n\t\tfclose(fp);\n\t\treturn PAM_PERM_DENIED;\n\t} else {\n\t        errno = save_errno;\n\t\tswitch (errno) {\n\t\tcase ENOENT:\n\t\t\tif (noent_code == PAM_SUCCESS) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, ignoring\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (debug) {\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t\t   \"%s does not exist, failing\",\n\t\t\t\t\t\t   path);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn noent_code;\n\t\tdefault:\n\t\t\tif (debug) {\n\t\t\t\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\t\t   \"error opening %s: %m\", path);\n\t\t\t}\n\t\t\treturn PAM_PERM_DENIED;\n\t\t}\n\t}\n}", "target": 1}
{"code": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n \tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n \tpx->ft->data = px;\n \tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\treturn FALSE;\n}", "target": 1}
{"code": "static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}", "target": 1}
{"code": "sds *ldbReplParseCommand(int *argcp) {\n    sds *argv = NULL;\n    int argc = 0;\n    if (sdslen(ldb.cbuf) == 0) return NULL;\n    sds copy = sdsdup(ldb.cbuf);\n    char *p = copy;\n    p = strchr(p,'*'); if (!p) goto protoerr;\n    char *plen = p+1; \n    p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n    *p = '\\0'; p += 2;\n    *argcp = atoi(plen);\n    if (*argcp <= 0 || *argcp > 1024) goto protoerr;\n    argv = zmalloc(sizeof(sds)*(*argcp));\n    argc = 0;\n    while(argc < *argcp) {\n        if (*p != '$') goto protoerr;\n        plen = p+1; \n        p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n        *p = '\\0'; p += 2;\n        int slen = atoi(plen); \n        if (slen <= 0 || slen > 1024) goto protoerr;\n        argv[argc++] = sdsnewlen(p,slen);\n        p += slen; \n        if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;\n        p += 2; \n    }\n    sdsfree(copy);\n    return argv;\nprotoerr:\n    sdsfreesplitres(argv,argc);\n    sdsfree(copy);\n    return NULL;\n}", "target": 1}
{"code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n \t\t}\n \t}\n \tif (table->total == table->max) {\n \t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 1}
{"code": "char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,\n uintptr_t abort_msg_address, bool dump_sibling_threads,\n bool* detach_failed, int* total_sleep_time_usec) {\n log_t log;\n   log.current_tid = tid;\n   log.crashed_tid = tid;\n  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {\n    _LOG(&log, logtype::ERROR, \"failed to create %s: %s\\n\", TOMBSTONE_DIR, strerror(errno));\n  }\n  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {\n    _LOG(&log, logtype::ERROR, \"failed to change ownership of %s: %s\\n\", TOMBSTONE_DIR, strerror(errno));\n  }\n   int fd = -1;\n  char* path = NULL;\n  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {\n    path = find_and_open_tombstone(&fd);\n  } else {\n    _LOG(&log, logtype::ERROR, \"Failed to restore security context, not writing tombstone.\\n\");\n  }\n   if (fd < 0) {\n     _LOG(&log, logtype::ERROR, \"Skipping tombstone write, nothing to do.\\n\");\n *detach_failed = false;\n return NULL;\n }\n  log.tfd = fd;\n int amfd = activity_manager_connect();\n  log.amfd = amfd;\n *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,\n                              dump_sibling_threads, total_sleep_time_usec);\n  ALOGI(\"\\nTombstone written to: %s\\n\", path);\n  close(amfd);\n  close(fd);\n return path;\n}", "target": 1}
{"code": "WM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n     if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n         return (NULL);\n     }\n     if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n         ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n     } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n    return (ret);\n}", "target": 1}
{"code": "static unsigned int ipv6_defrag(void *priv,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tconst struct nf_hook_state *state)\n{\n\tint err;\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\n\t\treturn NF_ACCEPT;\n#endif\n\terr = nf_ct_frag6_gather(state->net, skb,\n\t\t\t\t nf_ct6_defrag_user(state->hook, skb));\n \tif (err == -EINPROGRESS)\n \t\treturn NF_STOLEN;\n\treturn NF_ACCEPT;\n }", "target": 1}
{"code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n \t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n \t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\tskcipher->setkey = alg->setkey;\n \tskcipher->encrypt = alg->encrypt;\n \tskcipher->decrypt = alg->decrypt;\n \tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\treturn 0;\n}", "target": 1}
{"code": "    bool load_face(Face & face, unsigned int options)\n    {\n#ifdef GRAPHITE2_TELEMETRY\n        telemetry::category _misc_cat(face.tele.misc);\n#endif\n        Face::Table silf(face, Tag::Silf, 0x00050000);\n        if (silf)   options &= ~gr_face_dumbRendering;\n        else if (!(options &  gr_face_dumbRendering))\n            return false;\n        if (!face.readGlyphs(options))\n            return false;\n        if (silf)\n        {\n            if (!face.readFeatures() || !face.readGraphite(silf))\n            {\n#if !defined GRAPHITE2_NTRACING\n                if (global_log)\n                {\n                    *global_log << json::object\n                        << \"type\" << \"fontload\"\n                        << \"failure\" << face.error()\n                        << \"context\" << face.error_context()\n                    << json::close;\n                }\n#endif\n                return false;\n            }\n            else\n                return true;\n        }\n        else\n            return options & gr_face_dumbRendering;\n    }", "target": 1}
{"code": " static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n\tstrlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrlcpy(ualg->cru_driver_name, alg->cra_driver_name,\n \t\tsizeof(ualg->cru_driver_name));\n\tstrlcpy(ualg->cru_module_name, module_name(alg->cra_module),\n \t\tsizeof(ualg->cru_module_name));\n \tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n\t\tstrlcpy(rl.type, \"larval\", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "options_transports(void)\n{\nstruct transport_info * ti;\nuschar buf[64];\noptions_from_list(optionlist_transports, nelem(optionlist_transports), US\"TRANSPORTS\", NULL);\nfor (ti = transports_available; ti->driver_name[0]; ti++)\n  {\n  spf(buf, sizeof(buf), US\"_DRIVER_TRANSPORT_%T\", ti->driver_name);\n  builtin_macro_create(buf);\n  options_from_list(ti->options, (unsigned)*ti->options_count, US\"TRANSPORT\", ti->driver_name);\n  }\n}", "target": 0}
{"code": "static ssize_t acpi_table_aml_write(struct config_item *cfg,\n\t\t\t\t    const void *data, size_t size)\n{\n\tconst struct acpi_table_header *header = data;\n\tstruct acpi_table *table;\n\tint ret;\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\tif (table->header) {\n\t\tpr_err(\"table already loaded\\n\");\n\t\treturn -EBUSY;\n\t}\n\tif (header->length != size) {\n\t\tpr_err(\"invalid table length\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\n\t\tpr_err(\"invalid table signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\ttable->header = kmemdup(header, header->length, GFP_KERNEL);\n\tif (!table->header)\n\t\treturn -ENOMEM;\n\tret = acpi_load_table(table->header, &table->index);\n\tif (ret) {\n\t\tkfree(table->header);\n\t\ttable->header = NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "_dbus_flush_caches (void)\n{\n}", "target": 0}
{"code": "static int bus_socket_make_message(sd_bus *bus, size_t size) {\n        sd_bus_message *t;\n        void *b;\n        int r;\n        assert(bus);\n        assert(bus->rbuffer_size >= size);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n        if (bus->rbuffer_size > size) {\n                b = memdup((const uint8_t*) bus->rbuffer + size,\n                           bus->rbuffer_size - size);\n                if (!b)\n                        return -ENOMEM;\n        } else\n                b = NULL;\n        r = bus_message_from_malloc(bus,\n                                    bus->rbuffer, size,\n                                    bus->fds, bus->n_fds,\n                                    NULL,\n                                    &t);\n        if (r < 0) {\n                free(b);\n                return r;\n        }\n        bus->rbuffer = b;\n        bus->rbuffer_size -= size;\n        bus->fds = NULL;\n        bus->n_fds = 0;\n        bus->rqueue[bus->rqueue_size++] = t;\n        return 1;\n}", "target": 1}
{"code": "void OmniboxViewWin::HandleKeystroke(UINT message,\n                                     TCHAR key,\n                                     UINT repeat_count,\n                                     UINT flags) {\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  OnBeforePossibleChange();\n  if (key == ui::VKEY_HOME || key == ui::VKEY_END) {\n    HKL layout = GetKeyboardLayout(0);\n    DefWindowProc(message, key, MAKELPARAM(repeat_count, flags));\n    ActivateKeyboardLayout(layout, KLF_REORDER);\n  } else {\n    DefWindowProc(message, key, MAKELPARAM(repeat_count, flags));\n  }\n  const int lang_options = SendMessage(EM_GETLANGOPTIONS, 0, 0);\n  if (lang_options & IMF_AUTOKEYBOARD)\n    SendMessage(EM_SETLANGOPTIONS, 0, lang_options & ~IMF_AUTOKEYBOARD);\n  OnAfterPossibleChange();\n}", "target": 0}
{"code": "static int spl_ptr_heap_zval_max_cmp(spl_ptr_heap_element a, spl_ptr_heap_element b, void* object TSRMLS_DC) { \n\tzval result;\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\tif (object) {\n\t\tspl_heap_object *heap_object = (spl_heap_object*)zend_object_store_get_object((zval *)object TSRMLS_CC);\n\t\tif (heap_object->fptr_cmp) {\n\t\t\tlong lval = 0;\n\t\t\tif (spl_ptr_heap_cmp_cb_helper((zval *)object, heap_object, (zval *)a, (zval *)b, &lval TSRMLS_CC) == FAILURE) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn lval;\n\t\t}\n\t}\n\tINIT_ZVAL(result);\n\tcompare_function(&result, (zval *)a, (zval *)b TSRMLS_CC);\n\treturn Z_LVAL(result);\n}", "target": 0}
{"code": "void html_link_open(char *url, char *title, char *class)\n{\n\thtml(\"<a href='\");\n\thtml_attr(url);\n\tif (title) {\n\t\thtml(\"' title='\");\n\t\thtml_attr(title);\n\t}\n\tif (class) {\n\t\thtml(\"' class='\");\n\t\thtml_attr(class);\n\t}\n\thtml(\"'>\");\n}", "target": 0}
{"code": "static void rtl8139_transfer_frame(RTL8139State *s, uint8_t *buf, int size,\n    int do_interrupt, const uint8_t *dot1q_buf)\n{\n    struct iovec *iov = NULL;\n    struct iovec vlan_iov[3];\n    if (!size)\n    {\n        DPRINTF(\"+++ empty ethernet frame\\n\");\n        return;\n    }\n    if (dot1q_buf && size >= ETH_ALEN * 2) {\n        iov = (struct iovec[3]) {\n            { .iov_base = buf, .iov_len = ETH_ALEN * 2 },\n            { .iov_base = (void *) dot1q_buf, .iov_len = VLAN_HLEN },\n            { .iov_base = buf + ETH_ALEN * 2,\n                .iov_len = size - ETH_ALEN * 2 },\n        };\n        memcpy(vlan_iov, iov, sizeof(vlan_iov));\n        iov = vlan_iov;\n    }\n    if (TxLoopBack == (s->TxConfig & TxLoopBack))\n    {\n        size_t buf2_size;\n        uint8_t *buf2;\n        if (iov) {\n            buf2_size = iov_size(iov, 3);\n            buf2 = g_malloc(buf2_size);\n            iov_to_buf(iov, 3, 0, buf2, buf2_size);\n            buf = buf2;\n        }\n        DPRINTF(\"+++ transmit loopback mode\\n\");\n        rtl8139_do_receive(qemu_get_queue(s->nic), buf, size, do_interrupt);\n        if (iov) {\n            g_free(buf2);\n        }\n    }\n    else\n    {\n        if (iov) {\n            qemu_sendv_packet(qemu_get_queue(s->nic), iov, 3);\n        } else {\n            qemu_send_packet(qemu_get_queue(s->nic), buf, size);\n        }\n    }\n}", "target": 1}
{"code": "GF_Err ohdr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu16 cid_len, ri_len;\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox*)s;\n\tISOM_DECREASE_SIZE(ptr, (1+1+8+2+2+2) );\n\tptr->EncryptionMethod = gf_bs_read_u8(bs);\n\tptr->PaddingScheme = gf_bs_read_u8(bs);\n\tptr->PlaintextLength = gf_bs_read_u64(bs);\n\tcid_len = gf_bs_read_u16(bs);\n\tri_len = gf_bs_read_u16(bs);\n\tptr->TextualHeadersLen = gf_bs_read_u16(bs);\n\tif (ptr->size<cid_len+ri_len+ptr->TextualHeadersLen) return GF_ISOM_INVALID_FILE;\n\tif (cid_len) {\n\t\tptr->ContentID = (char *)gf_malloc(sizeof(char)*(cid_len+1));\n\t\tif (!ptr->ContentID) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->ContentID, cid_len);\n\t\tptr->ContentID[cid_len]=0;\n\t}\n\tif (ri_len) {\n\t\tptr->RightsIssuerURL = (char *)gf_malloc(sizeof(char)*(ri_len+1));\n\t\tif (!ptr->RightsIssuerURL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->RightsIssuerURL, ri_len);\n\t\tptr->RightsIssuerURL[ri_len]=0;\n\t}\n\tif (ptr->TextualHeadersLen) {\n\t\tptr->TextualHeaders = (char *)gf_malloc(sizeof(char)*(ptr->TextualHeadersLen+1));\n\t\tif (!ptr->TextualHeaders) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->TextualHeaders, ptr->TextualHeadersLen);\n\t\tptr->TextualHeaders[ptr->TextualHeadersLen] = 0;\n\t}\n\tISOM_DECREASE_SIZE(ptr, (cid_len+ri_len+ptr->TextualHeadersLen) );\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n    auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }", "target": 1}
{"code": "static int onChdir(rpmfi fi, void *data)\n{\n    struct diriter_s *di = data;\n    if (di->dirfd >= 0) {\n\tclose(di->dirfd);\n\tdi->dirfd = -1;\n    }\n    return 0;\n}", "target": 0}
{"code": " static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                 size_t mincodes, size_t numcodes, unsigned maxbitlen)\n {\n   unsigned error = 0;\n   while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; \n   tree->maxbitlen = maxbitlen;\n   tree->numcodes = (unsigned)numcodes; \n  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n   if(!tree->lengths) return 83; \n   memset(tree->lengths, 0, numcodes * sizeof(unsigned));\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}", "target": 1}
{"code": "njs_typed_array_get_this(njs_vm_t *vm, njs_value_t *args,\n    njs_uint_t nargs, njs_index_t unused)\n{\n    vm->retval = args[0];\n    return NJS_OK;\n}", "target": 0}
{"code": "void stl_phys(AddressSpace *as, hwaddr addr, uint32_t val)\n{\n    address_space_stl(as, addr, val, MEMTXATTRS_UNSPECIFIED, NULL);\n}", "target": 0}
{"code": "njs_chb_write_byte_as_utf8(njs_chb_t *chain, u_char byte)\n{\n    njs_utf8_encode(njs_chb_current(chain), byte);\n    njs_chb_written(chain, njs_utf8_size(byte));\n}", "target": 0}
{"code": " LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n {\n \tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n \tif(!file) return 0;\n \tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n \t}\n\tretval = (int)tmpretval;\n \tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n \t}\n\topenmpt_free_string(str);\n\treturn retval;\n }", "target": 1}
{"code": "v8::Local<v8::Value> SerializedScriptValue::deserialize(MessagePortArray* messagePorts)\n{\n    return deserialize(v8::Isolate::GetCurrent(), messagePorts, 0);\n}", "target": 0}
{"code": "static int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", NT_PRXFPREG, sizeof(t->xfpu),\n\t\t\t  &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}", "target": 0}
{"code": "  void operator()(OpKernelContext* context, const Tensor& input_tensor,\n                  Tensor& output_tensor, int n, bool reverse) {\n    const T* input = input_tensor.flat<T>().data();\n    T* output = output_tensor.flat<T>().data();\n    const int num_rows = output_tensor.NumElements();\n    const int last_dim = input_tensor.dim_size(input_tensor.dims() - 1);\n    auto SubNthElement = [&, input, output, last_dim, n](int start, int limit) {\n      std::vector<T> buf(last_dim);\n      for (int b = start; b < limit; ++b) {\n        const T* input_start = input + b * last_dim;\n        const T* input_end = input + (b + 1) * last_dim;\n        std::copy(input_start, input_end, buf.begin());\n        std::nth_element(buf.begin(), buf.begin() + n, buf.end());\n        output[b] = buf[n];\n      }\n    };\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n    Shard(worker_threads.num_threads, worker_threads.workers, num_rows,\n          20 * last_dim, SubNthElement);\n  }", "target": 1}
{"code": "date_initialize(int argc, VALUE *argv, VALUE self)\n{\n    VALUE vy, vm, vd, vsg, y, fr, fr2, ret;\n    int m, d;\n    double sg;\n    struct SimpleDateData *dat = rb_check_typeddata(self, &d_lite_type);\n    if (!simple_dat_p(dat)) {\n\trb_raise(rb_eTypeError, \"Date expected\");\n    }\n    rb_scan_args(argc, argv, \"04\", &vy, &vm, &vd, &vsg);\n    y = INT2FIX(-4712);\n    m = 1;\n    d = 1;\n    fr2 = INT2FIX(0);\n    sg = DEFAULT_SG;\n    switch (argc) {\n      case 4:\n\tval2sg(vsg, sg);\n      case 3:\n        check_numeric(vd, \"day\");\n\tnum2int_with_frac(d, positive_inf);\n      case 2:\n        check_numeric(vm, \"month\");\n\tm = NUM2INT(vm);\n      case 1:\n        check_numeric(vy, \"year\");\n\ty = vy;\n    }\n    if (guess_style(y, sg) < 0) {\n\tVALUE nth;\n\tint ry, rm, rd;\n\tif (!valid_gregorian_p(y, m, d,\n\t\t\t       &nth, &ry,\n\t\t\t       &rm, &rd))\n\t    rb_raise(eDateError, \"invalid date\");\n\tset_to_simple(self, dat, nth, 0, sg, ry, rm, rd, HAVE_CIVIL);\n    }\n    else {\n\tVALUE nth;\n\tint ry, rm, rd, rjd, ns;\n\tif (!valid_civil_p(y, m, d, sg,\n\t\t\t   &nth, &ry,\n\t\t\t   &rm, &rd, &rjd,\n\t\t\t   &ns))\n\t    rb_raise(eDateError, \"invalid date\");\n\tset_to_simple(self, dat, nth, rjd, sg, ry, rm, rd, HAVE_JD | HAVE_CIVIL);\n    }\n    ret = self;\n    add_frac();\n    return ret;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n \t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\nfreeargb:\n\tgdFree(argb);\n}", "target": 1}
{"code": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\treturn threads;\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1}
{"code": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}", "target": 1}
{"code": "ClearServer2Client(rfbClient* client, int messageType)\n{\n  client->supportedMessages.server2client[((messageType & 0xFF)/8)] &= (!(1<<(messageType % 8)));\n}", "target": 0}
{"code": "Status TensorSliceReader::GetTensor(\n    const string& name, std::unique_ptr<tensorflow::Tensor>* out_tensor) const {\n  DataType type;\n  TensorShape shape;\n  TensorSlice slice;\n  {\n    mutex_lock l(mu_);\n    const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n    if (tss == nullptr) {\n      return errors::NotFound(name, \" not found in checkpoint file\");\n    }\n    if (tss->Slices().size() > 1) {\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));\n  bool success = false;\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n  switch (type) {\n    READER_COPY(DT_FLOAT);\n    READER_COPY(DT_DOUBLE);\n    READER_COPY(DT_INT32);\n    READER_COPY(DT_UINT8);\n    READER_COPY(DT_INT16);\n    READER_COPY(DT_INT8);\n    READER_COPY(DT_INT64);\n    READER_COPY(DT_STRING);\n    default:\n      return errors::Unimplemented(\"Data type not supported\");\n  }\n#undef READER_COPY\n  if (!success) {\n    return errors::NotFound(name, \" not found in checkpoint file\");\n  }\n  std::swap(*out_tensor, t);\n  return Status::OK();\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* data =\n      reinterpret_cast<TfLiteAudioMicrofrontendParams*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 1);\n  TF_LITE_ENSURE_EQ(context, input->type, kTfLiteInt16);\n  output->type = kTfLiteInt32;\n  if (data->out_float) {\n    output->type = kTfLiteFloat32;\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(2);\n  int num_frames = 0;\n  if (input->dims->data[0] >= data->state->window.size) {\n    num_frames = (input->dims->data[0] - data->state->window.size) /\n                     data->state->window.step / data->frame_stride +\n                 1;\n  }\n  output_size->data[0] = num_frames;\n  output_size->data[1] = data->state->filterbank.num_channels *\n                         (1 + data->left_context + data->right_context);\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 1}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "void mvcg_box_del(GF_Box *s)\n{\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}", "target": 0}
{"code": "        ~BlockMap()\n        {\n            if (data_) {\n                std::free(data_);\n                data_ = nullptr;\n            }\n        }", "target": 0}
{"code": "static int adpt_hba_reset(adpt_hba* pHba)\n{\n\tint rcode;\n\tpHba->state |= DPTI_STATE_RESET;\n\tif ((rcode=adpt_i2o_activate_hba(pHba)) < 0) {\n\t\tprintk(KERN_ERR \"%s: Could not activate\\n\", pHba->name);\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tif ((rcode=adpt_i2o_build_sys_table()) < 0) {\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tPDEBUG(\"%s: in HOLD state\\n\",pHba->name);\n\tif ((rcode=adpt_i2o_online_hba(pHba)) < 0) {\n\t\tadpt_i2o_delete_hba(pHba);\t\n\t\treturn rcode;\n\t}\n\tPDEBUG(\"%s: in OPERATIONAL state\\n\",pHba->name);\n\tif ((rcode=adpt_i2o_lct_get(pHba)) < 0){\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tif ((rcode=adpt_i2o_reparse_lct(pHba)) < 0){\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tpHba->state &= ~DPTI_STATE_RESET;\n\tscsi_host_complete_all_commands(pHba->host, DID_RESET);\n\treturn 0;\t\n}", "target": 1}
{"code": "TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,\n                                      TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  *data->invoke_count += 1;\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const uint8_t* input_data = GetTensorData<uint8_t>(input);\n  int size = NumElements(input->dims);\n  uint8_t* sorting_buffer = reinterpret_cast<uint8_t*>(\n      context->GetScratchBuffer(context, data->sorting_buffer));\n  for (int i = 0; i < size; i++) {\n    sorting_buffer[i] = input_data[i];\n  }\n  for (int i = 1; i < size; i++) {\n    for (int j = i; j > 0 && sorting_buffer[j] < sorting_buffer[j - 1]; j--) {\n      std::swap(sorting_buffer[j], sorting_buffer[j - 1]);\n    }\n  }\n  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);\n  uint8_t* median_data = GetTensorData<uint8_t>(median);\n  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);\n  int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);\n  median_data[0] = sorting_buffer[size / 2];\n  invoke_count_data[0] = *data->invoke_count;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\trcu_assign_pointer(*pp, p);\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 row = 0;\n\t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns; s++) {\n\t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n\t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n\t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}", "target": 1}
{"code": "parse_LEARN(char *arg, const struct ofpact_parse_params *pp)\n{\n    return learn_parse(arg, pp->port_map, pp->table_map, pp->ofpacts);\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicyImpl::RegisterPseudoScheme(\n    const std::string& scheme) {\n  base::AutoLock lock(lock_);\n  DCHECK(pseudo_schemes_.count(scheme) == 0) << \"Add schemes at most once.\";\n  DCHECK(web_safe_schemes_.count(scheme) == 0) <<\n      \"Pseudo implies not web-safe.\";\n  pseudo_schemes_.insert(scheme);\n}", "target": 0}
{"code": "KCleanup::selectionChanged( KFileInfo *selection )\n{\n    bool enabled = false;\n    _selection = selection;\n    if ( selection )\n    {\n\tenabled = worksFor( selection );\n\tif ( ! selection->isFinished() )\n\t{\n\t    switch ( _refreshPolicy )\n\t    {\n\t\tcase refreshThis:\n\t\tcase refreshParent:\n\t\tcase assumeDeleted:\n\t\t    enabled = false;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n    }\n    KAction::setEnabled( enabled );\n}", "target": 0}
{"code": "rpl_dao_print(netdissect_options *ndo,\n              const u_char *bp, u_int length)\n{\n        const struct nd_rpl_dao *dao = (const struct nd_rpl_dao *)bp;\n        const char *dagid_str = \"<elided>\";\n        ND_TCHECK(*dao);\n        if (length < ND_RPL_DAO_MIN_LEN)\n        \tgoto tooshort;\n        bp += ND_RPL_DAO_MIN_LEN;\n        length -= ND_RPL_DAO_MIN_LEN;\n        if(RPL_DAO_D(dao->rpl_flags)) {\n                ND_TCHECK2(dao->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, dao->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u%s%s,%02x]\",\n                  dagid_str,\n                  dao->rpl_daoseq,\n                  dao->rpl_instanceid,\n                  RPL_DAO_K(dao->rpl_flags) ? \",acK\":\"\",\n                  RPL_DAO_D(dao->rpl_flags) ? \",Dagid\":\"\",\n                  dao->rpl_flags));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\ntooshort:\n\tND_PRINT((ndo,\" [|length too short]\"));\n\treturn;\n}", "target": 1}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = _mm_xor_si128(D[i], S[i]);\n}", "target": 1}
{"code": "  Builtins* builtins() { return &builtins_; }", "target": 0}
{"code": "int tipc_node_get_mtu(struct net *net, u32 addr, u32 sel, bool connected)\n{\n\tstruct tipc_node *n;\n\tint bearer_id;\n\tunsigned int mtu = MAX_MSG_SIZE;\n\tn = tipc_node_find(net, addr);\n\tif (unlikely(!n))\n\t\treturn mtu;\n\tif (n->peer_net && connected) {\n\t\ttipc_node_put(n);\n\t\treturn mtu;\n\t}\n\tbearer_id = n->active_links[sel & 1];\n\tif (likely(bearer_id != INVALID_BEARER_ID))\n\t\tmtu = n->links[bearer_id].mtu;\n\ttipc_node_put(n);\n\treturn mtu;\n}", "target": 0}
{"code": "static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n\t\t\tunsigned int slen)\n{\n\tu8 *buf = NULL;\n\tu8 *src = (u8 *)seed;\n\tint err;\n\tif (slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(buf, seed, slen);\n\t\tsrc = buf;\n\t}\n\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n\tkzfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "bool setup_tables_and_check_access(THD *thd, Name_resolution_context *context,\n                                   List<TABLE_LIST> *from_clause,\n                                   TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                                   bool select_insert, ulong want_access_first,\n                                   ulong want_access, bool full_table_list)\n{\n  DBUG_ENTER(\"setup_tables_and_check_access\");\n  if (setup_tables(thd, context, from_clause, tables,\n                   leaves, select_insert, full_table_list))\n    DBUG_RETURN(TRUE);\n  List_iterator<TABLE_LIST> ti(leaves);\n  TABLE_LIST *table_list;\n  ulong access= want_access_first;\n  while ((table_list= ti++))\n  {\n    if (table_list->belong_to_view && !table_list->view && \n        check_single_table_access(thd, access, table_list, FALSE))\n    {\n      tables->hide_view_error(thd);\n      DBUG_RETURN(TRUE);\n    }\n    access= want_access;\n  }\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "static ssize_t hid_debug_events_read(struct file *file, char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hid_debug_list *list = file->private_data;\n\tint ret = 0, len;\n\tDECLARE_WAITQUEUE(wait, current);\n\tmutex_lock(&list->read_mutex);\n\twhile (ret == 0) {\n\t\tif (list->head == list->tail) {\n\t\t\tadd_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\twhile (list->head == list->tail) {\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!list->hdev || !list->hdev->debug) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&list->read_mutex);\n\t\t\t\tschedule();\n\t\t\t\tmutex_lock(&list->read_mutex);\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t}\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\ncopy_rest:\n\t\tif (list->tail == list->head)\n\t\t\tgoto out;\n\t\tif (list->tail > list->head) {\n\t\t\tlen = list->tail - list->head;\n\t\t\tif (copy_to_user(buffer + ret, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret += len;\n\t\t\tlist->head += len;\n\t\t} else {\n\t\t\tlen = HID_DEBUG_BUFSIZE - list->head;\n\t\t\tif (copy_to_user(buffer, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlist->head = 0;\n\t\t\tret += len;\n\t\t\tgoto copy_rest;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&list->read_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "QStringList JlCompress::extractDir(QuaZip &zip, const QString &dir)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n    QDir directory(dir);\n    QStringList extracted;\n    if (!zip.goToFirstFile()) {\n        return QStringList();\n    }\n    do {\n        QString name = zip.getCurrentFileName();\n        QString absFilePath = directory.absoluteFilePath(name);\n        if (!extractFile(&zip, \"\", absFilePath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absFilePath);\n    } while (zip.goToNextFile());\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n    return extracted;\n}", "target": 1}
{"code": "static void phys_map_node_reserve(PhysPageMap *map, unsigned nodes)\n{\n    if (map->nodes_nb + nodes > map->nodes_nb_alloc) {\n        map->nodes_nb_alloc = MAX(map->nodes_nb_alloc * 2, 16);\n        map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, map->nodes_nb + nodes);\n        map->nodes = g_renew(Node, map->nodes, map->nodes_nb_alloc);\n    }\n}", "target": 0}
{"code": "void IndexedDBDatabase::Get(IndexedDBTransaction* transaction,\n                            int64_t object_store_id,\n                            int64_t index_id,\n                            std::unique_ptr<IndexedDBKeyRange> key_range,\n                            bool key_only,\n                            scoped_refptr<IndexedDBCallbacks> callbacks) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::Get\", \"txn.id\", transaction->id());\n  if (!ValidateObjectStoreIdAndOptionalIndexId(object_store_id, index_id))\n    return;\n  transaction->ScheduleTask(base::BindOnce(\n      &IndexedDBDatabase::GetOperation, this, object_store_id, index_id,\n      std::move(key_range),\n      key_only ? indexed_db::CURSOR_KEY_ONLY : indexed_db::CURSOR_KEY_AND_VALUE,\n      callbacks));\n}", "target": 0}
{"code": "ECDSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                      const std::string& params,\n                                      const std::string& provider) const\n   {\n#if defined(BOTAN_HAS_BEARSSL)\n   if(provider == \"bearssl\" || provider.empty())\n      {\n      try\n         {\n         return make_bearssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"bearssl\")\n            throw;\n         }\n      }\n#endif\n#if defined(BOTAN_HAS_OPENSSL)\n   if(provider == \"openssl\" || provider.empty())\n      {\n      try\n         {\n         return make_openssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"openssl\")\n            throw;\n         }\n      }\n#endif\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new ECDSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }", "target": 1}
{"code": "static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n  free(copy);\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n  return result;\n}", "target": 1}
{"code": "int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n \tif (ipv6_hdr(skb)->payload_len == 0) {\n \t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn -EINVAL;\n \t}\n \tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn -EINVAL;\n \tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n \t\treturn -ENOMEM;\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\tfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\n\t\t     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_bh(&fq->q.lock);\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tret = -EINPROGRESS;\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len &&\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\nout_unlock:\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q, &nf_frags);\n\treturn ret;\n}", "target": 1}
{"code": "static void __net_exit ip6_route_net_exit(struct net *net)\n{\n\tkfree(net->ipv6.ip6_null_entry);\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tkfree(net->ipv6.ip6_prohibit_entry);\n\tkfree(net->ipv6.ip6_blk_hole_entry);\n#endif\n\tdst_entries_destroy(&net->ipv6.ip6_dst_ops);\n}", "target": 0}
{"code": "static int handle_nop(struct kvm_vcpu *vcpu)\n{\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "local unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register z_crc_t c;\n    register const z_crc_t FAR *buf4;\n    c = ZSWAP32((z_crc_t)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n     }\n     buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n    buf4--;\n     while (len >= 32) {\n         DOBIG32;\n         len -= 32;\n    }\n    while (len >= 4) {\n         DOBIG4;\n         len -= 4;\n     }\n    buf4++;\n     buf = (const unsigned char FAR *)buf4;\n     if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(ZSWAP32(c));\n}", "target": 1}
{"code": "static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\tif (serial->num_ports < 2)\n\t\treturn -1;\n \tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\treturn 0;\n}", "target": 1}
{"code": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "lt_dlinsertsearchdir (const char *before, const char *search_dir)\n{\n  int errors = 0;\n  if (before)\n    {\n      if ((before < user_search_path)\n\t  || (before >= user_search_path + LT_STRLEN (user_search_path)))\n\t{\n\t  LT__SETERROR (INVALID_POSITION);\n\t  return 1;\n\t}\n    }\n  if (search_dir && *search_dir)\n    {\n      if (lt_dlpath_insertdir (&user_search_path,\n\t\t\t       (char *) before, search_dir) != 0)\n\t{\n\t  ++errors;\n\t}\n    }\n  return errors;\n}", "target": 0}
{"code": "static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tint err;\n\tif (len > ds)\n\t\tlen = ds;\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\terr = memcpy_toiovec(msg->msg_iov, ctx->result, len);\nunlock:\n\trelease_sock(sk);\n\treturn err ?: len;\n}", "target": 1}
{"code": "int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n    uint8_t *start = pkt;\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            case 0x0:\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            case 0x1:\n                return TM_ECODE_FAILED;\n            default:\n                return TM_ECODE_FAILED;\n        }\n    }\n    if (IP_GET_RAW_VER(start) == 6) {\n        IPV6Hdr *thdr = (IPV6Hdr *)start;\n        if (len ==  IPV6_HEADER_LEN +\n                IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n            if (pq != NULL) {\n                int blen = len - (start - pkt);\n                Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n                                                  DECODE_TUNNEL_IPV6, pq);\n                if (tp != NULL) {\n                    PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                    PacketEnqueue(pq,tp);\n                    StatsIncr(tv, dtv->counter_teredo);\n                    return TM_ECODE_OK;\n                }\n            }\n        }\n        return TM_ECODE_FAILED;\n    }\n    return TM_ECODE_FAILED;\n}", "target": 1}
{"code": "  PutOperationParams() {}", "target": 0}
{"code": "static int MVGMacroCompare(const void *target,const void *source)\n{\n  const char\n    *p,\n    *q;\n  p=(const char *) target;\n  q=(const char *) source;\n  return(strcmp(p,q));\n}", "target": 0}
{"code": "_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}", "target": 1}
{"code": "std::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array, extra_settings &ext)\n{\n    std::string real_rule, ret;\n    for(const RegexMatchConfig &x : emoji_array)\n    {\n        if(!x.Script.empty())\n        {\n            std::string result;\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto getEmoji = (std::function<std::string(const Proxy&)>) ctx.eval(\"getEmoji\");\n                    ret = getEmoji(node);\n                    if(!ret.empty())\n                        result = ret + \" \" + node.Remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            if(!result.empty())\n                return result;\n            continue;\n        }\n        if(x.Replace.empty())\n            continue;\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size() && regFind(node.Remark, real_rule))\n            return x.Replace + \" \" + node.Remark;\n    }\n    return node.Remark;\n}", "target": 1}
{"code": "static int technisat_usb2_get_ir(struct dvb_usb_device *d)\n{\n\tstruct technisat_usb2_state *state = d->priv;\n\tu8 *buf = state->buf;\n\tu8 *b;\n\tint ret;\n\tstruct ir_raw_event ev;\n\tbuf[0] = GET_IR_DATA_VENDOR_REQUEST;\n\tbuf[1] = 0x08;\n\tbuf[2] = 0x8f;\n\tbuf[3] = MINIMUM_IR_BIT_TRANSITION_TICK_COUNT;\n\tbuf[4] = MAXIMUM_IR_BIT_TIME_TICK_COUNT;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\tret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t0, 0,\n\t\t\tbuf, 5, 500);\n\tif (ret < 0)\n\t\tgoto unlock;\n\tbuf[1] = 0;\n\tbuf[2] = 0;\n\tret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t0x8080, 0,\n\t\t\tbuf, 62, 500);\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 1)\n\t\treturn 0; \n\tb = buf+1;\n#if 0\n\tdeb_rc(\"RC: %d \", ret);\n\tdebug_dump(b, ret, deb_rc);\n#endif\n\tev.pulse = 0;\n\twhile (1) {\n\t\tev.pulse = !ev.pulse;\n\t\tev.duration = (*b * FIRMWARE_CLOCK_DIVISOR * FIRMWARE_CLOCK_TICK) / 1000;\n\t\tir_raw_event_store(d->rc_dev, &ev);\n\t\tb++;\n\t\tif (*b == 0xff) {\n\t\t\tev.pulse = 0;\n\t\t\tev.duration = 888888*2;\n\t\t\tir_raw_event_store(d->rc_dev, &ev);\n\t\t\tbreak;\n\t\t}\n\t}\n\tir_raw_event_handle(d->rc_dev);\n\treturn 1;\n}", "target": 1}
{"code": "static int n_tty_receive_buf2(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      char *fp, int count)\n{\n\treturn n_tty_receive_buf_common(tty, cp, fp, count, 1);\n}", "target": 0}
{"code": "uint STDCALL mysql_thread_safe(void)\n{\n  return 1;\n}", "target": 0}
{"code": "HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)\n{\n\tint n = 0;\n\tchar *reason = NULL;\n\trfbClientToServerTightMsg msg;\n\tmemset(&msg, 0, sizeof(rfbClientToServerTightMsg));\n\tif((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\tmsg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);\n\tif(msg.fdc.reasonLen == 0) {\n\t\trfbLog(\"File [%s]: Method [%s]: reason length received is Zero\\n\",\n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\treason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));\n\tif(reason == NULL) {\n\t\trfbLog(\"File [%s]: Method [%s]: Fatal Error: Memory alloc failed\\n\", \n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\tif((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t    rfbCloseClient(cl);\n\t}\n\trfbLog(\"File [%s]: Method [%s]: File Download Cancel Request received:\"\n\t\t\t\t\t\" reason <%s>\\n\", __FILE__, __FUNCTION__, reason);\n\tpthread_mutex_lock(&fileDownloadMutex);\n\tCloseUndoneFileTransfer(cl, rtcp);\n\tpthread_mutex_unlock(&fileDownloadMutex);\n\tif(reason != NULL) {\n\t\tfree(reason);\n\t\treason = NULL;\n\t}\n}", "target": 1}
{"code": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\treturn &rt->dst;\n}", "target": 1}
{"code": "void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n{\n\tint i;\n\tint opts;\n\tResub m;\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushnull(J);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tjs_newarray(J);\n\t\tjs_pushstring(J, text);\n\t\tjs_setproperty(J, -2, \"input\");\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\t\tjs_setproperty(J, -2, \"index\");\n\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\tjs_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushnull(J);\n}", "target": 1}
{"code": "SHA256_Init(struct SHA256_CTX * ctx)\n{\n  ctx->count[0] = ctx->count[1] = 0;\n  ctx->state[0] = 0x6A09E667;\n  ctx->state[1] = 0xBB67AE85;\n  ctx->state[2] = 0x3C6EF372;\n  ctx->state[3] = 0xA54FF53A;\n  ctx->state[4] = 0x510E527F;\n  ctx->state[5] = 0x9B05688C;\n  ctx->state[6] = 0x1F83D9AB;\n  ctx->state[7] = 0x5BE0CD19;\n}", "target": 1}
{"code": "static CURLcode error_init_writer(struct Curl_easy *data,\n                                  struct contenc_writer *writer)\n{\n  (void) data;\n  return writer->downstream? CURLE_OK: CURLE_WRITE_ERROR;\n}", "target": 0}
{"code": "static ssize_t remove_slot_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tint rc;\n\tchar *end;\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\tmemcpy(drc_name, buf, nbytes);\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\trc = dlpar_remove_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\treturn nbytes;\n}", "target": 1}
{"code": "int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n\t\t     int flen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\tif (udf_build_ustr_exact(unifilename, sname, flen))\n\t\tgoto out2;\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}", "target": 1}
{"code": "static ptrdiff_t finderrfunc(lua_State *L)\n{\n  cTValue *frame = L->base-1, *bot = tvref(L->stack);\n  void *cf = L->cframe;\n  while (frame > bot && cf) {\n    while (cframe_nres(cframe_raw(cf)) < 0) {  \n      if (frame >= restorestack(L, -cframe_nres(cf)))\n\tbreak;\n      if (cframe_errfunc(cf) >= 0)  \n\treturn cframe_errfunc(cf);\n      cf = cframe_prev(cf);  \n      if (cf == NULL)\n\treturn 0;\n    }\n    switch (frame_typep(frame)) {\n    case FRAME_LUA:\n    case FRAME_LUAP:\n      frame = frame_prevl(frame);\n      break;\n    case FRAME_C:\n      cf = cframe_prev(cf);\n    case FRAME_VARG:\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_CONT:\n#if LJ_HASFFI\n      if ((frame-1)->u32.lo == LJ_CONT_FFI_CALLBACK)\n\tcf = cframe_prev(cf);\n#endif\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_CP:\n      if (cframe_canyield(cf)) return 0;\n      if (cframe_errfunc(cf) >= 0)\n\treturn cframe_errfunc(cf);\n      frame = frame_prevd(frame);\n      break;\n    case FRAME_PCALL:\n    case FRAME_PCALLH:\n      if (frame_ftsz(frame) >= (ptrdiff_t)(2*sizeof(TValue)))  \n\treturn savestack(L, frame-1);  \n      return 0;\n    default:\n      lua_assert(0);\n      return 0;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\tcard->cmdrsp_buf = skb;\n\treturn 0;\n}", "target": 1}
{"code": "eui64_to_display(wmem_allocator_t *allocator, const guint64 addr_eui64)\n{\n    guint8 *addr = (guint8 *)wmem_alloc(NULL, 8);\n    hashmanuf_t *manuf_value;\n    gchar *ret;\n    *(guint64 *)(void *)(addr) = pntoh64(&(addr_eui64));\n    manuf_value = manuf_name_lookup(addr);\n    if (!gbl_resolv_flags.mac_name || (manuf_value->status == HASHETHER_STATUS_UNRESOLVED)) {\n        ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);\n    } else {\n        ret = wmem_strdup_printf(allocator, \"%s_%02x:%02x:%02x:%02x:%02x\", manuf_value->resolved_name, addr[3], addr[4], addr[5], addr[6], addr[7]);\n    }\n    wmem_free(NULL, addr);\n    return ret;\n} ", "target": 1}
{"code": "static char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tdemangled[strlen(demangled) - 1] = 0;\n\treturn demangled;\n}", "target": 1}
{"code": "static void fuse_lib_statfs(fuse_req_t req, fuse_ino_t ino)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    struct statvfs buf;\n    char *path;\n    int err;\n    memset(&buf, 0, sizeof(buf));\n    pthread_rwlock_rdlock(&f->tree_lock);\n    if (!ino) {\n        err = -ENOMEM;\n        path = strdup(\"/\");\n    } else {\n        err = -ENOENT;\n        path = get_path(f, ino);\n    }\n    if (path) {\n        struct fuse_intr_data d;\n        fuse_prepare_interrupt(f, req, &d);\n        err = fuse_fs_statfs(f->fs, path, &buf);\n        fuse_finish_interrupt(f, req, &d);\n        free(path);\n    }\n    pthread_rwlock_unlock(&f->tree_lock);\n    if (!err)\n        fuse_reply_statfs(req, &buf);\n    else\n        reply_err(req, err);\n}", "target": 0}
{"code": "gboolean reds_config_get_agent_mouse(const RedsState *reds)\n{\n    return reds->config->agent_mouse;\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_assert(pj_cis_match(spec,0)==0);\n    if (!pj_cis_match(spec, *s)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    do {\n\t++s;\n    } while (pj_cis_match(spec, *s));\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}", "target": 1}
{"code": "    CImg<T>& CMYtoRGB() {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"CMYtoRGB(): Instance is not a CMY image.\",\n                                    cimg_instance);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=2048))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          C = (Tfloat)p1[N],\n          M = (Tfloat)p2[N],\n          Y = (Tfloat)p3[N],\n          R = 255 - C,\n          G = 255 - M,\n          B = 255 - Y;\n        p1[N] = (T)cimg::cut(R,0,255),\n        p2[N] = (T)cimg::cut(G,0,255),\n        p3[N] = (T)cimg::cut(B,0,255);\n      }\n      return *this;", "target": 0}
{"code": "static bool mnt_ns_loop(struct dentry *dentry)\n{\n\tstruct mnt_namespace *mnt_ns;\n\tif (!is_mnt_ns_file(dentry))\n\t\treturn false;\n\tmnt_ns = get_proc_ns(dentry->d_inode)->ns;\n\treturn current->nsproxy->mnt_ns->seq >= mnt_ns->seq;\n}", "target": 0}
{"code": "asmlinkage void __sched schedule(void)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq *rq;\n\tint cpu;\nneed_resched:\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\trcu_note_context_switch(cpu);\n\tprev = rq->curr;\n\trelease_kernel_lock(prev);\nneed_resched_nonpreemptible:\n\tschedule_debug(prev);\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\traw_spin_lock_irq(&rq->lock);\n\tclear_tsk_need_resched(prev);\n\tswitch_count = &prev->nivcsw;\n\tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup);\n\t\t\t}\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\tpre_schedule(rq, prev);\n\tif (unlikely(!rq->nr_running))\n\t\tidle_balance(cpu, rq);\n\tput_prev_task(rq, prev);\n\tnext = pick_next_task(rq);\n\tif (likely(prev != next)) {\n\t\tsched_info_switch(prev, next);\n\t\tperf_event_task_sched_out(prev, next);\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t++*switch_count;\n\t\tcontext_switch(rq, prev, next); \n\t\tcpu = smp_processor_id();\n\t\trq = cpu_rq(cpu);\n\t} else\n\t\traw_spin_unlock_irq(&rq->lock);\n\tpost_schedule(rq);\n\tif (unlikely(reacquire_kernel_lock(prev)))\n\t\tgoto need_resched_nonpreemptible;\n\tpreempt_enable_no_resched();\n\tif (need_resched())\n\t\tgoto need_resched;\n}", "target": 1}
{"code": "    static bool is4ByteType(uint16_t type)\n    {\n        return isLongType(type)\n            || isRationalType(type)\n            ;\n    }", "target": 0}
{"code": "void FormatConverter<T>::InitSparseToDenseConverter(\n    std::vector<int> shape, std::vector<int> traversal_order,\n    std::vector<TfLiteDimensionType> format, std::vector<int> dense_size,\n    std::vector<std::vector<int>> segments,\n    std::vector<std::vector<int>> indices, std::vector<int> block_map) {\n  dense_shape_ = std::move(shape);\n  traversal_order_ = std::move(traversal_order);\n  block_map_ = std::move(block_map);\n  format_ = std::move(format);\n  dense_size_ = 1;\n  for (int i = 0; i < dense_shape_.size(); i++) {\n    dense_size_ *= dense_shape_[i];\n  }\n  dim_metadata_.resize(2 * format_.size());\n  for (int i = 0; i < format_.size(); i++) {\n    if (format_[i] == kTfLiteDimDense) {\n      dim_metadata_[2 * i] = {dense_size[i]};\n    } else {\n      dim_metadata_[2 * i] = std::move(segments[i]);\n      dim_metadata_[2 * i + 1] = std::move(indices[i]);\n    }\n  }\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      int orig_dim = traversal_order_[original_rank + block_dim];\n      block_size_[block_dim] = dense_size[orig_dim];\n      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n      block_dim++;\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}", "target": 1}
{"code": "static int oidc_cache_crypto_encrypt(request_rec *r, const char *plaintext,\n\t\tunsigned char *key, char **result) {\n\tchar *encoded = NULL, *p = NULL, *e_tag = NULL;\n\tunsigned char *ciphertext = NULL;\n\tint plaintext_len, ciphertext_len, encoded_len, e_tag_len;\n\tunsigned char tag[OIDC_CACHE_TAG_LEN];\n\tplaintext_len = strlen(plaintext) + 1;\n\tciphertext = apr_pcalloc(r->pool,\n\t\t\t(plaintext_len + EVP_CIPHER_block_size(OIDC_CACHE_CIPHER)));\n\tciphertext_len = oidc_cache_crypto_encrypt_impl(r,\n\t\t\t(unsigned char *) plaintext, plaintext_len,\n\t\t\tOIDC_CACHE_CRYPTO_GCM_AAD, sizeof(OIDC_CACHE_CRYPTO_GCM_AAD), key,\n\t\t\tOIDC_CACHE_CRYPTO_GCM_IV, sizeof(OIDC_CACHE_CRYPTO_GCM_IV),\n\t\t\tciphertext, tag, sizeof(tag));\n\tencoded_len = oidc_base64url_encode(r, &encoded, (const char *) ciphertext,\n\t\t\tciphertext_len, 1);\n\tif (encoded_len > 0) {\n\t\tp = encoded;\n\t\te_tag_len = oidc_base64url_encode(r, &e_tag, (const char *) tag,\n\t\t\t\tOIDC_CACHE_TAG_LEN, 1);\n\t\tencoded = apr_pcalloc(r->pool, encoded_len + 1 + e_tag_len + 1);\n\t\tmemcpy(encoded, p, encoded_len);\n\t\tp = encoded + encoded_len;\n\t\t*p = OIDC_CHAR_DOT;\n\t\tp++;\n\t\tmemcpy(p, e_tag, e_tag_len);\n\t\tencoded_len += e_tag_len + 1;\n\t\tencoded[encoded_len] = '\\0';\n\t\t*result = encoded;\n\t}\n\treturn encoded_len;\n}", "target": 1}
{"code": "void ewk_view_menubar_visible_get(Evas_Object* ewkView, bool* visible)\n{\n    DBG(\"%s, o=%p\", __func__, ewkView);\n    *visible = false;\n    evas_object_smart_callback_call(ewkView, \"menubar,visible,get\", visible);\n}", "target": 0}
{"code": "  void ComputeAsyncImpl(OpKernelContext* c, CollectiveExecutor* col_exec,\n                        DoneCallback done) override {\n    auto output_shape = c->input(0).shape();\n    OP_REQUIRES_ASYNC(c, output_shape.dims() > 0,\n                      errors::InvalidArgument(\"input should have rank > 0, \",\n                                              \"recieved \", output_shape.dims()),\n                      done);\n    output_shape.set_dim(\n        0, output_shape.dim_size(0) * col_params_->group.group_size);\n    col_params_->instance.shape = output_shape;\n    if (c->mutable_output(0) == nullptr) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          c, c->allocate_output(0, col_params_->instance.shape, &output), done);\n    }\n    if (!CanProceedWithCompute(c, col_exec, done)) return;\n    auto actual_done = [c, col_params = col_params_, done](const Status& s) {\n      VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync done for collective \"\n              << c->op_kernel().name() << \" device \" << c->device()->name()\n              << \" group \" << col_params->group.group_key << \" instance \"\n              << col_params->instance.instance_key << \" status \" << s;\n      col_params->Unref();\n      OP_REQUIRES_OK_ASYNC(c, s, done);\n      done();\n    };\n    VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync start for collective \"\n            << col_params_->name << \" device \" << c->device()->name()\n            << \" group \" << col_params_->group.group_key << \" instance \"\n            << col_params_->instance.instance_key;\n    col_params_->Ref();\n    col_exec->ExecuteAsync(c, col_params_, GetCollectiveKey(c), actual_done);\n  }", "target": 0}
{"code": "void WasmBinaryBuilder::throwError(std::string text) {\n  throw ParseException(text, 0, pos);\n}", "target": 0}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \n                break;\n            case TYPE_COMMENT:\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\topenflags &= ~(O_CREAT|O_EXCL);\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}", "target": 1}
{"code": "ContentSettingsStore::ContentSettingsStore() {\n  DCHECK(OnCorrectThread());\n}", "target": 0}
{"code": "        bool operator()(const Exiv2::Exifdatum& md) const\n        {\n            return idx_ == md.idx() && 0 == strcmp(md.groupName().c_str(), groupName_);\n        }", "target": 0}
{"code": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n \t\t\t struct nf_conntrack_expect *exp)\n {\n \tchar buffer[sizeof(\"4294967296 65635\")];\n \tu_int16_t port;\n \tunsigned int ret;\n \texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n \texp->dir = IP_CT_DIR_REPLY;\n \texp->expectfn = nf_nat_follow_master;\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n \t}\n \tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n \t\treturn NF_DROP;\n \t}\n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n \tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n \t\tnf_ct_unexpect_related(exp);\n \t}\n \treturn ret;\n }", "target": 1}
{"code": "setkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal((void *)handle, arg->princ,\n                                          arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "dirvote_get_vote(const char *fp, int flags)\n{\n  int by_id = flags & DGV_BY_ID;\n  const int include_pending = flags & DGV_INCLUDE_PENDING;\n  const int include_previous = flags & DGV_INCLUDE_PREVIOUS;\n  if (!pending_vote_list && !previous_vote_list)\n    return NULL;\n  if (fp == NULL) {\n    authority_cert_t *c = get_my_v3_authority_cert();\n    if (c) {\n      fp = c->cache_info.identity_digest;\n      by_id = 1;\n    } else\n      return NULL;\n  }\n  if (by_id) {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  } else {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "int fz_colorspace_is_subtractive(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->type == FZ_COLORSPACE_CMYK || cs->type == FZ_COLORSPACE_SEPARATION);\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_diff,\n                         const Variant& container1,\n                         const Variant& container2,\n                         const Array& args ) {\n  ARRAY_DIFF_PRELUDE()\n  auto st = req::make<c_Set>();\n  st->reserve(largestSize);\n  containerValuesToSetHelper(st, container2);\n  if (UNLIKELY(moreThanTwo)) {\n    for (ArrayIter argvIter(args); argvIter; ++argvIter) {\n      const auto& container = argvIter.secondRef();\n      containerValuesToSetHelper(st, container);\n    }\n  }\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(c1.m_type);\n  for (ArrayIter iter(container1); iter; ++iter) {\n    const auto& val = iter.secondRefPlus();\n    const auto& c = *val.asCell();\n    if (checkSetHelper(st, c, strTv, true)) continue;\n    ret.setWithRef(iter.first(), val, isKey);\n  }\n  return tvReturn(std::move(ret));\n}", "target": 0}
{"code": "nfsd4_deallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t union nfsd4_op_u *u)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, &u->deallocate,\n\t\t\t       FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE);\n}", "target": 0}
{"code": "int gdCompareInt (const void *a, const void *b)\n{\n\treturn (*(const int *) a) - (*(const int *) b);\n}", "target": 0}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::EvictDelegatedFrame() {\n  window_->layer()->SetShowPaintedContent();\n  frame_provider_ = NULL;\n  delegated_frame_evictor_->DiscardedFrame();\n}", "target": 0}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tUnmaybe(object->Delete(context_handle, key_inner));\n\t\t\tLocal<Value> val_inner = val->TransferIn();\n\t\t\tdid_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));\n\t\t}", "target": 1}
{"code": "TfLiteStatus GatherNd(const TfLiteTensor* params, const TfLiteTensor* indices,\n                      TfLiteTensor* output) {\n  reference_ops::GatherNd(\n      GetTensorShape(params), GetTensorData<ParamsT>(params),\n      GetTensorShape(indices), GetTensorData<IndicesT>(indices),\n      GetTensorShape(output), GetTensorData<ParamsT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "int HeaderMapWrapper::luaGet(lua_State* state) {\n  const char* key = luaL_checkstring(state, 2);\n  const auto value =\n      Http::HeaderUtility::getAllOfHeaderAsString(headers_, Http::LowerCaseString(key));\n  if (value.result().has_value()) {\n    lua_pushlstring(state, value.result().value().data(), value.result().value().length());\n    return 1;\n  } else {\n    return 0;\n  }\n}", "target": 0}
{"code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}", "target": 1}
{"code": "dup_list_from_ptrarray (GPtrArray *p)\n{\n  GList *ret;\n  guint n;\n  ret = NULL;\n  for (n = 0; n < p->len; n++)\n    ret = g_list_prepend (ret, g_strdup (((gchar **) p->pdata)[n]));\n  return ret;\n}", "target": 0}
{"code": "void IndexedDBDatabase::DeleteObjectStoreAbortOperation(\n    IndexedDBObjectStoreMetadata object_store_metadata) {\n  IDB_TRACE(\"IndexedDBDatabase::DeleteObjectStoreAbortOperation\");\n  AddObjectStore(std::move(object_store_metadata),\n                 IndexedDBObjectStoreMetadata::kInvalidId);\n}", "target": 0}
{"code": "bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n \t\t    return FALSE;\n \t       }\n \t  }\n\t  return (xdr_opaque(xdrs, *objp, size));\n      case XDR_ENCODE:\n \t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n     return FALSE;\n}", "target": 1}
{"code": "int ssh_scp_init(ssh_scp scp)\n{\n    int rc;\n    char execbuffer[1024] = {0};\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->state != SSH_SCP_NEW) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"ssh_scp_init called under invalid state\");\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PROTOCOL,\n            \"Initializing scp session %s %son location '%s'\",\n            scp->mode == SSH_SCP_WRITE?\"write\":\"read\",\n            scp->recursive?\"recursive \":\"\",\n            scp->location);\n    scp->channel = ssh_channel_new(scp->session);\n    if (scp->channel == NULL) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    rc = ssh_channel_open_session(scp->channel);\n    if (rc == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -t %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    } else {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -f %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    }\n    if (ssh_channel_request_exec(scp->channel, execbuffer) == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        rc = ssh_scp_response(scp, NULL);\n        if (rc != 0) {\n            return SSH_ERROR;\n        }\n    } else {\n        ssh_channel_write(scp->channel, \"\", 1);\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        scp->state = SSH_SCP_WRITE_INITED;\n    } else {\n        scp->state = SSH_SCP_READ_INITED;\n    }\n    return SSH_OK;\n}", "target": 1}
{"code": "static void update_ple_window_actual_max(void)\n{\n\tple_window_actual_max =\n\t\t\t__shrink_ple_window(max(ple_window_max, ple_window),\n\t\t\t                    ple_window_grow, INT_MIN);\n}", "target": 0}
{"code": "int nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol)\n{\n\tint rc;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s target_idx=%u protocol=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, protocol);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_idx);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->activate_target(dev, target, protocol);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t\tif (dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void sdhci_send_command(SDHCIState *s)\n{\n    SDRequest request;\n    uint8_t response[16];\n    int rlen;\n    s->errintsts = 0;\n    s->acmd12errsts = 0;\n    request.cmd = s->cmdreg >> 8;\n    request.arg = s->argument;\n    trace_sdhci_send_command(request.cmd, request.arg);\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n        if (rlen == 4) {\n            s->rspreg[0] = ldl_be_p(response);\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n            trace_sdhci_response4(s->rspreg[0]);\n        } else if (rlen == 16) {\n            s->rspreg[0] = ldl_be_p(&response[11]);\n            s->rspreg[1] = ldl_be_p(&response[7]);\n            s->rspreg[2] = ldl_be_p(&response[3]);\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n                            response[2];\n            trace_sdhci_response16(s->rspreg[3], s->rspreg[2],\n                                   s->rspreg[1], s->rspreg[0]);\n        } else {\n            trace_sdhci_error(\"timeout waiting for command response\");\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n                s->norintsts |= SDHC_NIS_ERR;\n            }\n        }\n        if (!(s->quirks & SDHCI_QUIRK_NO_BUSY_IRQ) &&\n            (s->norintstsen & SDHC_NISEN_TRSCMP) &&\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n            s->norintsts |= SDHC_NIS_TRSCMP;\n        }\n    }\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n        s->norintsts |= SDHC_NIS_CMDCMP;\n    }\n    sdhci_update_irq(s);\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n        s->data_count = 0;\n        sdhci_data_transfer(s);\n    }\n}", "target": 1}
{"code": "begin_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tpdf_xobject *softmask = gstate->softmask;\n\tfz_rect mask_bbox;\n\tfz_matrix tos_save[2], save_ctm;\n\tfz_matrix mask_matrix;\n\tfz_colorspace *mask_colorspace;\n\tsave->softmask = softmask;\n\tif (softmask == NULL)\n\t\treturn gstate;\n\tsave->page_resources = gstate->softmask_resources;\n\tsave->ctm = gstate->softmask_ctm;\n\tsave_ctm = gstate->ctm;\n\tpdf_xobject_bbox(ctx, softmask, &mask_bbox);\n\tpdf_xobject_matrix(ctx, softmask, &mask_matrix);\n\tpdf_tos_save(ctx, &pr->tos, tos_save);\n\tif (gstate->luminosity)\n\t\tmask_bbox = fz_infinite_rect;\n\telse\n\t{\n\t\tfz_transform_rect(&mask_bbox, &mask_matrix);\n\t\tfz_transform_rect(&mask_bbox, &gstate->softmask_ctm);\n\t}\n\tgstate->softmask = NULL;\n\tgstate->softmask_resources = NULL;\n\tgstate->ctm = gstate->softmask_ctm;\n        mask_colorspace = pdf_xobject_colorspace(ctx, softmask);\n        if (gstate->luminosity && !mask_colorspace)\n               mask_colorspace = fz_device_gray(ctx);\n        fz_try(ctx)\n        {\n\t\tfz_begin_mask(ctx, pr->dev, &mask_bbox, gstate->luminosity, mask_colorspace, gstate->softmask_bc, &gstate->fill.color_params);\n\t\tpdf_run_xobject(ctx, pr, softmask, save->page_resources, &fz_identity, 1);\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_colorspace(ctx, mask_colorspace);\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t}\n\tfz_end_mask(ctx, pr->dev);\n\tpdf_tos_restore(ctx, &pr->tos, tos_save);\n\tgstate = pr->gstate + pr->gtop;\n\tgstate->ctm = save_ctm;\n\treturn gstate;\n}", "target": 1}
{"code": "static bool rb_is_reader_page(struct buffer_page *page)\n{\n\tstruct list_head *list = page->list.prev;\n\treturn rb_list_head(list->next) != &page->list;\n}", "target": 0}
{"code": "\tUnbufferedAsioTlsStream(UnbufferedAsioTlsStreamParams& init)\n\t\t: AsioTcpTlsStream(init.IoContext, init.SslContext), m_VerifyOK(true), m_Hostname(init.Hostname)\n\t{\n\t}", "target": 1}
{"code": "void MidiManagerUsb::DispatchSendMidiData(MidiManagerClient* client,\n                                           uint32_t port_index,\n                                           const std::vector<uint8>& data,\n                                           double timestamp) {\n  DCHECK_LT(port_index, output_streams_.size());\n   output_streams_[port_index]->Send(data);\n   client->AccumulateMidiBytesSent(data.size());\n }", "target": 1}
{"code": "unsigned long kvm_vcpu_gfn_to_hva(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn gfn_to_hva_many(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn, NULL);\n}", "target": 0}
{"code": "static void dhcps_send_offer(struct pbuf *packet_buffer)\n{\n\tuint8_t temp_ip = 0;\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\t\n#if (!IS_USE_FIXED_IP) \t\n\ttemp_ip = check_client_request_ip(&client_request_ip, client_addr);\n\tif(temp_ip == 0)\n\t\ttemp_ip = search_next_ip();\n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n temp_ip = %d\",temp_ip);\n#endif\t\n\tif (temp_ip == 0) {\n#if 0\t\n\t  \tmemset(&ip_table, 0, sizeof(struct table));\n\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));\n\t\tprintf(\"\\r\\n reset ip table!!\\r\\n\");\t\n#endif\t\n\t\tprintf(\"\\r\\n No useable ip!!!!\\r\\n\");\n\t}\n\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),temp_ip);\n\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), temp_ip);\n#endif   \n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n\t\t\tDHCP_MESSAGE_TYPE_OFFER));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t\t&dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}", "target": 1}
{"code": "put16(unsigned char *cp, unsigned short x)\n{\n\t*cp++ = x >> 8;\n\t*cp++ = x;\n\treturn cp;\n}", "target": 0}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n \t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n \t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "bool EditorClientBlackBerry::shouldDeleteRange(Range* range)\n{\n    if (m_webPagePrivate->m_dumpRenderTree)\n        return m_webPagePrivate->m_dumpRenderTree->shouldDeleteDOMRange(range);\n    return true;\n}", "target": 0}
{"code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n \tw = image->comps[0].w;\n \th = image->comps[0].h;\n\tif(image->numcomps < 4) return;\n \tmax = w * h;\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); \n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); \n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); \n\t}\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n}", "target": 1}
{"code": "  ClickModifierTest() {\n  }", "target": 0}
{"code": "void ZeroSuggestProvider::AddProviderInfo(ProvidersInfo* provider_info) const {\n  BaseSearchProvider::AddProviderInfo(provider_info);\n  if (!results_.suggest_results.empty() ||\n      !results_.navigation_results.empty() ||\n      !most_visited_urls_.empty())\n    provider_info->back().set_times_returned_results_in_session(1);\n}", "target": 0}
{"code": "MOCK_IMPL(const char *,\ndirvote_get_pending_consensus, (consensus_flavor_t flav))\n{\n  tor_assert(((int)flav) >= 0 && (int)flav < N_CONSENSUS_FLAVORS);\n  return pending_consensuses[flav].body;\n}", "target": 0}
{"code": "ex_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\teap->errmsg =\n\t\t_(\"E319: Sorry, the command is not available in this version\");\n}", "target": 0}
{"code": " std::string GetUploadData(const std::string& brand) {\n   DCHECK(!brand.empty());\n  std::string data(kPostXml);\n  const std::string placeholder(\"__BRANDCODE_PLACEHOLDER__\");\n  size_t placeholder_pos = data.find(placeholder);\n  DCHECK(placeholder_pos != std::string::npos);\n  data.replace(placeholder_pos, placeholder.size(), brand);\n  return data;\n }", "target": 1}
{"code": "static int _mysql_begin_txn(void *conn, const sasl_utils_t *utils)\n{\n    return _mysql_exec(conn,\n#if MYSQL_VERSION_ID >= 40011\n\t\t       \"START TRANSACTION\",\n#else\n\t\t       \"BEGIN\",\n#endif\n\t\t       NULL, 0, NULL, utils);\n}", "target": 0}
{"code": "static int __init big_key_crypto_init(void)\n{\n\tint ret = -EINVAL;\n\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n\tif (IS_ERR(big_key_rng)) {\n\t\tbig_key_rng = NULL;\n\t\treturn -EFAULT;\n\t}\n\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n\tif (ret)\n\t\tgoto error;\n\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_skcipher)) {\n\t\tbig_key_skcipher = NULL;\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tcrypto_free_rng(big_key_rng);\n\tbig_key_rng = NULL;\n\treturn ret;\n}", "target": 1}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}", "target": 1}
{"code": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\tunsigned char header[18];\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\ttga->ident = NULL;\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void gf_isom_delete(GF_ISOFile *movie)\n{\n\tgf_isom_delete_movie(movie);\n}", "target": 0}
{"code": "void HTPStateFree(void *state)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    if (s == NULL) {\n        SCReturn;\n    }\n    if (s->connp != NULL) {\n        SCLogDebug(\"freeing HTP state\");\n        uint64_t tx_id;\n        uint64_t total_txs = HTPStateGetTxCnt(state);\n        if (s->conn != NULL) {\n            for (tx_id = 0; tx_id < total_txs; tx_id++) {\n                htp_tx_t *tx = HTPStateGetTx(s, tx_id);\n                if (tx != NULL) {\n                    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n                    HtpTxUserDataFree(s, htud);\n                    htp_tx_set_user_data(tx, NULL);\n                }\n            }\n        }\n        htp_connp_destroy_all(s->connp);\n    }\n    HTPFree(s, sizeof(HtpState));\n#ifdef DEBUG\n    SCMutexLock(&htp_state_mem_lock);\n    htp_state_memcnt--;\n    htp_state_memuse -= sizeof(HtpState);\n    SCLogDebug(\"htp memory %\"PRIu64\" (%\"PRIu64\")\", htp_state_memuse, htp_state_memcnt);\n    SCMutexUnlock(&htp_state_mem_lock);\n#endif\n    SCReturn;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, CompoundIndexBoundsRangeAndEquality) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    runQuery(fromjson(\"{a: {$gt: 8}, b: 6}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, bounds: \"\n        \"{a: [[8,Infinity,false,true]], b:[[6,6,true,true]]}}}}}\");\n}", "target": 0}
{"code": "static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,\n  jas_image_t *image)\n{\n\tint pad;\n\tint nz;\n\tint z;\n\tint c;\n\tint y;\n\tint x;\n\tint v;\n\tint i;\n\tjas_matrix_t *data[3];\n\tcmap = 0;\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tdata[i] = jas_matrix_create(1, jas_image_width(image));\n\t\tassert(data[i]);\n\t}\n\tpad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) / 8;\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tnz = 0;\n\t\tz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\twhile (nz < hdr->depth) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tz = (z << 8) | c;\n\t\t\t\tnz += 8;\n\t\t\t}\n\t\t\tv = (z >> (nz - hdr->depth)) & RAS_ONES(hdr->depth);\n\t\t\tz &= RAS_ONES(nz - hdr->depth);\n\t\t\tnz -= hdr->depth;\n\t\t\tif (jas_image_numcmpts(image) == 3) {\n\t\t\t\tjas_matrix_setv(data[0], x, (RAS_GETRED(v)));\n\t\t\t\tjas_matrix_setv(data[1], x, (RAS_GETGREEN(v)));\n\t\t\t\tjas_matrix_setv(data[2], x, (RAS_GETBLUE(v)));\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(data[0], x, (v));\n\t\t\t}\n\t\t}\n\t\tif (pad) {\n\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tif (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,\n\t\t\t  data[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "OmniboxViewWin::~OmniboxViewWin() {\n  text_object_model_->Release();\n  g_paint_patcher.Pointer()->DerefPatch();\n}", "target": 0}
{"code": "bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "static void ip6_append_data_mtu(int *mtu,\n \t\t\t\tint *maxfraglen,\n \t\t\t\tunsigned int fragheaderlen,\n \t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n {\n \tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n \t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n \t\t}\n \t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n \t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}", "target": 1}
{"code": "static int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void http1_on_data_first_time(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  ssize_t i;\n  i = fio_read(uuid, p->buf + p->buf_len, HTTP_MAX_HEADER_LENGTH - p->buf_len);\n  if (i <= 0)\n    return;\n  p->buf_len += i;\n  p->p.protocol.on_data = http1_on_data;\n  if (i >= 24 && !memcmp(p->buf, \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\", 24)) {\n    FIO_LOG_WARNING(\"client claimed unsupported HTTP/2 prior knowledge.\");\n    fio_close(uuid);\n    return;\n  }\n  http1_consume_data(uuid, p);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    const T min_as_quantized = FloatToQuantized<T>(0.0f, min_input, max_input);\n    if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n      auto input_ui8_array = input.flat<quint8>();\n      meta::Clamp(context, input_ui8_array.data(), input_ui8_array.size(),\n                  min_as_quantized, 255, output->flat<quint8>().data());\n    } else {\n      output->flat<T>().device(context->eigen_cpu_device()) =\n          input.flat<T>().cwiseMax(min_as_quantized).template cast<T>();\n    }\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "njs_typed_array_prototype_buffer(njs_vm_t *vm, njs_value_t *args,\n    njs_uint_t nargs, njs_index_t unused)\n{\n    njs_value_t        *this;\n    njs_typed_array_t  *array;\n    this = njs_argument(args, 0);\n    if (!njs_is_typed_array(this) && !njs_is_data_view(this)) {\n        njs_type_error(vm, \"Method TypedArray.prototype.buffer called \"\n                       \"on incompatible receiver\");\n        return NJS_ERROR;\n    }\n    array = njs_typed_array(this);\n    njs_set_array_buffer(&vm->retval, njs_typed_array_buffer(array));\n    return NJS_OK;\n}", "target": 0}
{"code": "ts_date_hmsfrac_print(netdissect_options *ndo, long sec, long usec,\n\t\t      enum date_flag date_flag, enum time_flag time_flag)\n{\n\ttime_t Time = sec;\n\tstruct tm *tm;\n\tchar timestr[32];\n\tif ((unsigned)sec & 0x80000000) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\tif (time_flag == LOCAL_TIME)\n\t\ttm = localtime(&Time);\n\telse\n\t\ttm = gmtime(&Time);\n\tif (!tm) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\tif (date_flag == WITH_DATE)\n\t\tstrftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", tm);\n\telse\n\t\tstrftime(timestr, sizeof(timestr), \"%H:%M:%S\", tm);\n\tND_PRINT(\"%s\", timestr);\n\tts_frac_print(ndo, usec);\n}", "target": 1}
{"code": "polkit_system_bus_name_get_creds_sync (PolkitSystemBusName           *system_bus_name,\n\t\t\t\t       guint32                       *out_uid,\n\t\t\t\t       guint32                       *out_pid,\n\t\t\t\t       GCancellable                  *cancellable,\n\t\t\t\t       GError                       **error)\n{\n  gboolean ret = FALSE;\n  AsyncGetBusNameCredsData data = { 0, };\n  GDBusConnection *connection = NULL;\n  GMainContext *tmp_context = NULL;\n  connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, cancellable, error);\n  if (connection == NULL)\n    goto out;\n  data.error = error;\n  tmp_context = g_main_context_new ();\n  g_main_context_push_thread_default (tmp_context);\n  g_dbus_connection_call (connection,\n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"/org/freedesktop/DBus\",      \n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"GetConnectionUnixUser\",      \n\t\t\t  g_variant_new (\"(s)\", system_bus_name->name),\n\t\t\t  G_VARIANT_TYPE (\"(u)\"),\n\t\t\t  G_DBUS_CALL_FLAGS_NONE,\n\t\t\t  -1,\n\t\t\t  cancellable,\n\t\t\t  on_retrieved_unix_uid_pid,\n\t\t\t  &data);\n  g_dbus_connection_call (connection,\n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"/org/freedesktop/DBus\",      \n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"GetConnectionUnixProcessID\", \n\t\t\t  g_variant_new (\"(s)\", system_bus_name->name),\n\t\t\t  G_VARIANT_TYPE (\"(u)\"),\n\t\t\t  G_DBUS_CALL_FLAGS_NONE,\n\t\t\t  -1,\n\t\t\t  cancellable,\n\t\t\t  on_retrieved_unix_uid_pid,\n\t\t\t  &data);\n  while (!((data.retrieved_uid && data.retrieved_pid) || data.caught_error))\n    g_main_context_iteration (tmp_context, TRUE);\n  if (out_uid)\n    *out_uid = data.uid;\n  if (out_pid)\n    *out_pid = data.pid;\n  ret = TRUE;\n out:\n  if (tmp_context)\n    {\n      g_main_context_pop_thread_default (tmp_context);\n      g_main_context_unref (tmp_context);\n    }\n  if (connection != NULL)\n    g_object_unref (connection);\n  return ret;\n}", "target": 1}
{"code": "uint_t aubio_tempo_set_delay(aubio_tempo_t * o, sint_t delay) {\n  o->delay = delay;\n  return AUBIO_OK;\n}", "target": 0}
{"code": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tgoto error;\n\t}\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "void SavePackage::StartSave(const SaveFileCreateInfo* info) {\n  DCHECK(info && !info->url.is_empty());\n  SaveUrlItemMap::iterator it = in_progress_items_.find(info->url.spec());\n  if (it == in_progress_items_.end()) {\n    DCHECK(canceled());\n    return;\n  }\n  SaveItem* save_item = it->second;\n  DCHECK(!saved_main_file_path_.empty());\n  save_item->SetSaveId(info->save_id);\n  save_item->SetTotalBytes(info->total_bytes);\n  DCHECK(!save_item->has_final_name());\n  if (info->url != page_url_) {\n    FilePath::StringType generated_name;\n    bool need_html_ext =\n        info->save_source == SaveFileCreateInfo::SAVE_FILE_FROM_DOM;\n    if (!GenerateFileName(info->content_disposition,\n                          GURL(info->url),\n                          need_html_ext,\n                          &generated_name)) {\n      if (info->save_source == SaveFileCreateInfo::SAVE_FILE_FROM_DOM)\n        Cancel(true);\n      else\n        SaveFinished(save_item->save_id(), 0, false);\n      return;\n    }\n    DCHECK(save_type_ == SAVE_PAGE_TYPE_AS_COMPLETE_HTML);\n    DCHECK(!saved_main_directory_path_.empty());\n    FilePath final_name = saved_main_directory_path_.Append(generated_name);\n    save_item->Rename(final_name);\n  } else {\n    save_item->Rename(saved_main_file_path_);\n  }\n  if (info->save_source == SaveFileCreateInfo::SAVE_FILE_FROM_FILE) {\n    BrowserThread::PostTask(\n        BrowserThread::FILE, FROM_HERE,\n        base::Bind(&SaveFileManager::SaveLocalFile,\n                   file_manager_,\n                   save_item->url(),\n                   save_item->save_id(),\n                   contents_id()));\n    return;\n  }\n  if (save_type_ == SAVE_PAGE_TYPE_AS_COMPLETE_HTML &&\n      wait_state_ == HTML_DATA) {\n    GetSerializedHtmlDataForCurrentPageWithLocalLinks();\n  }\n}", "target": 0}
{"code": "static void chase_port(struct edgeport_port *port, unsigned long timeout,\n\t\t\t\t\t\t\t\tint flush)\n{\n\tint baud_rate;\n\tstruct tty_struct *tty = tty_port_tty_get(&port->port->port);\n\tstruct usb_serial *serial = port->port->serial;\n \twait_queue_t wait;\n \tunsigned long flags;\n \tif (!timeout)\n \t\ttimeout = (HZ * EDGE_CLOSING_WAIT)/100;\n\tspin_lock_irqsave(&port->ep_lock, flags);\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&tty->write_wait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kfifo_len(&port->write_fifo) == 0\n\t\t|| timeout == 0 || signal_pending(current)\n\t\t|| serial->disconnected)\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tspin_lock_irqsave(&port->ep_lock, flags);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (flush)\n\t\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\ttty_kref_put(tty);\n\ttimeout += jiffies;\n\twhile ((long)(jiffies - timeout) < 0 && !signal_pending(current)\n\t\t\t\t\t\t&& !serial->disconnected) {\n\t\tif (!tx_active(port))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\tif (serial->disconnected)\n\t\treturn;\n\tbaud_rate = port->baud_rate;\n\tif (baud_rate == 0)\n\t\tbaud_rate = 50;\n\tmsleep(max(1, DIV_ROUND_UP(10000, baud_rate)));\n}", "target": 1}
{"code": "int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\tif (is_vm_hugetlb_page(vma) && (addr &\n\t\t\t\t\t~(huge_page_mask(hstate_vma(vma)))))\n\t\treturn -EINVAL;\n\tnew = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\t*new = *vma;\n\tINIT_LIST_HEAD(&new->anon_vma_chain);\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\tif (!err)\n\t\treturn 0;\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tkmem_cache_free(vm_area_cachep, new);\n\treturn err;\n}", "target": 0}
{"code": "void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t}\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_x86_ops->compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\taccumulate_steal_time(vcpu);\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}", "target": 0}
{"code": "wsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_CSI;\n\tint oargs;\n\tint rc = 0;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tcase '?': \n\tcase '>': \n\t\tedp->modif1 = (char)instate->inchar;\n\t\tbreak;\n\tcase '!':\n\tcase '\"':\n\tcase '$':\n\tcase '&':\n\t\tedp->modif2 = (char)instate->inchar;\n\t\tbreak;\n\tdefault: \n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\trc = wsemul_vt100_handle_csi(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "get_one_option(int optid, const struct my_option *opt,\n               char *argument)\n{\n  my_bool add_option= TRUE;\n  switch (optid) {\n  case '?':\n    printf(\"%s  Ver %s Distrib %s, for %s (%s)\\n\",\n           my_progname, VER, MYSQL_SERVER_VERSION, SYSTEM_TYPE, MACHINE_TYPE);\n    puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n    puts(\"MySQL utility for upgrading databases to new MySQL versions.\\n\");\n    my_print_help(my_long_options);\n    exit(0);\n    break;\n  case '#':\n    DBUG_PUSH(argument ? argument : default_dbug_option);\n    add_option= FALSE;\n    debug_check_flag= 1;\n    break;\n  case 'p':\n    if (argument == disabled_my_option)\n      argument= (char*) \"\";\t\t\t\n    tty_password= 1;\n    add_option= FALSE;\n    if (argument)\n    {\n      add_one_option(&ds_args, opt, argument);\n      while (*argument)\n        *argument++= 'x';                       \n      tty_password= 0;\n    }\n    break;\n  case 't':\n    my_stpnmov(opt_tmpdir, argument, sizeof(opt_tmpdir));\n    add_option= FALSE;\n    break;\n  case 'k':                                     \n  case 'v': \n  case 'f': \n  case 's':                                     \n  case OPT_WRITE_BINLOG:                        \n    add_option= FALSE;\n    break;\n  case 'h': \n  case 'W': \n  case 'P': \n  case 'S': \n  case OPT_MYSQL_PROTOCOL: \n  case OPT_SHARED_MEMORY_BASE_NAME: \n  case OPT_PLUGIN_DIR:                          \n  case OPT_DEFAULT_AUTH:                        \n    add_one_option(&conn_args, opt, argument);\n    break;\n  }\n  if (add_option)\n  {\n    add_one_option(&ds_args, opt, argument);\n  }\n  return 0;\n}", "target": 1}
{"code": "int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\tmemcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],\n\t\thmacs->shmac_num_idents * sizeof(__u16));\n\tep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +\n\t\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}", "target": 1}
{"code": "TEST_F(ExprMatchTest, ConstantFalseValueExpressionMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: false}\"));\n    ASSERT_FALSE(matches(BSON(\"x\" << 2)));\n}", "target": 0}
{"code": "static void codeOffset(\n  Vdbe *v,          \n  int iOffset,      \n  int iContinue     \n){\n  if( iOffset>0 ){\n    sqlite3VdbeAddOp3(v, OP_IfPos, iOffset, iContinue, 1); VdbeCoverage(v);\n    VdbeComment((v, \"OFFSET\"));\n  }\n}", "target": 0}
{"code": "get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0 &&\n\t\t   unconditional(&s->ip)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\treturn 0;\n}", "target": 1}
{"code": "void calc_group_buffer(TMP_TABLE_PARAM *param, ORDER *group)\n{\n  uint key_length=0, parts=0, null_parts=0;\n  for (; group ; group=group->next)\n  {\n    Item *group_item= *group->item;\n    Field *field= group_item->get_tmp_table_field();\n    if (field)\n    {\n      enum_field_types type;\n      if ((type= field->type()) == MYSQL_TYPE_BLOB)\n\tkey_length+=MAX_BLOB_WIDTH;\t\t\n      else if (type == MYSQL_TYPE_VARCHAR || type == MYSQL_TYPE_VAR_STRING)\n        key_length+= field->field_length + HA_KEY_BLOB_LENGTH;\n      else if (type == MYSQL_TYPE_BIT)\n      {\n        key_length+= 8;                         \n      }\n      else\n\tkey_length+= field->pack_length();\n    }\n    else\n    { \n      switch (group_item->cmp_type()) {\n      case REAL_RESULT:\n        key_length+= sizeof(double);\n        break;\n      case INT_RESULT:\n        key_length+= sizeof(longlong);\n        break;\n      case DECIMAL_RESULT:\n        key_length+= my_decimal_get_binary_size(group_item->max_length - \n                                                (group_item->decimals ? 1 : 0),\n                                                group_item->decimals);\n        break;\n      case TIME_RESULT:\n      {\n        key_length+= 8;\n        break;\n      }\n      case STRING_RESULT:\n      {\n        enum enum_field_types type= group_item->field_type();\n        if (type == MYSQL_TYPE_BLOB)\n          key_length+= MAX_BLOB_WIDTH;\t\t\n        else\n        {\n          key_length+= group_item->max_length + HA_KEY_BLOB_LENGTH;\n        }\n        break;\n      }\n      default:\n        DBUG_ASSERT(0);\n        my_error(ER_OUT_OF_RESOURCES, MYF(ME_FATAL));\n      }\n    }\n    parts++;\n    if (group_item->maybe_null)\n      null_parts++;\n  }\n  param->group_length= key_length + null_parts;\n  param->group_parts= parts;\n  param->group_null_parts= null_parts;\n}", "target": 0}
{"code": "void SerializedScriptValue::transferImageBitmaps(v8::Isolate* isolate, const ImageBitmapArray& imageBitmaps, ExceptionState& exceptionState)\n{\n    if (!imageBitmaps.size())\n        return;\n    for (size_t i = 0; i < imageBitmaps.size(); ++i) {\n        if (imageBitmaps[i]->isNeutered()) {\n            exceptionState.throwDOMException(DataCloneError, \"ImageBitmap at index \" + String::number(i) + \" is already neutered.\");\n            return;\n        }\n    }\n    OwnPtr<ImageBitmapContentsArray> contents = adoptPtr(new ImageBitmapContentsArray);\n    HeapHashSet<Member<ImageBitmap>> visited;\n    for (size_t i = 0; i < imageBitmaps.size(); ++i) {\n        if (visited.contains(imageBitmaps[i]))\n            continue;\n        visited.add(imageBitmaps[i]);\n        contents->append(imageBitmaps[i]->transfer());\n    }\n    m_imageBitmapContentsArray = contents.release();\n}", "target": 0}
{"code": "static void bpf_map_ptr_store(struct bpf_insn_aux_data *aux,\n\t\t\t      const struct bpf_map *map, bool unpriv)\n{\n\tBUILD_BUG_ON((unsigned long)BPF_MAP_PTR_POISON & BPF_MAP_PTR_UNPRIV);\n\tunpriv |= bpf_map_ptr_unpriv(aux);\n\taux->map_ptr_state = (unsigned long)map |\n\t\t\t     (unpriv ? BPF_MAP_PTR_UNPRIV : 0UL);\n}", "target": 0}
{"code": "get_indent_buf(buf_T *buf, linenr_T lnum)\n{\n# ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get_buf(buf, lnum, FALSE),\n\t\t\t       (int)curbuf->b_p_ts, buf->b_p_vts_array, FALSE);\n# else\n    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts, FALSE);\n# endif\n}", "target": 0}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "void __init shm_init(void)\n{\n\tipc_init_proc_interface(\"sysvipc/shm\",\n#if BITS_PER_LONG <= 32\n\t\t\t\t\"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\\n\",\n#else\n\t\t\t\t\"       key      shmid perms                  size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime                   rss                  swap\\n\",\n#endif\n\t\t\t\tIPC_SHM_IDS, sysvipc_shm_proc_show);\n}", "target": 0}
{"code": " asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n {\n \tconsole_verbose();\n \tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n \t\thandler[reason], esr);\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n }", "target": 1}
{"code": "static ssize_t module_xz_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\tstatic const u8 signature[] = { 0xfd, '7', 'z', 'X', 'Z', 0 };\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\tsize_t new_size = 0;\n\tssize_t retval;\n\tif (size < sizeof(signature) ||\n\t    memcmp(buf, signature, sizeof(signature))) {\n\t\tpr_err(\"not an xz compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\txz_buf.in_size = size;\n\txz_buf.in = buf;\n\txz_buf.in_pos = 0;\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\txz_buf.out = kmap_local_page(page);\n\t\txz_buf.out_pos = 0;\n\t\txz_buf.out_size = PAGE_SIZE;\n\t\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\t\tkunmap_local(xz_buf.out);\n\t\tnew_size += xz_buf.out_pos;\n\t} while (xz_buf.out_pos == PAGE_SIZE && xz_ret == XZ_OK);\n\tif (xz_ret != XZ_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", xz_ret);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tretval = new_size;\n out:\n\txz_dec_end(xz_dec);\n\treturn retval;\n}", "target": 1}
{"code": "static int redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *host, const char *url)\n{\n\tchar *originurl_raw;\n\tchar *originurl;\n\tchar *query;\n\tint ret = 0;\n\tconst char *separator = \"&\";\n\tchar *querystr;\n\tquery = safe_calloc(QUERYMAXLEN);\n\tif (!query) {\n\t\tret = send_error(connection, 503);\n\t\tfree(query);\n\t\treturn ret;\n\t}\n\tquerystr = safe_calloc(QUERYMAXLEN);\n\tif (!querystr) {\n\t\tret = send_error(connection, 503);\n\t\tfree(querystr);\n\t\treturn ret;\n\t}\n\toriginurl_raw = safe_calloc(MID_BUF);\n\tif (!originurl_raw) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl_raw);\n\t\treturn ret;\n\t}\n\toriginurl = safe_calloc(CUSTOM_ENC);\n\tif (!originurl) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl);\n\t\treturn ret;\n\t}\n\tget_query(connection, &query, separator);\n\tif (!query) {\n\t\tdebug(LOG_DEBUG, \"Unable to get query string - error 503\");\n\t\tfree(query);\n\t\treturn send_error(connection, 503);\n\t}\n\tdebug(LOG_DEBUG, \"Query string is [ %s ]\", query);\n\tsafe_asprintf(&originurl_raw, \"http:\n\tuh_urlencode(originurl, CUSTOM_ENC, originurl_raw, strlen(originurl_raw));\n\tif (strcmp(url, \"/login\") == 0) {\n\t\tclient->cpi_query = safe_strdup(originurl);\n\t\tdebug(LOG_DEBUG, \"RFC8910 request: %s\", client->cpi_query);\n\t} else {\n\t\tclient->cpi_query = \"none\";\n\t}\n\tdebug(LOG_DEBUG, \"originurl_raw: %s\", originurl_raw);\n\tdebug(LOG_DEBUG, \"originurl: %s\", originurl);\n\tquerystr=construct_querystring(connection, client, originurl, querystr);\n\tret = encode_and_redirect_to_splashpage(connection, client, originurl, querystr);\n\tfree(originurl_raw);\n\tfree(originurl);\n\tfree(query);\n\tfree(querystr);\n\treturn ret;\n}", "target": 1}
{"code": "static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}", "target": 1}
{"code": "SPICE_GNUC_VISIBLE void spice_server_set_name(SpiceServer *s, const char *name)\n{\n    g_free(s->config->spice_name);\n    s->config->spice_name = g_strdup(name);\n}", "target": 0}
{"code": "void tref_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}", "target": 0}
{"code": "int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)\n{\n\tstruct net_device *dev;\n\tstruct bnep_session *s, *ss;\n\tu8 dst[ETH_ALEN], src[ETH_ALEN];\n\tint err;\n \tBT_DBG(\"\");\n \tbaswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);\n \tbaswap((void *) src, &l2cap_pi(sock->sk)->chan->src);\n\tdev = alloc_netdev(sizeof(struct bnep_session),\n\t\t\t   (*req->device) ? req->device : \"bnep%d\",\n\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t   bnep_net_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdown_write(&bnep_session_sem);\n\tss = __bnep_get_session(dst);\n\tif (ss && ss->state == BT_CONNECTED) {\n\t\terr = -EEXIST;\n\t\tgoto failed;\n\t}\n\ts = netdev_priv(dev);\n\tmemcpy(s->eh.h_dest,   &src, ETH_ALEN);\n\tmemcpy(s->eh.h_source, &dst, ETH_ALEN);\n\tmemcpy(dev->dev_addr, s->eh.h_dest, ETH_ALEN);\n\ts->dev   = dev;\n\ts->sock  = sock;\n\ts->role  = req->role;\n\ts->state = BT_CONNECTED;\n\ts->msg.msg_flags = MSG_NOSIGNAL;\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\tset_bit(bnep_mc_hash(dev->broadcast), (ulong *) &s->mc_filter);\n#endif\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\tbnep_set_default_proto_filter(s);\n#endif\n\tSET_NETDEV_DEV(dev, bnep_get_device(s));\n\tSET_NETDEV_DEVTYPE(dev, &bnep_type);\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto failed;\n\t__bnep_link_session(s);\n\t__module_get(THIS_MODULE);\n\ts->task = kthread_run(bnep_session, s, \"kbnepd %s\", dev->name);\n\tif (IS_ERR(s->task)) {\n\t\tmodule_put(THIS_MODULE);\n\t\tunregister_netdev(dev);\n\t\t__bnep_unlink_session(s);\n\t\terr = PTR_ERR(s->task);\n\t\tgoto failed;\n\t}\n\tup_write(&bnep_session_sem);\n\tstrcpy(req->device, dev->name);\n\treturn 0;\nfailed:\n\tup_write(&bnep_session_sem);\n\tfree_netdev(dev);\n\treturn err;\n}", "target": 1}
{"code": "bool Alter_table_prelocking_strategy::\nhandle_routine(THD *thd, Query_tables_list *prelocking_ctx,\n               Sroutine_hash_entry *rt, sp_head *sp, bool *need_prelocking)\n{\n  return FALSE;\n}", "target": 0}
{"code": "static Jsi_RC SysVerConvertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *flag = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!val) goto bail;\n    if (Jsi_ValueIsNumber(interp, val)) {\n        char buf[200];\n        Jsi_Number n;\n        if (Jsi_GetNumberFromValue(interp, val, &n) != JSI_OK)\n            goto bail;\n        jsi_VersionNormalize(n, buf, sizeof(buf));\n        int trunc = 0;\n        if (flag && (Jsi_GetIntFromValue(interp, flag, &trunc) != JSI_OK\n            || trunc<0 || trunc>2))\n            return Jsi_LogError(\"arg2: bad trunc: expected int between 0 and 2\");\n        if (trunc) {\n            int len = Jsi_Strlen(buf)-1;\n            while (trunc>0 && len>1) {\n                if (buf[len] == '0' && buf[len-1] == '.')\n                    buf[len-1] = 0;\n                len -= 2;\n                trunc--;\n            }\n        }\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n        return JSI_OK;\n    }\n    if (Jsi_ValueIsString(interp, val)) {\n        Jsi_Number n;\n        if (jsi_GetVerFromVal(interp, val, &n, 0) == JSI_OK) {\n            Jsi_ValueMakeNumber(interp, ret, n);\n            return JSI_OK;\n        }\n    }\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}", "target": 1}
{"code": "void comps_objrtree_unite(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_ObjRTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjRTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL) {\n                    comps_objrtree_set(rt1, pair->key,\n                                      (((COMPS_ObjRTreeData*)it->data)->data));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}", "target": 1}
{"code": "std::string GdkAtomToString(const GdkAtom& atom) {\n  gchar* name = gdk_atom_name(atom);\n  std::string rv(name);\n  g_free(name);\n  return rv;\n}", "target": 0}
{"code": "GF_Err gf_isom_avc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, 0, GF_FALSE);\n}", "target": 0}
{"code": "int xmkstemp(char **tmpname, char *dir)\n{\n\tchar *localtmp;\n\tchar *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\tif (dir != NULL)\n\t\ttmpenv = dir;\n\telse\n\t\ttmpenv = getenv(\"TMPDIR\");\n\tif (tmpenv)\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,\n\t\t\t  program_invocation_short_name);\n\telse\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,\n\t\t\t  program_invocation_short_name);\n\tif (rc < 0)\n\t\treturn -1;\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}\n\t*tmpname = localtmp;\n\treturn fd;\n}", "target": 1}
{"code": "    void CiffHeader::print(std::ostream& os, const std::string& prefix) const\n    {\n        std::ios::fmtflags f( os.flags() );\n        os << prefix\n           << _(\"Header, offset\") << \" = 0x\" << std::setw(8) << std::setfill('0')\n           << std::hex << std::right << offset_ << \"\\n\";\n        if (pRootDir_) pRootDir_->print(os, byteOrder_, prefix);\n        os.flags(f);\n    } ", "target": 0}
{"code": "static void XMLCDECL xmlNoValidityErr(void *ctx ATTRIBUTE_UNUSED,\n                                const char *msg ATTRIBUTE_UNUSED, ...) {\n    return;\n}", "target": 0}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "bool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbPlaintextData_longlong;\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n    *pcbPlaintextData = pcbPlaintextData_longlong;\n    return nDecryptResult == 0;\n}", "target": 1}
{"code": "static void __mcheck_cpu_clear_vendor(struct cpuinfo_x86 *c)\n{\n\tswitch (c->x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\tmce_intel_feature_clear(c);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": " static void queue_delete(struct snd_seq_queue *q)\n {\n \tsnd_seq_timer_stop(q->timer);\n \tsnd_seq_timer_close(q);\n \tsnd_use_lock_sync(&q->use_lock);\n\tsnd_seq_prioq_delete(&q->tickq);\n\tsnd_seq_prioq_delete(&q->timeq);\n\tsnd_seq_timer_delete(&q->timer);\n\tkfree(q);\n}", "target": 1}
{"code": "jd_to_nth_kday(VALUE jd, double sg,\n\t       VALUE *nth, int *rjd,\n\t       int *ry, int *rm, int *rn, int *rk)\n{\n    decode_jd(jd, nth, rjd);\n    c_jd_to_nth_kday(*rjd, sg, ry, rm, rn, rk);\n}", "target": 0}
{"code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tremain = dp->logicalSize - dp->pos;\n \tif(remain >= len) {\n \t\trlen = len;\n \t} else {\n\t\tif(remain == 0) {\n\t\t\treturn 0; \n\t\t}\n\t\trlen = remain;\n\t}\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "void promote_select_describe_flag_if_needed(LEX *lex)\n{\n  if (lex->describe)\n  {\n    lex->select_lex.options |= SELECT_DESCRIBE;\n  }\n}", "target": 0}
{"code": "int Item_decimal::save_in_field(Field *field, bool no_conversions)\n{\n  field->set_notnull();\n  return field->store_decimal(&decimal_value);\n}", "target": 0}
{"code": "void ThreadWatcher::OnPingMessage(const BrowserThread::ID& thread_id,\n                                  const base::Closure& callback_task) {\n  DCHECK(BrowserThread::CurrentlyOn(thread_id));\n  WatchDogThread::PostTask(FROM_HERE, callback_task);\n}", "target": 0}
{"code": "static inline bool hackAroundLibXMLEntityBug(void* closure)\n{\n#if LIBXML_VERSION >= 20627\n    UNUSED_PARAM(closure);\n    return false;\n#else\n    return static_cast<xmlParserCtxtPtr>(closure)->node;\n#endif\n}", "target": 0}
{"code": "static uint8_t pfkey_proto_to_xfrm(uint8_t proto)\n{\n\treturn proto == IPSEC_PROTO_ANY ? 0 : proto;\n}", "target": 0}
{"code": "ieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct sta_info *sta = tx->sta;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_local *local = tx->local;\n\tif (unlikely(!sta))\n\t\treturn TX_CONTINUE;\n\tif (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DRIVER)) &&\n\t\t     !(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER))) {\n\t\tint ac = skb_get_queue_mapping(tx->skb);\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d: PS buffer for AC %d\\n\",\n \t\t       sta->sta.addr, sta->sta.aid, ac);\n \t\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n \t\t\tpurge_old_ps_buffers(tx->local);\n \t\tif (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {\n \t\t\tstruct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);\n \t\t\tps_dbg(tx->sdata,\n\t\t\t       \"STA %pM TX buffer for AC %d full - dropping oldest frame\\n\",\n\t\t\t       sta->sta.addr, ac);\n\t\t\tieee80211_free_txskb(&local->hw, old);\n\t\t} else\n\t\t\ttx->local->total_ps_buffered++;\n\t\tinfo->control.jiffies = jiffies;\n\t\tinfo->control.vif = &tx->sdata->vif;\n \t\tinfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n \t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n \t\tskb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);\n \t\tif (!timer_pending(&local->sta_cleanup))\n \t\t\tmod_timer(&local->sta_cleanup,\n\t\t\t\t  round_jiffies(jiffies +\n\t\t\t\t\t\tSTA_INFO_CLEANUP_INTERVAL));\n\t\tsta_info_recalc_tim(sta);\n\t\treturn TX_QUEUED;\n\t} else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"STA %pM in PS mode, but polling/in SP -> send frame\\n\",\n\t\t       sta->sta.addr);\n\t}\n\treturn TX_CONTINUE;\n}", "target": 1}
{"code": "ConnStateData::checkLogging()\n{\n    if (bodyPipe)\n        return;\n    if (!pipeline.empty() && pipeline.back()->mayUseConnection())\n        return;\n    if (pipeline.nrequests && inBuf.isEmpty())\n        return;\n    ClientHttpRequest http(this);\n    http.req_sz = inBuf.length();\n    http.setErrorUri(\"error:transaction-end-before-headers\");\n}", "target": 0}
{"code": "onigenc_not_support_get_ctype_code_range(OnigCtype ctype,\n                       OnigCodePoint* sb_out, const OnigCodePoint* ranges[],\n\t\t       OnigEncoding enc)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}", "target": 0}
{"code": "nextvar(\n\tint *datalen,\n\tconst char **datap,\n\tchar **vname,\n\tchar **vvalue\n\t)\n{\n\tconst char *cp;\n\tconst char *np;\n\tconst char *cpend;\n\tsize_t srclen;\n\tsize_t len;\n\tstatic char name[MAXVARLEN];\n\tstatic char value[MAXVALLEN];\n\tcp = *datap;\n\tcpend = cp + *datalen;\n\twhile (cp < cpend && (*cp == ',' || isspace((int)*cp)))\n\t\tcp++;\n\tif (cp >= cpend)\n\t\treturn 0;\n\tsrclen = strcspn(cp, \",=\\r\\n\");\n\tsrclen = min(srclen, (size_t)(cpend - cp));\n\tlen = srclen;\n\twhile (len > 0 && isspace((unsigned char)cp[len - 1]))\n\t\tlen--;\n\tif (len > 0)\n\t\tmemcpy(name, cp, len);\n\tname[len] = '\\0';\n\t*vname = name;\n\tcp += srclen;\n\tif (cp >= cpend || *cp == ',' || *cp == '\\r' || *cp == '\\n') {\n\t\tif (cp < cpend)\n\t\t\tcp++;\n\t\t*datap = cp;\n\t\t*datalen = cpend - cp;\n\t\t*vvalue = NULL;\n\t\treturn 1;\n\t}\n\tcp++;\t\n\twhile (cp < cpend && (isspace((unsigned char)*cp) && *cp != '\\r' && *cp != '\\n'))\n\t\tcp++;\n\tnp = cp;\n\tif ('\"' == *np) {\n\t\tdo {\n\t\t\tnp++;\n\t\t} while (np < cpend && '\"' != *np);\n\t\tif (np < cpend && '\"' == *np)\n\t\t\tnp++;\n\t} else {\n\t\twhile (np < cpend && ',' != *np && '\\r' != *np)\n\t\t\tnp++;\n\t}\n\tlen = np - cp;\n\tif (np > cpend || len >= sizeof(value) ||\n\t    (np < cpend && ',' != *np && '\\r' != *np))\n\t\treturn 0;\n\tmemcpy(value, cp, len);\n\twhile (len > 0 && isspace((unsigned char)value[len - 1]))\n\t\tlen--;\n\tvalue[len] = '\\0';\n\tif (np < cpend && ',' == *np)\n\t\tnp++;\n\t*datap = np;\n\t*datalen = cpend - np;\n\t*vvalue = value;\n\treturn 1;\n}", "target": 1}
{"code": "emacs_tags_incstack_free(void)\n{\n    while (incstack_idx)\n    {\n\t--incstack_idx;\n\tfclose(incstack[incstack_idx].fp);\n\tincstack[incstack_idx].fp = NULL;\n\tVIM_CLEAR(incstack[incstack_idx].etag_fname);\n    }\n}", "target": 0}
{"code": "static inline int route4_hash_iif(int iif)\n{\n\treturn 16 + ((iif >> 16) & 0xF);\n}", "target": 0}
{"code": "FunctionDef FunctionDefHelper::Define(gtl::ArraySlice<string> arg_def,\n                                      gtl::ArraySlice<string> ret_def,\n                                      gtl::ArraySlice<string> attr_def,\n                                      gtl::ArraySlice<Node> node_def) {\n  return Define(\"_\", arg_def, ret_def, attr_def, node_def);\n}", "target": 0}
{"code": "folly::Optional<TLSMessage> PlaintextReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    folly::io::Cursor cursor(buf.front());\n    if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {\n      return folly::none;\n    }\n    TLSMessage msg;\n    msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n    if (skipEncryptedRecords_) {\n      if (msg.type == ContentType::application_data) {\n        cursor.skip(sizeof(ProtocolVersion));\n        auto length = cursor.readBE<uint16_t>();\n        if (buf.chainLength() < (cursor - buf.front()) + length) {\n          return folly::none;\n        }\n        length +=\n            sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n        buf.trimStart(length);\n        continue;\n      } else if (msg.type != ContentType::change_cipher_spec) {\n        skipEncryptedRecords_ = false;\n      }\n    }\n    switch (msg.type) {\n      case ContentType::handshake:\n      case ContentType::alert:\n        break;\n      case ContentType::change_cipher_spec:\n        break;\n      default:\n        throw std::runtime_error(folly::to<std::string>(\n            \"received plaintext content type \",\n            static_cast<ContentTypeType>(msg.type),\n            \", header: \",\n            folly::hexlify(buf.splitAtMost(10)->coalesce())));\n    }\n    receivedRecordVersion_ =\n        static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());\n    auto length = cursor.readBE<uint16_t>();\n    if (length > kMaxPlaintextRecordSize) {\n      throw std::runtime_error(\"received too long plaintext record\");\n    }\n    if (length == 0) {\n      throw std::runtime_error(\"received empty plaintext record\");\n    }\n    if (buf.chainLength() < (cursor - buf.front()) + length) {\n      return folly::none;\n    }\n    cursor.clone(msg.fragment, length);\n    buf.trimStart(cursor - buf.front());\n    if (msg.type == ContentType::change_cipher_spec) {\n      msg.fragment->coalesce();\n      if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n    return std::move(msg);\n  }\n}", "target": 1}
{"code": "static __init int activate_jump_labels(void)\n{\n\tif (has_steal_clock) {\n\t\tstatic_key_slow_inc(&paravirt_steal_enabled);\n\t\tif (steal_acc)\n\t\t\tstatic_key_slow_inc(&paravirt_steal_rq_enabled);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "struct nft_flow_rule *nft_flow_rule_create(struct net *net,\n\t\t\t\t\t   const struct nft_rule *rule)\n{\n\tstruct nft_offload_ctx *ctx;\n\tstruct nft_flow_rule *flow;\n\tint num_actions = 0, err;\n\tstruct nft_expr *expr;\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (expr->ops->offload_flags & NFT_OFFLOAD_F_ACTION)\n\t\t\tnum_actions++;\n\t\texpr = nft_expr_next(expr);\n\t}\n\tif (num_actions == 0)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tflow = nft_flow_rule_alloc(num_actions);\n\tif (!flow)\n\t\treturn ERR_PTR(-ENOMEM);\n\texpr = nft_expr_first(rule);\n\tctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tctx->net = net;\n\tctx->dep.type = NFT_OFFLOAD_DEP_UNSPEC;\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (!expr->ops->offload) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = expr->ops->offload(ctx, flow, expr);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t\texpr = nft_expr_next(expr);\n\t}\n\tnft_flow_rule_transfer_vlan(ctx, flow);\n\tflow->proto = ctx->dep.l3num;\n\tkfree(ctx);\n\treturn flow;\nerr_out:\n\tkfree(ctx);\n\tnft_flow_rule_destroy(flow);\n\treturn ERR_PTR(err);\n}", "target": 1}
{"code": "static int i740fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset\t= var->green.offset = var->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (var->green.length) {\n\t\tdefault:\n\t\tcase 5:\n\t\t\tvar->red.offset = 10;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length\t= 5;\n\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.length = 5;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tvar->red.offset = 11;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length = var->blue.length = 5;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->transp.length = 8;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\tif (info->monspecs.hfmax && info->monspecs.vfmax &&\n\t    info->monspecs.dclkmax && fb_validate_mode(var, info) < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "  void* GetData() { return embedder_data_; }", "target": 0}
{"code": "TfLiteStatus PrepareHashtableSize(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, output_tensor->type, kTfLiteInt64);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, output_tensor, outputSize);\n}", "target": 1}
{"code": "date_s__valid_weeknum_p(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE vy, vw, vd, vf, vsg;\n    VALUE argv2[5];\n    rb_scan_args(argc, argv, \"41\", &vy, &vw, &vd, &vf, &vsg);\n    argv2[0] = vy;\n    argv2[1] = vw;\n    argv2[2] = vd;\n    argv2[3] = vf;\n    if (argc < 5)\n\targv2[4] = DBL2NUM(GREGORIAN);\n    else\n\targv2[4] = vsg;\n    return valid_weeknum_sub(5, argv2, klass, 1);\n}", "target": 0}
{"code": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\tND_PRINT((ndo,\" len=%d method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (1 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" authdata=(\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo,\") \"));\n\t} else if(ndo->ndo_vflag && 4 < len) {\n\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n\t}\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n \tif (ops->init)\n \t\tops->init(dev);\n \tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n \tif (ret < 0) {\n \t\tmutex_lock(&kvm->lock);\n \t\tlist_del(&dev->vm_node);\n \t\tmutex_unlock(&kvm->lock);\n \t\tops->destroy(dev);\n \t\treturn ret;\n \t}\n\tkvm_get_kvm(kvm);\n \tcd->fd = ret;\n \treturn 0;\n }", "target": 1}
{"code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    auto* resource = node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      outer_context->set_output_handle_shapes_and_types(index, *resource);\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "void Hybrid_type_traits_decimal::div(Hybrid_type *val, ulonglong u) const\n{\n  int2my_decimal(E_DEC_FATAL_ERROR, u, TRUE, &val->dec_buf[2]);\n  my_decimal_div(E_DEC_FATAL_ERROR,\n                 &val->dec_buf[val->used_dec_buf_no ^ 1],\n                 &val->dec_buf[val->used_dec_buf_no],\n                 &val->dec_buf[2], 4);\n  val->used_dec_buf_no^= 1;\n}", "target": 0}
{"code": "status_t MPEG4Extractor::parse3GPPMetaData(off64_t offset, size_t size, int depth) {\n if (size < 4 || size == SIZE_MAX) {\n return ERROR_MALFORMED;\n }\n uint8_t *buffer = new (std::nothrow) uint8_t[size + 1];\n if (buffer == NULL) {\n return ERROR_MALFORMED;\n }\n if (mDataSource->readAt(\n                offset, buffer, size) != (ssize_t)size) {\n delete[] buffer;\n        buffer = NULL;\n return ERROR_IO;\n }\n uint32_t metadataKey = 0;\n switch (mPath[depth]) {\n case FOURCC('t', 'i', 't', 'l'):\n {\n            metadataKey = kKeyTitle;\n break;\n }\n case FOURCC('p', 'e', 'r', 'f'):\n {\n            metadataKey = kKeyArtist;\n break;\n }\n case FOURCC('a', 'u', 't', 'h'):\n {\n            metadataKey = kKeyWriter;\n break;\n }\n case FOURCC('g', 'n', 'r', 'e'):\n {\n            metadataKey = kKeyGenre;\n break;\n }\n case FOURCC('a', 'l', 'b', 'm'):\n {\n if (buffer[size - 1] != '\\0') {\n char tmp[4];\n              sprintf(tmp, \"%u\", buffer[size - 1]);\n              mFileMetaData->setCString(kKeyCDTrackNumber, tmp);\n }\n            metadataKey = kKeyAlbum;\n break;\n }\n case FOURCC('y', 'r', 'r', 'c'):\n {\n char tmp[5];\n uint16_t year = U16_AT(&buffer[4]);\n if (year < 10000) {\n                sprintf(tmp, \"%u\", year);\n                mFileMetaData->setCString(kKeyYear, tmp);\n }\n break;\n }\n default:\n break;\n }\n if (metadataKey > 0) {\n bool isUTF8 = true; \n char16_t *framedata = NULL;\n         int len16 = 0; \n         if (size - 6 >= 4) {\n             len16 = ((size - 6) / 2) - 1; \n             framedata = (char16_t *)(buffer + 6);\n if (0xfffe == *framedata) {\n for (int i = 0; i < len16; i++) {\n                    framedata[i] = bswap_16(framedata[i]);\n }\n }\n if (0xfeff == *framedata) {\n                framedata++;\n                len16--;\n                isUTF8 = false;\n }\n }\n if (isUTF8) {\n            buffer[size] = 0;\n            mFileMetaData->setCString(metadataKey, (const char *)buffer + 6);\n } else {\n String8 tmpUTF8str(framedata, len16);\n            mFileMetaData->setCString(metadataKey, tmpUTF8str.string());\n }\n }\n delete[] buffer;\n    buffer = NULL;\n return OK;\n}", "target": 1}
{"code": "redraw_buf_and_status_later(buf_T *buf, int type)\n{\n    win_T\t*wp;\n#ifdef FEAT_WILDMENU\n    if (wild_menu_showing != 0)\n\treturn;\n#endif\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer == buf)\n\t{\n\t    redraw_win_later(wp, type);\n\t    wp->w_redr_status = TRUE;\n\t}\n    }\n}", "target": 0}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "    inline char lowercase(const char x) {\n      return (char)((x<'A'||x>'Z')?x:x - 'A' + 'a');", "target": 0}
{"code": "static AMQP_VALUE test_on_transfer_received(void* context, TRANSFER_HANDLE transfer, uint32_t payload_size, const unsigned char* payload_bytes)\n{\n    (void)context;\n    test_on_transfer_received_transfer = transfer;\n    test_on_transfer_received_payload_size = payload_size;\n    memcpy(test_on_transfer_received_payload_bytes, payload_bytes, payload_size);\n    return (AMQP_VALUE)0x6000;\n}", "target": 0}
{"code": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\tret = buf[1];\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}", "target": 1}
{"code": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\tfile->f_flags = op->open_flag;\n \tif (unlikely(file->f_flags & __O_TMPFILE)) {\n \t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n \t}\n \terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { \n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n \t}\n out:\n \tpath_cleanup(nd);\n \tif (!(opened & FILE_OPENED)) {\n \t\tBUG_ON(!error);\n \t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}", "target": 1}
{"code": "void Document::UpdateStyleAndLayoutIgnorePendingStylesheets(\n    Document::RunPostLayoutTasks run_post_layout_tasks) {\n  UpdateStyleAndLayoutTreeIgnorePendingStylesheets();\n  UpdateStyleAndLayout();\n  if (run_post_layout_tasks == kRunPostLayoutTasksSynchronously && View())\n    View()->FlushAnyPendingPostLayoutTasks();\n}", "target": 0}
{"code": "partition_table_create_data_new (DBusGMethodInvocation *context,\n                                 Device *device,\n                                 const char *scheme)\n{\n  CreatePartitionTableData *data;\n  data = g_new0 (CreatePartitionTableData, 1);\n  data->refcount = 1;\n  data->context = context;\n  data->device = g_object_ref (device);\n  data->scheme = g_strdup (scheme);\n  return data;\n}", "target": 0}
{"code": "fbFetch_b5g6r5 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD16 *pixel = (const CARD16 *)bits + x;\n    const CARD16 *end = pixel + width;\n    while (pixel < end) {\n        CARD32  p = READ(pixel++);\n        CARD32  r,g,b;\n        b = ((p & 0xf800) | ((p & 0xe000) >> 5)) >> 8;\n        g = ((p & 0x07e0) | ((p & 0x0600) >> 6)) << 5;\n        r = ((p & 0x001c) | ((p & 0x001f) << 5)) << 14;\n        WRITE(buffer++, (0xff000000 | r | g | b));\n    }\n}", "target": 0}
{"code": "static void disk_del_events(struct gendisk *disk)\n{\n\tif (!disk->ev)\n\t\treturn;\n\tdisk_block_events(disk);\n\tmutex_lock(&disk_events_mutex);\n\tlist_del_init(&disk->ev->node);\n\tmutex_unlock(&disk_events_mutex);\n\tsysfs_remove_files(&disk_to_dev(disk)->kobj, disk_events_attrs);\n}", "target": 0}
{"code": "    kssl_keytab_is_available(KSSL_CTX *kssl_ctx)\n{\n    krb5_context\t\tkrb5context = NULL;\n    krb5_keytab \t\tkrb5keytab = NULL;\n    krb5_keytab_entry           entry;\n    krb5_principal              princ = NULL;\n    krb5_error_code  \t\tkrb5rc = KRB5KRB_ERR_GENERIC;\n    int rc = 0;\n    if ((krb5rc = krb5_init_context(&krb5context)))\n        return(0);\n    if (kssl_ctx->keytab_file)\n    {\n        krb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,\n                                  &krb5keytab);\n        if (krb5rc)\n            goto exit;\n    }\n    else\n    {\n        krb5rc = krb5_kt_default(krb5context,&krb5keytab);\n        if (krb5rc)\n            goto exit;\n    }\n    krb5rc = krb5_sname_to_principal(krb5context, NULL, \n                                     kssl_ctx->service_name ? kssl_ctx->service_name: KRB5SVC,\n                                     KRB5_NT_SRV_HST, &princ);\n    krb5rc = krb5_kt_get_entry(krb5context, krb5keytab, \n                                princ,\n                                0 ,\n                                0 ,\n                                &entry);\n    if ( krb5rc == KRB5_KT_NOTFOUND ) {\n        rc = 1;\n        goto exit;\n    } else if ( krb5rc )\n        goto exit;\n    krb5_kt_free_entry(krb5context, &entry);\n    rc = 1;\n  exit:\n    if (krb5keytab)     krb5_kt_close(krb5context, krb5keytab);\n    if (princ)          krb5_free_principal(krb5context, princ);\n    if (krb5context)\tkrb5_free_context(krb5context);\n    return(rc);\n}", "target": 1}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_BASE + DRAM1_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\tif (dst < prot_start && dst > prot_start - len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static ChannelSecurityOptions *reds_find_channel_security(RedsState *reds, int id)\n{\n    ChannelSecurityOptions *now = reds->config->channels_security;\n    while (now && now->channel_id != id) {\n        now = now->next;\n    }\n    return now;\n}", "target": 0}
{"code": "AudioSource::AudioSource(\n audio_source_t inputSource, const String16 &opPackageName,\n uint32_t sampleRate, uint32_t channelCount, uint32_t outSampleRate)\n     : mStarted(false),\n       mSampleRate(sampleRate),\n       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),\n       mPrevSampleTimeUs(0),\n       mFirstSampleTimeUs(-1ll),\n       mNumFramesReceived(0),\n       mNumClientOwnedBuffers(0) {\n     ALOGV(\"sampleRate: %u, outSampleRate: %u, channelCount: %u\",\n            sampleRate, outSampleRate, channelCount);\n    CHECK(channelCount == 1 || channelCount == 2);\n    CHECK(sampleRate > 0);\n size_t minFrameCount;\n status_t status = AudioRecord::getMinFrameCount(&minFrameCount,\n                                           sampleRate,\n                                           AUDIO_FORMAT_PCM_16_BIT,\n                                           audio_channel_in_mask_from_count(channelCount));\n if (status == OK) {\n uint32_t frameCount = kMaxBufferSize / sizeof(int16_t) / channelCount;\n size_t bufCount = 2;\n while ((bufCount * frameCount) < minFrameCount) {\n            bufCount++;\n }\n        mRecord = new AudioRecord(\n                    inputSource, sampleRate, AUDIO_FORMAT_PCM_16_BIT,\n                    audio_channel_in_mask_from_count(channelCount),\n                    opPackageName,\n (size_t) (bufCount * frameCount),\n AudioRecordCallbackFunction,\n this,\n                    frameCount );\n        mInitCheck = mRecord->initCheck();\n if (mInitCheck != OK) {\n            mRecord.clear();\n }\n } else {\n        mInitCheck = status;\n }\n}", "target": 1}
{"code": "static const char* lua_ap_get_server_name(request_rec* r)\n{\n    const char *name;\n    name = ap_get_server_name(r);\n    return name ? name : \"localhost\";\n}", "target": 0}
{"code": "void PeerListWidget::updatePeer(const QString &ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    QStandardItem *item = m_peerItems.value(ip);\n    int row = item->row();\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n            m_missingFlags.remove(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n}", "target": 1}
{"code": "TEST(HeaderMapImplTest, DoubleInlineSet) {\n  TestRequestHeaderMapImpl headers;\n  headers.setReferenceKey(Headers::get().ContentType, \"blah\");\n  headers.setReferenceKey(Headers::get().ContentType, \"text/html\");\n  EXPECT_EQ(\"text/html\", headers.getContentTypeValue());\n  EXPECT_EQ(1UL, headers.size());\n}", "target": 0}
{"code": "imapx_server_info_changed_cb (CamelIMAPXSummary *summary,\n\t\t\t      CamelMessageInfo *info,\n\t\t\t      gpointer user_data)\n{\n\tGHashTable *changed_meanwhile = user_data;\n\tg_return_if_fail (info != NULL);\n\tg_return_if_fail (changed_meanwhile != NULL);\n\tif (camel_message_info_uid (info)) {\n\t\tg_hash_table_insert (changed_meanwhile,\n\t\t\t(gpointer) camel_pstring_strdup (camel_message_info_uid (info)),\n\t\t\tGINT_TO_POINTER (1));\n\t}\n}", "target": 0}
{"code": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n \tmemset((void *) &saddr, 0, sizeof(saddr));\n \tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n \tsaddr.sin_port = htons(port);\n \tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\treturn sfd;\n}", "target": 1}
{"code": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\tkfree(old);\n\treturn count;\n}", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n \tstatic u32 challenge_timestamp;\n \tstatic unsigned int challenge_count;\n \tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n \tif (tcp_oow_rate_limited(sock_net(sk), skb,\n \t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n \t\t\t\t &tp->last_oow_ack_time))\n \t\treturn;\n \tnow = jiffies / HZ;\n \tif (now != challenge_timestamp) {\n \t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n \t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n \t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n \t\ttcp_send_ack(sk);\n \t}\n}", "target": 1}
{"code": "    Loader::UniquePtr createLoaderXmpJpeg(PreviewId id, const Image &image, int parIdx)\n    {\n        return Loader::UniquePtr(new LoaderXmpJpeg(id, image, parIdx));\n    }", "target": 0}
{"code": "int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\ttemp = bridge->current_size;\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\tnum_entries -= agp_memory_reserved/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\treturn -EINVAL;\n\t}\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\tj = pg_start;\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}", "target": 1}
{"code": "static int extractRDNSequence(struct ndpi_packet_struct *packet,\n\t\t\t      u_int offset, char *buffer, u_int buffer_len,\n\t\t\t      char *rdnSeqBuf, u_int *rdnSeqBuf_offset,\n\t\t\t      u_int rdnSeqBuf_len,\n\t\t\t      const char *label) {\n  u_int8_t str_len = packet->payload[offset+4], is_printable = 1;\n  char *str;\n  u_int len, j;\n  if((offset+4+str_len) >= packet->payload_packet_len)\n    return(-1);\n  str = (char*)&packet->payload[offset+5];\n  len = (u_int)ndpi_min(str_len, buffer_len-1);\n  strncpy(buffer, str, len);\n  buffer[len] = '\\0';\n  for(j = 0; j < len; j++) {\n    if(!ndpi_isprint(buffer[j])) {\n      is_printable = 0;\n      break;\n    }\n  }\n  if(is_printable) {\n    int rc = snprintf(&rdnSeqBuf[*rdnSeqBuf_offset],\n\t\t      rdnSeqBuf_len-(*rdnSeqBuf_offset),\n\t\t      \"%s%s=%s\", (*rdnSeqBuf_offset > 0) ? \", \" : \"\",\n\t\t      label, buffer);\n    if(rc > 0)\n      (*rdnSeqBuf_offset) += rc;\n  }\n  return(is_printable);\n}", "target": 1}
{"code": "unsigned int bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {\n    std::pair<unsigned int, Sirikata::JpegError> retval;\n    if (byte_bound != 0 && byte_position + bytes_to_write > byte_bound) {\n        size_t real_bytes_to_write = byte_bound - byte_position;\n        byte_position += real_bytes_to_write;\n        retval = parent->Write(reinterpret_cast<const unsigned char*>(from), real_bytes_to_write);\n        if (retval.first < real_bytes_to_write) {\n            err = retval.second;\n            return retval.first;\n        }\n        return bytes_to_write; \n    }\n    size_t total = bytes_to_write;\n    retval = parent->Write(reinterpret_cast<const unsigned char*>(from), total);\n    unsigned int written = retval.first;\n    byte_position += written;\n    if (written < total ) {\n        err = retval.second;\n        return written;\n    }\n    return bytes_to_write;\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));\n\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));\n\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);\n\tfree(name);\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPrintf(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"};\\n\");\n}", "target": 1}
{"code": "m_split(struct mbuf *m0, int len0, int wait)\n{\n\tstruct mbuf *m, *n;\n\tunsigned len = len0, remain, olen;\n\tfor (m = m0; m && len > m->m_len; m = m->m_next)\n\t\tlen -= m->m_len;\n\tif (m == NULL)\n\t\treturn (NULL);\n\tremain = m->m_len - len;\n\tif (m0->m_flags & M_PKTHDR) {\n\t\tMGETHDR(n, wait, m0->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tif (m_dup_pkthdr(n, m0, wait)) {\n\t\t\tm_freem(n);\n\t\t\treturn (NULL);\n\t\t}\n\t\tn->m_pkthdr.len -= len0;\n\t\tolen = m0->m_pkthdr.len;\n\t\tm0->m_pkthdr.len = len0;\n\t\tif (remain == 0) {\n\t\t\tn->m_next = m->m_next;\n\t\t\tm->m_next = NULL;\n\t\t\tn->m_len = 0;\n\t\t\treturn (n);\n\t\t}\n\t\tif (m->m_flags & M_EXT)\n\t\t\tgoto extpacket;\n\t\tif (remain > MHLEN) {\n\t\t\tm_align(n, 0);\n\t\t\tn->m_next = m_split(m, len, wait);\n\t\t\tif (n->m_next == NULL) {\n\t\t\t\t(void) m_free(n);\n\t\t\t\tm0->m_pkthdr.len = olen;\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\tn->m_len = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t} else\n\t\t\tm_align(n, remain);\n\t} else if (remain == 0) {\n\t\tn = m->m_next;\n\t\tm->m_next = NULL;\n\t\treturn (n);\n\t} else {\n\t\tMGET(n, wait, m->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tm_align(n, remain);\n\t}\nextpacket:\n\tif (m->m_flags & M_EXT) {\n\t\tn->m_ext = m->m_ext;\n\t\tMCLADDREFERENCE(m, n);\n\t\tn->m_data = m->m_data + len;\n\t} else {\n\t\tmemcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);\n\t}\n\tn->m_len = remain;\n\tm->m_len = len;\n\tn->m_next = m->m_next;\n\tm->m_next = NULL;\n\treturn (n);\n}", "target": 1}
{"code": "m_sf_in_sec(union DateData *x)\n{\n    return ns_to_sec(m_sf(x));\n}", "target": 0}
{"code": "static void GetStandardDeviationPixelList(PixelList *pixel_list,\n  MagickPixelPacket *pixel)\n{\n  MagickRealType\n    sum,\n    sum_squared;\n  SkipList\n    *list;\n  ssize_t\n    channel;\n  size_t\n    color;\n  ssize_t\n    count;\n  unsigned short\n    channels[ListChannels];\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    sum=0.0;\n    sum_squared=0.0;\n    do\n    {\n      ssize_t\n        i;\n      color=list->nodes[color].next[0];\n      sum+=(MagickRealType) list->nodes[color].count*color;\n      for (i=0; i < (ssize_t) list->nodes[color].count; i++)\n        sum_squared+=((MagickRealType) color)*((MagickRealType) color);\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    sum/=pixel_list->length;\n    sum_squared/=pixel_list->length;\n    channels[channel]=(unsigned short) sqrt(sum_squared-(sum*sum));\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}", "target": 0}
{"code": "static void ppp_cp_parse_cr(struct net_device *dev, u16 pid, u8 id,\n\t\t\t    unsigned int req_len, const u8 *data)\n{\n\tstatic u8 const valid_accm[6] = { LCP_OPTION_ACCM, 6, 0, 0, 0, 0 };\n\tconst u8 *opt;\n\tu8 *out;\n\tunsigned int len = req_len, nak_len = 0, rej_len = 0;\n\tif (!(out = kmalloc(len, GFP_ATOMIC))) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\t\n\t}\n\tfor (opt = data; len; len -= opt[1], opt += opt[1]) {\n\t\tif (len < 2 || len < opt[1]) {\n\t\t\tdev->stats.rx_errors++;\n\t\t\tkfree(out);\n\t\t\treturn; \n\t\t}\n\t\tif (pid == PID_LCP)\n\t\t\tswitch (opt[0]) {\n\t\t\tcase LCP_OPTION_MRU:\n\t\t\t\tcontinue; \n\t\t\tcase LCP_OPTION_ACCM: \n\t\t\t\tif (!memcmp(opt, valid_accm,\n\t\t\t\t\t    sizeof(valid_accm)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!rej_len) { \n\t\t\t\t\tmemcpy(out + nak_len, valid_accm,\n\t\t\t\t\t       sizeof(valid_accm));\n\t\t\t\t\tnak_len += sizeof(valid_accm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LCP_OPTION_MAGIC:\n\t\t\t\tif (opt[1] != 6 || (!opt[2] && !opt[3] &&\n\t\t\t\t\t\t    !opt[4] && !opt[5]))\n\t\t\t\t\tbreak; \n\t\t\t\tcontinue;\n\t\t\t}\n\t\tmemcpy(out + rej_len, opt, opt[1]);\n\t\trej_len += opt[1];\n\t}\n\tif (rej_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_REJ, id, rej_len, out);\n\telse if (nak_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_NAK, id, nak_len, out);\n\telse\n\t\tppp_cp_event(dev, pid, RCR_GOOD, CP_CONF_ACK, id, req_len, data);\n\tkfree(out);\n}", "target": 1}
{"code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\tR_FREE (prelink_range);\n\t*bin_obj = obj;\n\tr_list_push (pending_bin_files, bf);\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\treturn true;\nbeach:\n\tr_buf_free (fbuf);\n\tobj->cache_buf = NULL;\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}", "target": 1}
{"code": "void CallInfo::set_handle(const methodHandle& resolved_method,\n                          Handle resolved_appendix,\n                          Handle resolved_method_type, TRAPS) {\n  set_handle(SystemDictionary::MethodHandle_klass(), resolved_method, resolved_appendix, resolved_method_type, CHECK);\n}", "target": 0}
{"code": "static inline QString toString(bool b)\n{\n    return b ? QLatin1String(\"true\") : QLatin1String(\"false\");\n}", "target": 0}
{"code": "xsltProcessingInstructionComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemPIPtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemPIPtr) xsltNewStylePreComp(style, XSLT_FUNC_PI);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_PI);\n#endif\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n    comp->name = xsltEvalStaticAttrValueTemplate(style, inst,\n\t\t\t\t (const xmlChar *)\"name\",\n\t\t\t\t XSLT_NAMESPACE, &comp->has_name);\n}", "target": 0}
{"code": "static void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tflush_kthread_work(&pit->expired);\n}", "target": 0}
{"code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 1}
{"code": "onig_print_statistics(FILE* f)\n{\n  int i;\n  fprintf(f, \"   count      prev        time\\n\");\n  for (i = 0; OnigOpInfo[i].opcode >= 0; i++) {\n    fprintf(f, \"%8d: %8d: %10lu: %s\\n\",\n\t    OpCounter[i], OpPrevCounter[i], OpTime[i], OnigOpInfo[i].name);\n  }\n  fprintf(f, \"\\nmax stack depth: %d\\n\", MaxStackDepth);\n}", "target": 0}
{"code": "call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t    return NULL;\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n    return qftf_list;\n}", "target": 1}
{"code": "static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = iocb->private;\n\tstruct workqueue_struct *wq;\n\tif (!io_end || !size)\n\t\treturn;\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p\"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %llu\\n\",\n \t\t  iocb->private, io_end->inode->i_ino, iocb, offset,\n\t\t  size);\n\tif (io_end->flag != EXT4_IO_UNWRITTEN){\n\t\text4_free_io_end(io_end);\n\t\tiocb->private = NULL;\n\t\treturn;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\twq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;\n\tqueue_work(wq, &io_end->work);\n\tlist_add_tail(&io_end->list,\n\t\t &EXT4_I(io_end->inode)->i_completed_io_list);\n\tiocb->private = NULL;\n}", "target": 1}
{"code": "void WebContentsImpl::HandleKeyboardEvent(const NativeWebKeyboardEvent& event) {\n  if (browser_plugin_embedder_ &&\n      browser_plugin_embedder_->HandleKeyboardEvent(event)) {\n    return;\n  }\n  if (delegate_)\n    delegate_->HandleKeyboardEvent(this, event);\n}", "target": 0}
{"code": "static void __ref adjust_range_page_size_mask(struct map_range *mr,\n\t\t\t\t\t\t\t int nr_range)\n{\n\tint i;\n\tfor (i = 0; i < nr_range; i++) {\n\t\tif ((page_size_mask & (1<<PG_LEVEL_2M)) &&\n\t\t    !(mr[i].page_size_mask & (1<<PG_LEVEL_2M))) {\n\t\t\tunsigned long start = round_down(mr[i].start, PMD_SIZE);\n\t\t\tunsigned long end = round_up(mr[i].end, PMD_SIZE);\n#ifdef CONFIG_X86_32\n\t\t\tif ((end >> PAGE_SHIFT) > max_low_pfn)\n\t\t\t\tcontinue;\n#endif\n\t\t\tif (memblock_is_region_memory(start, end - start))\n\t\t\t\tmr[i].page_size_mask |= 1<<PG_LEVEL_2M;\n\t\t}\n\t\tif ((page_size_mask & (1<<PG_LEVEL_1G)) &&\n\t\t    !(mr[i].page_size_mask & (1<<PG_LEVEL_1G))) {\n\t\t\tunsigned long start = round_down(mr[i].start, PUD_SIZE);\n\t\t\tunsigned long end = round_up(mr[i].end, PUD_SIZE);\n\t\t\tif (memblock_is_region_memory(start, end - start))\n\t\t\t\tmr[i].page_size_mask |= 1<<PG_LEVEL_1G;\n\t\t}\n\t}\n}", "target": 0}
{"code": "Browser::CreateParams::CreateParams(Type type, Profile* profile)\n    : type(type),\n      profile(profile),\n      trusted_source(false),\n      initial_show_state(ui::SHOW_STATE_DEFAULT),\n      is_session_restore(false),\n      window(NULL) {}", "target": 0}
{"code": "add_header (char *name, char *value, int mode)\n{\n  struct add_header *hp;\n  if (!add_header_list)\n    {\n      int rc = mu_list_create (&add_header_list);\n      if (rc)\n\t{\n\t  mu_error (_(\"Cannot create header list: %s\"), mu_strerror (rc));\n\t  exit (1);\n\t}\n    }\n  hp = mu_alloc (sizeof (*hp));\n  hp->mode = mode;\n  hp->name = name;\n  hp->value = value;\n  mu_list_append (add_header_list, hp);\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* data =\n      reinterpret_cast<TfLiteAudioMicrofrontendParams*>(node->user_data);\n  FrontendReset(data->state);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  if (data->out_float) {\n    GenerateFeatures<float>(data, input, output);\n  } else {\n    GenerateFeatures<int32>(data, input, output);\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "node_new_true_anychar(Node** node, ScanEnv* env)\n{\n  Node* n;\n  n = node_new_anychar_with_fixed_option(ONIG_OPTION_MULTILINE);\n  CHECK_NULL_RETURN_MEMERR(n);\n  *node = n;\n  return 0;\n}", "target": 0}
{"code": "juniper_atm2_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM2;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (l2info.direction != JUNIPER_BPF_PKT_IN && \n            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {\n            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            return l2info.header_len;\n        }\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\n}", "target": 1}
{"code": "BOOL CALLBACK DismissOwnedPopups(HWND window, LPARAM arg) {\n  const HWND toplevel_hwnd = reinterpret_cast<HWND>(arg);\n  if (::IsWindowVisible(window)) {\n    const HWND owner = ::GetWindow(window, GW_OWNER);\n    if (toplevel_hwnd == owner) {\n      ::PostMessage(window, WM_CANCELMODE, 0, 0);\n    }\n  }\n  return TRUE;\n}", "target": 0}
{"code": "nfsd4_check_open_attributes(struct svc_rqst *rqstp,\n\tstruct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\t__be32 status = nfs_ok;\n\tif (open->op_create == NFS4_OPEN_CREATE) {\n\t\tif (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd_attrmask);\n\t\telse if (open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd41_ex_attrmask);\n\t}\n\treturn status;\n}", "target": 0}
{"code": "static int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (ple_gap)\n\t\tgrow_ple_window(vcpu);\n\tkvm_vcpu_on_spin(vcpu, true);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 0}
{"code": "static jboolean Region_quickContains(JNIEnv* env, jobject region, jint left, jint top, jint right, jint bottom) {\n bool result = GetSkRegion(env, region)->quickContains(left, top, right, bottom);\n return boolTojboolean(result);\n}", "target": 0}
{"code": "pcx_write_rle(const byte * from, const byte * end, int step, gp_file * file)\n{\t\t\t\t\n#define MAX_RUN_COUNT 15\n    int max_run = step * MAX_RUN_COUNT;\n    while (from < end) {\n        byte data = *from;\n        from += step;\n        if (data != *from || from == end) {\n            if (data >= 0xc0)\n                gp_fputc(0xc1, file);\n        } else {\n            const byte *start = from;\n            while ((from < end) && (*from == data))\n                from += step;\n            while (from - start >= max_run) {\n                gp_fputc(0xc0 + MAX_RUN_COUNT, file);\n                gp_fputc(data, file);\n                start += max_run;\n            }\n            if (from > start || data >= 0xc0)\n                gp_fputc((from - start) / step + 0xc1, file);\n        }\n        gp_fputc(data, file);\n    }\n#undef MAX_RUN_COUNT\n}", "target": 1}
{"code": "GF_Err aprm_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeStdEncryptionParamsBox *ptr = (GF_AdobeStdEncryptionParamsBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->enc_info, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->key_info, &pos);\n    return GF_OK;\n}", "target": 0}
{"code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\t\tnewdst = 0;\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}", "target": 1}
{"code": "void RenderView::SetContentSettings(const ContentSettings& settings) {\n  current_content_settings_ = settings;\n}", "target": 0}
{"code": "gb18030_code_to_mbclen(OnigCodePoint code)\n{\n       if ((code & 0xff000000) != 0) return 4;\n  else if ((code &   0xff0000) != 0) return ONIGERR_INVALID_CODE_POINT_VALUE;\n  else if ((code &     0xff00) != 0) return 2;\n  else {\n    if (GB18030_MAP[(int )(code & 0xff)] == CM)\n      return ONIGERR_INVALID_CODE_POINT_VALUE;\n    return 1;\n  }\n}", "target": 0}
{"code": "bool VariableUnserializer::matchString(folly::StringPiece str) {\n  const char* p = m_buf;\n  assertx(p <= m_end);\n  int total = 0;\n  if (*p == 'S') {\n    total = 2 + 8 + 1;\n    if (p + total > m_end) return false;\n    p++;\n    if (*p++ != ':') return false;\n    auto const sd = *reinterpret_cast<StringData*const*>(p);\n    assertx(sd->isStatic());\n    if (str.compare(sd->slice()) != 0) return false;\n    p += size_t(8);\n  } else {\n    const auto ss = str.size();\n    if (ss >= 100) return false;\n    int digits = ss >= 10 ? 2 : 1;\n    total = 2 + digits + 2 + ss + 2;\n    if (p + total > m_end) return false;\n    if (*p++ != 's') return false;\n    if (*p++ != ':') return false;\n    if (digits == 2) {\n      if (*p++ != '0' + ss/10) return false;\n      if (*p++ != '0' + ss%10) return false;\n    } else {\n      if (*p++ != '0' + ss) return false;\n    }\n    if (*p++ != ':') return false;\n    if (*p++ != '\\\"') return false;\n    if (memcmp(p, str.data(), ss)) return false;\n    p += ss;\n    if (*p++ != '\\\"') return false;\n  }\n  if (*p++ != ';') return false;\n  assertx(m_buf + total == p);\n  m_buf = p;\n  return true;\n}", "target": 1}
{"code": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString += \"<var name='\";\n      m_packetString += varName.data();\n      m_packetString += \"'>\";\n    }\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n      } else {\n        m_packetString += \"<array length='\";\n        m_packetString += std::to_string(length);\n        m_packetString += \"'>\";\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString += \"</struct>\";\n      }\n      else {\n        m_packetString += \"</array>\";\n      }\n    }\n    else {\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n        m_packetString += \"</struct>\";\n      }\n    }\n    if (hasVarTag) {\n      m_packetString += \"</var>\";\n    }\n    return true;\n  }\n  std::string varType = getDataTypeString(varVariant.getType()).data();\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    std::string varValue = varVariant.toString().data();\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    }\n    m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);\n    return true;\n  }\n  return false;\n}", "target": 1}
{"code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "AcpiNsGetNode (\n    ACPI_NAMESPACE_NODE     *PrefixNode,\n    const char              *Pathname,\n    UINT32                  Flags,\n    ACPI_NAMESPACE_NODE     **ReturnNode)\n{\n    ACPI_STATUS             Status;\n    ACPI_FUNCTION_TRACE_PTR (NsGetNode, ACPI_CAST_PTR (char, Pathname));\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_ACPI_STATUS (Status);\n    }\n    Status = AcpiNsGetNodeUnlocked (PrefixNode, Pathname,\n        Flags, ReturnNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n    return_ACPI_STATUS (Status);\n}", "target": 0}
{"code": "exo_open_find_scheme (const gchar *string)\n{\n  gchar *current_dir;\n  gchar *uri;\n  gchar *path;\n  if (g_path_is_absolute (string))\n    return exo_open_get_path (string);\n  current_dir = g_get_current_dir ();\n  path = g_build_filename (current_dir, string, NULL);\n  g_free (current_dir);\n  if (g_file_test (path, G_FILE_TEST_EXISTS))\n    {\n       uri = exo_open_get_path (path);\n       g_free (path);\n       return uri;\n    }\n  g_free (path);\n  if (g_regex_match_simple (MATCH_PATTERN_EMAIL, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"mailto:\", string, NULL);\n  if (g_regex_match_simple (MATCH_PATTERN_HTTP, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"http:\n  return NULL;\n}", "target": 0}
{"code": " char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)\n {\n        char *dst;\n        if (!value.length)\n                return NULL;\n\tdst = talloc_array(mem_ctx, char, value.length * 3 + 1);\n\tif ( ! dst) {\n\t\ttalloc_free(dst);\n                return NULL;\n        }\n       ldb_dn_escape_internal(dst, (const char *)value.data, value.length);\n       dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);\n        return dst;\n }", "target": 1}
{"code": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), result);\n\t\t}", "target": 1}
{"code": "    void TiffImage::printStructure(std::ostream& out, Exiv2::PrintStructureOption option,int depth)\n    {\n        if (io_->open() != 0) throw Error(9, io_->path(), strError());\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(14);\n            throw Error(15);\n        }\n        io_->seek(0,BasicIo::beg);\n        printTiffStructure(io(),out,option,depth-1);\n    }", "target": 0}
{"code": "static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_byte = data[0];\n\tut64 offset = addr - java_get_method_start ();\n\tut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;\n\tif (op_byte == 0xaa) {\n\t\tif (pos + 8 > len) {\n\t\t\treturn op->size;\n\t\t}\n\t\tint min_val = (ut32)(UINT (data, pos + 4)),\n\t\t\tmax_val = (ut32)(UINT (data, pos + 8));\n\t\tut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;\n\t\top->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);\n\t\tRAnalCaseOp *caseop = NULL;\n\t\tpos += 12;\n\t\tif (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {\n\t\t\tfor (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {\n\t\t\t\tif (pos + 4 >= len) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));\n\t\t\t\tcaseop = r_anal_switch_op_add_case (op->switch_op,\n\t\t\t\t\taddr + pos, cur_case + min_val, addr + offset);\n\t\t\t\tif (caseop) {\n\t\t\t\t\tcaseop->bb_ref_to = addr+offset;\n\t\t\t\t\tcaseop->bb_ref_from = addr; \n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid switch boundaries at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\top->size = pos;\n\treturn op->size;\n}", "target": 1}
{"code": "  NoStartupWindowTest() {}", "target": 0}
{"code": "void html_url_path(const char *txt)\n{\n\tconst char *t = txt;\n\twhile (t && *t) {\n\t\tunsigned char c = *t;\n\t\tconst char *e = url_escape_table[c];\n\t\tif (e && c != '+' && c != '&') {\n\t\t\thtml_raw(txt, t - txt);\n\t\t\thtml(e);\n\t\t\ttxt = t + 1;\n\t\t}\n\t\tt++;\n\t}\n\tif (t != txt)\n\t\thtml(txt);\n}", "target": 0}
{"code": "writeDataError(instanceData *pData, cJSON **pReplyRoot, uchar *reqmsg)\n{\n\tchar *rendered = NULL;\n\tcJSON *errRoot;\n\tcJSON *req;\n\tcJSON *replyRoot = *pReplyRoot;\n\tsize_t toWrite;\n\tssize_t wrRet;\n\tchar errStr[1024];\n\tDEFiRet;\n\tif(pData->errorFile == NULL) {\n\t\tDBGPRINTF(\"omelasticsearch: no local error logger defined - \"\n\t\t          \"ignoring ES error information\\n\");\n\t\tFINALIZE;\n\t}\n\tif(pData->fdErrFile == -1) {\n\t\tpData->fdErrFile = open((char*)pData->errorFile,\n\t\t\t\t\tO_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,\n\t\t\t\t\tS_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);\n\t\tif(pData->fdErrFile == -1) {\n\t\t\trs_strerror_r(errno, errStr, sizeof(errStr));\n\t\t\tDBGPRINTF(\"omelasticsearch: error opening error file: %s\\n\", errStr);\n\t\t\tABORT_FINALIZE(RS_RET_ERR);\n\t\t}\n\t}\n\tif((req=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);\n\tcJSON_AddItemToObject(req, \"url\", cJSON_CreateString((char*)pData->restURL));\n\tcJSON_AddItemToObject(req, \"postdata\", cJSON_CreateString((char*)reqmsg));\n\tif((errRoot=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);\n\tcJSON_AddItemToObject(errRoot, \"request\", req);\n\tcJSON_AddItemToObject(errRoot, \"reply\", replyRoot);\n\trendered = cJSON_Print(errRoot);\n\tDBGPRINTF(\"omelasticsearch: error record: '%s'\\n\", rendered);\n\ttoWrite = strlen(rendered);\n\twrRet = write(pData->fdErrFile, rendered, toWrite);\n\tif(wrRet != (ssize_t) toWrite) {\n\t\tDBGPRINTF(\"omelasticsearch: error %d writing error file, write returns %lld\\n\",\n\t\t\t  errno, (long long) wrRet);\n\t}\n\tfree(rendered);\n\tcJSON_Delete(errRoot);\n\t*pReplyRoot = NULL; \nfinalize_it:\n\tif(rendered != NULL)\n\t\tfree(rendered);\n\tRETiRet;\n}", "target": 1}
{"code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                return;\n            }\n            iterator = it->second;\n        }\n        iterator->messages[messageId] = message;\n        if (!iterator->triggered) {\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }", "target": 1}
{"code": "static inline int sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent)\n{\n\tint err = 0;\n\tsco_conn_lock(conn);\n\tif (conn->sk)\n\t\terr = -EBUSY;\n\telse\n\t\t__sco_chan_add(conn, sk, parent);\n\tsco_conn_unlock(conn);\n\treturn err;\n}", "target": 0}
{"code": "DECLAREContigPutFunc(putcontig8bitCIELab)\n{\n\tfloat X, Y, Z;\n\tuint32 r, g, b;\n\t(void) y;\n\tfromskew *= 3;\n\twhile (h-- > 0) {\n\t\tfor (x = w; x-- > 0;) {\n\t\t\tTIFFCIELabToXYZ(img->cielab,\n\t\t\t\t\t(unsigned char)pp[0],\n\t\t\t\t\t(signed char)pp[1],\n\t\t\t\t\t(signed char)pp[2],\n\t\t\t\t\t&X, &Y, &Z);\n\t\t\tTIFFXYZToRGB(img->cielab, X, Y, Z, &r, &g, &b);\n\t\t\t*cp++ = PACK(r, g, b);\n\t\t\tpp += 3;\n\t\t}\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t}\n}", "target": 0}
{"code": "void WebContentsImpl::ViewFrameSource(const GURL& url,\n                                      const PageState& page_state) {\n  if (!delegate_)\n    return;\n  delegate_->ViewSourceForFrame(this, url, page_state);\n}", "target": 0}
{"code": "static void* socketio_CloneOption(const char* name, const void* value)\n{\n    void* result;\n    if (name != NULL)\n    {\n        result = NULL;\n        if (strcmp(name, OPTION_NET_INT_MAC_ADDRESS) == 0)\n        {\n            if (value == NULL)\n            {\n                LogError(\"Failed cloning option %s (value is NULL)\", name);\n            }\n            else\n            {\n                if ((result = malloc(sizeof(char) * (strlen((char*)value) + 1))) == NULL)\n                {\n                    LogError(\"Failed cloning option %s (malloc failed)\", name);\n                }\n                else\n                {\n                    strcpy((char *)result, (char *)value);\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Cannot clone option %s (not suppported)\", name);\n        }\n    }\n    else\n    {\n        result = NULL;\n    }\n    return result;\n}", "target": 1}
{"code": "    TiffHeader::~TiffHeader()\n    {\n    }", "target": 0}
{"code": "static int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n    if (S_ISREG(mode)) {\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode)) return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t\n}", "target": 1}
{"code": "static void fuse_freecontext(void *data)\n{\n    free(data);\n}", "target": 0}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tbool allow = [&]() {\n\t\t\t\tif (!inherit) {\n\t\t\t\t\tif (key_inner->IsName()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealNamedProperty(context_handle, key_inner.As<Name>()));\n\t\t\t\t\t} else if (key_inner->IsNumber()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealIndexedProperty(context_handle, HandleCast<uint32_t>(key_inner)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}();\n\t\t\tLocal<Value> value = allow ?\n\t\t\t\tUnmaybe(object->Get(context_handle, key_inner)) :\n\t\t\t\tUndefined(Isolate::GetCurrent()).As<Value>();\n\t\t\tret = TransferOut(value, options);\n\t\t}", "target": 1}
{"code": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tstruct bpf_prog *prog_adj;\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\tinsn_adj_cnt = prog->len + insn_delta;\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\tprog_adj->len = insn_adj_cnt;\n\tinsn_rest = insn_adj_cnt - off - len;\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\tbpf_adj_branches(prog_adj, off, insn_delta);\n\treturn prog_adj;\n}", "target": 1}
{"code": "bool AuthNoneAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n  try {\n    __u8 struct_v = 1;\n    ::decode(struct_v, iter);\n    ::decode(entity_name, iter);\n    ::decode(global_id, iter);\n  } catch (const buffer::error &err) {\n    ldout(cct, 0) << \"AuthNoneAuthorizeHandle::verify_authorizer() failed to decode\" << dendl;\n    return false;\n  }\n  caps_info.allow_all = true;\n  return true;\n}", "target": 1}
{"code": "static void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\tu64 boot_ns;\n\tboot_ns = ktime_to_ns(ktime_add(tk->tkr.base_mono, tk->offs_boot));\n\twrite_seqcount_begin(&vdata->seq);\n\tvdata->clock.vclock_mode\t= tk->tkr.clock->archdata.vclock_mode;\n\tvdata->clock.cycle_last\t\t= tk->tkr.cycle_last;\n\tvdata->clock.mask\t\t= tk->tkr.mask;\n\tvdata->clock.mult\t\t= tk->tkr.mult;\n\tvdata->clock.shift\t\t= tk->tkr.shift;\n\tvdata->boot_ns\t\t\t= boot_ns;\n\tvdata->nsec_base\t\t= tk->tkr.xtime_nsec;\n\twrite_seqcount_end(&vdata->seq);\n}", "target": 0}
{"code": "static int adis_update_scan_mode_burst(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tunsigned int burst_length;\n\tu8 *tx;\n\tburst_length = (indio_dev->num_channels - 1) * sizeof(u16);\n\tburst_length += adis->burst->extra_len;\n\tadis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\ttx = adis->buffer + burst_length;\n\ttx[0] = ADIS_READ_REG(adis->burst->reg_cmd);\n\ttx[1] = 0;\n\tadis->xfer[0].tx_buf = tx;\n\tadis->xfer[0].bits_per_word = 8;\n\tadis->xfer[0].len = 2;\n\tadis->xfer[1].rx_buf = adis->buffer;\n\tadis->xfer[1].bits_per_word = 8;\n\tadis->xfer[1].len = burst_length;\n\tspi_message_init(&adis->msg);\n\tspi_message_add_tail(&adis->xfer[0], &adis->msg);\n\tspi_message_add_tail(&adis->xfer[1], &adis->msg);\n\treturn 0;\n}", "target": 1}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": "void WavOutFile::write(const float *buffer, int numElems)\n{\n    int numBytes;\n    int bytesPerSample;\n    if (numElems == 0) return;\n    bytesPerSample = header.format.bits_per_sample / 8;\n    numBytes = numElems * bytesPerSample;\n    int confBufBytes = (numBytes + 3) & -4; \n    void *temp = getConvBuffer(confBufBytes);\n    switch (bytesPerSample)\n    {\n        case 1:\n        {\n            unsigned char *temp2 = (unsigned char *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                temp2[i] = (unsigned char)saturate(buffer[i] * 128.0f + 128.0f, 0.0f, 255.0f);\n            }\n            break;\n        }\n        case 2:\n        {\n            short *temp2 = (short *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                short value = (short)saturate(buffer[i] * 32768.0f, -32768.0f, 32767.0f);\n                temp2[i] = _swap16(value);\n            }\n            break;\n        }\n        case 3:\n        {\n            char *temp2 = (char *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                int value = saturate(buffer[i] * 8388608.0f, -8388608.0f, 8388607.0f);\n                *((int*)temp2) = _swap32(value);\n                temp2 += 3;\n            }\n            break;\n        }\n        case 4:\n        {\n            int *temp2 = (int *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                int value = saturate(buffer[i] * 2147483648.0f, -2147483648.0f, 2147483647.0f);\n                temp2[i] = _swap32(value);\n            }\n            break;\n        }\n        default:\n            assert(false);\n    }\n    int res = (int)fwrite(temp, 1, numBytes, fptr);\n    if (res != numBytes) \n    {\n        ST_THROW_RT_ERROR(\"Error while writing to a wav file.\");\n    }\n    bytesWritten += numBytes;\n}", "target": 1}
{"code": "SYSCALL_DEFINE2(clock_getres, const clockid_t, which_clock,\n\t\tstruct timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 rtn_tp64;\n\tstruct timespec rtn_tp;\n\tint error;\n\tif (!kc)\n\t\treturn -EINVAL;\n\terror = kc->clock_getres(which_clock, &rtn_tp64);\n\trtn_tp = timespec64_to_timespec(rtn_tp64);\n\tif (!error && tp && copy_to_user(tp, &rtn_tp, sizeof (rtn_tp)))\n\t\terror = -EFAULT;\n\treturn error;\n}", "target": 0}
{"code": "le64addr_string(netdissect_options *ndo, const u_char *ep)\n{\n\tconst unsigned int len = 8;\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tchar buf[BUFSIZE];\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\tcp = buf;\n\tfor (i = len; i > 0 ; --i) {\n\t\t*cp++ = hex[*(ep + i - 1) >> 4];\n\t\t*cp++ = hex[*(ep + i - 1) & 0xf];\n\t\t*cp++ = ':';\n\t}\n\tcp --;\n\t*cp = '\\0';\n\ttp->e_name = strdup(buf);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"le64addr_string: strdup(buf)\");\n\treturn (tp->e_name);\n}", "target": 1}
{"code": "SV*\nPerl_reg_named_buff_nextkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY;\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv = RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        while ( (temphe = hv_iternext_flags(hv, 0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n\t\treturn newSVhek(HeKEY_hek(temphe));\n            }\n        }\n    }\n    return NULL;", "target": 0}
{"code": "TEST_P(RBACIntegrationTest, DeniedWithPrefixRule) {\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             cfg) { cfg.mutable_normalize_path()->set_value(false); });\n  config_helper_.addFilter(RBAC_CONFIG_WITH_PREFIX_MATCH);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"POST\"},\n          {\":path\", \"/foo/../bar\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"host\"},\n          {\"x-forwarded-for\", \"10.0.0.1\"},\n      },\n      1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "ble_hs_conn_timer(void)\n{\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 && \\\n    BLE_HS_ATT_SVR_QUEUED_WRITE_TMO == 0\n    return BLE_HS_FOREVER;\n#endif\n    struct ble_hs_conn *conn;\n    ble_npl_time_t now;\n    int32_t next_exp_in;\n    int32_t time_diff;\n    uint16_t conn_handle;\n    for (;;) {\n        conn_handle = BLE_HS_CONN_HANDLE_NONE;\n        next_exp_in = BLE_HS_FOREVER;\n        now = ble_npl_time_get();\n        ble_hs_lock();\n        SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n            if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) != 0\n                if (conn->bhc_rx_chan != NULL) {\n                    time_diff = conn->bhc_rx_timeout - now;\n                    if (time_diff <= 0) {\n                        conn_handle = conn->bhc_handle;\n                        break;\n                    }\n                    if (time_diff < next_exp_in) {\n                        next_exp_in = time_diff;\n                    }\n                }\n#endif\n#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n                time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n                if (time_diff <= 0) {\n                    conn_handle = conn->bhc_handle;\n                    break;\n                }\n                if (time_diff < next_exp_in) {\n                    next_exp_in = time_diff;\n                }\n#endif\n            }\n        }\n        ble_hs_unlock();\n        if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {\n            ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);\n            continue;\n        }\n        return next_exp_in;\n    }\n}", "target": 1}
{"code": "xsltCompilerVarInfoFree(xsltCompilerCtxtPtr cctxt)\n{\n    xsltVarInfoPtr ivar = cctxt->ivars, ivartmp;    \n    while (ivar) {\n\tivartmp = ivar;\n\tivar = ivar->next;\n\txmlFree(ivartmp);\n    }\n}", "target": 0}
{"code": "static int adpt_bus_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tu32 msg[4];\n\tu32 rcode;\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tmemset(msg, 0, sizeof(msg));\n\tprintk(KERN_WARNING\"%s: Bus reset: SCSI Bus %d: tid: %d\\n\",pHba->name, cmd->device->channel,pHba->channel[cmd->device->channel].tid );\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->device->channel].tid);\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\trcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tprintk(KERN_WARNING\"%s: Bus reset failed.\\n\",pHba->name);\n\t\treturn FAILED;\n\t} else {\n\t\tprintk(KERN_WARNING\"%s: Bus reset success.\\n\",pHba->name);\n\t\treturn SUCCESS;\n\t}\n}", "target": 1}
{"code": "merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JSAMPROW work_ptrs[2];\n  JDIMENSION num_rows;          \n  if (upsample->spare_full) {\n    JDIMENSION size = upsample->out_row_width;\n    if (cinfo->out_color_space == JCS_RGB565)\n      size = cinfo->output_width * 2;\n    jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0, 1,\n                      size);\n    num_rows = 1;\n    upsample->spare_full = FALSE;\n  } else {\n    num_rows = 2;\n    if (num_rows > upsample->rows_to_go)\n      num_rows = upsample->rows_to_go;\n    out_rows_avail -= *out_row_ctr;\n    if (num_rows > out_rows_avail)\n      num_rows = out_rows_avail;\n    work_ptrs[0] = output_buf[*out_row_ctr];\n    if (num_rows > 1) {\n      work_ptrs[1] = output_buf[*out_row_ctr + 1];\n    } else {\n      work_ptrs[1] = upsample->spare_row;\n      upsample->spare_full = TRUE;\n    }\n    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);\n  }\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  if (!upsample->spare_full)\n    (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, NegatedRangeIntGTE) {\n    addIndex(BSON(\"i\" << 1));\n    runQuery(fromjson(\"{i: {$not: {$gte: 5}}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {i:1}, \"\n        \"bounds: {i: [['MinKey',5,true,false], \"\n        \"[Infinity,'MaxKey',false,true]]}}}}}\");\n}", "target": 0}
{"code": "void *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree (mo->symbols[i].name);\n\t\t}\n\t\tfree (mo->symbols);\n\t}\n\tfree (mo->segs);\n\tfree (mo->sects);\n\tfree (mo->symtab);\n\tfree (mo->symstr);\n\tfree (mo->indirectsyms);\n\tfree (mo->imports_by_ord);\n\tht_pp_free (mo->imports_by_name);\n\tfree (mo->dyld_info);\n\tfree (mo->toc);\n\tfree (mo->modtab);\n\tfree (mo->libs);\n\tfree (mo->func_start);\n\tfree (mo->signature);\n\tfree (mo->intrp);\n\tfree (mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nsegs; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree (mo->chained_starts[i]->page_start);\n\t\t\t\tfree (mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree (mo->chained_starts);\n\t}\n\tr_buf_free (mo->b);\n\tfree (mo);\n\treturn NULL;\n}", "target": 1}
{"code": "_dbus_credentials_add_from_user (DBusCredentials  *credentials,\n                                     const DBusString *username)\n{\n  return _dbus_credentials_add_windows_sid (credentials,\n                    _dbus_string_get_const_data(username));\n}", "target": 0}
{"code": "bool BlobURLRequestJob::ReadItem() {\n  if (remaining_bytes_ == 0)\n    return true;\n  if (item_index_ >= blob_data_->items().size()) {\n    NotifyFailure(net::ERR_FAILED);\n    return false;\n  }\n  bytes_to_read_ = ComputeBytesToRead();\n  if (bytes_to_read_ == 0) {\n    AdvanceItem();\n    return ReadItem();\n  }\n  const BlobData::Item& item = blob_data_->items().at(item_index_);\n  switch (item.type()) {\n    case BlobData::TYPE_DATA:\n      return ReadBytes(item);\n    case BlobData::TYPE_FILE:\n      return DispatchReadFile(item);\n    default:\n      DCHECK(false);\n      return false;\n  }\n}", "target": 0}
{"code": "static ssize_t sanity_checks_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_CONSISTENCY_CHECKS));\n}", "target": 0}
{"code": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n\tstruct rtable *rt;\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\treturn 0;\n}", "target": 1}
{"code": "gfx::SwapResult GLSurfaceOzoneSurfacelessSurfaceImpl::SwapBuffers() {\n  if (!images_[current_surface_]->ScheduleOverlayPlane(\n          widget_, 0, OverlayTransform::OVERLAY_TRANSFORM_NONE,\n          gfx::Rect(GetSize()), gfx::RectF(1, 1)))\n    return gfx::SwapResult::SWAP_FAILED;\n  gfx::SwapResult result = GLSurfaceOzoneSurfaceless::SwapBuffers();\n  if (result != gfx::SwapResult::SWAP_ACK)\n    return result;\n  current_surface_ ^= 1;\n  BindFramebuffer();\n  return gfx::SwapResult::SWAP_ACK;\n}", "target": 0}
{"code": "void InterstitialPage::InterstitialPageRVHViewDelegate::CreateNewWindow(\n    int route_id) {\n  NOTREACHED() << \"InterstitialPage does not support showing popups yet.\";\n}", "target": 0}
{"code": "static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n \t\tif (err) {\n \t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n \t\t\t\t    midi->out_ep->name, err);\n\t\t\tfree_ep_req(midi->out_ep, req);\n \t\t\treturn err;\n \t\t}\n \t}\n\treturn 0;\n}", "target": 1}
{"code": "    template<typename t, typename to>\n    static float __draw_object3d(const CImgList<t>& opacities, const unsigned int n_primitive, CImg<to>& opacity) {\n      if (n_primitive>=opacities._width || opacities[n_primitive].is_empty()) { opacity.assign(); return 1; }\n      if (opacities[n_primitive].size()==1) { opacity.assign(); return opacities(n_primitive,0); }\n      opacity.assign(opacities[n_primitive],true);\n      return 1.0f;", "target": 0}
{"code": "int cli_hm_scan(const unsigned char *digest, uint32_t size, const char **virname, const struct cli_matcher *root, enum CLI_HASH_TYPE type) {\n    const struct cli_htu32_element *item;\n    unsigned int keylen;\n    struct cli_sz_hash *szh;\n    size_t l, r;\n    if(!digest || !size || size == 0xffffffff || !root || !root->hm.sizehashes[type].capacity)\n\treturn CL_CLEAN;\n    item = cli_htu32_find(&root->hm.sizehashes[type], size);\n    if(!item)\n\treturn CL_CLEAN;\n    szh = (struct cli_sz_hash *)item->data.as_ptr;\n    keylen = hashlen[type];\n    l = 0;\n    r = szh->items;\n    while(l <= r) {\n\tsize_t c = (l + r) / 2;\n\tint res = hm_cmp(digest, &szh->hash_array[keylen * c], keylen);\n\tif(res < 0) {\n\t    if(!c)\n\t\tbreak;\n\t    r = c - 1;\n\t} else if(res > 0)\n\t    l = c + 1;\n\telse {\n\t    if(virname)\n\t\t*virname = szh->virusnames[c];\n\t    return CL_VIRUS;\n\t}\n    }\n    return CL_CLEAN;\n}", "target": 1}
{"code": "static size_t push_pipe(struct iov_iter *i, size_t size,\n\t\t\tint *iter_headp, size_t *offp)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int iter_head;\n\tsize_t off;\n\tssize_t left;\n\tif (unlikely(size > i->count))\n\t\tsize = i->count;\n\tif (unlikely(!size))\n\t\treturn 0;\n\tleft = size;\n\tdata_start(i, &iter_head, &off);\n\t*iter_headp = iter_head;\n\t*offp = off;\n\tif (off) {\n\t\tleft -= PAGE_SIZE - off;\n\t\tif (left <= 0) {\n\t\t\tpipe->bufs[iter_head & p_mask].len += size;\n\t\t\treturn size;\n\t\t}\n\t\tpipe->bufs[iter_head & p_mask].len = PAGE_SIZE;\n\t\titer_head++;\n\t}\n\twhile (!pipe_full(iter_head, p_tail, pipe->max_usage)) {\n\t\tstruct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];\n\t\tstruct page *page = alloc_page(GFP_USER);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tbuf->ops = &default_pipe_buf_ops;\n\t\tbuf->page = page;\n\t\tbuf->offset = 0;\n\t\tbuf->len = min_t(ssize_t, left, PAGE_SIZE);\n\t\tleft -= buf->len;\n\t\titer_head++;\n\t\tpipe->head = iter_head;\n\t\tif (left == 0)\n\t\t\treturn size;\n\t}\n\treturn size - left;\n}", "target": 1}
{"code": "    size_t operator()(const ArrayOrObject data) const {\n      return data.toOpaque();\n    }", "target": 0}
{"code": "int av_hwframe_ctx_init(AVBufferRef *ref)\n{\n    AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;\n    const enum AVPixelFormat *pix_fmt;\n    int ret;\n    if (ctx->internal->source_frames) {\n        return 0;\n    }\n    for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {\n        if (*pix_fmt == ctx->format)\n            break;\n    }\n    if (*pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"The hardware pixel format '%s' is not supported by the device type '%s'\\n\",\n               av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);\n        return AVERROR(ENOSYS);\n    }\n    ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);\n    if (ret < 0)\n        return ret;\n    if (ctx->internal->hw_type->frames_init) {\n        ret = ctx->internal->hw_type->frames_init(ctx);\n        if (ret < 0)\n            goto fail;\n    }\n    if (ctx->internal->pool_internal && !ctx->pool)\n        ctx->pool = ctx->internal->pool_internal;\n    if (ctx->initial_pool_size > 0) {\n        ret = hwframe_pool_prealloc(ref);\n        if (ret < 0)\n            goto fail;\n    }\n    return 0;\nfail:\n    if (ctx->internal->hw_type->frames_uninit)\n        ctx->internal->hw_type->frames_uninit(ctx);\n    return ret;\n}", "target": 1}
{"code": "hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime->raiseTypeErrorForValue(\n        args.getArgHandle(0), \" is not a function\");\n  }\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime->raiseTypeError(\"args must be an array\");\n  }\n  uint32_t len = JSArray::getLength(*argArray);\n  bool isConstructor = args.getArgCount() == 2;\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = *thisValRes;\n  } else {\n    thisVal = args.getArg(2);\n  }\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  for (uint32_t i = 0; i < len; ++i) {\n    newFrame->getArgRef(i) = argArray->at(runtime, i);\n  }\n  return isConstructor ? Callable::construct(fn, runtime, thisVal)\n                       : Callable::call(fn, runtime);\n}", "target": 1}
{"code": "get_pw_flags (NMSettingVpn *s_vpn, const char *secret_name, const char *type_name)\n{\n\tconst char *val;\n\tNMSettingSecretFlags flags = NM_SETTING_SECRET_FLAG_NONE;\n\tif (nm_setting_get_secret_flags (NM_SETTING (s_vpn), secret_name, &flags, NULL))\n\t\treturn flags;\n\tval = nm_setting_vpn_get_data_item (s_vpn, type_name);\n\tif (val) {\n\t\tif (g_strcmp0 (val, NM_VPNC_PW_TYPE_ASK) == 0)\n\t\t\treturn NM_SETTING_SECRET_FLAG_NOT_SAVED;\n\t\telse if (g_strcmp0 (val, NM_VPNC_PW_TYPE_UNUSED) == 0)\n\t\t\treturn NM_SETTING_SECRET_FLAG_NOT_REQUIRED;\n\t}\n\treturn NM_SETTING_SECRET_FLAG_NONE;\n}", "target": 0}
{"code": "test_compressed_stream_overflow (xd3_stream *stream, int ignore)\n{\n  int ret;\n  int i;\n  uint8_t *buf;\n  if ((buf = (uint8_t*) malloc (TWO_MEGS_AND_DELTA)) == NULL) { return ENOMEM; }\n  memset (buf, 0, TWO_MEGS_AND_DELTA);\n  for (i = 0; i < (2 << 20); i += 256) \n    {\n      int j;\n      int off = mt_random(& static_mtrand) % 10;\n      for (j = 0; j < 256; j++) \n\t{\n\t  buf[i + j] = j + off;\n\t}\n    }\n  if (SIZEOF_XOFF_T == 4)\n    {\n      ret = test_streaming (stream, buf, buf + (1 << 20), buf + (2 << 20), (1 << 12) + 1);\n      if (ret == XD3_INVALID_INPUT && MSG_IS (\"decoder file offset overflow\"))\n\t{\n\t  ret = 0;\n\t}\n      else\n\t{\n          XPR(NT XD3_LIB_ERRMSG (stream, ret));\n\t  stream->msg = \"expected overflow condition\";\n\t  ret = XD3_INTERNAL;\n\t  goto fail;\n\t}\n    }\n  if ((ret = test_streaming (stream, \n\t\t\t     buf, \n\t\t\t     buf + (1 << 20), \n\t\t\t     buf + (2 << 20), \n\t\t\t     1 << 12))) \n    {\n      goto fail;\n    }\n fail:\n  free (buf);\n  return ret;\n}", "target": 1}
{"code": "int nfc_dep_link_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tif (!dev->ops->dep_link_down)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == false) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_down(dev);\n\tif (!rc) {\n\t\tdev->dep_link_up = false;\n\t\tdev->active_target = NULL;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t\tnfc_llcp_mac_is_down(dev);\n\t\tnfc_genl_dep_link_down_event(dev);\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl,\n\t\t\t  u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t qdisc_root_sleeping_lock(q), &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n {\n \tstruct snd_msnd *chip = dev_id;\n \tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n\t\tu16 wTmp;\n\t\tsnd_msnd_eval_dsp_msg(chip,\n\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n \t}\n \tinb(chip->io + HP_RXL);\n \treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "        std::string getExiv2ConfigPath()\n        {\n            std::string homedir;\n            std::string inifile;\n#if defined(_MSC_VER) || defined(__MINGW__)\n            char path[MAX_PATH];\n            if (SUCCEEDED(SHGetFolderPathA(nullptr, CSIDL_PROFILE, nullptr, 0, path))) {\n                homedir = std::string(path);\n                inifile = \"exiv2.ini\"      ;\n            }\n#else\n            struct passwd* pw = getpwuid(getuid());\n            homedir = std::string(pw?pw->pw_dir:\"\");\n            inifile = std::string(\".exiv2\");\n#endif\n            return homedir + EXV_SEPARATOR_CHR + inifile;\n        }", "target": 0}
{"code": "GF_Box *pssh_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProtectionSystemHeaderBox, GF_ISOM_BOX_TYPE_PSSH);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "bool ChildProcessSecurityPolicy::CanReadRawCookies(int renderer_id) {\n  AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(renderer_id);\n  if (state == security_state_.end())\n    return false;\n  return state->second->can_read_raw_cookies();\n}", "target": 0}
{"code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n \theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n \t\treturn 0;\n \t}\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\t(*header)->os_type = RAW_DATA(header, 23);\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}", "target": 1}
{"code": "int LibRaw::subtract_black()\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\ttry {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))\n        {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c] \n            int cblk[4],i;\n            for(i=0;i<4;i++)\n                cblk[i] = C.cblack[i];\n            int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(C.data_maximum < val) C.data_maximum = val;\n              }\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n            C.maximum -= C.black;\n            ZERO(C.cblack);\n            C.black = 0;\n#undef BAYERC\n        }\n    else\n        {\n          int idx;\n          ushort *p = (ushort*)imgdata.image;\n          C.data_maximum = 0;\n          for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n            if(C.data_maximum < p[idx]) C.data_maximum = p[idx];\n        }\n\t\treturn 0;\n\t}\n\tcatch ( LibRaw_exceptions err) {\n\t\tEXCEPTION_HANDLER(err);\n\t}\n}", "target": 1}
{"code": "static void execlists_destroy(struct intel_engine_cs *engine)\n{\n\tintel_engine_cleanup_common(engine);\n\tlrc_destroy_wa_ctx(engine);\n\tkfree(engine);\n}", "target": 0}
{"code": "ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep)\n{\n\tint totlen;\n\tuint32_t t;\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tt = p[2];\n\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}", "target": 1}
{"code": "static size_t oss_write(HWVoiceOut *hw, void *buf, size_t len)\n{\n    OSSVoiceOut *oss = (OSSVoiceOut *) hw;\n    size_t pos;\n    if (oss->mmapped) {\n        size_t total_len;\n        len = MIN(len, oss_get_available_bytes(oss));\n        total_len = len;\n        while (len) {\n            size_t to_copy = MIN(len, hw->size_emul - hw->pos_emul);\n            memcpy(hw->buf_emul + hw->pos_emul, buf, to_copy);\n            hw->pos_emul = (hw->pos_emul + to_copy) % hw->pos_emul;\n            buf += to_copy;\n            len -= to_copy;\n        }\n        return total_len;\n    }\n    pos = 0;\n    while (len) {\n        ssize_t bytes_written;\n        void *pcm = advance(buf, pos);\n        bytes_written = write(oss->fd, pcm, len);\n        if (bytes_written < 0) {\n            if (errno != EAGAIN) {\n                oss_logerr(errno, \"failed to write %zu bytes\\n\",\n                           len);\n            }\n            return pos;\n        }\n        pos += bytes_written;\n        if (bytes_written < len) {\n            break;\n        }\n        len -= bytes_written;\n    }\n    return pos;\n}", "target": 1}
{"code": "ProcListFonts(ClientPtr client)\n{\n    REQUEST(xListFontsReq);\n    REQUEST_FIXED_SIZE(xListFontsReq, stuff->nbytes);\n    return ListFonts(client, (unsigned char *) &stuff[1], stuff->nbytes,\n                     stuff->maxNames);\n}", "target": 0}
{"code": "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "sds _sdsMakeRoomFor(sds s, size_t addlen, int greedy) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n    size_t usable;\n    if (avail >= addlen) return s;\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    assert(newlen > len);   \n    if (greedy == 1) {\n        if (newlen < SDS_MAX_PREALLOC)\n            newlen *= 2;\n        else\n            newlen += SDS_MAX_PREALLOC;\n    }\n    type = sdsReqType(newlen);\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > len);  \n    if (oldtype==type) {\n        newsh = s_realloc_usable(sh, hdrlen+newlen+1, &usable);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        newsh = s_malloc_usable(hdrlen+newlen+1, &usable);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    usable = usable-hdrlen-1;\n    if (usable > sdsTypeMaxSize(type))\n        usable = sdsTypeMaxSize(type);\n    sdssetalloc(s, usable);\n    return s;\n}", "target": 1}
{"code": "static void record_init(node_t * n)\n{\n    field_t *info;\n    pointf ul, sz;\n    int flip, len;\n    char *textbuf;\t\t\n    int sides = BOTTOM | RIGHT | TOP | LEFT;\n    flip = NOT(GD_realflip(agraphof(n)));\n    reclblp = ND_label(n)->text;\n    len = strlen(reclblp);\n    len = MAX(len, 1);\n    textbuf = N_NEW(len + 1, char);\n    if (!(info = parse_reclbl(n, flip, TRUE, textbuf))) {\n\tagerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\n\treclblp = \"\\\\N\";\n\tinfo = parse_reclbl(n, flip, TRUE, textbuf);\n    }\n    free(textbuf);\n    size_reclbl(n, info);\n    sz.x = POINTS(ND_width(n));\n    sz.y = POINTS(ND_height(n));\n    if (mapbool(late_string(n, N_fixed, \"false\"))) {\n\tif ((sz.x < info->size.x) || (sz.y < info->size.y)) {\n\t}\n    } else {\n\tsz.x = MAX(info->size.x, sz.x);\n\tsz.y = MAX(info->size.y, sz.y);\n    }\n    resize_reclbl(info, sz, mapbool(late_string(n, N_nojustify, \"false\")));\n    ul = pointfof(-sz.x / 2., sz.y / 2.);\t\n    pos_reclbl(info, ul, sides);\n    ND_width(n) = PS2INCH(info->size.x);\n    ND_height(n) = PS2INCH(info->size.y + 1);\t\n    ND_shape_info(n) = (void *) info;\n}", "target": 1}
{"code": "static void mptsas_fetch_request(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    char req[MPTSAS_MAX_REQUEST_SIZE];\n    MPIRequestHeader *hdr = (MPIRequestHeader *)req;\n     hwaddr addr;\n     int size;\n    if (s->state != MPI_IOC_STATE_OPERATIONAL) {\n        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);\n        return;\n    }\n     addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);\n     pci_dma_read(pci, addr, req, sizeof(hdr));\n    }", "target": 1}
{"code": "TfLiteStatus PrepareHashtableFind(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  const TfLiteTensor* default_value_tensor =\n      GetInput(context, node, kDefaultValueTensor);\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, default_value_tensor->type, output_tensor->type);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           output_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               output_tensor->type == kTfLiteInt64));\n  return context->ResizeTensor(context, output_tensor,\n                               TfLiteIntArrayCopy(key_tensor->dims));\n}", "target": 1}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n \t\t\tBIO_free(f);\n \t\t\tf = tbio;\n \t\t\t}\n\t\twhile (f != upto);\n \t\t}\n \telse\n \t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "xfs_bunmapi(\n\txfs_trans_t\t\t*tp,\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\tflags,\n\txfs_extnum_t\t\tnexts,\n\txfs_fsblock_t\t\t*firstblock,\n\tstruct xfs_defer_ops\t*dfops,\n\tint\t\t\t*done)\n{\n\tint\t\t\terror;\n\terror = __xfs_bunmapi(tp, ip, bno, &len, flags, nexts, firstblock,\n\t\t\tdfops);\n\t*done = (len == 0);\n\treturn error;\n}", "target": 0}
{"code": "void generic_end_io_acct(struct request_queue *q, int rw,\n\t\t\t struct hd_struct *part, unsigned long start_time)\n{\n\tunsigned long duration = jiffies - start_time;\n\tint cpu = part_stat_lock();\n\tpart_stat_add(cpu, part, ticks[rw], duration);\n\tpart_round_stats(q, cpu, part);\n\tpart_dec_in_flight(q, part, rw);\n\tpart_stat_unlock();\n}", "target": 0}
{"code": "PHP_FUNCTION(is_finite)\n{\n\tdouble dval;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"d\", &dval) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_BOOL(zend_finite(dval));\n}", "target": 0}
{"code": "static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_alg *alg;\n\tstruct shash_alg *salg;\n\tint err;\n\tint ds;\n\tint ss;\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\n\tif (err)\n\t\treturn err;\n\tsalg = shash_attr_alg(tb[1], 0, 0);\n\tif (IS_ERR(salg))\n\t\treturn PTR_ERR(salg);\n\terr = -EINVAL;\n\tds = salg->digestsize;\n\tss = salg->statesize;\n\talg = &salg->base;\n\tif (ds > alg->cra_blocksize ||\n\t    ss < alg->cra_blocksize)\n\t\tgoto out_put_alg;\n\tinst = shash_alloc_instance(\"hmac\", alg);\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\terr = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,\n\t\t\t\t      shash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = alg->cra_blocksize;\n\tinst->alg.base.cra_alignmask = alg->cra_alignmask;\n\tss = ALIGN(ss, alg->cra_alignmask + 1);\n\tinst->alg.digestsize = ds;\n\tinst->alg.statesize = ss;\n\tinst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +\n\t\t\t\t     ALIGN(ss * 2, crypto_tfm_ctx_alignment());\n\tinst->alg.base.cra_init = hmac_init_tfm;\n\tinst->alg.base.cra_exit = hmac_exit_tfm;\n\tinst->alg.init = hmac_init;\n\tinst->alg.update = hmac_update;\n\tinst->alg.final = hmac_final;\n\tinst->alg.finup = hmac_finup;\n\tinst->alg.export = hmac_export;\n\tinst->alg.import = hmac_import;\n\tinst->alg.setkey = hmac_setkey;\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nout_free_inst:\n\t\tshash_free_instance(shash_crypto_instance(inst));\n\t}\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}", "target": 1}
{"code": "static inline int track_pfn_copy(struct vm_area_struct *vma)\n{\n\treturn 0;\n}", "target": 0}
{"code": "void QuotaManager::DumpQuotaTable(DumpQuotaTableCallback* callback) {\n  make_scoped_refptr(new DumpQuotaTableTask(this, callback))->Start();\n}", "target": 0}
{"code": "static void apply_independent_coupling(AACContext *ac,\n                                       SingleChannelElement *target,\n                                       ChannelElement *cce, int index)\n{\n    int i;\n    const float gain = cce->coup.gain[index][0];\n    const float *src = cce->ch[0].ret;\n    float *dest = target->ret;\n    const int len = 1024 << (ac->oc[1].m4ac.sbr == 1);\n    for (i = 0; i < len; i++)\n        dest[i] += gain * src[i];\n}", "target": 0}
{"code": "CMYK_table_init (void)\n{\n\tg_mutex_lock (&Tables_Mutex);\n\tif (CMYK_Tab == NULL) {\n\t\tint    v, k, i;\n\t\tdouble k1;\n\t\tCMYK_Tab = g_new (unsigned char, 256 * 256);\n\t\ti = 0;\n\t\tfor (k = 0; k <= 255; k++) {\n\t\t\tk1 = (double) k / 255.0;\n\t\t\tfor (v = 0; v <= 255; v++)\n\t\t\t\tCMYK_Tab[i++] = (double) v * k1;\n\t\t}\n\t}\n\tg_mutex_unlock (&Tables_Mutex);\n}", "target": 0}
{"code": "void PacketReader::getDnsrecordheader(struct dnsrecordheader &ah)\n{\n  unsigned int n;\n  unsigned char *p=reinterpret_cast<unsigned char*>(&ah);\n  for(n=0; n < sizeof(dnsrecordheader); ++n) \n    p[n]=d_content.at(d_pos++);\n  ah.d_type=ntohs(ah.d_type);\n  ah.d_class=ntohs(ah.d_class);\n  ah.d_clen=ntohs(ah.d_clen);\n  ah.d_ttl=ntohl(ah.d_ttl);\n  d_startrecordpos=d_pos; \n  d_recordlen=ah.d_clen;\n}", "target": 0}
{"code": "static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,\n                                                       String scriptClassName,\n                                                       const char* source,\n                                                       size_t size) {\n  v8::Isolate* isolate = scriptState->isolate();\n  v8::TryCatch block(isolate);\n  String sourceString(source, size);\n  String fileName = scriptClassName + \".js\";\n   v8::Local<v8::Context> context = scriptState->context();\n   v8::Local<v8::Object> global = context->Global();\n  v8::Local<v8::Value> privateScriptController =\n      global->Get(context, v8String(isolate, \"privateScriptController\"))\n          .ToLocalChecked();\n  RELEASE_ASSERT(privateScriptController->IsUndefined() ||\n                 privateScriptController->IsObject());\n  if (privateScriptController->IsObject()) {\n     v8::Local<v8::Object> privateScriptControllerObject =\n         privateScriptController.As<v8::Object>();\n     v8::Local<v8::Value> importFunctionValue =\n        privateScriptControllerObject->Get(context, v8String(isolate, \"import\"))\n            .ToLocalChecked();\n    if (importFunctionValue->IsUndefined()) {\n      v8::Local<v8::Function> function;\n      if (!v8::FunctionTemplate::New(isolate, importFunction)\n               ->GetFunction(context)\n               .ToLocal(&function) ||\n          !v8CallBoolean(privateScriptControllerObject->Set(\n              context, v8String(isolate, \"import\"), function))) {\n        dumpV8Message(context, block.Message());\n        LOG(FATAL)\n            << \"Private script error: Setting import function failed. (Class \"\n               \"name = \"\n            << scriptClassName.utf8().data() << \")\";\n      }\n    }\n  }\n  v8::Local<v8::Script> script;\n  if (!v8Call(V8ScriptRunner::compileScript(\n                  v8String(isolate, sourceString), fileName, String(),\n                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,\n                  nullptr, NotSharableCrossOrigin),\n              script, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: Compile failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n  v8::Local<v8::Value> result;\n  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),\n              result, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: installClass() failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n  return result;\n}", "target": 1}
{"code": "void ConnectDialogEdit::showNotice(const QString &text) {\n\tQLabel *label = qwInlineNotice->findChild<QLabel *>(QLatin1String(\"qlPasteNotice\"));\n\tQ_ASSERT(label);\n\tlabel->setText(text);\n\tqwInlineNotice->show();\n\tadjustSize();\n}", "target": 0}
{"code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }", "target": 1}
{"code": "aura::RootWindow* DesktopNativeWidgetHelperAura::GetRootWindow() {\n  return root_window_.get();\n}", "target": 0}
{"code": "GF_Err proj_type_box_size(GF_Box *s)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP)\n\t\ts->size += 8;\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI)\n\t\ts->size += 16;\n\telse\n\t\ts->size += 8;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static inline pte_t pte_file_mksoft_dirty(pte_t pte)\n{\n       return pte;\n}", "target": 0}
{"code": "PassRefPtrWillBeRawPtr<Node> ContainerNode::removeChild(PassRefPtrWillBeRawPtr<Node> oldChild, ExceptionState& exceptionState)\n{\n#if !ENABLE(OILPAN)\n    ASSERT(refCount() || parentOrShadowHostNode());\n#endif\n    RefPtrWillBeRawPtr<Node> protect(this);\n    if (!oldChild || oldChild->parentNode() != this || oldChild->isPseudoElement()) {\n        exceptionState.throwDOMException(NotFoundError, \"The node to be removed is not a child of this node.\");\n        return nullptr;\n    }\n    RefPtrWillBeRawPtr<Node> child = oldChild;\n    document().removeFocusedElementOfSubtree(child.get());\n    if (child->parentNode() != this) {\n        exceptionState.throwDOMException(NotFoundError, \"The node to be removed is no longer a child of this node. Perhaps it was moved in a 'blur' event handler?\");\n        return nullptr;\n    }\n    willRemoveChild(*child);\n    if (child->parentNode() != this) {\n        exceptionState.throwDOMException(NotFoundError, \"The node to be removed is no longer a child of this node. Perhaps it was moved in response to a mutation?\");\n        return nullptr;\n    }\n    {\n        HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;\n        Node* prev = child->previousSibling();\n        Node* next = child->nextSibling();\n        removeBetween(prev, next, *child);\n        notifyNodeRemoved(*child);\n        childrenChanged(ChildrenChange::forRemoval(*child, prev, next, ChildrenChangeSourceAPI));\n    }\n    dispatchSubtreeModifiedEvent();\n    return child;\n}", "target": 0}
{"code": " bool NavigateToUrlWithEdge(const base::string16& url) {\n   base::string16 protocol_url = L\"microsoft-edge:\" + url;\n   SHELLEXECUTEINFO info = { sizeof(info) };\n  info.fMask = SEE_MASK_NOASYNC | SEE_MASK_FLAG_NO_UI;\n   info.lpVerb = L\"open\";\n   info.lpFile = protocol_url.c_str();\n   info.nShow = SW_SHOWNORMAL;\n  if (::ShellExecuteEx(&info))\n    return true;\n  PLOG(ERROR) << \"Failed to launch Edge for uninstall survey\";\n  return false;\n}", "target": 1}
{"code": "static void tcp_disable_fack(struct tcp_sock *tp)\n{\n\tif (tcp_is_fack(tp))\n\t\ttp->lost_skb_hint = NULL;\n\ttp->rx_opt.sack_ok &= ~2;\n}", "target": 0}
{"code": "isakmp_rfc3948_print(netdissect_options *ndo,\n \t\t     const u_char *bp, u_int length,\n \t\t     const u_char *bp2)\n {\n \tif(length == 1 && bp[0]==0xff) {\n \t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n \t\treturn;\n\t}\n \tif(length < 4) {\n \t\tgoto trunc;\n \t}\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}", "target": 1}
{"code": "int go7007_snd_init(struct go7007 *go)\n{\n\tstatic int dev;\n\tstruct go7007_snd *gosnd;\n\tint ret;\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\tgosnd = kmalloc(sizeof(struct go7007_snd), GFP_KERNEL);\n\tif (gosnd == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&gosnd->lock);\n\tgosnd->hw_ptr = gosnd->w_idx = gosnd->avail = 0;\n\tgosnd->capturing = 0;\n\tret = snd_card_new(go->dev, index[dev], id[dev], THIS_MODULE, 0,\n\t\t\t   &gosnd->card);\n\tif (ret < 0) {\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tret = snd_device_new(gosnd->card, SNDRV_DEV_LOWLEVEL, go,\n\t\t\t&go7007_snd_device_ops);\n\tif (ret < 0) {\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tret = snd_pcm_new(gosnd->card, \"go7007\", 0, 0, 1, &gosnd->pcm);\n\tif (ret < 0) {\n\t\tsnd_card_free(gosnd->card);\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tstrscpy(gosnd->card->driver, \"go7007\", sizeof(gosnd->card->driver));\n\tstrscpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->shortname));\n\tstrscpy(gosnd->card->longname, gosnd->card->shortname,\n\t\tsizeof(gosnd->card->longname));\n\tgosnd->pcm->private_data = go;\n\tsnd_pcm_set_ops(gosnd->pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&go7007_snd_capture_ops);\n\tret = snd_card_register(gosnd->card);\n\tif (ret < 0) {\n\t\tsnd_card_free(gosnd->card);\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tgosnd->substream = NULL;\n\tgo->snd_context = gosnd;\n\tv4l2_device_get(&go->v4l2_dev);\n\t++dev;\n\treturn 0;\n}", "target": 1}
{"code": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    if (output.size() == 0) {\n      return;\n    }\n    GPUDevice d = ctx->template eigen_device<GPUDevice>();\n    GpuLaunchConfig config = GetGpuLaunchConfig(output.size(), d);\n    TF_CHECK_OK(GpuLaunchKernel(\n        SetToValue<T>, config.block_count, config.thread_per_block, 0,\n        d.stream(), output.size(), output.data(), InitialValueF()()));\n    if (data_size == 0 || segment_ids_shape.num_elements() == 0) {\n      return;\n    }\n    const Index input_outer_dim_size = segment_ids.dimension(0);\n    const Index input_inner_dim_size = data_size / input_outer_dim_size;\n    config = GetGpuLaunchConfig(data_size, d);\n    TF_CHECK_OK(\n        GpuLaunchKernel(UnsortedSegmentCustomKernel<T, Index, ReductionF>,\n                        config.block_count, config.thread_per_block, 0,\n                        d.stream(), input_outer_dim_size, input_inner_dim_size,\n                        num_segments, segment_ids.data(), data, output.data()));\n  }", "target": 1}
{"code": "int HTMLBodyElement::scrollLeft()\n{\n    Document& document = this->document();\n    document.updateLayoutIgnorePendingStylesheets();\n    if (RuntimeEnabledFeatures::scrollTopLeftInteropEnabled()) {\n        RenderBox* render = renderBox();\n        if (!render)\n            return 0;\n        if (render->hasOverflowClip())\n            return adjustForAbsoluteZoom(render->scrollLeft(), render);\n        if (!document.inQuirksMode())\n            return 0;\n    }\n    FrameView* view = document.view();\n    return view ? adjustForZoom(view->scrollX(), &document) : 0;\n}", "target": 0}
{"code": "h2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval = VFP_OK;\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\tLck_Lock(&h2->sess->mtx);\n\tassert (r2->state == H2_S_OPEN);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0) {\n\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n\t\t\t\tretval = VFP_END;\n\t\t\t\tr2->state = H2_S_CLOS_REM;\n\t\t\t}\n\t\t}\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}", "target": 1}
{"code": "pci_emul_cmdsts_write(struct pci_vdev *dev, int coff, uint32_t new, int bytes)\n{\n\tint i, rshift;\n\tuint32_t cmd, cmd2, changed, old, readonly;\n\tcmd = pci_get_cfgdata16(dev, PCIR_COMMAND);\t\n\trshift = (coff & 0x3) * 8;\n\treadonly = 0xFFFFF880 >> rshift;\n\told = CFGREAD(dev, coff, bytes);\n\tnew &= ~readonly;\n\tnew |= (old & readonly);\n\tCFGWRITE(dev, coff, new, bytes);\t\t\n\tcmd2 = pci_get_cfgdata16(dev, PCIR_COMMAND);\t\n\tchanged = cmd ^ cmd2;\n\tfor (i = 0; i <= PCI_BARMAX; i++) {\n\t\tswitch (dev->bar[i].type) {\n\t\tcase PCIBAR_NONE:\n\t\tcase PCIBAR_MEMHI64:\n\t\t\tbreak;\n\t\tcase PCIBAR_IO:\n\t\t\tif (changed & PCIM_CMD_PORTEN) {\n\t\t\t\tif (porten(dev))\n\t\t\t\t\tregister_bar(dev, i);\n\t\t\t\telse\n\t\t\t\t\tunregister_bar(dev, i);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCIBAR_MEM32:\n\t\tcase PCIBAR_MEM64:\n\t\t\tif (changed & PCIM_CMD_MEMEN) {\n\t\t\t\tif (memen(dev))\n\t\t\t\t\tregister_bar(dev, i);\n\t\t\t\telse\n\t\t\t\t\tunregister_bar(dev, i);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t}\n\t}\n\tpci_lintr_update(dev);\n}", "target": 1}
{"code": "void LanLinkProvider::udpBroadcastReceived()\n{\n    while (m_udpSocket.hasPendingDatagrams()) {\n        QByteArray datagram;\n        datagram.resize(m_udpSocket.pendingDatagramSize());\n        QHostAddress sender;\n        m_udpSocket.readDatagram(datagram.data(), datagram.size(), &sender);\n        if (sender.isLoopback() && !m_testMode)\n            continue;\n        NetworkPacket* receivedPacket = new NetworkPacket(QLatin1String(\"\"));\n        bool success = NetworkPacket::unserialize(datagram, receivedPacket);\n        if (!success) {\n            qCDebug(KDECONNECT_CORE) << \"Could not unserialize UDP packet\";\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->type() != PACKET_TYPE_IDENTITY) {\n            qCDebug(KDECONNECT_CORE) << \"Received a UDP packet of wrong type\" << receivedPacket->type();\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) == KdeConnectConfig::instance().deviceId()) {\n            delete receivedPacket;\n            continue;\n        }\n        int tcpPort = receivedPacket->get<int>(QStringLiteral(\"tcpPort\"));\n        if (m_receivedIdentityPackets.size() > MAX_REMEMBERED_IDENTITY_PACKETS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many remembered identities, ignoring\" << receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) << \"received via UDP\";\n            delete receivedPacket;\n            continue;\n        }\n        QSslSocket* socket = new QSslSocket(this);\n        socket->setProxy(QNetworkProxy::NoProxy);\n        m_receivedIdentityPackets[socket].np = receivedPacket;\n        m_receivedIdentityPackets[socket].sender = sender;\n        connect(socket, &QAbstractSocket::connected, this, &LanLinkProvider::tcpSocketConnected);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n        connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n        connect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n        socket->connectToHost(sender, tcpPort);\n    }\n}", "target": 1}
{"code": "uint64_t hllCount(struct hllhdr *hdr, int *invalid) {\n    double m = HLL_REGISTERS;\n    double E;\n    int j;\n    int reghisto[HLL_Q+2] = {0};\n    if (hdr->encoding == HLL_DENSE) {\n        hllDenseRegHisto(hdr->registers,reghisto);\n    } else if (hdr->encoding == HLL_SPARSE) {\n        hllSparseRegHisto(hdr->registers,\n                         sdslen((sds)hdr)-HLL_HDR_SIZE,invalid,reghisto);\n    } else if (hdr->encoding == HLL_RAW) {\n        hllRawRegHisto(hdr->registers,reghisto);\n    } else {\n        serverPanic(\"Unknown HyperLogLog encoding in hllCount()\");\n    }\n    double z = m * hllTau((m-reghisto[HLL_Q+1])/(double)m);\n    for (j = HLL_Q; j >= 1; --j) {\n        z += reghisto[j];\n        z *= 0.5;\n    }\n    z += m * hllSigma(reghisto[0]/(double)m);\n    E = llroundl(HLL_ALPHA_INF*m*m/z);\n    return (uint64_t) E;\n}", "target": 1}
{"code": "void scramble(FILE* keyFile){\n\tfor (int j = 0; j < 16; ++j)\n\t{\n\t\tchar temp = 0;\n\t\tfor (int i = 0; i < 256; ++i)\n\t\t{\n\t\t\tscrambleAsciiTables[j][i] = i;\n\t\t}\n\t\tif (keyFile != NULL){\n\t\t\tint size;\n\t\t\tchar extractedString[BUFFER_SIZE] = \"\";\n\t\t\twhile((size = fread(extractedString, 1, BUFFER_SIZE, keyFile)) > 0){\n\t\t\t\tfor (int i = 0; i < size; ++i)\n\t\t\t\t{\n\t\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][(unsigned char)(extractedString[i])];\n\t\t\t\t\tscrambleAsciiTables[j][(unsigned char)(extractedString[i])] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\trewind(keyFile);\n\t\t} else {\n\t\t\tunsigned char random256;\n\t\t\tfor (int i = 0; i < 10 * 256; ++i)\n\t\t\t{\n\t\t\t\trandom256 = generateNumber() ^ passPhrase[passIndex];\n\t\t\t\tpassIndex++;\n\t\t\t\tpassIndex %= 16384;\n\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][random256];\n\t\t\t\tscrambleAsciiTables[j][random256] = temp;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\tif (line == NULL)\n\t\treturn (0);\n\tif (*line != '<')\n\t\treturn (0);\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "storagePoolLookupByName(virConnectPtr conn,\n                        const char *name)\n{\n    virStoragePoolObj *obj;\n    virStoragePoolDef *def;\n    virStoragePoolPtr pool = NULL;\n    if (!(obj = storagePoolObjFindByName(name)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n    if (virStoragePoolLookupByNameEnsureACL(conn, def) < 0)\n        goto cleanup;\n    pool = virGetStoragePool(conn, def->name, def->uuid, NULL, NULL);\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return pool;\n}", "target": 0}
{"code": "PrintWebViewHelper::PrintPreviewContext::metafile() const {\n  DCHECK(IsRendering());\n  return metafile_.get();\n}", "target": 0}
{"code": "void zmq::stream_engine_t::set_handshake_timer ()\n{\n    zmq_assert (!has_handshake_timer);\n    if (!options.raw_sock && options.handshake_ivl > 0) {\n        add_timer (options.handshake_ivl, handshake_timer_id);\n        has_handshake_timer = true;\n    }\n}", "target": 0}
{"code": "void EditorClientBlackBerry::didBeginEditing()\n{\n    if (m_webPagePrivate->m_dumpRenderTree)\n        m_webPagePrivate->m_dumpRenderTree->didBeginEditing();\n}", "target": 0}
{"code": "static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)\n{\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct sock *sk;\n\tstruct inet_sock *inet;\n\t__be32 daddr;\n\tif (ip_options_echo(&icmp_param->replyopts, skb))\n\t\treturn;\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\tinet = inet_sk(sk);\n\ticmp_param->data.icmph.checksum = 0;\n\tinet->tos = ip_hdr(skb)->tos;\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tif (icmp_param->replyopts.optlen) {\n\t\tipc.opt = &icmp_param->replyopts;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = icmp_param->replyopts.faddr;\n\t}\n\t{\n\t\tstruct flowi4 fl4 = {\n\t\t\t.daddr = daddr,\n\t\t\t.saddr = rt->rt_spec_dst,\n\t\t\t.flowi4_tos = RT_TOS(ip_hdr(skb)->tos),\n\t\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t};\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto out_unlock;\n\t}\n\tif (icmpv4_xrlim_allow(net, rt, icmp_param->data.icmph.type,\n\t\t\t       icmp_param->data.icmph.code))\n\t\ticmp_push_reply(icmp_param, &ipc, &rt);\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\n}", "target": 1}
{"code": "ncp_read_kernel(struct ncp_server *server, const char *file_id,\n\t     __u32 offset, __u16 to_read, char *target, int *bytes_read)\n{\n\tconst char *source;\n\tint result;\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\tif ((result = ncp_request(server, 72)) != 0) {\n\t\tgoto out;\n\t}\n\t*bytes_read = ncp_reply_be16(server, 0);\n\tsource = ncp_reply_data(server, 2 + (offset & 1));\n\tmemcpy(target, source, *bytes_read);\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}", "target": 1}
{"code": "TEST(RegexMatchExpression, MatchesElementExtendedOn) {\n    BSONObj match = BSON(\"x\"\n                         << \"ab\");\n    BSONObj notMatch = BSON(\"x\"\n                            << \"a b\");\n    RegexMatchExpression regex(\"\", \"a b\", \"x\");\n    ASSERT(regex.matchesSingleElement(match.firstElement()));\n    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));\n}", "target": 0}
{"code": "normalizeLines(XML_Char *s)\n{\n  XML_Char *p;\n  for (;; s++) {\n    if (*s == XML_T('\\0'))\n      return;\n    if (*s == 0xD)\n      break;\n  }\n  p = s;\n  do {\n    if (*s == 0xD) {\n      *p++ = 0xA;\n      if (*++s == 0xA)\n        s++;\n    }\n    else\n      *p++ = *s++;\n  } while (*s);\n  *p = XML_T('\\0');\n}", "target": 0}
{"code": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tstruct sshcomp *comp;\n\tint r, mode;\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif (ssh->state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &ssh->state->newkeys[mode]->comp;\n\t\tif (comp && comp->enabled &&\n\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline struct epitem *ep_item_from_epqueue(poll_table *p)\n{\n\treturn container_of(p, struct ep_pqueue, pt)->epi;\n}", "target": 0}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  if (update) return -1;\n  return len;\n}", "target": 1}
{"code": "convert(\n    Imaging imOut, Imaging imIn, const char *mode, ImagingPalette palette, int dither) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (!imIn) {\n        return (Imaging)ImagingError_ModeError();\n    }\n    if (!mode) {\n        if (!imIn->palette) {\n            return (Imaging)ImagingError_ModeError();\n        }\n        mode = imIn->palette->mode;\n    } else {\n        if (!strcmp(imIn->mode, mode)) {\n            return ImagingCopy2(imOut, imIn);\n        }\n    }\n    if (strcmp(imIn->mode, \"P\") == 0 || strcmp(imIn->mode, \"PA\") == 0) {\n        return frompalette(imOut, imIn, mode);\n    }\n    if (strcmp(mode, \"P\") == 0 || strcmp(mode, \"PA\") == 0) {\n        return topalette(imOut, imIn, mode, palette, dither);\n    }\n    if (dither && strcmp(mode, \"1\") == 0) {\n        return tobilevel(imOut, imIn, dither);\n    }\n    convert = NULL;\n    for (y = 0; converters[y].from; y++) {\n        if (!strcmp(imIn->mode, converters[y].from) &&\n            !strcmp(mode, converters[y].to)) {\n            convert = converters[y].convert;\n            break;\n        }\n    }\n    if (!convert) {\n#ifdef notdef\n        return (Imaging)ImagingError_ValueError(\"conversion not supported\");\n#else\n        static char buf[256];\n        sprintf(buf, \"conversion from %s to %s not supported\", imIn->mode, mode);\n        return (Imaging)ImagingError_ValueError(buf);\n#endif\n    }\n    imOut = ImagingNew2Dirty(mode, imOut, imIn);\n    if (!imOut) {\n        return NULL;\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imOut;\n}", "target": 1}
{"code": " char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n {\n\tchar buffer[4096];\n    char buffer2[4096];\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n    int l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n \tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n \tif (SUHOSIN_G(cookie_plainlist)) {\n \t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\n encrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n \t\t\treturn estrndup(value, value_len);\n \t\t}\n \t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n \t\t}\n \t}\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n \tvalue_len = php_url_decode(buf2, value_len);\n \td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n \td_url = php_url_encode(d, strlen(d), &l);\n \tefree(d);\n    if (buf != buffer) {\n\t\tefree(buf);\n\t}\n    if (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n \treturn d_url;\n }", "target": 1}
{"code": "static void set_ntacl_dacl(struct user_namespace *user_ns,\n\t\t\t   struct smb_acl *pndacl,\n\t\t\t   struct smb_acl *nt_dacl,\n\t\t\t   const struct smb_sid *pownersid,\n\t\t\t   const struct smb_sid *pgrpsid,\n\t\t\t   struct smb_fattr *fattr)\n{\n\tstruct smb_ace *ntace, *pndace;\n\tint nt_num_aces = le32_to_cpu(nt_dacl->num_aces), num_aces = 0;\n\tunsigned short size = 0;\n\tint i;\n\tpndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\tif (nt_num_aces) {\n\t\tntace = (struct smb_ace *)((char *)nt_dacl + sizeof(struct smb_acl));\n\t\tfor (i = 0; i < nt_num_aces; i++) {\n\t\t\tmemcpy((char *)pndace + size, ntace, le16_to_cpu(ntace->size));\n\t\t\tsize += le16_to_cpu(ntace->size);\n\t\t\tntace = (struct smb_ace *)((char *)ntace + le16_to_cpu(ntace->size));\n\t\t\tnum_aces++;\n\t\t}\n\t}\n\tset_posix_acl_entries_dacl(user_ns, pndace, fattr,\n\t\t\t\t   &num_aces, &size, nt_num_aces);\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}", "target": 1}
{"code": "public char * shell_quoten(constant char *s, size_t slen)\n{\n\tconstant char *p;\n\tchar *np;\n\tchar *newstr;\n\tsize_t len;\n\tconstant char *esc = get_meta_escape();\n\tsize_t esclen = strlen(esc);\n\tlbool use_quotes = FALSE;\n\tlbool have_quotes = FALSE;\n\tlen = 1; \n\tfor (p = s;  p < s + slen;  p++)\n\t{\n\t\tlen++;\n\t\tif (*p == openquote || *p == closequote)\n\t\t\thave_quotes = TRUE;\n\t\tif (metachar(*p))\n\t\t{\n\t\t\tif (esclen == 0)\n\t\t\t{\n\t\t\t\tuse_quotes = TRUE;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tlen += esclen;\n\t\t\t}\n\t\t}\n\t}\n\tif (use_quotes)\n\t{\n\t\tif (have_quotes)\n\t\t\treturn (NULL);\n\t\tlen = slen + 3;\n\t}\n\tnewstr = np = (char *) ecalloc(len, sizeof(char));\n\tif (use_quotes)\n\t{\n\t\tSNPRINTF4(newstr, len, \"%c%.*s%c\", openquote, (int) slen, s, closequote);\n\t} else\n\t{\n\t\tconstant char *es = s + slen;\n\t\twhile (s < es)\n\t\t{\n\t\t\tif (metachar(*s))\n\t\t\t{\n\t\t\t\tstrcpy(np, esc);\n\t\t\t\tnp += esclen;\n\t\t\t}\n\t\t\t*np++ = *s++;\n\t\t}\n\t\t*np = '\\0';\n\t}\n\treturn (newstr);\n}", "target": 1}
{"code": "R_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {\n\tRSocket *s;\n\tbool ssl = r_str_startswith (url, \"https:\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\tchar *host = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\tprintf (\"Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tchar *port = strchr (host, ':');\n\tif (!port) {\n\t\tport = (ssl)? \"443\": \"80\";\n\t} else {\n\t\t*port++ = 0;\n\t}\n\tchar *path = strchr (host, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\tprintf (\"Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (!r_socket_connect_tcp (s, host, port, 0)) {\n\t\teprintf (\"Cannot connect to %s:%s\\n\", host, port);\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tr_socket_printf (s,\n\t\t\t\"POST /%s HTTP/1.0\\r\\n\"\n\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\"Accept: *", "target": 1}
{"code": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = *data++;\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\treturn data;\n}", "target": 1}
{"code": "Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t size_bound =\n      ss->ByteSize() + kTensorProtoHeaderBytes +\n      (MaxBytesPerElement(DataTypeToEnum<T>::value) * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }\n  Fill(data, num_elements, ss->mutable_data());\n  DCHECK_GE(ss->ByteSize(), 0);\n  DCHECK_LE(ss->ByteSize(), size_bound);\n  return OkStatus();\n}", "target": 1}
{"code": "void OutOfMem(size_t size)\n{\n    FatalError(\"Out of memory on allocating %d bytes.\", size);\n}", "target": 0}
{"code": "static int ssl_write_certificate_verify( mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    int ret;\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write certificate verify\" ) );\n    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n        return( ret );\n    }\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}", "target": 0}
{"code": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n \t\treturn -EPROTONOSUPPORT;\n \thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n \terr = hci_uart_register_dev(hu);\n \tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n \t\treturn err;\n \t}\n \treturn 0;\n }", "target": 1}
{"code": "is_mbc_ambiguous(OnigCaseFoldType flag,\n\t\t const UChar** pp, const UChar* end)\n{\n  int v;\n  const UChar* p = *pp;\n  if (*p == SHARP_s && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    (*pp)++;\n    return TRUE;\n  }\n  (*pp)++;\n  v = (EncISO_8859_15_CtypeTable[*p] & (BIT_CTYPE_UPPER | BIT_CTYPE_LOWER));\n  if ((v | BIT_CTYPE_LOWER) != 0) {\n    if (*p == 0xaa || *p == 0xb5 || *p == 0xba)\n      return FALSE;\n    else\n      return TRUE;\n  }\n  return (v != 0 ? TRUE : FALSE);\n}", "target": 0}
{"code": "static unsigned int snd_disconnect_poll(struct file * file, poll_table * wait)\n{\n\treturn POLLERR | POLLNVAL;\n}", "target": 0}
{"code": "void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartcol;\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = numrows - hstartcol;\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "m_wnum1(union DateData *x)\n{\n    return m_wnumx(x, 1);\n}", "target": 0}
{"code": "uint8_t WasmBinaryBuilder::getLaneIndex(size_t lanes) {\n  BYN_TRACE(\"<==\\n\");\n  auto ret = getInt8();\n  if (ret >= lanes) {\n    throwError(\"Illegal lane index\");\n  }\n  BYN_TRACE(\"getLaneIndex(\" << lanes << \"): \" << ret << \" ==>\" << std::endl);\n  return ret;\n}", "target": 0}
{"code": " static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n {\n\tu8 *gb_cur, *version_tlv, version, version_length;\n\tu8 *lto_tlv, lto_length;\n\tu8 *wks_tlv, wks_length;\n\tu8 *miux_tlv, miux_length;\n \t__be16 wks = cpu_to_be16(local->local_wks);\n \tu8 gb_len = 0;\n \tint ret = 0;\n \tversion = LLCP_VERSION_11;\n \tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n \t\t\t\t\t 1, &version_length);\n \tgb_len += version_length;\n \tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n \tgb_len += lto_length;\n \tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n \twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n \tgb_len += wks_length;\n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n \t\t\t\t      &miux_length);\n \tgb_len += miux_length;\n \tgb_len += ARRAY_SIZE(llcp_magic);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tgb_cur = local->gb;\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\tlocal->gb_len = gb_len;\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\treturn ret;\n}", "target": 1}
{"code": "void GLES2DecoderWithShaderTestBase::DoBufferSubData(\n    GLenum target, GLint offset, GLsizei size, const void* data) {\n  EXPECT_CALL(*gl_, BufferSubData(target, offset, size,\n                                  shared_memory_address_))\n      .Times(1)\n      .RetiresOnSaturation();\n  memcpy(shared_memory_address_, data, size);\n  BufferSubData cmd;\n  cmd.Init(target, offset, size, shared_memory_id_, shared_memory_offset_);\n  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));\n}", "target": 0}
{"code": "static int propagate_liveness_reg(struct bpf_verifier_env *env,\n\t\t\t\t  struct bpf_reg_state *reg,\n\t\t\t\t  struct bpf_reg_state *parent_reg)\n{\n\tu8 parent_flag = parent_reg->live & REG_LIVE_READ;\n\tu8 flag = reg->live & REG_LIVE_READ;\n\tint err;\n\tif (parent_flag == REG_LIVE_READ64 ||\n\t    !flag ||\n\t    parent_flag == flag)\n\t\treturn 0;\n\terr = mark_reg_read(env, reg, parent_reg, flag);\n\tif (err)\n\t\treturn err;\n\treturn flag;\n}", "target": 0}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\tif (threshold > 100.0) {\n \t\treturn NULL;\n \t}\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\treturn gdImageCrop(im, &crop);\n}", "target": 1}
{"code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  \n\treturn escaped;\n}", "target": 1}
{"code": "static void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret)\n{\n\tMD5_CTX md5_secret, my_md5;\n\tunsigned char misc[AUTH_VECTOR_LEN];\n\tint i;\n\tint length = strlen(password);\n\tunsigned char hashed[256 + AUTH_PASS_LEN];\t\n\tunsigned char *vector;\n\tattribute_t *attr;\n\tif (length > MAXPASS) {\t\t\t\t\n\t\tlength = MAXPASS;\n\t}\n\tif (length == 0) {\n\t\tlength = AUTH_PASS_LEN;\t\t\t\n\t} if ((length & (AUTH_PASS_LEN - 1)) != 0) {\n\t\tlength += (AUTH_PASS_LEN - 1);\t\t\n\t\tlength &= ~(AUTH_PASS_LEN - 1);\t\t\n\t}\t\t\t\t\t\t\n\tmemset(hashed, 0, length);\n\tmemcpy(hashed, password, strlen(password));\n\tattr = find_attribute(request, PW_PASSWORD);\n\tif (type == PW_PASSWORD) {\n\t\tvector = request->vector;\n\t} else {\n\t\tvector = attr->data;\t\t\t\n\t}\n\tMD5Init(&md5_secret);\n\tMD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));\n\tmy_md5 = md5_secret;\t\t\t\t\n\tMD5Update(&my_md5, vector, AUTH_VECTOR_LEN);\n\tMD5Final(misc, &my_md5);\t\t\t\n\txor(hashed, misc, AUTH_PASS_LEN);\n\tfor (i = 1; i < (length >> 4); i++) {\n\t\tmy_md5 = md5_secret;\t\t\t\n\t\tMD5Update(&my_md5, &hashed[(i-1) * AUTH_PASS_LEN], AUTH_PASS_LEN);\n\t\tMD5Final(misc, &my_md5);\t\t\t\n\t\txor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);\n\t}\n\tif (type == PW_OLD_PASSWORD) {\n\t\tattr = find_attribute(request, PW_OLD_PASSWORD);\n\t}\n\tif (!attr) {\n\t\tadd_attribute(request, type, hashed, length);\n\t} else {\n\t\tmemcpy(attr->data, hashed, length); \n\t}\n}", "target": 1}
{"code": "static int php_zip_ops_close(php_stream *stream, int close_handle TSRMLS_DC)\n{\n\tSTREAM_DATA_FROM_STREAM();\n\tif (close_handle) {\n\t\tif (self->zf) {\n\t\t\tzip_fclose(self->zf);\n\t\t\tself->zf = NULL;\n\t\t}\n\t\tif (self->za) {\n\t\t\tzip_close(self->za);\n\t\t\tself->za = NULL;\n\t\t}\n\t}\n\tefree(self);\n\tstream->abstract = NULL;\n\treturn EOF;\n}", "target": 0}
{"code": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n \tunsigned long inodes;\n \tint error = -EINVAL;\n \tif (shmem_parse_options(data, &config, true))\n \t\treturn error;\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n \tsbinfo->max_inodes  = config.max_inodes;\n \tsbinfo->free_inodes = config.max_inodes - inodes;\n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t\n out:\n \tspin_unlock(&sbinfo->stat_lock);\n \treturn error;\n}", "target": 1}
{"code": "void HeaderToMetadataFilter::setDecoderFilterCallbacks(\n    Http::StreamDecoderFilterCallbacks& callbacks) {\n  decoder_callbacks_ = &callbacks;\n}", "target": 0}
{"code": "String *Item_cache_wrapper::val_str(String* str)\n{\n  Item *cached_value;\n  DBUG_ENTER(\"Item_cache_wrapper::val_str\");\n  if (!expr_cache)\n  {\n    String *tmp= orig_item->val_str(str);\n    null_value= orig_item->null_value;\n    DBUG_RETURN(tmp);\n  }\n  if ((cached_value= check_cache()))\n  {\n    String *tmp= cached_value->val_str(str);\n    null_value= cached_value->null_value;\n    DBUG_RETURN(tmp);\n  }\n  cache();\n  if ((null_value= expr_value->null_value))\n    DBUG_RETURN(NULL);\n  DBUG_RETURN(expr_value->val_str(str));\n}", "target": 0}
{"code": "    long Xmpdatum::copy(byte* , ByteOrder ) const\n    {\n        throw Error(kerFunctionNotSupported, \"Xmpdatum::copy\");\n        return 0;\n    }", "target": 0}
{"code": "void for_each_server(PgPool *pool, void (*func)(PgSocket *sk))\n{\n\tstruct List *item;\n\tstatlist_for_each(item, &pool->idle_server_list)\n\t\tfunc(container_of(item, PgSocket, head));\n\tstatlist_for_each(item, &pool->used_server_list)\n\t\tfunc(container_of(item, PgSocket, head));\n\tstatlist_for_each(item, &pool->tested_server_list)\n\t\tfunc(container_of(item, PgSocket, head));\n\tstatlist_for_each(item, &pool->active_server_list)\n\t\tfunc(container_of(item, PgSocket, head));\n\tstatlist_for_each(item, &pool->new_server_list)\n\t\tfunc(container_of(item, PgSocket, head));\n}", "target": 0}
{"code": "u32 h264bsdInitDpb(\n dpbStorage_t *dpb,\n  u32 picSizeInMbs,\n  u32 dpbSize,\n  u32 maxRefFrames,\n  u32 maxFrameNum,\n  u32 noReordering)\n{\n    u32 i;\n    ASSERT(picSizeInMbs);\n    ASSERT(maxRefFrames <= MAX_NUM_REF_PICS);\n    ASSERT(maxRefFrames <= dpbSize);\n     ASSERT(maxFrameNum);\n     ASSERT(dpbSize);\n     dpb->maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES;\n     dpb->maxRefFrames        = MAX(maxRefFrames, 1);\n     if (noReordering)\n        dpb->dpbSize         = dpb->maxRefFrames;\n else\n        dpb->dpbSize         = dpbSize;\n    dpb->maxFrameNum         = maxFrameNum;\n    dpb->noReordering        = noReordering;\n    dpb->fullness            = 0;\n    dpb->numRefFrames        = 0;\n    dpb->prevRefFrameNum     = 0;\n    ALLOCATE(dpb->buffer, MAX_NUM_REF_IDX_L0_ACTIVE + 1, dpbPicture_t);\n if (dpb->buffer == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n    H264SwDecMemset(dpb->buffer, 0,\n (MAX_NUM_REF_IDX_L0_ACTIVE + 1)*sizeof(dpbPicture_t));\n for (i = 0; i < dpb->dpbSize + 1; i++)\n {\n        ALLOCATE(dpb->buffer[i].pAllocatedData, (picSizeInMbs*384 + 32+15), u8);\n if (dpb->buffer[i].pAllocatedData == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n        dpb->buffer[i].data = ALIGN(dpb->buffer[i].pAllocatedData, 16);\n }\n    ALLOCATE(dpb->list, MAX_NUM_REF_IDX_L0_ACTIVE + 1, dpbPicture_t*);\n    ALLOCATE(dpb->outBuf, dpb->dpbSize+1, dpbOutPicture_t);\n if (dpb->list == NULL || dpb->outBuf == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n    H264SwDecMemset(dpb->list, 0,\n ((MAX_NUM_REF_IDX_L0_ACTIVE + 1) * sizeof(dpbPicture_t*)) );\n    dpb->numOut = dpb->outIndex = 0;\n return(HANTRO_OK);\n}", "target": 1}
{"code": "static ssize_t revision_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\treturn snprintf(buf, 20, \"%u\\n\", id.device_revision & 0x0F);\n}", "target": 0}
{"code": "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\tstruct search_domain *dom;\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\tEVUTIL_ASSERT(0);\n\treturn NULL; \n}", "target": 1}
{"code": "bool Item_field::is_null_result()\n{\n  return (null_value=result_field->is_null());\n}", "target": 0}
{"code": "get_manuf_name_if_known(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    guint manuf_key;\n    guint8 oct;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {\n        return manuf_value->resolved_longname;\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return long_name;\n    }\n    return NULL;\n} ", "target": 1}
{"code": "rleUncompress (int inLength, int maxLength, const signed char in[], char out[])\n{\n    char *outStart = out;\n    while (inLength > 0)\n    {\n\tif (*in < 0)\n\t{\n\t    int count = -((int)*in++);\n\t    inLength -= count + 1;\n\t    if (0 > (maxLength -= count))\n\t\treturn 0;\n        if (inLength < 0)\n          return 0;\n        memcpy(out, in, count);\n        out += count;\n        in  += count;\n\t}\n\telse\n\t{\n\t    int count = *in++;\n\t    inLength -= 2;\n\t    if (0 > (maxLength -= count + 1))\n\t\treturn 0;\n        memset(out, *(char*)in, count+1);\n        out += count+1;\n\t    in++;\n\t}\n    }\n    return out - outStart;\n}", "target": 1}
{"code": "static UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tStream_Read_UINT16(s, eventId);   \n\tStream_Read_UINT32(s, pduLength); \n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n    const Tensor& num_segments = context->input(2);\n    if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids,\n                                              num_segments)) {\n      return;\n    }\n    const auto segment_flat = segment_ids.flat<Index>();\n    const Index output_rows = internal::SubtleMustCopy(static_cast<Index>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n    TensorShape output_shape;\n    output_shape.AddDim(output_rows);\n    for (int i = segment_ids.dims(); i < data.dims(); i++) {\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_ptr = data.template flat<T>().data();\n    reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat,\n                       data.NumElements(), data_ptr, output_flat);\n  }", "target": 1}
{"code": "struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\tif (!bin->nlibs)\n\t\treturn NULL;\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))\n\t\treturn NULL;\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}", "target": 1}
{"code": "static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n \tstruct pptp_opt *opt = &po->proto.pptp;\n \tint error = 0;\n \tlock_sock(sk);\n \topt->src_addr = sp->sa_addr.pptp;\n\tif (add_chan(po))\n\t\terror = -EBUSY;\n\trelease_sock(sk);\n\treturn error;\n}", "target": 1}
{"code": "init_sum_functions(Item_sum **func_ptr, Item_sum **end_ptr)\n{\n  for (; func_ptr != end_ptr ;func_ptr++)\n  {\n    if ((*func_ptr)->reset_and_add())\n      return 1;\n  }\n  for ( ; *func_ptr ; func_ptr++)\n  {\n    if ((*func_ptr)->aggregator_add())\n      return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_diff_assoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Array& args ) {\n  diff_intersect_body(diff, args, true COMMA true);\n}", "target": 0}
{"code": "check_REG_MOVE(const struct ofpact_reg_move *a,\n               const struct ofpact_check_params *cp)\n{\n    return nxm_reg_move_check(a, cp->match);\n}", "target": 0}
{"code": "static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,\n                                                    UINT32 x, UINT32 y, UINT32 width, UINT32 height)\n{\n\tVideoClientContextPriv* priv = video->priv;\n\tPresentationContext* ret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\tret->video = video;\n\tret->PresentationId = PresentationId;\n\tret->h264 = h264_context_new(FALSE);\n\tif (!ret->h264)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create a h264 context\");\n\t\tgoto error_h264;\n\t}\n\th264_context_reset(ret->h264, width, height);\n\tret->currentSample = Stream_New(NULL, 4096);\n\tif (!ret->currentSample)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create current packet stream\");\n\t\tgoto error_currentSample;\n\t}\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, width * height * 4);\n\tif (!ret->surfaceData)\n\t{\n\t\tWLog_ERR(TAG, \"unable to allocate surfaceData\");\n\t\tgoto error_surfaceData;\n\t}\n\tret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height);\n\tif (!ret->surface)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create surface\");\n\t\tgoto error_surface;\n\t}\n\tret->yuv = yuv_context_new(FALSE);\n\tif (!ret->yuv)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create YUV decoder\");\n\t\tgoto error_yuv;\n\t}\n\tyuv_context_reset(ret->yuv, width, height);\n\tret->refCounter = 1;\n\treturn ret;\nerror_yuv:\n\tvideo->deleteSurface(video, ret->surface);\nerror_surface:\n\tBufferPool_Return(priv->surfacePool, ret->surfaceData);\nerror_surfaceData:\n\tStream_Free(ret->currentSample, TRUE);\nerror_currentSample:\n\th264_context_free(ret->h264);\nerror_h264:\n\tfree(ret);\n\treturn NULL;\n}", "target": 1}
{"code": "SWFShape_drawScaledLineTo(SWFShape shape, int x, int y)\n{\n\tSWFShape_drawScaledLine(shape, x-shape->xpos, y-shape->ypos);\n}", "target": 0}
{"code": "static u32 *gen8_emit_fini_breadcrumb_rcs(struct i915_request *request, u32 *cs)\n{\n\tcs = gen8_emit_pipe_control(cs,\n\t\t\t\t    PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH |\n\t\t\t\t    PIPE_CONTROL_DEPTH_CACHE_FLUSH |\n\t\t\t\t    PIPE_CONTROL_DC_FLUSH_ENABLE,\n\t\t\t\t    0);\n\tcs = gen8_emit_ggtt_write_rcs(cs,\n\t\t\t\t      request->fence.seqno,\n\t\t\t\t      i915_request_active_timeline(request)->hwsp_offset,\n\t\t\t\t      PIPE_CONTROL_FLUSH_ENABLE |\n\t\t\t\t      PIPE_CONTROL_CS_STALL);\n\treturn gen8_emit_fini_breadcrumb_footer(request, cs);\n}", "target": 0}
{"code": "MenuCacheItem *menu_cache_find_child_by_name(MenuCacheDir *dir, const char *name)\n{\n    GSList *child;\n    MenuCacheItem *item = NULL;\n    if (MENU_CACHE_ITEM(dir)->type != MENU_CACHE_TYPE_DIR || name == NULL)\n        return NULL;\n    MENU_CACHE_LOCK;\n    for (child = dir->children; child; child = child->next)\n        if (g_strcmp0(MENU_CACHE_ITEM(child->data)->name, name) == 0)\n        {\n            item = menu_cache_item_ref(child->data);\n            break;\n        }\n    MENU_CACHE_UNLOCK;\n    return item;\n}", "target": 0}
{"code": "int ldb_match_message(struct ldb_context *ldb,\n\t\t      const struct ldb_message *msg,\n\t\t      const struct ldb_parse_tree *tree,\n\t\t      enum ldb_scope scope, bool *matched)\n{\n\tunsigned int i;\n\tint ret;\n\t*matched = false;\n\tif (scope != LDB_SCOPE_BASE && ldb_dn_is_special(msg->dn)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tswitch (tree->operation) {\n\tcase LDB_OP_AND:\n\t\tfor (i=0;i<tree->u.list.num_elements;i++) {\n\t\t\tret = ldb_match_message(ldb, msg, tree->u.list.elements[i], scope, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (!*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = true;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_OR:\n\t\tfor (i=0;i<tree->u.list.num_elements;i++) {\n\t\t\tret = ldb_match_message(ldb, msg, tree->u.list.elements[i], scope, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = false;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_NOT:\n\t\tret = ldb_match_message(ldb, msg, tree->u.isnot.child, scope, matched);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t*matched = ! *matched;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_EQUALITY:\n\t\treturn ldb_match_equality(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_SUBSTRING:\n\t\treturn ldb_match_substring(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_GREATER:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_GREATER, matched);\n\tcase LDB_OP_LESS:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_LESS, matched);\n\tcase LDB_OP_PRESENT:\n\t\treturn ldb_match_present(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_APPROX:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_APPROX, matched);\n\tcase LDB_OP_EXTENDED:\n\t\treturn ldb_match_extended(ldb, msg, tree, scope, matched);\n\t}\n\treturn LDB_ERR_INAPPROPRIATE_MATCHING;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::SetNeedsBeginFrame(bool needs_begin_frames) {\n  if (needs_begin_frames_ == needs_begin_frames)\n    return;\n  needs_begin_frames_ = needs_begin_frames;\n  if (view_)\n    view_->SetNeedsBeginFrames(needs_begin_frames);\n}", "target": 0}
{"code": "void IndexedDBDatabase::ReportErrorWithDetails(Status status,\n                                               const char* message) {\n  DCHECK(!status.ok());\n  if (status.IsCorruption()) {\n    IndexedDBDatabaseError error(blink::kWebIDBDatabaseExceptionUnknownError,\n                                 message);\n    factory_->HandleBackingStoreCorruption(backing_store_->origin(), error);\n  } else {\n    factory_->HandleBackingStoreFailure(backing_store_->origin());\n  }\n}", "target": 0}
{"code": "void DCR_CLASS dcr_parse_riff(DCRAW* p)\n{\n\tunsigned i, size, end;\n\tchar tag[4], date[64], month[64];\n\tstatic const char mon[12][4] =\n\t{ \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n\tstruct tm t;\n\tp->order = 0x4949;\n\tdcr_fread(p->obj_, tag, 4, 1);\n\tsize = dcr_get4(p);\n\tend = dcr_ftell(p->obj_) + size;\n\tif (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n\t\tdcr_get4(p);\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end)\n\t\t\tdcr_parse_riff(p);\n\t} else if (!memcmp(tag,\"nctg\",4)) {\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end) {\n\t\t\ti = dcr_get2(p);\n\t\t\tsize = dcr_get2(p);\n\t\t\tif ((i+1) >> 1 == 10 && size == 20)\n\t\t\t\tdcr_get_timestamp(p,0);\n\t\t\telse dcr_fseek(p->obj_, size, SEEK_CUR);\n\t\t}\n\t} else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n\t\tdcr_fread(p->obj_, date, 64, 1);\n\t\tdate[size] = 0;\n\t\tmemset (&t, 0, sizeof t);\n\t\tif (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t\t\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n\t\t\tfor (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n\t\t\tt.tm_mon = i;\n\t\t\tt.tm_year -= 1900;\n\t\t\tif (mktime(&t) > 0)\n\t\t\t\tp->timestamp = mktime(&t);\n\t\t}\n\t} else\n\t\tdcr_fseek(p->obj_, size, SEEK_CUR);\n}", "target": 1}
{"code": "void appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        if (checkType(c,o,OBJ_STRING))\n            return;\n        append = c->argv[2];\n        totlen = stringObjectLen(o)+sdslen(append->ptr);\n        if (checkStringLength(c,totlen) != C_OK)\n            return;\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}", "target": 1}
{"code": "ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {\n  bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));\n  const std::string server_name_indication = options && options->serverNameOverride().has_value()\n                                                 ? options->serverNameOverride().value()\n                                                 : server_name_indication_;\n  if (!server_name_indication.empty()) {\n    const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());\n    RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  if (options && !options->verifySubjectAltNameListOverride().empty()) {\n    SSL_set_verify(ssl_con.get(), SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);\n  }\n  bool has_alpn_defined = !parsed_alpn_protocols_.empty();\n  if (options) {\n    has_alpn_defined |= parseAndSetAlpn(options->applicationProtocolListOverride(), *ssl_con);\n  }\n  if (options && !has_alpn_defined && !options->applicationProtocolFallback().empty()) {\n    parseAndSetAlpn(options->applicationProtocolFallback(), *ssl_con);\n  }\n  if (allow_renegotiation_) {\n    SSL_set_renegotiate_mode(ssl_con.get(), ssl_renegotiate_freely);\n  }\n  SSL_set_enforce_rsa_key_usage(ssl_con.get(), enforce_rsa_key_usage_);\n  if (max_session_keys_ > 0) {\n    if (session_keys_single_use_) {\n      absl::WriterMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n        if (SSL_SESSION_should_be_single_use(session)) {\n          session_keys_.pop_front();\n        }\n      }\n    } else {\n      absl::ReaderMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n      }\n    }\n  }\n  return ssl_con;\n}", "target": 1}
{"code": "static Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Interp *interp = tree->opts.interp;\n    Jsi_Obj *obj = (Jsi_Obj*)data;\n    int n;\n    if (!hPtr->f.bits.dontenum) {\n        char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);\n        if (!cp || !isdigit(*cp))\n            return JSI_OK;\n        n = (int)strtol(cp, &ep, 0);\n        if (n<0 || n >= interp->maxArrayList)\n            return JSI_OK;\n        hPtr->f.bits.isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) \n            return Jsi_LogError(\"too long\");\n        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "sctp_disposition_t sctp_sf_not_impl(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\treturn SCTP_DISPOSITION_NOT_IMPL;\n}", "target": 0}
{"code": "ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n     case EXPR_INVERT:\n     case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n         if (ok)\n             *set_rtrn = !*set_rtrn;\n         return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}", "target": 1}
{"code": "static void storm_memset_spq_addr(struct bnx2x *bp,\n\t\t\t\t  dma_addr_t mapping, u16 abs_fid)\n{\n\tu32 addr = XSEM_REG_FAST_MEMORY +\n\t\t\tXSTORM_SPQ_PAGE_BASE_OFFSET(abs_fid);\n\t__storm_memset_dma_mapping(bp, addr, mapping);\n}", "target": 0}
{"code": "sg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\tsrp->data.cmd_opcode = cmnd[0];\t\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n\t\treturn k;\t\n\t}\n\tif (atomic_read(&sdp->detaching)) {\n\t\tif (srp->bio)\n\t\t\tblk_end_request_all(srp->rq, -EIO);\n\t\tsg_finish_rem_req(srp);\n\t\treturn -ENODEV;\n\t}\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); \n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}", "target": 1}
{"code": "static int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n\tbool grab_newname = false;\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n\t}\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n\t}\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n\t}\n\tclose(fd); fd = -1;\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n\t}\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto out_err;\n\t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n\t}\n\tclose(ofd);\n\treturn 0;\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn -1;\n}", "target": 1}
{"code": " ActionReply Smb4KMountHelper::mount(const QVariantMap &args)\n {\n   ActionReply reply;\n   QMapIterator<QString, QVariant> it(args);\n    proc.setOutputChannelMode(KProcess::SeparateChannels);\n    proc.setProcessEnvironment(QProcessEnvironment::systemEnvironment());\n#if defined(Q_OS_LINUX)\n    proc.setEnv(\"PASSWD\", entry[\"mh_url\"].toUrl().password(), true);\n#endif\n     QVariantMap entry = it.value().toMap();\n     KProcess proc(this);\n    command << entry[\"mh_mountpoint\"].toString();\n    command << entry[\"mh_options\"].toStringList();\n#elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n    command << entry[\"mh_command\"].toString();\n    command << entry[\"mh_options\"].toStringList();\n    command << entry[\"mh_unc\"].toString();\n    command << entry[\"mh_mountpoint\"].toString();\n#else\n#endif\n    proc.setProgram(command);\n    proc.start();\n    if (proc.waitForStarted(-1))\n    {\n      bool userKill = false;\n     QStringList command;\n #if defined(Q_OS_LINUX)\n    command << entry[\"mh_command\"].toString();\n     command << entry[\"mh_unc\"].toString();\n     command << entry[\"mh_mountpoint\"].toString();\n     command << entry[\"mh_options\"].toStringList();\n #elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n    command << entry[\"mh_command\"].toString();\n     command << entry[\"mh_options\"].toStringList();\n     command << entry[\"mh_unc\"].toString();\n     command << entry[\"mh_mountpoint\"].toString();\n        else\n        {\n        }\n        if (HelperSupport::isStopped())\n        {\n          proc.kill();\n          userKill = true;\n          break;\n        }\n        else\n        {\n        }\n      }\n      if (proc.exitStatus() == KProcess::CrashExit)\n      {\n        if (!userKill)\n        {\n          reply.setType(ActionReply::HelperErrorType);\n          reply.setErrorDescription(i18n(\"The mount process crashed.\"));\n          break;\n        }\n        else\n        {\n        }\n      }\n      else\n      {\n        QString stdErr = QString::fromUtf8(proc.readAllStandardError());\n        reply.addData(QString(\"mh_error_message_%1\").arg(index), stdErr.trimmed());\n      }\n    }", "target": 1}
{"code": "ZEND_API zval *zend_read_static_property(zend_class_entry *scope, const char *name, int name_length, zend_bool silent TSRMLS_DC) \n{\n\tzval **property;\n\tzend_class_entry *old_scope = EG(scope);\n\tEG(scope) = scope;\n\tproperty = zend_std_get_static_property(scope, name, name_length, silent, NULL TSRMLS_CC);\n\tEG(scope) = old_scope;\n\treturn property?*property:NULL;\n}", "target": 0}
{"code": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n \tint error;\n \tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n \t}\n \tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}", "target": 1}
{"code": "*/\nPHP_METHOD(DateTimeImmutable, setDate)\n{\n\tzval *object, *new_object;\n\tlong  y, m, d;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Olll\", &object, date_ce_immutable, &y, &m, &d) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tnew_object = date_clone_immutable(object TSRMLS_CC);\n\tphp_date_date_set(new_object, y, m, d, return_value TSRMLS_CC);\n\tRETURN_ZVAL(new_object, 0, 1);", "target": 0}
{"code": "static inline Quantum ScaleCharToQuantum(const unsigned char value)\n{\n  return((Quantum) value);\n}", "target": 0}
{"code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n \tbee_t *bee = ic->bee;\n \tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\tif (bee->ui->ft_in_start) {\n \t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n \t} else {\n \t\treturn NULL;\n\t}\n}", "target": 1}
{"code": "static void ConvertLoopSequence(ModSample &smp, STPLoopList &loopList)\n{\n\tif(!smp.HasSampleData() || loopList.size() < 2) return;\n\tModSample newSmp = smp;\n\tnewSmp.nLength = 0;\n\tnewSmp.pSample = nullptr;\n\tsize_t numLoops = loopList.size();\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\t\tif((newSmp.nLength + info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopStart + info.loopLength > smp.nLength))\n\t\t{\n\t\t\tnumLoops = i;\n\t\t\tbreak;\n\t\t}\n\t\tnewSmp.nLength += info.loopLength;\n\t}\n\tif(!newSmp.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\tSmpLength start = 0;\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\t\tmemcpy(newSmp.pSample8 + start, smp.pSample8 + info.loopStart, info.loopLength);\n\t\tinfo.loopStart = start;\n\t\tif(i > 0 && i <= mpt::size(newSmp.cues))\n\t\t{\n\t\t\tnewSmp.cues[i - 1] = start;\n\t\t}\n\t\tstart += info.loopLength;\n\t}\n\tsmp.FreeSample();\n\tsmp = newSmp;\n\tsmp.nLoopStart = 0;\n\tsmp.nLoopEnd = smp.nLength;\n\tsmp.uFlags.set(CHN_LOOP);\n}", "target": 1}
{"code": "static int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n\tstruct pppol2tp_session *ps;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlen = min_t(unsigned int, len, sizeof(int));\n\tif (len < 0)\n\t\treturn -EINVAL;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\tif (copy_to_user((void __user *) optval, &val, len))\n\t\tgoto end_put_sess;\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n  DCHECK_EQ(-1, mapped_file_);\n  if (options.size == 0) return false;\n  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))\n    return false;\n  base::ThreadRestrictions::ScopedAllowIO allow_io;\n  FILE *fp;\n  bool fix_size = true;\n  FilePath path;\n  if (options.name == NULL || options.name->empty()) {\n    DCHECK(!options.open_existing);\n    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);\n    if (fp) {\n      if (unlink(path.value().c_str()))\n        PLOG(WARNING) << \"unlink\";\n    }\n  } else {\n     if (!FilePathForMemoryName(*options.name, &path))\n       return false;\n    fp = file_util::OpenFile(path, \"w+x\");\n    if (fp == NULL && options.open_existing) {\n      fp = file_util::OpenFile(path, \"a+\");\n       fix_size = false;\n     }\n   }\n   if (fp && fix_size) {\n    struct stat stat;\n    if (fstat(fileno(fp), &stat) != 0) {\n      file_util::CloseFile(fp);\n      return false;\n    }\n    const size_t current_size = stat.st_size;\n    if (current_size != options.size) {\n      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {\n        file_util::CloseFile(fp);\n        return false;\n      }\n    }\n    requested_size_ = options.size;\n  }\n  if (fp == NULL) {\n#if !defined(OS_MACOSX)\n    PLOG(ERROR) << \"Creating shared memory in \" << path.value() << \" failed\";\n    FilePath dir = path.DirName();\n    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {\n      PLOG(ERROR) << \"Unable to access(W_OK|X_OK) \" << dir.value();\n      if (dir.value() == \"/dev/shm\") {\n        LOG(FATAL) << \"This is frequently caused by incorrect permissions on \"\n                   << \"/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix.\";\n      }\n    }\n#else\n    PLOG(ERROR) << \"Creating shared memory in \" << path.value() << \" failed\";\n#endif\n    return false;\n  }\n  return PrepareMapFile(fp);\n}", "target": 1}
{"code": "static int matchFunc(const char*)\n{\n    return XMLTokenizerScope::currentDocLoader && currentThread() == libxmlLoaderThread;\n}", "target": 0}
{"code": "void GfxIndexedColorSpace::getGray(const GfxColor *color, GfxGray *gray) const\n{\n    GfxColor color2;\n    base->getGray(mapColorToBase(color, &color2), gray);\n}", "target": 0}
{"code": " crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n {\n    static uid_t uid_server = 0;\n     static gid_t gid_cluster = 0;\n     crm_client_t *client = NULL;\n    CRM_LOG_ASSERT(c);\n    if (c == NULL) {\n        return NULL;\n     }\n     if (gid_cluster == 0) {\n        uid_server = getuid();\n         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n             static bool have_error = FALSE;\n             if(have_error == FALSE) {\n                crm_warn(\"Could not find group for user %s\", CRM_DAEMON_USER);\n                have_error = TRUE;\n            }\n         }\n     }\n    if(gid_cluster != 0 && gid_client != 0) {\n        uid_t best_uid = -1; \n        if(uid_client == 0 || uid_server == 0) { \n            best_uid = QB_MAX(uid_client, uid_server);\n            crm_trace(\"Allowing user %u to clean up after disconnect\", best_uid);\n        }\n         crm_trace(\"Giving access to group %u\", gid_cluster);\n        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n     }\n     crm_client_init();\n    client = calloc(1, sizeof(crm_client_t));\n    client->ipcs = c;\n    client->kind = CRM_CLIENT_IPC;\n    client->pid = crm_ipcs_client_pid(c);\n    client->id = crm_generate_uuid();\n    crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", c, uid_client, gid_client, client->pid, client->id);\n#if ENABLE_ACL\n    client->user = uid2username(uid_client);\n#endif\n    g_hash_table_insert(client_connections, c, client);\n    return client;\n}", "target": 1}
{"code": "static int lodepng_add32bitInt(ucvector* buffer, unsigned value)\n{\n  if (!ucvector_resize(buffer, buffer->size + 4)) return 0;\n  lodepng_set32bitInt(&buffer->data[buffer->size - 4], value);\n  return 1;\n}", "target": 0}
{"code": "static int handle_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tskip_emulated_instruction(vcpu);\n\tkvm_emulate_wbinvd(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "static int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\nretry:\n\thandle = ext4_journal_start(inode, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tflags |= AOP_FLAG_NOFS;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\text4_journal_stop(handle);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t*pagep = page;\n\tret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\text4_get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\nout:\n\treturn ret;\n}", "target": 1}
{"code": " */\nint re_yyget_lineno  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    return yylineno;", "target": 1}
{"code": "Opal::Call::get_start_time () const\n{\n  return start_time.GetTimeInSeconds ();\n}", "target": 0}
{"code": "bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n{\n  bgp_notify_send (peer, \n\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t   BGP_NOTIFY_OPEN_AUTH_FAILURE); \n  return -1;\n}", "target": 1}
{"code": "WebContentsImpl::~WebContentsImpl() {\n  is_being_destroyed_ = true;\n  ClearAllPowerSaveBlockers();\n  for (std::set<RenderWidgetHostImpl*>::iterator iter =\n           created_widgets_.begin(); iter != created_widgets_.end(); ++iter) {\n    (*iter)->DetachDelegate();\n  }\n  created_widgets_.clear();\n  if (dialog_manager_)\n    dialog_manager_->WebContentsDestroyed(this);\n  if (color_chooser_)\n    color_chooser_->End();\n  NotifyDisconnected();\n  NotificationService::current()->Notify(\n      NOTIFICATION_WEB_CONTENTS_DESTROYED,\n      Source<WebContents>(this),\n      NotificationService::NoDetails());\n#if defined(OS_WIN) && !defined(USE_AURA)\n  if (view_->GetNativeView()) {\n    RenderViewHost* host = GetRenderViewHost();\n    if (host && host->GetView())\n      RenderWidgetHostViewPort::FromRWHV(host->GetView())->WillWmDestroy();\n  }\n#endif\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    WebContentsImplDestroyed());\n  SetDelegate(NULL);\n  STLDeleteContainerPairSecondPointers(destruction_observers_.begin(),\n                                       destruction_observers_.end());\n}", "target": 0}
{"code": "static inline int r_sys_mkdirp(char *dir) {\n\tint ret = 1;\n\tconst char slash = DIRSEP;\n\tchar *path = dir;\n\tchar *ptr = path;\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __SDB_WINDOWS__\n\tchar *p = strstr (ptr, \":\\\\\");\n\tif (p) {\n\t\tptr = p + 2;\n\t}\n#endif\n\twhile ((ptr = strchr (ptr, slash))) {\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\t*ptr = slash;\n\t\t\treturn 0;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::OnTouchEvent(ui::TouchEvent* event) {\n  TRACE_EVENT0(\"input\", \"RenderWidgetHostViewAura::OnTouchEvent\");\n  if (touch_editing_client_ && touch_editing_client_->HandleInputEvent(event))\n    return;\n  blink::WebTouchPoint* point = UpdateWebTouchEventFromUIEvent(*event,\n                                                                &touch_event_);\n  if (host_->ShouldForwardTouchEvent())\n    event->StopPropagation();\n  if (point) {\n    if (host_->ShouldForwardTouchEvent())\n      host_->ForwardTouchEventWithLatencyInfo(touch_event_, *event->latency());\n    UpdateWebTouchEventAfterDispatch(&touch_event_, point);\n  }\n}", "target": 0}
{"code": "static int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n     endp++;\n   memmove(line, endp, strlen(endp) + 1);\n   for (i = 0; i < ctx->msgcount; i++)\n     if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n       break;\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n  return 0;\n}", "target": 1}
{"code": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\t*pos = '\\0'; \n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}", "target": 1}
{"code": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n \t\t\t\t\t  const struct flowi6 *fl6)\n {\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n \tif (!dst)\n \t\tgoto out;\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\nout:\n\treturn dst;\n}", "target": 1}
{"code": "bool DefaultCertValidator::matchSubjectAltName(\n    X509* cert,\n    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n        subject_alt_name_matchers) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return false;\n  }\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    const std::string san = Utility::generalNameAsString(general_name);\n    for (auto& config_san_matcher : subject_alt_name_matchers) {\n      if (general_name->type == GEN_DNS &&\n                  config_san_matcher.matcher().match_pattern_case() ==\n                      envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact\n              ? Utility::dnsNameMatch(config_san_matcher.matcher().exact(), absl::string_view(san))\n              : config_san_matcher.match(san)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "rdp_process_general_caps(STREAM s)\n{\n\tuint16 pad2octetsB;\t\n\tin_uint8s(s, 10);\n\tin_uint16_le(s, pad2octetsB);\n\tif (!pad2octetsB)\n\t\tg_rdp_version = RDP_V4;\n}", "target": 0}
{"code": "CreateMultiStringPopUp (\n  IN  UINTN                       RequestedWidth,\n  IN  UINTN                       NumberOfLines,\n  ...\n  )\n{\n  VA_LIST Marker;\n  VA_START (Marker, NumberOfLines);\n  CreateSharedPopUp (RequestedWidth, NumberOfLines, Marker);\n  VA_END (Marker);\n}", "target": 0}
{"code": "loader_init_callback (lt_dlhandle handle)\n{\n  lt_get_vtable *vtable_func = (lt_get_vtable *) lt_dlsym (handle, \"get_vtable\");\n  return loader_init (vtable_func, 0);\n}", "target": 0}
{"code": "static void naludmx_update_nalu_maxsize(GF_NALUDmxCtx *ctx, u32 size)\n{\n\tif (ctx->max_nalu_size < size) {\n\t\tctx->max_nalu_size = size;\n\t\tif (size > ctx->max_nalu_size_allowed) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] nal size %d larger than max allowed size %d - change import settings\\n\", ctx->log_name, size, ctx->max_nalu_size_allowed ));\n\t\t}\n\t}\n}", "target": 0}
{"code": "void GfxPath::append(GfxPath *path)\n{\n    int i;\n    if (n + path->n > size) {\n        size = n + path->n;\n        subpaths = (GfxSubpath **)greallocn(subpaths, size, sizeof(GfxSubpath *));\n    }\n    for (i = 0; i < path->n; ++i) {\n        subpaths[n++] = path->subpaths[i]->copy();\n    }\n    justMoved = false;\n}", "target": 0}
{"code": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n    u32in();\n    u32in();\n    mp4config.frame.ents = u32in();\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n        mp4config.frame.data[cnt + 1] = ofs;\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n    return size;\n}", "target": 1}
{"code": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "virStoragePoolObjBuildTempFilePath(virStoragePoolObj *obj,\n                                   virStorageVolDef *voldef)\n{\n    virStoragePoolDef *def = virStoragePoolObjGetDef(obj);\n    return g_strdup_printf(\"%s/%s.%s.secret.XXXXXX\", driver->stateDir,\n                           def->name, voldef->name);\n}", "target": 0}
{"code": "MenuCacheNotifyId menu_cache_add_reload_notify(MenuCache* cache, MenuCacheReloadNotify func, gpointer user_data)\n{\n    GSList* l = g_slist_alloc();\n    CacheReloadNotifier* n = g_slice_new(CacheReloadNotifier);\n    gboolean is_first;\n    n->func = func;\n    n->user_data = user_data;\n    l->data = n;\n    MENU_CACHE_LOCK;\n    is_first = (cache->root_dir == NULL && cache->notifiers == NULL);\n    cache->notifiers = g_slist_concat( cache->notifiers, l );\n    if(is_first && cache->reload_id == 0)\n        cache->reload_id = g_idle_add_full(G_PRIORITY_HIGH_IDLE,\n                                           menu_cache_reload_idle,\n                                           menu_cache_ref(cache),\n                                           (GDestroyNotify)menu_cache_unref);\n    MENU_CACHE_UNLOCK;\n    return (MenuCacheNotifyId)l;\n}", "target": 0}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "static inline int imgCoordMungeUpper(SplashCoord x) {\n  return splashCeil(x + 0.5) - 1;\n}", "target": 0}
{"code": "acl_fetch_proto_http(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                     const struct arg *args, struct sample *smp)\n{\n\tCHECK_HTTP_MESSAGE_FIRST_PERM();\n\tsmp->type = SMP_T_BOOL;\n\tsmp->data.uint = 1;\n\treturn 1;\n}", "target": 0}
{"code": "void handle_get_plugin_schema(nng_aio *aio)\n{\n    size_t      len                        = 0;\n    char *      schema_path                = NULL;\n    char        param[NEU_PLUGIN_NAME_LEN] = { 0 };\n    const char *schema_name                = param;\n    NEU_VALIDATE_JWT(aio);\n    int rv = neu_http_get_param_str(aio, \"schema_name\", param, sizeof(param));\n    if (-2 == rv) {\n        rv = neu_http_get_param_str(aio, \"plugin_name\", param, sizeof(param));\n        schema_name = plugin_name_to_schema_name(param);\n    }\n    if (rv < 0) {\n        neu_http_bad_request(aio, \"{\\\"error\\\": 1002}\");\n        return;\n    }\n    if (0 > neu_asprintf(&schema_path, \"%s/schema/%s.json\", g_plugin_dir,\n                         schema_name)) {\n        NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n            neu_http_response(aio, error_code.error, result_error);\n        });\n        return;\n    }\n    char *buf = NULL;\n    buf = file_string_read(&len, schema_path);\n    if (NULL == buf) {\n        free(schema_path);\n        if (0 > neu_asprintf(&schema_path, \"%s/custom/schema/%s.json\",\n                             g_plugin_dir, schema_name)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n    }\n    if (NULL == buf) {\n        free(schema_path);\n        if (0 > neu_asprintf(&schema_path, \"%s/system/schema/%s.json\",\n                             g_plugin_dir, schema_name)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n    }\n    if (NULL == buf) {\n        nlog_info(\"open %s error: %d\", schema_path, errno);\n        neu_http_not_found(aio, \"{\\\"status\\\": \\\"error\\\"}\");\n        free(schema_path);\n        return;\n    }\n    neu_http_ok(aio, buf);\n    free(buf);\n    free(schema_path);\n}", "target": 1}
{"code": "\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\tif (edit && !edit->dead_leaf) {\n\t\tkey_payload_reserve(keyring,\n\t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}", "target": 1}
{"code": "static int php_jpg_get16(void *value)\n{\n\treturn (((uchar *)value)[0] << 8) | ((uchar *)value)[1];\n}", "target": 0}
{"code": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "static PyObject *convert_slist(struct curl_slist *slist, int free_flags)\n{\n    PyObject *ret = NULL;\n    struct curl_slist *slist_start = slist;\n    ret = PyList_New((Py_ssize_t)0);\n    if (ret == NULL) goto error;\n    for ( ; slist != NULL; slist = slist->next) {\n        PyObject *v = NULL;\n        if (slist->data == NULL) {\n            v = Py_None; Py_INCREF(v);\n        } else {\n            v = PyText_FromString(slist->data);\n        }\n        if (v == NULL || PyList_Append(ret, v) != 0) {\n            Py_XDECREF(v);\n            goto error;\n        }\n        Py_DECREF(v);\n    }\n    if ((free_flags & 1) && slist_start)\n        curl_slist_free_all(slist_start);\n    return ret;\nerror:\n    Py_XDECREF(ret);\n    if ((free_flags & 2) && slist_start)\n        curl_slist_free_all(slist_start);\n    return NULL;\n}", "target": 0}
{"code": "int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n\tstruct scsi_device *SDev;\n\tstruct scsi_sense_hdr sshdr;\n\tint result, err = 0, retries = 0;\n\tSDev = cd->device;\n      retry:\n\tif (!scsi_block_when_processing_errors(SDev)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen,\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n\t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n\tif (driver_byte(result) != 0) {\n\t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n      out:\n\tcgc->stat = err;\n\treturn err;\n}", "target": 1}
{"code": "    long TimeValue::toLong(long ) const\n    {\n        long result = (time_.hour - time_.tzHour) * 60 * 60;\n        result += (time_.minute - time_.tzMinute) * 60;\n        result += time_.second;\n        if (result < 0) {\n            result += 86400;\n        }\n        ok_ = true;\n        return result;\n    }", "target": 0}
{"code": "getFileTypeNoFollowSymlinks(const StaticString &filename) {\n\tstruct stat buf;\n\tint ret;\n\tret = lstat(filename.c_str(), &buf);\n\tif (ret == 0) {\n\t\tif (S_ISREG(buf.st_mode)) {\n\t\t\treturn FT_REGULAR;\n\t\t} else if (S_ISDIR(buf.st_mode)) {\n\t\t\treturn FT_DIRECTORY;\n\t\t} else if (S_ISLNK(buf.st_mode)) {\n\t\t\treturn FT_SYMLINK;\n\t\t} else {\n\t\t\treturn FT_OTHER;\n\t\t}\n\t} else {\n\t\tif (errno == ENOENT) {\n\t\t\treturn FT_NONEXISTANT;\n\t\t} else {\n\t\t\tint e = errno;\n\t\t\tstring message(\"Cannot lstat '\");\n\t\t\tmessage.append(filename);\n\t\t\tmessage.append(\"'\");\n\t\t\tthrow FileSystemException(message, e, filename);\n\t\t}\n\t}\n}", "target": 1}
{"code": "kg_seal(minor_status, context_handle, conf_req_flag, qop_req,\n        input_message_buffer, conf_state, output_message_buffer, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    int conf_req_flag;\n    gss_qop_t qop_req;\n    gss_buffer_t input_message_buffer;\n    int *conf_state;\n    gss_buffer_t output_message_buffer;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    output_message_buffer->length = 0;\n    output_message_buffer->value = NULL;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32) G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto)\n    {\n    case 0:\n        code = make_seal_token_v1(context, ctx->enc, ctx->seq,\n                                  &ctx->seq_send, ctx->initiate,\n                                  input_message_buffer, output_message_buffer,\n                                  ctx->signalg, ctx->cksum_size, ctx->sealalg,\n                                  conf_req_flag, toktype, ctx->mech_used);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3(context, ctx,\n                                              input_message_buffer,\n                                              output_message_buffer,\n                                              conf_req_flag, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;   \n        break;\n    }\n    if (code) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return(GSS_S_FAILURE);\n    }\n    if (conf_state)\n        *conf_state = conf_req_flag;\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}", "target": 1}
{"code": "void __init files_init(unsigned long mempages)\n{ \n\tunsigned long n;\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n\tfiles_defer_init();\n\tlg_lock_init(&files_lglock, \"files_lglock\");\n\tpercpu_counter_init(&nr_files, 0);\n} ", "target": 1}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t       unsigned long err)\n{\n    int level = 0;\n    int len = 0; \n    ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    level++;\n    if (err == SSL_ERROR_SSL) {\n\terr = ERR_get_error();\n\tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    }\n    ssock->last_err = err;\n    return GET_STATUS_FROM_SSL_ERR(err);\n}", "target": 1}
{"code": "int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)\n\t{\n\tconst u_char* data_start = data;\n\tif ( len <= 0 )\n\t\treturn 0;\n\tfor ( ; len > 0; --len, ++data )\n\t\t{\n\t\tif ( offset >= buf_len )\n\t\t\tInitBuffer(buf_len * 2);\n\t\tint c = data[0];\n#define EMIT_LINE \\\n\t{ \\\n\tbuf[offset] = '\\0'; \\\n\tint seq_len = data + 1 - data_start; \\\n\tseq_delivered_in_lines = seq + seq_len; \\\n\tlast_char = c; \\\n\tForwardStream(offset, buf, IsOrig()); \\\n\toffset = 0; \\\n\treturn seq_len; \\\n\t}\n\t\tswitch ( c ) {\n\t\tcase '\\r':\n\t\t\tif ( len > 1 && data[1] == '\\n' )\n\t\t\t\t{\n\t\t\t\t--len; ++data;\n\t\t\t\tlast_char = c;\n\t\t\t\tc = data[0];\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & CR_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\tif ( last_char == '\\r' )\n\t\t\t\t{\n\t\t\t\t--offset; \n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & LF_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )\n\t\t\t\t\tConn()->Weird(\"line_terminated_with_single_LF\");\n\t\t\t\tbuf[offset++] = c;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tif ( flag_NULs )\n\t\t\t\tCheckNUL();\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\t}\n\t\tif ( last_char == '\\r' )\n\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )\n\t\t\t\tConn()->Weird(\"line_terminated_with_single_CR\");\n\t\tlast_char = c;\n\t\t}\n\treturn data - data_start;\n\t}", "target": 1}
{"code": "static char *get_pid_environ_val(pid_t pid,char *val){\n  char temp[500];\n  int i=0;\n  int foundit=0;\n  FILE *fp;\n  sprintf(temp,\"/proc/%d/environ\",pid);\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n  for(;;){\n    temp[i]=fgetc(fp);    \n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }\n    switch(temp[i]){\n    case EOF:\n      fclose(fp);\n      return NULL;\n    case '=':\n      temp[i]=0;\n      if(!strcmp(temp,val)){\n\tfoundit=1;\n      }\n      i=0;\n      break;\n    case '\\0':\n      i=0;\n      break;\n    default:\n      i++;\n    }\n  }\n}", "target": 1}
{"code": "TEST(HeaderDataConstructorTest, RegexMatchSpecifier) {\n  const std::string yaml = R\"EOF(\nname: test-header\nregex_match: value\n  )EOF\";\n  HeaderUtility::HeaderData header_data =\n      HeaderUtility::HeaderData(parseHeaderMatcherFromYaml(yaml));\n  EXPECT_EQ(\"test-header\", header_data.name_.get());\n  EXPECT_EQ(HeaderUtility::HeaderMatchType::Regex, header_data.header_match_type_);\n  EXPECT_EQ(\"\", header_data.value_);\n}", "target": 0}
{"code": "static int dump_seek(struct file *file, loff_t off)\n{\n\tif (file->f_op->llseek) {\n\t\tif (file->f_op->llseek(file, off, SEEK_SET) != off)\n\t\t\treturn 0;\n\t} else {\n\t\tfile->f_pos = off;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "void __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tdl_se->dl_runtime = 0;\n\tdl_se->dl_deadline = 0;\n\tdl_se->dl_period = 0;\n\tdl_se->flags = 0;\n\tdl_se->dl_bw = 0;\n\tdl_se->dl_throttled = 0;\n\tdl_se->dl_yielded = 0;\n}", "target": 0}
{"code": "local block_state deflate_rle(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n    uInt prev;              \n    Bytef *scan, *strend;   \n    for (;;) {\n        if (s->lookahead <= MAX_MATCH) {\n            fill_window(s);\n            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; \n        }\n        s->match_length = 0;\n        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {\n            scan = s->window + s->strstart - 1;\n            prev = *scan;\n            if (prev == *++scan && prev == *++scan && prev == *++scan) {\n                strend = s->window + s->strstart + MAX_MATCH;\n                do {\n                } while (prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         scan < strend);\n                s->match_length = MAX_MATCH - (uInt)(strend - scan);\n                if (s->match_length > s->lookahead)\n                    s->match_length = s->lookahead;\n            }\n            Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->strstart - 1, s->match_length);\n            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);\n            s->lookahead -= s->match_length;\n            s->strstart += s->match_length;\n            s->match_length = 0;\n        } else {\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit (s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "WifiNetwork::WifiNetwork(const ServiceInfo* service)\n    : WirelessNetwork(service) {\n  encryption_ = service->security;\n  passphrase_ = SafeString(service->passphrase);\n  identity_ = SafeString(service->identity);\n  cert_path_ = SafeString(service->cert_path);\n  type_ = TYPE_WIFI;\n}", "target": 0}
{"code": "Opal::Call::Call (OpalManager& _manager,\n\t\t  Ekiga::ServiceCore& _core,\n\t\t  const std::string& uri)\n  : OpalCall (_manager), Ekiga::Call (), core (_core), remote_uri (uri),\n    call_setup(false), jitter(0), outgoing(false)\n{\n  notification_core = core.get<Ekiga::NotificationCore> (\"notification-core\");\n  re_a_bytes = tr_a_bytes = re_v_bytes = tr_v_bytes = 0.0;\n  last_v_tick = last_a_tick = PTime ();\n  total_a =\n    total_v =\n    lost_a =\n    too_late_a =\n    out_of_order_a =\n    lost_v =\n    too_late_v =\n    out_of_order_v = 0;\n  lost_packets = late_packets = out_of_order_packets = 0.0;\n  re_a_bw = tr_a_bw = re_v_bw = tr_v_bw = 0.0;\n  NoAnswerTimer.SetNotifier (PCREATE_NOTIFIER (OnNoAnswerTimeout));\n}", "target": 0}
{"code": " static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n {\n \t++vcpu->stat.insn_emulation_fail;\n \ttrace_kvm_emulate_insn_failed(vcpu);\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\tvcpu->run->internal.ndata = 0;\n \tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn EMULATE_FAIL;\n }", "target": 1}
{"code": "g_markup_parse_context_new (const GMarkupParser *parser,\n                            GMarkupParseFlags    flags,\n                            gpointer             user_data,\n                            GDestroyNotify       user_data_dnotify)\n{\n  GMarkupParseContext *context;\n  g_return_val_if_fail (parser != NULL, NULL);\n  context = g_new (GMarkupParseContext, 1);\n  context->ref_count = 1;\n  context->parser = parser;\n  context->flags = flags;\n  context->user_data = user_data;\n  context->dnotify = user_data_dnotify;\n  context->line_number = 1;\n  context->char_number = 1;\n  context->partial_chunk = NULL;\n  context->spare_chunks = NULL;\n  context->spare_list_nodes = NULL;\n  context->state = STATE_START;\n  context->tag_stack = NULL;\n  context->tag_stack_gstr = NULL;\n  context->attr_names = NULL;\n  context->attr_values = NULL;\n  context->cur_attr = -1;\n  context->alloc_attrs = 0;\n  context->current_text = NULL;\n  context->current_text_len = -1;\n  context->current_text_end = NULL;\n  context->start = NULL;\n  context->iter = NULL;\n  context->document_empty = TRUE;\n  context->parsing = FALSE;\n  context->awaiting_pop = FALSE;\n  context->subparser_stack = NULL;\n  context->subparser_element = NULL;\n  context->held_user_data = NULL;\n  context->balance = 0;\n  return context;\n}", "target": 0}
{"code": "blkid_loff_t blkid_parttable_get_offset(blkid_parttable tab)\n{\n\treturn (blkid_loff_t)tab->offset;\n}", "target": 0}
{"code": "reallocWrapper (void *address, size_t size)\n{\n  if (!(address = realloc (address, size)) && size)\n    outOfMemory ();\n  return address;\n}", "target": 0}
{"code": " void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n {\n \tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n \tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n\tif (p->mm) {\n\t\tstats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE / KB;\n \t}\n \tstats->read_char\t= p->rchar;\n \tstats->write_char\t= p->wchar;\n\tstats->read_syscalls\t= p->syscr;\n\tstats->write_syscalls\t= p->syscw;\n}", "target": 1}
{"code": "bool Item_cache_row::null_inside()\n{\n  for (uint i= 0; i < item_count; i++)\n  {\n    if (values[i]->cols() > 1)\n    {\n      if (values[i]->null_inside())\n\treturn 1;\n    }\n    else\n    {\n      values[i]->update_null_value();\n      if (values[i]->null_value)\n\treturn 1;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "void ChangeListLoader::LoadDirectoryIfNeededAfterGetEntry(\n    const base::FilePath& directory_path,\n    const FileOperationCallback& callback,\n    bool should_try_loading_parent,\n    const ResourceEntry* entry,\n    FileError error) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!callback.is_null());\n  if (error == FILE_ERROR_NOT_FOUND &&\n      should_try_loading_parent &&\n      util::GetDriveGrandRootPath().IsParent(directory_path)) {\n    LoadDirectoryIfNeeded(\n        directory_path.DirName(),\n        base::Bind(&ChangeListLoader::LoadDirectoryIfNeededAfterLoadParent,\n                   weak_ptr_factory_.GetWeakPtr(),\n                   directory_path,\n                   callback));\n    return;\n  }\n  if (error != FILE_ERROR_OK) {\n    callback.Run(error);\n    return;\n  }\n  if (!entry->file_info().is_directory()) {\n    callback.Run(FILE_ERROR_NOT_A_DIRECTORY);\n    return;\n  }\n  if (entry->local_id() == util::kDriveOtherDirLocalId) {\n    callback.Run(FILE_ERROR_OK);\n    return;\n  }\n  Load(DirectoryFetchInfo(entry->local_id(),\n                          entry->resource_id(),\n                          entry->directory_specific_info().changestamp()),\n       callback);\n}", "target": 0}
{"code": " static void copyIPv6IfDifferent(void * dest, const void * src)\n {\n\tif(dest != src) {\n \t\tmemcpy(dest, src, sizeof(struct in6_addr));\n \t}\n }", "target": 1}
{"code": "int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n\tif (flags & ~(MSG_DONTWAIT | MSG_PEEK))\n\t\treturn -EOPNOTSUPP;\n\tvcc = ATM_SD(sock);\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags))\n\t\treturn 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);\n\tif (!skb)\n\t\treturn error;\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terror = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (error)\n\t\treturn error;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\tif (!(flags & MSG_PEEK)) {\n\t\tpr_debug(\"%d -= %d\\n\", atomic_read(&sk->sk_rmem_alloc),\n\t\t\t skb->truesize);\n\t\tatm_return(vcc, skb->truesize);\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}", "target": 1}
{"code": "static int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    MOVFragmentIndex* index = NULL;\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    void *tmp;\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index) {\n        return AVERROR(ENOMEM);\n    }\n    tmp = av_realloc_array(mov->fragment_index_data,\n                           mov->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n    mov->fragment_index_data = tmp;\n    mov->fragment_index_data[mov->fragment_index_count++] = index;\n    version = avio_r8(f);\n    avio_rb24(f);\n    index->track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    index->item_count = avio_rb32(f);\n    index->items = av_mallocz_array(\n            index->item_count, sizeof(MOVFragmentIndexItem));\n    if (!index->items) {\n        index->item_count = 0;\n        return AVERROR(ENOMEM);\n     }\n     for (i = 0; i < index->item_count; i++) {\n         int64_t time, offset;\n         if (version == 1) {\n             time   = avio_rb64(f);\n             offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n        index->items[i].time = time;\n        index->items[i].moof_offset = offset;\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}", "target": 1}
{"code": "GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "con_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) {\n\t\t\tkfree(p1);\n\t\t\tp->uni_pgdir[n] = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); \n\t}\n\tp2[unicode & 0x3f] = fontpos;\n\tp->sum += (fontpos << 20) + unicode;\n\treturn 0;\n}", "target": 1}
{"code": "uint16_t read16(uint8_t* arr, int pos,  int swapBytes)\n{\n    uint8_t b1 = arr[pos];\n    uint8_t b2 = arr[pos+1];\n    return (swapBytes) ?  ((b2 << 8) | b1) : ((b1 << 8) | b2);\n}", "target": 0}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "DynamicsCompressorNode* BaseAudioContext::createDynamicsCompressor(\n    ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  return DynamicsCompressorNode::Create(*this, exception_state);\n}", "target": 0}
{"code": "static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);\n    unsigned int rxbase = s->rxbuf * (0x800 / 4);\n    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))\n        return size;\n    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {\n        D(qemu_log(\"ethlite lost packet %x\\n\", s->regs[R_RX_CTRL0]));\n        return -1;\n     }\n     D(qemu_log(\"%s %zd rxbase=%x\\n\", __func__, size, rxbase));\n     memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);\n     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;\n    s->rxbuf ^= s->c_rx_pingpong;\n    return size;\n}", "target": 1}
{"code": "static ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\tbuf[buf_size - 1] = '\\0';\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\tseq = file->private_data;\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\treturn nbytes;\n}", "target": 1}
{"code": "MagickExport void DestroyImageProperties(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties != (void *) NULL)\n    image->properties=(void *) DestroySplayTree((SplayTreeInfo *)\n      image->properties);\n}", "target": 0}
{"code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}", "target": 1}
{"code": "TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,\n                                       TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);\n  if (input->type != kTfLiteUInt8) return kTfLiteError;\n  if (NumElements(input->dims) == 0) return kTfLiteError;\n  TF_LITE_ENSURE_STATUS(context->RequestScratchBufferInArena(\n      context, sizeof(uint8_t) * NumElements(input->dims),\n      &data->sorting_buffer));\n  data->invoke_count = reinterpret_cast<int*>(\n      context->AllocatePersistentBuffer(context, sizeof(int)));\n  *data->invoke_count = 0;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep) {\n\t\tdev_err(&sdev->udev->dev, \"no such endpoint?, %d\\n\",\n\t\t\tepnum);\n\t\tBUG();\n\t}\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\tdev_err(&sdev->udev->dev, \"get pipe, epnum %d\\n\", epnum);\n\treturn 0;\n}", "target": 1}
{"code": "bool initialise_control(rzip_control *control)\n{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; \n\tsize_t len;\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = \".lrz\";\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\tcontrol->threads = PROCESSORS;\t\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\tif (unlikely((now_t = time(NULL)) == ((time_t)-1)))\n\t\tfatal_return((\"Failed to call time in main\\n\"), false);\n\tif (unlikely(now_t < T_ZERO)) {\n\t\tprint_output(\"Warning your time reads before the year 2011, check your system clock\\n\");\n\t\tnow_t = T_ZERO;\n\t}\n\ttdiff = (now_t - T_ZERO) / 4;\n\tnow_t = T_ZERO + tdiff;\n\tcontrol->secs = now_t;\n\tcontrol->encloops = nloops(control->secs, control->salt, control->salt + 1);\n\tif (unlikely(!get_rand(control, control->salt + 2, 6)))\n\t\treturn false;\n\teptr = getenv(\"TMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TMP\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMP\");\n\tif (!eptr)\n\t\teptr = localeptr;\n\tlen = strlen(eptr);\n\tcontrol->tmpdir = malloc(len + 2);\n\tif (control->tmpdir == NULL)\n\t\tfatal_return((\"Failed to allocate for tmpdir\\n\"), false);\n\tstrcpy(control->tmpdir, eptr);\n\tif (control->tmpdir[len - 1] != '/') {\n\t\tcontrol->tmpdir[len] = '/'; \n\t\tcontrol->tmpdir[len + 1] = '\\0';\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 2;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tint l2 = 33 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc/%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc/%s/%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}", "target": 1}
{"code": "bool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            if (sTarget.Equals(\"status\")) {\n                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n        if (!GetIRCSock()) {\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n    return true;\n}", "target": 1}
{"code": "TIFFjpeg_set_quality(JPEGState* sp, int quality, boolean force_baseline)\n{\n\treturn CALLVJPEG(sp,\n\t    jpeg_set_quality(&sp->cinfo.c, quality, force_baseline));\n}", "target": 0}
{"code": "static void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)\n{\n\trcu_read_lock_bh();\n\tif (likely(ifp->idev->dead == 0))\n\t\t__ipv6_ifa_notify(event, ifp);\n\trcu_read_unlock_bh();\n}", "target": 0}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev, RBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tif (!buf || !buf_end || buf > buf_end) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (RBinDwarfDie));\n\t}\n\tfor (i = 0; i < abbrev->count && i < die->capacity; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\tconst ut8 *nbuf = parse_attr_value (buf, buf_end - buf,\n\t\t\t&abbrev->defs[i],\n\t\t\t&die->attr_values[i],\n\t\t\thdr, debug_str, debug_str_len);\n\t\tif (nbuf) {\n\t\t\tbuf = nbuf;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tbool is_string = (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string);\n\t\tbool is_valid_string_form = is_string && attribute->string.content;\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n \t}\n \tn = xmalloc(len);\n \tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n \tfor (p = path; p; p = p->up) {\n \t\tif (p->elem_len) {\n \t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}", "target": 1}
{"code": "static int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\treturn -ENOPROTOOPT;\n}", "target": 0}
{"code": "void HTMLTextAreaElement::accessKeyAction(bool)\n{\n    focus();\n}", "target": 0}
{"code": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n \tstruct mm_struct *mm = file->private_data;\n \tunsigned long env_start, env_end;\n\tif (!mm)\n \t\treturn 0;\n \tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\t\tthis_len = env_end - (env_start + src);\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\t\tretval = access_remote_vm(mm, (env_start + src),\n\t\t\tpage, this_len, 0);\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}", "target": 1}
{"code": "xface2xpm(char *xface)\n{\n    Image image;\n    ImageCache *cache;\n    FILE *f;\n    struct stat st;\n    SKIP_BLANKS(xface);\n    image.url = xface;\n    image.ext = \".xpm\";\n    image.width = 48;\n    image.height = 48;\n    image.cache = NULL;\n    cache = getImage(&image, NULL, IMG_FLAG_AUTO);\n    if (cache->loaded & IMG_FLAG_LOADED && !stat(cache->file, &st))\n\treturn cache->file;\n    cache->loaded = IMG_FLAG_ERROR;\n    f = popen(Sprintf(\"%s > %s\", shell_quote(auxbinFile(XFACE2XPM)),\n\t\t      shell_quote(cache->file))->ptr, \"w\");\n    if (!f)\n\treturn NULL;\n    fputs(xface, f);\n    pclose(f);\n    if (stat(cache->file, &st) || !st.st_size)\n\treturn NULL;\n    cache->loaded = IMG_FLAG_LOADED | IMG_FLAG_DONT_REMOVE;\n    cache->index = 0;\n    return cache->file;\n}", "target": 0}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\\n\";\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tresult = current_dir + filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\\n\";\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\\n\";\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\\n\";\n\treturn result;\n}", "target": 1}
{"code": "xps_load_sfnt_name(xps_font_t *font, char *namep)\n{\n    byte *namedata;\n    int offset, length;\n    int count, stringoffset;\n    int found;\n    int i, k;\n    found = 0;\n    strcpy(namep, \"Unknown\");\n    offset = xps_find_sfnt_table(font, \"name\", &length);\n    if (offset < 0 || length < 6)\n    {\n        gs_warn(\"cannot find name table\");\n         return;\n     }\n     namedata = font->data + offset;\n     count = u16(namedata + 2);\n     stringoffset = u16(namedata + 4);\n     if (length < 6 + (count * 12))\n     {\n         gs_warn(\"name table too short\");\n        {\n            if (pid == 1 && eid == 0 && langid == 0) \n            {\n                if (found < 3)\n                {\n                    memcpy(namep, namedata + stringoffset + offset, length);\n                    namep[length] = 0;\n                    found = 3;\n                }\n            }\n            if (pid == 3 && eid == 1 && langid == 0x409) \n            {\n                if (found < 2)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 2;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u16(s + k * 2);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 2;\n                }\n            }\n            if (pid == 3 && eid == 10 && langid == 0x409) \n            {\n                if (found < 1)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 4;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u32(s + k * 4);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 1;\n                }\n            }\n        }\n    }\n}", "target": 1}
{"code": "Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr,\n                                const XlaPlatformInfo& platform_info,\n                                XlaCompilationCache** cache) {\n  if (platform_info.xla_device_metadata()) {\n    *cache = new XlaCompilationCache(\n        platform_info.xla_device_metadata()->client(),\n        platform_info.xla_device_metadata()->jit_device_type());\n    return Status::OK();\n  }\n  auto platform =\n      se::MultiPlatformManager::PlatformWithId(platform_info.platform_id());\n  if (!platform.ok()) {\n    return platform.status();\n  }\n  StatusOr<xla::Compiler*> compiler_for_platform =\n      xla::Compiler::GetForPlatform(platform.ValueOrDie());\n  if (!compiler_for_platform.ok()) {\n    const Status& status = compiler_for_platform.status();\n    if (status.code() == error::NOT_FOUND) {\n      return errors::Unimplemented(\"Could not find compiler for platform \",\n                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());\n  }\n  *cache = new XlaCompilationCache(\n      client.ValueOrDie(), DeviceType(registration->compilation_device_name));\n  return Status::OK();\n}", "target": 1}
{"code": "static inline void *freelist_dereference(const struct kmem_cache *s,\n\t\t\t\t\t void *ptr_addr)\n{\n\treturn freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr),\n\t\t\t    (unsigned long)ptr_addr);\n}", "target": 0}
{"code": "ospf_auth_type (struct ospf_interface *oi)\n{\n  int auth_type;\n  if (OSPF_IF_PARAM (oi, auth_type) == OSPF_AUTH_NOTSET)\n    auth_type = oi->area->auth_type;\n  else\n    auth_type = OSPF_IF_PARAM (oi, auth_type);\n  if (auth_type == OSPF_AUTH_CRYPTOGRAPHIC &&\n      list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))\n    return OSPF_AUTH_NULL;\n  return auth_type;\n}", "target": 0}
{"code": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n    avio_rl64(pb);            \n    avio_rl64(pb);            \n     count = avio_rl32(pb);    \n     avio_rl16(pb);            \n     name_len = avio_rl16(pb); \n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); \n     for (i = 0; i < count; i++) {\n         int64_t pres_time;\n         int name_len;\n         avio_rl64(pb);             \n         pres_time = avio_rl64(pb); \n         pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             \n        avio_rl32(pb);             \n        avio_rl32(pb);             \n        name_len = avio_rl32(pb);  \n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n    return 0;\n}", "target": 1}
{"code": "translate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace(*s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}", "target": 1}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 1}
{"code": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 1}
{"code": "int dtls1_process_buffered_records(SSL *s)\n {\n     pitem *item;\n     SSL3_BUFFER *rb;\n     item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);\n     if (item) {\n         if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)\n            return (1);         \n         rb = RECORD_LAYER_get_rbuf(&s->rlayer);\n             */\n            return 1;\n        }\n        while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n            dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n            if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n         while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n             dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n             if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <\n                0)\n                return -1;\n         }\n     }\n *             here, anything else is handled by higher layers\n *     Application data protocol\n *             none of our business\n */\n     s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;\n     s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;\n    return (1);\n }", "target": 1}
{"code": "void *memslot_get_virt(RedMemSlotInfo *info, QXLPHYSICAL addr, uint32_t add_size,\n                       int group_id)\n{\n    int slot_id;\n    int generation;\n    unsigned long h_virt;\n    MemSlot *slot;\n    if (group_id > info->num_memslots_groups) {\n        spice_critical(\"group_id too big\");\n        return NULL;\n    }\n    slot_id = memslot_get_id(info, addr);\n    if (slot_id > info->num_memslots) {\n        print_memslots(info);\n        spice_critical(\"slot_id %d too big, addr=%\" PRIx64, slot_id, addr);\n        return NULL;\n    }\n    slot = &info->mem_slots[group_id][slot_id];\n    generation = memslot_get_generation(info, addr);\n    if (generation != slot->generation) {\n        print_memslots(info);\n        spice_critical(\"address generation is not valid, group_id %d, slot_id %d, \"\n                       \"gen %d, slot_gen %d\",\n                       group_id, slot_id,\n                       generation, slot->generation);\n        return NULL;\n    }\n    h_virt = __get_clean_virt(info, addr);\n    h_virt += slot->address_delta;\n    if (!memslot_validate_virt(info, h_virt, slot_id, add_size, group_id)) {\n        return NULL;\n    }\n    return (void*)(uintptr_t)h_virt;\n}", "target": 1}
{"code": "static int jsR_hasproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.a.length);\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.s.length);\n\t\t\treturn 1;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k)) {\n\t\t\tif (k >= 0 && k < obj->u.s.length) {\n\t\t\t\tjs_pushrune(J, js_runeat(J, obj->u.s.string, k));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) {\n\t\t\tjs_pushliteral(J, obj->u.r.source);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"global\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_G);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"ignoreCase\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_I);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"multiline\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_M);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tjs_pushnumber(J, obj->u.r.last);\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.has && obj->u.user.has(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\tref = jsV_getproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->getter) {\n\t\t\tjs_pushobject(J, ref->getter);\n\t\t\tjs_pushobject(J, obj);\n\t\t\tjs_call(J, 0);\n\t\t} else {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline void http1_consume_data(intptr_t uuid, http1pr_s *p) {\n  if (fio_pending(uuid) > 4) {\n    goto throttle;\n  }\n  ssize_t i = 0;\n  size_t org_len = p->buf_len;\n  int pipeline_limit = 8;\n  if (!p->buf_len)\n    return;\n  do {\n    i = http1_fio_parser(.parser = &p->parser,\n                         .buffer = p->buf + (org_len - p->buf_len),\n                         .length = p->buf_len, .on_request = http1_on_request,\n                         .on_response = http1_on_response,\n                         .on_method = http1_on_method,\n                         .on_status = http1_on_status, .on_path = http1_on_path,\n                         .on_query = http1_on_query,\n                         .on_http_version = http1_on_http_version,\n                         .on_header = http1_on_header,\n                         .on_body_chunk = http1_on_body_chunk,\n                         .on_error = http1_on_error);\n    p->buf_len -= i;\n    --pipeline_limit;\n  } while (i && p->buf_len && pipeline_limit && !p->stop);\n  if (p->buf_len && org_len != p->buf_len) {\n    memmove(p->buf, p->buf + (org_len - p->buf_len), p->buf_len);\n  }\n  if (p->buf_len == HTTP_MAX_HEADER_LENGTH) {\n    if (p->request.method)\n      http_send_error(&p->request, 413);\n    else {\n      p->request.method = fiobj_str_tmp();\n      http_send_error(&p->request, 413);\n    }\n  }\n  if (!pipeline_limit) {\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  return;\nthrottle:\n  fio_suspend(uuid);\n  p->stop |= 4;\n  FIO_LOG_DEBUG(\"(HTTP/1,1) throttling client at %.*s\",\n                (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n}", "target": 1}
{"code": "  Status SetUnknownShape(const NodeDef* node, int output_port) {\n    shape_inference::ShapeHandle shape =\n        GetUnknownOutputShape(node, output_port);\n    InferenceContext* ctx = GetContext(node);\n    if (ctx == nullptr) {\n      return errors::InvalidArgument(\"Missing context\");\n    }\n    ctx->set_output(output_port, shape);\n    return Status::OK();\n  }", "target": 1}
{"code": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\nskip_error:\n\twake_up(&desc->wait);\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}", "target": 1}
{"code": "void tcp_valid_rtt_meas(struct sock *sk, u32 seq_rtt)\n{\n\ttcp_rtt_estimator(sk, seq_rtt);\n\ttcp_set_rto(sk);\n\tinet_csk(sk)->icsk_backoff = 0;\n}", "target": 0}
{"code": "static void bdrv_mirror_top_refresh_filename(BlockDriverState *bs)\n{\n    if (bs->backing == NULL) {\n        return;\n    }\n    pstrcpy(bs->exact_filename, sizeof(bs->exact_filename),\n            bs->backing->bs->filename);\n}", "target": 0}
{"code": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n \t\tbb->failbb->prev = NULL;\n \t\tbb->failbb = NULL;\n \t}\n\tR_FREE (bb);\n }", "target": 1}
{"code": " static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n \t\t\t\t       int rw, char __user *buf,\n \t\t\t\t       unsigned long *nr_segs,\n \t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n {\n \tif (unlikely(!access_ok(!rw, buf, len)))\n \t\treturn -EFAULT;\n \tiovec->iov_base = buf;\n \tiovec->iov_len = len;\n \t*nr_segs = 1;\n \treturn 0;\n }", "target": 1}
{"code": "static ssize_t TIFFReadCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n  size_t\n    total;\n  ssize_t\n    remaining;\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  remaining=(MagickOffsetType) profile->length-profile->offset;\n  if (remaining <= 0)\n    return(-1);\n  total=MagickMin(count, (size_t) remaining);\n  (void) memcpy(data,profile->data->datum+profile->offset,total);\n  profile->offset+=total;\n  return(total);\n}", "target": 0}
{"code": "void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)\n{\n    int     i, id, dummy;\n    char   *buf, *c;\n    long    start, sz;\n    start = ftell(fp);\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))\n        {\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            while (SAFE_F(fp, (fgetc(fp) != 't')))\n                ; \n             sz = pdf->xrefs[i].end - ftell(fp);\n            buf = malloc(sz + 1);\n             SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");\n             buf[sz] = '\\0';\n             if (!(c = strstr(buf, \"/Root\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Root\") + 1);\n            free(buf);\n            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);\n            if (!buf || !(c = strstr(buf, \"/Pages\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Pages\") + 1);\n            load_kids(fp, id, &pdf->xrefs[i]);\n            free(buf); \n        }\n    }\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "monitor_allowed_key(u_char *blob, u_int bloblen)\n{\n\tif (key_blob == NULL || key_bloblen != bloblen ||\n\t    memcmp(key_blob, blob, key_bloblen))\n\t\treturn (0);\n\treturn (1);\n}", "target": 0}
{"code": "int FFmpegVideoDecoder::GetVideoBuffer(AVCodecContext* codec_context,\n                                       AVFrame* frame) {\n  VideoFrame::Format format = PixelFormatToVideoFormat(codec_context->pix_fmt);\n  if (format == VideoFrame::UNKNOWN)\n    return AVERROR(EINVAL);\n  DCHECK(format == VideoFrame::YV12 || format == VideoFrame::YV16 ||\n          format == VideoFrame::YV12J);\n   gfx::Size size(codec_context->width, codec_context->height);\n  int ret;\n  if ((ret = av_image_check_size(size.width(), size.height(), 0, NULL)) < 0)\n     return ret;\n   gfx::Size natural_size;\n  if (codec_context->sample_aspect_ratio.num > 0) {\n    natural_size = GetNaturalSize(size,\n                                  codec_context->sample_aspect_ratio.num,\n                                  codec_context->sample_aspect_ratio.den);\n  } else {\n     natural_size = config_.natural_size();\n   }\n  if (!VideoFrame::IsValidConfig(format, size, gfx::Rect(size), natural_size))\n     return AVERROR(EINVAL);\n  scoped_refptr<VideoFrame> video_frame =\n      frame_pool_.CreateFrame(format, size, gfx::Rect(size),\n                              natural_size, kNoTimestamp());\n   for (int i = 0; i < 3; i++) {\n     frame->base[i] = video_frame->data(i);\n    frame->data[i] = video_frame->data(i);\n    frame->linesize[i] = video_frame->stride(i);\n  }\n   frame->opaque = NULL;\n   video_frame.swap(reinterpret_cast<VideoFrame**>(&frame->opaque));\n   frame->type = FF_BUFFER_TYPE_USER;\n  frame->width = codec_context->width;\n  frame->height = codec_context->height;\n   frame->format = codec_context->pix_fmt;\n   return 0;\n}", "target": 1}
{"code": "    bool replaceHostInUri( std::string& uri, const char* szHost, const char* szPort ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            return false ;\n        }\n        url->url_host = szHost ;\n        url->url_port = szPort ;\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, 1, url, params, comment) ;\n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }", "target": 1}
{"code": "callbacks_revert_activate (GtkMenuItem *menuitem, gpointer user_data)\n{\n\tgerbv_revert_all_files (mainProject);\n\tselection_clear (&screen.selectionInfo);\n\tupdate_selected_object_message (FALSE);\n\trender_refresh_rendered_image_on_screen ();\n\tcallbacks_update_layer_tree ();\n}", "target": 0}
{"code": "static int dns_parse_callback(void *c, int rr, const void *data, int len, const void *packet)\n {\n \tchar tmp[256];\n \tstruct dpc_ctx *ctx = c;\n \tswitch (rr) {\n \tcase RR_A:\n \t\tif (len != 4) return -1;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 4);\n\t\tbreak;\n\tcase RR_AAAA:\n\t\tif (len != 16) return -1;\n\t\tctx->addrs[ctx->cnt].family = AF_INET6;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 16);\n\t\tbreak;\n\tcase RR_CNAME:\n\t\tif (__dn_expand(packet, (const unsigned char *)packet + 512,\n\t\t    data, tmp, sizeof tmp) > 0 && is_valid_hostname(tmp))\n\t\t\tstrcpy(ctx->canon, tmp);\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int rc4_hmac_md5_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                             void *ptr)\n{\n    EVP_RC4_HMAC_MD5 *key = data(ctx);\n    switch (type) {\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        {\n            unsigned int i;\n            unsigned char hmac_key[64];\n            memset(hmac_key, 0, sizeof(hmac_key));\n            if (arg > (int)sizeof(hmac_key)) {\n                MD5_Init(&key->head);\n                MD5_Update(&key->head, ptr, arg);\n                MD5_Final(hmac_key, &key->head);\n            } else {\n                memcpy(hmac_key, ptr, arg);\n            }\n            for (i = 0; i < sizeof(hmac_key); i++)\n                hmac_key[i] ^= 0x36; \n            MD5_Init(&key->head);\n            MD5_Update(&key->head, hmac_key, sizeof(hmac_key));\n            for (i = 0; i < sizeof(hmac_key); i++)\n                hmac_key[i] ^= 0x36 ^ 0x5c; \n            MD5_Init(&key->tail);\n            MD5_Update(&key->tail, hmac_key, sizeof(hmac_key));\n            OPENSSL_cleanse(hmac_key, sizeof(hmac_key));\n            return 1;\n        }\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        {\n            unsigned char *p = ptr;\n            unsigned int len;\n            if (arg != EVP_AEAD_TLS1_AAD_LEN)\n                return -1;\n            len = p[arg - 2] << 8 | p[arg - 1];\n            if (!EVP_CIPHER_CTX_encrypting(ctx)) {\n                len -= MD5_DIGEST_LENGTH;\n                p[arg - 2] = len >> 8;\n                p[arg - 1] = len;\n            }\n            key->payload_length = len;\n            key->md = key->head;\n            MD5_Update(&key->md, p, arg);\n            return MD5_DIGEST_LENGTH;\n        }\n    default:\n        return -1;\n    }\n}", "target": 1}
{"code": "xmlCreateMemoryParserCtxt(const char *buffer, int size) {\n    xmlParserCtxtPtr ctxt;\n    xmlParserInputPtr input;\n    xmlParserInputBufferPtr buf;\n    if (buffer == NULL)\n\treturn(NULL);\n    if (size <= 0)\n\treturn(NULL);\n    ctxt = xmlNewParserCtxt();\n    if (ctxt == NULL)\n\treturn(NULL);\n    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n    if (buf == NULL) {\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input = xmlNewInputStream(ctxt);\n    if (input == NULL) {\n\txmlFreeParserInputBuffer(buf);\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input->filename = NULL;\n    input->buf = buf;\n    xmlBufResetInput(input->buf->buffer, input);\n    inputPush(ctxt, input);\n    return(ctxt);\n}", "target": 0}
{"code": "static struct dmar_domain *find_domain(struct device *dev)\n{\n\tstruct device_domain_info *info;\n\tinfo = dev->archdata.iommu;\n\tif (likely(info))\n\t\treturn info->domain;\n\treturn NULL;\n}", "target": 0}
{"code": "static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "PHP_FUNCTION(xml_parse_into_struct)\n{\n\txml_parser *parser;\n\tzval *pind, **xdata, **info = NULL;\n\tchar *data;\n\tint data_len, ret;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rsZ|Z\", &pind, &data, &data_len, &xdata, &info) == FAILURE) {\n\t\treturn;\n\t}\n\tif (info) {\n\t\tzval_dtor(*info);\n\t\tarray_init(*info);\n\t}\n\tZEND_FETCH_RESOURCE(parser,xml_parser *, &pind, -1, \"XML Parser\", le_xml_parser);\n\tzval_dtor(*xdata);\n\tarray_init(*xdata);\n\tparser->data = *xdata;\n\tif (info) {\n\t\tparser->info = *info;\n\t}\n\tparser->level = 0;\n\tparser->ltags = safe_emalloc(XML_MAXLEVEL, sizeof(char *), 0);\n\tXML_SetDefaultHandler(parser->parser, _xml_defaultHandler);\n\tXML_SetElementHandler(parser->parser, _xml_startElementHandler, _xml_endElementHandler);\n\tXML_SetCharacterDataHandler(parser->parser, _xml_characterDataHandler);\n\tparser->isparsing = 1;\n\tret = XML_Parse(parser->parser, data, data_len, 1);\n\tparser->isparsing = 0;\n\tRETVAL_LONG(ret);\n}", "target": 0}
{"code": "void QuickOpen::Load(uint64 BlockPos)\n{\n  if (!Loaded) \n  {\n    SeekPos=Arc->Tell();\n    UnsyncSeekPos=false;\n    SaveFilePos SavePos(*Arc);\n    Arc->Seek(BlockPos,SEEK_SET);\n    if (Arc->ReadHeader()==0 || Arc->GetHeaderType()!=HEAD_SERVICE ||\n        !Arc->SubHead.CmpName(SUBHEAD_TYPE_QOPEN))\n      return;\n    QLHeaderPos=Arc->CurBlockPos;\n    RawDataStart=Arc->Tell();\n    RawDataSize=Arc->SubHead.UnpSize;\n    Loaded=true; \n  }\n  if (Arc->SubHead.Encrypted)\n  {\n    RAROptions *Cmd=Arc->GetRAROptions();\n#ifndef RAR_NOCRYPT\n    if (Cmd->Password.IsSet())\n      Crypt.SetCryptKeys(false,CRYPT_RAR50,&Cmd->Password,Arc->SubHead.Salt,\n                         Arc->SubHead.InitV,Arc->SubHead.Lg2Count,\n                         Arc->SubHead.HashKey,Arc->SubHead.PswCheck);\n    else\n#endif\n      return;\n  }\n  RawDataPos=0;\n  ReadBufSize=0;\n  ReadBufPos=0;\n  LastReadHeader.Reset();\n  LastReadHeaderPos=0;\n  ReadBuffer();\n}", "target": 1}
{"code": "std::shared_ptr<EC_Group_Data> EC_Group::BER_decode_EC_group(const uint8_t bits[], size_t len,\n                                                             EC_Group_Source source)\n   {\n   BER_Decoder ber(bits, len);\n   BER_Object obj = ber.get_next_object();\n   if(obj.type() == NULL_TAG)\n      {\n      throw Decoding_Error(\"Cannot handle ImplicitCA ECC parameters\");\n      }\n   else if(obj.type() == OBJECT_ID)\n      {\n      OID dom_par_oid;\n      BER_Decoder(bits, len).decode(dom_par_oid);\n      return ec_group_data().lookup(dom_par_oid);\n      }\n   else if(obj.type() == SEQUENCE)\n      {\n      BigInt p, a, b, order, cofactor;\n      std::vector<uint8_t> base_pt;\n      std::vector<uint8_t> seed;\n      BER_Decoder(bits, len)\n         .start_cons(SEQUENCE)\n           .decode_and_check<size_t>(1, \"Unknown ECC param version code\")\n           .start_cons(SEQUENCE)\n            .decode_and_check(OID(\"1.2.840.10045.1.1\"),\n                              \"Only prime ECC fields supported\")\n             .decode(p)\n           .end_cons()\n           .start_cons(SEQUENCE)\n             .decode_octet_string_bigint(a)\n             .decode_octet_string_bigint(b)\n             .decode_optional_string(seed, BIT_STRING, BIT_STRING)\n           .end_cons()\n           .decode(base_pt, OCTET_STRING)\n           .decode(order)\n           .decode(cofactor)\n         .end_cons()\n         .verify_end();\n      if(p.bits() < 64 || p.is_negative() || !is_bailie_psw_probable_prime(p))\n         throw Decoding_Error(\"Invalid ECC p parameter\");\n      if(a.is_negative() || a >= p)\n         throw Decoding_Error(\"Invalid ECC a parameter\");\n      if(b <= 0 || b >= p)\n         throw Decoding_Error(\"Invalid ECC b parameter\");\n      if(order <= 0 || !is_bailie_psw_probable_prime(order))\n         throw Decoding_Error(\"Invalid ECC order parameter\");\n      if(cofactor <= 0 || cofactor >= 16)\n         throw Decoding_Error(\"Invalid ECC cofactor parameter\");\n      std::pair<BigInt, BigInt> base_xy = Botan::OS2ECP(base_pt.data(), base_pt.size(), p, a, b);\n      return ec_group_data().lookup_or_create(p, a, b, base_xy.first, base_xy.second,\n                                              order, cofactor, OID(), source);\n      }\n   else\n      {\n      throw Decoding_Error(\"Unexpected tag while decoding ECC domain params\");\n      }\n   }", "target": 1}
{"code": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n \t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n \t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n \t\t\tregno, tn_buf);\n \t}\n \toff = regs[regno].off + regs[regno].var_off.value;\n \tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tif ((ctxt->rex_prefix & 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tbreak;\n\t}\n\tcs_sel |= SELECTOR_RPL_MASK;\n\tss_sel |= SELECTOR_RPL_MASK;\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tctxt->_eip = reg_read(ctxt, VCPU_REGS_RDX);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = reg_read(ctxt, VCPU_REGS_RCX);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\t*rcmd = NULL;\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n \t\treturn -ENOMEM;\n \t*rcmd = ptr;\n \tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n \tptr->next = NULL;\n \tptr->buffer_length = 0;\n \tparam += sizeof(struct floppy_raw_cmd);\n \tif (ptr->cmd_count > 33)\n\t\treturn -EINVAL;\n \tfor (i = 0; i < 16; i++)\n \t\tptr->reply[i] = 0;\n \tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n \tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n \t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "map_oplock_to_lease(u8 oplock)\n{\n\tif (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\treturn SMB2_LEASE_WRITE_CACHING_LE | SMB2_LEASE_READ_CACHING_LE;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_II)\n\t\treturn SMB2_LEASE_READ_CACHING_LE;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_BATCH)\n\t\treturn SMB2_LEASE_HANDLE_CACHING_LE | SMB2_LEASE_READ_CACHING_LE |\n\t\t       SMB2_LEASE_WRITE_CACHING_LE;\n\treturn 0;\n}", "target": 0}
{"code": "int FoFiTrueType::mapNameToGID(char *name) {\n  if (!nameToGID) {\n    return 0;\n  }\n  return nameToGID->lookupInt(name);\n}", "target": 0}
{"code": "decodenetnum(\n\tconst char *num,\n\tsockaddr_u *netnum\n\t)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint err;\n\tu_short port;\n\tconst char *cp;\n\tconst char *port_str;\n\tchar *pp;\n\tchar *np;\n\tchar name[80];\n\tREQUIRE(num != NULL);\n\tREQUIRE(strlen(num) < sizeof(name));\n\tport_str = NULL;\n\tif ('[' != num[0]) {\n\t\tpp = strchr(num, ':');\n\t\tif (NULL == pp)\n\t\t\tcp = num;\t\n\t\telse if (NULL != strchr(pp + 1, ':'))\n\t\t\tcp = num;\t\n\t\telse {\t\t\t\n\t\t\tstrlcpy(name, num, sizeof(name));\n\t\t\tcp = name;\n\t\t\tpp = strchr(cp, ':');\n\t\t\t*pp = '\\0';\n\t\t\tport_str = pp + 1;\n\t\t}\n\t} else {\n\t\tcp = num + 1;\n\t\tnp = name; \n\t\twhile (*cp && ']' != *cp)\n\t\t\t*np++ = *cp++;\n\t\t*np = 0;\n\t\tif (']' == cp[0] && ':' == cp[1] && '\\0' != cp[2])\n\t\t\tport_str = &cp[2];\n\t\tcp = name; \n\t}\n\tZERO(hints);\n\thints.ai_flags = Z_AI_NUMERICHOST;\n\terr = getaddrinfo(cp, \"ntp\", &hints, &ai);\n\tif (err != 0)\n\t\treturn 0;\n\tINSIST(ai->ai_addrlen <= sizeof(*netnum));\n\tZERO(*netnum);\n\tmemcpy(netnum, ai->ai_addr, ai->ai_addrlen);\n\tfreeaddrinfo(ai);\n\tif (NULL == port_str || 1 != sscanf(port_str, \"%hu\", &port))\n\t\tport = NTP_PORT;\n\tSET_PORT(netnum, port);\n\treturn 1;\n}", "target": 1}
{"code": "Bool gf_filter_send_gf_event(GF_Filter *filter, GF_Event *evt)\n{\n\treturn gf_filter_forward_gf_event(filter, evt, GF_FALSE, GF_FALSE);\n}", "target": 0}
{"code": "static int cg_rmdir(const char *path)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",\n\t\t\tcontroller, cgdir, path);\n\tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": " static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n \tut32 i = 0;\n \twhile (buf + i < max && buf[i] != eoc) {\n\t\ti += 1;\n \t}\n \tif (buf[i] != eoc) {\n \t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}", "target": 1}
{"code": "void ScanLineInputFile::initialize(const Header& header)\n{\n        _data->header = header;\n        _data->lineOrder = _data->header.lineOrder();\n        const Box2i &dataWindow = _data->header.dataWindow();\n        _data->minX = dataWindow.min.x;\n        _data->maxX = dataWindow.max.x;\n        _data->minY = dataWindow.min.y;\n        _data->maxY = dataWindow.max.y;\n        Compression comp = _data->header.compression();\n        _data->linesInBuffer =\n            numLinesInBuffer (comp);\n        int lineOffsetSize = (dataWindow.max.y - dataWindow.min.y +\n                              _data->linesInBuffer) / _data->linesInBuffer;\n        if (lineOffsetSize > gLargeChunkTableSize)\n        {\n            Int64 pos = _streamData->is->tellg();\n            _streamData->is->seekg(pos + (lineOffsetSize-1)*sizeof(Int64));\n            Int64 temp;\n            OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*_streamData->is, temp);\n            _streamData->is->seekg(pos);\n        }\n        size_t maxBytesPerLine = bytesPerLineTable (_data->header,\n                                                    _data->bytesPerLine);\n        if (maxBytesPerLine*numLinesInBuffer(comp) > INT_MAX)\n        {\n            throw IEX_NAMESPACE::InputExc(\"maximum bytes per scanline exceeds maximum permissible size\");\n        }\n        for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n        {\n            _data->lineBuffers[i] = new LineBuffer (newCompressor(comp,\n                                                 maxBytesPerLine,\n                                                 _data->header));\n        }\n        _data->lineBufferSize = maxBytesPerLine * _data->linesInBuffer;\n        if (!_streamData->is->isMemoryMapped())\n        {\n            for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n            {\n                _data->lineBuffers[i]->buffer = (char *) EXRAllocAligned(_data->lineBufferSize*sizeof(char),16);\n                if (!_data->lineBuffers[i]->buffer)\n                {\n                    throw IEX_NAMESPACE::LogicExc(\"Failed to allocate memory for scanline buffers\");\n                }\n            }\n        }\n        _data->nextLineBufferMinY = _data->minY - 1;\n        offsetInLineBufferTable (_data->bytesPerLine,\n                                 _data->linesInBuffer,\n                                 _data->offsetInLineBuffer);\n        _data->lineOffsets.resize (lineOffsetSize);\n}", "target": 1}
{"code": "static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)\n{\n\tint L1, L2, L3;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\tL2 = emitjump(J, F, OP_TRY);\n\t\t{\n\t\t\tcstm(J, F, finallystm); \n\t\t\temit(J, F, OP_THROW); \n\t\t}\n\t\tlabel(J, F, L2);\n\t\tif (F->strict) {\n\t\t\tcheckfutureword(J, F, catchvar);\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitline(J, F, catchvar);\n \t\temitstring(J, F, OP_CATCH, catchvar->string);\n \t\tcstm(J, F, catchstm);\n \t\temit(J, F, OP_ENDCATCH);\n \t\tL3 = emitjump(J, F, OP_JUMP); \n \t}\n \tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L3);\n\tcstm(J, F, finallystm);\n}", "target": 1}
{"code": "bytesPerDeepLineTable (const Header &header,\n                       int minY, int maxY,\n                       const char* base,\n                       int xStride,\n                       int yStride,\n                       vector<size_t> &bytesPerLine)\n{\n    const Box2i &dataWindow = header.dataWindow();\n    const ChannelList &channels = header.channels();\n    for (ChannelList::ConstIterator c = channels.begin();\n         c != channels.end();\n         ++c)\n    {\n        const int ySampling = abs(c.channel().ySampling);\n        const int xSampling = abs(c.channel().xSampling);\n        const int pixelSize = pixelTypeSize (c.channel().type);\n        const int sampleMinY = roundToNextMultiple(minY, ySampling);\n        const int sampleMaxY = roundToPrevMultiple(maxY, ySampling);\n        const int sampleMinX = roundToNextMultiple(dataWindow.min.x, xSampling);\n        const int sampleMaxX = roundToPrevMultiple(dataWindow.max.x, xSampling);\n        for (int y = sampleMinY; y <= sampleMaxY; y+=ySampling)\n        {\n            int nBytes = 0;\n            for (int x = sampleMinX; x <= sampleMaxX; x += xSampling)\n            {\n                nBytes += pixelSize *\n                          sampleCount(base, xStride, yStride, x, y);\n            }\n            bytesPerLine[y - dataWindow.min.y] += nBytes;\n        }\n    }\n    size_t maxBytesPerLine = 0;\n    for (int y = minY; y <= maxY; ++y)\n        if (maxBytesPerLine < bytesPerLine[y - dataWindow.min.y])\n            maxBytesPerLine = bytesPerLine[y - dataWindow.min.y];\n    return maxBytesPerLine;\n}", "target": 1}
{"code": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\tsk_mem_reclaim(sk);\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}", "target": 1}
{"code": "static long vsock_dev_ioctl(struct file *filp,\n\t\t\t    unsigned int cmd, unsigned long arg)\n{\n\treturn vsock_dev_do_ioctl(filp, cmd, (void __user *)arg);\n}", "target": 0}
{"code": "pixBlockconv(PIX     *pix,\n             l_int32  wc,\n             l_int32  hc)\n{\nl_int32  w, h, d;\nPIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\n    PROCNAME(\"pixBlockconv\");\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pix);\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\"pix has colormap; removing\\n\", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\"depth not 8 or 32 bpp\", procName, NULL);\n    }\n    if (d == 8) {\n        pixd = pixBlockconvGray(pixs, NULL, wc, hc);\n    } else { \n        pixr = pixGetRGBComponent(pixs, COLOR_RED);\n        pixrc = pixBlockconvGray(pixr, NULL, wc, hc);\n        pixDestroy(&pixr);\n        pixg = pixGetRGBComponent(pixs, COLOR_GREEN);\n        pixgc = pixBlockconvGray(pixg, NULL, wc, hc);\n        pixDestroy(&pixg);\n        pixb = pixGetRGBComponent(pixs, COLOR_BLUE);\n        pixbc = pixBlockconvGray(pixb, NULL, wc, hc);\n        pixDestroy(&pixb);\n        pixd = pixCreateRGBImage(pixrc, pixgc, pixbc);\n        pixDestroy(&pixrc);\n        pixDestroy(&pixgc);\n        pixDestroy(&pixbc);\n    }\n    pixDestroy(&pixs);\n    return pixd;\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    GradFunContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int p, direct;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        direct = 0;\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    for (p = 0; p < 4 && in->data[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;\n            h = s->chroma_h;\n            r = s->chroma_r;\n        }\n        if (FFMIN(w, h) > 2 * r)\n            filter(s, out->data[p], in->data[p], w, h, out->linesize[p], in->linesize[p], r);\n        else if (out->data[p] != in->data[p])\n            av_image_copy_plane(out->data[p], out->linesize[p], in->data[p], in->linesize[p], w, h);\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": " int snmp_version(void *context, size_t hdrlen, unsigned char tag,\n \t\t const void *data, size_t datalen)\n {\n \tif (*(unsigned char *)data > 1)\n \t\treturn -ENOTSUPP;\n \treturn 1;\n}", "target": 1}
{"code": "int kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static MXFPackage* mxf_resolve_source_package(MXFContext *mxf, UID package_uid)\n{\n    MXFPackage *package = NULL;\n    int i;\n    for (i = 0; i < mxf->packages_count; i++) {\n        package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], SourcePackage);\n        if (!package)\n            continue;\n        if (!memcmp(package->package_uid, package_uid, 16))\n            return package;\n    }\n    return NULL;\n}", "target": 0}
{"code": "static int restore_case_semantics(struct case_semantics_state *state)\n{\n\tstate->conn->case_sensitive = state->case_sensitive;\n\tstate->conn->case_preserve = state->case_preserve;\n\tstate->conn->short_case_preserve = state->short_case_preserve;\n\treturn 0;\n}", "target": 0}
{"code": "double Item_cache_str::val_real()\n{\n  DBUG_ASSERT(fixed == 1);\n  int err_not_used;\n  char *end_not_used;\n  if (!has_value())\n    return 0.0;\n  if (value)\n    return my_strntod(value->charset(), (char*) value->ptr(),\n\t\t      value->length(), &end_not_used, &err_not_used);\n  return (double) 0;\n}", "target": 0}
{"code": "GF_Err prhd_box_size(GF_Box *s)\n{\n\ts->size += 12;\n\treturn GF_OK;\n}", "target": 0}
{"code": "PHP_FUNCTION(cosh)\n{\n\tdouble num;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"d\", &num) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_DOUBLE(cosh(num));\n}", "target": 0}
{"code": "int fz_colorspace_is_lab_icc(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn fz_colorspace_is_lab(ctx, cs) && fz_colorspace_is_icc(ctx, cs);\n}", "target": 0}
{"code": " static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n\tstruct trusted_key_payload *p = key->payload.data[0];\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}", "target": 1}
{"code": "cache_record_length(JOIN *join,uint idx)\n{\n  uint length=0;\n  JOIN_TAB **pos,**end;\n  for (pos=join->best_ref+join->const_tables,end=join->best_ref+idx ;\n       pos != end ;\n       pos++)\n  {\n    JOIN_TAB *join_tab= *pos;\n    length+= join_tab->get_used_fieldlength();\n  }\n  return length;\n}", "target": 0}
{"code": "RenderLineBoxList* InlineFlowBox::rendererLineBoxes() const\n{\n    return toRenderInline(renderer())->lineBoxes();\n}", "target": 0}
{"code": "GF_Err st3d_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->stereo_type = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}", "target": 0}
{"code": "void HTMLMediaElement::WaitForSourceChange() {\n  BLINK_MEDIA_LOG << \"waitForSourceChange(\" << (void*)this << \")\";\n  StopPeriodicTimers();\n  load_state_ = kWaitingForSource;\n  SetNetworkState(kNetworkNoSource);\n  SetShouldDelayLoadEvent(false);\n  UpdateDisplayState();\n  if (GetLayoutObject())\n    GetLayoutObject()->UpdateFromElement();\n}", "target": 0}
{"code": "load_cu_tu_indexes (void *file)\n{\n  if (cu_tu_indexes_read == -1)\n    {\n      cu_tu_indexes_read = true;\n      if (load_debug_section_with_follow (dwp_cu_index, file))\n\tif (! process_cu_tu_index (&debug_displays [dwp_cu_index].section, 0))\n\t  cu_tu_indexes_read = false;\n      if (load_debug_section_with_follow (dwp_tu_index, file))\n\tif (! process_cu_tu_index (&debug_displays [dwp_tu_index].section, 0))\n\t  cu_tu_indexes_read = false;\n    }\n  return (bool) cu_tu_indexes_read;\n}", "target": 0}
{"code": "void RenderView::OnSetRendererPrefs(const RendererPreferences& renderer_prefs) {\n  renderer_preferences_ = renderer_prefs;\n  UpdateFontRenderingFromRendererPrefs();\n#if defined(TOOLKIT_GTK)\n  WebColorName name = WebKit::WebColorWebkitFocusRingColor;\n  WebKit::setNamedColors(&name, &renderer_prefs.focus_ring_color, 1);\n  WebKit::setCaretBlinkInterval(renderer_prefs.caret_blink_interval);\n  if (webview()) {\n    webview()->setScrollbarColors(\n        renderer_prefs.thumb_inactive_color,\n        renderer_prefs.thumb_active_color,\n        renderer_prefs.track_color);\n    webview()->setSelectionColors(\n        renderer_prefs.active_selection_bg_color,\n        renderer_prefs.active_selection_fg_color,\n        renderer_prefs.inactive_selection_bg_color,\n        renderer_prefs.inactive_selection_fg_color);\n    didInvalidateRect(gfx::Rect(size_));\n  }\n#endif\n}", "target": 0}
{"code": "int lg3ff_init(struct hid_device *hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tconst signed short *ff_bits = ff3_joystick_ac;\n\tint error;\n\tint i;\n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 35))\n\t\treturn -ENODEV;\n\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\tset_bit(ff_bits[i], dev->ffbit);\n\terror = input_ff_create_memless(dev, NULL, hid_lg3ff_play);\n\tif (error)\n\t\treturn error;\n\tif (test_bit(FF_AUTOCENTER, dev->ffbit))\n\t\tdev->ff->set_autocenter = hid_lg3ff_set_autocenter;\n\thid_info(hid, \"Force feedback for Logitech Flight System G940 by Gary Stein <LordCnidarian@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}", "target": 1}
{"code": "int jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}", "target": 1}
{"code": "void acpi_os_unmap_generic_address(struct acpi_generic_address *gas)\n{\n\tu64 addr;\n\tstruct acpi_ioremap *map;\n\tif (gas->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\treturn;\n\tmemcpy(&addr, &gas->address, sizeof(addr));\n\tif (!addr || !gas->bit_width)\n\t\treturn;\n\tmutex_lock(&acpi_ioremap_lock);\n\tmap = acpi_map_lookup(addr, gas->bit_width / 8);\n\tif (!map) {\n\t\tmutex_unlock(&acpi_ioremap_lock);\n\t\treturn;\n\t}\n\tacpi_os_drop_map_ref(map);\n\tmutex_unlock(&acpi_ioremap_lock);\n\tacpi_os_map_cleanup(map);\n}", "target": 0}
{"code": "void fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_work(&delayed_fput_work);\n\t}\n}", "target": 1}
{"code": "main_get_appheader (xd3_stream *stream, main_file *ifile,\n\t\t    main_file *output, main_file *sfile)\n{\n  uint8_t *apphead;\n  usize_t appheadsz;\n  int ret;\n  if (! option_use_appheader) { return; }\n  ret = xd3_get_appheader (stream, & apphead, & appheadsz);\n  if (ret != 0) { return; }\n  if (appheadsz > 0)\n    {\n      char *start = (char*)apphead;\n      char *slash;\n      int   place = 0;\n      char *parsed[4];\n      memset (parsed, 0, sizeof (parsed));\n      while ((slash = strchr (start, '/')) != NULL)\n\t{\n\t  *slash = 0;\n\t  parsed[place++] = start;\n\t  start = slash + 1;\n\t}\n      parsed[place++] = start;\n      if (place == 2 || place == 4)\n\t{\n\t  main_get_appheader_params (output, parsed, 1, \"output\", ifile);\n\t}\n      if (place == 4)\n\t{\n\t  main_get_appheader_params (sfile, parsed+2, 0, \"source\", ifile);\n\t}\n    }\n  option_use_appheader = 0;\n  return;\n}", "target": 1}
{"code": "onig_get_regex_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->regex;\n}", "target": 0}
{"code": "int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT16(s, fields->Len); \n\tStream_Read_UINT16(s, fields->MaxLen); \n\tStream_Read_UINT32(s, fields->BufferOffset); \n\treturn 1;\n}", "target": 1}
{"code": "bool EditorClientBlackBerry::doTextFieldCommandFromEvent(Element*, KeyboardEvent*)\n{\n    notImplemented();\n    return false;\n}", "target": 0}
{"code": "void OmniboxViewWin::OnKeyUp(TCHAR key,\n                             UINT repeat_count,\n                             UINT flags) {\n  if (key == VK_CONTROL)\n    model_->OnControlKeyChanged(false);\n  if (!(flags & KF_ALTDOWN) &&\n      (((key == VK_CONTROL) && (GetKeyState(VK_SHIFT) < 0)) ||\n       ((key == VK_SHIFT) && (GetKeyState(VK_CONTROL) < 0)))) {\n    ScopedFreeze freeze(this, GetTextObjectModel());\n    string16 saved_text(GetText());\n    CHARRANGE saved_sel;\n    GetSelection(saved_sel);\n    SetWindowText(L\"\");\n    DefWindowProc(WM_KEYUP, key, MAKELPARAM(repeat_count, flags));\n    SetWindowText(saved_text.c_str());\n    SetSelectionRange(saved_sel);\n    return;\n  }\n  SetMsgHandled(false);\n}", "target": 0}
{"code": "static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n \tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n \t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n \t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (((int)arg >= cdi->capacity))\n \t\treturn -EINVAL;\n \treturn cdrom_slot_status(cdi, arg);\n }", "target": 1}
{"code": "static void construct_get_dest_keyring(struct key **_dest_keyring)\n {\n \tstruct request_key_auth *rka;\n \tconst struct cred *cred = current_cred();\n \tstruct key *dest_keyring = *_dest_keyring, *authkey;\n \tkenter(\"%p\", dest_keyring);\n\tif (dest_keyring) {\n \t\tkey_get(dest_keyring);\n \t} else {\n \t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n \t\t\t\t\tdest_keyring =\n \t\t\t\t\t\tkey_get(rka->dest_keyring);\n \t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n \t\tdefault:\n \t\t\tBUG();\n \t\t}\n \t}\n \t*_dest_keyring = dest_keyring;\n \tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n }", "target": 1}
{"code": "Locked_tables_list::unlock_locked_tables(THD *thd)\n{\n  DBUG_ASSERT(!thd->in_sub_stmt &&\n              !(thd->state_flags & Open_tables_state::BACKUPS_AVAIL));\n  if (thd->locked_tables_mode != LTM_LOCK_TABLES)\n    return;\n  for (TABLE_LIST *table_list= m_locked_tables;\n       table_list; table_list= table_list->next_global)\n  {\n    if (table_list->table)                    \n      table_list->table->pos_in_locked_tables= NULL;\n  }\n  thd->leave_locked_tables_mode();\n  TRANSACT_TRACKER(clear_trx_state(thd, TX_LOCKED_TABLES));\n  DBUG_ASSERT(thd->transaction.stmt.is_empty());\n  close_thread_tables(thd);\n  reset();\n}", "target": 0}
{"code": "ssize_t qemu_deliver_packet_iov(NetClientState *sender,\n                                unsigned flags,\n                                const struct iovec *iov,\n                                int iovcnt,\n                                void *opaque)\n{\n    NetClientState *nc = opaque;\n    size_t size = iov_size(iov, iovcnt);\n    int ret;\n    if (size > INT_MAX) {\n        return size;\n    }\n    if (nc->link_down) {\n        return size;\n    }\n    if (nc->receive_disabled) {\n        return 0;\n    }\n    if (nc->info->receive_iov && !(flags & QEMU_NET_PACKET_FLAG_RAW)) {\n        ret = nc->info->receive_iov(nc, iov, iovcnt);\n    } else {\n        ret = nc_sendv_compat(nc, iov, iovcnt, flags);\n    }\n    if (ret == 0) {\n        nc->receive_disabled = 1;\n    }\n    return ret;\n}", "target": 1}
{"code": "int blkid_probe_enable_partitions(blkid_probe pr, int enable)\n{\n\tpr->chains[BLKID_CHAIN_PARTS].enabled = enable;\n\treturn 0;\n}", "target": 0}
{"code": "krb5_pac_parse(krb5_context context,\n               const void *ptr,\n               size_t len,\n               krb5_pac *ppac)\n{\n    krb5_error_code ret;\n    size_t i;\n    const unsigned char *p = (const unsigned char *)ptr;\n    krb5_pac pac;\n    size_t header_len;\n    krb5_ui_4 cbuffers, version;\n    *ppac = NULL;\n    if (len < PACTYPE_LENGTH)\n        return ERANGE;\n    cbuffers = load_32_le(p);\n    p += 4;\n    version = load_32_le(p);\n    p += 4;\n    if (version != 0)\n        return EINVAL;\n    header_len = PACTYPE_LENGTH + (cbuffers * PAC_INFO_BUFFER_LENGTH);\n    if (len < header_len)\n        return ERANGE;\n    ret = krb5_pac_init(context, &pac);\n    if (ret != 0)\n        return ret;\n    pac->pac = (PACTYPE *)realloc(pac->pac,\n                                  sizeof(PACTYPE) + ((cbuffers - 1) * sizeof(PAC_INFO_BUFFER)));\n    if (pac->pac == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n    pac->pac->cBuffers = cbuffers;\n    pac->pac->Version = version;\n    for (i = 0; i < pac->pac->cBuffers; i++) {\n        PAC_INFO_BUFFER *buffer = &pac->pac->Buffers[i];\n        buffer->ulType = load_32_le(p);\n        p += 4;\n        buffer->cbBufferSize = load_32_le(p);\n        p += 4;\n        buffer->Offset = load_64_le(p);\n        p += 8;\n        if (buffer->Offset % PAC_ALIGNMENT) {\n            krb5_pac_free(context, pac);\n            return EINVAL;\n        }\n        if (buffer->Offset < header_len ||\n            buffer->Offset + buffer->cbBufferSize > len) {\n            krb5_pac_free(context, pac);\n            return ERANGE;\n        }\n    }\n    pac->data.data = realloc(pac->data.data, len);\n    if (pac->data.data == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n    memcpy(pac->data.data, ptr, len);\n    pac->data.length = len;\n    *ppac = pac;\n    return 0;\n}", "target": 1}
{"code": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n \t\tgoto err;\n \t}\n\tlen = file ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\t*data_len = r;\n\tok = 1;\nerr:\n\tsc_file_free(file);\n\treturn ok;\n}", "target": 1}
{"code": "*/\nPHP_FUNCTION(timezone_name_from_abbr)\n{\n\tchar    *abbr;\n\tchar    *tzid;\n\tint      abbr_len;\n\tlong     gmtoffset = -1;\n\tlong     isdst = -1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ll\", &abbr, &abbr_len, &gmtoffset, &isdst) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\ttzid = timelib_timezone_id_from_abbr(abbr, gmtoffset, isdst);\n\tif (tzid) {\n\t\tRETURN_STRING(tzid, 1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 0}
{"code": " unsigned char *base64decode(const char *buf, size_t *size)\n {\n \tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n \tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n \tconst char *ptr = buf;\n \tint p = 0;\n\tsize_t l = 0;\n \tdo {\n\t\tptr += strspn(ptr, \"\\r\\n\\t \");\n \t\tif (*ptr == '\\0' || ptr >= buf+len) {\n \t\t\tbreak;\n \t\t}\n\t\tl = strcspn(ptr, \"\\r\\n\\t \");\n\t\tif (l > 3 && ptr+l <= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n \t\t}\n \t} while (1);\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}", "target": 1}
{"code": "GF_Err fdsa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "void blk_mq_disable_hotplug(void)\n{\n\tmutex_lock(&all_q_mutex);\n}", "target": 0}
{"code": " static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n\tunsigned int random_variable = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}", "target": 1}
{"code": "ZEND_API zend_bool ZEND_FASTCALL instanceof_function_ex(const zend_class_entry *instance_ce, const zend_class_entry *ce, zend_bool is_interface) \n{\n\tif (is_interface) {\n\t\tZEND_ASSERT(ce->ce_flags & ZEND_ACC_INTERFACE);\n\t\treturn instanceof_interface(instance_ce, ce);\n\t} else {\n\t\tZEND_ASSERT(!(ce->ce_flags & ZEND_ACC_INTERFACE));\n\t\treturn instanceof_class(instance_ce, ce);\n\t}\n}", "target": 0}
{"code": "int min_free_kbytes_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tint rc;\n\trc = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (rc)\n\t\treturn rc;\n\tif (write) {\n\t\tuser_min_free_kbytes = min_free_kbytes;\n\t\tsetup_per_zone_wmarks();\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int parse_sa_P_opt(char *argv[], int *opt, unsigned int *flags, struct activity *act[])\n{\n\tint p;\n\tp = get_activity_position(act, A_CPU, EXIT_IF_NOT_FOUND);\n\tif (argv[++(*opt)]) {\n\t\tif (parse_values(argv[*opt], act[p]->bitmap->b_array,\n\t\t\t     act[p]->bitmap->b_size, K_LOWERALL))\n\t\t\treturn 1;\n\t\t(*opt)++;\n\t\t*flags |= S_F_OPTION_P;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\tpn = ppp_pernet(net);\n \tpch->ppp = NULL;\n \tpch->chan = chan;\n\tpch->chan_net = net;\n \tchan->ppp = pch;\n \tinit_ppp_file(&pch->file, CHANNEL);\n \tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif \n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\treturn 0;\n}", "target": 1}
{"code": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n\tunsigned long inodes;\n\tint error = -EINVAL;\n\tif (shmem_parse_options(data, &config, true))\n\t\treturn error;\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n\tsbinfo->max_inodes  = config.max_inodes;\n\tsbinfo->free_inodes = config.max_inodes - inodes;\n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t\nout:\n\tspin_unlock(&sbinfo->stat_lock);\n\treturn error;\n}", "target": 1}
{"code": "    bool normalizeSipUri( std::string& uri, int brackets ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            return false ;\n        }\n        if( NULL == url->url_scheme && NULL == url->url_user && NULL != url->url_host ) {\n            url->url_scheme = \"sip\" ;\n            url->url_user = url->url_host ;\n            url->url_host = \"localhost\" ;   \n         }\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, brackets, url, params, comment) ;\n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }", "target": 1}
{"code": "is_code_ctype(OnigCodePoint code, unsigned int ctype, OnigEncoding enc ARG_UNUSED)\n{\n  if (code < 256)\n    return ENC_IS_ISO_8859_15_CTYPE(code, ctype);\n  else\n    return FALSE;\n}", "target": 0}
{"code": "static jas_image_cmpt_t *jas_image_cmpt_create(uint_fast32_t tlx, uint_fast32_t tly,\n  uint_fast32_t hstep, uint_fast32_t vstep, uint_fast32_t width, uint_fast32_t\n  height, uint_fast16_t depth, bool sgnd, uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tlong size;\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\treturn 0;\n\t}\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\tsize = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) : jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t\treturn 0;\n\t}\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t\treturn 0;\n\t}\n\treturn cmpt;\n}", "target": 1}
{"code": "static void spl_array_unset_property(zval *object, zval *member, const zend_literal *key TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tif ((intern->ar_flags & SPL_ARRAY_ARRAY_AS_PROPS) != 0\n\t&& !std_object_handlers.has_property(object, member, 2, key TSRMLS_CC)) {\n\t\tspl_array_unset_dimension(object, member TSRMLS_CC);\n\t\tspl_array_rewind(intern TSRMLS_CC); \n\t\treturn;\n\t}\n\tstd_object_handlers.unset_property(object, member, key TSRMLS_CC);\n} ", "target": 0}
{"code": "static inline void GetMaximumPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n  size_t\n    color,\n    maximum;\n  ssize_t\n    count;\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  maximum=p->nodes[color].next[0];\n  do\n  {\n    color=p->nodes[color].next[0];\n    if (color > maximum)\n      maximum=color;\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  *pixel=ScaleShortToQuantum((unsigned short) maximum);\n}", "target": 0}
{"code": "nosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct client *client = file->private_data;\n\tspinlock_t *client_list_lock = &client->lynx->client_list_lock;\n\tstruct nosy_stats stats;\n\tswitch (cmd) {\n\tcase NOSY_IOC_GET_STATS:\n\t\tspin_lock_irq(client_list_lock);\n\t\tstats.total_packet_count = client->buffer.total_packet_count;\n\t\tstats.lost_packet_count  = client->buffer.lost_packet_count;\n\t\tspin_unlock_irq(client_list_lock);\n\t\tif (copy_to_user((void __user *) arg, &stats, sizeof stats))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\treturn 0;\n\tcase NOSY_IOC_START:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_add_tail(&client->link, &client->lynx->client_list);\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tcase NOSY_IOC_STOP:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_del_init(&client->link);\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tcase NOSY_IOC_FILTER:\n\t\tspin_lock_irq(client_list_lock);\n\t\tclient->tcode_mask = arg;\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}", "target": 0}
{"code": "static void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\tvmx->nested.vmxon = false;\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tnested_free_all_saved_vmcss(vmx);\n}", "target": 0}
{"code": "static void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \"content-type\");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \"application/x-www-form-urlencoded\")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \"multipart/form-data\")) {\n    const char *boundary   = getFromHashMap(&contentType, \"boundary\");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \"--\")) != NULL) ||\n            (ptr = urlMemstr(part, len, \"\\r\\n--\")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \"\\r\\n\")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\"[http] Ignoring prologue before \\\"multipart/form-data\\\"!\");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \"--\\r\\n\")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\"[http] Ignoring epilogue past end of \\\"multipart/\"\n\t\t\t\t     \"form-data\\\"!\");\n              }\n            }\n          }\n        }\n      }\n      if (lastPart) {\n        warn(\"[http] Missing final \\\"boundary\\\" for \\\"multipart/form-data\\\"!\");\n      }\n    } else {\n      warn(\"[http] Missing \\\"boundary\\\" information for \\\"multipart/form-data\\\"!\");\n    }\n  }\n  destroyHashMap(&contentType);\n}", "target": 1}
{"code": "bool AudioContext::tryLock()\n{\n    ASSERT(isAudioThread());\n    if (!isAudioThread()) {\n        lock();\n        return true;\n    }\n    return m_contextGraphMutex.tryLock();\n}", "target": 0}
{"code": "int epo_fill_parallelogram(gx_device *dev, fixed px, fixed py, fixed ax, fixed ay, fixed bx, fixed by,\n    const gx_drawing_color *pdcolor, gs_logical_operation_t lop)\n{\n    int code = epo_handle_erase_page(dev);\n    if (code != 0)\n        return code;\n    return dev_proc(dev, fill_parallelogram)(dev, px, py, ax, ay, bx, by, pdcolor, lop);\n}", "target": 0}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !ap_cstr_casecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 1}
{"code": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\tassert (sizeof (sf_count_t) == 8) ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "void WasmBinaryWriter::writeSourceMapUrl() {\n  BYN_TRACE(\"== writeSourceMapUrl\\n\");\n  auto start = startSection(BinaryConsts::Section::User);\n  writeInlineString(BinaryConsts::UserSections::SourceMapUrl);\n  writeInlineString(sourceMapUrl.c_str());\n  finishSection(start);\n}", "target": 0}
{"code": "LibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR *sFile)\n    : LibRaw_buffer_datastream(NULL, 0), hMap_(0), pView_(NULL)\n{\n  HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING,\n                            FILE_ATTRIBUTE_NORMAL, 0);\n  if (hFile == INVALID_HANDLE_VALUE)\n    throw std::runtime_error(\"failed to open the file\");\n  try\n  {\n    Open(hFile);\n  }\n  catch (...)\n  {\n    CloseHandle(hFile);\n    throw;\n  }\n  CloseHandle(hFile); \n  reconstruct_base();\n}", "target": 0}
{"code": "static const char *fault_name(unsigned int esr)\n{\n\tconst struct fault_info *inf = fault_info + (esr & 63);\n\treturn inf->name;\n}", "target": 0}
{"code": "void ChangeListLoader::UpdateAboutResourceAfterGetAbout(\n    const google_apis::AboutResourceCallback& callback,\n    google_apis::GDataErrorCode status,\n    scoped_ptr<google_apis::AboutResource> about_resource) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!callback.is_null());\n  FileError error = GDataToFileError(status);\n  if (error == FILE_ERROR_OK) {\n    if (cached_about_resource_ &&\n        cached_about_resource_->largest_change_id() >\n        about_resource->largest_change_id()) {\n      LOG(WARNING) << \"Local cached about resource is fresher than server, \"\n                   << \"local = \" << cached_about_resource_->largest_change_id()\n                   << \", server = \" << about_resource->largest_change_id();\n    }\n    cached_about_resource_.reset(\n        new google_apis::AboutResource(*about_resource));\n  }\n  callback.Run(status, about_resource.Pass());\n}", "target": 0}
{"code": "static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                             const BYTE* exponent, int exponent_size, BYTE* output)\n{\n\tBN_CTX* ctx;\n\tint output_length = -1;\n\tBYTE* input_reverse;\n\tBYTE* modulus_reverse;\n\tBYTE* exponent_reverse;\n\tBIGNUM *mod, *exp, *x, *y;\n\tinput_reverse = (BYTE*)malloc(2 * key_length + exponent_size);\n\tif (!input_reverse)\n\t\treturn -1;\n\tmodulus_reverse = input_reverse + key_length;\n\texponent_reverse = modulus_reverse + key_length;\n\tmemcpy(modulus_reverse, modulus, key_length);\n\tcrypto_reverse(modulus_reverse, key_length);\n\tmemcpy(exponent_reverse, exponent, exponent_size);\n\tcrypto_reverse(exponent_reverse, exponent_size);\n\tmemcpy(input_reverse, input, length);\n\tcrypto_reverse(input_reverse, length);\n\tif (!(ctx = BN_CTX_new()))\n\t\tgoto fail_bn_ctx;\n\tif (!(mod = BN_new()))\n\t\tgoto fail_bn_mod;\n\tif (!(exp = BN_new()))\n\t\tgoto fail_bn_exp;\n\tif (!(x = BN_new()))\n\t\tgoto fail_bn_x;\n\tif (!(y = BN_new()))\n\t\tgoto fail_bn_y;\n\tBN_bin2bn(modulus_reverse, key_length, mod);\n\tBN_bin2bn(exponent_reverse, exponent_size, exp);\n\tBN_bin2bn(input_reverse, length, x);\n\tBN_mod_exp(y, x, exp, mod, ctx);\n\toutput_length = BN_bn2bin(y, output);\n\tcrypto_reverse(output, output_length);\n\tif (output_length < (int)key_length)\n\t\tmemset(output + output_length, 0, key_length - output_length);\n\tBN_free(y);\nfail_bn_y:\n\tBN_clear_free(x);\nfail_bn_x:\n\tBN_free(exp);\nfail_bn_exp:\n\tBN_free(mod);\nfail_bn_mod:\n\tBN_CTX_free(ctx);\nfail_bn_ctx:\n\tfree(input_reverse);\n\treturn output_length;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, NoSplitLimitedSortAsCommandBatchSize) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n    params.options |= QueryPlannerParams::SPLIT_LIMITED_SORT;\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    runQueryAsCommand(fromjson(\"{find: 'testns', filter: {a: 1}, sort: {b: 1}, batchSize: 3}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{fetch: {filter: {a: 1}, node: {ixscan: \"\n        \"{filter: null, pattern: {b: 1}}}}}\");\n    assertSolutionExists(\n        \"{sort: {pattern: {b: 1}, limit: 0, node: {sortKeyGen: {node: {fetch: {filter: null,\"\n        \"node: {ixscan: {pattern: {a: 1}}}}}}}}}\");\n}", "target": 0}
{"code": "AudioContext::AudioContext(Document* document)\n    : ActiveDOMObject(document)\n    , m_isStopScheduled(false)\n    , m_isCleared(false)\n    , m_isInitialized(false)\n    , m_destinationNode(nullptr)\n    , m_isResolvingResumePromises(false)\n    , m_automaticPullNodesNeedUpdating(false)\n    , m_connectionCount(0)\n    , m_didInitializeContextGraphMutex(false)\n    , m_audioThread(0)\n    , m_isOfflineContext(false)\n    , m_contextState(Suspended)\n    , m_cachedSampleFrame(0)\n{\n    m_didInitializeContextGraphMutex = true;\n    m_destinationNode = DefaultAudioDestinationNode::create(this);\n    initialize();\n#if DEBUG_AUDIONODE_REFERENCES\n    fprintf(stderr, \"%p: AudioContext::AudioContext() #%u\\n\", this, AudioContext::s_hardwareContextCount);\n#endif\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& image = context->input(0);\n    OP_REQUIRES(context, image.dims() == 3,\n                errors::InvalidArgument(\"image must be 3-dimensional\",\n                                        image.shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        FastBoundsCheck(image.NumElements(), std::numeric_limits<int32>::max()),\n        errors::InvalidArgument(\"image cannot have >= int32 max elements\"));\n    const int32 height = static_cast<int32>(image.dim_size(0));\n    const int32 width = static_cast<int32>(image.dim_size(1));\n    const int32 channels = static_cast<int32>(image.dim_size(2));\n    const int32 max_row_width = std::numeric_limits<int32>::max() / 2;\n    OP_REQUIRES(context, FastBoundsCheck(width * channels, max_row_width),\n                errors::InvalidArgument(\"image too wide to encode\"));\n    OP_REQUIRES(context, channels >= 1 && channels <= 4,\n                errors::InvalidArgument(\n                    \"image must have 1, 2, 3, or 4 channels, got \", channels));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({}), &output));\n    if (desired_channel_bits_ == 8) {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint8>().data(), width, height,\n                      width * channels, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    } else {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint16>().data(), width, height,\n                      width * channels * 2, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    }\n  }", "target": 1}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n \t    !(mnt_flags & MNT_READONLY)) {\n \t\treturn -EPERM;\n \t}\n \terr = security_sb_remount(sb, data);\n \tif (err)\n \t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 1}
{"code": "gdk_pixbuf__bmp_image_begin_load(GdkPixbufModuleSizeFunc size_func,\n                                 GdkPixbufModulePreparedFunc prepared_func,\n\t\t\t\t GdkPixbufModuleUpdatedFunc updated_func,\n                                 gpointer user_data,\n                                 GError **error)\n{\n\tstruct bmp_progressive_state *context;\n\tcontext = g_new0(struct bmp_progressive_state, 1);\n\tcontext->size_func = size_func;\n\tcontext->prepared_func = prepared_func;\n\tcontext->updated_func = updated_func;\n\tcontext->user_data = user_data;\n\tcontext->read_state = READ_STATE_HEADERS;\n\tcontext->BufferSize = 26;\n\tcontext->BufferPadding = 0;\n\tcontext->buff = g_malloc(26);\n\tcontext->BufferDone = 0;\n\tcontext->Colormap = NULL;\n\tcontext->Lines = 0;\n\tcontext->Type = 0;\n\tmemset(&context->Header, 0, sizeof(struct headerpair));\n\tmemset(&context->compr, 0, sizeof(struct bmp_compression_state));\n\tcontext->pixbuf = NULL;\n\treturn (gpointer) context;\n}", "target": 0}
{"code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n \t\t\tstruct oz_multiple_fixed *body =\n \t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n \t\t\tu8 *data = body->data;\n\t\t\tint n = (len - sizeof(struct oz_multiple_fixed)+1)\n \t\t\t\t/ body->unit_size;\n \t\t\twhile (n--) {\n \t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "static inline bool nested_cpu_has_eptp_switching(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has_vmfunc(vmcs12) &&\n\t\t(vmcs12->vm_function_control &\n\t\t VMX_VMFUNC_EPTP_SWITCHING);\n}", "target": 0}
{"code": "find_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}", "target": 1}
{"code": "static int http_open(URLContext *h, const char *uri, int flags,\n                     AVDictionary **options)\n{\n    HTTPContext *s = h->priv_data;\n    int ret;\n    if( s->seekable == 1 )\n        h->is_streamed = 0;\n    else\n        h->is_streamed = 1;\n    s->filesize = -1;\n    s->location = av_strdup(uri);\n    if (!s->location)\n        return AVERROR(ENOMEM);\n    if (options)\n        av_dict_copy(&s->chained_options, *options, 0);\n    if (s->headers) {\n        int len = strlen(s->headers);\n        if (len < 2 || strcmp(\"\\r\\n\", s->headers + len - 2)) {\n            av_log(h, AV_LOG_WARNING,\n                   \"No trailing CRLF found in HTTP header.\\n\");\n            ret = av_reallocp(&s->headers, len + 3);\n            if (ret < 0)\n                return ret;\n            s->headers[len]     = '\\r';\n            s->headers[len + 1] = '\\n';\n            s->headers[len + 2] = '\\0';\n        }\n    }\n    if (s->listen) {\n        return http_listen(h, uri, flags, options);\n    }\n    ret = http_open_cnx(h, options);\n    if (ret < 0)\n        av_dict_free(&s->chained_options);\n    return ret;\n}", "target": 1}
{"code": "    DataLocId CiffComponent::dataLocation(uint16_t tag)\n    {\n        switch (tag & 0xc000) {\n        case 0x0000: return valueData;\n        case 0x4000: return directoryData;\n        default: throw Error(kerCorruptedMetadata);\n        }\n    } ", "target": 0}
{"code": "static void edge_heartbeat_schedule(struct edgeport_serial *edge_serial)\n{\n\tif (!edge_serial->use_heartbeat)\n\t\treturn;\n\tschedule_delayed_work(&edge_serial->heartbeat_work,\n\t\t\tFW_HEARTBEAT_SECS * HZ);\n}", "target": 0}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "qedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "int lgff_init(struct hid_device* hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tconst signed short *ff_bits = ff_joystick;\n\tint error;\n\tint i;\n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))\n\t\treturn -ENODEV;\n\tfor (i = 0; i < ARRAY_SIZE(devices); i++) {\n\t\tif (dev->id.vendor == devices[i].idVendor &&\n\t\t    dev->id.product == devices[i].idProduct) {\n\t\t\tff_bits = devices[i].ff;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\tset_bit(ff_bits[i], dev->ffbit);\n\terror = input_ff_create_memless(dev, NULL, hid_lgff_play);\n\tif (error)\n\t\treturn error;\n\tif ( test_bit(FF_AUTOCENTER, dev->ffbit) )\n\t\tdev->ff->set_autocenter = hid_lgff_set_autocenter;\n\tpr_info(\"Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "int cap_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\tbool effective, has_cap = false;\n\tint ret;\n\teffective = false;\n\tret = get_file_caps(bprm, &effective, &has_cap);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!issecure(SECURE_NOROOT)) {\n\t\tif (has_cap && new->uid != 0 && new->euid == 0) {\n\t\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\t\tgoto skip;\n\t\t}\n\t\tif (new->euid == 0 || new->uid == 0) {\n\t\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t\t old->cap_inheritable);\n\t\t}\n\t\tif (new->euid == 0)\n\t\t\teffective = true;\n \t}\n skip:\n\tif ((new->euid != old->uid ||\n\t     new->egid != old->gid ||\n\t     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&\n\t    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {\n\t\tif (!capable(CAP_SETUID)) {\n\t\t\tnew->euid = new->uid;\n\t\t\tnew->egid = new->gid;\n\t\t}\n\t\tnew->cap_permitted = cap_intersect(new->cap_permitted,\n\t\t\t\t\t\t   old->cap_permitted);\n\t}\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\tif (effective)\n\t\tnew->cap_effective = new->cap_permitted;\n\telse\n\t\tcap_clear(new->cap_effective);\n\tbprm->cap_effective = effective;\n\tif (!cap_isclear(new->cap_effective)) {\n\t\tif (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||\n\t\t    new->euid != 0 || new->uid != 0 ||\n\t\t    issecure(SECURE_NOROOT)) {\n\t\t\tret = audit_log_bprm_fcaps(bprm, new, old);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\treturn 0;\n}", "target": 1}
